{"version":3,"file":"game.js","mappings":";;;;;;;;;;AACA;AACA;AACA;;AAEA,eAAe;;AAEf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC9KA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;AAC1B;;;;;;;;;;;ACjDA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAA4C;;AAEvD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,oDAAU;;AAEnC,OAAO,YAAY;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;AC3QA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,sCAAI;AACpC;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,EAKuB;AAC7B,CAAC;AACD,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mBAAmB,+BAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,+BAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA;AACA,UAAU,+BAAmB;AAC7B,eAAe,+BAAmB;AAClC,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA,iEAAiE,iBAAiB;AAClF;AACA,0DAA0D,aAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,+BAAmB;AAC7B,gCAAgC,+BAAmB;AACnD;AACA;AACA;AACA,WAAW,+BAAmB;AAC9B,kDAAkD,gCAAgC;AAClF,0EAA0E,+BAAmB,4BAA4B,oBAAoB;AAC7I;AACA;AACA;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA,oCAAoC,4BAA4B;AAChE,0CAA0C;AAC1C,WAAW,+BAAmB;AAC9B;AACA;AACA;AACA;AACA,UAAU,+BAAmB,kCAAkC;AAC/D;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA;AACA;AACA,iBAAiB,+BAAmB,CAAC,+BAAmB;AACxD,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,SAAS;AACxB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,gCAAgC,sBAAsB;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,MAAM;AACrB,kBAAkB;AAClB;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,kBAAkB;AAClB;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD,OAAO;AACzD;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAM;AACxC,yBAAyB,qBAAM;AAC/B;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY,IAAI,cAAc,IAAI,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,oCAAoC;AAC9D,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA,wBAAwB;;AAExB,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,UAAU;AACV,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,oBAAoB,qBAAqB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,gCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,kBAAkB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,WAAW,gCAAmB;;AAE9B;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,cAAc;AAC7B,gBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA,iDAAiD,gBAAgB;;AAEjE,wBAAwB,oBAAoB;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD,gBAAgB;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,cAAc;AAC7B,eAAe,SAAS;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA,oDAAoD,gBAAgB;;AAEpE,wBAAwB,oBAAoB;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mDAAmD,gBAAgB;;AAEnE;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,eAAe,SAAS;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,MAAM;AACrB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,YAAY;AAC3B,eAAe,SAAS;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA,wEAAwE,uBAAuB;AAC/F,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,wBAAwB,iCAAiC;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,cAAc;AAC9B;AACA;AACA;;AAEA,wBAAwB,iCAAiC;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,aAAa;AAC7B;AACA;AACA;;AAEA,wBAAwB,iCAAiC;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,eAAe,gCAAmB;AAClC,aAAa,gCAAmB;AAChC,eAAe,gCAAmB;AAClC,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,WAAW,gCAAmB;;AAE9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,wBAAwB,YAAY;AACpC,qBAAqB,YAAY;AACjC;AACA,+BAA+B,YAAY;AAC3C,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,0CAA0C;AAC1F;AACA,gDAAgD,wCAAwC;;AAExF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA,sDAAsD,uBAAuB;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY,IAAI,cAAc,IAAI,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;AAChC,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;AAChC,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,YAAY;AAC5B;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,cAAc,iCAAmB;;AAEjC;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;AAChC,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO,yDAAyD,YAAY;AAC3F,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,gCAAgC,YAAY;AAC5C;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,uBAAuB;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;;AAEA,gCAAgC,kBAAkB;AAClD;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,2BAA2B;AAC/D,wCAAwC,2BAA2B;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,uBAAuB;;AAEtE;AACA,qCAAqC,YAAY;;AAEjD;AACA,UAAU;AACV;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,oCAAoC;AACpC,kCAAkC;AAClC,yBAAyB;AACzB,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,UAAU,iCAAmB;AAC7B,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA,wBAAwB,4BAA4B;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,wBAAwB;AACrF;;AAEA,iEAAiE,wBAAwB;AACzF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,WAAW;AAC1B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;;AAEhC;;AAEA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,oBAAoB,QAAQ;AAC5B,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,+BAA+B;AACvD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET,wBAAwB,0BAA0B;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,qBAAqB,QAAQ;AAC7B,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,gBAAgB,iCAAmB;AACnC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,YAAY,iCAAmB;;AAE/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,+BAA+B,yBAAyB;;AAErH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mBAAmB;AACnB;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,WAAW;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA,oDAAoD,uBAAuB;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA,wCAAwC,0BAA0B;AAClE;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA,oDAAoD,uBAAuB;AAC3E;;AAEA;;AAEA,4BAA4B,0BAA0B;AACtD;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA,+CAA+C,kBAAkB;AACjE;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,mDAAmD,kBAAkB;AACrE;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;;AAEA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;;AAEA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,eAAe,iCAAmB;AAClC,eAAe,iCAAmB;AAClC,YAAY,iCAAmB;AAC/B,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;AAChC,gBAAgB,iCAAmB;AACnC,iBAAiB,iCAAmB;AACpC,aAAa,iCAAmB;AAChC,WAAW,iCAAmB;;AAE9B;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2DAA2D,gBAAgB;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,6BAA6B;;AAEpF;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;;AAEA;AACA;AACA,wDAAwD,8BAA8B;;AAEtF;AACA,qDAAqD,2BAA2B;;AAEhF;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,2CAA2C,qBAAqB;AAChE,+CAA+C,qBAAqB;AACpE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD,8BAA8B,iCAAmB;AACjD;AACA,cAAc,iCAAmB;AACjC,gBAAgB,iCAAmB;AACnC,cAAc,iCAAmB;AACjC,gBAAgB,iCAAmB;AACnC,gBAAgB,iCAAmB;AACnC,mBAAmB,iCAAmB;AACtC,oBAAoB,iCAAmB;AACvC,oBAAoB,iCAAmB;AACvC,iBAAiB,iCAAmB;AACpC,kBAAkB,iCAAmB;AACrC,gBAAgB,iCAAmB;AACnC,gBAAgB,iCAAmB;AACnC,cAAc,iCAAmB;AACjC,eAAe,iCAAmB;AAClC,yBAAyB,iCAAmB;AAC5C,cAAc,iCAAmB;AACjC,eAAe,iCAAmB;AAClC,gBAAgB,iCAAmB;AACnC,eAAe,iCAAmB;AAClC,gBAAgB,iCAAmB;AACnC,kBAAkB,iCAAmB;AACrC,gBAAgB,iCAAmB;AACnC,aAAa,iCAAmB;AAChC,kBAAkB,iCAAmB;AACrC,aAAa,iCAAmB;AAChC,gBAAgB,iCAAmB;AACnC,kBAAkB,iCAAmB;AACrC,eAAe,iCAAmB;AAClC;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,sBAAsB,KAAI,cAAc,CAAS;AACjD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,iCAAmB;AACnC,iBAAiB,iCAAmB;AACpC,aAAa,iCAAmB;AAChC,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;AAChC;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,WAAW;AAC3B;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,yCAAyC;;AAEpF;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAqD;AAC/E;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC,0BAA0B,eAAe;AACzC;AACA;AACA,qFAAqF,4BAA4B;AACjH;;AAEA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA,yFAAyF,4BAA4B;;AAErH;AACA;AACA,6FAA6F,4BAA4B;AACzH;;AAEA;AACA;AACA,6FAA6F,4BAA4B;AACzH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAkE;AAC7G;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA,+CAA+C,yBAAyB;;AAExE,wBAAwB,YAAY;AACpC;AACA;AACA,sBAAsB,8EAA8E;AACpG,iDAAiD,UAAU,wCAAwC,iBAAiB;;AAEpH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB,WAAW;AAC3B;AACA;AACA,0CAA0C,mBAAmB;AAC7D,4CAA4C,0BAA0B,gCAAgC;;AAEtG;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,eAAe,iCAAmB;AAClC,YAAY,iCAAmB;AAC/B,aAAa,iCAAmB;AAChC,eAAe,iCAAmB;AAClC,iBAAiB,iCAAmB;AACpC,gBAAgB,iCAAmB;AACnC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA,oEAAoE,uBAAuB;AAC3F;AACA;AACA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA,+EAA+E,0BAA0B;;AAEzG;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,6DAA6D,0BAA0B;AACvF;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,2DAA2D,cAAc;;AAEzE;AACA,2DAA2D,cAAc;;AAEzE;AACA,yDAAyD,cAAc;;AAEvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,UAAU,iCAAmB;AAC7B,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,eAAe,iCAAmB;;AAElC;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,+DAA+D,wBAAwB;AACvF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sEAAsE,iBAAiB;AACvF;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,8DAA8D,uBAAuB;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,oCAAoC;AACxD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,iCAAmB;AACnC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,CAAC;;;;;;;;;;ACttUD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA,cAAc;AACd;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;;AAEA,yGAAyG,IAAI,GAAG,IAAI,SAAS,IAAI;;AAEjI;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wEAAwE;AACxE,kFAAkF;AAClF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,IAAI;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;;;;;;;;;;;;;;;ACnEA,sHAA+B;AAC/B,iGAAkD;AAClD,2FAA8C;AAC9C,wFAA4C;AAE5C,MAAM,QAAQ,GAAG,IAAI,mBAAQ,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;AAC/D,QAAQ,CAAC,KAAK,EAAE,CAAC;AAEjB,MAAM,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC;AAC9B,MAAM,CAAC,QAAQ,CAAC,GAAG,eAAM,CAAC;AAC1B,MAAM,CAAC,OAAO,CAAC,GAAG,aAAK,CAAC;AAExB,kBAAkB,EAAE,CAAC;AAErB,SAAS,kBAAkB;IACvB,MAAM,KAAK,GAAG,GAAG,CAAC;IAClB,MAAM,MAAM,GAAG,GAAG,CAAC;IACnB,MAAM,CAAC,GAAG,CAAC,CAAC;IAEZ,WAAW;IACX,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAO,CAAC;IACtD,MAAM,MAAM,GAAG,mBAAM,CAAC,MAAM,CAAC,MAAM,CAAC;QAChC,OAAO,EAAE,QAAQ,CAAC,IAAI;QACtB,MAAM,EAAE,MAAM;QACd,MAAM,EAAE;YACJ,GAAG,EAAE;gBACD,CAAC,EAAE,CAAC,KAAK,GAAC,CAAC,GAAG,CAAC;gBACf,CAAC,EAAE,CAAC,MAAM,GAAC,CAAC,GAAG,CAAC;aACnB;YACD,GAAG,EAAE;gBACD,CAAC,EAAE,KAAK,GAAC,CAAC,GAAG,CAAC;gBACd,CAAC,EAAE,MAAM,GAAC,CAAC,GAAG,CAAC;aAClB;SACH;QACD,OAAO,EAAE;YACL,SAAS,EAAE,IAAI;YACf,KAAK,EAAE,KAAK;YACZ,MAAM,EAAE,MAAM;YACd,kBAAkB,EAAE,IAAI;SAC3B;KACL,CAAC,CAAC;IACH,mBAAM,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAI1B,mBAAmB;IACnB,MAAM,WAAW,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAM,CAAC;IAE1D,MAAM,UAAU,GAAQ;QACpB,SAAS,EAAE,GAAG;QACd,MAAM,EAAE;YACJ,OAAO,EAAE,KAAK;SACjB;KACJ,CAAC;IACF,MAAM,KAAK,GAAG,mBAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IACjD,MAAM,eAAe,GAAG,mBAAM,CAAC,eAAe,CAAC,MAAM,CAAC,MAAM,EAAE;QAC1D,KAAK,EAAE,KAAK;QACZ,UAAU,EAAE,UAAU;KACzB,CAAC,CAAC;IACH,mBAAM,CAAC,SAAS,CAAC,GAAG,CAAC,WAAW,EAAE,eAAe,CAAC,CAAC;AACvD,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5DD,iHAAiC;AAEjC,qFAAsC;AACtC,+EAAkC;AAElC,MAAa,MAAM;IAGR,MAAM,KAAK,OAAO,KAAK,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IAM/C,MAAM,CAAC,IAAI;QACd,MAAM,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC;IAC9B,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,EAAU;;QAC3B,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;QAE/B,qBAAM,CAAC,MAAM,0CAAE,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;QAEtG,IAAI,CAAC,eAAe,EAAE,CAAC;IAC3B,CAAC;IAEO,MAAM,CAAC,eAAe;QAC1B,IAAG,IAAI,CAAC,QAAQ,EAAE;YAEd,qBAAqB;YAErB,MAAM,MAAM,GAAG,mBAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;YAExC,IAAG,CAAC,MAAM;gBAAE,OAAO;YAEnB,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;YAEhD,sDAAsD;YACtD,iGAAiG;YACjG,eAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;YACnC,eAAM,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC;SAEhE;IACL,CAAC;IAEM,MAAM,CAAC,WAAW,CAAC,CAAS,EAAE,CAAS;QAC1C,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;QACrB,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;IACzB,CAAC;;AA3CL,wBA4CC;AA3CiB,aAAM,GAAW,IAAI,CAAC;AACtB,mBAAY,GAAY,IAAI,CAAC;AAG7B,eAAQ,GAAY,KAAK,CAAC;AAEzB,gBAAS,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZ7C,iHAAiC;AACjC,+EAAkC;AAElC,iFAAsC;AACtC,oFAAwC;AACxC,kFAAoC;AACpC,+EAAkC;AAClC,iIAA6D;AAC7D,oFAAgD;AAChD,uHAA6D;AAG7D,MAAa,QAAQ;IAgBjB,YAAY,MAAM;QAZX,wBAAmB,GAAW,EAAE,CAAC;QAapC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,KAAK,GAAG,IAAI,WAAI,EAAE,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,IAAI,iBAAO,EAAE,CAAC;QAE9B,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC;IAC7B,CAAC;IAhBD,IAAW,IAAI,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IACxC,IAAW,OAAO,KAAK,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC9C,IAAW,GAAG,KAAK,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAgB/B,KAAK;QACR,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;QAEpB,eAAM,CAAC,IAAI,EAAE,CAAC;QACd,eAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACvB,aAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEtB,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;QAElB,MAAM,aAAa,GAAG,IAAI,CAAC;QAE3B,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QAC7C,IAAG,aAAa;YAAE,KAAK,CAAC,QAAQ,GAAG,qBAAa,CAAC,MAAM,CAAC;QACxD,KAAK,CAAC,IAAI,EAAE,CAAC;QAEb,eAAM,CAAC,KAAK,GAAG,KAAK,CAAC;QAIrB,IAAG,aAAa,EAAE;YACd,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YACvB,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;SACtC;aAAM;YACH,KAAK,CAAC,aAAa,EAAE,CAAC;YAEtB,MAAM,MAAM,GAAG,KAAK,CAAC,WAAW,CAAC,2BAAY,CAAC,CAAC;YAC/C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;SAC1B;IACL,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,uBAAuB;QACvB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAExB,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAE9B,eAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACtB,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,eAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACtB,CAAC;IAGO,cAAc;QAClB,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,EAAE,CAAC,WAAW,CAAC,MAAM,EAAE;YAC/C,KAAK,EAAE,IAAI,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC;YAC3B,KAAK,EAAE,IAAI,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC;YACjC,QAAQ,EAAE,IAAI,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC;SAC3C,CAAC,CAAC;QAEH,EAAE,CAAC,cAAc,CAAC,uBAAU,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC;QAGjD,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QAC3B,GAAG,CAAC,iBAAiB,CAAC,EAAE,CAAC,oBAAoB,CAAC,CAAC;QAC/C,GAAG,CAAC,mBAAmB,CAAC,EAAE,CAAC,eAAe,CAAC,CAAC;QAE5C,GAAG,CAAC,KAAK,CAAC,YAAY,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;QAErD,GAAG,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,EAAU,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;QAClD,GAAG,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,EAAU,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;QAClD,GAAG,CAAC,KAAK,EAAE,CAAC;QAEZ,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE,UAAS,KAAK;YAC5C,GAAG,CAAC,YAAY,EAAE;QACtB,CAAC,EAAE,IAAI,CAAC,CAAC;QAGT,IAAI;QAEJ;;;;;;UAME;IACN,CAAC;IAEM,SAAS,CAAC,MAAc;QAC3B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,kEAAkE;QAClE,yEAAyE;QAEzE,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC;IAC7B,CAAC;IAEM,sBAAsB;IAE7B,CAAC;CACJ;AAtHD,4BAsHC;;;;;;;;;;;;;;;ACjID,6HAA8C;AAE9C,qFAAsC;AACtC,uFAAiN;AACjN,iHAAyD;AAEzD,gIAAkE;AAIlE,MAAa,OAAO;IAApB;QACW,uBAAkB,GAAW,EAAE,CAAC;QAG/B,oBAAe,GAAW,CAAC,CAAC;IA2QxC,CAAC;IAzQG,IAAW,OAAO;QACd,IAAG,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;YAAE,OAAO,GAAG,QAAQ,CAAC,QAAQ,KAAK,QAAQ,CAAC,IAAI,GAAG,CAAC;QACzF,OAAO,iCAAiC,CAAC;IAC7C,CAAC;IAEM,IAAI;QACP,IAAI,CAAC,OAAO,GAAG,yBAAE,EAAC,IAAI,CAAC,OAAO,EAAE;YAC5B,kBAAkB;YAClB,WAAW,EAAE,KAAK;YAClB,YAAY,EAAE,KAAK;SACtB,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,UAAsB,EAAE,IAAS,EAAE,EAAE;YACvD,MAAM,MAAM,GAAW;gBACnB,IAAI,EAAE,UAAU;gBAChB,IAAI,EAAE,IAAI;aACb;YAED,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QACjC,CAAC,CAAC;QAEF,OAAO,CAAC,GAAG,CAAC,uBAAuB,IAAI,CAAC,OAAO,GAAG,CAAC;IACvD,CAAC;IAEM,OAAO;QACV,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAEM,cAAc,CAAC,EAAU;QAC5B,IAAI,CAAC,UAAU,CAAyB,mBAAU,CAAC,WAAW,EAAE,EAAC,EAAE,EAAE,EAAE,EAAC,CAAC,CAAC;IAC9E,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,IAAI,CAAC,eAAe,IAAI,EAAE,CAAC;QAC3B,IAAG,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,kBAAkB,GAAG,IAAI,EAAE;YACvD,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;YAEzB,MAAM,MAAM,GAAG,mBAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;YACxC,IAAG,MAAM;gBAAE,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;SAC1C;IACL,CAAC;IAEM,cAAc,CAAC,MAAc;QAEhC,4CAA4C;QAE5C,mBAAmB;QAEnB,iCAAiC;QAEjC,8FAA8F;QAE9F;;;;;UAKE;IACN,CAAC;IAEM,UAAU,CAAI,IAAgB,EAAE,UAAa;QAChD,MAAM,MAAM,GAAW;YACnB,IAAI,EAAE,IAAI;YACV,IAAI,EAAE,UAAU;SACnB;QACD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IACnC,CAAC;IAEM,eAAe,CAAC,MAAc;QACjC,IAAG,MAAM,CAAC,IAAI,IAAI,mBAAU,CAAC,WAAW,EAAE;YACtC,MAAM,UAAU,GAA2B,MAAM,CAAC,IAAI,CAAC;YAEvD,MAAM,EAAE,GAAW,UAAU,CAAC,EAAE,CAAC;YAEjC,kBAAkB;YAElB,MAAM,KAAK,GAAG,mBAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC/C,IAAI,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;YAEjC,IAAG,CAAC,MAAM,EAAE;gBACR,MAAM,GAAG,IAAI,uBAAU,CAAC,KAAK,CAAC,CAAC;gBAC/B,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBACjB,MAAM,CAAC,YAAY,CAAC,IAAI,6BAAa,EAAE,CAAC,CAAC;gBACzC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;aAC3B;YAED,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SAClC;QAED,IAAG,MAAM,CAAC,IAAI,IAAI,mBAAU,CAAC,YAAY,EAAE;YACvC,MAAM,UAAU,GAA4B,MAAM,CAAC,IAAI,CAAC;YAExD,MAAM,QAAQ,GAAG,UAAU,CAAC,EAAE,CAAC;YAC/B,MAAM,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC;YAGnC,MAAM,KAAK,GAAG,mBAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAE/C,IAAI,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;YAEvC,IAAG,MAAM;gBAAE,OAAO;YAElB,MAAM,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;YAEhE,MAAM,GAAG,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC;YACtB,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAEvB,MAAM,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC,IAAI,6BAAa,EAAE,CAAC,CAAC;YAE/D,MAAM,CAAC,QAAQ,EAAE;YACjB,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAElC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAExB,aAAa,CAAC,SAAS,EAAE,CAAC;YAG1B,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,UAAU,CAAC;SAC1C;QAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA+EE;QAEF,oDAAoD;QAEpD;;;;;;;;;;;;;;;;;;;UAmBE;QAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAuCE;IACN,CAAC;CACJ;AA/QD,0BA+QC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1RD,iHAAiC;AAEjC,MAAa,UAAW,SAAQ,EAAE,CAAC,UAAU;IAA7C;;QAEW,SAAI,GAAW,WAAW,CAAC;QAC3B,aAAQ,GAAW,EAAE,CAAC;QAMtB,WAAM,GAAW,EAAE,CAAC;QAEpB,eAAU,GAAG,GAAG,EAAE;YACrB,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAExB,2CAA2C;YAC3C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YAC/C,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAA6B,CAAC;YAExE,IAAI,CAAC,OAAO,GAAG,IAAI,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE;gBACnD,MAAM,EAAE,EAAE,CAAC,uBAAuB;aACrC,CAAC,CAAC;YACH,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAEpC,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,EAAE,CAAC,2BAA2B,CAAC;YACxD,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,EAAE,CAAC,aAAa,CAAC;YAG1C,IAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,EAAE,CAAC,qBAAqB,CAAC;YACjD,IAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,EAAE,CAAC,qBAAqB,CAAC;YAEjD,MAAM,QAAQ,GAAG,IAAI,EAAE,CAAC,gBAAgB,EAAE,CAAC;YAC3C,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,QAAQ,EAAE;gBAC/B,QAAQ,EAAE,QAAQ;gBAClB,IAAI,EAAE,OAAO;aAChB,CAAC,CAAC;YAEH,IAAI,CAAC,MAAM,CAAC,MAAO,CAAC,WAAW,GAAG,KAAK,CAAC;YACxC,IAAI,CAAC,MAAM,CAAC,MAAO,CAAC,cAAc,GAAG,KAAK,CAAC;YAE3C,sCAAsC;YAEtC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC;YACnC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC;YACnC,QAAQ,CAAC,SAAS,GAAG,EAAE,CAAC,YAAY,CAAC;YACrC,6BAA6B;YAC7B,QAAQ,CAAC,MAAM,EAAE,CAAC;YAElB,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC;YACrC,IAAI,CAAC,UAAU,EAAE,CAAC;QAEtB,CAAC;QA+CM,mBAAc,GAAG,GAAG,EAAE;YAGzB,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAChC,CAAC;QAIM,WAAM,GAAG,CAAC,EAAE,EAAE,EAAE;YACnB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;QAC5B,CAAC;QAEM,eAAU,GAAG,CAAC,EAAE,EAAE,EAAE;YACvB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;YAE5B,4CAA4C;YAE5C,0CAA0C;YAE1C,6BAA6B;YAC7B,oBAAoB;QACxB,CAAC;QAEM,SAAI,GAAG,GAAG,EAAE;YACf,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtB,CAAC;IACL,CAAC;IAvEW,cAAc,CAAC,CAAS,EAAE,CAAS;QACvC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;QACtB,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;QACvB,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;IACpD,CAAC;IAEO,OAAO,CAAC,IAAY;QACxB,IAAI,CAAC,SAAS,EAAE;QAEhB,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;QACzB,MAAM,KAAK,GAAG,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;QAE1C,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC;QAEvC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC;QACzB,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC;QAE1B,4BAA4B;QAC5B,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC1B,2BAA2B;QAE3B,IAAI,CAAC,SAAS,EAAE;QAChB,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;QAEjC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;IAC1B,CAAC;IAEO,SAAS;QACb,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;QACvB,GAAG,CAAC,IAAI,GAAG,OAAO,GAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAC,YAAY,CAAC;QACtD,GAAG,CAAC,SAAS,GAAG,QAAQ,CAAC;QACzB,GAAG,CAAC,YAAY,GAAG,QAAQ,CAAC;QAC5B,GAAG,CAAC,SAAS,GAAG,OAAO,CAAC;IAC5B,CAAC;IAEO,UAAU;QACd,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAExB,WAAW,CAAC,GAAG,EAAE;YACb,gCAAgC;YAEhC,0BAA0B;QAC9B,CAAC,EAAE,GAAG,CAAC;IACX,CAAC;CA4BJ;AA3HD,gCA2HC;AAED,oEAAoE;AACpE,8DAA8D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChI9D,iHAAgC;AAGhC,yEAA6B;AAE7B,MAAa,MAAM;IAQR,MAAM,CAAC,IAAI,CAAC,GAAmB;QAClC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QAEf,IAAI,CAAC,qBAAqB,EAAE,CAAC;IACjC,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,EAAU;QAC3B,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC;IAEO,MAAM,CAAC,WAAW,CAAC,EAAU;QACjC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACzB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QAErB,IAAG,CAAC,KAAK;YAAE,OAAO;QAGlB,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,QAAQ,EAAE;YAGjC,IAAG,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;gBAC1C,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAErC,MAAM,CAAC,cAAc,EAAE,CAAC;gBAExB,OAAO,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;gBAErC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAEnC,2CAA2C;gBAC3C,qEAAqE;gBAErE,IAAG,CAAC,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE;oBAC/C,MAAM,QAAQ,GAAG,IAAI,EAAE,CAAC,gBAAgB,EAAE,CAAC;oBAC3C,QAAQ,CAAC,OAAO,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBACzC,QAAQ,CAAC,MAAM,EAAE,CAAC;oBAElB,MAAM,cAAc,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;oBACpD,cAAc,CAAC,YAAY,CAAC,QAAQ,EAAE;wBAClC,QAAQ,EAAE,QAAQ;wBAClB,IAAI,EAAE,KAAK;qBACd,CAAC,CAAC;oBACH,cAAc,CAAC,MAAO,CAAC,WAAW,GAAG,KAAK,CAAC;oBAC3C,cAAc,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;oBACzD,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;oBAE7C,oCAAoC;iBACvC;gBAID;;kBAEE;aAEL;YAGD,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;YACnC,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;YACzC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;YACrE,MAAM,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;SAGxF;QAED,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC1C,IAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,EACnC;gBACI,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;gBAE3E,OAAO,CAAC,GAAG,CAAC,0BAA0B,CAAC,CAAC;gBACxC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;aACzC;SACJ;QAED,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC1C,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACrB;QAED,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC1C,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;SACzB;IACL,CAAC;IAEM,MAAM,CAAC,qBAAqB;QAC/B,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QACrB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACrD,MAAM,CAAC,YAAY,CAAC,QAAQ,EAAE;YAC1B,UAAU,EAAE,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;SAC1C,CAAC,CAAC;QACH,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC1B,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QAC7B,yBAAyB;QACzB,MAAM,CAAC,cAAc,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAChC,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAwB,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;QAG7E,OAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEb,qCAAqC;QAErC,EAAE;QAEF;;;;;;;;;;;;;;;;;;;;UAoBE;QAGF,EAAE;QAGF;;;;UAIE;QAEF,IAAI,CAAC,IAAI,EAAE,CAAC;IAChB,CAAC;IAEO,MAAM,CAAC,IAAI;QACf,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QAErB,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACrC,MAAM,cAAc,GAAG,KAAK,CAAC,YAAY,CAAC,OAAO,CAAsB,CAAC;QACxE,KAAK,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC1B,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAEzB,cAAc,CAAC,IAAI,GAAG,OAAO;QAC7B,cAAc,CAAC,KAAK,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC7C,cAAc,CAAC,KAAK,GAAG,EAAE,CAAC;QAC1B,cAAc,CAAC,SAAS,GAAG,CAAC,CAAC;QAC7B,cAAc,CAAC,UAAU,GAAG,GAAG;QAE/B,cAAc,CAAC,WAAW,GAAG,IAAI,CAAC;QAElC,MAAM,CAAC,WAAW,CAAC,GAAG,cAAc;QACpC,gCAAgC;QAChC,oCAAoC;QAEpC;;;;UAIE;QAEF,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC;QAC5B,8CAA8C;IAClD,CAAC;IAEM,MAAM,CAAC,SAAS,CAAC,GAAW,EAAE,QAAmC;QACpE,MAAM,QAAQ,GAAG,GAAG,CAAC;QACrB,MAAM,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC;QAEvB,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,aAAa,CAAC,GAAG,WAAW,CAAC;QAE9D,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,WAAW,EAAE,SAAS,EAAE,EAAC,GAAG,EAAE,QAAQ,EAAC,CAAC,CAAC;QAEpE,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,UAAU,OAAO;YAC/B,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,UAAU,KAAK;YAC5B,QAAQ,CAAC,KAAK,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;QAEH,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACtB,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvB,OAAO,KAAK,CAAC;IACjB,CAAC;IAEM,MAAM,CAAC,cAAc,CAAC,CAAS,EAAE,CAAS;QAC7C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QAErB,IAAG,CAAC,GAAG;YAAE,OAAO;QAEhB,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACrC,MAAM,cAAc,GAAG,KAAK,CAAC,YAAY,CAAC,OAAO,CAAsB,CAAC;QACxE,KAAK,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC;QAC1C,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAEzB,cAAc,CAAC,IAAI,GAAG,OAAO;QAC7B,cAAc,CAAC,KAAK,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC7C,cAAc,CAAC,KAAK,GAAG,CAAC,CAAC;QACzB,cAAc,CAAC,SAAS,GAAG,CAAC;QAE5B,UAAU,CAAC,GAAG,EAAE;YACZ,KAAK,CAAC,OAAO,EAAE,CAAC;YAChB,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAChC,CAAC,EAAE,EAAE,CAAC,CAAC;IACX,CAAC;;AAzNL,wBA0NC;AApNkB,yBAAkB,GAAa,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXrD,iHAAgC;AAChC,gFAAmC;AAEnC,MAAa,MAAM;IAKf,YAAY,CAAS,EAAE,CAAS,EAAE,IAAY,EAAE,SAAS;QACrD,MAAM,MAAM,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QACxC,MAAM,CAAC,YAAY,CAAC,SAAS,EAAE;YAC3B,6DAA6D;YAC7D,SAAS,EAAE,SAAS;YACpB,QAAQ,EAAE,EAAE;YACZ,4DAA4D;YAC5D,IAAI,EAAE,IAAI;YACV,IAAI,EAAE,EAAE,CAAC,gBAAgB;SAC5B,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAhBD,IAAW,MAAM,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAkBrC,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1C,CAAC;CACJ;AAtBD,wBAsBC;AAED,MAAa,EAAE;IACJ,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAK5C,MAAM,CAAC,IAAI,CAAC,GAAmB;QAClC,MAAM,YAAY,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAChD,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC,YAAY,CAAC,QAAQ,EAAE;YAC/C,WAAW,EAAE,IAAI;YACjB,SAAS,EAAE,EAAE,CAAC,eAAe;YAC7B,UAAU,EAAE,GAAG;SAClB,CAAuB,CAAC;QACzB,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAEhC,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;QAC1C,qCAAqC;QAErC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;IACtB,CAAC;IAEM,MAAM,CAAC,OAAO,CAAC,CAAS,EAAE,CAAS,EAAE,IAAY;QACpD,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;QAC3D,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAEzB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAE5C,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,MAAM,CAAC,QAAQ;QAClB,MAAM,OAAO,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QAC7C,OAAO,CAAC,YAAY,CAAC,SAAS,EAAE;YAC5B,IAAI,EAAE,EAAE,CAAC,iBAAiB;SAC7B,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAC1C,CAAC;IAEM,MAAM,CAAC,YAAY;QACtB,MAAM,GAAG,GAAG,eAAM,CAAC,GAAG,CAAC;QAEvB,IAAG,IAAI,CAAC,UAAU,IAAI,SAAS;YAAE,OAAO,IAAI,CAAC,UAAU,CAAC;QAExD,IAAI,CAAC,UAAU,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,EAAE,EAAE,GAAG,EAAE,0BAA0B,EAAE,CAAC,CAAC;QAC1F,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,MAAM,EAAE;YACvB,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC;QAC9B,CAAC,CAAC,CAAC;QAEH,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAChC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAGjC,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;CACJ;AAxDD,gBAwDC;;;;;;;;;;;;;;;;;;ACnFD,sHAA+B;AAG/B,kGAAwC;AAExC,IAAK,QAGJ;AAHD,WAAK,QAAQ;IACT,iDAAS;IACT,2CAAM;AACV,CAAC,EAHI,QAAQ,KAAR,QAAQ,QAGZ;AAED,MAAM,QAAQ;IAeV,YAAY,GAAW,EAAE,CAAS,EAAE,CAAS,EAAE,IAAc;QATtD,UAAK,GAAW,CAAC;QACjB,WAAM,GAAW,CAAC;QAElB,WAAM,GAAW,CAAC;QAElB,WAAM,GAAY,KAAK,CAAC;QAK3B,IAAI,CAAC,GAAG,GAAG,GAAG;QACd,IAAI,CAAC,CAAC,GAAG,CAAC;QACV,IAAI,CAAC,CAAC,GAAG,CAAC;QACV,IAAI,CAAC,IAAI,GAAG,IAAI;IACpB,CAAC;CACJ;AAGD,MAAa,kBAAmB,SAAQ,qBAAS;IAAjD;;QAEW,aAAQ,GAAW,GAAG,CAAC;QAEvB,YAAO,GAAsC,EAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC;QAK3F,eAAU,GAAG,IAAI,GAAG,EAAoB,CAAC;IA4GrD,CAAC;IA/GG,IAAW,IAAI,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAKjC,UAAU,CAAC,CAAS,EAAE,CAAS;QAClC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAEvB,IAAG,CAAC,IAAI;YAAE,OAAO;QAEjB,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE/B,mBAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,CAAC,CAAC;IACzD,CAAC;IAEM,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;QAEb,IAAI,CAAC,UAAU,EAAE,CAAC;IACtB,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAEjB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAEvB,IAAG,IAAI,EAAE;YACL,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAC/C,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAC/C,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClD,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClD,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;SACjD;IACL,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;QAEpB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAEvB,IAAG,IAAI,EAAE;YACL,mBAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE;gBAC1B,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC/B,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;aAClC,CAAC,CAAC;YACH,mBAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAG;gBAC3B,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI;gBAClC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI;aACrC,CAAC,CAAC;YACH,mBAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAChE;IAEL,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC;IAEO,UAAU;QAEd,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,KAAM,CAAC;QACpD,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAChD,MAAM,KAAK,GAAkB,EAAE,CAAC;QAGhC,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE;YAE7C,OAAO,CAAC,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC;YACnC,IAAG,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,SAAS;gBAAE,QAAQ,CAAC,IAAI,GAAG,mBAAM,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC;YACjJ,IAAG,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,MAAM;gBAAE,QAAQ,CAAC,IAAI,GAAG,mBAAM,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC;YAE3H,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAK,CAAC;SAC7B;QAED,OAAO,CAAC,QAAQ,GAAG,KAAK,CAAC;QACzB,OAAO,CAAC,KAAK,GAAG,KAAK;QAErB,MAAM,IAAI,GAAG,mBAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QAEzC,mBAAM,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,EAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,CAAC,CAAC;QAE1C,mBAAM,CAAC,SAAS,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QAExC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,CAAC;IAEM,WAAW,CAAC,GAAW;QAC1B,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACpC,CAAC;IAEM,YAAY,CAAC,GAAW,EAAE,CAAS,EAAE,CAAS,EAAE,KAAa,EAAE,MAAc,EAAE,SAAkB,KAAK;QACzG,IAAI,QAAQ,GAAG,IAAI,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,SAAS,CAAC;QAE1D,QAAQ,CAAC,KAAK,GAAG,KAAK;QACtB,QAAQ,CAAC,MAAM,GAAG,MAAM;QACxB,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAC;QAEzB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC;QAElC,OAAO,QAAQ;IACnB,CAAC;IAEM,SAAS,CAAC,GAAW,EAAE,CAAS,EAAE,CAAS,EAAE,MAAc;QAC9D,IAAI,QAAQ,GAAG,IAAI,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC;QAEvD,QAAQ,CAAC,MAAM,GAAG,MAAM;QAExB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC;QAElC,OAAO,QAAQ;IACnB,CAAC;CACJ;AArHD,gDAqHC;;;;;;;;;;;;;;;ACrJD,4FAA2C;AAE3C,MAAa,SAAS;IAAtB;QAIW,aAAQ,GAAW,CAAC,CAAC;QAEpB,WAAM,GAAkB,IAAI,CAAC;QAC7B,OAAE,GAAY,KAAK,CAAC;IAuChC,CAAC;IArCU,IAAI;QACP,iDAAiD;IACrD,CAAC;IACM,QAAQ;QACX,iDAAiD;IACrD,CAAC;IACM,OAAO;QACV,oDAAoD;IACxD,CAAC;IACM,SAAS,CAAC,EAAU,IAAG,CAAC;IACxB,MAAM,CAAC,EAAU;QACpB,IAAG,CAAC,IAAI,CAAC,EAAE,EAAE;YACT,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC;YACf,mDAAmD;SACtD;IACL,CAAC;IACM,UAAU,CAAC,EAAU,IAAG,CAAC;IAEzB,MAAM,CAAC,EAAU,IAAG,CAAC;IACrB,UAAU,CAAC,EAAU,IAAG,CAAC;IAEzB,kBAAkB,CAAC,KAAa,EAAE,IAAI,EAAE,UAAmB;QAC9D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,uBAAU,CAAC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IACpG,CAAC;IAEM,uBAAuB,CAAC,KAAa,EAAE,IAAI,EAAE,UAAmB;QACnE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,uBAAU,CAAC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IACnG,CAAC;IAEM,uBAAuB,CAAC,KAAa,EAAE,IAAI,EAAE,UAAmB,IAAG,CAAC;IAEpE,QAAQ;QACX,IAAG,IAAI,CAAC,MAAM,IAAI,IAAI,EAAE;YACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;SAChF;QACD,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;CACJ;AA9CD,8BA8CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDD,iHAAiC;AACjC,0FAA6C;AAC7C,oFAAgD;AAIhD,kGAAwC;AAGxC,MAAa,cAAe,SAAQ,qBAAS;IAA7C;;QAEW,aAAQ,GAAW,CAAC,CAAC;QAIpB,eAAU,GAAG,IAAI,GAAG,EAAkB,CAAC;IA2DnD,CAAC;IAzDU,QAAQ;IAEf,CAAC;IAEM,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;QAEb,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC9D,CAAC;IAEM,WAAW,CAAC,IAAY,EAAE,IAAY;QACzC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACpC,CAAC;IAEM,MAAM,CAAC,EAAU;QAEpB,IAAG,CAAC,eAAM,CAAC,GAAG;YAAE,OAAO;QAEvB,IAAG,CAAC,IAAI,CAAC,OAAO,EAAE;YAEd,IAAI,CAAC,OAAO,GAAG,OAAE,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;YACpC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC;SAC5C;QAGD,uDAAuD;QAEvD,IAAI,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;QAClD,IAAI,SAAS,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;QAE9B,0BAA0B;QAC1B,eAAM,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;QAExD,IAAI,UAAU,GAAG,eAAM,CAAC,GAAG,CAAC,cAAc,CAAC,aAAa,CAAC;QACzD,SAAS,CAAC,CAAC,IAAI,UAAU,CAAC;QAC1B,SAAS,CAAC,CAAC,IAAI,UAAU,CAAC;QAE1B,2CAA2C;QAC3C,IAAI,YAAY,GAAG,OAAE,CAAC,MAAM,CAAC,MAAM,CAAC;QACpC,IAAI,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC;QAEtC,IAAI,MAAM,GAAG,eAAM,CAAC,GAAG,CAAC,cAAc,CAAC;QAEvC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC,MAAM,CAAC,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC,CAAC,CAAC;QAEpG,IAAI,GAAG,GAAG,EAAE,CAAC;QAEb,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;YAChC,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;SACzB;QAED,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,GAAG,GAAG,CAAC;IAC3C,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrB,CAAC;CACJ;AAjED,wCAiEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1ED,iHAAiC;AAGjC,kGAAwC;AAExC,MAAa,qBAAsB,SAAQ,qBAAS;IAApD;;QAEW,aAAQ,GAAW,CAAC,CAAC;QAEpB,oBAAe,GAAG,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QACxC,qBAAgB,GAAG,CAAC,CAAC;IA4DjC,CAAC;IA1DU,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAEjB,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;QAC5B,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;IAC7B,CAAC;IAEO,kBAAkB,CAAC,EAAU;QACjC,IAAI,CAAC,gBAAgB,IAAI,EAAE,CAAC;QAC5B,IAAG,IAAI,CAAC,gBAAgB,IAAI,CAAC,EAAE;YAC3B,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,MAAM,EAAE,GAAC,CAAC,CAAC;YAExC,MAAM,KAAK,GAAG,IAAI,CAAC;YAEnB,IAAI,CAAC,eAAe,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAC,KAAK,GAAC,CAAC,KAAK,GAAC,CAAC,CAAC,CAAC;YACvD,IAAI,CAAC,eAAe,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAC,KAAK,GAAC,CAAC,KAAK,GAAC,CAAC,CAAC,CAAC;SAC1D;IACL,CAAC;IAEO,eAAe,CAAC,EAAU;QAE9B,MAAM,KAAK,GAAG;YACV,UAAU,EAAE,CAAC;YACb,QAAQ,EAAE,CAAC;SACd,CAAC;QAEF,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;QAErD,IAAG,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE;YACpC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC;SACxB;aAAM;YACH,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;SACzB;QAED,IAAG,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE;YACpC,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC;SACtB;aAAM;YACH,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;SACvB;QAED,IAAG,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,EAAE;YAC7C,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC;YACnB,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC;SACxB;QAGD,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,GAAG,CAAC,GAAG,EAAE,EAAE,KAAK,CAAC,QAAQ,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;QACrF,0CAA0C;QAC1C,gGAAgG;IACpG,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC;CACJ;AAjED,sDAiEC;;;;;;;;;;;;;;;ACpED,6EAAyC;AAEzC,kGAAwC;AACxC,iHAAkD;AAQlD,MAAa,eAAgB,SAAQ,qBAAS;IAA9C;;QAEW,aAAQ,GAAW,CAAC,CAAC;QAErB,SAAI,GAA0B;YACjC,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,CAAC;SACX;IAuBL,CAAC;IArBU,QAAQ;QACX,IAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,IAAI,qBAAa,CAAC,MAAM,EAAE;YACnD,WAAW,CAAC,GAAG,EAAE;gBACb,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACrB,CAAC,EAAE,IAAI,CAAC;SACX;IACL,CAAC;IAEM,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;IAGjB,CAAC;IAIM,MAAM,CAAC,EAAU;;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAEjB,UAAI,CAAC,MAAM,CAAC,YAAY,CAAC,+BAAc,CAAC,0CAAE,WAAW,CAAC,YAAY,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;IAChH,CAAC;CACJ;AA9BD,0CA8BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CD,iHAAiC;AAGjC,kGAAwC;AAExC,IAAY,QAIX;AAJD,WAAY,QAAQ;IAChB,iDAAS;IACT,qDAAW;IACX,qDAAW;AACf,CAAC,EAJW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAInB;AAED,MAAa,aAAc,SAAQ,qBAAS;IAA5C;;QAEW,aAAQ,GAAW,IAAI,CAAC;QAExB,aAAQ,GAAa,QAAQ,CAAC,WAAW,CAAC;QAC1C,iBAAY,GAAW,IAAI,CAAC;QAE3B,oBAAe,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;QAChC,oBAAe,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;QAChC,iBAAY,GAAG,CAAC,CAAC;QACjB,iBAAY,GAAW,CAAC,CAAC;IA+ErC,CAAC;IA7EU,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,CAAC;IAEM,WAAW;QAEd,IAAG,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,SAAS;YAAE,OAAO;QAE/C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAEvB,IAAI,EAAE,GAAG,GAAG,CAAC;QACb,IAAI,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,CAAC;QAEnE,iBAAiB;QAGjB,iFAAiF;QAGjF,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;QAExC,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;QAEzC,IAAI,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC;QAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACzD,IAAG,QAAQ,GAAG,EAAE,EAAE;YACd,OAAO,GAAG,CAAC,CAAC;SACf;QAED,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,OAAO,GAAG,UAAU,CAAC,CAAC;QACjF,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,OAAO,GAAG,UAAU,CAAC,CAAC;QAEjF,IAAI,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,YAAY,EAAE,GAAG,GAAG,UAAU,CAAC,CAAC;QACzF,IAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,CAAC,EAAE,GAAC,CAAC;YAAE,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;QAE/E,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;QAEzC,MAAM,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,GAAG,CAAE,CAAC;QACpE,MAAM,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,GAAG,CAAE,CAAC;QAGpE,SAAS,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5B,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC1B,SAAS,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAElC,yBAAyB;QACzB,kCAAkC;IACtC,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;QAEpB,IAAI,CAAC,WAAW,EAAE,CAAC;IACvB,CAAC;IAEM,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnC,CAAC;IAEM,QAAQ,CAAC,KAAa;QACzB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;IAC9B,CAAC;IAEM,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnC,CAAC;IAEM,SAAS;QACZ,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;QAExC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;QACtE,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACtC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IAC1E,CAAC;CACJ;AAzFD,sCAyFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpGD,iHAAiC;AAEjC,6HAA0D;AAC1D,kGAAwC;AAWxC,MAAa,kBAAmB,SAAQ,qBAAS;IAAjD;;QAEW,aAAQ,GAAW,IAAI,CAAC;QAIxB,SAAI,GAA6B;YACpC,KAAK,EAAE,CAAC;YACR,QAAQ,EAAE,CAAC;YACX,CAAC,EAAE,CAAC;YACJ,CAAC,EAAE,CAAC;YACJ,IAAI,EAAE,CAAC;YACP,IAAI,EAAE,CAAC;SACV;IAyDL,CAAC;IAvDU,QAAQ;QACX,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;IAC3B,CAAC;IAEM,QAAQ,CAAC,KAAa;QACzB,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IAC5B,CAAC;IAEM,WAAW;QACd,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;IAC3B,CAAC;IAEM,WAAW,CAAC,KAAa;QAC5B,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;IAC/B,CAAC;IAEM,WAAW;QACd,OAAO,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjD,CAAC;IAEM,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC;IAEM,WAAW;QACd,OAAO,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;IAEM,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;IACvB,CAAC;IAEM,UAAU,CAAC,CAAS,EAAE,CAAS;;QAClC,UAAI,CAAC,mBAAmB,0CAAE,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/C,CAAC;IAEM,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;QAEb,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,uCAAkB,CAAC,CAAC;IAC5E,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrB,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC;CACJ;AAtED,gDAsEC;;;;;;;;;;;;;;;AClFD,MAAa,aAAa;IAA1B;QAEY,mBAAc,GAAyC,EAAE,CAAC;QAC1D,iBAAY,GAAsC,EAAE,CAAC;IAoCjE,CAAC;IAjCU,cAAc,CAAmB,MAAkC;QACtE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC;IAEM,iBAAiB,CAAsB,MAAkC;QAC5E,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACrC,CAAC;IAEM,mBAAmB,CAAsB,CAAI;QAChD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,cAAc,EAAE;YACtC,IAAG,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI;gBAAE,OAAO,CAAC,CAAC;YAC/C,CAAC,EAAE,CAAC;SACP;QACD,MAAM,YAAY,GAAG,CAAC,CAAC,WAAW,CAAC,IAAI,GAAG,YAAY,CAAC;IAC3D,CAAC;IAEM,gBAAgB,CAAC,KAAa;QACjC,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEM,mBAAmB,CAAC,KAAa;QACpC,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAEM,gBAAgB,CAAmB,CAAI;QAC1C,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,EAAE;YAC7C,IAAG,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI;gBAAE,OAAO,CAAC,CAAC;YAC/C,CAAC,EAAE,CAAC;SACP;QACD,MAAM,SAAS,GAAG,CAAC,CAAC,WAAW,CAAC,IAAI,GAAG,YAAY,CAAC;IACxD,CAAC;CACJ;AAvCD,sCAuCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1CD,iHAAiC;AACjC,gGAAoC;AAEpC,yHAA2D;AAC3D,wIAA+F;AAG/F,MAAa,WAAW;IAAxB;QAEY,UAAK,GAAQ,EAAE,CAAC;IAgE5B,CAAC;IA/DG,iCAAiC;IAE1B,OAAO,CAAC,IAAS;QAEpB,qDAAqD;QACrD,gDAAgD;QAEhD,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACnD,0DAA0D;QAE1D,uCAAuC;QACvC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;QAE9C,OAAO,WAAW,CAAC;IACvB,CAAC;IAEM,OAAO,CAAC,CAAM,EAAE,OAAY;QAC/B,4CAA4C;QAE5C,IAAI,MAAM,GAAQ,SAAS,CAAC;QAE5B,MAAM,SAAS,GAAG,CAAC,GAAW,EAAE,KAAU,EAAE,EAAE;YAC1C,IAAG,MAAM,IAAI,SAAS;gBAAE,MAAM,GAAG,EAAE,CAAC;YAEpC,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACxB,CAAC;QAED,KAAK,MAAM,CAAC,IAAI,CAAC,EAAE;YAEf,sBAAsB;YAItB,IAAG,CAAC,CAAC,CAAC,CAAC,YAAY,MAAM,EAAE;gBAGvB,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEjD,IAAG,SAAS,IAAI,SAAS,EAAE;oBACvB,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC;iBAC1B;aACJ;iBAAM;gBAEH,IAAG,OAAO,IAAI,SAAS,EAAE;oBACrB,oCAAoC;oBAEpC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBACtB;qBAAM;oBAEH,IAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;wBAEnB,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;qBAErB;iBAEJ;aAEJ;SAEJ;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;CACJ;AAlED,kCAkEC;AAED,MAAa,MAAM;IAkCf,YAAY,KAAY,EAAE,QAAoB;QAjCvC,cAAS,GAAY,KAAK,CAAC;QAE3B,gBAAW,GAAgB,IAAI,WAAW,EAAE,CAAC;QAE7C,YAAO,GAAY,IAAI,CAAC;QAS/B;;;;;;;;UAQE;QAGM,WAAM,GAAkB,IAAI,CAAC;QAE7B,QAAG,GAAW,aAAM,GAAE,CAAC;QAEvB,gBAAW,GAAgB,EAAE,CAAC;QAE9B,mBAAc,GAAY,KAAK,CAAC;QAChC,uBAAkB,GAAY,KAAK,CAAC;QAGxC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAG,QAAQ;YAAE,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QACvC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,uCAAkB,EAAE,CAAC,CAAC;IAClE,CAAC;IA/BD,IAAW,EAAE,KAAK,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IACpC,IAAW,KAAK,KAAK,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAC1C,IAAW,UAAU,KAAK,OAAO,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;IACpD,IAAW,SAAS,KAAK,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;IAClD,IAAW,QAAQ,KAAK,OAAO,IAAI,CAAC,SAAU,CAAC,CAAC,CAAC;IACjD,IAAW,YAAY,KAAK,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAE,CAAC,CAAC,CAAC;IA4BhE,WAAW;QACd,IAAI,QAAQ,GAAQ,SAAS,CAAC;QAE9B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;YACrC,MAAM,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;YAE5B,IAAG,IAAI,IAAI,SAAS;gBAAE,SAAS;YAE/B,IAAG,QAAQ,IAAI,SAAS;gBAAE,QAAQ,GAAG,EAAE,CAAC;YAExC,QAAQ,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,GAAG,IAAI,CAAC;SAEzC;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IAEM,SAAS,CAAC,IAAS;QACtB,IAAG,IAAI,IAAI,SAAS;YAAE,OAAO;QAE7B,EAAE;QACF,MAAM,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;QAEtD,IAAG,aAAa,IAAI,SAAS,EAAE;YAC3B,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;YAEjC,MAAM,KAAK,GAAG,SAAS,CAAC,QAAQ,EAAE,CAAC;YACnC,MAAM,WAAW,GAAG,aAAa,CAAC,KAAK,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC;YAEnF,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;YACzC,MAAM,cAAc,GAAG;gBACnB,CAAC,EAAE,aAAa,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;gBAC9D,CAAC,EAAE,aAAa,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;aACjE;YAED,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;YACzC,MAAM,cAAc,GAAG;gBACnB,CAAC,EAAE,aAAa,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;gBACpE,CAAC,EAAE,aAAa,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;aACvE;YAED,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;YAE7C,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;YAElC,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,6BAAa,CAAC,CAAC;YAEvD,IAAG,aAAa,EAAE;gBACd,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC9C,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC9C,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAE1B,aAAa,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;gBAC9D,aAAa,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;gBAC9D,aAAa,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;aACvC;SACJ;QAED,EAAE;QAEF,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW,EAAE;YACtC,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;YACzC,IAAG,KAAK,IAAI,SAAS;gBAAE,SAAS;YAChC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SACxC;IAOL,CAAC;IAEM,KAAK,CAAC,EAAU;QACnB,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;IAClB,CAAC;IAEM,YAAY,CAAsB,CAAI;QACzC,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;QAChB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAEzB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAE3E,IAAG,IAAI,CAAC,cAAc;YAAE,CAAC,CAAC,IAAI,EAAE,CAAC;QACjC,OAAO,CAAC,CAAC;IACb,CAAC;IAEM,cAAc;QACjB,IAAG,CAAC,IAAI,CAAC,SAAS,EAAE;YAChB,IAAI,CAAC,SAAS,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YACzC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SACjD;IACL,CAAC;IAED;;;;;MAKE;IAEK,YAAY,CAAsB,MAAkC;QACvE,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,IAAI,SAAS,YAAY,MAAM;gBAAE,OAAO,SAAc,CAAC;QACjG,OAAM;IACV,CAAC;IAEM,QAAQ;QACX,IAAG,IAAI,CAAC,kBAAkB;YAAE,OAAO;QAEnC,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,QAAQ,EAAE,CAAC;QAC/D,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;IACnC,CAAC;IAEM,IAAI;QACP,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,IAAI,EAAE,CAAC;QAC3D,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC/B,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IACtE,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACnE,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACvE,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACnE,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACvE,CAAC;IAEM,OAAO;QACV,IAAG,IAAI,CAAC,SAAS;YAAE,OAAO;QAC1B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QAEtB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,OAAO,EAAE,CAAC;IAClE,CAAC;IAEM,QAAQ;QAEX,IAAG,IAAI,CAAC,MAAM,IAAI,IAAI,EAAE;YACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;SACtE;QACD,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;CACJ;AAhMD,wBAgMC;;;;;;;;;;;;;;;AC3QD,wIAAqE;AACrE,4HAA6D;AAC7D,+HAA+D;AAE/D,sFAAkC;AAElC,MAAa,UAAW,SAAQ,eAAM;IAClC,YAAY,KAAY;QACpB,KAAK,CAAC,KAAK,CAAC,CAAC;QAEb,IAAI,CAAC,YAAY,CAAC,IAAI,iCAAe,EAAE,CAAC,CAAC;QACzC,IAAI,CAAC,YAAY,CAAC,IAAI,+BAAc,EAAE,CAAC,CAAC;QACxC,iDAAiD;QAEjD,0DAA0D;QAC1D,wDAAwD;QAExD,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,uCAAkB,EAAE,CAAC,CAAC;QAC9D,sCAAsC;QACtC,SAAS,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;IAC7C,CAAC;CACJ;AAfD,gCAeC;;;;;;;;;;;;;;;ACrBD,wIAAqE;AACrE,4HAA6D;AAG7D,sFAAkC;AAElC,MAAa,YAAa,SAAQ,eAAM;IACpC,YAAY,KAAY;QACpB,KAAK,CAAC,KAAK,CAAC,CAAC;QAEb,IAAI,CAAC,YAAY,CAAC,IAAI,+BAAc,EAAE,CAAC,CAAC;QAGxC,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,uCAAkB,EAAE,CAAC,CAAC;QAC9D,sCAAsC;QACtC,SAAS,CAAC,YAAY,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IACpD,CAAC;CACJ;AAXD,oCAWC;;;;;;;;;;;;;;;ACfD,kGAA0C;AAE1C,MAAa,YAAa,SAAQ,uBAAU;IACxC,YAAY,KAAY;QACpB,KAAK,CAAC,KAAK,CAAC,CAAC;IACjB,CAAC;CACJ;AAJD,oCAIC;;;;;;;;;;;;;;;ACRD,MAAa,YAAY;IAAzB;QACY,YAAO,GAAG,IAAI,GAAG,EAAsC,CAAC;IAwBpE,CAAC;IAtBU,EAAE,CAAC,KAAa,EAAE,EAA0B;QAC/C,OAAO,CAAC,GAAG,CAAC,sBAAsB,KAAK,EAAE,CAAC,CAAC;QAE3C,IAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACzB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;SAC/B;QAED,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAElC,2BAA2B;IAC/B,CAAC;IAEM,IAAI,CAAC,KAAa,EAAE,GAAG,IAAI;QAC9B,0BAA0B;QAE1B,IAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC;YAAE,OAAO;QAEpC,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAE,EAAE;YACvC,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACxB;IAEL,CAAC;CACJ;AAzBD,oCAyBC;;;;;;;;;;;;;;;ACzBD,uIAAoE;AACpE,oGAAgD;AAChD,4EAAgC;AAChC,6GAAsD;AACtD,yGAAiD;AACjD,+GAAqD;AACrD,uIAAoE;AACpE,8HAA8D;AAC9D,gJAA0E;AAC1E,+GAAqD;AACrD,wHAA0D;AAC1D,2HAA4D;AAE5D,MAAa,IAAI;IAWb;QAPQ,YAAO,GAAG,IAAI,GAAG,EAAiB,CAAC;QAIpC,mBAAc,GAAW,EAAE,CAAC;QAC5B,YAAO,GAAW,IAAI,CAAC;QAG1B,IAAI,CAAC,cAAc,GAAG,IAAI,6BAAa,EAAE,CAAC;QAE1C,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,uCAAkB,CAAC,CAAC;QAC1D,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,uCAAkB,CAAC,CAAC;QAC1D,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,iCAAe,CAAC,CAAC;QACvD,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,6CAAqB,CAAC,CAAC;QAC7D,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,6BAAa,CAAC,CAAC;QACrD,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,+BAAc,CAAC,CAAC;QAGtD,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,uBAAU,CAAC,CAAC;QAC/C,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,2BAAY,CAAC,CAAC;QACjD,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,2BAAY,CAAC,CAAC;QAEjD,IAAI,CAAC,iBAAiB,GAAG,IAAI,mCAAgB,EAAE,CAAC;QAEhD,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QACjE,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE1B,IAAI,CAAC,GAAW,CAAC,CAAC,CAAC;QAEnB,IAAI,QAAQ,GAAG,CAAC,CAAC;QACjB,WAAW,CAAC,GAAG,EAAE;YACb,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAIrB,IAAG,GAAG,GAAG,QAAQ,IAAI,IAAI,CAAC,cAAc,EAAE;gBACtC,eAAe;gBAEf,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC,QAAQ,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC;gBACzD,QAAQ,GAAG,GAAG,CAAC;gBAEf;;;;;kBAKE;gBAEF,IAAG,EAAE,IAAI,CAAC;oBAAE,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;aAC/B;YAKD,kBAAkB;QACtB,CAAC,CAAC;IACN,CAAC;IA3DD,IAAW,MAAM,KAAK,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;IACjE,IAAW,aAAa,KAAK,OAAO,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;IA4DnD,KAAK;QACR,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAChC,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,qCAAqC;QAGrC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;YAC7B,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAClB;IAEL,CAAC;IAEM,WAAW,CAAC,IAAY;QAC3B,OAAO,CAAC,GAAG,CAAC,wBAAwB,IAAI,GAAG,CAAC,CAAC;QAE7C,MAAM,KAAK,GAAG,IAAI,aAAK,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC9B,OAAO,KAAK,CAAC;IACjB,CAAC;CACJ;AAnFD,oBAmFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChGD,iHAAgC;AAEhC,MAAa,KAAK;IACP,MAAM,KAAK,aAAa,KAAK,OAAO,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;IAC1D,MAAM,KAAK,SAAS,KAAK,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;IAMlD,MAAM,CAAC,IAAI,CAAC,GAAmB;QAClC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAE5B,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QACxD,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAEpD,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QACzD,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QACzD,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAEzD,CAAC;IAEO,MAAM,CAAC,mBAAmB,CAAC,KAAiB;QAChD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;IAC7C,CAAC;IAEO,MAAM,CAAC,WAAW,CAAC,KAAiB;QACxC,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEO,MAAM,CAAC,WAAW,CAAC,KAAiB;QACxC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEO,MAAM,CAAC,SAAS,CAAC,KAAiB;QACtC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,EAAU;IAE/B,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,GAAoB;QACzC,MAAM,QAAQ,GAAa,EAAE;QAE7B,IAAG,OAAO,GAAG,IAAI,QAAQ,EAAE;YACvB,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9C,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SACjD;aAAM;YACH,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC;SACrB;QAED,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;YAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC;YAC/C,IAAG,KAAK;gBAAE,OAAO,IAAI,CAAC;SACzB;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAEO,MAAM,CAAC,SAAS,CAAC,CAAgB;QACrC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;QAChC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAClC,CAAC;IAEO,MAAM,CAAC,OAAO,CAAC,CAAgB;QACnC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;QAChC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACnC,CAAC;;AApEL,sBAsEC;AAlEkB,WAAK,GAAG,IAAI,GAAG,EAAmB,CAAC;AACnC,oBAAc,GAAG,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACnC,gBAAU,GAAY,KAAK,CAAC;;;;;;;;;;;;;;;ACR/C,gGAAoC;AAEpC,MAAa,IAAI;IAAjB;QAGY,QAAG,GAAW,aAAM,GAAE,CAAC;IACnC,CAAC;IAHG,IAAW,EAAE,KAAK,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;CAGvC;AAJD,oBAIC;AAED,MAAa,GAAG;CAEf;AAFD,kBAEC;AAED,MAAa,SAAS;IAKlB;QAHQ,UAAK,GAAU,EAAE,CAAC;IAK1B,CAAC;IAEM,SAAS,CAAC,MAAc,EAAE,MAAc;IAE/C,CAAC;CAEJ;AAbD,8BAaC;AAED,MAAa,gBAAgB;IAElB,eAAe,CAAC,EAAU;QAC7B,MAAM,SAAS,GAAG,IAAI,SAAS,EAAE,CAAC;QAClC,OAAO,SAAS,CAAC;IACrB,CAAC;CAGJ;AARD,4CAQC;;;;;;;;;;;;;ACnCD,sCAAsC;;;AAEtC,IAAY,UAQX;AARD,WAAY,UAAU;IAClB,yDAAW;IACX,yDAAW;IACX,2DAAY;IACZ,+DAAc;IACd,+DAAc;IACd,yDAAW;IACX,iEAAe;AACnB,CAAC,EARW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAQrB;AAqCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgDE;;;;;;;;;;;;;;;;;;AC/FF,sHAA+B;AAK/B,iGAA8C;AAC9C,2FAA0C;AAC1C,6FAA8C;AAC9C,+EAAkE;AAElE,+GAAqD;AACrD,yGAAiD;AACjD,gJAA0E;AAE1E,+GAAqD;AAErD,IAAI,KAAK,GAAG,CAAC,CAAC;AACd,IAAI,KAAK,GAAG,CAAC,CAAC;AAQd,IAAY,aAIX;AAJD,WAAY,aAAa;IACrB,iEAAY;IACZ,qDAAM;IACN,iDAAI;AACR,CAAC,EAJW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAIxB;AAED,MAAa,KAAK;IAYd,YAAY,IAAU;QAXf,WAAM,GAAiB,IAAI,2BAAY,EAAE,CAAC;QAE1C,aAAQ,GAAkB,aAAa,CAAC,YAAY,CAAC;QAErD,WAAM,GAAiB,EAAE;QAIxB,cAAS,GAAa,EAAE,CAAC;QAI7B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAElB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,uBAAU,CAAC,eAAe,EAAE,CAAC,SAAoB,EAAE,KAAa,EAAE,SAAkB,EAAE,IAAS,EAAE,UAAmB,EAAE,EAAE;YACnI,+FAA+F;YAE/F,IAAG,IAAI,CAAC,QAAQ,IAAI,aAAa,CAAC,MAAM,EAAE;gBAEtC,MAAM,UAAU,GAA+B;oBAC3C,MAAM,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE;oBAC3B,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,SAAS,CAAC;oBACjE,KAAK,EAAE,KAAK;oBACZ,IAAI,EAAE,IAAI;iBACb;gBAED,mBAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,mBAAU,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;gBAG7E,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC;aAEhC;iBAAM;gBAEH,IAAG,UAAU,EAAE;oBAEX,MAAM,UAAU,GAA+B;wBAC3C,MAAM,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE;wBAC3B,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,SAAS,CAAC;wBACjE,KAAK,EAAE,KAAK;wBACZ,IAAI,EAAE,IAAI;qBACb;oBAED,UAAU,CAAC,UAAU,CAAC,mBAAU,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;iBACjE;gBAED,SAAS,CAAC,uBAAuB,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC,CAAC;aACjF;QACL,CAAC,CAAC;IACN,CAAC;IA3CD,IAAW,QAAQ,KAAK,OAAO,IAAI,CAAC,SAAS,EAAC,CAAC;IAAA,CAAC;IAChD,IAAW,IAAI,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAAA,CAAC;IA4ClC,IAAI;QACP,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAE5B,IAAI;YACA,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC;SAC1B;QAAC,OAAM,CAAC,EAAE;SAEV;QAED,IAAI,CAAC,eAAe,EAAE,CAAC;QAEvB;;;;;;;;UAQE;IACN,CAAC;IAEM,IAAI,CAAC,EAAU;QAClB,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;QAElB,oBAAoB;QACpB,mBAAM,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAO,EAAE,kBAAkB,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACjF,uBAAuB;QAEpB,kGAAkG;QACrG,4CAA4C;QAE5C,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAEhB,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC;IAEO,UAAU,CAAC,EAAU;IAE7B,CAAC;IAGM,SAAS,CAAC,EAAU;QACvB,wBAAwB;QAExB,KAAI,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;SACrB;IACL,CAAC;IAGM,MAAM,CAAC,EAAU;QACpB,KAAK,EAAE,CAAC;QACR,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAO,CAAC,MAAM,CAAC,SAAS,CAAC;QAE7C,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;QAEpB,KAAI,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC;SAClB;IACL,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,sBAAsB;QACtB,KAAI,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC;SACtB;IACL,CAAC;IAEO,eAAe;QACnB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,mBAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QAC3D,MAAM,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;QACrB,MAAM,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;QAErB,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;QAE/C;;;;;;;;;;;;;UAaE;QAEF,WAAW,CAAC,GAAG,EAAE;YACb,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,gBAAgB,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,qBAAqB,IAAI,CAAC,IAAI,CAAC,cAAc,WAAW,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;YAChJ,KAAK,GAAG,CAAC,CAAC;QACd,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC;IAEO,aAAa;QAEjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;YACzB,IAAI,CAAC,WAAW,EAAE;SACrB;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;YACzB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,GAAC,GAAG,GAAC,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,GAAC,GAAG,GAAC,EAAE,CAAC;SAC5D;IAEL,CAAC;IAEM,WAAW;QACd,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,2BAAY,CAAC,CAAC;IAE/C,CAAC;IAEM,WAAW;QACd,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,2BAAY,CAAC,CAAC;IAClD,CAAC;IAEM,QAAQ,CAAC,CAAS,EAAE,CAAS;QAChC,IAAI,EAAE,GAAG,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChC,IAAI,EAAE,GAAG,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEhC,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,uBAAU,CAAC,CAAC;QACzC,GAAG,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,EAAE,EAAE,CAAC;QACjC,GAAG,CAAC,YAAY,CAAC,IAAI,6CAAqB,EAAE,CAAC,CAAC;QAE9C,+BAA+B;QAE/B,WAAW,CAAC,GAAG,EAAE;YAEb;;;;;cAKE;QAEN,CAAC,EAAE,GAAG,CAAC;QAEP,gDAAgD;QAChD,OAAO,GAAG,CAAC;IACf,CAAC;IAEM,aAAa;QAChB,OAAO,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAC;QAEtC,IAAI,CAAC,aAAa,EAAE,CAAC;IACzB,CAAC;IAIM,WAAW,CAAC,CAAgB;QAC/B,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;QAE3B,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAClC,CAAC;IAEM,SAAS,CAAC,MAAc;QAC3B,+DAA+D;QAE/D,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC5B,MAAM,CAAC,IAAI,EAAE,CAAC;QACd,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YAChC,IAAG,MAAM,CAAC,EAAE,IAAI,EAAE;gBAAE,OAAO,MAAM,CAAC;SACrC;IACL,CAAC;CACJ;AA7ND,sBA6NC;;;;;;;;;;;;;;;AC5PD,IAAY,UAEX;AAFD,WAAY,UAAU;IAClB,iDAAmC;AACvC,CAAC,EAFW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAErB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFuC;AACA;AACA;AACA;AACE;AACQ;AACE;AACE;;;;;;;;;;;;;;;;ACPtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,GAAG;;;;;;;;;;;;;;;ACtNlB,iEAAe,sCAAsC;;;;;;;;;;;;;;;;ACAhB;;AAErC;AACA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,qBAAqB;;AAErB;AACA,qBAAqB;;AAErB;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;AClCpB,iEAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC;;;;;;;;;;;;;;;ACApI;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD;;AAEnD;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,IAAI;;;;;;;;;;;;;;;;AC/FkB;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,0gBAA0gB;AAC1gB;AACA;AACA;AACA;;AAEA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,SAAS;;;;;;;;;;;;;;;;;AC7BG;AACY,CAAC;AACxC;AACA;AACA;;AAEA;;AAEA,eAAe;;;AAGf;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;;AAEA;AACA,sDAAsD,+CAAG;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA,wEAAwE;AACxE;;AAEA,4EAA4E;;AAE5E,8DAA8D;;AAE9D;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA,uBAAuB;;AAEvB,oCAAoC;;AAEpC,8BAA8B;;AAE9B,kCAAkC;;AAElC,4BAA4B;;AAE5B,kBAAkB,OAAO;AACzB;AACA;;AAEA,gBAAgB,yDAAS;AACzB;;AAEA,iEAAe,EAAE;;;;;;;;;;;;;;;;;AC9FU;AACA;AAC3B,SAAS,mDAAG,aAAa,+CAAG;AAC5B,iEAAe,EAAE;;;;;;;;;;;;;;;;;;;ACHsB;AACR;;AAE/B;AACA,2CAA2C;;AAE3C;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;;AAEO;AACA;AACP,6BAAe,oCAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qDAAK;AACvB;;AAEA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA;;AAEA,WAAW,yDAAS;AACpB,IAAI;;;AAGJ;AACA,8BAA8B;AAC9B,IAAI,eAAe;;;AAGnB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/D2B;AACY;;AAEvC;AACA;AACA,+CAA+C,+CAAG,KAAK;;AAEvD;AACA,mCAAmC;;AAEnC;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA,SAAS,yDAAS;AAClB;;AAEA,iEAAe,EAAE;;;;;;;;;;;;;;;;;ACvBU;AACE;AAC7B,SAAS,mDAAG,aAAa,gDAAI;AAC7B,iEAAe,EAAE;;;;;;;;;;;;;;;;ACHc;;AAE/B;AACA,qCAAqC,sDAAU;AAC/C;;AAEA,iEAAe,QAAQ;;;;;;;;;;;;;;;;ACNc;;AAErC;AACA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,OAAO;;;;;;;;;;;ACVT;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA,cAAc,gBAAgB;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,YAAY;;AAEnB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACZY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,cAAc;AAC1G,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,0CAAyC,EAAE,qCAAqC,8BAA8B,EAAC;AAC/G,gBAAgB;AAChB,qBAAqB,mBAAO,CAAC,8EAAgB;AAC7C,6CAA4C,EAAE,qCAAqC,oCAAoC,EAAC;AACxH,iBAAiB,mBAAO,CAAC,4FAAuB;AAChD,8CAA6C,EAAE,qCAAqC,iCAAiC,EAAC;AACtH,gBAAgB,mBAAO,CAAC,oEAAW;AACnC,yDAAwD,EAAE,qCAAqC,2CAA2C,EAAC;;;;;;;;;;;;ACX9H;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,mBAAmB,mBAAO,CAAC,4FAAuB;AAClD,kBAAkB,mBAAO,CAAC,oEAAW;AACrC,kCAAkC,mBAAO,CAAC,gDAAS;AACnD,mCAAmC,mBAAO,CAAC,kDAAU;AACrD,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gCAAgC;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7kBa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,kBAAkB,mBAAO,CAAC,oEAAW;AACrC,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,kEAAkE;AAClE;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACxHJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,yBAAyB,mBAAO,CAAC,6FAAkB;AACnD,uBAAuB,mBAAO,CAAC,yFAAgB;AAC/C,kBAAkB;AAClB;AACA;AACA;;;;;;;;;;;;ACRa;AACb;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,WAAW;AAC7B,4CAA4C,mBAAO,CAAC,2GAAqB;AACzE,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,wCAAwC,mBAAO,CAAC,yFAAkB;AAClE,kBAAkB,mBAAO,CAAC,qEAAY;AACtC,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,qBAAqB,mBAAO,CAAC,qFAAc;AAC3C,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,qBAAqB;AACrB,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrRa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,uBAAuB,mBAAO,CAAC,+EAAiB;AAChD,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,gCAAgC,mBAAO,CAAC,4CAAO;AAC/C,kCAAkC,mBAAO,CAAC,gDAAS;AACnD,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;ACvLF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,6BAA6B,GAAG,iBAAiB,GAAG,gBAAgB;AAChG,wCAAwC,mBAAO,CAAC,yFAAkB;AAClE,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iBAAiB;AACjB,6BAA6B;AAC7B,yBAAyB;;;;;;;;;;;;AClBZ;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,UAAU;AACV,uBAAuB,mBAAO,CAAC,+EAAiB;AAChD,kCAAkC,mBAAO,CAAC,gDAAS;AACnD,gCAAgC,mBAAO,CAAC,4CAAO;AAC/C,kBAAkB,mBAAO,CAAC,qEAAY;AACtC,mCAAmC,mBAAO,CAAC,yHAA4B;AACvE,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;;;;;;;;;;;ACjMG;AACb;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,mBAAO,CAAC,kDAAU;AACrD,wCAAwC,mBAAO,CAAC,yFAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACxBF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,YAAY;AAC5C,wCAAwC,mBAAO,CAAC,wFAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;;AC7BhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,4BAA4B,GAAG,oBAAoB;AAC1E,0CAA0C;AAC1C,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,CAAC;AACD,uBAAuB;AACvB,oBAAoB;;;;;;;;;;;;AClBP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,6BAA6B,mBAAO,CAAC,4FAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kBAAe;;;;;;;;;;;;AClDF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AC1CF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,gBAAgB;AAC9G,0BAA0B,mBAAO,CAAC,4FAAmB;AACrD,oBAAoB;AACpB,0BAA0B,mBAAO,CAAC,4FAAmB;AACrD,oBAAoB;AACpB,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,gBAAgB;;;;;;;;;;;;ACrCH;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAe,GAAG,eAAe,GAAG,UAAU,GAAG,cAAc,GAAG,eAAe,GAAG,gBAAgB;AACpG,iBAAiB,mBAAO,CAAC,kEAAU;AACnC,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,2CAA0C,EAAE,qCAAqC,gCAAgC,EAAC;AAClH,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,0CAAyC,EAAE,qCAAqC,8BAA8B,EAAC;AAC/G,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,eAAe;AACf,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,0GAAkB;AACnD,4CAA2C,EAAE,qCAAqC,uCAAuC,EAAC;;AAE1H;;;;;;;;;;;;ACpEa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,4BAA4B,mBAAO,CAAC,0GAAkB;AACtD,gBAAgB,mBAAO,CAAC,gEAAS;AACjC,iCAAiC,mBAAO,CAAC,8CAAQ;AACjD,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;AChZF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;;;;;;;;;;;ACTG;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,2BAA2B,mBAAO,CAAC,0GAAkB;AACrD,gBAAgB,mBAAO,CAAC,gEAAS;AACjC,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAmD;AACjF,aAAa;AACb;AACA;AACA,0BAA0B,8DAA8D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;AC1cD;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW;AACX,mCAAmC,mBAAO,CAAC,kDAAU;AACrD,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;;;;;;;;;;ACrEE;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,yBAAyB;AACrD,uBAAuB,mBAAO,CAAC,4GAAgB;AAC/C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,eAAe,GAAG,kBAAkB,GAAG,gBAAgB;AACzE,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,oBAAoB,mBAAO,CAAC,sGAAa;AACzC,uBAAuB,mBAAO,CAAC,4GAAgB;AAC/C,gBAAgB,mBAAO,CAAC,kDAAO,GAAG;AAClC,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,wBAAwB;AACxB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA,iBAAiB,qDAAqD;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;;AAEnC;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,kBAAkB,mGAAmG;AACrH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,iBAAiB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA,MAAM;AACN,iBAAiB,sBAAsB;AACvC;AACA;AACA,MAAM;AACN;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,KAAK;AACL,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,mBAAmB,gBAAgB;AACnC;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW,GAAG,aAAa;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,IAAI,KAAK,UAAU,WAAW,gBAAgB,YAAY;AACnF;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,SAAS;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA,MAAM;AACN,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;;AAEA,mBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO,IAAI,OAAO;AAC/B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AACrD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AACrD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2CAA2C,2BAA2B,+BAA+B,GAAG;;AAExG,4CAA4C,yCAAyC,GAAG;;AAExF,6FAA6F,6BAA6B,8DAA8D,4FAA4F,+CAA+C,+BAA+B,gDAAgD,GAAG;;AAErZ,6CAA6C,qBAAqB,qCAAqC,6SAA6S,+DAA+D,GAAG;;AAEtd,+DAA+D,0BAA0B,cAAc,kEAAkE,oEAAoE,mCAAmC,GAAG;;AAEnR,mEAAmE,0BAA0B,6CAA6C,4FAA4F,mEAAmE,8BAA8B,2BAA2B,GAAG;;AAErW,gDAAgD,6CAA6C,4FAA4F,8BAA8B,2BAA2B,GAAG;;AAErP,sDAAsD,wBAAwB,8BAA8B,2BAA2B,GAAG;;AAE1I,yEAAyE,0BAA0B,qEAAqE,8BAA8B,2BAA2B,GAAG;;AAEpO,0EAA0E,wBAAwB,6BAA6B,gDAAgD,kCAAkC,sGAAsG,0CAA0C,0DAA0D,QAAQ,MAAM,6BAA6B,OAAO,MAAM,MAAM,mCAAmC,yEAAyE,KAAK;;AAE1kB,sDAAsD,wDAAwD,4BAA4B,wHAAwH,0DAA0D,uCAAuC;;AAEnW,yCAAyC,mCAAmC,yBAAyB,eAAe,GAAG,2BAA2B,8BAA8B,GAAG,yBAAyB,0CAA0C,GAAG;;AAEzP,6CAA6C,+BAA+B,gCAAgC,kCAAkC,kCAAkC,8BAA8B,qCAAqC,4BAA4B,6BAA6B,kBAAkB,oBAAoB,qBAAqB;;AAEvW,+DAA+D,wBAAwB,mCAAmC,kCAAkC,iCAAiC,oBAAoB;;AAEjN,+DAA+D,wBAAwB,mCAAmC,kCAAkC,iCAAiC;;AAE7L,4FAA4F,wBAAwB,mCAAmC,kCAAkC,iCAAiC,oBAAoB;;AAE9O,6FAA6F,mBAAmB,GAAG;;AAEnH,mCAAmC,2BAA2B,2BAA2B,8CAA8C,uDAAuD,mCAAmC,GAAG,iCAAiC,oCAAoC,qBAAqB,+CAA+C,eAAe,GAAG,2BAA2B,6BAA6B,0DAA0D,kBAAkB,WAAW,MAAM,8DAA8D,+EAA+E,iEAAiE,kCAAkC,iBAAiB,+CAA+C,uGAAuG,uEAAuE,aAAa;;AAE//B,qEAAqE,oEAAoE,+BAA+B,wBAAwB,2DAA2D,6FAA6F,8EAA8E,aAAa;;AAEnb,oFAAoF,yEAAyE,yCAAyC,uBAAuB,oEAAoE,iGAAiG,6EAA6E,wCAAwC,GAAG;;AAE1f,yFAAyF,4CAA4C,qCAAqC,mGAAmG,4FAA4F,iCAAiC,mDAAmD,qEAAqE,GAAG;;AAErgB,wHAAwH,yBAAyB,aAAa,YAAY,+CAA+C,0CAA0C,wBAAwB,sDAAsD,yBAAyB,6CAA6C,MAAM,2BAA2B,0CAA0C,wBAAwB,qDAAqD,yBAAyB,6CAA6C,MAAM,MAAM,0CAA0C,wBAAwB,sDAAsD,yBAAyB,6CAA6C,KAAK,yBAAyB,GAAG,wIAAwI,oBAAoB,oBAAoB,oEAAoE,8CAA8C,6DAA6D,+CAA+C,4DAA4D,wBAAwB,qCAAqC,+BAA+B,cAAc,GAAG;;AAEv5C,kIAAkI,+DAA+D,uEAAuE,GAAG,iIAAiI,wDAAwD,6FAA6F,GAAG,wLAAwL,4GAA4G,yEAAyE,GAAG;;AAEp5B,gOAAgO,qDAAqD,8GAA8G,oEAAoE,mDAAmD,KAAK,iMAAiM,qDAAqD,8GAA8G,oEAAoE,uCAAuC,0DAA0D,KAAK,iMAAiM,qDAAqD,8GAA8G,oEAAoE,uCAAuC,0DAA0D,KAAK,kMAAkM,qDAAqD,8GAA8G,0DAA0D,oEAAoE,yCAAyC,KAAK,gOAAgO,qDAAqD,8GAA8G,oEAAoE,uCAAuC,0DAA0D,KAAK,2LAA2L,2GAA2G,KAAK,2JAA2J,8CAA8C,KAAK,uIAAuI,0DAA0D,KAAK,uIAAuI,0DAA0D,KAAK,wIAAwI,uEAAuE,gDAAgD,KAAK,sKAAsK,0DAA0D,KAAK,iIAAiI,iEAAiE,KAAK;;AAE9oI,8DAA8D,mCAAmC,6CAA6C,uFAAuF,oDAAoD,mFAAmF,6CAA6C,6CAA6C,oCAAoC,kCAAkC,gCAAgC,kCAAkC,+BAA+B,+BAA+B,wCAAwC,iCAAiC,sCAAsC,2BAA2B,iBAAiB,eAAe,gBAAgB,mBAAmB,oBAAoB,sBAAsB,sBAAsB,qBAAqB,2BAA2B,kBAAkB,mBAAmB,gBAAgB,4BAA4B,4BAA4B,eAAe,2BAA2B,iBAAiB,oBAAoB,0BAA0B,2BAA2B,eAAe,IAAI,6BAA6B,ouBAAouB,iLAAiL,GAAG,2PAA2P,sGAAsG,GAAG,kFAAkF,0GAA0G,GAAG,0FAA0F,0EAA0E,qFAAqF,wCAAwC,yCAAyC,+CAA+C,+CAA+C,oFAAoF,oFAAoF,0IAA0I,uCAAuC,qCAAqC,mIAAmI,oDAAoD,+CAA+C,qGAAqG,uDAAuD,mGAAmG,0FAA0F,0FAA0F,oJAAoJ,sFAAsF,mFAAmF,gGAAgG,gGAAgG,gGAAgG,yHAAyH,aAAa,wEAAwE,2FAA2F,gFAAgF,gFAAgF,GAAG,qFAAqF,mJAAmJ,2GAA2G,kGAAkG,oIAAoI,aAAa,4EAA4E,gJAAgJ,kHAAkH,6GAA6G,oGAAoG,oGAAoG,oJAAoJ,sGAAsG,sGAAsG,sGAAsG,wJAAwJ,aAAa,wFAAwF,oHAAoH,oFAAoF,oFAAoF,oFAAoF,gGAAgG,uFAAuF,uFAAuF,uFAAuF,+DAA+D,uFAAuF,uFAAuF,uFAAuF,uFAAuF,+DAA+D,uFAAuF,uFAAuF,uFAAuF,uFAAuF,+DAA+D,uFAAuF,uFAAuF,uFAAuF,uFAAuF,yIAAyI,2DAA2D,GAAG,8EAA8E,wFAAwF,2IAA2I,GAAG,8EAA8E,sFAAsF,iDAAiD,2CAA2C,4GAA4G,GAAG,8CAA8C,wBAAwB,qCAAqC,mEAAmE,wCAAwC,0CAA0C,sCAAsC,6BAA6B,OAAO,wCAAwC,+EAA+E,QAAQ,uCAAuC,+EAA+E,QAAQ,MAAM,iFAAiF,OAAO,6CAA6C,MAAM,mBAAmB,8FAA8F,6DAA6D,KAAK,2BAA2B,uEAAuE,0CAA0C,iDAAiD,UAAU,uCAAuC,iDAAiD,UAAU,MAAM,mDAAmD,SAAS,QAAQ,uBAAuB,oCAAoC,OAAO,wCAAwC,sCAAsC,mGAAmG,OAAO,2FAA2F,iFAAiF,4CAA4C,0DAA0D,YAAY,MAAM,uDAAuD,WAAW,8DAA8D,uDAAuD,8EAA8E,gDAAgD,8CAA8C,sLAAsL,cAAc,MAAM,qOAAqO,aAAa,WAAW,kGAAkG,gDAAgD,2HAA2H,8CAA8C,0FAA0F,0IAA0I,4IAA4I,4IAA4I,kCAAkC,MAAM,oDAAoD,iMAAiM,mMAAmM,mMAAmM,iCAAiC,WAAW,yBAAyB,OAAO,mFAAmF,SAAS,wEAAwE,6IAA6I,uDAAuD,SAAS,iEAAiE,4CAA4C,uDAAuD,YAAY,uCAAuC,uDAAuD,YAAY,MAAM,yDAAyD,WAAW,8FAA8F,yEAAyE,8CAA8C,6DAA6D,cAAc,uCAAuC,6DAA6D,cAAc,MAAM,+DAA+D,aAAa,oGAAoG,sCAAsC,uBAAuB,SAAS,gEAAgE,oLAAoL,2DAA2D,SAAS,0CAA0C,wFAAwF,0FAA0F,iEAAiE,WAAW,uHAAuH,qFAAqF,4DAA4D,qCAAqC,KAAK,GAAG,+CAA+C,sCAAsC,yDAAyD,gFAAgF,GAAG,6BAA6B,6FAA6F,wGAAwG,yDAAyD,+DAA+D,qEAAqE,yDAAyD,8CAA8C,uCAAuC,gCAAgC,mBAAmB,iIAAiI,4CAA4C,wBAAwB,OAAO,MAAM,kDAAkD,0CAA0C,iCAAiC,SAAS,oDAAoD,gBAAgB,SAAS,OAAO,KAAK,GAAG;;AAEl4iB,iDAAiD,wGAAwG,GAAG;;AAE5J,6CAA6C,mCAAmC,GAAG;;AAEnF,qDAAqD,wGAAwG,GAAG;;AAEhK,+DAA+D,uGAAuG,GAAG;;AAEzK,2DAA2D,mEAAmE,GAAG;;AAEjI,mFAAmF,uBAAuB,oIAAoI,GAAG;;AAEjP,wDAAwD,wGAAwG,GAAG;;AAEnK,kFAAkF,qDAAqD,4BAA4B,iEAAiE,GAAG,wEAAwE,qDAAqD,4BAA4B,sHAAsH,iEAAiE,GAAG,+GAA+G,qDAAqD,4BAA4B,+BAA+B,sEAAsE,yDAAyD,GAAG,mHAAmH,qDAAqD,4BAA4B,+BAA+B,sHAAsH,sEAAsE,yDAAyD,GAAG,wEAAwE,yFAAyF,GAAG;;AAE1hD,6DAA6D,mCAAmC,iCAAiC,kDAAkD,kDAAkD,kBAAkB,gDAAgD,gDAAgD,gDAAgD,4DAA4D,4CAA4C,mDAAmD,2CAA2C,GAAG;;AAEhlB,2DAA2D,8BAA8B,GAAG;;AAE5F,mFAAmF,2CAA2C,mEAAmE,yBAAyB,WAAW;;AAErO,6CAA6C,mBAAmB,GAAG,8BAA8B,mCAAmC,GAAG,6BAA6B,yCAAyC,yBAAyB,GAAG,6BAA6B,uBAAuB,iCAAiC,MAAM,MAAM,uDAAuD,KAAK,GAAG,qCAAqC,8BAA8B,6EAA6E,GAAG,gCAAgC,0DAA0D,kCAAkC,GAAG,gCAAgC,yCAAyC,kCAAkC,6IAA6I,GAAG,6CAA6C,gCAAgC,mDAAmD,GAAG,qCAAqC,gCAAgC,yDAAyD,GAAG;;AAE1pC,4DAA4D,mBAAmB,GAAG,yCAAyC,mBAAmB,GAAG,4CAA4C,uCAAuC,GAAG,6CAA6C,gFAAgF,GAAG,yCAAyC,uBAAuB,GAAG,yCAAyC,uBAAuB,GAAG;;AAE7e,gEAAgE,kEAAkE,4BAA4B,wBAAwB,uDAAuD,yHAAyH,2FAA2F,aAAa;;AAE9c,wFAAwF,6CAA6C,gGAAgG,wDAAwD,2BAA2B,aAAa;;AAErU,8DAA8D,2BAA2B,2BAA2B,mBAAmB,qCAAqC,2DAA2D,uEAAuE,mFAAmF,uEAAuE,sEAAsE,mFAAmF,sEAAsE,2DAA2D,qBAAqB,GAAG;;AAE1vB,2GAA2G,qEAAqE,GAAG,8BAA8B,2CAA2C,yBAAyB,GAAG,2BAA2B,8BAA8B,GAAG,+BAA+B,iBAAiB,4CAA4C,6BAA6B,8FAA8F,gDAAgD,6BAA6B,mBAAmB,GAAG,sCAAsC,2BAA2B,2BAA2B,sBAAsB,uBAAuB,8BAA8B,mBAAmB,6CAA6C,6BAA6B,+BAA+B,cAAc,KAAK,2BAA2B,4BAA4B,0CAA0C,oCAAoC,kCAAkC,kCAAkC,yBAAyB,YAAY,MAAM,2BAA2B,YAAY,MAAM,mEAAmE,6CAA6C,2BAA2B,sCAAsC,+DAA+D,8DAA8D,yCAAyC,sCAAsC,SAAS,OAAO,KAAK,kEAAkE,GAAG;;AAE5rD,kEAAkE,oEAAoE,mEAAmE,8BAA8B,8BAA8B,8DAA8D,+DAA+D,8FAA8F,4FAA4F,8BAA8B,GAAG;;AAE7lB,uEAAuE,+CAA+C,gDAAgD,gDAAgD,gEAAgE,4DAA4D;;AAElV;;AAEA,uDAAuD,iBAAiB,GAAG;;AAE3E,mDAAmD,uCAAuC,mCAAmC,GAAG;;AAEhI;;AAEA;;AAEA,sEAAsE,gDAAgD,wCAAwC,6EAA6E,GAAG,iDAAiD,gDAAgD,0CAA0C,wCAAwC,oBAAoB,iFAAiF,mBAAmB,GAAG;;AAE5hB,kEAAkE,iCAAiC,uDAAuD,GAAG;;AAE7J,yEAAyE,eAAe,GAAG,2BAA2B,eAAe,GAAG,sDAAsD,eAAe,GAAG,2BAA2B,mBAAmB,GAAG,oDAAoD,eAAe,GAAG;;AAEvU,4EAA4E,yBAAyB,kDAAkD,+CAA+C,oCAAoC,oCAAoC,oCAAoC,eAAe,GAAG,2BAA2B,yBAAyB,oCAAoC,+CAA+C,oCAAoC,oCAAoC,oCAAoC,eAAe,GAAG,sDAAsD,yBAAyB,gCAAgC,+CAA+C,oCAAoC,oCAAoC,oCAAoC,eAAe,GAAG,2BAA2B,yBAAyB,+CAA+C,6GAA6G,GAAG,oDAAoD,6CAA6C,GAAG;;AAE5pC,uDAAuD,6CAA6C,GAAG,iCAAiC,4DAA4D,GAAG,iCAAiC,8EAA8E,GAAG,4DAA4D,6CAA6C,GAAG,4DAA4D,6CAA6C,GAAG,4DAA4D,6CAA6C,GAAG,4CAA4C,yDAAyD,mDAAmD,kCAAkC,GAAG;;AAE1zB,uCAAuC,4BAA4B,kCAAkC,2BAA2B,kDAAkD,gDAAgD,2CAA2C,kEAAkE,GAAG;;AAElV,wCAAwC,4BAA4B,kCAAkC,2BAA2B,kDAAkD,sEAAsE,2CAA2C,kEAAkE,GAAG;;AAEzW,0CAA0C,0BAA0B,wBAAwB,kCAAkC,2BAA2B,kDAAkD,gEAAgE,2CAA2C,6CAA6C,kEAAkE,GAAG;;AAExa,iDAAiD,2BAA2B,iBAAiB,GAAG;;AAEhG,6DAA6D,qBAAqB,6DAA6D,uCAAuC,mCAAmC,yCAAyC,iEAAiE,4EAA4E,iCAAiC,mCAAmC,2CAA2C,oEAAoE,aAAa;;AAE/kB,0CAA0C,2BAA2B,mBAAmB,2CAA2C,GAAG;;AAEtI,uDAAuD,oBAAoB,oBAAoB,kDAAkD,sCAAsC,GAAG;;AAE1L,8DAA8D,8BAA8B,GAAG,0DAA0D,oCAAoC,GAAG,mDAAmD,iCAAiC,GAAG,uCAAuC,iBAAiB,GAAG,sCAAsC,iBAAiB,GAAG,wCAAwC,iBAAiB,GAAG,sCAAsC,iBAAiB,GAAG;;AAElgB,sDAAsD,iCAAiC,GAAG,wCAAwC,2BAA2B,GAAG,sCAAsC,oDAAoD,GAAG,8CAA8C,mCAAmC,2CAA2C,gBAAgB,GAAG,0DAA0D,yCAAyC,2CAA2C,gBAAgB,GAAG,mDAAmD,sCAAsC,2CAA2C,gBAAgB,GAAG,uCAAuC,+BAA+B,sCAAsC,kCAAkC,aAAa;;AAE/1B,+DAA+D;;AAE/D;;AAEA,iEAAiE,gEAAgE,gCAAgC,sBAAsB,yDAAyD,uFAAuF,4EAA4E,uCAAuC,GAAG;;AAE7b,kDAAkD,gCAAgC,gCAAgC,gCAAgC;;AAElJ,sDAAsD,oDAAoD,GAAG;;AAE7G,8DAA8D,wCAAwC,2CAA2C,2BAA2B,GAAG;;AAE/K,wDAAwD,wCAAwC,sBAAsB,6DAA6D,uDAAuD,wCAAwC,6BAA6B,MAAM,MAAM,wDAAwD,oEAAoE,8DAA8D,wDAAwD,4CAA4C,KAAK,iDAAiD,GAAG;;AAElpB,8EAA8E,8BAA8B,wBAAwB,2EAA2E,mEAAmE,kCAAkC,GAAG;;AAEvT,gDAAgD,gDAAgD,GAAG;;AAEnG,0FAA0F,iCAAiC,4EAA4E,uDAAuD,8DAA8D,8DAA8D,0EAA0E,iCAAiC,gCAAgC,gCAAgC,uBAAuB,gDAAgD,yBAAyB,uBAAuB,wCAAwC,wCAAwC,wCAAwC,8CAA8C,8CAA8C,yCAAyC,+CAA+C,gEAAgE,gEAAgE,wCAAwC,iBAAiB,GAAG,4BAA4B,oDAAoD,GAAG,8BAA8B,sDAAsD,GAAG;;AAE9yC,uFAAuF,sDAAsD,8CAA8C,6CAA6C,2CAA2C,mCAAmC,oDAAoD,GAAG,4BAA4B,oDAAoD,GAAG,8BAA8B,sDAAsD,GAAG;;AAEvhB,wFAAwF,gCAAgC,2CAA2C,4EAA4E,GAAG,4BAA4B,qDAAqD,GAAG,8BAA8B,uDAAuD,GAAG;;AAE9Z,kDAAkD,aAAa,oDAAoD,oDAAoD,oDAAoD,eAAe,GAAG,6EAA6E,gCAAgC,0DAA0D,0CAA0C,0CAA0C,qDAAqD,mCAAmC,cAAc,GAAG,wDAAwD,0BAA0B,qDAAqD,GAAG,uEAAuE,4BAA4B,uBAAuB,4DAA4D,gDAAgD,oBAAoB,+FAA+F,4CAA4C,GAAG,iBAAiB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,IAAI,8HAA8H,oDAAoD,oDAAoD,uCAAuC,oEAAoE,gBAAgB,0CAA0C,iCAAiC,yDAAyD,qBAAqB,kDAAkD,kDAAkD,kDAAkD,kDAAkD,2CAA2C,2CAA2C,2CAA2C,2CAA2C,wCAAwC,6EAA6E,6EAA6E,6EAA6E,6EAA6E,mEAAmE,kBAAkB,GAAG,oBAAoB,2EAA2E,kBAAkB,sDAAsD,sDAAsD,sDAAsD,sDAAsD,kBAAkB,GAAG,sBAAsB,8EAA8E,+DAA+D,oEAAoE,6CAA6C,oCAAoC,6EAA6E,GAAG,cAAc,iCAAiC,iEAAiE,4EAA4E,oDAAoD,GAAG,oBAAoB,uCAAuC,iEAAiE,iDAAiD,+DAA+D,+BAA+B,gFAAgF,GAAG,8BAA8B,kDAAkD,mEAAmE,uEAAuE,4EAA4E,WAAW,6EAA6E,oEAAoE,GAAG,6EAA6E,yDAAyD,GAAG,+EAA+E,uEAAuE,GAAG,sCAAsC,uBAAuB,qCAAqC,0BAA0B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,oMAAoM,sEAAsE,wBAAwB,kBAAkB,KAAK,sBAAsB,0BAA0B,+CAA+C,yDAAyD,iDAAiD,oEAAoE,eAAe,oDAAoD,4BAA4B,4BAA4B,KAAK,KAAK,oBAAoB,0BAA0B,mDAAmD,6DAA6D,iDAAiD,oEAAoE,eAAe,kDAAkD,4BAA4B,6BAA6B,KAAK,4BAA4B,6CAA6C,4BAA4B,mDAAmD,kEAAkE,qEAAqE,0EAA0E,gBAAgB,GAAG,6EAA6E,gBAAgB,sCAAsC,sBAAsB,gDAAgD,iBAAiB,wCAAwC,wCAAwC,wCAAwC,wBAAwB,mCAAmC,oCAAoC,oCAAoC,iBAAiB,mBAAmB,mBAAmB,eAAe,4BAA4B,4BAA4B,4BAA4B,iDAAiD,2BAA2B,yCAAyC,sBAAsB,2CAA2C,2CAA2C,sCAAsC,sCAAsC,oBAAoB,2BAA2B,4CAA4C,4CAA4C,OAAO,iBAAiB,wCAAwC,wCAAwC,OAAO,sBAAsB,sBAAsB,0BAA0B,0BAA0B,KAAK,aAAa,4BAA4B,4BAA4B,oBAAoB,oBAAoB,KAAK,4BAA4B,0CAA0C,yBAAyB,8BAA8B,8BAA8B,8BAA8B,8BAA8B,eAAe,eAAe,qBAAqB,yDAAyD,+DAA+D,mBAAmB,kDAAkD,uBAAuB,uBAAuB,uBAAuB,kEAAkE,mCAAmC,6BAA6B,+BAA+B,8BAA8B,8BAA8B,gFAAgF,gCAAgC,0DAA0D,0CAA0C,qDAAqD,iCAAiC,uDAAuD,4BAA4B,GAAG,+BAA+B,wFAAwF,GAAG,+BAA+B,wFAAwF,GAAG,iCAAiC,kFAAkF,qCAAqC,GAAG,oCAAoC,iDAAiD,+EAA+E,4CAA4C,+GAA+G,GAAG,uDAAuD,sCAAsC,iFAAiF,GAAG,gCAAgC,mDAAmD,GAAG,oDAAoD,qDAAqD,GAAG,+DAA+D,sCAAsC,iFAAiF,GAAG,gCAAgC,mDAAmD,GAAG,oDAAoD,qDAAqD,GAAG,0CAA0C,mDAAmD,GAAG,sDAAsD,qDAAqD,GAAG;;AAE5xU,2DAA2D,oCAAoC,+DAA+D,+BAA+B,GAAG,oDAAoD,oEAAoE,iCAAiC,0BAA0B,uDAAuD,yFAAyF,0EAA0E,0CAA0C,GAAG;;AAE1nB,gDAAgD,mJAAmJ,6CAA6C,GAAG,6CAA6C,mCAAmC,GAAG,kCAAkC,6BAA6B,kCAAkC,6BAA6B,kCAAkC,4BAA4B,6BAA6B,8BAA8B,wDAAwD,uCAAuC,0DAA0D,4DAA4D,gEAAgE,6BAA6B,+CAA+C,uFAAuF,oCAAoC,yEAAyE,kCAAkC,+DAA+D,sDAAsD,4EAA4E,uEAAuE,uBAAuB,gFAAgF,mFAAmF,+EAA+E,wHAAwH,wCAAwC,iHAAiH,0CAA0C,kBAAkB,GAAG;;AAEr+D,6FAA6F,4BAA4B,uGAAuG,kHAAkH,2CAA2C,8CAA8C,8FAA8F,kDAAkD,kDAAkD,kDAAkD,qFAAqF,kDAAkD,kDAAkD,kDAAkD,uGAAuG,8DAA8D,8BAA8B,2DAA2D,GAAG;;AAE3oC,sFAAsF,kDAAkD,uCAAuC,wBAAwB,0BAA0B,+CAA+C,GAAG,gDAAgD,sGAAsG,8GAA8G,oDAAoD,8BAA8B,aAAa;;AAEtnB,2CAA2C,qFAAqF,oDAAoD,GAAG;;AAEvL,uDAAuD,mCAAmC,oBAAoB,qEAAqE,mFAAmF,4CAA4C,iCAAiC,GAAG;;AAEtV,2DAA2D,oBAAoB,qEAAqE,4CAA4C,iCAAiC,GAAG;;AAEpO,yCAAyC,wFAAwF,oDAAoD,GAAG;;AAExL,wCAAwC,yCAAyC,GAAG;;AAEpF,gDAAgD,gBAAgB,oCAAoC,+DAA+D,kBAAkB,GAAG;;AAExL,iDAAiD,gCAAgC,GAAG;;AAEpF,iEAAiE,kEAAkE,6BAA6B,iBAAiB,kDAAkD,oFAAoF,8EAA8E,aAAa;;AAElZ,6CAA6C;;AAE7C,gDAAgD;;AAEhD,sDAAsD,0BAA0B;;AAEhF,yCAAyC,6BAA6B,sBAAsB,2BAA2B,8BAA8B,GAAG,+BAA+B,0CAA0C,2BAA2B,sFAAsF,4CAA4C,yBAAyB,iBAAiB,GAAG,mBAAmB,+BAA+B,0BAA0B,aAAa,oBAAoB,kCAAkC,MAAM,qBAAqB,kCAAkC,MAAM,qBAAqB,gCAAgC,MAAM,qBAAqB,kCAAkC,MAAM,qBAAqB,iCAAiC,MAAM,MAAM,mCAAmC,KAAK,4CAA4C,iEAAiE,GAAG;;AAE/8B,uCAAuC,2BAA2B,mBAAmB,2CAA2C,GAAG;;AAEnI,gDAAgD,kFAAkF,2EAA2E,0EAA0E,+BAA+B,eAAe,GAAG;;AAExU,oDAAoD,kFAAkF,2EAA2E,0EAA0E,gBAAgB,+BAA+B,eAAe,GAAG;;AAE5V,sDAAsD,yCAAyC,sBAAsB,mDAAmD,yDAAyD,wDAAwD,qCAAqC,uBAAuB,oDAAoD,GAAG;;AAE5Y,kDAAkD,6BAA6B,+BAA+B,gCAAgC,gCAAgC,yEAAyE,kCAAkC,0BAA0B,2BAA2B,8BAA8B,GAAG,+EAA+E,uGAAuG,2CAA2C,iBAAiB,GAAG,2BAA2B,+FAA+F,2EAA2E,0BAA0B,mCAAmC,kCAAkC,6BAA6B;;AAEr6B,kDAAkD,yBAAyB,iCAAiC,mCAAmC,yBAAyB,GAAG,2BAA2B,8BAA8B,GAAG,oDAAoD,sGAAsG,GAAG,gEAAgE,+BAA+B,iDAAiD,0CAA0C,yCAAyC,yCAAyC,qCAAqC,wBAAwB,GAAG,iEAAiE,6BAA6B,6BAA6B,+BAA+B,kBAAkB,sBAAsB,GAAG,oDAAoD,8FAA8F,wGAAwG,yBAAyB,GAAG,qDAAqD,8DAA8D,eAAe,GAAG,8BAA8B,wBAAwB,mCAAmC,GAAG,mBAAmB,gDAAgD,4CAA4C,kDAAkD,qFAAqF,oCAAoC,kBAAkB,2DAA2D,2EAA2E,sCAAsC,wFAAwF,kCAAkC,6DAA6D,kBAAkB,wEAAwE,2BAA2B,gCAAgC,gCAAgC,8EAA8E,6IAA6I,0HAA0H,qCAAqC,sCAAsC,mBAAmB;;AAEnoF,0IAA0I;;AAE1I,+IAA+I;;AAE/I,gDAAgD,sCAAsC,+FAA+F,MAAM,MAAM,sEAAsE,KAAK,uEAAuE,oEAAoE,2BAA2B,mDAAmD,kDAAkD;;AAEvhB,sDAAsD,wDAAwD,yDAAyD,oBAAoB,qBAAqB,qDAAqD,0BAA0B,oBAAoB,GAAG;;AAEtT,qFAAqF,8BAA8B,uBAAuB,gCAAgC,mCAAmC,GAAG,sCAAsC,0EAA0E,GAAG,4BAA4B,0DAA0D,0DAA0D,0DAA0D,0DAA0D,yFAAyF,gEAAgE,qBAAqB,yCAAyC,2CAA2C,0BAA0B,mCAAmC,4EAA4E,oCAAoC,6DAA6D,GAAG;;AAEtjC,iDAAiD,6BAA6B,iEAAiE,MAAM,MAAM,2CAA2C,KAAK,GAAG;;AAE9M,uDAAuD,4BAA4B,iCAAiC,oCAAoC,qBAAqB,+CAA+C,eAAe,GAAG,mCAAmC,0DAA0D,qBAAqB,8DAA8D,eAAe,GAAG,sBAAsB,kDAAkD,qCAAqC,2CAA2C,4EAA4E,oCAAoC,iEAAiE,+BAA+B,4EAA4E,MAAM,gCAAgC,4EAA4E,MAAM,gCAAgC,mDAAmD,MAAM,MAAM,8CAA8C,KAAK,GAAG;;AAEjnC,sDAAsD,kCAAkC,0DAA0D,oCAAoC,2BAA2B,+DAA+D,mEAAmE,wEAAwE,wEAAwE,wEAAwE,+DAA+D,oCAAoC,WAAW,oEAAoE,iDAAiD,GAAG;;AAEjxB,4CAA4C,GAAG;;AAE/C,+CAA+C,wCAAwC,uCAAuC,uCAAuC,uCAAuC,uCAAuC,+CAA+C,4BAA4B,8EAA8E,wGAAwG,wCAAwC,gCAAgC,gCAAgC,gCAAgC,aAAa,aAAa,gBAAgB,cAAc,eAAe,gBAAgB,cAAc,cAAc,iBAAiB,eAAe,gBAAgB;;AAE/xB,8DAA8D,oEAAoE,qBAAqB,KAAK;;AAE5J,wEAAwE;;AAExE,4DAA4D,oEAAoE,oBAAoB,KAAK,0CAA0C;;AAEnM,+DAA+D,4CAA4C,0DAA0D,2CAA2C,oDAAoD,uFAAuF,0EAA0E,+CAA+C,WAAW,oEAAoE,uEAAuE,GAAG;;AAE7mB,uDAAuD,8BAA8B,GAAG,kCAAkC,yBAAyB,iCAAiC,mCAAmC,yBAAyB,GAAG,gEAAgE,gCAAgC,kDAAkD,4CAA4C,yCAAyC,yCAAyC,qCAAqC,gCAAgC,GAAG,4EAA4E,0CAA0C,iCAAiC,uGAAuG,GAAG,mBAAmB,+CAA+C,sBAAsB,iCAAiC,mDAAmD,sDAAsD,6BAA6B,sDAAsD,0BAA0B,qBAAqB,kBAAkB,uFAAuF,+EAA+E,2EAA2E,8BAA8B,mCAAmC,8EAA8E,uCAAuC,0CAA0C,wDAAwD,4EAA4E,4EAA4E,6DAA6D,kCAAkC,8GAA8G,+FAA+F,wGAAwG,4FAA4F,8EAA8E,qDAAqD,wGAAwG,6FAA6F,4CAA4C,0CAA0C;;AAEjvF,0EAA0E,mDAAmD;;AAE7H,uDAAuD,oDAAoD,oDAAoD;;AAE/J,qEAAqE,8CAA8C;;AAEnH,sDAAsD;;AAEtD,yDAAyD,sCAAsC,sCAAsC,uCAAuC,+HAA+H,qCAAqC,4BAA4B,mEAAmE,qCAAqC,kCAAkC,6BAA6B,yBAAyB,wBAAwB,qBAAqB,iEAAiE,2CAA2C,uCAAuC,uCAAuC,uCAAuC,0BAA0B,kCAAkC,kEAAkE,6BAA6B,6BAA6B,+BAA+B,kBAAkB,sBAAsB,GAAG,qDAAqD,6FAA6F,eAAe,GAAG,sDAAsD,8DAA8D,eAAe,GAAG,oBAAoB,+CAA+C,6BAA6B,4CAA4C,8FAA8F,2CAA2C,kDAAkD,qFAAqF,2DAA2D,uEAAuE,6BAA6B,uHAAuH,yGAAyG,2BAA2B,2CAA2C,sCAAsC,iDAAiD;;AAE9xE,8EAA8E,4BAA4B,8DAA8D;;AAExK,2EAA2E,oDAAoD;;AAE/H,0CAA0C,uBAAuB,kCAAkC,gCAAgC,GAAG;;AAEtI,yDAAyD,4BAA4B,gFAAgF,2EAA2E;;AAEhP,gEAAgE,qCAAqC,2BAA2B,2BAA2B;;AAE3J,0DAA0D,8CAA8C,6CAA6C,4BAA4B,6BAA6B,kCAAkC,mEAAmE,sDAAsD,gCAAgC,gCAAgC,wBAAwB,0BAA0B,iEAAiE,wGAAwG,kDAAkD,uCAAuC,uCAAuC,uCAAuC,yEAAyE,0CAA0C,aAAa,aAAa,gBAAgB,cAAc,eAAe;;AAEr+B,oEAAoE,6CAA6C;;AAEjH,oOAAoO,iBAAiB;;AAErP,yFAAyF;;AAEzF,sDAAsD,0DAA0D,0DAA0D,mCAAmC;;AAE7M,oFAAoF;;AAEpF,uJAAuJ,0CAA0C;;AAEjM,wEAAwE;;AAExE,8DAA8D,iCAAiC,uEAAuE,mBAAmB;;AAEzL,2DAA2D;;AAE3D,2DAA2D,yCAAyC,gCAAgC,wEAAwE,uEAAuE,2DAA2D;;AAE9U,sIAAsI,iHAAiH;;AAEvP,4DAA4D,uCAAuC,kEAAkE,uCAAuC,qDAAqD;;AAEjQ,wCAAwC,sCAAsC,GAAG;;AAEjF,iDAAiD,+BAA+B,kFAAkF,2EAA2E,0EAA0E,+BAA+B,eAAe,GAAG,mBAAmB,6CAA6C,sDAAsD,mCAAmC,GAAG;;AAEpgB,oCAAoC,yDAAyD,GAAG;;AAEhG,yCAAyC,wDAAwD,uDAAuD,sEAAsE,qEAAqE,6EAA6E,oGAAoG,gDAAgD,GAAG;;AAEvgB,qFAAqF,0BAA0B,mGAAmG,GAAG;;AAErN,4DAA4D,sCAAsC,0DAA0D,yDAAyD,wBAAwB,4DAA4D,GAAG,wBAAwB,uFAAuF,GAAG;;AAE9Z,gGAAgG,8CAA8C,gCAAgC,uBAAuB,uBAAuB,6CAA6C,yBAAyB,yBAAyB,uFAAuF,mDAAmD,GAAG,0DAA0D,gEAAgE,iCAAiC,oDAAoD,gCAAgC,iDAAiD,kCAAkC,kBAAkB,iBAAiB,wBAAwB,gCAAgC,sCAAsC,gCAAgC,MAAM,MAAM,6CAA6C,mBAAmB,KAAK,6DAA6D,6DAA6D,iDAAiD,0FAA0F,qEAAqE,GAAG,wBAAwB,uFAAuF,GAAG;;AAE37C,2FAA2F,8CAA8C,sCAAsC,0DAA0D,wDAAwD,8FAA8F,6CAA6C,8DAA8D,GAAG,wBAAwB,uFAAuF,GAAG;;AAE/lB,iEAAiE,sCAAsC,0DAA0D,6BAA6B,+CAA+C,8DAA8D,GAAG,wBAAwB,uFAAuF,GAAG;;AAEha,gFAAgF,uDAAuD,oCAAoC,gDAAgD,iEAAiE,mBAAmB,GAAG,wBAAwB,yBAAyB,4BAA4B,4BAA4B,yEAAyE,oBAAoB,uFAAuF,oBAAoB,uBAAuB,GAAG;;AAE7nB,qCAAqC,8BAA8B,iCAAiC,+BAA+B,qCAAqC,sBAAsB,uBAAuB,uBAAuB,kBAAkB,0BAA0B,kBAAkB,gCAAgC,kBAAkB,gCAAgC,kBAAkB,8BAA8B,mBAAmB,8BAA8B,mBAAmB,+BAA+B,2BAA2B,8BAA8B,GAAG,kCAAkC,sBAAsB,GAAG,kCAAkC,6BAA6B,GAAG,iCAAiC,sCAAsC,GAAG,iCAAiC,+DAA+D,GAAG,8BAA8B,2CAA2C,yBAAyB,GAAG,gCAAgC,gBAAgB,4CAA4C,4BAA4B,0FAA0F,8CAA8C,2BAA2B,kBAAkB,GAAG,gCAAgC,0BAA0B,iCAAiC,MAAM,MAAM,6DAA6D,KAAK,GAAG,gCAAgC,0DAA0D,yBAAyB,8BAA8B,MAAM,MAAM,mCAAmC,6DAA6D,KAAK,GAAG,2CAA2C,yBAAyB,+CAA+C,+HAA+H,GAAG,8BAA8B,6EAA6E,GAAG,+BAA+B,2FAA2F,GAAG,+BAA+B,wFAAwF,GAAG,iCAAiC,6CAA6C,wDAAwD,GAAG,iCAAiC,4CAA4C,GAAG,gCAAgC,kFAAkF,GAAG,gCAAgC,6CAA6C,GAAG,iDAAiD,6CAA6C,gGAAgG,+DAA+D,WAAW,iDAAiD,sDAAsD,GAAG,gDAAgD,2IAA2I,0GAA0G,WAAW,gDAAgD,uDAAuD,GAAG,6BAA6B,kCAAkC,GAAG,4BAA4B,oDAAoD,GAAG,0BAA0B,uDAAuD,oBAAoB,mDAAmD,KAAK,wBAAwB,GAAG,iCAAiC,6DAA6D,GAAG,6BAA6B,kDAAkD,wCAAwC,oBAAoB,+DAA+D,KAAK,kBAAkB,GAAG,mCAAmC,yCAAyC,wDAAwD,GAAG,mCAAmC,gDAAgD,GAAG,mDAAmD,yCAAyC,gGAAgG,+DAA+D,WAAW,mDAAmD,0DAA0D,GAAG,8BAA8B,+BAA+B,8BAA8B,aAAa,sBAAsB,kCAAkC,MAAM,uBAAuB,kCAAkC,MAAM,uBAAuB,gCAAgC,MAAM,uBAAuB,kCAAkC,MAAM,uBAAuB,iCAAiC,MAAM,MAAM,mCAAmC,KAAK,4EAA4E,GAAG,iCAAiC,gCAAgC,6BAA6B,iDAAiD,iDAAiD,2BAA2B,GAAG,qCAAqC,2GAA2G,qCAAqC,yBAAyB,yBAAyB,GAAG,oBAAoB,2BAA2B,kEAAkE,MAAM,MAAM,4CAA4C,4BAA4B,4BAA4B,8DAA8D,8BAA8B,0BAA0B,sBAAsB,MAAM,4BAA4B,sBAAsB,MAAM,kLAAkL,SAAS,OAAO,yEAAyE,KAAK,GAAG,6EAA6E,4DAA4D,6DAA6D,yDAAyD,aAAa,iEAAiE,6BAA6B,iEAAiE,6BAA6B,iEAAiE,6BAA6B,gEAAgE,gCAAgC,2BAA2B,GAAG,2BAA2B,wDAAwD,WAAW,mBAAmB,4BAA4B,4BAA4B,oBAAoB,iBAAiB,MAAM,mCAAmC,uEAAuE,yBAAyB,KAAK,6CAA6C,GAAG,qCAAqC,wDAAwD,WAAW,mBAAmB,4BAA4B,4BAA4B,oBAAoB,iBAAiB,MAAM,mCAAmC,iEAAiE,KAAK,oDAAoD,GAAG,mBAAmB,kCAAkC,GAAG;;AAE5yP,0DAA0D,0CAA0C,GAAG,mDAAmD,6CAA6C,GAAG;;AAE1M,uDAAuD,mEAAmE,2EAA2E,iFAAiF,qDAAqD,sBAAsB,yDAAyD,GAAG,sFAAsF,uGAAuG,oCAAoC,GAAG,uDAAuD,sFAAsF,4EAA4E,aAAa,sDAAsD,+CAA+C,oCAAoC,GAAG,0CAA0C,6CAA6C,GAAG;;AAE7kC,sDAAsD,wBAAwB,uHAAuH,uCAAuC,6BAA6B,wBAAwB,iBAAiB,MAAM,mDAAmD,yBAAyB,cAAc,OAAO,KAAK,+DAA+D,8EAA8E,yCAAyC,kDAAkD,OAAO,qCAAqC,kDAAkD,OAAO,qCAAqC,kDAAkD,OAAO,YAAY,kDAAkD,OAAO,aAAa,oDAAoD,uCAAuC,iEAAiE,kCAAkC,KAAK,GAAG;;AAEjmC,uEAAuE,yCAAyC,uIAAuI,iCAAiC,qBAAqB,GAAG;;AAEhT,iGAAiG,wDAAwD,uDAAuD,yFAAyF,aAAa,8EAA8E,kDAAkD,4BAA4B,iCAAiC,yDAAyD,yFAAyF,aAAa,kEAAkE,iEAAiE,GAAG,kEAAkE,iEAAiE,GAAG,8EAA8E,wEAAwE,uIAAuI,2DAA2D,GAAG,8EAA8E,2HAA2H,2DAA2D,GAAG;;AAEhgD,oHAAoH,kDAAkD,6BAA6B,+BAA+B,GAAG,qFAAqF,wEAAwE,uIAAuI,kEAAkE,GAAG,yEAAyE,wEAAwE,GAAG;;AAEluB,yHAAyH,iDAAiD,wDAAwD,GAAG,+EAA+E,sGAAsG,GAAG,mFAAmF,4IAA4I,GAAG;;AAE/nB,0HAA0H,uCAAuC,iCAAiC,6CAA6C,kEAAkE,kEAAkE,+DAA+D,4CAA4C,kCAAkC,kCAAkC,qCAAqC,wDAAwD,GAAG,+EAA+E,sGAAsG,GAAG,mFAAmF,4IAA4I,GAAG;;AAE5hC,wDAAwD,2CAA2C,GAAG,+EAA+E,uGAAuG,oCAAoC,GAAG,4FAA4F,6BAA6B,+CAA+C,kDAAkD,mCAAmC,uCAAuC,uCAAuC,yBAAyB,gCAAgC,oBAAoB,gCAAgC,gCAAgC,qCAAqC,6BAA6B,gCAAgC,gCAAgC,qCAAqC,6BAA6B,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2DAA2D,2DAA2D,2DAA2D,2DAA2D,uBAAuB,eAAe,GAAG,uEAAuE,qDAAqD,GAAG,2EAA2E,yDAAyD,GAAG,4FAA4F,sBAAsB,oCAAoC,uCAAuC,iEAAiE,iEAAiE,iEAAiE,oEAAoE,+EAA+E,+EAA+E,sBAAsB,oFAAoF,oFAAoF,oFAAoF,oFAAoF,mDAAmD,GAAG,kEAAkE,oCAAoC,yCAAyC,yBAAyB,wBAAwB,qBAAqB,2FAA2F,2FAA2F,2FAA2F,2FAA2F,0EAA0E,2FAA2F,2FAA2F,2FAA2F,2FAA2F,mEAAmE,GAAG,iEAAiE,qDAAqD,GAAG,qEAAqE,yDAAyD,GAAG,qFAAqF,6BAA6B,yBAAyB,kCAAkC,kCAAkC,iCAAiC,qDAAqD,+BAA+B,+BAA+B,6BAA6B,MAAM,sDAAsD,+BAA+B,+BAA+B,6BAA6B,KAAK,wFAAwF,wDAAwD,wDAAwD,wBAAwB,wBAAwB,uBAAuB,uBAAuB,sBAAsB,qBAAqB,4EAA4E,sEAAsE,4EAA4E,sEAAsE,gEAAgE,sEAAsE,4EAA4E,sEAAsE,4EAA4E,uEAAuE,+DAA+D,+DAA+D,+DAA+D,kEAAkE,wDAAwD,+EAA+E,+EAA+E,sBAAsB,oFAAoF,oFAAoF,oFAAoF,oFAAoF,yDAAyD,GAAG,wEAAwE,gEAAgE,GAAG;;AAEzhN,iGAAiG,6BAA6B,+CAA+C,kDAAkD,mCAAmC,uCAAuC,uCAAuC,yBAAyB,gCAAgC,gCAAgC,oBAAoB,gCAAgC,2CAA2C,+BAA+B,6BAA6B,gCAAgC,oBAAoB,gCAAgC,2CAA2C,+BAA+B,6BAA6B,oBAAoB,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,wBAAwB,iCAAiC,wBAAwB,eAAe,GAAG,uEAAuE,qDAAqD,GAAG,2EAA2E,yDAAyD,GAAG;;AAEj5D,+EAA+E,4BAA4B,mCAAmC,iDAAiD,iEAAiE,GAAG,gCAAgC,mCAAmC,GAAG,uGAAuG,uCAAuC,uEAAuE,8CAA8C,GAAG,+EAA+E,iGAAiG,GAAG,mFAAmF,uIAAuI,GAAG;;AAE/9B,oEAAoE,uCAAuC,GAAG,uDAAuD,sCAAsC,GAAG,wGAAwG,yDAAyD,0CAA0C,+BAA+B,iDAAiD,6DAA6D,4CAA4C,GAAG,6EAA6E,sBAAsB,0CAA0C,iFAAiF,4BAA4B,wDAAwD,iDAAiD,2EAA2E,GAAG;;AAEtgC,2DAA2D,2CAA2C,wCAAwC,wCAAwC,8CAA8C,8CAA8C,6HAA6H,GAAG;;AAElZ,yDAAyD,0CAA0C,mCAAmC,wCAAwC,sBAAsB,qCAAqC,qCAAqC,4BAA4B,8CAA8C,uBAAuB,kEAAkE,kEAAkE,kEAAkE,6HAA6H,GAAG;;AAErrB,qDAAqD,oCAAoC,2CAA2C,+EAA+E,mCAAmC,yCAAyC,yCAAyC,GAAG,oEAAoE,oBAAoB,yCAAyC,oBAAoB,yCAAyC,oBAAoB,yCAAyC,oBAAoB,yCAAyC,gFAAgF,gFAAgF,gFAAgF,wCAAwC,+HAA+H,GAAG;;AAE7hC,mDAAmD,oCAAoC,0CAA0C,mCAAmC,+EAA+E,sBAAsB,qCAAqC,qCAAqC,4BAA4B,8CAA8C,uBAAuB,6DAA6D,6DAA6D,6DAA6D,GAAG,oEAAoE,oBAAoB,yCAAyC,oBAAoB,yCAAyC,oBAAoB,yCAAyC,oBAAoB,yCAAyC,gFAAgF,gFAAgF,gFAAgF,wCAAwC,+HAA+H,GAAG;;AAEh0C,yCAAyC,qCAAqC,yBAAyB,mBAAmB,+CAA+C,4CAA4C,qFAAqF,sFAAsF,GAAG;;AAEnY,yCAAyC,sCAAsC,mBAAmB,sBAAsB,kBAAkB,6GAA6G,2BAA2B,sCAAsC,oCAAoC,GAAG;;AAE/V,yCAAyC,mEAAmE,+CAA+C,qCAAqC,wBAAwB,mBAAmB,4BAA4B,+CAA+C,wEAAwE,4CAA4C,iDAAiD,GAAG;;AAE9d,kEAAkE,mEAAmE,iCAAiC,6BAA6B,yDAAyD,2FAA2F,6EAA6E,aAAa;;AAEjb,gEAAgE,iBAAiB,GAAG;;AAEpF,mEAAmE,oDAAoD,uDAAuD,yDAAyD,GAAG;;AAE1O,uEAAuE,oDAAoD,uDAAuD,2BAA2B,GAAG;;AAEhN,6GAA6G,wDAAwD,0EAA0E,GAAG;;AAElP,gCAAgC,4BAA4B,6BAA6B,0BAA0B,2BAA2B,kDAAkD,2BAA2B;;AAE3N,gCAAgC,gCAAgC;;AAEhE,+CAA+C,0CAA0C;;AAEzF,2EAA2E,4DAA4D,wDAAwD,2HAA2H,wDAAwD,wEAAwE,0CAA0C;;AAEpe,iDAAiD,4BAA4B,gCAAgC,oDAAoD;;AAEjK,4CAA4C,yDAAyD,GAAG,sBAAsB,yDAAyD,GAAG,2BAA2B,oDAAoD,GAAG;;AAE5Q,4BAA4B,wFAAwF,GAAG;;AAEvH,8CAA8C,iBAAiB,kBAAkB,kCAAkC,kCAAkC,2BAA2B,2BAA2B,gDAAgD,gDAAgD,iDAAiD,iDAAiD,4CAA4C,mEAAmE,0DAA0D,GAAG;;AAEzjB,gCAAgC,uDAAuD,GAAG;;AAE1F,uCAAuC,oDAAoD,sCAAsC,2BAA2B,gFAAgF,yCAAyC,6CAA6C,mCAAmC,OAAO,8CAA8C,6CAA6C,mCAAmC,OAAO,8CAA8C,6CAA6C,mCAAmC,OAAO,KAAK,uEAAuE,GAAG;;AAErsB,gDAAgD,4BAA4B,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,8BAA8B,0CAA0C,GAAG;;AAE3P,iDAAiD,8HAA8H,sIAAsI,6BAA6B,+CAA+C,uDAAuD,iBAAiB,GAAG,4BAA4B,sBAAsB,iCAAiC,gCAAgC,kCAAkC,mCAAmC,iBAAiB,GAAG;;AAExpB,gDAAgD,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,yBAAyB,kCAAkC,mDAAmD,GAAG,4BAA4B,gDAAgD,2DAA2D,+BAA+B,iBAAiB,GAAG;;AAEre,gDAAgD,4BAA4B,sBAAsB,qEAAqE,2BAA2B,mDAAmD,yIAAyI,GAAG;;AAEjY,kDAAkD,4BAA4B,4BAA4B,GAAG;;AAE7G,mDAAmD,iBAAiB,GAAG;;AAEvE,8DAA8D,wDAAwD,+BAA+B,uEAAuE,gCAAgC,qCAAqC,2CAA2C,8CAA8C,0DAA0D,+DAA+D,oFAAoF,GAAG,2FAA2F,iCAAiC,oEAAoE,uGAAuG,6GAA6G,iCAAiC,aAAa,sBAAsB,oCAAoC,oCAAoC,mDAAmD,8EAA8E,+EAA+E,sHAAsH,wEAAwE,wBAAwB,4BAA4B,0GAA0G,oDAAoD,oDAAoD,oDAAoD,uFAAuF,oDAAoD,oDAAoD,oDAAoD,yGAAyG,6DAA6D,yBAAyB,6DAA6D,mDAAmD,oCAAoC,mBAAmB,kFAAkF,oDAAoD,sDAAsD,4EAA4E,mCAAmC,uCAAuC,mCAAmC,8CAA8C,yCAAyC,GAAG,2BAA2B,sBAAsB,GAAG;;AAE94F,sDAAsD,4BAA4B,qCAAqC,kBAAkB,oBAAoB;;AAE7J,+CAA+C,iCAAiC,8EAA8E,+EAA+E,6GAA6G,yBAAyB,0CAA0C,gCAAgC,cAAc,GAAG,wBAAwB,4BAA4B,GAAG;;AAErgB,4BAA4B,4BAA4B,GAAG;;AAE3D,oCAAoC,sDAAsD,GAAG;;AAE7F,qFAAqF,gCAAgC,wCAAwC,GAAG;;AAEhK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uDAAuD;;AAEvD;AACA,2EAA2E;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,0BAA0B;AACpD;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,wCAAwC;AACxC,gCAAgC;AAChC;;AAEA;AACA,4CAA4C;AAC5C,8BAA8B;AAC9B;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA,yCAAyC;;AAEzC;AACA,yFAAyF;AACzF;;AAEA;AACA,oCAAoC;AACpC;;AAEA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,IAAI;AACJ,gCAAgC;AAChC;;AAEA;AACA,8BAA8B;AAC9B,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;;AAEA;AACA,oCAAoC;AACpC,IAAI;AACJ,oCAAoC;AACpC;;AAEA;AACA,kEAAkE;AAClE;;AAEA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA,gDAAgD;AAChD,KAAK;AACL;AACA,2DAA2D;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,gEAAgE;AAChE,qEAAqE;AACrE,mEAAmE;AACnE,8DAA8D;AAC9D,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;;AAEf;AACA;AACA,sCAAsC;AACtC,KAAK;AACL,2CAA2C;AAC3C;;AAEA,2CAA2C;AAC3C;;AAEA,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA,sEAAsE;AACtE;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,aAAa,GAAG,aAAa,GAAG,YAAY,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,cAAc,GAAG,qBAAqB,GAAG,YAAY,cAAc,aAAa,GAAG,iBAAiB,GAAG,qBAAqB,GAAG,cAAc,GAAG,oBAAoB;AAC9S,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA,IAAI;AACJ,sBAAsB,UAAU;AAChC,oBAAoB,yBAAyB;AAC7C;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,UAAU,GAAG,OAAO;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;;AAEnC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,UAAU;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,QAAQ;AACR,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO,EAAE,KAAK,EAAE,YAAY;AACnD,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,QAAQ;;AAE1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,oBAAoB,YAAY;;AAEhC;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA,6BAA6B,KAAK;AAClC;AACA,8BAA8B,QAAQ,EAAE;AACxC,8BAA8B,QAAQ,EAAE;;AAExC;AACA,kCAAkC,GAAG,GAAG,IAAI;AAC5C,uBAAuB,GAAG,GAAG,IAAI,oBAAoB,GAAG,QAAQ,QAAQ,iBAAiB,GAAG,QAAQ,QAAQ,IAAI;AAChH;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA,0CAA0C,WAAW,6BAA6B,WAAW,gCAAgC,WAAW,qBAAqB;AAC7J,2CAA2C,eAAe,EAAE;AAC5D;;AAEA;AACA,6BAA6B,WAAW,yBAAyB;AACjE;AACA,EAAE;AACF;AACA,8BAA8B,aAAa,IAAI,eAAe,EAAE;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA,sEAAsE;AACtE,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,uCAAuC;AACvC,uCAAuC;AACvC;;AAEA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,2CAA2C;AAC3C,8CAA8C;AAC9C,+BAA+B;AAC/B,yDAAyD;AACzD,yBAAyB;AACzB,aAAa;AACb;;AAEA;;AAEA;AACA,2BAA2B;AAC3B,gCAAgC;AAChC;;AAEA;;AAEA;AACA,6FAA6F;AAC7F,IAAI;AACJ,2CAA2C;AAC3C;;AAEA;AACA;AACA,wDAAwD,0CAA0C;AAClG,+GAA+G;AAC/G,+CAA+C;AAC/C,KAAK;AACL,+CAA+C;AAC/C;AACA,IAAI;AACJ,uCAAuC;;AAEvC;AACA,oCAAoC;AACpC;AACA,IAAI;AACJ,oFAAoF;AACpF,IAAI;AACJ;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;;AAElD;AACA,iCAAiC;AACjC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,uCAAuC;AACvC;AACA,qFAAqF;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C,8CAA8C;AAC9C,KAAK;AACL;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA,uDAAuD;AACvD;;AAEA;AACA,8CAA8C;AAC9C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mGAAmG;AACnG;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B;AAC5B,iCAAiC;AACjC;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iCAAiC;AACjC;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B;AAC5B,iCAAiC;AACjC;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE,oEAAoE;AACpE;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA,mDAAmD;AACnD,KAAK;AACL,kDAAkD;AAClD,iDAAiD;;AAEjD;AACA,oDAAoD;AACpD,0DAA0D;AAC1D,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA,mDAAmD;AACnD,oDAAoD;AACpD;;AAEA;AACA,sDAAsD;;AAEtD;AACA,iEAAiE;AACjE,qEAAqE;AACrE,8DAA8D;AAC9D;;AAEA;AACA,uDAAuD;AACvD,MAAM;AACN;AACA,uDAAuD;AACvD;;AAEA;AACA,2DAA2D;AAC3D,MAAM;AACN;AACA,gEAAgE;AAChE,OAAO;AACP,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD,4DAA4D;AAC5D,oGAAoG;AACpG;AACA,MAAM;AACN;AACA,uDAAuD;AACvD,4DAA4D;AAC5D,oGAAoG;;AAEpG;AACA,yDAAyD;AACzD,yDAAyD;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS,eAAe,SAAS;;AAEhF;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4EAA4E;;AAE5E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sFAAsF;AACtF;;AAEA;AACA;AACA;AACA,oJAAoJ;AACpJ,MAAM;AACN,qDAAqD;AACrD;AACA,KAAK;AACL;AACA,yIAAyI;AACzI,MAAM;AACN,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA,sIAAsI;AACtI,yIAAyI;AACzI,MAAM;AACN,sCAAsC;AACtC,wCAAwC;AACxC;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B;AAC3B,IAAI;AACJ;AACA;AACA,KAAK;AACL,4BAA4B;;AAE5B;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B;;AAE3B;AACA,wBAAwB;AACxB;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA,4BAA4B;;AAE5B;AACA,kCAAkC;AAClC;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA,4BAA4B;AAC5B;AACA;;AAEA,yBAAyB;;AAEzB;AACA,6BAA6B;AAC7B,uCAAuC;AACvC,mCAAmC;AACnC;;AAEA;AACA,+BAA+B;AAC/B,wDAAwD;;AAExD;AACA;AACA,iDAAiD;AACjD;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA,yDAAyD;AACzD;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;;AAEA;AACA,wBAAwB;AACxB;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA,+BAA+B;AAC/B;;AAEA;AACA,iDAAiD;AACjD,+CAA+C;AAC/C,8CAA8C;AAC9C,uFAAuF;AACvF,oCAAoC;AACpC;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iIAAiI;AACjI;;AAEA;AACA,0DAA0D;AAC1D,6BAA6B;AAC7B,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;;AAEA;AACA;AACA,mVAAmV;AACnV,QAAQ;AACR,2JAA2J;AAC3J;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA,QAAQ;AACR,uEAAuE;AACvE;AACA;AACA,OAAO;AACP,kEAAkE;AAClE;AACA;;AAEA,uCAAuC;;AAEvC;AACA;AACA,oIAAoI;AACpI;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C,OAAO;AACP,yEAAyE;AACzE;AACA,MAAM;AACN,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,kFAAkF;;AAElF;AACA,0EAA0E;AAC1E;;AAEA;AACA,QAAQ;AACR,oCAAoC,EAAE;AACtC,sCAAsC,EAAE;AACxC;AACA;AACA,iKAAiK;AACjK;AACA;AACA;;AAEA;AACA;AACA,qJAAqJ;AACrJ,OAAO;AACP,yHAAyH;AACzH;AACA,MAAM;AACN;AACA,yIAAyI;AACzI,OAAO;AACP,6GAA6G;AAC7G;AACA;;AAEA;AACA,mMAAmM;AACnM,6LAA6L;AAC7L,MAAM;AACN;AACA,iLAAiL;AACjL,2KAA2K;AAC3K,OAAO;AACP,iKAAiK;AACjK,4JAA4J;AAC5J;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA,oIAAoI;AACpI,oKAAoK;AACpK,2EAA2E;AAC3E;;AAEA,yCAAyC;AACzC;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,qDAAqD;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oEAAoE;AACpE,sDAAsD;AACtD,4DAA4D;AAC5D,gEAAgE;AAChE,8DAA8D;AAC9D,0EAA0E;AAC1E,gEAAgE;AAChE,kEAAkE;AAClE,gEAAgE;AAChE,gEAAgE;AAChE,wEAAwE;AACxE,0EAA0E;AAC1E,0EAA0E;AAC1E,kEAAkE;AAClE,kEAAkE;AAClE,sEAAsE;AACtE,kEAAkE;AAClE,sEAAsE;AACtE,kFAAkF;AAClF,gEAAgE;AAChE,qEAAqE;AACrE,2DAA2D;AAC3D,2DAA2D;AAC3D,6DAA6D;AAC7D,4DAA4D;AAC5D,qDAAqD;AACrD,wDAAwD;AACxD,sEAAsE;AACtE,gEAAgE;AAChE,kEAAkE;AAClE,4EAA4E;AAC5E,yEAAyE;AACzE,qFAAqF;AACrF,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,gCAAgC,WAAW,GAAG,kBAAkB;AAChE;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA,8BAA8B,WAAW,GAAG,cAAc;AAC1D;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA,4BAA4B,WAAW,GAAG,cAAc,GAAG,kBAAkB;AAC7E;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C,6BAA6B,kBAAkB;AAC/C,6BAA6B,qCAAqC;AAClE,mCAAmC,qCAAqC;AACxE;AACA,sBAAsB,YAAY,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW;AACxG;AACA;;AAEA;AACA,0CAA0C,YAAY,6BAA6B,WAAW,6BAA6B,WAAW,6BAA6B,WAAW,6BAA6B,WAAW,6BAA6B,WAAW;AAC9P;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAmD,QAAQ,IAAI,yBAAyB;AACxF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,8BAA8B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;;AAEA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;;AAEA,mBAAmB,iCAAiC;AACpD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,4BAA4B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qIAAqI;;AAErI;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,UAAU;;AAEpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,UAAU;;AAEpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;;AAEF;AACA;AACA,YAAY,KAAK;AACjB;AACA,GAAG;AACH;;AAEA;AACA;AACA,YAAY,KAAK;AACjB;AACA,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB;AACA,GAAG;AACH;;AAEA,sBAAsB,KAAK;AAC3B,sBAAsB,KAAK;AAC3B,wBAAwB,KAAK;AAC7B,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA,IAAI;AACJ,qBAAqB,aAAa;AAClC;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE,0EAA0E;AAC1E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,yFAAyF,MAAM,MAAM,KAAK;AAC1G;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,2GAA2G;AAC3G;AACA;;AAEA,kBAAkB,qCAAqC;AACvD;AACA;;AAEA,eAAe;AACf,iDAAiD;AACjD;AACA,uHAAuH;AACvH;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,uBAAuB;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,iCAAiC;AACvD,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,8BAA8B;AACjD;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,YAAY,aAAa,QAAQ,IAAI,KAAK;AAClF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C,UAAU;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA,iBAAiB,cAAc;AAC/B,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,UAAU;AAC9B,kBAAkB,cAAc;AAChC,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,WAAW;AAC/B;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,sBAAsB,eAAe;AACrC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,mBAAmB,mCAAmC;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,qBAAqB;AACzC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,qBAAqB;AACzC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mCAAmC;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,+BAA+B;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,6BAA6B;AAChD;AACA;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;;AAEA,mBAAmB,+BAA+B;AAClD;AACA;;AAEA,mBAAmB,8BAA8B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,+BAA+B;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,cAAc;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,oCAAoC;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,gCAAgC;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC,yBAAyB,WAAW;AACpC,0BAA0B,WAAW;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4HAA4H,OAAO;AACnI;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sBAAsB,kBAAkB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA,uBAAuB,oBAAoB;AAC3C,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,UAAU,GAAG,WAAW,GAAG,WAAW;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,6CAA6C,iCAAiC;AAC9E,qBAAqB,mBAAmB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,aAAa;AACjC;AACA;;AAEA;AACA;;AAEA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,+CAA+C;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;;AAEA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;;AAEA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,QAAQ;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,6BAA6B;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG,IAAI;AACJ;AACA;AACA;AACA,kHAAkH;AAClH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,2BAA2B;;AAEjD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,kCAAkC;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sDAAsD;AAC7E;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;;AAEA,mBAAmB,wBAAwB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA,mBAAmB,4BAA4B;AAC/C;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,4DAA4D;AACnG;;AAEA,kBAAkB,iBAAiB;AACnC,qEAAqE;AACrE;;AAEA,uCAAuC,6CAA6C;;AAEpF,kBAAkB,iBAAiB;AACnC,yGAAyG;AACzG;;AAEA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,gCAAgC;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,uBAAuB;AAC7C,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,SAAS;AACpE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;;AAEA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,yCAAyC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,oBAAoB;AAClC;AACA;;AAEA,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,aAAa,kCAAkC;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA,cAAc,yCAAyC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,iBAAiB;AAChC,gBAAgB,UAAU;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,eAAe;AAC7B,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,cAAc,eAAe;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;;AAEA;AACA,0EAA0E,0EAA0E,wCAAwC,wBAAwB,+DAA+D,6FAA6F,kFAAkF,oDAAoD,mCAAmC,KAAK;AAC9hB,2EAA2E,6EAA6E,yCAAyC,+BAA+B,mEAAmE,mGAAmG,mFAAmF,yFAAyF,iBAAiB;AACnkB,6FAA6F,mFAAmF,iDAAiD,yBAAyB,0EAA0E,uGAAuG,mFAAmF,sDAAsD,oCAAoC,KAAK;AAC7lB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mCAAmC;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,uBAAuB;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAmB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;;AAEA,mBAAmB,8BAA8B;AACjD;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,WAAW;AAC7B;;AAEA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qFAAqF,mBAAmB;AACxG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,6BAA6B;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,MAAM;AACN,KAAK;AACL,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,cAAc,GAAG,IAAI;AACvE,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,cAAc,GAAG,IAAI;AAC5E,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;;AAEA,oBAAoB,kCAAkC;AACtD;;AAEA;AACA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,cAAc,GAAG,IAAI;AACnF,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,IAAI;AACJ;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,+CAA+C,cAAc,GAAG,IAAI;AACpE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,qBAAqB;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,4CAA4C,cAAc,GAAG,IAAI;AACjE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,kBAAkB,sCAAsC;AACxD;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;;AAEA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG,IAAI;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,MAAM;AACN,8CAA8C,cAAc,GAAG,IAAI;AACnE;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,+BAA+B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,kCAAkC;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,cAAc,GAAG,IAAI;AAC9D;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,qBAAqB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;AACA;;AAEA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA,eAAe,0BAA0B;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,0BAA0B;AACzC;AACA;;AAEA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,oCAAoC;AAClF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,uBAAuB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA,gBAAgB,kCAAkC;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,iBAAiB,gCAAgC;AACjD;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,eAAe,uBAAuB;AACtC;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,8BAA8B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAc,4BAA4B;AAC1C;AACA;;AAEA,eAAe,yCAAyC;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,6BAA6B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,6BAA6B;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,0BAA0B;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,qCAAqC,cAAc,GAAG,IAAI;AAC1D;AACA,GAAG;AACH;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,gCAAgC;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,gCAAgC;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAE;AACF,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,MAAM;AACN;;AAEA,qBAAqB,iCAAiC;;AAEtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,+CAA+C,cAAc,GAAG,IAAI;AACpE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,KAAK,QAAQ,OAAO,SAAS,QAAQ,SAAS,OAAO;AACxG;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,KAAK,QAAQ,OAAO,SAAS,QAAQ,SAAS,QAAQ,SAAS,OAAO;AACzH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,IAAI;AAC5D,KAAK;AACL,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA,+CAA+C,WAAW;AAC1D;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gDAAgD,YAAY,kBAAkB,WAAW;AACzF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL,6CAA6C,YAAY;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,kDAAkD;AAC9E;;AAEA;AACA;AACA;;AAEA;;AAEA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oCAAoC;AACtD;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC,mBAAmB,kBAAkB;AACrC,oBAAoB,OAAO;AAC3B;;AAEA,sBAAsB,SAAS;AAC/B,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,2BAA2B;AACrE;AACA;;AAEA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,sCAAsC;AAC3D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,kCAAkC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,OAAO;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,UAAU;AAC3C,IAAI;AACJ;;AAEA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,gBAAgB;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gBAAgB,uBAAuB,IAAI;AAChE;;AAEA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,KAAK;AACxB;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,WAAW,uBAAuB,IAAI;AAC7D;AACA;;AAEA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD,EAAE,EAAE,IAAI;AAClE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;;AAEA,qBAAqB,SAAS;;AAE9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,8BAA8B;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,8BAA8B;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,WAAW,gCAAgC,iBAAiB;AACvF,IAAI;AACJ;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,kDAAkD,WAAW;AAC7D;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,0CAA0C;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,mBAAmB,4BAA4B;;AAE/C,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,0CAA0C,SAAS;AACnD;;AAEA;AACA,sDAAsD,EAAE;AACxD;;AAEA;AACA,sDAAsD,EAAE;AACxD;;AAEA;AACA,8CAA8C,EAAE;AAChD;;AAEA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,UAAU;AACjD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,qBAAqB;AACzC;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,gBAAgB,wBAAwB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,oCAAoC;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,mBAAmB,mCAAmC;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA,IAAI;AACJ,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,aAAa;AAC/B,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,8DAA8D,GAAG,UAAU,GAAG,oEAAoE;AAC9J;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,kBAAkB;AACzC,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,6DAA6D,qDAAqD;AAClH;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,mCAAmC;AACtD;AACA;;AAEA;AACA;AACA,IAAI;AACJ,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mCAAmC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qCAAqC;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,gCAAgC;AACtD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kCAAkC;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sBAAsB,EAAE,EAAE,EAAE;;AAE5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,EAAE,EAAE,EAAE;;AAE5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;;AAEA;AACA,wCAAwC;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,uCAAuC;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,uCAAuC;AACzD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kCAAkC;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA,mBAAmB,2CAA2C;AAC9D;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mCAAmC;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,2CAA2C;AAC/D;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;AACA;;AAEA;AACA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,UAAU,GAAG,UAAU;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,8BAA8B;AAChD;;AAEA,wCAAwC;AACxC;;AAEA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,qCAAqC;;AAErC,kBAAkB,yBAAyB;AAC3C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL,IAAI;AACJ,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,uCAAuC;AACzD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uCAAuC;AACzD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,mBAAmB,4BAA4B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,GAAG;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD,GAAG;AACnD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR,uBAAuB,EAAE,EAAE,EAAE;AAC7B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,8DAA8D,KAAK;AACnE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;;AAEA,yBAAyB,UAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oDAAoD,SAAS;AAC7D;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,2CAA2C,2BAA2B;AACtE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mCAAmC;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,4BAA4B;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;;AAEA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD,YAAY;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;;AAEA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,IAAI;AACJ,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;;AAEA;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAmB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;;AAEA;AACA,qBAAqB,mBAAmB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,qCAAqC;AACnE;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,SAAS;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC,wBAAwB,OAAO;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,cAAc;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;;AAEA;AACA,sBAAsB,iBAAiB;AACvC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,SAAS;AAC1D;AACA;AACA;;AAEA;AACA,iCAAiC,0CAA0C;AAC3E;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C,SAAS;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,KAAK,mBAAmB,IAAI,SAAS,wCAAwC,GAAG,EAAE,kBAAkB;AAC9I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC,oCAAoC;AACpC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,yCAAyC;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,SAAS;AAC3D;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;;AAEA;;AAEA;AACA,mBAAmB,kCAAkC;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,KAAK,WAAW,WAAW;AAChE;;AAEA;AACA;;AAEA;AACA;AACA,yDAAyD,+CAA+C;AACxG,kCAAkC,gDAAgD;AAClF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,2FAA2F,wBAAwB;AACnH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,sBAAsB;AACpC;AACA;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,sCAAsC;AACzE;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,0BAA0B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,QAAQ;AAC3C,IAAI;AACJ,gBAAgB,EAAE,IAAI,EAAE,IAAI,EAAE;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B,qBAAqB;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qEAAqE,KAAK;;AAE1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA,qEAAqE,OAAO;AAC5E,kFAAkF,mCAAmC;AACrH;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,gBAAgB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,gBAAgB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,+CAA+C,SAAS;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+CAA+C,SAAS;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,OAAO;AAClD;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,OAAO;AACpD;AACA;;AAEA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4DAA4D,KAAK;AACjE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC;AACD;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC;AACD;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2CAA2C,OAAO;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2CAA2C,OAAO;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEiqd;;;;;;;UCp3vEjqd;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://dmdassc-game/./node_modules/@socket.io/component-emitter/index.js","webpack://dmdassc-game/./node_modules/backo2/index.js","webpack://dmdassc-game/./node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","webpack://dmdassc-game/./node_modules/debug/src/browser.js","webpack://dmdassc-game/./node_modules/debug/src/common.js","webpack://dmdassc-game/./node_modules/has-cors/index.js","webpack://dmdassc-game/./node_modules/matter-js/build/matter.js","webpack://dmdassc-game/./node_modules/ms/index.js","webpack://dmdassc-game/./node_modules/parseqs/index.js","webpack://dmdassc-game/./node_modules/parseuri/index.js","webpack://dmdassc-game/./index/index.ts","webpack://dmdassc-game/./src/client/camera.ts","webpack://dmdassc-game/./src/client/gameface.ts","webpack://dmdassc-game/./src/client/network.ts","webpack://dmdassc-game/./src/client/playcanvas/scripts/textScript.ts","webpack://dmdassc-game/./src/client/render.ts","webpack://dmdassc-game/./src/client/ui/ui.ts","webpack://dmdassc-game/./src/shared/component/collisionComponent.ts","webpack://dmdassc-game/./src/shared/component/component.ts","webpack://dmdassc-game/./src/shared/component/debugComponent.ts","webpack://dmdassc-game/./src/shared/component/npcBehaviourComponent.ts","webpack://dmdassc-game/./src/shared/component/playerComponent.ts","webpack://dmdassc-game/./src/shared/component/syncComponent.ts","webpack://dmdassc-game/./src/shared/component/transformComponent.ts","webpack://dmdassc-game/./src/shared/entityFactory.ts","webpack://dmdassc-game/./src/shared/entity/entity.ts","webpack://dmdassc-game/./src/shared/entity/entityChar.ts","webpack://dmdassc-game/./src/shared/entity/entityObject.ts","webpack://dmdassc-game/./src/shared/entity/entityPlayer.ts","webpack://dmdassc-game/./src/shared/eventEmitter.ts","webpack://dmdassc-game/./src/shared/game.ts","webpack://dmdassc-game/./src/shared/input.ts","webpack://dmdassc-game/./src/shared/inventoryManager.ts","webpack://dmdassc-game/./src/shared/packet.ts","webpack://dmdassc-game/./src/shared/world.ts","webpack://dmdassc-game/./src/shared/worldEvent.ts","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/index.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/md5.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/nil.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/parse.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/regex.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/rng.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/sha1.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v1.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v3.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v35.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v4.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v5.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/validate.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/version.js","webpack://dmdassc-game/./node_modules/yeast/index.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/globalThis.browser.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/index.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/socket.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transport.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/index.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/polling-xhr.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/polling.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/websocket.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/util.js","webpack://dmdassc-game/./node_modules/engine.io-parser/build/cjs/commons.js","webpack://dmdassc-game/./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js","webpack://dmdassc-game/./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js","webpack://dmdassc-game/./node_modules/engine.io-parser/build/cjs/index.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/index.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/manager.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/on.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/socket.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/url.js","webpack://dmdassc-game/./node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/binary.js","webpack://dmdassc-game/./node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/index.js","webpack://dmdassc-game/./node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/is-binary.js","webpack://dmdassc-game/./node_modules/playcanvas/build/playcanvas.mjs","webpack://dmdassc-game/webpack/bootstrap","webpack://dmdassc-game/webpack/runtime/define property getters","webpack://dmdassc-game/webpack/runtime/global","webpack://dmdassc-game/webpack/runtime/hasOwnProperty shorthand","webpack://dmdassc-game/webpack/runtime/make namespace object","webpack://dmdassc-game/webpack/before-startup","webpack://dmdassc-game/webpack/startup","webpack://dmdassc-game/webpack/after-startup"],"sourcesContent":["\n/**\n * Expose `Emitter`.\n */\n\nexports.Emitter = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n","\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n","/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = typeof XMLHttpRequest !== 'undefined' &&\n    'withCredentials' in new XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n","/*!\n * matter-js 0.17.1 by @liabru\n * http://brm.io/matter-js/\n * License MIT\n * \n * The MIT License (MIT)\n * \n * Copyright (c) Liam Brummitt and contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Matter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Matter\"] = factory();\n\telse\n\t\troot[\"Matter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 22);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Common` module contains utility functions that are common to all modules.\n*\n* @class Common\n*/\n\nvar Common = {};\n\nmodule.exports = Common;\n\n(function() {\n\n    Common._nextId = 0;\n    Common._seed = 0;\n    Common._nowStartTime = +(new Date());\n    Common._warnedOnce = {};\n    Common._decomp = null;\n    \n    /**\n     * Extends the object in the first argument using the object in the second argument.\n     * @method extend\n     * @param {} obj\n     * @param {boolean} deep\n     * @return {} obj extended\n     */\n    Common.extend = function(obj, deep) {\n        var argsStart,\n            args,\n            deepClone;\n\n        if (typeof deep === 'boolean') {\n            argsStart = 2;\n            deepClone = deep;\n        } else {\n            argsStart = 1;\n            deepClone = true;\n        }\n\n        for (var i = argsStart; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            if (source) {\n                for (var prop in source) {\n                    if (deepClone && source[prop] && source[prop].constructor === Object) {\n                        if (!obj[prop] || obj[prop].constructor === Object) {\n                            obj[prop] = obj[prop] || {};\n                            Common.extend(obj[prop], deepClone, source[prop]);\n                        } else {\n                            obj[prop] = source[prop];\n                        }\n                    } else {\n                        obj[prop] = source[prop];\n                    }\n                }\n            }\n        }\n        \n        return obj;\n    };\n\n    /**\n     * Creates a new clone of the object, if deep is true references will also be cloned.\n     * @method clone\n     * @param {} obj\n     * @param {bool} deep\n     * @return {} obj cloned\n     */\n    Common.clone = function(obj, deep) {\n        return Common.extend({}, deep, obj);\n    };\n\n    /**\n     * Returns the list of keys for the given object.\n     * @method keys\n     * @param {} obj\n     * @return {string[]} keys\n     */\n    Common.keys = function(obj) {\n        if (Object.keys)\n            return Object.keys(obj);\n\n        // avoid hasOwnProperty for performance\n        var keys = [];\n        for (var key in obj)\n            keys.push(key);\n        return keys;\n    };\n\n    /**\n     * Returns the list of values for the given object.\n     * @method values\n     * @param {} obj\n     * @return {array} Array of the objects property values\n     */\n    Common.values = function(obj) {\n        var values = [];\n        \n        if (Object.keys) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length; i++) {\n                values.push(obj[keys[i]]);\n            }\n            return values;\n        }\n        \n        // avoid hasOwnProperty for performance\n        for (var key in obj)\n            values.push(obj[key]);\n        return values;\n    };\n\n    /**\n     * Gets a value from `base` relative to the `path` string.\n     * @method get\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} The object at the given path\n     */\n    Common.get = function(obj, path, begin, end) {\n        path = path.split('.').slice(begin, end);\n\n        for (var i = 0; i < path.length; i += 1) {\n            obj = obj[path[i]];\n        }\n\n        return obj;\n    };\n\n    /**\n     * Sets a value on `base` relative to the given `path` string.\n     * @method set\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {} val The value to set\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} Pass through `val` for chaining\n     */\n    Common.set = function(obj, path, val, begin, end) {\n        var parts = path.split('.').slice(begin, end);\n        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\n        return val;\n    };\n\n    /**\n     * Shuffles the given array in-place.\n     * The function uses a seeded random generator.\n     * @method shuffle\n     * @param {array} array\n     * @return {array} array shuffled randomly\n     */\n    Common.shuffle = function(array) {\n        for (var i = array.length - 1; i > 0; i--) {\n            var j = Math.floor(Common.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n        return array;\n    };\n\n    /**\n     * Randomly chooses a value from a list with equal probability.\n     * The function uses a seeded random generator.\n     * @method choose\n     * @param {array} choices\n     * @return {object} A random choice object from the array\n     */\n    Common.choose = function(choices) {\n        return choices[Math.floor(Common.random() * choices.length)];\n    };\n\n    /**\n     * Returns true if the object is a HTMLElement, otherwise false.\n     * @method isElement\n     * @param {object} obj\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\n     */\n    Common.isElement = function(obj) {\n        if (typeof HTMLElement !== 'undefined') {\n            return obj instanceof HTMLElement;\n        }\n\n        return !!(obj && obj.nodeType && obj.nodeName);\n    };\n\n    /**\n     * Returns true if the object is an array.\n     * @method isArray\n     * @param {object} obj\n     * @return {boolean} True if the object is an array, otherwise false\n     */\n    Common.isArray = function(obj) {\n        return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n\n    /**\n     * Returns true if the object is a function.\n     * @method isFunction\n     * @param {object} obj\n     * @return {boolean} True if the object is a function, otherwise false\n     */\n    Common.isFunction = function(obj) {\n        return typeof obj === \"function\";\n    };\n\n    /**\n     * Returns true if the object is a plain object.\n     * @method isPlainObject\n     * @param {object} obj\n     * @return {boolean} True if the object is a plain object, otherwise false\n     */\n    Common.isPlainObject = function(obj) {\n        return typeof obj === 'object' && obj.constructor === Object;\n    };\n\n    /**\n     * Returns true if the object is a string.\n     * @method isString\n     * @param {object} obj\n     * @return {boolean} True if the object is a string, otherwise false\n     */\n    Common.isString = function(obj) {\n        return toString.call(obj) === '[object String]';\n    };\n    \n    /**\n     * Returns the given value clamped between a minimum and maximum value.\n     * @method clamp\n     * @param {number} value\n     * @param {number} min\n     * @param {number} max\n     * @return {number} The value clamped between min and max inclusive\n     */\n    Common.clamp = function(value, min, max) {\n        if (value < min)\n            return min;\n        if (value > max)\n            return max;\n        return value;\n    };\n    \n    /**\n     * Returns the sign of the given value.\n     * @method sign\n     * @param {number} value\n     * @return {number} -1 if negative, +1 if 0 or positive\n     */\n    Common.sign = function(value) {\n        return value < 0 ? -1 : 1;\n    };\n    \n    /**\n     * Returns the current timestamp since the time origin (e.g. from page load).\n     * The result is in milliseconds and will use high-resolution timing if available.\n     * @method now\n     * @return {number} the current timestamp in milliseconds\n     */\n    Common.now = function() {\n        if (typeof window !== 'undefined' && window.performance) {\n            if (window.performance.now) {\n                return window.performance.now();\n            } else if (window.performance.webkitNow) {\n                return window.performance.webkitNow();\n            }\n        }\n\n        if (Date.now) {\n            return Date.now();\n        }\n\n        return (new Date()) - Common._nowStartTime;\n    };\n    \n    /**\n     * Returns a random value between a minimum and a maximum value inclusive.\n     * The function uses a seeded random generator.\n     * @method random\n     * @param {number} min\n     * @param {number} max\n     * @return {number} A random number between min and max inclusive\n     */\n    Common.random = function(min, max) {\n        min = (typeof min !== \"undefined\") ? min : 0;\n        max = (typeof max !== \"undefined\") ? max : 1;\n        return min + _seededRandom() * (max - min);\n    };\n\n    var _seededRandom = function() {\n        // https://en.wikipedia.org/wiki/Linear_congruential_generator\n        Common._seed = (Common._seed * 9301 + 49297) % 233280;\n        return Common._seed / 233280;\n    };\n\n    /**\n     * Converts a CSS hex colour string into an integer.\n     * @method colorToNumber\n     * @param {string} colorString\n     * @return {number} An integer representing the CSS hex string\n     */\n    Common.colorToNumber = function(colorString) {\n        colorString = colorString.replace('#','');\n\n        if (colorString.length == 3) {\n            colorString = colorString.charAt(0) + colorString.charAt(0)\n                        + colorString.charAt(1) + colorString.charAt(1)\n                        + colorString.charAt(2) + colorString.charAt(2);\n        }\n\n        return parseInt(colorString, 16);\n    };\n\n    /**\n     * The console logging level to use, where each level includes all levels above and excludes the levels below.\n     * The default level is 'debug' which shows all console messages.  \n     *\n     * Possible level values are:\n     * - 0 = None\n     * - 1 = Debug\n     * - 2 = Info\n     * - 3 = Warn\n     * - 4 = Error\n     * @property Common.logLevel\n     * @type {Number}\n     * @default 1\n     */\n    Common.logLevel = 1;\n\n    /**\n     * Shows a `console.log` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method log\n     * @param ...objs {} The objects to log.\n     */\n    Common.log = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Shows a `console.info` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method info\n     * @param ...objs {} The objects to log.\n     */\n    Common.info = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\n            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method warn\n     * @param ...objs {} The objects to log.\n     */\n    Common.warn = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Uses `Common.warn` to log the given message one time only.\n     * @method warnOnce\n     * @param ...objs {} The objects to log.\n     */\n    Common.warnOnce = function() {\n        var message = Array.prototype.slice.call(arguments).join(' ');\n\n        if (!Common._warnedOnce[message]) {\n            Common.warn(message);\n            Common._warnedOnce[message] = true;\n        }\n    };\n\n    /**\n     * Shows a deprecated console warning when the function on the given object is called.\n     * The target function will be replaced with a new function that first shows the warning\n     * and then calls the original function.\n     * @method deprecated\n     * @param {object} obj The object or module\n     * @param {string} name The property name of the function on obj\n     * @param {string} warning The one-time message to show if the function is called\n     */\n    Common.deprecated = function(obj, prop, warning) {\n        obj[prop] = Common.chain(function() {\n            Common.warnOnce('🔅 deprecated 🔅', warning);\n        }, obj[prop]);\n    };\n\n    /**\n     * Returns the next unique sequential ID.\n     * @method nextId\n     * @return {Number} Unique sequential ID\n     */\n    Common.nextId = function() {\n        return Common._nextId++;\n    };\n\n    /**\n     * A cross browser compatible indexOf implementation.\n     * @method indexOf\n     * @param {array} haystack\n     * @param {object} needle\n     * @return {number} The position of needle in haystack, otherwise -1.\n     */\n    Common.indexOf = function(haystack, needle) {\n        if (haystack.indexOf)\n            return haystack.indexOf(needle);\n\n        for (var i = 0; i < haystack.length; i++) {\n            if (haystack[i] === needle)\n                return i;\n        }\n\n        return -1;\n    };\n\n    /**\n     * A cross browser compatible array map implementation.\n     * @method map\n     * @param {array} list\n     * @param {function} func\n     * @return {array} Values from list transformed by func.\n     */\n    Common.map = function(list, func) {\n        if (list.map) {\n            return list.map(func);\n        }\n\n        var mapped = [];\n\n        for (var i = 0; i < list.length; i += 1) {\n            mapped.push(func(list[i]));\n        }\n\n        return mapped;\n    };\n\n    /**\n     * Takes a directed graph and returns the partially ordered set of vertices in topological order.\n     * Circular dependencies are allowed.\n     * @method topologicalSort\n     * @param {object} graph\n     * @return {array} Partially ordered set of vertices in topological order.\n     */\n    Common.topologicalSort = function(graph) {\n        // https://github.com/mgechev/javascript-algorithms\n        // Copyright (c) Minko Gechev (MIT license)\n        // Modifications: tidy formatting and naming\n        var result = [],\n            visited = [],\n            temp = [];\n\n        for (var node in graph) {\n            if (!visited[node] && !temp[node]) {\n                Common._topologicalSort(node, visited, temp, graph, result);\n            }\n        }\n\n        return result;\n    };\n\n    Common._topologicalSort = function(node, visited, temp, graph, result) {\n        var neighbors = graph[node] || [];\n        temp[node] = true;\n\n        for (var i = 0; i < neighbors.length; i += 1) {\n            var neighbor = neighbors[i];\n\n            if (temp[neighbor]) {\n                // skip circular dependencies\n                continue;\n            }\n\n            if (!visited[neighbor]) {\n                Common._topologicalSort(neighbor, visited, temp, graph, result);\n            }\n        }\n\n        temp[node] = false;\n        visited[node] = true;\n\n        result.push(node);\n    };\n\n    /**\n     * Takes _n_ functions as arguments and returns a new function that calls them in order.\n     * The arguments applied when calling the new function will also be applied to every function passed.\n     * The value of `this` refers to the last value returned in the chain that was not `undefined`.\n     * Therefore if a passed function does not return a value, the previously returned value is maintained.\n     * After all passed functions have been called the new function returns the last returned value (if any).\n     * If any of the passed functions are a chain, then the chain will be flattened.\n     * @method chain\n     * @param ...funcs {function} The functions to chain.\n     * @return {function} A new function that calls the passed functions in order.\n     */\n    Common.chain = function() {\n        var funcs = [];\n\n        for (var i = 0; i < arguments.length; i += 1) {\n            var func = arguments[i];\n\n            if (func._chained) {\n                // flatten already chained functions\n                funcs.push.apply(funcs, func._chained);\n            } else {\n                funcs.push(func);\n            }\n        }\n\n        var chain = function() {\n            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\n            var lastResult,\n                args = new Array(arguments.length);\n\n            for (var i = 0, l = arguments.length; i < l; i++) {\n                args[i] = arguments[i];\n            }\n\n            for (i = 0; i < funcs.length; i += 1) {\n                var result = funcs[i].apply(lastResult, args);\n\n                if (typeof result !== 'undefined') {\n                    lastResult = result;\n                }\n            }\n\n            return lastResult;\n        };\n\n        chain._chained = funcs;\n\n        return chain;\n    };\n\n    /**\n     * Chains a function to excute before the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathBefore\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain before the original\n     * @return {function} The chained function that replaced the original\n     */\n    Common.chainPathBefore = function(base, path, func) {\n        return Common.set(base, path, Common.chain(\n            func,\n            Common.get(base, path)\n        ));\n    };\n\n    /**\n     * Chains a function to excute after the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathAfter\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain after the original\n     * @return {function} The chained function that replaced the original\n     */\n    Common.chainPathAfter = function(base, path, func) {\n        return Common.set(base, path, Common.chain(\n            Common.get(base, path),\n            func\n        ));\n    };\n\n    /**\n     * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable\n     * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require('poly-decomp'))`.\n     * @method setDecomp\n     * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module.\n     */\n    Common.setDecomp = function(decomp) {\n        Common._decomp = decomp;\n    };\n\n    /**\n     * Returns the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module provided through `Common.setDecomp`,\n     * otherwise returns the global `decomp` if set.\n     * @method getDecomp\n     * @return {} The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module if provided.\n     */\n    Common.getDecomp = function() {\n        // get user provided decomp if set\n        var decomp = Common._decomp;\n\n        try {\n            // otherwise from window global\n            if (!decomp && typeof window !== 'undefined') {\n                decomp = window.decomp;\n            }\n    \n            // otherwise from node global\n            if (!decomp && typeof global !== 'undefined') {\n                decomp = global.decomp;\n            }\n        } catch (e) {\n            // decomp not available\n            decomp = null;\n        }\n\n        return decomp;\n    };\n})();\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\n*\n* @class Bounds\n*/\n\nvar Bounds = {};\n\nmodule.exports = Bounds;\n\n(function() {\n\n    /**\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\n     * @method create\n     * @param {vertices} vertices\n     * @return {bounds} A new bounds object\n     */\n    Bounds.create = function(vertices) {\n        var bounds = { \n            min: { x: 0, y: 0 }, \n            max: { x: 0, y: 0 }\n        };\n\n        if (vertices)\n            Bounds.update(bounds, vertices);\n        \n        return bounds;\n    };\n\n    /**\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\n     * @method update\n     * @param {bounds} bounds\n     * @param {vertices} vertices\n     * @param {vector} velocity\n     */\n    Bounds.update = function(bounds, vertices, velocity) {\n        bounds.min.x = Infinity;\n        bounds.max.x = -Infinity;\n        bounds.min.y = Infinity;\n        bounds.max.y = -Infinity;\n\n        for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n        }\n        \n        if (velocity) {\n            if (velocity.x > 0) {\n                bounds.max.x += velocity.x;\n            } else {\n                bounds.min.x += velocity.x;\n            }\n            \n            if (velocity.y > 0) {\n                bounds.max.y += velocity.y;\n            } else {\n                bounds.min.y += velocity.y;\n            }\n        }\n    };\n\n    /**\n     * Returns true if the bounds contains the given point.\n     * @method contains\n     * @param {bounds} bounds\n     * @param {vector} point\n     * @return {boolean} True if the bounds contain the point, otherwise false\n     */\n    Bounds.contains = function(bounds, point) {\n        return point.x >= bounds.min.x && point.x <= bounds.max.x \n               && point.y >= bounds.min.y && point.y <= bounds.max.y;\n    };\n\n    /**\n     * Returns true if the two bounds intersect.\n     * @method overlaps\n     * @param {bounds} boundsA\n     * @param {bounds} boundsB\n     * @return {boolean} True if the bounds overlap, otherwise false\n     */\n    Bounds.overlaps = function(boundsA, boundsB) {\n        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x\n                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);\n    };\n\n    /**\n     * Translates the bounds by the given vector.\n     * @method translate\n     * @param {bounds} bounds\n     * @param {vector} vector\n     */\n    Bounds.translate = function(bounds, vector) {\n        bounds.min.x += vector.x;\n        bounds.max.x += vector.x;\n        bounds.min.y += vector.y;\n        bounds.max.y += vector.y;\n    };\n\n    /**\n     * Shifts the bounds to the given position.\n     * @method shift\n     * @param {bounds} bounds\n     * @param {vector} position\n     */\n    Bounds.shift = function(bounds, position) {\n        var deltaX = bounds.max.x - bounds.min.x,\n            deltaY = bounds.max.y - bounds.min.y;\n            \n        bounds.min.x = position.x;\n        bounds.max.x = position.x + deltaX;\n        bounds.min.y = position.y;\n        bounds.max.y = position.y + deltaY;\n    };\n    \n})();\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\n* Vectors are the basis of all the geometry related operations in the engine.\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vector\n*/\n\n// TODO: consider params for reusing vector objects\n\nvar Vector = {};\n\nmodule.exports = Vector;\n\n(function() {\n\n    /**\n     * Creates a new vector.\n     * @method create\n     * @param {number} x\n     * @param {number} y\n     * @return {vector} A new vector\n     */\n    Vector.create = function(x, y) {\n        return { x: x || 0, y: y || 0 };\n    };\n\n    /**\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\n     * @method clone\n     * @param {vector} vector\n     * @return {vector} A new cloned vector\n     */\n    Vector.clone = function(vector) {\n        return { x: vector.x, y: vector.y };\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector.\n     * @method magnitude\n     * @param {vector} vector\n     * @return {number} The magnitude of the vector\n     */\n    Vector.magnitude = function(vector) {\n        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\n     * @method magnitudeSquared\n     * @param {vector} vector\n     * @return {number} The squared magnitude of the vector\n     */\n    Vector.magnitudeSquared = function(vector) {\n        return (vector.x * vector.x) + (vector.y * vector.y);\n    };\n\n    /**\n     * Rotates the vector about (0, 0) by specified angle.\n     * @method rotate\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} [output]\n     * @return {vector} The vector rotated about (0, 0)\n     */\n    Vector.rotate = function(vector, angle, output) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        if (!output) output = {};\n        var x = vector.x * cos - vector.y * sin;\n        output.y = vector.x * sin + vector.y * cos;\n        output.x = x;\n        return output;\n    };\n\n    /**\n     * Rotates the vector about a specified point by specified angle.\n     * @method rotateAbout\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} point\n     * @param {vector} [output]\n     * @return {vector} A new vector rotated about the point\n     */\n    Vector.rotateAbout = function(vector, angle, point, output) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        if (!output) output = {};\n        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);\n        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);\n        output.x = x;\n        return output;\n    };\n\n    /**\n     * Normalises a vector (such that its magnitude is `1`).\n     * @method normalise\n     * @param {vector} vector\n     * @return {vector} A new vector normalised\n     */\n    Vector.normalise = function(vector) {\n        var magnitude = Vector.magnitude(vector);\n        if (magnitude === 0)\n            return { x: 0, y: 0 };\n        return { x: vector.x / magnitude, y: vector.y / magnitude };\n    };\n\n    /**\n     * Returns the dot-product of two vectors.\n     * @method dot\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The dot product of the two vectors\n     */\n    Vector.dot = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);\n    };\n\n    /**\n     * Returns the cross-product of two vectors.\n     * @method cross\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The cross product of the two vectors\n     */\n    Vector.cross = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);\n    };\n\n    /**\n     * Returns the cross-product of three vectors.\n     * @method cross3\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} vectorC\n     * @return {number} The cross product of the three vectors\n     */\n    Vector.cross3 = function(vectorA, vectorB, vectorC) {\n        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);\n    };\n\n    /**\n     * Adds the two vectors.\n     * @method add\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB added\n     */\n    Vector.add = function(vectorA, vectorB, output) {\n        if (!output) output = {};\n        output.x = vectorA.x + vectorB.x;\n        output.y = vectorA.y + vectorB.y;\n        return output;\n    };\n\n    /**\n     * Subtracts the two vectors.\n     * @method sub\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB subtracted\n     */\n    Vector.sub = function(vectorA, vectorB, output) {\n        if (!output) output = {};\n        output.x = vectorA.x - vectorB.x;\n        output.y = vectorA.y - vectorB.y;\n        return output;\n    };\n\n    /**\n     * Multiplies a vector and a scalar.\n     * @method mult\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector multiplied by scalar\n     */\n    Vector.mult = function(vector, scalar) {\n        return { x: vector.x * scalar, y: vector.y * scalar };\n    };\n\n    /**\n     * Divides a vector and a scalar.\n     * @method div\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector divided by scalar\n     */\n    Vector.div = function(vector, scalar) {\n        return { x: vector.x / scalar, y: vector.y / scalar };\n    };\n\n    /**\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\n     * @method perp\n     * @param {vector} vector\n     * @param {bool} [negate=false]\n     * @return {vector} The perpendicular vector\n     */\n    Vector.perp = function(vector, negate) {\n        negate = negate === true ? -1 : 1;\n        return { x: negate * -vector.y, y: negate * vector.x };\n    };\n\n    /**\n     * Negates both components of a vector such that it points in the opposite direction.\n     * @method neg\n     * @param {vector} vector\n     * @return {vector} The negated vector\n     */\n    Vector.neg = function(vector) {\n        return { x: -vector.x, y: -vector.y };\n    };\n\n    /**\n     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.\n     * @method angle\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The angle in radians\n     */\n    Vector.angle = function(vectorA, vectorB) {\n        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\n    };\n\n    /**\n     * Temporary vector pool (not thread-safe).\n     * @property _temp\n     * @type {vector[]}\n     * @private\n     */\n    Vector._temp = [\n        Vector.create(), Vector.create(), \n        Vector.create(), Vector.create(), \n        Vector.create(), Vector.create()\n    ];\n\n})();\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vertices\n*/\n\nvar Vertices = {};\n\nmodule.exports = Vertices;\n\nvar Vector = __webpack_require__(2);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new set of `Matter.Body` compatible vertices.\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\n     * but with some additional references required for efficient collision detection routines.\n     *\n     * Vertices must be specified in clockwise order.\n     *\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\n     *\n     * @method create\n     * @param {vector[]} points\n     * @param {body} body\n     */\n    Vertices.create = function(points, body) {\n        var vertices = [];\n\n        for (var i = 0; i < points.length; i++) {\n            var point = points[i],\n                vertex = {\n                    x: point.x,\n                    y: point.y,\n                    index: i,\n                    body: body,\n                    isInternal: false\n                };\n\n            vertices.push(vertex);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \n     * into a `Matter.Vertices` object for the given `Matter.Body`.\n     * For parsing SVG paths, see `Svg.pathToVertices`.\n     * @method fromPath\n     * @param {string} path\n     * @param {body} body\n     * @return {vertices} vertices\n     */\n    Vertices.fromPath = function(path, body) {\n        var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig,\n            points = [];\n\n        path.replace(pathPattern, function(match, x, y) {\n            points.push({ x: parseFloat(x), y: parseFloat(y) });\n        });\n\n        return Vertices.create(points, body);\n    };\n\n    /**\n     * Returns the centre (centroid) of the set of vertices.\n     * @method centre\n     * @param {vertices} vertices\n     * @return {vector} The centre point\n     */\n    Vertices.centre = function(vertices) {\n        var area = Vertices.area(vertices, true),\n            centre = { x: 0, y: 0 },\n            cross,\n            temp,\n            j;\n\n        for (var i = 0; i < vertices.length; i++) {\n            j = (i + 1) % vertices.length;\n            cross = Vector.cross(vertices[i], vertices[j]);\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n            centre = Vector.add(centre, temp);\n        }\n\n        return Vector.div(centre, 6 * area);\n    };\n\n    /**\n     * Returns the average (mean) of the set of vertices.\n     * @method mean\n     * @param {vertices} vertices\n     * @return {vector} The average point\n     */\n    Vertices.mean = function(vertices) {\n        var average = { x: 0, y: 0 };\n\n        for (var i = 0; i < vertices.length; i++) {\n            average.x += vertices[i].x;\n            average.y += vertices[i].y;\n        }\n\n        return Vector.div(average, vertices.length);\n    };\n\n    /**\n     * Returns the area of the set of vertices.\n     * @method area\n     * @param {vertices} vertices\n     * @param {bool} signed\n     * @return {number} The area\n     */\n    Vertices.area = function(vertices, signed) {\n        var area = 0,\n            j = vertices.length - 1;\n\n        for (var i = 0; i < vertices.length; i++) {\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n            j = i;\n        }\n\n        if (signed)\n            return area / 2;\n\n        return Math.abs(area) / 2;\n    };\n\n    /**\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\n     * @method inertia\n     * @param {vertices} vertices\n     * @param {number} mass\n     * @return {number} The polygon's moment of inertia\n     */\n    Vertices.inertia = function(vertices, mass) {\n        var numerator = 0,\n            denominator = 0,\n            v = vertices,\n            cross,\n            j;\n\n        // find the polygon's moment of inertia, using second moment of area\n        // from equations at http://www.physicsforums.com/showthread.php?t=25293\n        for (var n = 0; n < v.length; n++) {\n            j = (n + 1) % v.length;\n            cross = Math.abs(Vector.cross(v[j], v[n]));\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n            denominator += cross;\n        }\n\n        return (mass / 6) * (numerator / denominator);\n    };\n\n    /**\n     * Translates the set of vertices in-place.\n     * @method translate\n     * @param {vertices} vertices\n     * @param {vector} vector\n     * @param {number} scalar\n     */\n    Vertices.translate = function(vertices, vector, scalar) {\n        var i;\n        if (scalar) {\n            for (i = 0; i < vertices.length; i++) {\n                vertices[i].x += vector.x * scalar;\n                vertices[i].y += vector.y * scalar;\n            }\n        } else {\n            for (i = 0; i < vertices.length; i++) {\n                vertices[i].x += vector.x;\n                vertices[i].y += vector.y;\n            }\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Rotates the set of vertices in-place.\n     * @method rotate\n     * @param {vertices} vertices\n     * @param {number} angle\n     * @param {vector} point\n     */\n    Vertices.rotate = function(vertices, angle, point) {\n        if (angle === 0)\n            return;\n\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n\n        for (var i = 0; i < vertices.length; i++) {\n            var vertice = vertices[i],\n                dx = vertice.x - point.x,\n                dy = vertice.y - point.y;\n                \n            vertice.x = point.x + (dx * cos - dy * sin);\n            vertice.y = point.y + (dx * sin + dy * cos);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Returns `true` if the `point` is inside the set of `vertices`.\n     * @method contains\n     * @param {vertices} vertices\n     * @param {vector} point\n     * @return {boolean} True if the vertices contains point, otherwise false\n     */\n    Vertices.contains = function(vertices, point) {\n        for (var i = 0; i < vertices.length; i++) {\n            var vertice = vertices[i],\n                nextVertice = vertices[(i + 1) % vertices.length];\n            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Scales the vertices from a point (default is centre) in-place.\n     * @method scale\n     * @param {vertices} vertices\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     */\n    Vertices.scale = function(vertices, scaleX, scaleY, point) {\n        if (scaleX === 1 && scaleY === 1)\n            return vertices;\n\n        point = point || Vertices.centre(vertices);\n\n        var vertex,\n            delta;\n\n        for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            delta = Vector.sub(vertex, point);\n            vertices[i].x = point.x + delta.x * scaleX;\n            vertices[i].y = point.y + delta.y * scaleY;\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\n     * @method chamfer\n     * @param {vertices} vertices\n     * @param {number[]} radius\n     * @param {number} quality\n     * @param {number} qualityMin\n     * @param {number} qualityMax\n     */\n    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\n        if (typeof radius === 'number') {\n            radius = [radius];\n        } else {\n            radius = radius || [8];\n        }\n\n        // quality defaults to -1, which is auto\n        quality = (typeof quality !== 'undefined') ? quality : -1;\n        qualityMin = qualityMin || 2;\n        qualityMax = qualityMax || 14;\n\n        var newVertices = [];\n\n        for (var i = 0; i < vertices.length; i++) {\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\n                vertex = vertices[i],\n                nextVertex = vertices[(i + 1) % vertices.length],\n                currentRadius = radius[i < radius.length ? i : radius.length - 1];\n\n            if (currentRadius === 0) {\n                newVertices.push(vertex);\n                continue;\n            }\n\n            var prevNormal = Vector.normalise({ \n                x: vertex.y - prevVertex.y, \n                y: prevVertex.x - vertex.x\n            });\n\n            var nextNormal = Vector.normalise({ \n                x: nextVertex.y - vertex.y, \n                y: vertex.x - nextVertex.x\n            });\n\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\n                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\n                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\n                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n\n            var precision = quality;\n\n            if (quality === -1) {\n                // automatically decide precision\n                precision = Math.pow(currentRadius, 0.32) * 1.75;\n            }\n\n            precision = Common.clamp(precision, qualityMin, qualityMax);\n\n            // use an even value for precision, more likely to reduce axes by using symmetry\n            if (precision % 2 === 1)\n                precision += 1;\n\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\n                theta = alpha / precision;\n\n            for (var j = 0; j < precision; j++) {\n                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n            }\n        }\n\n        return newVertices;\n    };\n\n    /**\n     * Sorts the input vertices into clockwise order in place.\n     * @method clockwiseSort\n     * @param {vertices} vertices\n     * @return {vertices} vertices\n     */\n    Vertices.clockwiseSort = function(vertices) {\n        var centre = Vertices.mean(vertices);\n\n        vertices.sort(function(vertexA, vertexB) {\n            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n        });\n\n        return vertices;\n    };\n\n    /**\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\n     * @method isConvex\n     * @param {vertices} vertices\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\n     */\n    Vertices.isConvex = function(vertices) {\n        // http://paulbourke.net/geometry/polygonmesh/\n        // Copyright (c) Paul Bourke (use permitted)\n\n        var flag = 0,\n            n = vertices.length,\n            i,\n            j,\n            k,\n            z;\n\n        if (n < 3)\n            return null;\n\n        for (i = 0; i < n; i++) {\n            j = (i + 1) % n;\n            k = (i + 2) % n;\n            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n\n            if (z < 0) {\n                flag |= 1;\n            } else if (z > 0) {\n                flag |= 2;\n            }\n\n            if (flag === 3) {\n                return false;\n            }\n        }\n\n        if (flag !== 0){\n            return true;\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * Returns the convex hull of the input vertices as a new array of points.\n     * @method hull\n     * @param {vertices} vertices\n     * @return [vertex] vertices\n     */\n    Vertices.hull = function(vertices) {\n        // http://geomalgorithms.com/a10-_hull-1.html\n\n        var upper = [],\n            lower = [], \n            vertex,\n            i;\n\n        // sort vertices on x-axis (y-axis for ties)\n        vertices = vertices.slice(0);\n        vertices.sort(function(vertexA, vertexB) {\n            var dx = vertexA.x - vertexB.x;\n            return dx !== 0 ? dx : vertexA.y - vertexB.y;\n        });\n\n        // build lower hull\n        for (i = 0; i < vertices.length; i += 1) {\n            vertex = vertices[i];\n\n            while (lower.length >= 2 \n                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\n                lower.pop();\n            }\n\n            lower.push(vertex);\n        }\n\n        // build upper hull\n        for (i = vertices.length - 1; i >= 0; i -= 1) {\n            vertex = vertices[i];\n\n            while (upper.length >= 2 \n                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\n                upper.pop();\n            }\n\n            upper.push(vertex);\n        }\n\n        // concatenation of the lower and upper hulls gives the convex hull\n        // omit last points because they are repeated at the beginning of the other list\n        upper.pop();\n        lower.pop();\n\n        return upper.concat(lower);\n    };\n\n})();\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Events` module contains methods to fire and listen to events on other objects.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Events\n*/\n\nvar Events = {};\n\nmodule.exports = Events;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Subscribes a callback function to the given object's `eventName`.\n     * @method on\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.on = function(object, eventNames, callback) {\n        var names = eventNames.split(' '),\n            name;\n\n        for (var i = 0; i < names.length; i++) {\n            name = names[i];\n            object.events = object.events || {};\n            object.events[name] = object.events[name] || [];\n            object.events[name].push(callback);\n        }\n\n        return callback;\n    };\n\n    /**\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\n     * @method off\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.off = function(object, eventNames, callback) {\n        if (!eventNames) {\n            object.events = {};\n            return;\n        }\n\n        // handle Events.off(object, callback)\n        if (typeof eventNames === 'function') {\n            callback = eventNames;\n            eventNames = Common.keys(object.events).join(' ');\n        }\n\n        var names = eventNames.split(' ');\n\n        for (var i = 0; i < names.length; i++) {\n            var callbacks = object.events[names[i]],\n                newCallbacks = [];\n\n            if (callback && callbacks) {\n                for (var j = 0; j < callbacks.length; j++) {\n                    if (callbacks[j] !== callback)\n                        newCallbacks.push(callbacks[j]);\n                }\n            }\n\n            object.events[names[i]] = newCallbacks;\n        }\n    };\n\n    /**\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\n     * @method trigger\n     * @param {} object\n     * @param {string} eventNames\n     * @param {} event\n     */\n    Events.trigger = function(object, eventNames, event) {\n        var names,\n            name,\n            callbacks,\n            eventClone;\n\n        var events = object.events;\n        \n        if (events && Common.keys(events).length > 0) {\n            if (!event)\n                event = {};\n\n            names = eventNames.split(' ');\n\n            for (var i = 0; i < names.length; i++) {\n                name = names[i];\n                callbacks = events[name];\n\n                if (callbacks) {\n                    eventClone = Common.clone(event, false);\n                    eventClone.name = name;\n                    eventClone.source = object;\n\n                    for (var j = 0; j < callbacks.length; j++) {\n                        callbacks[j].apply(object, [eventClone]);\n                    }\n                }\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* A composite is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite` objects.\n*\n* They are a container that can represent complex objects made of multiple parts, even if they are not physically connected.\n* A composite could contain anything from a single body all the way up to a whole world.\n* \n* When making any changes to composites, use the included functions rather than changing their properties directly.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composite\n*/\n\nvar Composite = {};\n\nmodule.exports = Composite;\n\nvar Events = __webpack_require__(4);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\nvar Body = __webpack_require__(6);\n\n(function() {\n\n    /**\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} [options]\n     * @return {composite} A new composite\n     */\n    Composite.create = function(options) {\n        return Common.extend({ \n            id: Common.nextId(),\n            type: 'composite',\n            parent: null,\n            isModified: false,\n            bodies: [], \n            constraints: [], \n            composites: [],\n            label: 'Composite',\n            plugin: {}\n        }, options);\n    };\n\n    /**\n     * Sets the composite's `isModified` flag. \n     * If `updateParents` is true, all parents will be set (default: false).\n     * If `updateChildren` is true, all children will be set (default: false).\n     * @method setModified\n     * @param {composite} composite\n     * @param {boolean} isModified\n     * @param {boolean} [updateParents=false]\n     * @param {boolean} [updateChildren=false]\n     */\n    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\n        composite.isModified = isModified;\n\n        if (updateParents && composite.parent) {\n            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n        }\n\n        if (updateChildren) {\n            for(var i = 0; i < composite.composites.length; i++) {\n                var childComposite = composite.composites[i];\n                Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n            }\n        }\n    };\n\n    /**\n     * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\n     * @method add\n     * @param {composite} composite\n     * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s)\n     * @return {composite} The original composite with the objects added\n     */\n    Composite.add = function(composite, object) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeAdd', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                // skip adding compound parts\n                if (obj.parent !== obj) {\n                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\n                    break;\n                }\n\n                Composite.addBody(composite, obj);\n                break;\n            case 'constraint':\n                Composite.addConstraint(composite, obj);\n                break;\n            case 'composite':\n                Composite.addComposite(composite, obj);\n                break;\n            case 'mouseConstraint':\n                Composite.addConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterAdd', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\n     * Optionally searching its children recursively.\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\n     * @method remove\n     * @param {composite} composite\n     * @param {object|array} object\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the objects removed\n     */\n    Composite.remove = function(composite, object, deep) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeRemove', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                Composite.removeBody(composite, obj, deep);\n                break;\n            case 'constraint':\n                Composite.removeConstraint(composite, obj, deep);\n                break;\n            case 'composite':\n                Composite.removeComposite(composite, obj, deep);\n                break;\n            case 'mouseConstraint':\n                Composite.removeConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterRemove', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Adds a composite to the given composite.\n     * @private\n     * @method addComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @return {composite} The original compositeA with the objects from compositeB added\n     */\n    Composite.addComposite = function(compositeA, compositeB) {\n        compositeA.composites.push(compositeB);\n        compositeB.parent = compositeA;\n        Composite.setModified(compositeA, true, true, false);\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @param {boolean} [deep=false]\n     * @return {composite} The original compositeA with the composite removed\n     */\n    Composite.removeComposite = function(compositeA, compositeB, deep) {\n        var position = Common.indexOf(compositeA.composites, compositeB);\n        if (position !== -1) {\n            Composite.removeCompositeAt(compositeA, position);\n            Composite.setModified(compositeA, true, true, false);\n        }\n\n        if (deep) {\n            for (var i = 0; i < compositeA.composites.length; i++){\n                Composite.removeComposite(compositeA.composites[i], compositeB, true);\n            }\n        }\n\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite.\n     * @private\n     * @method removeCompositeAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the composite removed\n     */\n    Composite.removeCompositeAt = function(composite, position) {\n        composite.composites.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a body to the given composite.\n     * @private\n     * @method addBody\n     * @param {composite} composite\n     * @param {body} body\n     * @return {composite} The original composite with the body added\n     */\n    Composite.addBody = function(composite, body) {\n        composite.bodies.push(body);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeBody\n     * @param {composite} composite\n     * @param {body} body\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBody = function(composite, body, deep) {\n        var position = Common.indexOf(composite.bodies, body);\n        if (position !== -1) {\n            Composite.removeBodyAt(composite, position);\n            Composite.setModified(composite, true, true, false);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeBody(composite.composites[i], body, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeBodyAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBodyAt = function(composite, position) {\n        composite.bodies.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a constraint to the given composite.\n     * @private\n     * @method addConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @return {composite} The original composite with the constraint added\n     */\n    Composite.addConstraint = function(composite, constraint) {\n        composite.constraints.push(constraint);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraint = function(composite, constraint, deep) {\n        var position = Common.indexOf(composite.constraints, constraint);\n        if (position !== -1) {\n            Composite.removeConstraintAt(composite, position);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeConstraint(composite.composites[i], constraint, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeConstraintAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraintAt = function(composite, position) {\n        composite.constraints.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes all bodies, constraints and composites from the given composite.\n     * Optionally clearing its children recursively.\n     * @method clear\n     * @param {composite} composite\n     * @param {boolean} keepStatic\n     * @param {boolean} [deep=false]\n     */\n    Composite.clear = function(composite, keepStatic, deep) {\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.clear(composite.composites[i], keepStatic, true);\n            }\n        }\n        \n        if (keepStatic) {\n            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });\n        } else {\n            composite.bodies.length = 0;\n        }\n\n        composite.constraints.length = 0;\n        composite.composites.length = 0;\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\n     * @method allBodies\n     * @param {composite} composite\n     * @return {body[]} All the bodies\n     */\n    Composite.allBodies = function(composite) {\n        var bodies = [].concat(composite.bodies);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n\n        return bodies;\n    };\n\n    /**\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\n     * @method allConstraints\n     * @param {composite} composite\n     * @return {constraint[]} All the constraints\n     */\n    Composite.allConstraints = function(composite) {\n        var constraints = [].concat(composite.constraints);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n\n        return constraints;\n    };\n\n    /**\n     * Returns all composites in the given composite, including all composites in its children, recursively.\n     * @method allComposites\n     * @param {composite} composite\n     * @return {composite[]} All the composites\n     */\n    Composite.allComposites = function(composite) {\n        var composites = [].concat(composite.composites);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            composites = composites.concat(Composite.allComposites(composite.composites[i]));\n\n        return composites;\n    };\n\n    /**\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\n     * @method get\n     * @param {composite} composite\n     * @param {number} id\n     * @param {string} type\n     * @return {object} The requested object, if found\n     */\n    Composite.get = function(composite, id, type) {\n        var objects,\n            object;\n\n        switch (type) {\n        case 'body':\n            objects = Composite.allBodies(composite);\n            break;\n        case 'constraint':\n            objects = Composite.allConstraints(composite);\n            break;\n        case 'composite':\n            objects = Composite.allComposites(composite).concat(composite);\n            break;\n        }\n\n        if (!objects)\n            return null;\n\n        object = objects.filter(function(object) { \n            return object.id.toString() === id.toString(); \n        });\n\n        return object.length === 0 ? null : object[0];\n    };\n\n    /**\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\n     * @method move\n     * @param {compositeA} compositeA\n     * @param {object[]} objects\n     * @param {compositeB} compositeB\n     * @return {composite} Returns compositeA\n     */\n    Composite.move = function(compositeA, objects, compositeB) {\n        Composite.remove(compositeA, objects);\n        Composite.add(compositeB, objects);\n        return compositeA;\n    };\n\n    /**\n     * Assigns new ids for all objects in the composite, recursively.\n     * @method rebase\n     * @param {composite} composite\n     * @return {composite} Returns composite\n     */\n    Composite.rebase = function(composite) {\n        var objects = Composite.allBodies(composite)\n            .concat(Composite.allConstraints(composite))\n            .concat(Composite.allComposites(composite));\n\n        for (var i = 0; i < objects.length; i++) {\n            objects[i].id = Common.nextId();\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Translates all children in the composite by a given vector relative to their current positions, \n     * without imparting any velocity.\n     * @method translate\n     * @param {composite} composite\n     * @param {vector} translation\n     * @param {bool} [recursive=true]\n     */\n    Composite.translate = function(composite, translation, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            Body.translate(bodies[i], translation);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\n     * @method rotate\n     * @param {composite} composite\n     * @param {number} rotation\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.rotate = function(composite, rotation, point, recursive) {\n        var cos = Math.cos(rotation),\n            sin = Math.sin(rotation),\n            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            });\n\n            Body.rotate(body, rotation);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\n     * @method scale\n     * @param {composite} composite\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + dx * scaleX,\n                y: point.y + dy * scaleY\n            });\n\n            Body.scale(body, scaleX, scaleY);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Returns the union of the bounds of all of the composite's bodies.\n     * @method bounds\n     * @param {composite} composite The composite.\n     * @returns {bounds} The composite bounds.\n     */\n    Composite.bounds = function(composite) {\n        var bodies = Composite.allBodies(composite),\n            vertices = [];\n\n        for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i];\n            vertices.push(body.bounds.min, body.bounds.max);\n        }\n\n        return Bounds.create(vertices);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, before objects have been added.\n    *\n    * @event beforeAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, after objects have been added.\n    *\n    * @event afterAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\n    *\n    * @event beforeRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\n    *\n    * @event afterRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"composite\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage composites.\n     *\n     * @property label\n     * @type string\n     * @default \"Composite\"\n     */\n\n    /**\n     * A flag that specifies whether the composite has been modified during the current step.\n     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.\n     * If you need to change it manually, you should use the `Composite.setModified` method.\n     *\n     * @property isModified\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\n     *\n     * @property parent\n     * @type composite\n     * @default null\n     */\n\n    /**\n     * An array of `Body` that are _direct_ children of this composite.\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\n     *\n     * @property bodies\n     * @type body[]\n     * @default []\n     */\n\n    /**\n     * An array of `Constraint` that are _direct_ children of this composite.\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\n     *\n     * @property constraints\n     * @type constraint[]\n     * @default []\n     */\n\n    /**\n     * An array of `Composite` that are _direct_ children of this composite.\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\n     *\n     * @property composites\n     * @type composite[]\n     * @default []\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n})();\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Body` module contains methods for creating and manipulating body models.\n* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\n* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n\n* @class Body\n*/\n\nvar Body = {};\n\nmodule.exports = Body;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\nvar Sleeping = __webpack_require__(7);\nvar Render = __webpack_require__(16);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\nvar Axes = __webpack_require__(10);\n\n(function() {\n\n    Body._inertiaScale = 4;\n    Body._nextCollidingGroupId = 1;\n    Body._nextNonCollidingGroupId = -1;\n    Body._nextCategory = 0x0001;\n\n    /**\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * Vertices must be specified in clockwise order.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {body} body\n     */\n    Body.create = function(options) {\n        var defaults = {\n            id: Common.nextId(),\n            type: 'body',\n            label: 'Body',\n            parts: [],\n            plugin: {},\n            angle: 0,\n            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),\n            position: { x: 0, y: 0 },\n            force: { x: 0, y: 0 },\n            torque: 0,\n            positionImpulse: { x: 0, y: 0 },\n            constraintImpulse: { x: 0, y: 0, angle: 0 },\n            totalContacts: 0,\n            speed: 0,\n            angularSpeed: 0,\n            velocity: { x: 0, y: 0 },\n            angularVelocity: 0,\n            isSensor: false,\n            isStatic: false,\n            isSleeping: false,\n            motion: 0,\n            sleepThreshold: 60,\n            density: 0.001,\n            restitution: 0,\n            friction: 0.1,\n            frictionStatic: 0.5,\n            frictionAir: 0.01,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            },\n            slop: 0.05,\n            timeScale: 1,\n            render: {\n                visible: true,\n                opacity: 1,\n                strokeStyle: null,\n                fillStyle: null,\n                lineWidth: null,\n                sprite: {\n                    xScale: 1,\n                    yScale: 1,\n                    xOffset: 0,\n                    yOffset: 0\n                }\n            },\n            events: null,\n            bounds: null,\n            chamfer: null,\n            circleRadius: 0,\n            positionPrev: null,\n            anglePrev: 0,\n            parent: null,\n            axes: null,\n            area: 0,\n            mass: 0,\n            inertia: 0,\n            _original: null\n        };\n\n        var body = Common.extend(defaults, options);\n\n        _initProperties(body, options);\n\n        return body;\n    };\n\n    /**\n     * Returns the next unique group index for which bodies will collide.\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\n     * See `body.collisionFilter` for more information.\n     * @method nextGroup\n     * @param {bool} [isNonColliding=false]\n     * @return {Number} Unique group index\n     */\n    Body.nextGroup = function(isNonColliding) {\n        if (isNonColliding)\n            return Body._nextNonCollidingGroupId--;\n\n        return Body._nextCollidingGroupId++;\n    };\n\n    /**\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\n     * There are 32 available. See `body.collisionFilter` for more information.\n     * @method nextCategory\n     * @return {Number} Unique category bitfield\n     */\n    Body.nextCategory = function() {\n        Body._nextCategory = Body._nextCategory << 1;\n        return Body._nextCategory;\n    };\n\n    /**\n     * Initialises body properties.\n     * @method _initProperties\n     * @private\n     * @param {body} body\n     * @param {} [options]\n     */\n    var _initProperties = function(body, options) {\n        options = options || {};\n\n        // init required properties (order is important)\n        Body.set(body, {\n            bounds: body.bounds || Bounds.create(body.vertices),\n            positionPrev: body.positionPrev || Vector.clone(body.position),\n            anglePrev: body.anglePrev || body.angle,\n            vertices: body.vertices,\n            parts: body.parts || [body],\n            isStatic: body.isStatic,\n            isSleeping: body.isSleeping,\n            parent: body.parent || body\n        });\n\n        Vertices.rotate(body.vertices, body.angle, body.position);\n        Axes.rotate(body.axes, body.angle);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n\n        // allow options to override the automatically calculated properties\n        Body.set(body, {\n            axes: options.axes || body.axes,\n            area: options.area || body.area,\n            mass: options.mass || body.mass,\n            inertia: options.inertia || body.inertia\n        });\n\n        // render properties\n        var defaultFillStyle = (body.isStatic ? '#14151f' : Common.choose(['#f19648', '#f5d259', '#f55a3c', '#063e7b', '#ececd1'])),\n            defaultStrokeStyle = body.isStatic ? '#555' : '#ccc',\n            defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;\n        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n        body.render.lineWidth = body.render.lineWidth || defaultLineWidth;\n        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n    };\n\n    /**\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\n     * Prefer to use the actual setter functions in performance critical situations.\n     * @method set\n     * @param {body} body\n     * @param {} settings A property name (or map of properties and values) to set on the body.\n     * @param {} value The value to set if `settings` is a single property name.\n     */\n    Body.set = function(body, settings, value) {\n        var property;\n\n        if (typeof settings === 'string') {\n            property = settings;\n            settings = {};\n            settings[property] = value;\n        }\n\n        for (property in settings) {\n            if (!Object.prototype.hasOwnProperty.call(settings, property))\n                continue;\n\n            value = settings[property];\n            switch (property) {\n\n            case 'isStatic':\n                Body.setStatic(body, value);\n                break;\n            case 'isSleeping':\n                Sleeping.set(body, value);\n                break;\n            case 'mass':\n                Body.setMass(body, value);\n                break;\n            case 'density':\n                Body.setDensity(body, value);\n                break;\n            case 'inertia':\n                Body.setInertia(body, value);\n                break;\n            case 'vertices':\n                Body.setVertices(body, value);\n                break;\n            case 'position':\n                Body.setPosition(body, value);\n                break;\n            case 'angle':\n                Body.setAngle(body, value);\n                break;\n            case 'velocity':\n                Body.setVelocity(body, value);\n                break;\n            case 'angularVelocity':\n                Body.setAngularVelocity(body, value);\n                break;\n            case 'parts':\n                Body.setParts(body, value);\n                break;\n            case 'centre':\n                Body.setCentre(body, value);\n                break;\n            default:\n                body[property] = value;\n\n            }\n        }\n    };\n\n    /**\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\n     * @method setStatic\n     * @param {body} body\n     * @param {bool} isStatic\n     */\n    Body.setStatic = function(body, isStatic) {\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.isStatic = isStatic;\n\n            if (isStatic) {\n                part._original = {\n                    restitution: part.restitution,\n                    friction: part.friction,\n                    mass: part.mass,\n                    inertia: part.inertia,\n                    density: part.density,\n                    inverseMass: part.inverseMass,\n                    inverseInertia: part.inverseInertia\n                };\n\n                part.restitution = 0;\n                part.friction = 1;\n                part.mass = part.inertia = part.density = Infinity;\n                part.inverseMass = part.inverseInertia = 0;\n\n                part.positionPrev.x = part.position.x;\n                part.positionPrev.y = part.position.y;\n                part.anglePrev = part.angle;\n                part.angularVelocity = 0;\n                part.speed = 0;\n                part.angularSpeed = 0;\n                part.motion = 0;\n            } else if (part._original) {\n                part.restitution = part._original.restitution;\n                part.friction = part._original.friction;\n                part.mass = part._original.mass;\n                part.inertia = part._original.inertia;\n                part.density = part._original.density;\n                part.inverseMass = part._original.inverseMass;\n                part.inverseInertia = part._original.inverseInertia;\n\n                part._original = null;\n            }\n        }\n    };\n\n    /**\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\n     * @method setMass\n     * @param {body} body\n     * @param {number} mass\n     */\n    Body.setMass = function(body, mass) {\n        var moment = body.inertia / (body.mass / 6);\n        body.inertia = moment * (mass / 6);\n        body.inverseInertia = 1 / body.inertia;\n\n        body.mass = mass;\n        body.inverseMass = 1 / body.mass;\n        body.density = body.mass / body.area;\n    };\n\n    /**\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\n     * @method setDensity\n     * @param {body} body\n     * @param {number} density\n     */\n    Body.setDensity = function(body, density) {\n        Body.setMass(body, density * body.area);\n        body.density = density;\n    };\n\n    /**\n     * Sets the moment of inertia (i.e. second moment of area) of the body. \n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\n     * @method setInertia\n     * @param {body} body\n     * @param {number} inertia\n     */\n    Body.setInertia = function(body, inertia) {\n        body.inertia = inertia;\n        body.inverseInertia = 1 / body.inertia;\n    };\n\n    /**\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\n     * They are then automatically translated to world space based on `body.position`.\n     *\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\n     * Vertices must form a convex hull, concave hulls are not supported.\n     *\n     * @method setVertices\n     * @param {body} body\n     * @param {vector[]} vertices\n     */\n    Body.setVertices = function(body, vertices) {\n        // change vertices\n        if (vertices[0].body === body) {\n            body.vertices = vertices;\n        } else {\n            body.vertices = Vertices.create(vertices, body);\n        }\n\n        // update properties\n        body.axes = Axes.fromVertices(body.vertices);\n        body.area = Vertices.area(body.vertices);\n        Body.setMass(body, body.density * body.area);\n\n        // orient vertices around the centre of mass at origin (0, 0)\n        var centre = Vertices.centre(body.vertices);\n        Vertices.translate(body.vertices, centre, -1);\n\n        // update inertia while vertices are at origin (0, 0)\n        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\n\n        // update geometry\n        Vertices.translate(body.vertices, body.position);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Sets the parts of the `body` and updates mass, inertia and centroid.\n     * Each part will have its parent set to `body`.\n     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\n     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\n     * @method setParts\n     * @param {body} body\n     * @param [body] parts\n     * @param {bool} [autoHull=true]\n     */\n    Body.setParts = function(body, parts, autoHull) {\n        var i;\n\n        // add all the parts, ensuring that the first part is always the parent body\n        parts = parts.slice(0);\n        body.parts.length = 0;\n        body.parts.push(body);\n        body.parent = body;\n\n        for (i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            if (part !== body) {\n                part.parent = body;\n                body.parts.push(part);\n            }\n        }\n\n        if (body.parts.length === 1)\n            return;\n\n        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;\n\n        // find the convex hull of all parts to set on the parent body\n        if (autoHull) {\n            var vertices = [];\n            for (i = 0; i < parts.length; i++) {\n                vertices = vertices.concat(parts[i].vertices);\n            }\n\n            Vertices.clockwiseSort(vertices);\n\n            var hull = Vertices.hull(vertices),\n                hullCentre = Vertices.centre(hull);\n\n            Body.setVertices(body, hull);\n            Vertices.translate(body.vertices, hullCentre);\n        }\n\n        // sum the properties of all compound parts of the parent body\n        var total = Body._totalProperties(body);\n\n        body.area = total.area;\n        body.parent = body;\n        body.position.x = total.centre.x;\n        body.position.y = total.centre.y;\n        body.positionPrev.x = total.centre.x;\n        body.positionPrev.y = total.centre.y;\n\n        Body.setMass(body, total.mass);\n        Body.setInertia(body, total.inertia);\n        Body.setPosition(body, total.centre);\n    };\n\n    /**\n     * Set the centre of mass of the body. \n     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\n     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\n     * This is equal to moving `body.position` but not the `body.vertices`.\n     * Invalid if the `centre` falls outside the body's convex hull.\n     * @method setCentre\n     * @param {body} body\n     * @param {vector} centre\n     * @param {bool} relative\n     */\n    Body.setCentre = function(body, centre, relative) {\n        if (!relative) {\n            body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\n            body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\n            body.position.x = centre.x;\n            body.position.y = centre.y;\n        } else {\n            body.positionPrev.x += centre.x;\n            body.positionPrev.y += centre.y;\n            body.position.x += centre.x;\n            body.position.y += centre.y;\n        }\n    };\n\n    /**\n     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.\n     * @method setPosition\n     * @param {body} body\n     * @param {vector} position\n     */\n    Body.setPosition = function(body, position) {\n        var delta = Vector.sub(position, body.position);\n        body.positionPrev.x += delta.x;\n        body.positionPrev.y += delta.y;\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.position.x += delta.x;\n            part.position.y += delta.y;\n            Vertices.translate(part.vertices, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n    };\n\n    /**\n     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.\n     * @method setAngle\n     * @param {body} body\n     * @param {number} angle\n     */\n    Body.setAngle = function(body, angle) {\n        var delta = angle - body.angle;\n        body.anglePrev += delta;\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.angle += delta;\n            Vertices.rotate(part.vertices, delta, body.position);\n            Axes.rotate(part.axes, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n            if (i > 0) {\n                Vector.rotateAbout(part.position, delta, body.position, part.position);\n            }\n        }\n    };\n\n    /**\n     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\n     * @method setVelocity\n     * @param {body} body\n     * @param {vector} velocity\n     */\n    Body.setVelocity = function(body, velocity) {\n        body.positionPrev.x = body.position.x - velocity.x;\n        body.positionPrev.y = body.position.y - velocity.y;\n        body.velocity.x = velocity.x;\n        body.velocity.y = velocity.y;\n        body.speed = Vector.magnitude(body.velocity);\n    };\n\n    /**\n     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\n     * @method setAngularVelocity\n     * @param {body} body\n     * @param {number} velocity\n     */\n    Body.setAngularVelocity = function(body, velocity) {\n        body.anglePrev = body.angle - velocity;\n        body.angularVelocity = velocity;\n        body.angularSpeed = Math.abs(body.angularVelocity);\n    };\n\n    /**\n     * Moves a body by a given vector relative to its current position, without imparting any velocity.\n     * @method translate\n     * @param {body} body\n     * @param {vector} translation\n     */\n    Body.translate = function(body, translation) {\n        Body.setPosition(body, Vector.add(body.position, translation));\n    };\n\n    /**\n     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.\n     * @method rotate\n     * @param {body} body\n     * @param {number} rotation\n     * @param {vector} [point]\n     */\n    Body.rotate = function(body, rotation, point) {\n        if (!point) {\n            Body.setAngle(body, body.angle + rotation);\n        } else {\n            var cos = Math.cos(rotation),\n                sin = Math.sin(rotation),\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            });\n\n            Body.setAngle(body, body.angle + rotation);\n        }\n    };\n\n    /**\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\n     * @method scale\n     * @param {body} body\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} [point]\n     */\n    Body.scale = function(body, scaleX, scaleY, point) {\n        var totalArea = 0,\n            totalInertia = 0;\n\n        point = point || body.position;\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            // scale vertices\n            Vertices.scale(part.vertices, scaleX, scaleY, point);\n\n            // update properties\n            part.axes = Axes.fromVertices(part.vertices);\n            part.area = Vertices.area(part.vertices);\n            Body.setMass(part, body.density * part.area);\n\n            // update inertia (requires vertices to be at origin)\n            Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });\n            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n            Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });\n\n            if (i > 0) {\n                totalArea += part.area;\n                totalInertia += part.inertia;\n            }\n\n            // scale position\n            part.position.x = point.x + (part.position.x - point.x) * scaleX;\n            part.position.y = point.y + (part.position.y - point.y) * scaleY;\n\n            // update bounds\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n\n        // handle parent body\n        if (body.parts.length > 1) {\n            body.area = totalArea;\n\n            if (!body.isStatic) {\n                Body.setMass(body, body.density * totalArea);\n                Body.setInertia(body, totalInertia);\n            }\n        }\n\n        // handle circles\n        if (body.circleRadius) { \n            if (scaleX === scaleY) {\n                body.circleRadius *= scaleX;\n            } else {\n                // body is no longer a circle\n                body.circleRadius = null;\n            }\n        }\n    };\n\n    /**\n     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.\n     * @method update\n     * @param {body} body\n     * @param {number} deltaTime\n     * @param {number} timeScale\n     * @param {number} correction\n     */\n    Body.update = function(body, deltaTime, timeScale, correction) {\n        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);\n\n        // from the previous step\n        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,\n            velocityPrevX = body.position.x - body.positionPrev.x,\n            velocityPrevY = body.position.y - body.positionPrev.y;\n\n        // update velocity with Verlet integration\n        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;\n        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;\n\n        body.positionPrev.x = body.position.x;\n        body.positionPrev.y = body.position.y;\n        body.position.x += body.velocity.x;\n        body.position.y += body.velocity.y;\n\n        // update angular velocity with Verlet integration\n        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;\n        body.anglePrev = body.angle;\n        body.angle += body.angularVelocity;\n\n        // track speed and acceleration\n        body.speed = Vector.magnitude(body.velocity);\n        body.angularSpeed = Math.abs(body.angularVelocity);\n\n        // transform the body geometry\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            Vertices.translate(part.vertices, body.velocity);\n            \n            if (i > 0) {\n                part.position.x += body.velocity.x;\n                part.position.y += body.velocity.y;\n            }\n\n            if (body.angularVelocity !== 0) {\n                Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n                Axes.rotate(part.axes, body.angularVelocity);\n                if (i > 0) {\n                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n                }\n            }\n\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n    };\n\n    /**\n     * Applies a force to a body from a given world-space position, including resulting torque.\n     * @method applyForce\n     * @param {body} body\n     * @param {vector} position\n     * @param {vector} force\n     */\n    Body.applyForce = function(body, position, force) {\n        body.force.x += force.x;\n        body.force.y += force.y;\n        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };\n        body.torque += offset.x * force.y - offset.y * force.x;\n    };\n\n    /**\n     * Returns the sums of the properties of all compound parts of the parent body.\n     * @method _totalProperties\n     * @private\n     * @param {body} body\n     * @return {}\n     */\n    Body._totalProperties = function(body) {\n        // from equations at:\n        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n        // http://output.to/sideway/default.asp?qno=121100087\n\n        var properties = {\n            mass: 0,\n            area: 0,\n            inertia: 0,\n            centre: { x: 0, y: 0 }\n        };\n\n        // sum the properties of all compound parts of the parent body\n        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\n            var part = body.parts[i],\n                mass = part.mass !== Infinity ? part.mass : 1;\n\n            properties.mass += mass;\n            properties.area += part.area;\n            properties.inertia += part.inertia;\n            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n        }\n\n        properties.centre = Vector.div(properties.centre, properties.mass);\n\n        return properties;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a body starts sleeping (where `this` is the body).\n    *\n    * @event sleepStart\n    * @this {body} The body that has started sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a body ends sleeping (where `this` is the body).\n    *\n    * @event sleepEnd\n    * @this {body} The body that has ended sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"body\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Body\"\n     */\n\n    /**\n     * An array of bodies that make up this body. \n     * The first body in the array must always be a self reference to the current body instance.\n     * All bodies in the `parts` array together form a single rigid compound body.\n     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\n     * Parts themselves should never be added to a `World`, only the parent body should be.\n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\n     *\n     * @property parts\n     * @type body[]\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * A self reference if the body is _not_ a part of another body.\n     * Otherwise this is a reference to the body that this is a part of.\n     * See `body.parts`.\n     *\n     * @property parent\n     * @type body\n     */\n\n    /**\n     * A `Number` specifying the angle of the body, in radians.\n     *\n     * @property angle\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * An array of `Vector` objects that specify the convex hull of the rigid body.\n     * These should be provided about the origin `(0, 0)`. E.g.\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).\n     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. \n     *\n     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).\n     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.\n     *\n     * @property vertices\n     * @type vector[]\n     */\n\n    /**\n     * A `Vector` that specifies the current world-space position of the body.\n     *\n     * @property position\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.\n     *\n     * @property force\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.\n     *\n     * @property torque\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).\n     *\n     * @readOnly\n     * @property speed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).\n     *\n     * @readOnly\n     * @property angularSpeed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. \n     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).\n     *\n     * @readOnly\n     * @property velocity\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. \n     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).\n     *\n     * @readOnly\n     * @property angularVelocity\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\n     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.\n     *\n     * @property isStatic\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\n     *\n     * @property isSensor\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\n     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.\n     *\n     * @property isSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.\n     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.\n     *\n     * @readOnly\n     * @property motion\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\n     *\n     * @property sleepThreshold\n     * @type number\n     * @default 60\n     */\n\n    /**\n     * A `Number` that defines the density of the body, that is its mass per unit area.\n     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.\n     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).\n     *\n     * @property density\n     * @type number\n     * @default 0.001\n     */\n\n    /**\n     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.\n     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).\n     *\n     * @property mass\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\n     * If you modify this value, you must also modify the `body.mass` property.\n     *\n     * @property inverseMass\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.\n     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.\n     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).\n     *\n     * @property inertia\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\n     * If you modify this value, you must also modify the `body.inertia` property.\n     *\n     * @property inverseInertia\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\n     *\n     *     Math.max(bodyA.restitution, bodyB.restitution)\n     *\n     * @property restitution\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means that the body may slide indefinitely.\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\n     *\n     * The effects of the value may be non-linear. \n     * High values may be unstable depending on the body.\n     * The engine uses a Coulomb friction model including static and kinetic friction.\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\n     *\n     *     Math.min(bodyA.friction, bodyB.friction)\n     *\n     * @property friction\n     * @type number\n     * @default 0.1\n     */\n\n    /**\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\n     *\n     * @property frictionStatic\n     * @type number\n     * @default 0.5\n     */\n\n    /**\n     * A `Number` that defines the air friction of the body (air resistance). \n     * A value of `0` means the body will never slow as it moves through space.\n     * The higher the value, the faster a body slows when moving through space.\n     * The effects of the value are non-linear. \n     *\n     * @property frictionAir\n     * @type number\n     * @default 0.01\n     */\n\n    /**\n     * An `Object` that specifies the collision filtering properties of this body.\n     *\n     * Collisions between two bodies will obey the following rules:\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\n     *   they will always collide if the value is positive, and they will never collide\n     *   if the value is negative.\n     * - If the two bodies have different values of `collisionFilter.group` or if one\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\n     *\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\n     * value is used as a bit field and the category should have only one bit set, meaning that\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\n     * different collision categories available.\n     *\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\n     *\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\n     * are both true.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n    /**\n     * An Integer `Number`, that specifies the collision group this body belongs to.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.group\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * A bit field that specifies the collision category this body belongs to.\n     * The category value should have only one bit set, for example `0x0001`.\n     * This means there are up to 32 unique collision categories available.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.category\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * A bit mask that specifies the collision categories this body may collide with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.mask\n     * @type object\n     * @default -1\n     */\n\n    /**\n     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.\n     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.\n     * The default should generally suffice, although very large bodies may require larger values for stable stacking.\n     *\n     * @property slop\n     * @type number\n     * @default 0.05\n     */\n\n    /**\n     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\n     *\n     * @property timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the body should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * Sets the opacity to use when rendering.\n     *\n     * @property render.opacity\n     * @type number\n     * @default 1\n    */\n\n    /**\n     * An `Object` that defines the sprite properties to use when rendering, if any.\n     *\n     * @property render.sprite\n     * @type object\n     */\n\n    /**\n     * An `String` that defines the path to the image to use as the sprite texture, if any.\n     *\n     * @property render.sprite.texture\n     * @type string\n     */\n     \n    /**\n     * A `Number` that defines the scaling in the x-axis for the sprite, if any.\n     *\n     * @property render.sprite.xScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that defines the scaling in the y-axis for the sprite, if any.\n     *\n     * @property render.sprite.yScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\n      *\n      * @property render.sprite.xOffset\n      * @type number\n      * @default 0\n      */\n\n    /**\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\n      *\n      * @property render.sprite.yOffset\n      * @type number\n      * @default 0\n      */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.fillStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * An array of unique axis vectors (edge normals) used for collision detection.\n     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.\n     * They are constantly updated by `Body.update` during the simulation.\n     *\n     * @property axes\n     * @type vector[]\n     */\n     \n    /**\n     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.\n     *\n     * @property area\n     * @type string\n     * @default \n     */\n\n    /**\n     * A `Bounds` object that defines the AABB region for the body.\n     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.\n     *\n     * @property bounds\n     * @type bounds\n     */\n\n})();\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\n*\n* @class Sleeping\n*/\n\nvar Sleeping = {};\n\nmodule.exports = Sleeping;\n\nvar Events = __webpack_require__(4);\n\n(function() {\n\n    Sleeping._motionWakeThreshold = 0.18;\n    Sleeping._motionSleepThreshold = 0.08;\n    Sleeping._minBias = 0.9;\n\n    /**\n     * Puts bodies to sleep or wakes them up depending on their motion.\n     * @method update\n     * @param {body[]} bodies\n     * @param {number} timeScale\n     */\n    Sleeping.update = function(bodies, timeScale) {\n        var timeFactor = timeScale * timeScale * timeScale;\n\n        // update bodies sleeping status\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;\n\n            // wake up bodies if they have a force applied\n            if (body.force.x !== 0 || body.force.y !== 0) {\n                Sleeping.set(body, false);\n                continue;\n            }\n\n            var minMotion = Math.min(body.motion, motion),\n                maxMotion = Math.max(body.motion, motion);\n        \n            // biased average motion estimation between frames\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n            \n            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {\n                body.sleepCounter += 1;\n                \n                if (body.sleepCounter >= body.sleepThreshold)\n                    Sleeping.set(body, true);\n            } else if (body.sleepCounter > 0) {\n                body.sleepCounter -= 1;\n            }\n        }\n    };\n\n    /**\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\n     * @method afterCollisions\n     * @param {pair[]} pairs\n     * @param {number} timeScale\n     */\n    Sleeping.afterCollisions = function(pairs, timeScale) {\n        var timeFactor = timeScale * timeScale * timeScale;\n\n        // wake up bodies involved in collisions\n        for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n            \n            // don't wake inactive pairs\n            if (!pair.isActive)\n                continue;\n\n            var collision = pair.collision,\n                bodyA = collision.bodyA.parent, \n                bodyB = collision.bodyB.parent;\n        \n            // don't wake if at least one body is static\n            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)\n                continue;\n        \n            if (bodyA.isSleeping || bodyB.isSleeping) {\n                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,\n                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n\n                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {\n                    Sleeping.set(sleepingBody, false);\n                }\n            }\n        }\n    };\n  \n    /**\n     * Set a body as sleeping or awake.\n     * @method set\n     * @param {body} body\n     * @param {boolean} isSleeping\n     */\n    Sleeping.set = function(body, isSleeping) {\n        var wasSleeping = body.isSleeping;\n\n        if (isSleeping) {\n            body.isSleeping = true;\n            body.sleepCounter = body.sleepThreshold;\n\n            body.positionImpulse.x = 0;\n            body.positionImpulse.y = 0;\n\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n\n            body.anglePrev = body.angle;\n            body.speed = 0;\n            body.angularSpeed = 0;\n            body.motion = 0;\n\n            if (!wasSleeping) {\n                Events.trigger(body, 'sleepStart');\n            }\n        } else {\n            body.isSleeping = false;\n            body.sleepCounter = 0;\n\n            if (wasSleeping) {\n                Events.trigger(body, 'sleepEnd');\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\n* The stiffness of constraints can be modified to create springs or elastic.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Constraint\n*/\n\nvar Constraint = {};\n\nmodule.exports = Constraint;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\nvar Sleeping = __webpack_require__(7);\nvar Bounds = __webpack_require__(1);\nvar Axes = __webpack_require__(10);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    Constraint._warming = 0.4;\n    Constraint._torqueDampen = 1;\n    Constraint._minLength = 0.000001;\n\n    /**\n     * Creates a new constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\n     * For compound bodies, constraints must be applied to the parent body (not one of its parts).\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {constraint} constraint\n     */\n    Constraint.create = function(options) {\n        var constraint = options;\n\n        // if bodies defined but no points, use body centre\n        if (constraint.bodyA && !constraint.pointA)\n            constraint.pointA = { x: 0, y: 0 };\n        if (constraint.bodyB && !constraint.pointB)\n            constraint.pointB = { x: 0, y: 0 };\n\n        // calculate static length using initial world space points\n        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,\n            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,\n            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\n    \n        constraint.length = typeof constraint.length !== 'undefined' ? constraint.length : length;\n\n        // option defaults\n        constraint.id = constraint.id || Common.nextId();\n        constraint.label = constraint.label || 'Constraint';\n        constraint.type = 'constraint';\n        constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);\n        constraint.damping = constraint.damping || 0;\n        constraint.angularStiffness = constraint.angularStiffness || 0;\n        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\n        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\n        constraint.plugin = {};\n\n        // render\n        var render = {\n            visible: true,\n            lineWidth: 2,\n            strokeStyle: '#ffffff',\n            type: 'line',\n            anchors: true\n        };\n\n        if (constraint.length === 0 && constraint.stiffness > 0.1) {\n            render.type = 'pin';\n            render.anchors = false;\n        } else if (constraint.stiffness < 0.9) {\n            render.type = 'spring';\n        }\n\n        constraint.render = Common.extend(render, constraint.render);\n\n        return constraint;\n    };\n\n    /**\n     * Prepares for solving by constraint warming.\n     * @private\n     * @method preSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.preSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\n                continue;\n            }\n\n            body.position.x += impulse.x;\n            body.position.y += impulse.y;\n            body.angle += impulse.angle;\n        }\n    };\n\n    /**\n     * Solves all constraints in a list of collisions.\n     * @private\n     * @method solveAll\n     * @param {constraint[]} constraints\n     * @param {number} timeScale\n     */\n    Constraint.solveAll = function(constraints, timeScale) {\n        // Solve fixed constraints first.\n        for (var i = 0; i < constraints.length; i += 1) {\n            var constraint = constraints[i],\n                fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic),\n                fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\n\n            if (fixedA || fixedB) {\n                Constraint.solve(constraints[i], timeScale);\n            }\n        }\n\n        // Solve free constraints last.\n        for (i = 0; i < constraints.length; i += 1) {\n            constraint = constraints[i];\n            fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic);\n            fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\n\n            if (!fixedA && !fixedB) {\n                Constraint.solve(constraints[i], timeScale);\n            }\n        }\n    };\n\n    /**\n     * Solves a distance constraint with Gauss-Siedel method.\n     * @private\n     * @method solve\n     * @param {constraint} constraint\n     * @param {number} timeScale\n     */\n    Constraint.solve = function(constraint, timeScale) {\n        var bodyA = constraint.bodyA,\n            bodyB = constraint.bodyB,\n            pointA = constraint.pointA,\n            pointB = constraint.pointB;\n\n        if (!bodyA && !bodyB)\n            return;\n\n        // update reference angle\n        if (bodyA && !bodyA.isStatic) {\n            Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);\n            constraint.angleA = bodyA.angle;\n        }\n        \n        // update reference angle\n        if (bodyB && !bodyB.isStatic) {\n            Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);\n            constraint.angleB = bodyB.angle;\n        }\n\n        var pointAWorld = pointA,\n            pointBWorld = pointB;\n\n        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\n        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\n\n        if (!pointAWorld || !pointBWorld)\n            return;\n\n        var delta = Vector.sub(pointAWorld, pointBWorld),\n            currentLength = Vector.magnitude(delta);\n\n        // prevent singularity\n        if (currentLength < Constraint._minLength) {\n            currentLength = Constraint._minLength;\n        }\n\n        // solve distance constraint with Gauss-Siedel method\n        var difference = (currentLength - constraint.length) / currentLength,\n            stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness,\n            force = Vector.mult(delta, difference * stiffness),\n            massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0),\n            inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0),\n            resistanceTotal = massTotal + inertiaTotal,\n            torque,\n            share,\n            normal,\n            normalVelocity,\n            relativeVelocity;\n\n        if (constraint.damping) {\n            var zero = Vector.create();\n            normal = Vector.div(delta, currentLength);\n\n            relativeVelocity = Vector.sub(\n                bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero,\n                bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero\n            );\n\n            normalVelocity = Vector.dot(normal, relativeVelocity);\n        }\n\n        if (bodyA && !bodyA.isStatic) {\n            share = bodyA.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyA.constraintImpulse.x -= force.x * share;\n            bodyA.constraintImpulse.y -= force.y * share;\n\n            // apply forces\n            bodyA.position.x -= force.x * share;\n            bodyA.position.y -= force.y * share;\n\n            // apply damping\n            if (constraint.damping) {\n                bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;\n                bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = (Vector.cross(pointA, force) / resistanceTotal) * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);\n            bodyA.constraintImpulse.angle -= torque;\n            bodyA.angle -= torque;\n        }\n\n        if (bodyB && !bodyB.isStatic) {\n            share = bodyB.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyB.constraintImpulse.x += force.x * share;\n            bodyB.constraintImpulse.y += force.y * share;\n            \n            // apply forces\n            bodyB.position.x += force.x * share;\n            bodyB.position.y += force.y * share;\n\n            // apply damping\n            if (constraint.damping) {\n                bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;\n                bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = (Vector.cross(pointB, force) / resistanceTotal) * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);\n            bodyB.constraintImpulse.angle += torque;\n            bodyB.angle += torque;\n        }\n\n    };\n\n    /**\n     * Performs body updates required after solving constraints.\n     * @private\n     * @method postSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.postSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\n                continue;\n            }\n\n            Sleeping.set(body, false);\n\n            // update geometry and reset\n            for (var j = 0; j < body.parts.length; j++) {\n                var part = body.parts[j];\n                \n                Vertices.translate(part.vertices, impulse);\n\n                if (j > 0) {\n                    part.position.x += impulse.x;\n                    part.position.y += impulse.y;\n                }\n\n                if (impulse.angle !== 0) {\n                    Vertices.rotate(part.vertices, impulse.angle, body.position);\n                    Axes.rotate(part.axes, impulse.angle);\n                    if (j > 0) {\n                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);\n                    }\n                }\n\n                Bounds.update(part.bounds, part.vertices, body.velocity);\n            }\n\n            // dampen the cached impulse for warming next step\n            impulse.angle *= Constraint._warming;\n            impulse.x *= Constraint._warming;\n            impulse.y *= Constraint._warming;\n        }\n    };\n\n    /**\n     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.\n     * @method pointAWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */\n    Constraint.pointAWorld = function(constraint) {\n        return {\n            x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,\n            y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y\n        };\n    };\n\n    /**\n     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.\n     * @method pointBWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */\n    Constraint.pointBWorld = function(constraint) {\n        return {\n            x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,\n            y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y\n        };\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Constraint\"\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the constraint should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the constraint outline.\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the constraint rendering type. \n     * The possible values are 'line', 'pin', 'spring'.\n     * An appropriate render type will be automatically chosen unless one is given in options.\n     *\n     * @property render.type\n     * @type string\n     * @default 'line'\n     */\n\n    /**\n     * A `Boolean` that defines if the constraint's anchor points should be rendered.\n     *\n     * @property render.anchors\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * The first possible `Body` that this constraint is attached to.\n     *\n     * @property bodyA\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The second possible `Body` that this constraint is attached to.\n     *\n     * @property bodyB\n     * @type body\n     * @default null\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n     *\n     * @property pointA\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.\n     *\n     * @property pointB\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\n     * A value of `1` means the constraint should be very stiff.\n     * A value of `0.2` means the constraint acts like a soft spring.\n     *\n     * @property stiffness\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the damping of the constraint, \n     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\n     * Damping will only be apparent when the constraint also has a very low `stiffness`.\n     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\n     * A value of `0` means the constraint will apply no damping.\n     *\n     * @property damping\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that specifies the target resting length of the constraint. \n     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     *\n     * @property length\n     * @type number\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n})();\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\n*\n* @class Pair\n*/\n\nvar Pair = {};\n\nmodule.exports = Pair;\n\nvar Contact = __webpack_require__(17);\n\n(function() {\n    \n    /**\n     * Creates a pair.\n     * @method create\n     * @param {collision} collision\n     * @param {number} timestamp\n     * @return {pair} A new pair\n     */\n    Pair.create = function(collision, timestamp) {\n        var bodyA = collision.bodyA,\n            bodyB = collision.bodyB,\n            parentA = collision.parentA,\n            parentB = collision.parentB;\n\n        var pair = {\n            id: Pair.id(bodyA, bodyB),\n            bodyA: bodyA,\n            bodyB: bodyB,\n            contacts: {},\n            activeContacts: [],\n            separation: 0,\n            isActive: true,\n            confirmedActive: true,\n            isSensor: bodyA.isSensor || bodyB.isSensor,\n            timeCreated: timestamp,\n            timeUpdated: timestamp,\n            inverseMass: parentA.inverseMass + parentB.inverseMass,\n            friction: Math.min(parentA.friction, parentB.friction),\n            frictionStatic: Math.max(parentA.frictionStatic, parentB.frictionStatic),\n            restitution: Math.max(parentA.restitution, parentB.restitution),\n            slop: Math.max(parentA.slop, parentB.slop)\n        };\n\n        Pair.update(pair, collision, timestamp);\n\n        return pair;\n    };\n\n    /**\n     * Updates a pair given a collision.\n     * @method update\n     * @param {pair} pair\n     * @param {collision} collision\n     * @param {number} timestamp\n     */\n    Pair.update = function(pair, collision, timestamp) {\n        var contacts = pair.contacts,\n            supports = collision.supports,\n            activeContacts = pair.activeContacts,\n            parentA = collision.parentA,\n            parentB = collision.parentB;\n        \n        pair.collision = collision;\n        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n        pair.friction = Math.min(parentA.friction, parentB.friction);\n        pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);\n        pair.restitution = Math.max(parentA.restitution, parentB.restitution);\n        pair.slop = Math.max(parentA.slop, parentB.slop);\n        activeContacts.length = 0;\n        \n        if (collision.collided) {\n            for (var i = 0; i < supports.length; i++) {\n                var support = supports[i],\n                    contactId = Contact.id(support),\n                    contact = contacts[contactId];\n\n                if (contact) {\n                    activeContacts.push(contact);\n                } else {\n                    activeContacts.push(contacts[contactId] = Contact.create(support));\n                }\n            }\n\n            pair.separation = collision.depth;\n            Pair.setActive(pair, true, timestamp);\n        } else {\n            if (pair.isActive === true)\n                Pair.setActive(pair, false, timestamp);\n        }\n    };\n    \n    /**\n     * Set a pair as active or inactive.\n     * @method setActive\n     * @param {pair} pair\n     * @param {bool} isActive\n     * @param {number} timestamp\n     */\n    Pair.setActive = function(pair, isActive, timestamp) {\n        if (isActive) {\n            pair.isActive = true;\n            pair.timeUpdated = timestamp;\n        } else {\n            pair.isActive = false;\n            pair.activeContacts.length = 0;\n        }\n    };\n\n    /**\n     * Get the id for the given pair.\n     * @method id\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {string} Unique pairId\n     */\n    Pair.id = function(bodyA, bodyB) {\n        if (bodyA.id < bodyB.id) {\n            return 'A' + bodyA.id + 'B' + bodyB.id;\n        } else {\n            return 'A' + bodyB.id + 'B' + bodyA.id;\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\n*\n* @class Axes\n*/\n\nvar Axes = {};\n\nmodule.exports = Axes;\n\nvar Vector = __webpack_require__(2);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new set of axes from the given vertices.\n     * @method fromVertices\n     * @param {vertices} vertices\n     * @return {axes} A new axes from the given vertices\n     */\n    Axes.fromVertices = function(vertices) {\n        var axes = {};\n\n        // find the unique axes, using edge normal gradients\n        for (var i = 0; i < vertices.length; i++) {\n            var j = (i + 1) % vertices.length, \n                normal = Vector.normalise({ \n                    x: vertices[j].y - vertices[i].y, \n                    y: vertices[i].x - vertices[j].x\n                }),\n                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);\n            \n            // limit precision\n            gradient = gradient.toFixed(3).toString();\n            axes[gradient] = normal;\n        }\n\n        return Common.values(axes);\n    };\n\n    /**\n     * Rotates a set of axes by the given angle.\n     * @method rotate\n     * @param {axes} axes\n     * @param {number} angle\n     */\n    Axes.rotate = function(axes, angle) {\n        if (angle === 0)\n            return;\n        \n        var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n\n        for (var i = 0; i < axes.length; i++) {\n            var axis = axes[i],\n                xx;\n            xx = axis.x * cos - axis.y * sin;\n            axis.y = axis.x * sin + axis.y * cos;\n            axis.x = xx;\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \n* with commonly used body configurations (such as rectangles, circles and other polygons).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Bodies\n*/\n\n// TODO: true circle bodies\n\nvar Bodies = {};\n\nmodule.exports = Bodies;\n\nvar Vertices = __webpack_require__(3);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(6);\nvar Bounds = __webpack_require__(1);\nvar Vector = __webpack_require__(2);\n\n(function() {\n\n    /**\n     * Creates a new rigid body model with a rectangle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method rectangle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {object} [options]\n     * @return {body} A new rectangle body\n     */\n    Bodies.rectangle = function(x, y, width, height, options) {\n        options = options || {};\n\n        var rectangle = { \n            label: 'Rectangle Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, rectangle, options));\n    };\n    \n    /**\n     * Creates a new rigid body model with a trapezoid hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method trapezoid\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} slope\n     * @param {object} [options]\n     * @return {body} A new trapezoid body\n     */\n    Bodies.trapezoid = function(x, y, width, height, slope, options) {\n        options = options || {};\n\n        slope *= 0.5;\n        var roof = (1 - (slope * 2)) * width;\n        \n        var x1 = width * slope,\n            x2 = x1 + roof,\n            x3 = x2 + x1,\n            verticesPath;\n\n        if (slope < 0.5) {\n            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\n        } else {\n            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\n        }\n\n        var trapezoid = { \n            label: 'Trapezoid Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(verticesPath)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, trapezoid, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a circle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {object} [options]\n     * @param {number} [maxSides]\n     * @return {body} A new circle body\n     */\n    Bodies.circle = function(x, y, radius, options, maxSides) {\n        options = options || {};\n\n        var circle = {\n            label: 'Circle Body',\n            circleRadius: radius\n        };\n        \n        // approximate circles with polygons until true circles implemented in SAT\n        maxSides = maxSides || 25;\n        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\n\n        // optimisation: always use even number of sides (half the number of unique axes)\n        if (sides % 2 === 1)\n            sides += 1;\n\n        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method polygon\n     * @param {number} x\n     * @param {number} y\n     * @param {number} sides\n     * @param {number} radius\n     * @param {object} [options]\n     * @return {body} A new regular polygon body\n     */\n    Bodies.polygon = function(x, y, sides, radius, options) {\n        options = options || {};\n\n        if (sides < 3)\n            return Bodies.circle(x, y, radius, options);\n\n        var theta = 2 * Math.PI / sides,\n            path = '',\n            offset = theta * 0.5;\n\n        for (var i = 0; i < sides; i += 1) {\n            var angle = offset + (i * theta),\n                xx = Math.cos(angle) * radius,\n                yy = Math.sin(angle) * radius;\n\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\n        }\n\n        var polygon = { \n            label: 'Polygon Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(path)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, polygon, options));\n    };\n\n    /**\n     * Utility to create a compound body based on set(s) of vertices.\n     * \n     * _Note:_ To optionally enable automatic concave vertices decomposition the [poly-decomp](https://github.com/schteppe/poly-decomp.js) \n     * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.\n     * \n     * The resulting vertices are reorientated about their centre of mass,\n     * and offset such that `body.position` corresponds to this point.\n     * \n     * The resulting offset may be found if needed by subtracting `body.bounds` from the original input bounds.\n     * To later move the centre of mass see `Body.setCentre`.\n     * \n     * Note that automatic conconcave decomposition results are not always optimal. \n     * For best results, simplify the input vertices as much as possible first.\n     * By default this function applies some addtional simplification to help.\n     * \n     * Some outputs may also require further manual processing afterwards to be robust.\n     * In particular some parts may need to be overlapped to avoid collision gaps.\n     * Thin parts and sharp points should be avoided or removed where possible.\n     *\n     * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults.\n     * \n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method fromVertices\n     * @param {number} x\n     * @param {number} y\n     * @param {array} vertexSets One or more arrays of vertex points e.g. `[[{ x: 0, y: 0 }...], ...]`.\n     * @param {object} [options] The body options.\n     * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`.\n     * @param {number} [removeCollinear=0.01] Threshold when simplifying vertices along the same edge.\n     * @param {number} [minimumArea=10] Threshold when removing small parts.\n     * @param {number} [removeDuplicatePoints=0.01] Threshold when simplifying nearby vertices.\n     * @return {body}\n     */\n    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {\n        var decomp = Common.getDecomp(),\n            canDecomp,\n            body,\n            parts,\n            isConvex,\n            isConcave,\n            vertices,\n            i,\n            j,\n            k,\n            v,\n            z;\n\n        // check decomp is as expected\n        canDecomp = Boolean(decomp && decomp.quickDecomp);\n\n        options = options || {};\n        parts = [];\n\n        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\n        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\n        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\n        removeDuplicatePoints = typeof removeDuplicatePoints !== 'undefined' ? removeDuplicatePoints : 0.01;\n\n        // ensure vertexSets is an array of arrays\n        if (!Common.isArray(vertexSets[0])) {\n            vertexSets = [vertexSets];\n        }\n\n        for (v = 0; v < vertexSets.length; v += 1) {\n            vertices = vertexSets[v];\n            isConvex = Vertices.isConvex(vertices);\n            isConcave = !isConvex;\n\n            if (isConcave && !canDecomp) {\n                Common.warnOnce(\n                    'Bodies.fromVertices: Install the \\'poly-decomp\\' library and use Common.setDecomp or provide \\'decomp\\' as a global to decompose concave vertices.'\n                );\n            }\n\n            if (isConvex || !canDecomp) {\n                if (isConvex) {\n                    vertices = Vertices.clockwiseSort(vertices);\n                } else {\n                    // fallback to convex hull when decomposition is not possible\n                    vertices = Vertices.hull(vertices);\n                }\n\n                parts.push({\n                    position: { x: x, y: y },\n                    vertices: vertices\n                });\n            } else {\n                // initialise a decomposition\n                var concave = vertices.map(function(vertex) {\n                    return [vertex.x, vertex.y];\n                });\n\n                // vertices are concave and simple, we can decompose into parts\n                decomp.makeCCW(concave);\n                if (removeCollinear !== false)\n                    decomp.removeCollinearPoints(concave, removeCollinear);\n                if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints)\n                    decomp.removeDuplicatePoints(concave, removeDuplicatePoints);\n\n                // use the quick decomposition algorithm (Bayazit)\n                var decomposed = decomp.quickDecomp(concave);\n\n                // for each decomposed chunk\n                for (i = 0; i < decomposed.length; i++) {\n                    var chunk = decomposed[i];\n\n                    // convert vertices into the correct structure\n                    var chunkVertices = chunk.map(function(vertices) {\n                        return {\n                            x: vertices[0],\n                            y: vertices[1]\n                        };\n                    });\n\n                    // skip small chunks\n                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)\n                        continue;\n\n                    // create a compound part\n                    parts.push({\n                        position: Vertices.centre(chunkVertices),\n                        vertices: chunkVertices\n                    });\n                }\n            }\n        }\n\n        // create body parts\n        for (i = 0; i < parts.length; i++) {\n            parts[i] = Body.create(Common.extend(parts[i], options));\n        }\n\n        // flag internal edges (coincident part edges)\n        if (flagInternal) {\n            var coincident_max_dist = 5;\n\n            for (i = 0; i < parts.length; i++) {\n                var partA = parts[i];\n\n                for (j = i + 1; j < parts.length; j++) {\n                    var partB = parts[j];\n\n                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n                        var pav = partA.vertices,\n                            pbv = partB.vertices;\n\n                        // iterate vertices of both parts\n                        for (k = 0; k < partA.vertices.length; k++) {\n                            for (z = 0; z < partB.vertices.length; z++) {\n                                // find distances between the vertices\n                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),\n                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\n\n                                // if both vertices are very close, consider the edge concident (internal)\n                                if (da < coincident_max_dist && db < coincident_max_dist) {\n                                    pav[k].isInternal = true;\n                                    pbv[z].isInternal = true;\n                                }\n                            }\n                        }\n\n                    }\n                }\n            }\n        }\n\n        if (parts.length > 1) {\n            // create the parent body to be returned, that contains generated compound parts\n            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));\n\n            // offset such that body.position is at the centre off mass\n            Body.setPosition(body, { x: x, y: y });\n\n            return body;\n        } else {\n            return parts[0];\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.\n*\n* @class Mouse\n*/\n\nvar Mouse = {};\n\nmodule.exports = Mouse;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a mouse input.\n     * @method create\n     * @param {HTMLElement} element\n     * @return {mouse} A new mouse\n     */\n    Mouse.create = function(element) {\n        var mouse = {};\n\n        if (!element) {\n            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');\n        }\n        \n        mouse.element = element || document.body;\n        mouse.absolute = { x: 0, y: 0 };\n        mouse.position = { x: 0, y: 0 };\n        mouse.mousedownPosition = { x: 0, y: 0 };\n        mouse.mouseupPosition = { x: 0, y: 0 };\n        mouse.offset = { x: 0, y: 0 };\n        mouse.scale = { x: 1, y: 1 };\n        mouse.wheelDelta = 0;\n        mouse.button = -1;\n        mouse.pixelRatio = parseInt(mouse.element.getAttribute('data-pixel-ratio'), 10) || 1;\n\n        mouse.sourceEvents = {\n            mousemove: null,\n            mousedown: null,\n            mouseup: null,\n            mousewheel: null\n        };\n        \n        mouse.mousemove = function(event) { \n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.sourceEvents.mousemove = event;\n        };\n        \n        mouse.mousedown = function(event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            } else {\n                mouse.button = event.button;\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mousedownPosition.x = mouse.position.x;\n            mouse.mousedownPosition.y = mouse.position.y;\n            mouse.sourceEvents.mousedown = event;\n        };\n        \n        mouse.mouseup = function(event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                event.preventDefault();\n            }\n            \n            mouse.button = -1;\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mouseupPosition.x = mouse.position.x;\n            mouse.mouseupPosition.y = mouse.position.y;\n            mouse.sourceEvents.mouseup = event;\n        };\n\n        mouse.mousewheel = function(event) {\n            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n            event.preventDefault();\n        };\n\n        Mouse.setElement(mouse, mouse.element);\n\n        return mouse;\n    };\n\n    /**\n     * Sets the element the mouse is bound to (and relative to).\n     * @method setElement\n     * @param {mouse} mouse\n     * @param {HTMLElement} element\n     */\n    Mouse.setElement = function(mouse, element) {\n        mouse.element = element;\n\n        element.addEventListener('mousemove', mouse.mousemove);\n        element.addEventListener('mousedown', mouse.mousedown);\n        element.addEventListener('mouseup', mouse.mouseup);\n        \n        element.addEventListener('mousewheel', mouse.mousewheel);\n        element.addEventListener('DOMMouseScroll', mouse.mousewheel);\n\n        element.addEventListener('touchmove', mouse.mousemove);\n        element.addEventListener('touchstart', mouse.mousedown);\n        element.addEventListener('touchend', mouse.mouseup);\n    };\n\n    /**\n     * Clears all captured source events.\n     * @method clearSourceEvents\n     * @param {mouse} mouse\n     */\n    Mouse.clearSourceEvents = function(mouse) {\n        mouse.sourceEvents.mousemove = null;\n        mouse.sourceEvents.mousedown = null;\n        mouse.sourceEvents.mouseup = null;\n        mouse.sourceEvents.mousewheel = null;\n        mouse.wheelDelta = 0;\n    };\n\n    /**\n     * Sets the mouse position offset.\n     * @method setOffset\n     * @param {mouse} mouse\n     * @param {vector} offset\n     */\n    Mouse.setOffset = function(mouse, offset) {\n        mouse.offset.x = offset.x;\n        mouse.offset.y = offset.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n\n    /**\n     * Sets the mouse position scale.\n     * @method setScale\n     * @param {mouse} mouse\n     * @param {vector} scale\n     */\n    Mouse.setScale = function(mouse, scale) {\n        mouse.scale.x = scale.x;\n        mouse.scale.y = scale.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n    \n    /**\n     * Gets the mouse position relative to an element given a screen pixel ratio.\n     * @method _getRelativeMousePosition\n     * @private\n     * @param {} event\n     * @param {} element\n     * @param {number} pixelRatio\n     * @return {}\n     */\n    Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {\n        var elementBounds = element.getBoundingClientRect(),\n            rootNode = (document.documentElement || document.body.parentNode || document.body),\n            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,\n            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,\n            touches = event.changedTouches,\n            x, y;\n        \n        if (touches) {\n            x = touches[0].pageX - elementBounds.left - scrollX;\n            y = touches[0].pageY - elementBounds.top - scrollY;\n        } else {\n            x = event.pageX - elementBounds.left - scrollX;\n            y = event.pageY - elementBounds.top - scrollY;\n        }\n\n        return { \n            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),\n            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)\n        };\n    };\n\n})();\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\n*\n* @class Detector\n*/\n\n// TODO: speculative contacts\n\nvar Detector = {};\n\nmodule.exports = Detector;\n\nvar SAT = __webpack_require__(14);\nvar Pair = __webpack_require__(9);\nvar Bounds = __webpack_require__(1);\n\n(function() {\n\n    /**\n     * Finds all collisions given a list of pairs.\n     * @method collisions\n     * @param {pair[]} broadphasePairs\n     * @param {engine} engine\n     * @return {array} collisions\n     */\n    Detector.collisions = function(broadphasePairs, engine) {\n        var collisions = [],\n            pairsTable = engine.pairs.table;\n\n        for (var i = 0; i < broadphasePairs.length; i++) {\n            var bodyA = broadphasePairs[i][0], \n                bodyB = broadphasePairs[i][1];\n\n            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))\n                continue;\n            \n            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))\n                continue;\n\n            // mid phase\n            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\n                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {\n                    var partA = bodyA.parts[j];\n\n                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {\n                        var partB = bodyB.parts[k];\n\n                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {\n                            // find a previous collision we could reuse\n                            var pairId = Pair.id(partA, partB),\n                                pair = pairsTable[pairId],\n                                previousCollision;\n\n                            if (pair && pair.isActive) {\n                                previousCollision = pair.collision;\n                            } else {\n                                previousCollision = null;\n                            }\n\n                            // narrow phase\n                            var collision = SAT.collides(partA, partB, previousCollision);\n\n                            if (collision.collided) {\n                                collisions.push(collision);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\n     * See `body.collisionFilter` for more information.\n     * @method canCollide\n     * @param {} filterA\n     * @param {} filterB\n     * @return {bool} `true` if collision can occur\n     */\n    Detector.canCollide = function(filterA, filterB) {\n        if (filterA.group === filterB.group && filterA.group !== 0)\n            return filterA.group > 0;\n\n        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n    };\n\n})();\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\n*\n* @class SAT\n*/\n\n// TODO: true circles and curves\n\nvar SAT = {};\n\nmodule.exports = SAT;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\n\n(function() {\n\n    /**\n     * Detect collision between two bodies using the Separating Axis Theorem.\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {collision} previousCollision\n     * @return {collision} collision\n     */\n    SAT.collides = function(bodyA, bodyB, previousCollision) {\n        var overlapAB,\n            overlapBA, \n            minOverlap,\n            collision,\n            canReusePrevCol = false;\n\n        if (previousCollision) {\n            // estimate total motion\n            var parentA = bodyA.parent,\n                parentB = bodyB.parent,\n                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed\n                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;\n\n            // we may be able to (partially) reuse collision result \n            // but only safe if collision was resting\n            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;\n\n            // reuse collision object\n            collision = previousCollision;\n        } else {\n            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };\n        }\n\n        if (previousCollision && canReusePrevCol) {\n            // if we can reuse the collision result\n            // we only need to test the previously found axis\n            var axisBodyA = collision.axisBody,\n                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,\n                axes = [axisBodyA.axes[previousCollision.axisNumber]];\n\n            minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);\n            collision.reused = true;\n\n            if (minOverlap.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n        } else {\n            // if we can't reuse a result, perform a full SAT test\n\n            overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);\n\n            if (overlapAB.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n\n            overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);\n\n            if (overlapBA.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n\n            if (overlapAB.overlap < overlapBA.overlap) {\n                minOverlap = overlapAB;\n                collision.axisBody = bodyA;\n            } else {\n                minOverlap = overlapBA;\n                collision.axisBody = bodyB;\n            }\n\n            // important for reuse later\n            collision.axisNumber = minOverlap.axisNumber;\n        }\n\n        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n        collision.collided = true;\n        collision.depth = minOverlap.overlap;\n        collision.parentA = collision.bodyA.parent;\n        collision.parentB = collision.bodyB.parent;\n        \n        bodyA = collision.bodyA;\n        bodyB = collision.bodyB;\n\n        // ensure normal is facing away from bodyA\n        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {\n            collision.normal = {\n                x: minOverlap.axis.x,\n                y: minOverlap.axis.y\n            };\n        } else {\n            collision.normal = {\n                x: -minOverlap.axis.x,\n                y: -minOverlap.axis.y\n            };\n        }\n\n        collision.tangent = Vector.perp(collision.normal);\n\n        collision.penetration = collision.penetration || {};\n        collision.penetration.x = collision.normal.x * collision.depth;\n        collision.penetration.y = collision.normal.y * collision.depth; \n\n        // find support points, there is always either exactly one or two\n        var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal),\n            supports = [];\n\n        // find the supports from bodyB that are inside bodyA\n        if (Vertices.contains(bodyA.vertices, verticesB[0]))\n            supports.push(verticesB[0]);\n\n        if (Vertices.contains(bodyA.vertices, verticesB[1]))\n            supports.push(verticesB[1]);\n\n        // find the supports from bodyA that are inside bodyB\n        if (supports.length < 2) {\n            var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));\n                \n            if (Vertices.contains(bodyB.vertices, verticesA[0]))\n                supports.push(verticesA[0]);\n\n            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))\n                supports.push(verticesA[1]);\n        }\n\n        // account for the edge case of overlapping but no vertex containment\n        if (supports.length < 1)\n            supports = [verticesB[0]];\n        \n        collision.supports = supports;\n\n        return collision;\n    };\n\n    /**\n     * Find the overlap between two sets of vertices.\n     * @method _overlapAxes\n     * @private\n     * @param {} verticesA\n     * @param {} verticesB\n     * @param {} axes\n     * @return result\n     */\n    SAT._overlapAxes = function(verticesA, verticesB, axes) {\n        var projectionA = Vector._temp[0], \n            projectionB = Vector._temp[1],\n            result = { overlap: Number.MAX_VALUE },\n            overlap,\n            axis;\n\n        for (var i = 0; i < axes.length; i++) {\n            axis = axes[i];\n\n            SAT._projectToAxis(projectionA, verticesA, axis);\n            SAT._projectToAxis(projectionB, verticesB, axis);\n\n            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\n\n            if (overlap <= 0) {\n                result.overlap = overlap;\n                return result;\n            }\n\n            if (overlap < result.overlap) {\n                result.overlap = overlap;\n                result.axis = axis;\n                result.axisNumber = i;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Projects vertices on an axis and returns an interval.\n     * @method _projectToAxis\n     * @private\n     * @param {} projection\n     * @param {} vertices\n     * @param {} axis\n     */\n    SAT._projectToAxis = function(projection, vertices, axis) {\n        var min = Vector.dot(vertices[0], axis),\n            max = min;\n\n        for (var i = 1; i < vertices.length; i += 1) {\n            var dot = Vector.dot(vertices[i], axis);\n\n            if (dot > max) { \n                max = dot; \n            } else if (dot < min) { \n                min = dot; \n            }\n        }\n\n        projection.min = min;\n        projection.max = max;\n    };\n    \n    /**\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\n     * @method _findSupports\n     * @private\n     * @param {} bodyA\n     * @param {} bodyB\n     * @param {} normal\n     * @return [vector]\n     */\n    SAT._findSupports = function(bodyA, bodyB, normal) {\n        var nearestDistance = Number.MAX_VALUE,\n            vertexToBody = Vector._temp[0],\n            vertices = bodyB.vertices,\n            bodyAPosition = bodyA.position,\n            distance,\n            vertex,\n            vertexA,\n            vertexB;\n\n        // find closest vertex on bodyB\n        for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            vertexToBody.x = vertex.x - bodyAPosition.x;\n            vertexToBody.y = vertex.y - bodyAPosition.y;\n            distance = -Vector.dot(normal, vertexToBody);\n\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                vertexA = vertex;\n            }\n        }\n\n        // find next closest vertex using the two connected to it\n        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;\n        vertex = vertices[prevIndex];\n        vertexToBody.x = vertex.x - bodyAPosition.x;\n        vertexToBody.y = vertex.y - bodyAPosition.y;\n        nearestDistance = -Vector.dot(normal, vertexToBody);\n        vertexB = vertex;\n\n        var nextIndex = (vertexA.index + 1) % vertices.length;\n        vertex = vertices[nextIndex];\n        vertexToBody.x = vertex.x - bodyAPosition.x;\n        vertexToBody.y = vertex.y - bodyAPosition.y;\n        distance = -Vector.dot(normal, vertexToBody);\n        if (distance < nearestDistance) {\n            vertexB = vertex;\n        }\n\n        return [vertexA, vertexB];\n    };\n\n})();\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\n*\n* @class Plugin\n*/\n\nvar Plugin = {};\n\nmodule.exports = Plugin;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    Plugin._registry = {};\n\n    /**\n     * Registers a plugin object so it can be resolved later by name.\n     * @method register\n     * @param plugin {} The plugin to register.\n     * @return {object} The plugin.\n     */\n    Plugin.register = function(plugin) {\n        if (!Plugin.isPlugin(plugin)) {\n            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');\n        }\n\n        if (plugin.name in Plugin._registry) {\n            var registered = Plugin._registry[plugin.name],\n                pluginVersion = Plugin.versionParse(plugin.version).number,\n                registeredVersion = Plugin.versionParse(registered.version).number;\n\n            if (pluginVersion > registeredVersion) {\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));\n                Plugin._registry[plugin.name] = plugin;\n            } else if (pluginVersion < registeredVersion) {\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));\n            } else if (plugin !== registered) {\n                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');\n            }\n        } else {\n            Plugin._registry[plugin.name] = plugin;\n        }\n\n        return plugin;\n    };\n\n    /**\n     * Resolves a dependency to a plugin object from the registry if it exists. \n     * The `dependency` may contain a version, but only the name matters when resolving.\n     * @method resolve\n     * @param dependency {string} The dependency.\n     * @return {object} The plugin if resolved, otherwise `undefined`.\n     */\n    Plugin.resolve = function(dependency) {\n        return Plugin._registry[Plugin.dependencyParse(dependency).name];\n    };\n\n    /**\n     * Returns a pretty printed plugin name and version.\n     * @method toString\n     * @param plugin {} The plugin.\n     * @return {string} Pretty printed plugin name and version.\n     */\n    Plugin.toString = function(plugin) {\n        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');\n    };\n\n    /**\n     * Returns `true` if the object meets the minimum standard to be considered a plugin.\n     * This means it must define the following properties:\n     * - `name`\n     * - `version`\n     * - `install`\n     * @method isPlugin\n     * @param obj {} The obj to test.\n     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\n     */\n    Plugin.isPlugin = function(obj) {\n        return obj && obj.name && obj.version && obj.install;\n    };\n\n    /**\n     * Returns `true` if a plugin with the given `name` been installed on `module`.\n     * @method isUsed\n     * @param module {} The module.\n     * @param name {string} The plugin name.\n     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\n     */\n    Plugin.isUsed = function(module, name) {\n        return module.used.indexOf(name) > -1;\n    };\n\n    /**\n     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\n     * If `plugin.for` is not specified then it is assumed to be applicable.\n     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\n     * @method isFor\n     * @param plugin {} The plugin.\n     * @param module {} The module.\n     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\n     */\n    Plugin.isFor = function(plugin, module) {\n        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);\n        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));\n    };\n\n    /**\n     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\n     * For installing plugins on `Matter` see the convenience function `Matter.use`.\n     * Plugins may be specified either by their name or a reference to the plugin object.\n     * Plugins themselves may specify further dependencies, but each plugin is installed only once.\n     * Order is important, a topological sort is performed to find the best resulting order of installation.\n     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\n     * This function logs the resulting status of each dependency in the console, along with any warnings.\n     * - A green tick ✅ indicates a dependency was resolved and installed.\n     * - An orange diamond 🔶 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\n     * - A red cross ❌ indicates a dependency could not be resolved.\n     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\n     * @method use\n     * @param module {} The module install plugins on.\n     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\n     */\n    Plugin.use = function(module, plugins) {\n        module.uses = (module.uses || []).concat(plugins || []);\n\n        if (module.uses.length === 0) {\n            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');\n            return;\n        }\n\n        var dependencies = Plugin.dependencies(module),\n            sortedDependencies = Common.topologicalSort(dependencies),\n            status = [];\n\n        for (var i = 0; i < sortedDependencies.length; i += 1) {\n            if (sortedDependencies[i] === module.name) {\n                continue;\n            }\n\n            var plugin = Plugin.resolve(sortedDependencies[i]);\n\n            if (!plugin) {\n                status.push('❌ ' + sortedDependencies[i]);\n                continue;\n            }\n\n            if (Plugin.isUsed(module, plugin.name)) {\n                continue;\n            }\n\n            if (!Plugin.isFor(plugin, module)) {\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');\n                plugin._warned = true;\n            }\n\n            if (plugin.install) {\n                plugin.install(module);\n            } else {\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');\n                plugin._warned = true;\n            }\n\n            if (plugin._warned) {\n                status.push('🔶 ' + Plugin.toString(plugin));\n                delete plugin._warned;\n            } else {\n                status.push('✅ ' + Plugin.toString(plugin));\n            }\n\n            module.used.push(plugin.name);\n        }\n\n        if (status.length > 0) {\n            Common.info(status.join('  '));\n        }\n    };\n\n    /**\n     * Recursively finds all of a module's dependencies and returns a flat dependency graph.\n     * @method dependencies\n     * @param module {} The module.\n     * @return {object} A dependency graph.\n     */\n    Plugin.dependencies = function(module, tracked) {\n        var parsedBase = Plugin.dependencyParse(module),\n            name = parsedBase.name;\n\n        tracked = tracked || {};\n\n        if (name in tracked) {\n            return;\n        }\n\n        module = Plugin.resolve(module) || module;\n\n        tracked[name] = Common.map(module.uses || [], function(dependency) {\n            if (Plugin.isPlugin(dependency)) {\n                Plugin.register(dependency);\n            }\n\n            var parsed = Plugin.dependencyParse(dependency),\n                resolved = Plugin.resolve(dependency);\n\n            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {\n                Common.warn(\n                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',\n                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'\n                );\n\n                resolved._warned = true;\n                module._warned = true;\n            } else if (!resolved) {\n                Common.warn(\n                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',\n                    Plugin.toString(parsedBase), 'could not be resolved.'\n                );\n\n                module._warned = true;\n            }\n\n            return parsed.name;\n        });\n\n        for (var i = 0; i < tracked[name].length; i += 1) {\n            Plugin.dependencies(tracked[name][i], tracked);\n        }\n\n        return tracked;\n    };\n\n    /**\n     * Parses a dependency string into its components.\n     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * This function can also handle dependencies that are already resolved (e.g. a module object).\n     * @method dependencyParse\n     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\n     * @return {object} The dependency parsed into its components.\n     */\n    Plugin.dependencyParse = function(dependency) {\n        if (Common.isString(dependency)) {\n            var pattern = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?))?$/;\n\n            if (!pattern.test(dependency)) {\n                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');\n            }\n\n            return {\n                name: dependency.split('@')[0],\n                range: dependency.split('@')[1] || '*'\n            };\n        }\n\n        return {\n            name: dependency.name,\n            range: dependency.range || dependency.version\n        };\n    };\n\n    /**\n     * Parses a version string into its components.  \n     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\n     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\n     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\n     * Only the following range types are supported:\n     * - Tilde ranges e.g. `~1.2.3`\n     * - Caret ranges e.g. `^1.2.3`\n     * - Greater than ranges e.g. `>1.2.3`\n     * - Greater than or equal ranges e.g. `>=1.2.3`\n     * - Exact version e.g. `1.2.3`\n     * - Any version `*`\n     * @method versionParse\n     * @param range {string} The version string.\n     * @return {object} The version range parsed into its components.\n     */\n    Plugin.versionParse = function(range) {\n        var pattern = /^(\\*)|(\\^|~|>=|>)?\\s*((\\d+)\\.(\\d+)\\.(\\d+))(-[0-9A-Za-z-]+)?$/;\n\n        if (!pattern.test(range)) {\n            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');\n        }\n\n        var parts = pattern.exec(range);\n        var major = Number(parts[4]);\n        var minor = Number(parts[5]);\n        var patch = Number(parts[6]);\n\n        return {\n            isRange: Boolean(parts[1] || parts[2]),\n            version: parts[3],\n            range: range,\n            operator: parts[1] || parts[2] || '',\n            major: major,\n            minor: minor,\n            patch: patch,\n            parts: [major, minor, patch],\n            prerelease: parts[7],\n            number: major * 1e8 + minor * 1e4 + patch\n        };\n    };\n\n    /**\n     * Returns `true` if `version` satisfies the given `range`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\n     * @method versionSatisfies\n     * @param version {string} The version string.\n     * @param range {string} The range string.\n     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\n     */\n    Plugin.versionSatisfies = function(version, range) {\n        range = range || '*';\n\n        var r = Plugin.versionParse(range),\n            v = Plugin.versionParse(version);\n\n        if (r.isRange) {\n            if (r.operator === '*' || version === '*') {\n                return true;\n            }\n\n            if (r.operator === '>') {\n                return v.number > r.number;\n            }\n\n            if (r.operator === '>=') {\n                return v.number >= r.number;\n            }\n\n            if (r.operator === '~') {\n                return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;\n            }\n\n            if (r.operator === '^') {\n                if (r.major > 0) {\n                    return v.major === r.major && v.number >= r.number;\n                }\n\n                if (r.minor > 0) {\n                    return v.minor === r.minor && v.patch >= r.patch;\n                }\n\n                return v.patch === r.patch;\n            }\n        }\n\n        return version === range || version === '*';\n    };\n\n})();\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Render` module is a simple canvas based renderer for visualising instances of `Matter.Engine`.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.\n*\n* @class Render\n*/\n\nvar Render = {};\n\nmodule.exports = Render;\n\nvar Common = __webpack_require__(0);\nvar Composite = __webpack_require__(5);\nvar Bounds = __webpack_require__(1);\nvar Events = __webpack_require__(4);\nvar Vector = __webpack_require__(2);\nvar Mouse = __webpack_require__(12);\n\n(function() {\n\n    var _requestAnimationFrame,\n        _cancelAnimationFrame;\n\n    if (typeof window !== 'undefined') {\n        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\n                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\n                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };\n\n        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame\n                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n    }\n\n    Render._goodFps = 30;\n    Render._goodDelta = 1000 / 60;\n\n    /**\n     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {render} A new renderer\n     */\n    Render.create = function(options) {\n        var defaults = {\n            controller: Render,\n            engine: null,\n            element: null,\n            canvas: null,\n            mouse: null,\n            frameRequestId: null,\n            timing: {\n                historySize: 60,\n                delta: 0,\n                deltaHistory: [],\n                lastTime: 0,\n                lastTimestamp: 0,\n                lastElapsed: 0,\n                timestampElapsed: 0,\n                timestampElapsedHistory: [],\n                engineDeltaHistory: [],\n                engineElapsedHistory: [],\n                elapsedHistory: []\n            },\n            options: {\n                width: 800,\n                height: 600,\n                pixelRatio: 1,\n                background: '#14151f',\n                wireframeBackground: '#14151f',\n                hasBounds: !!options.bounds,\n                enabled: true,\n                wireframes: true,\n                showSleeping: true,\n                showDebug: false,\n                showStats: false,\n                showPerformance: false,\n                showBroadphase: false,\n                showBounds: false,\n                showVelocity: false,\n                showCollisions: false,\n                showSeparations: false,\n                showAxes: false,\n                showPositions: false,\n                showAngleIndicator: false,\n                showIds: false,\n                showVertexNumbers: false,\n                showConvexHulls: false,\n                showInternalEdges: false,\n                showMousePosition: false\n            }\n        };\n\n        var render = Common.extend(defaults, options);\n\n        if (render.canvas) {\n            render.canvas.width = render.options.width || render.canvas.width;\n            render.canvas.height = render.options.height || render.canvas.height;\n        }\n\n        render.mouse = options.mouse;\n        render.engine = options.engine;\n        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);\n        render.context = render.canvas.getContext('2d');\n        render.textures = {};\n\n        render.bounds = render.bounds || {\n            min: {\n                x: 0,\n                y: 0\n            },\n            max: {\n                x: render.canvas.width,\n                y: render.canvas.height\n            }\n        };\n\n        if (render.options.pixelRatio !== 1) {\n            Render.setPixelRatio(render, render.options.pixelRatio);\n        }\n\n        if (Common.isElement(render.element)) {\n            render.element.appendChild(render.canvas);\n        } else if (!render.canvas.parentNode) {\n            Common.log('Render.create: options.element was undefined, render.canvas was created but not appended', 'warn');\n        }\n\n        return render;\n    };\n\n    /**\n     * Continuously updates the render canvas on the `requestAnimationFrame` event.\n     * @method run\n     * @param {render} render\n     */\n    Render.run = function(render) {\n        (function loop(time){\n            render.frameRequestId = _requestAnimationFrame(loop);\n            \n            _updateTiming(render, time);\n\n            Render.world(render, time);\n\n            if (render.options.showStats || render.options.showDebug) {\n                Render.stats(render, render.context, time);\n            }\n\n            if (render.options.showPerformance || render.options.showDebug) {\n                Render.performance(render, render.context, time);\n            }\n        })();\n    };\n\n    /**\n     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.\n     * @method stop\n     * @param {render} render\n     */\n    Render.stop = function(render) {\n        _cancelAnimationFrame(render.frameRequestId);\n    };\n\n    /**\n     * Sets the pixel ratio of the renderer and updates the canvas.\n     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.\n     * @method setPixelRatio\n     * @param {render} render\n     * @param {number} pixelRatio\n     */\n    Render.setPixelRatio = function(render, pixelRatio) {\n        var options = render.options,\n            canvas = render.canvas;\n\n        if (pixelRatio === 'auto') {\n            pixelRatio = _getPixelRatio(canvas);\n        }\n\n        options.pixelRatio = pixelRatio;\n        canvas.setAttribute('data-pixel-ratio', pixelRatio);\n        canvas.width = options.width * pixelRatio;\n        canvas.height = options.height * pixelRatio;\n        canvas.style.width = options.width + 'px';\n        canvas.style.height = options.height + 'px';\n    };\n\n    /**\n     * Positions and sizes the viewport around the given object bounds.\n     * Objects must have at least one of the following properties:\n     * - `object.bounds`\n     * - `object.position`\n     * - `object.min` and `object.max`\n     * - `object.x` and `object.y`\n     * @method lookAt\n     * @param {render} render\n     * @param {object[]} objects\n     * @param {vector} [padding]\n     * @param {bool} [center=true]\n     */\n    Render.lookAt = function(render, objects, padding, center) {\n        center = typeof center !== 'undefined' ? center : true;\n        objects = Common.isArray(objects) ? objects : [objects];\n        padding = padding || {\n            x: 0,\n            y: 0\n        };\n\n        // find bounds of all objects\n        var bounds = {\n            min: { x: Infinity, y: Infinity },\n            max: { x: -Infinity, y: -Infinity }\n        };\n\n        for (var i = 0; i < objects.length; i += 1) {\n            var object = objects[i],\n                min = object.bounds ? object.bounds.min : (object.min || object.position || object),\n                max = object.bounds ? object.bounds.max : (object.max || object.position || object);\n\n            if (min && max) {\n                if (min.x < bounds.min.x)\n                    bounds.min.x = min.x;\n\n                if (max.x > bounds.max.x)\n                    bounds.max.x = max.x;\n\n                if (min.y < bounds.min.y)\n                    bounds.min.y = min.y;\n\n                if (max.y > bounds.max.y)\n                    bounds.max.y = max.y;\n            }\n        }\n\n        // find ratios\n        var width = (bounds.max.x - bounds.min.x) + 2 * padding.x,\n            height = (bounds.max.y - bounds.min.y) + 2 * padding.y,\n            viewHeight = render.canvas.height,\n            viewWidth = render.canvas.width,\n            outerRatio = viewWidth / viewHeight,\n            innerRatio = width / height,\n            scaleX = 1,\n            scaleY = 1;\n\n        // find scale factor\n        if (innerRatio > outerRatio) {\n            scaleY = innerRatio / outerRatio;\n        } else {\n            scaleX = outerRatio / innerRatio;\n        }\n\n        // enable bounds\n        render.options.hasBounds = true;\n\n        // position and size\n        render.bounds.min.x = bounds.min.x;\n        render.bounds.max.x = bounds.min.x + width * scaleX;\n        render.bounds.min.y = bounds.min.y;\n        render.bounds.max.y = bounds.min.y + height * scaleY;\n\n        // center\n        if (center) {\n            render.bounds.min.x += width * 0.5 - (width * scaleX) * 0.5;\n            render.bounds.max.x += width * 0.5 - (width * scaleX) * 0.5;\n            render.bounds.min.y += height * 0.5 - (height * scaleY) * 0.5;\n            render.bounds.max.y += height * 0.5 - (height * scaleY) * 0.5;\n        }\n\n        // padding\n        render.bounds.min.x -= padding.x;\n        render.bounds.max.x -= padding.x;\n        render.bounds.min.y -= padding.y;\n        render.bounds.max.y -= padding.y;\n\n        // update mouse\n        if (render.mouse) {\n            Mouse.setScale(render.mouse, {\n                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,\n                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height\n            });\n\n            Mouse.setOffset(render.mouse, render.bounds.min);\n        }\n    };\n\n    /**\n     * Applies viewport transforms based on `render.bounds` to a render context.\n     * @method startViewTransform\n     * @param {render} render\n     */\n    Render.startViewTransform = function(render) {\n        var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n            boundsHeight = render.bounds.max.y - render.bounds.min.y,\n            boundsScaleX = boundsWidth / render.options.width,\n            boundsScaleY = boundsHeight / render.options.height;\n\n        render.context.setTransform(\n            render.options.pixelRatio / boundsScaleX, 0, 0, \n            render.options.pixelRatio / boundsScaleY, 0, 0\n        );\n        \n        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);\n    };\n\n    /**\n     * Resets all transforms on the render context.\n     * @method endViewTransform\n     * @param {render} render\n     */\n    Render.endViewTransform = function(render) {\n        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n    };\n\n    /**\n     * Renders the given `engine`'s `Matter.World` object.\n     * This is the entry point for all rendering and should be called every time the scene changes.\n     * @method world\n     * @param {render} render\n     */\n    Render.world = function(render, time) {\n        var startTime = Common.now(),\n            engine = render.engine,\n            world = engine.world,\n            canvas = render.canvas,\n            context = render.context,\n            options = render.options,\n            timing = render.timing;\n\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world),\n            background = options.wireframes ? options.wireframeBackground : options.background,\n            bodies = [],\n            constraints = [],\n            i;\n\n        var event = {\n            timestamp: engine.timing.timestamp\n        };\n\n        Events.trigger(render, 'beforeRender', event);\n\n        // apply background if it has changed\n        if (render.currentBackground !== background)\n            _applyBackground(render, background);\n\n        // clear the canvas with a transparent fill, to allow the canvas background to show\n        context.globalCompositeOperation = 'source-in';\n        context.fillStyle = \"transparent\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        context.globalCompositeOperation = 'source-over';\n\n        // handle bounds\n        if (options.hasBounds) {\n            // filter out bodies that are not in view\n            for (i = 0; i < allBodies.length; i++) {\n                var body = allBodies[i];\n                if (Bounds.overlaps(body.bounds, render.bounds))\n                    bodies.push(body);\n            }\n\n            // filter out constraints that are not in view\n            for (i = 0; i < allConstraints.length; i++) {\n                var constraint = allConstraints[i],\n                    bodyA = constraint.bodyA,\n                    bodyB = constraint.bodyB,\n                    pointAWorld = constraint.pointA,\n                    pointBWorld = constraint.pointB;\n\n                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n\n                if (!pointAWorld || !pointBWorld)\n                    continue;\n\n                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))\n                    constraints.push(constraint);\n            }\n\n            // transform the view\n            Render.startViewTransform(render);\n\n            // update mouse\n            if (render.mouse) {\n                Mouse.setScale(render.mouse, {\n                    x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,\n                    y: (render.bounds.max.y - render.bounds.min.y) / render.options.height\n                });\n\n                Mouse.setOffset(render.mouse, render.bounds.min);\n            }\n        } else {\n            constraints = allConstraints;\n            bodies = allBodies;\n\n            if (render.options.pixelRatio !== 1) {\n                render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n            }\n        }\n\n        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {\n            // fully featured rendering of bodies\n            Render.bodies(render, bodies, context);\n        } else {\n            if (options.showConvexHulls)\n                Render.bodyConvexHulls(render, bodies, context);\n\n            // optimised method for wireframes only\n            Render.bodyWireframes(render, bodies, context);\n        }\n\n        if (options.showBounds)\n            Render.bodyBounds(render, bodies, context);\n\n        if (options.showAxes || options.showAngleIndicator)\n            Render.bodyAxes(render, bodies, context);\n\n        if (options.showPositions)\n            Render.bodyPositions(render, bodies, context);\n\n        if (options.showVelocity)\n            Render.bodyVelocity(render, bodies, context);\n\n        if (options.showIds)\n            Render.bodyIds(render, bodies, context);\n\n        if (options.showSeparations)\n            Render.separations(render, engine.pairs.list, context);\n\n        if (options.showCollisions)\n            Render.collisions(render, engine.pairs.list, context);\n\n        if (options.showVertexNumbers)\n            Render.vertexNumbers(render, bodies, context);\n\n        if (options.showMousePosition)\n            Render.mousePosition(render, render.mouse, context);\n\n        Render.constraints(constraints, context);\n\n        if (options.showBroadphase)\n            Render.grid(render, engine.grid, context);\n\n        if (options.hasBounds) {\n            // revert view transforms\n            Render.endViewTransform(render);\n        }\n\n        Events.trigger(render, 'afterRender', event);\n\n        // log the time elapsed computing this update\n        timing.lastElapsed = Common.now() - startTime;\n    };\n\n    /**\n     * Renders statistics about the engine and world useful for debugging.\n     * @private\n     * @method stats\n     * @param {render} render\n     * @param {RenderingContext} context\n     * @param {Number} time\n     */\n    Render.stats = function(render, context, time) {\n        var engine = render.engine,\n            world = engine.world,\n            bodies = Composite.allBodies(world),\n            parts = 0,\n            width = 55,\n            height = 44,\n            x = 0,\n            y = 0;\n        \n        // count parts\n        for (var i = 0; i < bodies.length; i += 1) {\n            parts += bodies[i].parts.length;\n        }\n\n        // sections\n        var sections = {\n            'Part': parts,\n            'Body': bodies.length,\n            'Cons': Composite.allConstraints(world).length,\n            'Comp': Composite.allComposites(world).length,\n            'Pair': engine.pairs.list.length\n        };\n\n        // background\n        context.fillStyle = '#0e0f19';\n        context.fillRect(x, y, width * 5.5, height);\n\n        context.font = '12px Arial';\n        context.textBaseline = 'top';\n        context.textAlign = 'right';\n\n        // sections\n        for (var key in sections) {\n            var section = sections[key];\n            // label\n            context.fillStyle = '#aaa';\n            context.fillText(key, x + width, y + 8);\n\n            // value\n            context.fillStyle = '#eee';\n            context.fillText(section, x + width, y + 26);\n\n            x += width;\n        }\n    };\n\n    /**\n     * Renders engine and render performance information.\n     * @private\n     * @method performance\n     * @param {render} render\n     * @param {RenderingContext} context\n     */\n    Render.performance = function(render, context) {\n        var engine = render.engine,\n            timing = render.timing,\n            deltaHistory = timing.deltaHistory,\n            elapsedHistory = timing.elapsedHistory,\n            timestampElapsedHistory = timing.timestampElapsedHistory,\n            engineDeltaHistory = timing.engineDeltaHistory,\n            engineElapsedHistory = timing.engineElapsedHistory,\n            lastEngineDelta = engine.timing.lastDelta;\n        \n        var deltaMean = _mean(deltaHistory),\n            elapsedMean = _mean(elapsedHistory),\n            engineDeltaMean = _mean(engineDeltaHistory),\n            engineElapsedMean = _mean(engineElapsedHistory),\n            timestampElapsedMean = _mean(timestampElapsedHistory),\n            rateMean = (timestampElapsedMean / deltaMean) || 0,\n            fps = (1000 / deltaMean) || 0;\n\n        var graphHeight = 4,\n            gap = 12,\n            width = 60,\n            height = 34,\n            x = 10,\n            y = 69;\n\n        // background\n        context.fillStyle = '#0e0f19';\n        context.fillRect(0, 50, gap * 4 + width * 5 + 22, height);\n\n        // show FPS\n        Render.status(\n            context, x, y, width, graphHeight, deltaHistory.length, \n            Math.round(fps) + ' fps', \n            fps / Render._goodFps,\n            function(i) { return (deltaHistory[i] / deltaMean) - 1; }\n        );\n\n        // show engine delta\n        Render.status(\n            context, x + gap + width, y, width, graphHeight, engineDeltaHistory.length,\n            lastEngineDelta.toFixed(2) + ' dt', \n            Render._goodDelta / lastEngineDelta,\n            function(i) { return (engineDeltaHistory[i] / engineDeltaMean) - 1; }\n        );\n\n        // show engine update time\n        Render.status(\n            context, x + (gap + width) * 2, y, width, graphHeight, engineElapsedHistory.length,\n            engineElapsedMean.toFixed(2) + ' ut', \n            1 - (engineElapsedMean / Render._goodFps),\n            function(i) { return (engineElapsedHistory[i] / engineElapsedMean) - 1; }\n        );\n\n        // show render time\n        Render.status(\n            context, x + (gap + width) * 3, y, width, graphHeight, elapsedHistory.length,\n            elapsedMean.toFixed(2) + ' rt', \n            1 - (elapsedMean / Render._goodFps),\n            function(i) { return (elapsedHistory[i] / elapsedMean) - 1; }\n        );\n\n        // show effective speed\n        Render.status(\n            context, x + (gap + width) * 4, y, width, graphHeight, timestampElapsedHistory.length, \n            rateMean.toFixed(2) + ' x', \n            rateMean * rateMean * rateMean,\n            function(i) { return (((timestampElapsedHistory[i] / deltaHistory[i]) / rateMean) || 0) - 1; }\n        );\n    };\n\n    /**\n     * Renders a label, indicator and a chart.\n     * @private\n     * @method status\n     * @param {RenderingContext} context\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} count\n     * @param {string} label\n     * @param {string} indicator\n     * @param {function} plotY\n     */\n    Render.status = function(context, x, y, width, height, count, label, indicator, plotY) {\n        // background\n        context.strokeStyle = '#888';\n        context.fillStyle = '#444';\n        context.lineWidth = 1;\n        context.fillRect(x, y + 7, width, 1);\n\n        // chart\n        context.beginPath();\n        context.moveTo(x, y + 7 - height * Common.clamp(0.4 * plotY(0), -2, 2));\n        for (var i = 0; i < width; i += 1) {\n            context.lineTo(x + i, y + 7 - (i < count ? height * Common.clamp(0.4 * plotY(i), -2, 2) : 0));\n        }\n        context.stroke();\n\n        // indicator\n        context.fillStyle = 'hsl(' + Common.clamp(25 + 95 * indicator, 0, 120) + ',100%,60%)';\n        context.fillRect(x, y - 7, 4, 4);\n\n        // label\n        context.font = '12px Arial';\n        context.textBaseline = 'middle';\n        context.textAlign = 'right';\n        context.fillStyle = '#eee';\n        context.fillText(label, x + width, y - 5);\n    };\n\n    /**\n     * Description\n     * @private\n     * @method constraints\n     * @param {constraint[]} constraints\n     * @param {RenderingContext} context\n     */\n    Render.constraints = function(constraints, context) {\n        var c = context;\n\n        for (var i = 0; i < constraints.length; i++) {\n            var constraint = constraints[i];\n\n            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)\n                continue;\n\n            var bodyA = constraint.bodyA,\n                bodyB = constraint.bodyB,\n                start,\n                end;\n\n            if (bodyA) {\n                start = Vector.add(bodyA.position, constraint.pointA);\n            } else {\n                start = constraint.pointA;\n            }\n\n            if (constraint.render.type === 'pin') {\n                c.beginPath();\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                c.closePath();\n            } else {\n                if (bodyB) {\n                    end = Vector.add(bodyB.position, constraint.pointB);\n                } else {\n                    end = constraint.pointB;\n                }\n\n                c.beginPath();\n                c.moveTo(start.x, start.y);\n\n                if (constraint.render.type === 'spring') {\n                    var delta = Vector.sub(end, start),\n                        normal = Vector.perp(Vector.normalise(delta)),\n                        coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)),\n                        offset;\n\n                    for (var j = 1; j < coils; j += 1) {\n                        offset = j % 2 === 0 ? 1 : -1;\n\n                        c.lineTo(\n                            start.x + delta.x * (j / coils) + normal.x * offset * 4,\n                            start.y + delta.y * (j / coils) + normal.y * offset * 4\n                        );\n                    }\n                }\n\n                c.lineTo(end.x, end.y);\n            }\n\n            if (constraint.render.lineWidth) {\n                c.lineWidth = constraint.render.lineWidth;\n                c.strokeStyle = constraint.render.strokeStyle;\n                c.stroke();\n            }\n\n            if (constraint.render.anchors) {\n                c.fillStyle = constraint.render.strokeStyle;\n                c.beginPath();\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                c.arc(end.x, end.y, 3, 0, 2 * Math.PI);\n                c.closePath();\n                c.fill();\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method bodies\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodies = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            showInternalEdges = options.showInternalEdges || !options.wireframes,\n            body,\n            part,\n            i,\n            k;\n\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n\n                if (!part.render.visible)\n                    continue;\n\n                if (options.showSleeping && body.isSleeping) {\n                    c.globalAlpha = 0.5 * part.render.opacity;\n                } else if (part.render.opacity !== 1) {\n                    c.globalAlpha = part.render.opacity;\n                }\n\n                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {\n                    // part sprite\n                    var sprite = part.render.sprite,\n                        texture = _getTexture(render, sprite.texture);\n\n                    c.translate(part.position.x, part.position.y);\n                    c.rotate(part.angle);\n\n                    c.drawImage(\n                        texture,\n                        texture.width * -sprite.xOffset * sprite.xScale,\n                        texture.height * -sprite.yOffset * sprite.yScale,\n                        texture.width * sprite.xScale,\n                        texture.height * sprite.yScale\n                    );\n\n                    // revert translation, hopefully faster than save / restore\n                    c.rotate(-part.angle);\n                    c.translate(-part.position.x, -part.position.y);\n                } else {\n                    // part polygon\n                    if (part.circleRadius) {\n                        c.beginPath();\n                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\n                    } else {\n                        c.beginPath();\n                        c.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n                        for (var j = 1; j < part.vertices.length; j++) {\n                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                                c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                            } else {\n                                c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                            }\n\n                            if (part.vertices[j].isInternal && !showInternalEdges) {\n                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                            }\n                        }\n\n                        c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                        c.closePath();\n                    }\n\n                    if (!options.wireframes) {\n                        c.fillStyle = part.render.fillStyle;\n\n                        if (part.render.lineWidth) {\n                            c.lineWidth = part.render.lineWidth;\n                            c.strokeStyle = part.render.strokeStyle;\n                            c.stroke();\n                        }\n\n                        c.fill();\n                    } else {\n                        c.lineWidth = 1;\n                        c.strokeStyle = '#bbb';\n                        c.stroke();\n                    }\n                }\n\n                c.globalAlpha = 1;\n            }\n        }\n    };\n\n    /**\n     * Optimised method for drawing body wireframes in one pass\n     * @private\n     * @method bodyWireframes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyWireframes = function(render, bodies, context) {\n        var c = context,\n            showInternalEdges = render.options.showInternalEdges,\n            body,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        // render all bodies\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n\n                c.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n                for (j = 1; j < part.vertices.length; j++) {\n                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                        c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                    } else {\n                        c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                    }\n\n                    if (part.vertices[j].isInternal && !showInternalEdges) {\n                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                    }\n                }\n\n                c.lineTo(part.vertices[0].x, part.vertices[0].y);\n            }\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = '#bbb';\n        c.stroke();\n    };\n\n    /**\n     * Optimised method for drawing body convex hull wireframes in one pass\n     * @private\n     * @method bodyConvexHulls\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyConvexHulls = function(render, bodies, context) {\n        var c = context,\n            body,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        // render convex hulls\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible || body.parts.length === 1)\n                continue;\n\n            c.moveTo(body.vertices[0].x, body.vertices[0].y);\n\n            for (j = 1; j < body.vertices.length; j++) {\n                c.lineTo(body.vertices[j].x, body.vertices[j].y);\n            }\n\n            c.lineTo(body.vertices[0].x, body.vertices[0].y);\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = 'rgba(255,255,255,0.2)';\n        c.stroke();\n    };\n\n    /**\n     * Renders body vertex numbers.\n     * @private\n     * @method vertexNumbers\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.vertexNumbers = function(render, bodies, context) {\n        var c = context,\n            i,\n            j,\n            k;\n\n        for (i = 0; i < bodies.length; i++) {\n            var parts = bodies[i].parts;\n            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {\n                var part = parts[k];\n                for (j = 0; j < part.vertices.length; j++) {\n                    c.fillStyle = 'rgba(255,255,255,0.2)';\n                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);\n                }\n            }\n        }\n    };\n\n    /**\n     * Renders mouse position.\n     * @private\n     * @method mousePosition\n     * @param {render} render\n     * @param {mouse} mouse\n     * @param {RenderingContext} context\n     */\n    Render.mousePosition = function(render, mouse, context) {\n        var c = context;\n        c.fillStyle = 'rgba(255,255,255,0.8)';\n        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);\n    };\n\n    /**\n     * Draws body bounds\n     * @private\n     * @method bodyBounds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyBounds = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.render.visible) {\n                var parts = bodies[i].parts;\n                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    var part = parts[j];\n                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);\n                }\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,255,255,0.08)';\n        } else {\n            c.strokeStyle = 'rgba(0,0,0,0.1)';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Draws body angle indicators and axes\n     * @private\n     * @method bodyAxes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyAxes = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                parts = body.parts;\n\n            if (!body.render.visible)\n                continue;\n\n            if (options.showAxes) {\n                // render all axes\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    part = parts[j];\n                    for (k = 0; k < part.axes.length; k++) {\n                        var axis = part.axes[k];\n                        c.moveTo(part.position.x, part.position.y);\n                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);\n                    }\n                }\n            } else {\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    part = parts[j];\n                    for (k = 0; k < part.axes.length; k++) {\n                        // render a single axis indicator\n                        c.moveTo(part.position.x, part.position.y);\n                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2,\n                            (part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2);\n                    }\n                }\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'indianred';\n            c.lineWidth = 1;\n        } else {\n            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n            c.globalCompositeOperation = 'overlay';\n            c.lineWidth = 2;\n        }\n\n        c.stroke();\n        c.globalCompositeOperation = 'source-over';\n    };\n\n    /**\n     * Draws body positions\n     * @private\n     * @method bodyPositions\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyPositions = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            body,\n            part,\n            i,\n            k;\n\n        c.beginPath();\n\n        // render current positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'indianred';\n        } else {\n            c.fillStyle = 'rgba(0,0,0,0.5)';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render previous positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (body.render.visible) {\n                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        c.fillStyle = 'rgba(255,165,0,0.8)';\n        c.fill();\n    };\n\n    /**\n     * Draws body velocity\n     * @private\n     * @method bodyVelocity\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyVelocity = function(render, bodies, context) {\n        var c = context;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            c.moveTo(body.position.x, body.position.y);\n            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);\n        }\n\n        c.lineWidth = 3;\n        c.strokeStyle = 'cornflowerblue';\n        c.stroke();\n    };\n\n    /**\n     * Draws body ids\n     * @private\n     * @method bodyIds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyIds = function(render, bodies, context) {\n        var c = context,\n            i,\n            j;\n\n        for (i = 0; i < bodies.length; i++) {\n            if (!bodies[i].render.visible)\n                continue;\n\n            var parts = bodies[i].parts;\n            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                var part = parts[j];\n                c.font = \"12px Arial\";\n                c.fillStyle = 'rgba(255,255,255,0.5)';\n                c.fillText(part.id, part.position.x + 10, part.position.y - 10);\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method collisions\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.collisions = function(render, pairs, context) {\n        var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render collision positions\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            for (j = 0; j < pair.activeContacts.length; j++) {\n                var contact = pair.activeContacts[j],\n                    vertex = contact.vertex;\n                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'rgba(255,255,255,0.7)';\n        } else {\n            c.fillStyle = 'orange';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render collision normals\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n\n            if (pair.activeContacts.length > 0) {\n                var normalPosX = pair.activeContacts[0].vertex.x,\n                    normalPosY = pair.activeContacts[0].vertex.y;\n\n                if (pair.activeContacts.length === 2) {\n                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;\n                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;\n                }\n\n                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {\n                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\n                } else {\n                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);\n                }\n\n                c.lineTo(normalPosX, normalPosY);\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.7)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method separations\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.separations = function(render, pairs, context) {\n        var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render separations\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.bodyA;\n            bodyB = collision.bodyB;\n\n            var k = 1;\n\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyB.isStatic) k = 0;\n\n            c.moveTo(bodyB.position.x, bodyB.position.y);\n            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);\n\n            k = 1;\n\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyA.isStatic) k = 0;\n\n            c.moveTo(bodyA.position.x, bodyA.position.y);\n            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.5)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method grid\n     * @param {render} render\n     * @param {grid} grid\n     * @param {RenderingContext} context\n     */\n    Render.grid = function(render, grid, context) {\n        var c = context,\n            options = render.options;\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,180,0,0.1)';\n        } else {\n            c.strokeStyle = 'rgba(255,180,0,0.5)';\n        }\n\n        c.beginPath();\n\n        var bucketKeys = Common.keys(grid.buckets);\n\n        for (var i = 0; i < bucketKeys.length; i++) {\n            var bucketId = bucketKeys[i];\n\n            if (grid.buckets[bucketId].length < 2)\n                continue;\n\n            var region = bucketId.split(/C|R/);\n            c.rect(0.5 + parseInt(region[1], 10) * grid.bucketWidth,\n                0.5 + parseInt(region[2], 10) * grid.bucketHeight,\n                grid.bucketWidth,\n                grid.bucketHeight);\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method inspector\n     * @param {inspector} inspector\n     * @param {RenderingContext} context\n     */\n    Render.inspector = function(inspector, context) {\n        var engine = inspector.engine,\n            selected = inspector.selected,\n            render = inspector.render,\n            options = render.options,\n            bounds;\n\n        if (options.hasBounds) {\n            var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n                boundsHeight = render.bounds.max.y - render.bounds.min.y,\n                boundsScaleX = boundsWidth / render.options.width,\n                boundsScaleY = boundsHeight / render.options.height;\n\n            context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n            context.translate(-render.bounds.min.x, -render.bounds.min.y);\n        }\n\n        for (var i = 0; i < selected.length; i++) {\n            var item = selected[i].data;\n\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.9)';\n            context.setLineDash([1,2]);\n\n            switch (item.type) {\n\n            case 'body':\n\n                // render body selections\n                bounds = item.bounds;\n                context.beginPath();\n                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3),\n                    Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            case 'constraint':\n\n                // render constraint selections\n                var point = item.pointA;\n                if (item.bodyA)\n                    point = item.pointB;\n                context.beginPath();\n                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            }\n\n            context.setLineDash([]);\n            context.translate(-0.5, -0.5);\n        }\n\n        // render selection region\n        if (inspector.selectStart !== null) {\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.6)';\n            context.fillStyle = 'rgba(255,165,0,0.1)';\n            bounds = inspector.selectBounds;\n            context.beginPath();\n            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y),\n                Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));\n            context.closePath();\n            context.stroke();\n            context.fill();\n            context.translate(-0.5, -0.5);\n        }\n\n        if (options.hasBounds)\n            context.setTransform(1, 0, 0, 1, 0, 0);\n    };\n\n    /**\n     * Updates render timing.\n     * @method _updateTiming\n     * @private\n     * @param {render} render\n     * @param {number} time\n     */\n    var _updateTiming = function(render, time) {\n        var engine = render.engine,\n            timing = render.timing,\n            historySize = timing.historySize,\n            timestamp = engine.timing.timestamp;\n\n        timing.delta = time - timing.lastTime || Render._goodDelta;\n        timing.lastTime = time;\n\n        timing.timestampElapsed = timestamp - timing.lastTimestamp || 0;\n        timing.lastTimestamp = timestamp;\n\n        timing.deltaHistory.unshift(timing.delta);\n        timing.deltaHistory.length = Math.min(timing.deltaHistory.length, historySize);\n\n        timing.engineDeltaHistory.unshift(engine.timing.lastDelta);\n        timing.engineDeltaHistory.length = Math.min(timing.engineDeltaHistory.length, historySize);\n\n        timing.timestampElapsedHistory.unshift(timing.timestampElapsed);\n        timing.timestampElapsedHistory.length = Math.min(timing.timestampElapsedHistory.length, historySize);\n\n        timing.engineElapsedHistory.unshift(engine.timing.lastElapsed);\n        timing.engineElapsedHistory.length = Math.min(timing.engineElapsedHistory.length, historySize);\n\n        timing.elapsedHistory.unshift(timing.lastElapsed);\n        timing.elapsedHistory.length = Math.min(timing.elapsedHistory.length, historySize);\n    };\n\n    /**\n     * Returns the mean value of the given numbers.\n     * @method _mean\n     * @private\n     * @param {Number[]} values\n     * @return {Number} the mean of given values\n     */\n    var _mean = function(values) {\n        var result = 0;\n        for (var i = 0; i < values.length; i += 1) {\n            result += values[i];\n        }\n        return (result / values.length) || 0;\n    };\n\n    /**\n     * @method _createCanvas\n     * @private\n     * @param {} width\n     * @param {} height\n     * @return canvas\n     */\n    var _createCanvas = function(width, height) {\n        var canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        canvas.oncontextmenu = function() { return false; };\n        canvas.onselectstart = function() { return false; };\n        return canvas;\n    };\n\n    /**\n     * Gets the pixel ratio of the canvas.\n     * @method _getPixelRatio\n     * @private\n     * @param {HTMLElement} canvas\n     * @return {Number} pixel ratio\n     */\n    var _getPixelRatio = function(canvas) {\n        var context = canvas.getContext('2d'),\n            devicePixelRatio = window.devicePixelRatio || 1,\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio\n                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio\n                                      || context.backingStorePixelRatio || 1;\n\n        return devicePixelRatio / backingStorePixelRatio;\n    };\n\n    /**\n     * Gets the requested texture (an Image) via its path\n     * @method _getTexture\n     * @private\n     * @param {render} render\n     * @param {string} imagePath\n     * @return {Image} texture\n     */\n    var _getTexture = function(render, imagePath) {\n        var image = render.textures[imagePath];\n\n        if (image)\n            return image;\n\n        image = render.textures[imagePath] = new Image();\n        image.src = imagePath;\n\n        return image;\n    };\n\n    /**\n     * Applies the background to the canvas using CSS.\n     * @method applyBackground\n     * @private\n     * @param {render} render\n     * @param {string} background\n     */\n    var _applyBackground = function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired before rendering\n    *\n    * @event beforeRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after rendering\n    *\n    * @event afterRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A back-reference to the `Matter.Render` module.\n     *\n     * @property controller\n     * @type render\n     */\n\n    /**\n     * A reference to the `Matter.Engine` instance to be used.\n     *\n     * @property engine\n     * @type engine\n     */\n\n    /**\n     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)\n     *\n     * @property element\n     * @type HTMLElement\n     * @default null\n     */\n\n    /**\n     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     * @default null\n     */\n\n    /**\n     * A `Bounds` object that specifies the drawing view region.\n     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).\n     * This allows for creating views that can pan or zoom around the scene.\n     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.\n     *\n     * @property bounds\n     * @type bounds\n     */\n\n    /**\n     * The 2d rendering context from the `render.canvas` element.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n\n    /**\n     * The sprite texture cache.\n     *\n     * @property textures\n     * @type {}\n     */\n\n    /**\n     * The mouse to render if `render.options.showMousePosition` is enabled.\n     *\n     * @property mouse\n     * @type mouse\n     * @default null\n     */\n\n    /**\n     * The configuration options of the renderer.\n     *\n     * @property options\n     * @type {}\n     */\n\n    /**\n     * The target width in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.width\n     * @type number\n     * @default 800\n     */\n\n    /**\n     * The target height in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.height\n     * @type number\n     * @default 600\n     */\n\n    /**\n     * The [pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio) to use when rendering.\n     *\n     * @property options.pixelRatio\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A CSS background color string to use when `render.options.wireframes` is disabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.background\n     * @type string\n     * @default '#14151f'\n     */\n\n    /**\n     * A CSS background color string to use when `render.options.wireframes` is enabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.wireframeBackground\n     * @type string\n     * @default '#14151f'\n     */\n\n    /**\n     * A flag that specifies if `render.bounds` should be used when rendering.\n     *\n     * @property options.hasBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable all debug information overlays together.  \n     * This includes and has priority over the values of:\n     *\n     * - `render.options.showStats`\n     * - `render.options.showPerformance`\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the engine stats info overlay.  \n     * From left to right, the values shown are:\n     *\n     * - body parts total\n     * - body total\n     * - constraints total\n     * - composites total\n     * - collision pairs total\n     *\n     * @property options.showStats\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable performance charts.  \n     * From left to right, the values shown are:\n     *\n     * - average render frequency (e.g. 60 fps)\n     * - exact engine delta time used for last update (e.g. 16.66ms)\n     * - average engine execution duration (e.g. 5.00ms)\n     * - average render execution duration (e.g. 0.40ms)\n     * - average effective play speed (e.g. '1.00x' is 'real-time')\n     *\n     * Each value is recorded over a fixed sample of past frames (60 frames).\n     *\n     * A chart shown below each value indicates the variance from the average over the sample.\n     * The more stable or fixed the value is the flatter the chart will appear.\n     *\n     * @property options.showPerformance\n     * @type boolean\n     * @default false\n     */\n    \n    /**\n     * A flag to enable or disable rendering entirely.\n     *\n     * @property options.enabled\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to toggle wireframe rendering otherwise solid fill rendering is used.\n     *\n     * @property options.wireframes\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A flag to enable or disable sleeping bodies indicators.\n     *\n     * @property options.showSleeping\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A flag to enable or disable the debug information overlay.\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the collision broadphase debug overlay.\n     *\n     * @property options.showBroadphase\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body bounds debug overlay.\n     *\n     * @property options.showBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body velocity debug overlay.\n     *\n     * @property options.showVelocity\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body collisions debug overlay.\n     *\n     * @property options.showCollisions\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the collision resolver separations debug overlay.\n     *\n     * @property options.showSeparations\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body axes debug overlay.\n     *\n     * @property options.showAxes\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body positions debug overlay.\n     *\n     * @property options.showPositions\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body angle debug overlay.\n     *\n     * @property options.showAngleIndicator\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body and part ids debug overlay.\n     *\n     * @property options.showIds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body vertex numbers debug overlay.\n     *\n     * @property options.showVertexNumbers\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body convex hulls debug overlay.\n     *\n     * @property options.showConvexHulls\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body internal edges debug overlay.\n     *\n     * @property options.showInternalEdges\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the mouse position debug overlay.\n     *\n     * @property options.showMousePosition\n     * @type boolean\n     * @default false\n     */\n\n})();\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.\n*\n* @class Contact\n*/\n\nvar Contact = {};\n\nmodule.exports = Contact;\n\n(function() {\n\n    /**\n     * Creates a new contact.\n     * @method create\n     * @param {vertex} vertex\n     * @return {contact} A new contact\n     */\n    Contact.create = function(vertex) {\n        return {\n            id: Contact.id(vertex),\n            vertex: vertex,\n            normalImpulse: 0,\n            tangentImpulse: 0\n        };\n    };\n    \n    /**\n     * Generates a contact id.\n     * @method id\n     * @param {vertex} vertex\n     * @return {string} Unique contactID\n     */\n    Contact.id = function(vertex) {\n        return vertex.body.id + '_' + vertex.index;\n    };\n\n})();\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\n* An engine is a controller that manages updating the simulation of the world.\n* See `Matter.Runner` for an optional game loop utility.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Engine\n*/\n\nvar Engine = {};\n\nmodule.exports = Engine;\n\nvar Sleeping = __webpack_require__(7);\nvar Resolver = __webpack_require__(19);\nvar Detector = __webpack_require__(13);\nvar Pairs = __webpack_require__(20);\nvar Grid = __webpack_require__(21);\nvar Events = __webpack_require__(4);\nvar Composite = __webpack_require__(5);\nvar Constraint = __webpack_require__(8);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(6);\n\n(function() {\n\n    /**\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {engine} engine\n     */\n    Engine.create = function(options) {\n        options = options || {};\n\n        var defaults = {\n            positionIterations: 6,\n            velocityIterations: 4,\n            constraintIterations: 2,\n            enableSleeping: false,\n            events: [],\n            plugin: {},\n            grid: null,\n            gravity: {\n                x: 0,\n                y: 1,\n                scale: 0.001\n            },\n            timing: {\n                timestamp: 0,\n                timeScale: 1,\n                lastDelta: 0,\n                lastElapsed: 0\n            }\n        };\n\n        var engine = Common.extend(defaults, options);\n\n        engine.world = options.world || Composite.create({ label: 'World' });\n        engine.grid = Grid.create(options.grid || options.broadphase);\n        engine.pairs = Pairs.create();\n\n        // temporary back compatibility\n        engine.world.gravity = engine.gravity;\n        engine.broadphase = engine.grid;\n        engine.metrics = {};\n        \n        return engine;\n    };\n\n    /**\n     * Moves the simulation forward in time by `delta` ms.\n     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.\n     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.\n     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.\n     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).\n     * See the paper on <a href=\"http://lonesock.net/article/verlet.html\">Time Corrected Verlet</a> for more information.\n     *\n     * Triggers `beforeUpdate` and `afterUpdate` events.\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\n     * @method update\n     * @param {engine} engine\n     * @param {number} [delta=16.666]\n     * @param {number} [correction=1]\n     */\n    Engine.update = function(engine, delta, correction) {\n        var startTime = Common.now();\n\n        delta = delta || 1000 / 60;\n        correction = correction || 1;\n\n        var world = engine.world,\n            timing = engine.timing,\n            grid = engine.grid,\n            gridPairs = [],\n            i;\n\n        // increment timestamp\n        timing.timestamp += delta * timing.timeScale;\n        timing.lastDelta = delta * timing.timeScale;\n\n        // create an event object\n        var event = {\n            timestamp: timing.timestamp\n        };\n\n        Events.trigger(engine, 'beforeUpdate', event);\n\n        // get lists of all bodies and constraints, no matter what composites they are in\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world);\n\n        // if sleeping enabled, call the sleeping controller\n        if (engine.enableSleeping)\n            Sleeping.update(allBodies, timing.timeScale);\n\n        // applies gravity to all bodies\n        Engine._bodiesApplyGravity(allBodies, engine.gravity);\n\n        // update all body position and rotation by integration\n        Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);\n\n        // update all constraints (first pass)\n        Constraint.preSolveAll(allBodies);\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, timing.timeScale);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // broadphase pass: find potential collision pairs\n\n        // if world is dirty, we must flush the whole grid\n        if (world.isModified)\n            Grid.clear(grid);\n\n        // update the grid buckets based on current bodies\n        Grid.update(grid, allBodies, engine, world.isModified);\n        gridPairs = grid.pairsList;\n\n        // clear all composite modified flags\n        if (world.isModified) {\n            Composite.setModified(world, false, false, true);\n        }\n\n        // narrowphase pass: find actual collisions, then create or update collision pairs\n        var collisions = Detector.collisions(gridPairs, engine);\n\n        // update collision pairs\n        var pairs = engine.pairs,\n            timestamp = timing.timestamp;\n        Pairs.update(pairs, collisions, timestamp);\n        Pairs.removeOld(pairs, timestamp);\n\n        // wake up bodies involved in collisions\n        if (engine.enableSleeping)\n            Sleeping.afterCollisions(pairs.list, timing.timeScale);\n\n        // trigger collision events\n        if (pairs.collisionStart.length > 0)\n            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });\n\n        // iteratively resolve position between collisions\n        Resolver.preSolvePosition(pairs.list);\n        for (i = 0; i < engine.positionIterations; i++) {\n            Resolver.solvePosition(pairs.list, timing.timeScale);\n        }\n        Resolver.postSolvePosition(allBodies);\n\n        // update all constraints (second pass)\n        Constraint.preSolveAll(allBodies);\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, timing.timeScale);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // iteratively resolve velocity between collisions\n        Resolver.preSolveVelocity(pairs.list);\n        for (i = 0; i < engine.velocityIterations; i++) {\n            Resolver.solveVelocity(pairs.list, timing.timeScale);\n        }\n\n        // trigger collision events\n        if (pairs.collisionActive.length > 0)\n            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });\n\n        if (pairs.collisionEnd.length > 0)\n            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });\n\n        // clear force buffers\n        Engine._bodiesClearForces(allBodies);\n\n        Events.trigger(engine, 'afterUpdate', event);\n\n        // log the time elapsed computing this update\n        engine.timing.lastElapsed = Common.now() - startTime;\n\n        return engine;\n    };\n    \n    /**\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\n     * @method merge\n     * @param {engine} engineA\n     * @param {engine} engineB\n     */\n    Engine.merge = function(engineA, engineB) {\n        Common.extend(engineA, engineB);\n        \n        if (engineB.world) {\n            engineA.world = engineB.world;\n\n            Engine.clear(engineA);\n\n            var bodies = Composite.allBodies(engineA.world);\n\n            for (var i = 0; i < bodies.length; i++) {\n                var body = bodies[i];\n                Sleeping.set(body, false);\n                body.id = Common.nextId();\n            }\n        }\n    };\n\n    /**\n     * Clears the engine including the world, pairs and broadphase.\n     * @method clear\n     * @param {engine} engine\n     */\n    Engine.clear = function(engine) {\n        var world = engine.world,\n            bodies = Composite.allBodies(world);\n\n        Pairs.clear(engine.pairs);\n        Grid.clear(engine.grid);\n        Grid.update(engine.grid, bodies, engine, true);\n    };\n\n    /**\n     * Zeroes the `body.force` and `body.torque` force buffers.\n     * @method _bodiesClearForces\n     * @private\n     * @param {body[]} bodies\n     */\n    Engine._bodiesClearForces = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            // reset force buffers\n            body.force.x = 0;\n            body.force.y = 0;\n            body.torque = 0;\n        }\n    };\n\n    /**\n     * Applys a mass dependant force to all given bodies.\n     * @method _bodiesApplyGravity\n     * @private\n     * @param {body[]} bodies\n     * @param {vector} gravity\n     */\n    Engine._bodiesApplyGravity = function(bodies, gravity) {\n        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;\n\n        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {\n            return;\n        }\n        \n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            // apply gravity\n            body.force.y += body.mass * gravity.y * gravityScale;\n            body.force.x += body.mass * gravity.x * gravityScale;\n        }\n    };\n\n    /**\n     * Applys `Body.update` to all given `bodies`.\n     * @method _bodiesUpdate\n     * @private\n     * @param {body[]} bodies\n     * @param {number} deltaTime \n     * The amount of time elapsed between updates\n     * @param {number} timeScale\n     * @param {number} correction \n     * The Verlet correction factor (deltaTime / lastDeltaTime)\n     * @param {bounds} worldBounds\n     */\n    Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            Body.update(body, deltaTime, timeScale, correction);\n        }\n    };\n\n    /**\n     * A deprecated alias for `Runner.run`, use `Matter.Runner.run(engine)` instead and see `Matter.Runner` for more information.\n     * @deprecated use Matter.Runner.run(engine) instead\n     * @method run\n     * @param {engine} engine\n     */\n\n    /**\n    * Fired just before an update\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update and all collision events\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\n    *\n    * @event collisionStart\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\n    *\n    * @event collisionActive\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\n    *\n    * @event collisionEnd\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` that specifies the number of position iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property positionIterations\n     * @type number\n     * @default 6\n     */\n\n    /**\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property velocityIterations\n     * @type number\n     * @default 4\n     */\n\n    /**\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     * The default value of `2` is usually very adequate.\n     *\n     * @property constraintIterations\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\n     *\n     * @property enableSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * An `Object` containing properties regarding the timing systems of the engine. \n     *\n     * @property timing\n     * @type object\n     */\n\n    /**\n     * A `Number` that specifies the global scaling factor of time for all bodies.\n     * A value of `0` freezes the simulation.\n     * A value of `0.1` gives a slow-motion effect.\n     * A value of `1.2` gives a speed-up effect.\n     *\n     * @property timing.timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \n     * It is incremented on every `Engine.update` by the given `delta` argument. \n     *\n     * @property timing.timestamp\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that represents the total execution time elapsed during the last `Engine.update` in milliseconds.\n     * It is updated by timing from the start of the last `Engine.update` call until it ends.\n     *\n     * This value will also include the total execution time of all event handlers directly or indirectly triggered by the engine update.\n     *\n     * @property timing.lastElapsed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that represents the `delta` value used in the last engine update.\n     *\n     * @property timing.lastDelta\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Matter.Grid` instance.\n     *\n     * @property grid\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * Replaced by and now alias for `engine.grid`.\n     *\n     * @deprecated use `engine.grid`\n     * @property broadphase\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * The root `Matter.Composite` instance that will contain all bodies, constraints and other composites to be simulated by this engine.\n     *\n     * @property world\n     * @type composite\n     * @default a Matter.Composite instance\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * The gravity to apply on all bodies in `engine.world`.\n     *\n     * @property gravity\n     * @type object\n     */\n\n    /**\n     * The gravity x component.\n     *\n     * @property gravity.x\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * The gravity y component.\n     *\n     * @property gravity.y\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * The gravity scale factor.\n     *\n     * @property gravity.scale\n     * @type object\n     * @default 0.001\n     */\n\n})();\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\n*\n* @class Resolver\n*/\n\nvar Resolver = {};\n\nmodule.exports = Resolver;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\n\n(function() {\n\n    Resolver._restingThresh = 4;\n    Resolver._restingThreshTangent = 6;\n    Resolver._positionDampen = 0.9;\n    Resolver._positionWarming = 0.8;\n    Resolver._frictionNormalMultiplier = 5;\n\n    /**\n     * Prepare pairs for position solving.\n     * @method preSolvePosition\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolvePosition = function(pairs) {\n        var i,\n            pair,\n            activeCount;\n\n        // find total contacts on each body\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive)\n                continue;\n            \n            activeCount = pair.activeContacts.length;\n            pair.collision.parentA.totalContacts += activeCount;\n            pair.collision.parentB.totalContacts += activeCount;\n        }\n    };\n\n    /**\n     * Find a solution for pair positions.\n     * @method solvePosition\n     * @param {pair[]} pairs\n     * @param {number} timeScale\n     */\n    Resolver.solvePosition = function(pairs, timeScale) {\n        var i,\n            pair,\n            collision,\n            bodyA,\n            bodyB,\n            normal,\n            bodyBtoA,\n            contactShare,\n            positionImpulse,\n            contactCount = {},\n            tempA = Vector._temp[0],\n            tempB = Vector._temp[1],\n            tempC = Vector._temp[2],\n            tempD = Vector._temp[3];\n\n        // find impulses required to resolve penetration\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n\n            // get current separation between body edges involved in collision\n            bodyBtoA = Vector.sub(Vector.add(bodyB.positionImpulse, bodyB.position, tempA), \n                Vector.add(bodyA.positionImpulse, \n                    Vector.sub(bodyB.position, collision.penetration, tempB), tempC), tempD);\n\n            pair.separation = Vector.dot(normal, bodyBtoA);\n        }\n        \n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n            positionImpulse = (pair.separation - pair.slop) * timeScale;\n\n            if (bodyA.isStatic || bodyB.isStatic)\n                positionImpulse *= 2;\n            \n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                contactShare = Resolver._positionDampen / bodyA.totalContacts;\n                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;\n                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;\n            }\n\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                contactShare = Resolver._positionDampen / bodyB.totalContacts;\n                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;\n                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;\n            }\n        }\n    };\n\n    /**\n     * Apply position resolution.\n     * @method postSolvePosition\n     * @param {body[]} bodies\n     */\n    Resolver.postSolvePosition = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            // reset contact count\n            body.totalContacts = 0;\n\n            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {\n                // update body geometry\n                for (var j = 0; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n                    Vertices.translate(part.vertices, body.positionImpulse);\n                    Bounds.update(part.bounds, part.vertices, body.velocity);\n                    part.position.x += body.positionImpulse.x;\n                    part.position.y += body.positionImpulse.y;\n                }\n\n                // move the body without changing velocity\n                body.positionPrev.x += body.positionImpulse.x;\n                body.positionPrev.y += body.positionImpulse.y;\n\n                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {\n                    // reset cached impulse if the body has velocity along it\n                    body.positionImpulse.x = 0;\n                    body.positionImpulse.y = 0;\n                } else {\n                    // warm the next iteration\n                    body.positionImpulse.x *= Resolver._positionWarming;\n                    body.positionImpulse.y *= Resolver._positionWarming;\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepare pairs for velocity solving.\n     * @method preSolveVelocity\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolveVelocity = function(pairs) {\n        var i,\n            j,\n            pair,\n            contacts,\n            collision,\n            bodyA,\n            bodyB,\n            normal,\n            tangent,\n            contact,\n            contactVertex,\n            normalImpulse,\n            tangentImpulse,\n            offset,\n            impulse = Vector._temp[0],\n            tempA = Vector._temp[1];\n        \n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            contacts = pair.activeContacts;\n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n            tangent = collision.tangent;\n\n            // resolve each contact\n            for (j = 0; j < contacts.length; j++) {\n                contact = contacts[j];\n                contactVertex = contact.vertex;\n                normalImpulse = contact.normalImpulse;\n                tangentImpulse = contact.tangentImpulse;\n\n                if (normalImpulse !== 0 || tangentImpulse !== 0) {\n                    // total impulse from contact\n                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\n                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\n                    \n                    // apply impulse from contact\n                    if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                        offset = Vector.sub(contactVertex, bodyA.position, tempA);\n                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;\n                    }\n\n                    if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                        offset = Vector.sub(contactVertex, bodyB.position, tempA);\n                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Find a solution for pair velocities.\n     * @method solveVelocity\n     * @param {pair[]} pairs\n     * @param {number} timeScale\n     */\n    Resolver.solveVelocity = function(pairs, timeScale) {\n        var timeScaleSquared = timeScale * timeScale,\n            impulse = Vector._temp[0],\n            tempA = Vector._temp[1],\n            tempB = Vector._temp[2],\n            tempC = Vector._temp[3],\n            tempD = Vector._temp[4],\n            tempE = Vector._temp[5];\n        \n        for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            var collision = pair.collision,\n                bodyA = collision.parentA,\n                bodyB = collision.parentB,\n                normal = collision.normal,\n                tangent = collision.tangent,\n                contacts = pair.activeContacts,\n                contactShare = 1 / contacts.length;\n\n            // update body velocities\n            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\n            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\n            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\n            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\n\n            // resolve each contact\n            for (var j = 0; j < contacts.length; j++) {\n                var contact = contacts[j],\n                    contactVertex = contact.vertex,\n                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),\n                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),\n                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),\n                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), \n                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),\n                    normalVelocity = Vector.dot(normal, relativeVelocity);\n\n                var tangentVelocity = Vector.dot(tangent, relativeVelocity),\n                    tangentSpeed = Math.abs(tangentVelocity),\n                    tangentVelocityDirection = Common.sign(tangentVelocity);\n\n                // raw impulses\n                var normalImpulse = (1 + pair.restitution) * normalVelocity,\n                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;\n\n                // coulomb friction\n                var tangentImpulse = tangentVelocity,\n                    maxFriction = Infinity;\n\n                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {\n                    maxFriction = tangentSpeed;\n                    tangentImpulse = Common.clamp(\n                        pair.friction * tangentVelocityDirection * timeScaleSquared,\n                        -maxFriction, maxFriction\n                    );\n                }\n\n                // modify impulses accounting for mass, inertia and offset\n                var oAcN = Vector.cross(offsetA, normal),\n                    oBcN = Vector.cross(offsetB, normal),\n                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);\n\n                normalImpulse *= share;\n                tangentImpulse *= share;\n\n                // handle high velocity and resting collisions separately\n                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {\n                    // high normal velocity so clear cached contact normal impulse\n                    contact.normalImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n                    // impulse constraint tends to 0\n                    var contactNormalImpulse = contact.normalImpulse;\n                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);\n                    normalImpulse = contact.normalImpulse - contactNormalImpulse;\n                }\n\n                // handle high velocity and resting collisions separately\n                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {\n                    // high tangent velocity so clear cached contact tangent impulse\n                    contact.tangentImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n                    // tangent impulse tends to -tangentSpeed or +tangentSpeed\n                    var contactTangentImpulse = contact.tangentImpulse;\n                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);\n                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n                }\n\n                // total impulse from contact\n                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\n                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\n                \n                // apply impulse from contact\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;\n                }\n\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;\n                }\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\n*\n* @class Pairs\n*/\n\nvar Pairs = {};\n\nmodule.exports = Pairs;\n\nvar Pair = __webpack_require__(9);\nvar Common = __webpack_require__(0);\n\n(function() {\n    \n    Pairs._pairMaxIdleLife = 1000;\n\n    /**\n     * Creates a new pairs structure.\n     * @method create\n     * @param {object} options\n     * @return {pairs} A new pairs structure\n     */\n    Pairs.create = function(options) {\n        return Common.extend({ \n            table: {},\n            list: [],\n            collisionStart: [],\n            collisionActive: [],\n            collisionEnd: []\n        }, options);\n    };\n\n    /**\n     * Updates pairs given a list of collisions.\n     * @method update\n     * @param {object} pairs\n     * @param {collision[]} collisions\n     * @param {number} timestamp\n     */\n    Pairs.update = function(pairs, collisions, timestamp) {\n        var pairsList = pairs.list,\n            pairsTable = pairs.table,\n            collisionStart = pairs.collisionStart,\n            collisionEnd = pairs.collisionEnd,\n            collisionActive = pairs.collisionActive,\n            collision,\n            pairId,\n            pair,\n            i;\n\n        // clear collision state arrays, but maintain old reference\n        collisionStart.length = 0;\n        collisionEnd.length = 0;\n        collisionActive.length = 0;\n\n        for (i = 0; i < pairsList.length; i++) {\n            pairsList[i].confirmedActive = false;\n        }\n\n        for (i = 0; i < collisions.length; i++) {\n            collision = collisions[i];\n\n            if (collision.collided) {\n                pairId = Pair.id(collision.bodyA, collision.bodyB);\n\n                pair = pairsTable[pairId];\n                \n                if (pair) {\n                    // pair already exists (but may or may not be active)\n                    if (pair.isActive) {\n                        // pair exists and is active\n                        collisionActive.push(pair);\n                    } else {\n                        // pair exists but was inactive, so a collision has just started again\n                        collisionStart.push(pair);\n                    }\n\n                    // update the pair\n                    Pair.update(pair, collision, timestamp);\n                    pair.confirmedActive = true;\n                } else {\n                    // pair did not exist, create a new pair\n                    pair = Pair.create(collision, timestamp);\n                    pairsTable[pairId] = pair;\n\n                    // push the new pair\n                    collisionStart.push(pair);\n                    pairsList.push(pair);\n                }\n            }\n        }\n\n        // deactivate previously active pairs that are now inactive\n        for (i = 0; i < pairsList.length; i++) {\n            pair = pairsList[i];\n            if (pair.isActive && !pair.confirmedActive) {\n                Pair.setActive(pair, false, timestamp);\n                collisionEnd.push(pair);\n            }\n        }\n    };\n    \n    /**\n     * Finds and removes pairs that have been inactive for a set amount of time.\n     * @method removeOld\n     * @param {object} pairs\n     * @param {number} timestamp\n     */\n    Pairs.removeOld = function(pairs, timestamp) {\n        var pairsList = pairs.list,\n            pairsTable = pairs.table,\n            indexesToRemove = [],\n            pair,\n            collision,\n            pairIndex,\n            i;\n\n        for (i = 0; i < pairsList.length; i++) {\n            pair = pairsList[i];\n            collision = pair.collision;\n            \n            // never remove sleeping pairs\n            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {\n                pair.timeUpdated = timestamp;\n                continue;\n            }\n\n            // if pair is inactive for too long, mark it to be removed\n            if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {\n                indexesToRemove.push(i);\n            }\n        }\n\n        // remove marked pairs\n        for (i = 0; i < indexesToRemove.length; i++) {\n            pairIndex = indexesToRemove[i] - i;\n            pair = pairsList[pairIndex];\n            delete pairsTable[pair.id];\n            pairsList.splice(pairIndex, 1);\n        }\n    };\n\n    /**\n     * Clears the given pairs structure.\n     * @method clear\n     * @param {pairs} pairs\n     * @return {pairs} pairs\n     */\n    Pairs.clear = function(pairs) {\n        pairs.table = {};\n        pairs.list.length = 0;\n        pairs.collisionStart.length = 0;\n        pairs.collisionActive.length = 0;\n        pairs.collisionEnd.length = 0;\n        return pairs;\n    };\n\n})();\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\n*\n* @class Grid\n*/\n\nvar Grid = {};\n\nmodule.exports = Grid;\n\nvar Pair = __webpack_require__(9);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new grid.\n     * @method create\n     * @param {} options\n     * @return {grid} A new grid\n     */\n    Grid.create = function(options) {\n        var defaults = {\n            buckets: {},\n            pairs: {},\n            pairsList: [],\n            bucketWidth: 48,\n            bucketHeight: 48\n        };\n\n        return Common.extend(defaults, options);\n    };\n\n    /**\n     * The width of a single grid bucket.\n     *\n     * @property bucketWidth\n     * @type number\n     * @default 48\n     */\n\n    /**\n     * The height of a single grid bucket.\n     *\n     * @property bucketHeight\n     * @type number\n     * @default 48\n     */\n\n    /**\n     * Updates the grid.\n     * @method update\n     * @param {grid} grid\n     * @param {body[]} bodies\n     * @param {engine} engine\n     * @param {boolean} forceUpdate\n     */\n    Grid.update = function(grid, bodies, engine, forceUpdate) {\n        var i, col, row,\n            world = engine.world,\n            buckets = grid.buckets,\n            bucket,\n            bucketId,\n            gridChanged = false;\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isSleeping && !forceUpdate)\n                continue;\n\n            // temporary back compatibility bounds check\n            if (world.bounds && (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x\n                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y))\n                continue;\n\n            var newRegion = Grid._getRegion(grid, body);\n\n            // if the body has changed grid region\n            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n\n                if (!body.region || forceUpdate)\n                    body.region = newRegion;\n\n                var union = Grid._regionUnion(newRegion, body.region);\n\n                // update grid buckets affected by region change\n                // iterate over the union of both regions\n                for (col = union.startCol; col <= union.endCol; col++) {\n                    for (row = union.startRow; row <= union.endRow; row++) {\n                        bucketId = Grid._getBucketId(col, row);\n                        bucket = buckets[bucketId];\n\n                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol\n                                                && row >= newRegion.startRow && row <= newRegion.endRow);\n\n                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol\n                                                && row >= body.region.startRow && row <= body.region.endRow);\n\n                        // remove from old region buckets\n                        if (!isInsideNewRegion && isInsideOldRegion) {\n                            if (isInsideOldRegion) {\n                                if (bucket)\n                                    Grid._bucketRemoveBody(grid, bucket, body);\n                            }\n                        }\n\n                        // add to new region buckets\n                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {\n                            if (!bucket)\n                                bucket = Grid._createBucket(buckets, bucketId);\n                            Grid._bucketAddBody(grid, bucket, body);\n                        }\n                    }\n                }\n\n                // set the new region\n                body.region = newRegion;\n\n                // flag changes so we can update pairs\n                gridChanged = true;\n            }\n        }\n\n        // update pairs list only if pairs changed (i.e. a body changed region)\n        if (gridChanged)\n            grid.pairsList = Grid._createActivePairsList(grid);\n    };\n\n    /**\n     * Clears the grid.\n     * @method clear\n     * @param {grid} grid\n     */\n    Grid.clear = function(grid) {\n        grid.buckets = {};\n        grid.pairs = {};\n        grid.pairsList = [];\n    };\n\n    /**\n     * Finds the union of two regions.\n     * @method _regionUnion\n     * @private\n     * @param {} regionA\n     * @param {} regionB\n     * @return {} region\n     */\n    Grid._regionUnion = function(regionA, regionB) {\n        var startCol = Math.min(regionA.startCol, regionB.startCol),\n            endCol = Math.max(regionA.endCol, regionB.endCol),\n            startRow = Math.min(regionA.startRow, regionB.startRow),\n            endRow = Math.max(regionA.endRow, regionB.endRow);\n\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Gets the region a given body falls in for a given grid.\n     * @method _getRegion\n     * @private\n     * @param {} grid\n     * @param {} body\n     * @return {} region\n     */\n    Grid._getRegion = function(grid, body) {\n        var bounds = body.bounds,\n            startCol = Math.floor(bounds.min.x / grid.bucketWidth),\n            endCol = Math.floor(bounds.max.x / grid.bucketWidth),\n            startRow = Math.floor(bounds.min.y / grid.bucketHeight),\n            endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Creates a region.\n     * @method _createRegion\n     * @private\n     * @param {} startCol\n     * @param {} endCol\n     * @param {} startRow\n     * @param {} endRow\n     * @return {} region\n     */\n    Grid._createRegion = function(startCol, endCol, startRow, endRow) {\n        return { \n            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\n            startCol: startCol, \n            endCol: endCol, \n            startRow: startRow, \n            endRow: endRow \n        };\n    };\n\n    /**\n     * Gets the bucket id at the given position.\n     * @method _getBucketId\n     * @private\n     * @param {} column\n     * @param {} row\n     * @return {string} bucket id\n     */\n    Grid._getBucketId = function(column, row) {\n        return 'C' + column + 'R' + row;\n    };\n\n    /**\n     * Creates a bucket.\n     * @method _createBucket\n     * @private\n     * @param {} buckets\n     * @param {} bucketId\n     * @return {} bucket\n     */\n    Grid._createBucket = function(buckets, bucketId) {\n        var bucket = buckets[bucketId] = [];\n        return bucket;\n    };\n\n    /**\n     * Adds a body to a bucket.\n     * @method _bucketAddBody\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    Grid._bucketAddBody = function(grid, bucket, body) {\n        // add new pairs\n        for (var i = 0; i < bucket.length; i++) {\n            var bodyB = bucket[i];\n\n            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))\n                continue;\n\n            // keep track of the number of buckets the pair exists in\n            // important for Grid.update to work\n            var pairId = Pair.id(body, bodyB),\n                pair = grid.pairs[pairId];\n\n            if (pair) {\n                pair[2] += 1;\n            } else {\n                grid.pairs[pairId] = [body, bodyB, 1];\n            }\n        }\n\n        // add to bodies (after pairs, otherwise pairs with self)\n        bucket.push(body);\n    };\n\n    /**\n     * Removes a body from a bucket.\n     * @method _bucketRemoveBody\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    Grid._bucketRemoveBody = function(grid, bucket, body) {\n        // remove from bucket\n        bucket.splice(Common.indexOf(bucket, body), 1);\n\n        // update pair counts\n        for (var i = 0; i < bucket.length; i++) {\n            // keep track of the number of buckets the pair exists in\n            // important for _createActivePairsList to work\n            var bodyB = bucket[i],\n                pairId = Pair.id(body, bodyB),\n                pair = grid.pairs[pairId];\n\n            if (pair)\n                pair[2] -= 1;\n        }\n    };\n\n    /**\n     * Generates a list of the active pairs in the grid.\n     * @method _createActivePairsList\n     * @private\n     * @param {} grid\n     * @return [] pairs\n     */\n    Grid._createActivePairsList = function(grid) {\n        var pairKeys,\n            pair,\n            pairs = [];\n\n        // grid.pairs is used as a hashmap\n        pairKeys = Common.keys(grid.pairs);\n\n        // iterate over grid.pairs\n        for (var k = 0; k < pairKeys.length; k++) {\n            pair = grid.pairs[pairKeys[k]];\n\n            // if pair exists in at least one bucket\n            // it is a pair that needs further collision testing so push it\n            if (pair[2] > 0) {\n                pairs.push(pair);\n            } else {\n                delete grid.pairs[pairKeys[k]];\n            }\n        }\n\n        return pairs;\n    };\n    \n})();\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Matter = module.exports = __webpack_require__(23);\r\n\r\nMatter.Axes = __webpack_require__(10);\r\nMatter.Bodies = __webpack_require__(11);\r\nMatter.Body = __webpack_require__(6);\r\nMatter.Bounds = __webpack_require__(1);\r\nMatter.Common = __webpack_require__(0);\r\nMatter.Composite = __webpack_require__(5);\r\nMatter.Composites = __webpack_require__(24);\r\nMatter.Constraint = __webpack_require__(8);\r\nMatter.Contact = __webpack_require__(17);\r\nMatter.Detector = __webpack_require__(13);\r\nMatter.Engine = __webpack_require__(18);\r\nMatter.Events = __webpack_require__(4);\r\nMatter.Grid = __webpack_require__(21);\r\nMatter.Mouse = __webpack_require__(12);\r\nMatter.MouseConstraint = __webpack_require__(25);\r\nMatter.Pair = __webpack_require__(9);\r\nMatter.Pairs = __webpack_require__(20);\r\nMatter.Plugin = __webpack_require__(15);\r\nMatter.Query = __webpack_require__(26);\r\nMatter.Render = __webpack_require__(16);\r\nMatter.Resolver = __webpack_require__(19);\r\nMatter.Runner = __webpack_require__(27);\r\nMatter.SAT = __webpack_require__(14);\r\nMatter.Sleeping = __webpack_require__(7);\r\nMatter.Svg = __webpack_require__(28);\r\nMatter.Vector = __webpack_require__(2);\r\nMatter.Vertices = __webpack_require__(3);\r\nMatter.World = __webpack_require__(29);\r\n\r\n// temporary back compatibility\r\nMatter.Engine.run = Matter.Runner.run;\r\nMatter.Common.deprecated(Matter.Engine, 'run', 'Engine.run ➤ use Matter.Runner.run(engine) instead');\r\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n*\r\n* @class Matter\r\n*/\r\n\r\nvar Matter = {};\r\n\r\nmodule.exports = Matter;\r\n\r\nvar Plugin = __webpack_require__(15);\r\nvar Common = __webpack_require__(0);\r\n\r\n(function() {\r\n\r\n    /**\r\n     * The library name.\r\n     * @property name\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.name = 'matter-js';\r\n\r\n    /**\r\n     * The library version.\r\n     * @property version\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.version =  true ? \"0.17.1\" : undefined;\r\n\r\n    /**\r\n     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n     * @property uses\r\n     * @type {Array}\r\n     */\r\n    Matter.uses = [];\r\n\r\n    /**\r\n     * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n     * @property used\r\n     * @readOnly\r\n     * @type {Array}\r\n     */\r\n    Matter.used = [];\r\n\r\n    /**\r\n     * Installs the given plugins on the `Matter` namespace.\r\n     * This is a short-hand for `Plugin.use`, see it for more information.\r\n     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n     * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n     */\r\n    Matter.use = function() {\r\n        Plugin.use(Matter, Array.prototype.slice.call(arguments));\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method before\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.before = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathBefore(Matter, path, func);\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method after\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.after = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathAfter(Matter, path, func);\r\n    };\r\n\r\n})();\r\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Composites` module contains factory methods for creating composite bodies\n* with commonly used configurations (such as stacks and chains).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composites\n*/\n\nvar Composites = {};\n\nmodule.exports = Composites;\n\nvar Composite = __webpack_require__(5);\nvar Constraint = __webpack_require__(8);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(6);\nvar Bodies = __webpack_require__(11);\nvar deprecated = Common.deprecated;\n\n(function() {\n\n    /**\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method stack\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n        var stack = Composite.create({ label: 'Stack' }),\n            x = xx,\n            y = yy,\n            lastBody,\n            i = 0;\n\n        for (var row = 0; row < rows; row++) {\n            var maxHeight = 0;\n            \n            for (var column = 0; column < columns; column++) {\n                var body = callback(x, y, column, row, lastBody, i);\n                    \n                if (body) {\n                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,\n                        bodyWidth = body.bounds.max.x - body.bounds.min.x; \n\n                    if (bodyHeight > maxHeight)\n                        maxHeight = bodyHeight;\n                    \n                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });\n\n                    x = body.bounds.max.x + columnGap;\n\n                    Composite.addBody(stack, body);\n                    \n                    lastBody = body;\n                    i += 1;\n                } else {\n                    x += columnGap;\n                }\n            }\n            \n            y += maxHeight + rowGap;\n            x = xx;\n        }\n\n        return stack;\n    };\n    \n    /**\n     * Chains all bodies in the given composite together using constraints.\n     * @method chain\n     * @param {composite} composite\n     * @param {number} xOffsetA\n     * @param {number} yOffsetA\n     * @param {number} xOffsetB\n     * @param {number} yOffsetB\n     * @param {object} options\n     * @return {composite} A new composite containing objects chained together with constraints\n     */\n    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n        var bodies = composite.bodies;\n        \n        for (var i = 1; i < bodies.length; i++) {\n            var bodyA = bodies[i - 1],\n                bodyB = bodies[i],\n                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\n                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, \n                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\n                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n        \n            var defaults = {\n                bodyA: bodyA,\n                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },\n                bodyB: bodyB,\n                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }\n            };\n            \n            var constraint = Common.extend(defaults, options);\n        \n            Composite.addConstraint(composite, Constraint.create(constraint));\n        }\n\n        composite.label += ' Chain';\n        \n        return composite;\n    };\n\n    /**\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\n     * @method mesh\n     * @param {composite} composite\n     * @param {number} columns\n     * @param {number} rows\n     * @param {boolean} crossBrace\n     * @param {object} options\n     * @return {composite} The composite containing objects meshed together with constraints\n     */\n    Composites.mesh = function(composite, columns, rows, crossBrace, options) {\n        var bodies = composite.bodies,\n            row,\n            col,\n            bodyA,\n            bodyB,\n            bodyC;\n        \n        for (row = 0; row < rows; row++) {\n            for (col = 1; col < columns; col++) {\n                bodyA = bodies[(col - 1) + (row * columns)];\n                bodyB = bodies[col + (row * columns)];\n                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n            }\n\n            if (row > 0) {\n                for (col = 0; col < columns; col++) {\n                    bodyA = bodies[col + ((row - 1) * columns)];\n                    bodyB = bodies[col + (row * columns)];\n                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n\n                    if (crossBrace && col > 0) {\n                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n\n                    if (crossBrace && col < columns - 1) {\n                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n                }\n            }\n        }\n\n        composite.label += ' Mesh';\n        \n        return composite;\n    };\n    \n    /**\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method pyramid\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {\n            var actualRows = Math.min(rows, Math.ceil(columns / 2)),\n                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n            \n            if (row > actualRows)\n                return;\n            \n            // reverse row order\n            row = actualRows - row;\n            \n            var start = row,\n                end = columns - 1 - row;\n\n            if (column < start || column > end)\n                return;\n            \n            // retroactively fix the first body's position, since width was unknown\n            if (i === 1) {\n                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });\n            }\n\n            var xOffset = lastBody ? column * lastBodyWidth : 0;\n            \n            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\n        });\n    };\n\n    /**\n     * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to newtonsCradle example\n     * @method newtonsCradle\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} number\n     * @param {number} size\n     * @param {number} length\n     * @return {composite} A new composite newtonsCradle body\n     */\n    Composites.newtonsCradle = function(xx, yy, number, size, length) {\n        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });\n\n        for (var i = 0; i < number; i++) {\n            var separation = 1.9,\n                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, \n                    { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),\n                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });\n\n            Composite.addBody(newtonsCradle, circle);\n            Composite.addConstraint(newtonsCradle, constraint);\n        }\n\n        return newtonsCradle;\n    };\n\n    deprecated(Composites, 'newtonsCradle', 'Composites.newtonsCradle ➤ moved to newtonsCradle example');\n    \n    /**\n     * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to car example\n     * @method car\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} width\n     * @param {number} height\n     * @param {number} wheelSize\n     * @return {composite} A new composite car body\n     */\n    Composites.car = function(xx, yy, width, height, wheelSize) {\n        var group = Body.nextGroup(true),\n            wheelBase = 20,\n            wheelAOffset = -width * 0.5 + wheelBase,\n            wheelBOffset = width * 0.5 - wheelBase,\n            wheelYOffset = 0;\n    \n        var car = Composite.create({ label: 'Car' }),\n            body = Bodies.rectangle(xx, yy, width, height, { \n                collisionFilter: {\n                    group: group\n                },\n                chamfer: {\n                    radius: height * 0.5\n                },\n                density: 0.0002\n            });\n    \n        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { \n            collisionFilter: {\n                group: group\n            },\n            friction: 0.8\n        });\n                    \n        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { \n            collisionFilter: {\n                group: group\n            },\n            friction: 0.8\n        });\n                    \n        var axelA = Constraint.create({\n            bodyB: body,\n            pointB: { x: wheelAOffset, y: wheelYOffset },\n            bodyA: wheelA,\n            stiffness: 1,\n            length: 0\n        });\n                        \n        var axelB = Constraint.create({\n            bodyB: body,\n            pointB: { x: wheelBOffset, y: wheelYOffset },\n            bodyA: wheelB,\n            stiffness: 1,\n            length: 0\n        });\n        \n        Composite.addBody(car, body);\n        Composite.addBody(car, wheelA);\n        Composite.addBody(car, wheelB);\n        Composite.addConstraint(car, axelA);\n        Composite.addConstraint(car, axelB);\n\n        return car;\n    };\n\n    deprecated(Composites, 'car', 'Composites.car ➤ moved to car example');\n\n    /**\n     * This has now moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)\n     * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js), follow those instead as this function is deprecated here.\n     * @deprecated moved to softBody and cloth examples\n     * @method softBody\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {boolean} crossBrace\n     * @param {number} particleRadius\n     * @param {} particleOptions\n     * @param {} constraintOptions\n     * @return {composite} A new composite softBody\n     */\n    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);\n        constraintOptions = Common.extend({ stiffness: 0.2, render: { type: 'line', anchors: false } }, constraintOptions);\n\n        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {\n            return Bodies.circle(x, y, particleRadius, particleOptions);\n        });\n\n        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n\n        softBody.label = 'Soft Body';\n\n        return softBody;\n    };\n\n    deprecated(Composites, 'softBody', 'Composites.softBody ➤ moved to softBody and cloth examples');\n})();\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.\n* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class MouseConstraint\n*/\n\nvar MouseConstraint = {};\n\nmodule.exports = MouseConstraint;\n\nvar Vertices = __webpack_require__(3);\nvar Sleeping = __webpack_require__(7);\nvar Mouse = __webpack_require__(12);\nvar Events = __webpack_require__(4);\nvar Detector = __webpack_require__(13);\nvar Constraint = __webpack_require__(8);\nvar Composite = __webpack_require__(5);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\n\n(function() {\n\n    /**\n     * Creates a new mouse constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {engine} engine\n     * @param {} options\n     * @return {MouseConstraint} A new MouseConstraint\n     */\n    MouseConstraint.create = function(engine, options) {\n        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);\n\n        if (!mouse) {\n            if (engine && engine.render && engine.render.canvas) {\n                mouse = Mouse.create(engine.render.canvas);\n            } else if (options && options.element) {\n                mouse = Mouse.create(options.element);\n            } else {\n                mouse = Mouse.create();\n                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');\n            }\n        }\n\n        var constraint = Constraint.create({ \n            label: 'Mouse Constraint',\n            pointA: mouse.position,\n            pointB: { x: 0, y: 0 },\n            length: 0.01, \n            stiffness: 0.1,\n            angularStiffness: 1,\n            render: {\n                strokeStyle: '#90EE90',\n                lineWidth: 3\n            }\n        });\n\n        var defaults = {\n            type: 'mouseConstraint',\n            mouse: mouse,\n            element: null,\n            body: null,\n            constraint: constraint,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            }\n        };\n\n        var mouseConstraint = Common.extend(defaults, options);\n\n        Events.on(engine, 'beforeUpdate', function() {\n            var allBodies = Composite.allBodies(engine.world);\n            MouseConstraint.update(mouseConstraint, allBodies);\n            MouseConstraint._triggerEvents(mouseConstraint);\n        });\n\n        return mouseConstraint;\n    };\n\n    /**\n     * Updates the given mouse constraint.\n     * @private\n     * @method update\n     * @param {MouseConstraint} mouseConstraint\n     * @param {body[]} bodies\n     */\n    MouseConstraint.update = function(mouseConstraint, bodies) {\n        var mouse = mouseConstraint.mouse,\n            constraint = mouseConstraint.constraint,\n            body = mouseConstraint.body;\n\n        if (mouse.button === 0) {\n            if (!constraint.bodyB) {\n                for (var i = 0; i < bodies.length; i++) {\n                    body = bodies[i];\n                    if (Bounds.contains(body.bounds, mouse.position) \n                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {\n                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {\n                            var part = body.parts[j];\n                            if (Vertices.contains(part.vertices, mouse.position)) {\n                                constraint.pointA = mouse.position;\n                                constraint.bodyB = mouseConstraint.body = body;\n                                constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };\n                                constraint.angleB = body.angle;\n\n                                Sleeping.set(body, false);\n                                Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });\n\n                                break;\n                            }\n                        }\n                    }\n                }\n            } else {\n                Sleeping.set(constraint.bodyB, false);\n                constraint.pointA = mouse.position;\n            }\n        } else {\n            constraint.bodyB = mouseConstraint.body = null;\n            constraint.pointB = null;\n\n            if (body)\n                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });\n        }\n    };\n\n    /**\n     * Triggers mouse constraint events.\n     * @method _triggerEvents\n     * @private\n     * @param {mouse} mouseConstraint\n     */\n    MouseConstraint._triggerEvents = function(mouseConstraint) {\n        var mouse = mouseConstraint.mouse,\n            mouseEvents = mouse.sourceEvents;\n\n        if (mouseEvents.mousemove)\n            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });\n\n        if (mouseEvents.mousedown)\n            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });\n\n        if (mouseEvents.mouseup)\n            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });\n\n        // reset the mouse state ready for the next step\n        Mouse.clearSourceEvents(mouse);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when the mouse has moved (or a touch moves) during the last step\n    *\n    * @event mousemove\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is down (or a touch has started) during the last step\n    *\n    * @event mousedown\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is up (or a touch has ended) during the last step\n    *\n    * @event mouseup\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user starts dragging a body\n    *\n    * @event startdrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user ends dragging a body\n    *\n    * @event enddrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body that has stopped being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */\n\n    /**\n     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.\n     *\n     * @property mouse\n     * @type mouse\n     * @default mouse\n     */\n\n    /**\n     * The `Body` that is currently being moved by the user, or `null` if no body.\n     *\n     * @property body\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The `Constraint` object that is used to move the body during interaction.\n     *\n     * @property constraint\n     * @type constraint\n     */\n\n    /**\n     * An `Object` that specifies the collision filter properties.\n     * The collision filter allows the user to define which types of body this mouse constraint can interact with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n})();\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Query` module contains methods for performing collision queries.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Query\n*/\n\nvar Query = {};\n\nmodule.exports = Query;\n\nvar Vector = __webpack_require__(2);\nvar SAT = __webpack_require__(14);\nvar Bounds = __webpack_require__(1);\nvar Bodies = __webpack_require__(11);\nvar Vertices = __webpack_require__(3);\n\n(function() {\n\n    /**\n     * Returns a list of collisions between `body` and `bodies`.\n     * @method collides\n     * @param {body} body\n     * @param {body[]} bodies\n     * @return {object[]} Collisions\n     */\n    Query.collides = function(body, bodies) {\n        var collisions = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var bodyA = bodies[i];\n            \n            if (Bounds.overlaps(bodyA.bounds, body.bounds)) {\n                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {\n                    var part = bodyA.parts[j];\n\n                    if (Bounds.overlaps(part.bounds, body.bounds)) {\n                        var collision = SAT.collides(part, body);\n\n                        if (collision.collided) {\n                            collisions.push(collision);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\n     * @method ray\n     * @param {body[]} bodies\n     * @param {vector} startPoint\n     * @param {vector} endPoint\n     * @param {number} [rayWidth]\n     * @return {object[]} Collisions\n     */\n    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\n        rayWidth = rayWidth || 1e-100;\n\n        var rayAngle = Vector.angle(startPoint, endPoint),\n            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\n            rayX = (endPoint.x + startPoint.x) * 0.5,\n            rayY = (endPoint.y + startPoint.y) * 0.5,\n            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),\n            collisions = Query.collides(ray, bodies);\n\n        for (var i = 0; i < collisions.length; i += 1) {\n            var collision = collisions[i];\n            collision.body = collision.bodyB = collision.bodyA;            \n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\n     * @method region\n     * @param {body[]} bodies\n     * @param {bounds} bounds\n     * @param {bool} [outside=false]\n     * @return {body[]} The bodies matching the query\n     */\n    Query.region = function(bodies, bounds, outside) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                overlaps = Bounds.overlaps(body.bounds, bounds);\n            if ((overlaps && !outside) || (!overlaps && outside))\n                result.push(body);\n        }\n\n        return result;\n    };\n\n    /**\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\n     * @method point\n     * @param {body[]} bodies\n     * @param {vector} point\n     * @return {body[]} The bodies matching the query\n     */\n    Query.point = function(bodies, point) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n            \n            if (Bounds.contains(body.bounds, point)) {\n                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n\n                    if (Bounds.contains(part.bounds, point)\n                        && Vertices.contains(part.vertices, point)) {\n                        result.push(body);\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n})();\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Runner` module is an optional utility which provides a game loop, \n* that handles continuously updating a `Matter.Engine` for you within a browser.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.\n* Instead just call `Engine.update(engine, delta)` in your own loop.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Runner\n*/\n\nvar Runner = {};\n\nmodule.exports = Runner;\n\nvar Events = __webpack_require__(4);\nvar Engine = __webpack_require__(18);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    var _requestAnimationFrame,\n        _cancelAnimationFrame;\n\n    if (typeof window !== 'undefined') {\n        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\n                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;\n   \n        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame \n                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n    }\n\n    if (!_requestAnimationFrame) {\n        var _frameTimeout;\n\n        _requestAnimationFrame = function(callback){ \n            _frameTimeout = setTimeout(function() { \n                callback(Common.now()); \n            }, 1000 / 60);\n        };\n\n        _cancelAnimationFrame = function() {\n            clearTimeout(_frameTimeout);\n        };\n    }\n\n    /**\n     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * @method create\n     * @param {} options\n     */\n    Runner.create = function(options) {\n        var defaults = {\n            fps: 60,\n            correction: 1,\n            deltaSampleSize: 60,\n            counterTimestamp: 0,\n            frameCounter: 0,\n            deltaHistory: [],\n            timePrev: null,\n            timeScalePrev: 1,\n            frameRequestId: null,\n            isFixed: false,\n            enabled: true\n        };\n\n        var runner = Common.extend(defaults, options);\n\n        runner.delta = runner.delta || 1000 / runner.fps;\n        runner.deltaMin = runner.deltaMin || 1000 / runner.fps;\n        runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);\n        runner.fps = 1000 / runner.delta;\n\n        return runner;\n    };\n\n    /**\n     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.\n     * @method run\n     * @param {engine} engine\n     */\n    Runner.run = function(runner, engine) {\n        // create runner if engine is first argument\n        if (typeof runner.positionIterations !== 'undefined') {\n            engine = runner;\n            runner = Runner.create();\n        }\n\n        (function render(time){\n            runner.frameRequestId = _requestAnimationFrame(render);\n\n            if (time && runner.enabled) {\n                Runner.tick(runner, engine, time);\n            }\n        })();\n\n        return runner;\n    };\n\n    /**\n     * A game loop utility that updates the engine and renderer by one step (a 'tick').\n     * Features delta smoothing, time correction and fixed or dynamic timing.\n     * Consider just `Engine.update(engine, delta)` if you're using your own loop.\n     * @method tick\n     * @param {runner} runner\n     * @param {engine} engine\n     * @param {number} time\n     */\n    Runner.tick = function(runner, engine, time) {\n        var timing = engine.timing,\n            correction = 1,\n            delta;\n\n        // create an event object\n        var event = {\n            timestamp: timing.timestamp\n        };\n\n        Events.trigger(runner, 'beforeTick', event);\n\n        if (runner.isFixed) {\n            // fixed timestep\n            delta = runner.delta;\n        } else {\n            // dynamic timestep based on wall clock between calls\n            delta = (time - runner.timePrev) || runner.delta;\n            runner.timePrev = time;\n\n            // optimistically filter delta over a few frames, to improve stability\n            runner.deltaHistory.push(delta);\n            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);\n            delta = Math.min.apply(null, runner.deltaHistory);\n            \n            // limit delta\n            delta = delta < runner.deltaMin ? runner.deltaMin : delta;\n            delta = delta > runner.deltaMax ? runner.deltaMax : delta;\n\n            // correction for delta\n            correction = delta / runner.delta;\n\n            // update engine timing object\n            runner.delta = delta;\n        }\n\n        // time correction for time scaling\n        if (runner.timeScalePrev !== 0)\n            correction *= timing.timeScale / runner.timeScalePrev;\n\n        if (timing.timeScale === 0)\n            correction = 0;\n\n        runner.timeScalePrev = timing.timeScale;\n        runner.correction = correction;\n\n        // fps counter\n        runner.frameCounter += 1;\n        if (time - runner.counterTimestamp >= 1000) {\n            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);\n            runner.counterTimestamp = time;\n            runner.frameCounter = 0;\n        }\n\n        Events.trigger(runner, 'tick', event);\n\n        // update\n        Events.trigger(runner, 'beforeUpdate', event);\n        Engine.update(engine, delta, correction);\n        Events.trigger(runner, 'afterUpdate', event);\n\n        Events.trigger(runner, 'afterTick', event);\n    };\n\n    /**\n     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.\n     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.\n     * @method stop\n     * @param {runner} runner\n     */\n    Runner.stop = function(runner) {\n        _cancelAnimationFrame(runner.frameRequestId);\n    };\n\n    /**\n     * Alias for `Runner.run`.\n     * @method start\n     * @param {runner} runner\n     * @param {engine} engine\n     */\n    Runner.start = function(runner, engine) {\n        Runner.run(runner, engine);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired at the start of a tick, before any updates to the engine or timing\n    *\n    * @event beforeTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine timing updated, but just before update\n    *\n    * @event tick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired at the end of a tick, after engine update and after rendering\n    *\n    * @event afterTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired before update\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after update\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A flag that specifies whether the runner is running or not.\n     *\n     * @property enabled\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).\n     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).\n     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).\n     *\n     * @property isFixed\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A `Number` that specifies the time step between updates in milliseconds.\n     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.\n     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.\n     *\n     * @property delta\n     * @type number\n     * @default 1000 / 60\n     */\n\n})();\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\n*\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Svg\n*/\n\nvar Svg = {};\n\nmodule.exports = Svg;\n\nvar Bounds = __webpack_require__(1);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Converts an SVG path into an array of vector points.\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\n     * See `Bodies.fromVertices` which provides support for this.\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\n     * You must load the `pathseg.js` polyfill on newer browsers.\n     * @method pathToVertices\n     * @param {SVGPathElement} path\n     * @param {Number} [sampleLength=15]\n     * @return {Vector[]} points\n     */\n    Svg.pathToVertices = function(path, sampleLength) {\n        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\n            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\n        }\n\n        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n        var i, il, total, point, segment, segments, \n            segmentsQueue, lastSegment, \n            lastPoint, segmentIndex, points = [],\n            lx, ly, length = 0, x = 0, y = 0;\n\n        sampleLength = sampleLength || 15;\n\n        var addPoint = function(px, py, pathSegType) {\n            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\n\n            // when the last point doesn't equal the current point add the current point\n            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n                if (lastPoint && isRelative) {\n                    lx = lastPoint.x;\n                    ly = lastPoint.y;\n                } else {\n                    lx = 0;\n                    ly = 0;\n                }\n\n                var point = {\n                    x: lx + px,\n                    y: ly + py\n                };\n\n                // set last point\n                if (isRelative || !lastPoint) {\n                    lastPoint = point;\n                }\n\n                points.push(point);\n\n                x = lx + px;\n                y = ly + py;\n            }\n        };\n\n        var addSegmentPoint = function(segment) {\n            var segType = segment.pathSegTypeAsLetter.toUpperCase();\n\n            // skip path ends\n            if (segType === 'Z') \n                return;\n\n            // map segment to x and y\n            switch (segType) {\n\n            case 'M':\n            case 'L':\n            case 'T':\n            case 'C':\n            case 'S':\n            case 'Q':\n                x = segment.x;\n                y = segment.y;\n                break;\n            case 'H':\n                x = segment.x;\n                break;\n            case 'V':\n                y = segment.y;\n                break;\n            }\n\n            addPoint(x, y, segment.pathSegType);\n        };\n\n        // ensure path is absolute\n        Svg._svgPathToAbsolute(path);\n\n        // get total length\n        total = path.getTotalLength();\n\n        // queue segments\n        segments = [];\n        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)\n            segments.push(path.pathSegList.getItem(i));\n\n        segmentsQueue = segments.concat();\n\n        // sample through path\n        while (length < total) {\n            // get segment at position\n            segmentIndex = path.getPathSegAtLength(length);\n            segment = segments[segmentIndex];\n\n            // new segment\n            if (segment != lastSegment) {\n                while (segmentsQueue.length && segmentsQueue[0] != segment)\n                    addSegmentPoint(segmentsQueue.shift());\n\n                lastSegment = segment;\n            }\n\n            // add points in between when curving\n            // TODO: adaptive sampling\n            switch (segment.pathSegTypeAsLetter.toUpperCase()) {\n\n            case 'C':\n            case 'T':\n            case 'S':\n            case 'Q':\n            case 'A':\n                point = path.getPointAtLength(length);\n                addPoint(point.x, point.y, 0);\n                break;\n\n            }\n\n            // increment by sample value\n            length += sampleLength;\n        }\n\n        // add remaining segments not passed by sampling\n        for (i = 0, il = segmentsQueue.length; i < il; ++i)\n            addSegmentPoint(segmentsQueue[i]);\n\n        return points;\n    };\n\n    Svg._svgPathToAbsolute = function(path) {\n        // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n        // Copyright (c) Gavin Kistner\n        // http://phrogz.net/js/_ReuseLicense.txt\n        // Modifications: tidy formatting and naming\n        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,\n            x = 0, y = 0, len = segs.numberOfItems;\n\n        for (var i = 0; i < len; ++i) {\n            var seg = segs.getItem(i),\n                segType = seg.pathSegTypeAsLetter;\n\n            if (/[MLHVCSQTA]/.test(segType)) {\n                if ('x' in seg) x = seg.x;\n                if ('y' in seg) y = seg.y;\n            } else {\n                if ('x1' in seg) x1 = x + seg.x1;\n                if ('x2' in seg) x2 = x + seg.x2;\n                if ('y1' in seg) y1 = y + seg.y1;\n                if ('y2' in seg) y2 = y + seg.y2;\n                if ('x' in seg) x += seg.x;\n                if ('y' in seg) y += seg.y;\n\n                switch (segType) {\n\n                case 'm':\n                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n                    break;\n                case 'l':\n                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n                    break;\n                case 'h':\n                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n                    break;\n                case 'v':\n                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n                    break;\n                case 'c':\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n                    break;\n                case 's':\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n                    break;\n                case 'q':\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n                    break;\n                case 't':\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n                    break;\n                case 'a':\n                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n                    break;\n                case 'z':\n                case 'Z':\n                    x = x0;\n                    y = y0;\n                    break;\n\n                }\n            }\n\n            if (segType == 'M' || segType == 'm') {\n                x0 = x;\n                y0 = y;\n            }\n        }\n    };\n\n})();\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* This module has now been replaced by `Matter.Composite`.\n*\n* All usage should be migrated to the equivalent functions found on `Matter.Composite`.\n* For example `World.add(world, body)` now becomes `Composite.add(world, body)`.\n*\n* The property `world.gravity` has been moved to `engine.gravity`.\n*\n* For back-compatibility purposes this module will remain as a direct alias to `Matter.Composite` in the short term during migration.\n* Eventually this alias module will be marked as deprecated and then later removed in a future release.\n*\n* @class World\n*/\n\nvar World = {};\n\nmodule.exports = World;\n\nvar Composite = __webpack_require__(5);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * See above, aliases for back compatibility only\n     */\n    World.create = Composite.create;\n    World.add = Composite.add;\n    World.remove = Composite.remove;\n    World.clear = Composite.clear;\n    World.addComposite = Composite.addComposite;\n    World.addBody = Composite.addBody;\n    World.addConstraint = Composite.addConstraint;\n\n})();\n\n\n/***/ })\n/******/ ]);\n});","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\n\nexports.encode = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\n\nexports.decode = function(qs){\n  var qry = {};\n  var pairs = qs.split('&');\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n};\n","/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n    var src = str,\n        b = str.indexOf('['),\n        e = str.indexOf(']');\n\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n\n    var m = re.exec(str || ''),\n        uri = {},\n        i = 14;\n\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n\n    return uri;\n};\n\nfunction pathNames(obj, path) {\n    var regx = /\\/{2,9}/g,\n        names = path.replace(regx, \"/\").split(\"/\");\n\n    if (path.substr(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.substr(path.length - 1, 1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n\n    return names;\n}\n\nfunction queryKey(uri, query) {\n    var data = {};\n\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n\n    return data;\n}\n","import Matter from \"matter-js\";\r\nimport { Gameface } from \"../src/client/gameface\";\r\nimport { Render } from \"../src/client/render\";\r\nimport { Input } from \"../src/shared/input\";\r\n\r\nconst gameface = new Gameface(document.getElementById('game'));\r\ngameface.start();\r\n\r\nwindow['gameface'] = gameface;\r\nwindow['Render'] = Render;\r\nwindow['Input'] = Input;\r\n\r\ncreateMatterRender();\r\n\r\nfunction createMatterRender() {\r\n    const width = 800;\r\n    const height = 600;\r\n    const s = 2;\r\n    \r\n    // renderer\r\n    const engine = gameface.game.worlds[0].matter.engine!;\r\n    const render = Matter.Render.create({\r\n        element: document.body,\r\n        engine: engine,\r\n        bounds: {\r\n            min: { \r\n                x: -width/2 * s, \r\n                y: -height/2 * s\r\n            },\r\n            max: { \r\n                x: width/2 * s,\r\n                y: height/2 * s\r\n            }\r\n         },\r\n         options: {\r\n             hasBounds: true,\r\n             width: width,\r\n             height: height,\r\n             showAngleIndicator: true\r\n         }\r\n    });\r\n    Matter.Render.run(render);\r\n    \r\n    \r\n    \r\n    // mouse constraint\r\n    const matterWorld = gameface.game.worlds[0].matter.world!;\r\n    \r\n    const constraint: any = {\r\n        stiffness: 0.2,\r\n        render: {\r\n            visible: false\r\n        }\r\n    };\r\n    const mouse = Matter.Mouse.create(render.canvas);\r\n    const mouseConstraint = Matter.MouseConstraint.create(engine, {\r\n        mouse: mouse,\r\n        constraint: constraint\r\n    });\r\n    Matter.Composite.add(matterWorld, mouseConstraint);\r\n}\r\n\r\n","import * as pc from \"playcanvas\";\r\nimport { Input } from \"../shared/input\";\r\nimport { Gameface } from \"./gameface\";\r\nimport { Render } from \"./render\";\r\n\r\nexport class Camera {\r\n    public static height: number = 1000;\r\n    public static followPlayer: boolean = true;\r\n    public static get positon() { return this._position; }\r\n\r\n    public static testMode: boolean = false;\r\n\r\n    private static _position = new pc.Vec3();\r\n    \r\n    public static init() {\r\n        window[\"Camera\"] = Camera;\r\n    }\r\n\r\n    public static update(dt: number) {\r\n        this._position.z = this.height;\r\n\r\n        Render.camera?.setPosition(this._position.x * 0.01, this._position.z * 0.01, this._position.y * 0.01);\r\n\r\n        this.processTestMode();\r\n    }\r\n\r\n    private static processTestMode() {\r\n        if(this.testMode) {\r\n\r\n            //Input.mousePosition\r\n\r\n            const player = Gameface.Instance.player;\r\n\r\n            if(!player) return;\r\n\r\n            const position = player.transform.getPosition();\r\n\r\n            //Render.camera.setPosition(0, this.height * 0.01, 0);\r\n            //Render.camera.lookAt(this._position.x * 0.01, this._position.z * 0.01, this._position.y * 0.01)\r\n            Render.camera.setPosition(0, 20, 0)\r\n            Render.camera.lookAt(position.x * 0.01, 0, position.y * 0.01)\r\n\r\n        }\r\n    }\r\n\r\n    public static setPosition(x: number, y: number) {\r\n        this._position.x = x;\r\n        this._position.y = y;\r\n    }\r\n}","import * as pc from 'playcanvas';\r\nimport { Camera } from './camera';\r\nimport { Entity } from '../shared/entity/entity';\r\nimport { Game } from '../shared/game';\r\nimport { Input } from '../shared/input';\r\nimport { Network } from './network';\r\nimport { Render } from './render';\r\nimport { TextScript } from './playcanvas/scripts/textScript';\r\nimport { WorldSyncType } from '../shared/world';\r\nimport { EntityPlayer } from '../shared/entity/entityPlayer';\r\nimport { SyncComponent, SyncType } from '../shared/component/syncComponent';\r\n\r\nexport class Gameface {\r\n    public static Instance: Gameface;\r\n\r\n    public player?: Entity;\r\n    public controllingEntityId: string = \"\";\r\n\r\n    public get game() { return this._game; }\r\n    public get network() { return this._network; }\r\n    public get app() { return this._app; }\r\n\r\n    private _game: Game;\r\n    private _app: pc.Application;\r\n    private _network: Network;\r\n\r\n    private _canvas;\r\n\r\n    constructor(canvas) {\r\n        this._canvas = canvas;\r\n        this._game = new Game();\r\n        this._network = new Network();\r\n        \r\n        Gameface.Instance = this;\r\n    }\r\n\r\n    public start() {\r\n        this.initPlaycanvas();\r\n\r\n        this.network.init();\r\n\r\n        Camera.init();\r\n        Render.init(this._app);\r\n        Input.init(this._app);\r\n\r\n        this.game.start();\r\n\r\n        const isMultiplayer = true;\r\n\r\n        const world = this.game.createWorld('world');\r\n        if(isMultiplayer) world.syncType = WorldSyncType.CLIENT;\r\n        world.init();\r\n\r\n        Render.world = world;\r\n\r\n        \r\n\r\n        if(isMultiplayer) {\r\n            this.network.connect();\r\n            this.network.sendJoinServer('idk');\r\n        } else {\r\n            world.generateWorld();\r\n\r\n            const entity = world.spawnEntity(EntityPlayer);\r\n            this.setPlayer(entity);\r\n        }\r\n    }\r\n   \r\n    public update(dt: number) {\r\n        //this.game.update(dt);\r\n        this.network.update(dt);\r\n\r\n        this.checkControllingEntity();\r\n\r\n        Camera.update(dt);\r\n    }\r\n\r\n    public render(dt: number) {\r\n        Render.render(dt);\r\n    }\r\n\r\n\r\n    private initPlaycanvas() {\r\n        const canvas = this._canvas;\r\n        const app = this._app = new pc.Application(canvas, {\r\n            mouse: new pc.Mouse(canvas),\r\n            touch: new pc.TouchDevice(canvas),\r\n            keyboard: new pc.Keyboard(document.body)\r\n        });\r\n\r\n        pc.registerScript(TextScript, 'textScript', app);\r\n\r\n        \r\n        app.resizeCanvas(800, 600);\r\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\r\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\r\n\r\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\r\n\r\n        app.on('update', (dt: number) => this.update(dt));\r\n        app.on('update', (dt: number) => this.render(dt));\r\n        app.start();\r\n\r\n        window.addEventListener('resize', function(event) {\r\n            app.resizeCanvas()\r\n        }, true);\r\n\r\n\r\n        //--\r\n\r\n        /*\r\n        const text = new pc.Entity('text');\r\n        app.root.addChild(text);\r\n        const textScript = (text.addComponent('script') as pc.ScriptComponent).create('textScript') as TextScript;\r\n\r\n        console.log(textScript)\r\n        */\r\n    }\r\n\r\n    public setPlayer(entity: Entity) {\r\n        this.player = entity;\r\n        //this.player.getComponent(InputHandlerComponent)!.enabled = true;\r\n        //this.player.getComponent(SyncComponent)!.syncType = SyncType.DONT_SYNC;\r\n\r\n        console.warn(\"SETPLAYER\")\r\n    }\r\n\r\n    public checkControllingEntity() {\r\n       \r\n    }\r\n}\r\n","\r\nimport { io, Socket } from \"socket.io-client\";\r\nimport { Entity } from \"../shared/entity/entity\";\r\nimport { Gameface } from \"./gameface\";\r\nimport { IPacketData_ComponentEvent, IPacketData_ControlEntity, IPacketData_DestroyEntity, IPacketData_EntityData, IPacketData_JoinServer, IPacketData_SpawnEntity, Packet, PacketType } from \"../shared/packet\";\r\nimport { EntityChar } from \"../shared/entity/entityChar\";\r\nimport { ITransformComponent_Data } from \"../shared/component/transformComponent\";\r\nimport { SyncComponent } from \"../shared/component/syncComponent\";\r\n\r\n\r\n\r\nexport class Network {\r\n    public sendPacketInterval: number = 80;\r\n\r\n    private _socket: Socket;\r\n    private _sendPacketTime: number = 0;\r\n\r\n    public get address() {\r\n        if(location.host.includes('localhost')) return `${location.protocol}//${location.host}/`;\r\n        return `https://dmdassc-game.glitch.me/`;\r\n    }\r\n\r\n    public init() {\r\n        this._socket = io(this.address, {\r\n            //path: '/socket',\r\n            autoConnect: false,\r\n            reconnection: false\r\n        });\r\n\r\n        this._socket.on(\"p\", (packetType: PacketType, data: any) => {\r\n            const packet: Packet = {\r\n                type: packetType,\r\n                data: data\r\n            }\r\n\r\n            this.onReceivePacket(packet);\r\n        })\r\n\r\n        console.log(`[network] Address: (${this.address})`)\r\n    }\r\n\r\n    public connect() {\r\n        this._socket.connect();\r\n    }\r\n\r\n    public sendJoinServer(id: string) {\r\n        this.sendPacket<IPacketData_JoinServer>(PacketType.JOIN_SERVER, {id: id});\r\n    }\r\n\r\n    public update(dt: number) {\r\n        this._sendPacketTime += dt;\r\n        if(this._sendPacketTime >= this.sendPacketInterval / 1000) {\r\n            this._sendPacketTime = 0;\r\n\r\n            const player = Gameface.Instance.player;\r\n            if(player) this.sendPlayerData(player);\r\n        }\r\n    }\r\n\r\n    public sendPlayerData(entity: Entity) {\r\n\r\n        //const data = entity.data.getChangedData();\r\n\r\n        //console.log(data)\r\n\r\n        //entity.data.clearChangedData();\r\n\r\n        //this.sendPacket<IPacketData_EntityData>(PacketType.ENTITY_DATA, {id: entity.id, data: data})\r\n\r\n        /*\r\n        const components: Component[] = [entity.transform];\r\n        if(entity.hasComponent(InputHandlerComponent)) components.push(entity.getComponent(InputHandlerComponent));\r\n        const packet = FormatPacket.entityData(entity, components);\r\n        this.sendPacket(packet);\r\n        */\r\n    }\r\n\r\n    public sendPacket<T>(type: PacketType, packetData: T) {\r\n        const packet: Packet = {\r\n            type: type,\r\n            data: packetData\r\n        }\r\n        this._socket.emit('p', packet);\r\n    }\r\n\r\n    public onReceivePacket(packet: Packet) {\r\n        if(packet.type == PacketType.ENTITY_DATA) {\r\n            const packetData: IPacketData_EntityData = packet.data;\r\n\r\n            const id: string = packetData.id;\r\n\r\n            //console.log(id);\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n            let entity = world.getEntity(id);\r\n            \r\n            if(!entity) {\r\n                entity = new EntityChar(world);\r\n                entity.setId(id);\r\n                entity.addComponent(new SyncComponent());\r\n                world.addEntity(entity);\r\n            }\r\n            \r\n            entity.mergeData(packetData.d);\r\n        }\r\n\r\n        if(packet.type == PacketType.SPAWN_ENTITY) {\r\n            const packetData: IPacketData_SpawnEntity = packet.data;\r\n            \r\n            const entityId = packetData.id;\r\n            const entityType = packetData.type;\r\n\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            let entity = world.getEntity(entityId);\r\n\r\n            if(entity) return;\r\n\r\n            const c = world.game.entityFactory.getEntityByIndex(entityType);\r\n            \r\n            entity = new c(world);\r\n            entity.setId(entityId);\r\n        \r\n            const syncComponent = entity.addComponent(new SyncComponent());\r\n\r\n            entity.initData()\r\n            entity.mergeData(packetData.data);\r\n\r\n            world.addEntity(entity);\r\n\r\n            syncComponent.forceLerp();\r\n\r\n\r\n            console.log(\"spawn entity\", packetData)\r\n        }\r\n\r\n        /*\r\n        if(packet.type == PacketType.SPAWN_ENTITY) {\r\n            const packetData: IPacketData_SpawnEntity = packet.data;\r\n            \r\n            const entityId = packetData.id;\r\n            const entityType = packetData.type;\r\n\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) return;\r\n\r\n            const entity = world.spawnEntity(world.game.entityFactory.getEntityByIndex(entityType), {id: entityId, dontAdd: true});\r\n            const syncComponent = entity.addComponent(new SyncComponent());\r\n\r\n            entity.initData()\r\n            entity.mergeEntityData(packetData.data);\r\n\r\n            world.addEntity(entity);\r\n\r\n            syncComponent.forceLerp();\r\n\r\n            //FormatPacket.unserializeEntityData(entity, packet);\r\n            \r\n            console.log(\"spsawn entity\", packetData)\r\n        }\r\n\r\n        if(packet.type == PacketType.ENTITY_DATA) {\r\n            const packetData: IPacketData_SpawnEntity = packet.data;\r\n            \r\n            const world = Gameface.Instance.game.worlds[0];\r\n            const entity = world.getEntity(packetData.id);\r\n\r\n            if(!entity) return;\r\n\r\n            entity.mergeEntityData(packetData.data);\r\n\r\n\r\n            //console.log(packet)\r\n\r\n            //console.log(\"got data\");\r\n        }\r\n\r\n        if(packet.type == PacketType.CONTROL_ENTITY) {\r\n            const packetData: IPacketData_ControlEntity = packet.data;\r\n            \r\n\r\n            Gameface.Instance.controllingEntityId = packetData.id;\r\n            Gameface.Instance.checkControllingEntity();\r\n        }\r\n\r\n        if(packet.type == PacketType.DESTROY_ENTITY) {\r\n            const packetData: IPacketData_DestroyEntity = packet.data;\r\n            const entityId = packetData.id;\r\n            \r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) {\r\n                world.removeEntity(world.getEntity(entityId)!);\r\n            }\r\n        }\r\n\r\n        if(packet.type == PacketType.COMPONENT_EVENT) {\r\n            console.log(\"received component event packet\")\r\n\r\n            const packetData: IPacketData_ComponentEvent = packet.data;\r\n\r\n            const player = Gameface.Instance.player!;\r\n\r\n            const world = player.world;\r\n            const entity = world.getEntity(packetData.entity)!;\r\n\r\n            const component = entity.getComponent(world.game.entityFactory.getComponentByIndex(packetData.component));\r\n            //console.log(component)\r\n\r\n            component.onReceiveComponentEvent(packetData.event, packetData.data);\r\n\r\n        }\r\n\r\n        */\r\n       \r\n        //const packetType: PacketType = packet.readShort();\r\n        \r\n        /*\r\n        if(packetType == PacketType.COMPONENT_DATA) {\r\n            const entityId: string = packet.readString();\r\n            const cindex: number = packet.readShort();\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) {\r\n                const entity = world.getEntity(entityId)!;\r\n                entity.components.forEach(c => {\r\n                    try {\r\n                        if(cindex == world.game.entityFactory.getIndexOfComponent(c)) {\r\n                            c.unserialize(packet);\r\n                        }\r\n                    } catch (error) {}\r\n                });\r\n            }\r\n\r\n        }\r\n        */\r\n\r\n        /*\r\n        if(packetType == PacketType.ENTITY_DATA) {\r\n            const entityId = packet.readString();\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n            const entity = world.getEntity(entityId);\r\n            \r\n            if(entity) {\r\n                FormatPacket.unserializeEntityData(entity, packet);\r\n            }\r\n        }\r\n\r\n        if(packetType == PacketType.SPAWN_ENTITY) {\r\n            const entityId: string = packet.readString();\r\n            const entityType: number = packet.readShort();\r\n            \r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) return;\r\n\r\n            const entity = world.spawnEntity(world.game.entityFactory.getEntityByIndex(entityType), {id: entityId});\r\n            entity.addComponent(new SyncComponent());\r\n\r\n            FormatPacket.unserializeEntityData(entity, packet);\r\n            \r\n            console.log(\"spsawn entity\")\r\n        }\r\n\r\n        if(packetType == PacketType.DESTROY_ENTITY) {\r\n            const entityId: string = packet.readString();\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) {\r\n                world.removeEntity(world.getEntity(entityId)!);\r\n            }\r\n        }\r\n\r\n        \r\n        */\r\n    }\r\n}","import * as pc from \"playcanvas\";\r\n\r\nexport class TextScript extends pc.ScriptType {\r\n\r\n    public text: string = \"WorldText\";\r\n    public fontsize: number = 20;\r\n\r\n    public canvas: HTMLCanvasElement;\r\n    public context: CanvasRenderingContext2D;\r\n    public texture: pc.Texture;\r\n\r\n    public height: number = 20;\r\n\r\n    public initialize = () => {\r\n        this.fire('initialize');\r\n\r\n        // Create a canvas to do the text rendering\r\n        this.canvas = document.createElement('canvas');\r\n        this.context = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n        this.texture = new pc.Texture(this.app.graphicsDevice, {\r\n            format: pc.PIXELFORMAT_R8_G8_B8_A8\r\n        });\r\n        this.texture.setSource(this.canvas);\r\n        \r\n        this.texture.minFilter = pc.FILTER_LINEAR_MIPMAP_LINEAR;\r\n        this.texture.magFilter = pc.FILTER_LINEAR;\r\n\r\n        \r\n        this.texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;\r\n        this.texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;\r\n\r\n        const material = new pc.StandardMaterial();\r\n        this.entity.addComponent(\"render\", {\r\n            material: material,\r\n            type: \"plane\",\r\n        });\r\n\r\n        this.entity.render!.castShadows = false;\r\n        this.entity.render!.receiveShadows = false;\r\n\r\n        //material.emissiveMap = this.texture;\r\n\r\n        material.opacityMap = this.texture;\r\n        material.diffuseMap = this.texture;\r\n        material.blendType = pc.BLEND_NORMAL;\r\n        //material.depthTest = false;\r\n        material.update();\r\n\r\n        this.setTextureSize(512, this.height)\r\n        this.updateText();\r\n        \r\n    }\r\n\r\n    private setTextureSize(x: number, y: number) {\r\n        this.canvas.width = x;\r\n        this.canvas.height = y;\r\n        this.entity.setLocalScale(x * 0.01, 1, y * 0.01)\r\n    }\r\n\r\n    private setText(text: string) {\r\n        this.applyFont()\r\n\r\n        const ctx = this.context;\r\n        const width = ctx.measureText(text).width;\r\n\r\n        this.setTextureSize(width, this.height)\r\n\r\n        var w = ctx.canvas.width;\r\n        var h = ctx.canvas.height;\r\n\r\n        //ctx.fillStyle = \"#000000\";\r\n        ctx.clearRect(0, 0, w, h);\r\n        //ctx.fillRect(0, 0, w, h);\r\n\r\n        this.applyFont()\r\n        ctx.fillText(text, w / 2, h / 2);\r\n\r\n        this.texture.upload();\r\n    }\r\n\r\n    private applyFont() {\r\n        var ctx = this.context;\r\n        ctx.font = 'bold '+String(this.fontsize)+'px Verdana';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillStyle = 'black';\r\n    }\r\n\r\n    private updateText() {\r\n        this.setText(this.text);\r\n\r\n        setInterval(() => {\r\n            //this.text = `${Math.random()}`\r\n\r\n            //this.setText(this.text);\r\n        }, 200)\r\n    }\r\n\r\n    public postInitialize = () => {\r\n      \r\n\r\n        this.fire('postInitialize');\r\n    }\r\n\r\n\r\n    \r\n    public update = (dt) => {\r\n        this.fire('update', dt);\r\n    }\r\n\r\n    public postUpdate = (dt) => {\r\n        this.fire('postUpdate', dt);\r\n\r\n        //var pos = PlayCanvas.camera.getPosition();\r\n\r\n        //this.entity.setPosition(pos.x, 0, pos.z)\r\n\r\n        //this.text = `${this.app.}`;\r\n        //this.updateText();\r\n    }\r\n\r\n    public swap = () => {\r\n        this.fire('swap');\r\n    }\r\n}\r\n\r\n//TestScript.attributes.add('height', {type: 'number', default: 5});\r\n//TestScript.attributes.add('followEntity', {type: 'entity'});","import * as pc from 'playcanvas'\r\nimport { Entity } from '../shared/entity/entity';\r\nimport { World } from \"../shared/world\";\r\nimport { UI } from './ui/ui';\r\n\r\nexport class Render {\r\n    public static app: pc.Application;\r\n    public static world?: World;\r\n    public static camera: pc.Entity;\r\n    public static sunLight: pc.Entity;\r\n\r\n    private static _renderingEntities: Entity[] = [];\r\n\r\n    public static init(app: pc.Application) {\r\n        this.app = app;\r\n\r\n        this.setupLocalClientScene();\r\n    }\r\n\r\n    public static render(dt: number) {\r\n        this.renderWorld(dt);\r\n    }\r\n\r\n    private static renderWorld(dt: number) {\r\n        const world = this.world;\r\n        const app = this.app;\r\n\r\n        if(!world) return;\r\n\r\n\r\n        for (const entity of world.entities) {\r\n\r\n            \r\n            if(!this._renderingEntities.includes(entity)) {\r\n                this._renderingEntities.push(entity);\r\n\r\n                entity.createPcEntity();\r\n\r\n                console.log(\"[render] add pcEntity\");\r\n\r\n                app.root.addChild(entity.pcEntity);\r\n\r\n                //console.log(entity.pcEntityRoot.children)\r\n                //console.log(\"found\", entity.pcEntityRoot.findByName('CenterDebug'))\r\n\r\n                if(!entity.pcEntityRoot.findByName('CenterDebug')) {\r\n                    const material = new pc.StandardMaterial();\r\n                    material.diffuse = new pc.Color(0, 1, 0);\r\n                    material.update();\r\n\r\n                    const centerPcEntity = new pc.Entity('CenterDebug');\r\n                    centerPcEntity.addComponent(\"render\", {\r\n                        material: material,\r\n                        type: \"box\",\r\n                    });\r\n                    centerPcEntity.render!.castShadows = false;\r\n                    centerPcEntity.setLocalScale(new pc.Vec3(0.1, 0.1, 0.1));\r\n                    entity.pcEntityRoot.addChild(centerPcEntity);\r\n\r\n                    //console.log('CenterDebug', entity)\r\n                }\r\n\r\n               \r\n\r\n                /*\r\n                can't create new pc.Entity every time it streams in..\r\n                */\r\n                \r\n            }\r\n\r\n            \r\n            const transform = entity.transform;\r\n            const position = transform.getPosition();\r\n            entity.pcEntity.setPosition(position.x * 0.01, 0, position.y * 0.01);\r\n            entity.pcEntityRoot.setEulerAngles(0, pc.math.RAD_TO_DEG * -transform.data.angle, 0);\r\n            \r\n            \r\n        }\r\n        \r\n        for (const entity of this._renderingEntities) {\r\n            if(!world.entities.includes(entity)) \r\n            {\r\n                this._renderingEntities.splice(this._renderingEntities.indexOf(entity), 1);\r\n\r\n                console.log(\"[render] remove pcEntity\");\r\n                app.root.removeChild(entity.pcEntity);\r\n            }\r\n        }\r\n\r\n        for (const entity of this._renderingEntities) {\r\n            entity.render(dt);\r\n        }\r\n        \r\n        for (const entity of this._renderingEntities) {\r\n            entity.postrender(dt);\r\n        }\r\n    }\r\n\r\n    public static setupLocalClientScene() {\r\n        const app = this.app;\r\n        const camera = this.camera = new pc.Entity('camera');\r\n        camera.addComponent('camera', {\r\n            clearColor: new pc.Color(0.1, 0.1, 0.1)\r\n        });\r\n        app.root.addChild(camera);\r\n        camera.setPosition(0, 20, 0);\r\n        //camera.lookAt(0, 0, 0);\r\n        camera.setEulerAngles(-90, 0, 0);\r\n        (camera.addComponent('script') as pc.ScriptComponent).create('cameraFollow');\r\n        \r\n        \r\n        UI.init(app);\r\n\r\n        //app.scene.ambientLight.set(0, 0, 0)\r\n\r\n        //\r\n\r\n        /*\r\n        \r\n        const light = this.sunLight = new pc.Entity('light');\r\n        light.addComponent('light');\r\n        app.root.addChild(light);\r\n        //light.setEulerAngles(30, 30, 0);\r\n        light.setEulerAngles(30, 30, 0);\r\n\r\n\r\n        \r\n        light.light!.color = new pc.Color(1, 1, 1);\r\n        light.light!.castShadows = true;\r\n        light.light!.shadowType = 3;\r\n        light.light!.shadowDistance = 40\r\n        light.light!.intensity = 0.05\r\n\r\n        \r\n        console.log('light', light);\r\n\r\n        window['light'] = light;\r\n        */\r\n        \r\n\r\n        //\r\n\r\n\r\n        /*\r\n        const text = new pc.Entity('text');\r\n        app.root.addChild(text);\r\n        (text.addComponent('script') as pc.ScriptComponent).create('textScript');\r\n        */\r\n   \r\n        this.test();\r\n    }\r\n\r\n    private static test() {\r\n        const app = this.app;\r\n\r\n        const light = new pc.Entity('light');\r\n        const lightComponent = light.addComponent('light') as pc.LightComponent;\r\n        light.setPosition(2, 2, 0)\r\n        app.root.addChild(light);\r\n\r\n        lightComponent.type = \"point\"\r\n        lightComponent.color = new pc.Color(1, 1, 1);\r\n        lightComponent.range = 10;\r\n        lightComponent.intensity = 1;\r\n        lightComponent.shadowBias = 0.2\r\n        \r\n        lightComponent.castShadows = true;\r\n\r\n        window['testlight'] = lightComponent\r\n        //lightComponent.shadowType = 3;\r\n        //lightComponent.shadowDistance = 40\r\n\r\n        /*\r\n        temp1.range = 3\r\n        temp1.entity.setPosition(0, 0.5, 0)\r\n        temp1.intensity = 32\r\n        */\r\n\r\n        console.warn(lightComponent)\r\n        //lightComponent.shape = pc.LIGHTSHAPE_SPHERE;\r\n    }\r\n\r\n    public static loadAsset(url: string, callback: (asset: pc.Asset) => void) {\r\n        const imageUrl = url;\r\n        const app = Render.app;\r\n        \r\n        app.loader.getHandler(\"texture\")['crossOrigin'] = \"anonymous\";\r\n        \r\n        const asset = new pc.Asset(\"myTexture\", \"texture\", {url: imageUrl});\r\n\r\n        asset.on(\"error\", function (message) {\r\n            console.log(message);\r\n        });\r\n\r\n        asset.on(\"load\", function (asset) {\r\n            callback(asset); \r\n        });\r\n\r\n        app.assets.add(asset);\r\n        app.assets.load(asset);\r\n        return asset;\r\n    }\r\n\r\n    public static createGunFlash(x: number, y: number) {\r\n        const app = this.app;\r\n\r\n        if(!app) return;\r\n\r\n        const light = new pc.Entity('light');\r\n        const lightComponent = light.addComponent('light') as pc.LightComponent;\r\n        light.setPosition(x * 0.01, 0.2, y * 0.01)\r\n        app.root.addChild(light);\r\n\r\n        lightComponent.type = \"point\"\r\n        lightComponent.color = new pc.Color(1, 1, 0);\r\n        lightComponent.range = 1;\r\n        lightComponent.intensity = 1\r\n\r\n        setTimeout(() => {\r\n            light.destroy();\r\n            app.root.removeChild(light);\r\n        }, 60);\r\n    }\r\n}","import * as pc from 'playcanvas'\r\nimport { Render } from '../render';\r\n\r\nexport class UIText {\r\n    public get entity() { return this._entity; }\r\n\r\n    private _entity: pc.Entity;\r\n\r\n    constructor(x: number, y: number, text: string, fontAsset) {\r\n        const entity = new pc.Entity('ui-text');\r\n        entity.addComponent(\"element\", {\r\n            //anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5), // centered anchor\r\n            fontAsset: fontAsset,\r\n            fontSize: 10,\r\n            //pivot: new pc.Vec2(0.5, 0.5),            // centered pivot\r\n            text: text,\r\n            type: pc.ELEMENTTYPE_TEXT\r\n        });\r\n\r\n        this._entity = entity;\r\n    }\r\n\r\n    public setPosition(x: number, y: number) {\r\n        this.entity.setLocalPosition(x, y, 0);\r\n    }\r\n}\r\n\r\nexport class UI {\r\n    public static get screen() { return this._screen; }\r\n\r\n    private static _fontAsset: any;\r\n    private static _screen: pc.ScreenComponent;\r\n\r\n    public static init(app: pc.Application) {\r\n        const screenEntity = new pc.Entity('ui-screen');\r\n        this._screen = screenEntity.addComponent('screen', {\r\n            screenSpace: true, // for 2d screen\r\n            scaleMode: pc.SCALEMODE_BLEND,\r\n            scaleBlend: 0.5,\r\n        }) as pc.ScreenComponent;\r\n        app.root.addChild(screenEntity);\r\n\r\n        this.addImage();\r\n        const uitext = this.addText(0, 0, 'text');\r\n        //uitext.entity.setPosition(0, -1, 0)\r\n\r\n        window['UI'] = UI;\r\n    }\r\n\r\n    public static addText(x: number, y: number, text: string) {\r\n        const uiText = new UIText(x, y, text, this.getFontAsset());\r\n        uiText.setPosition(x, y);\r\n\r\n        this._screen.entity.addChild(uiText.entity);\r\n\r\n        return uiText;\r\n    }\r\n\r\n    public static addImage() {\r\n        const element = new pc.Entity('the element');\r\n        element.addComponent(\"element\", {\r\n            type: pc.ELEMENTTYPE_IMAGE\r\n        });\r\n\r\n        this._screen.entity.addChild(element);\r\n    }\r\n\r\n    public static getFontAsset() {\r\n        const app = Render.app;\r\n\r\n        if(this._fontAsset != undefined) return this._fontAsset;\r\n\r\n        this._fontAsset = new pc.Asset('arial.json', \"font\", { url: \"/assets/fonts/arial.json\" });\r\n        this._fontAsset.on('load', function () {\r\n            console.log(\"font loaded\")\r\n        });\r\n\r\n        app.assets.add(this._fontAsset);\r\n        app.assets.load(this._fontAsset);\r\n\r\n\r\n        return this._fontAsset;\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { Component } from \"./component\";\r\n\r\nenum BodyType {\r\n    RECTANGLE,\r\n    CIRCLE\r\n}\r\n\r\nclass BodyPart {\r\n    public key: string\r\n    public type: BodyType\r\n    public x: number\r\n    public y: number\r\n\r\n    public width: number = 0\r\n    public height: number = 0\r\n\r\n    public radius: number = 0\r\n\r\n    public sensor: boolean = false;\r\n\r\n    public body?: Matter.Body\r\n\r\n    constructor(key: string, x: number, y: number, type: BodyType) {\r\n        this.key = key\r\n        this.x = x\r\n        this.y = y\r\n        this.type = type\r\n    }\r\n}\r\n\r\n\r\nexport class CollisionComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 980;\r\n\r\n    public options: Matter.IChamferableBodyDefinition = {mass: 20, friction: 0.001, frictionAir: 0.3 };\r\n\r\n    public get body() { return this._body; }\r\n\r\n    private _body: Matter.Body;\r\n    private _bodyParts = new Map<string, BodyPart>();\r\n\r\n    public applyForce(x: number, y: number) {\r\n        const body = this.body;\r\n\r\n        if(!body) return;\r\n\r\n        const position = body.position;\r\n\r\n        Matter.Body.applyForce(body, position, {x: x, y: y});\r\n    }\r\n\r\n    public init() {\r\n        super.init();\r\n\r\n        this.createBody();\r\n    }\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n\r\n        const body = this.body;\r\n\r\n        if(body) {\r\n            this.entity.transform.data.x = body.position.x;\r\n            this.entity.transform.data.y = body.position.y;\r\n            this.entity.transform.data.velX = body.velocity.x;\r\n            this.entity.transform.data.velY = body.velocity.y;\r\n            this.entity.transform.data.angle = body.angle;\r\n        }\r\n    }\r\n\r\n    public preupdate(dt: number) {\r\n        super.preupdate(dt);\r\n        \r\n        const body = this.body;\r\n\r\n        if(body) {\r\n            Matter.Body.setPosition(body, {\r\n                x: this.entity.transform.data.x,\r\n                y: this.entity.transform.data.y\r\n            });\r\n            Matter.Body.setVelocity(body,  {\r\n                x: this.entity.transform.data.velX,\r\n                y: this.entity.transform.data.velY\r\n            });\r\n            Matter.Body.setAngle(body, this.entity.transform.data.angle);\r\n        }\r\n\r\n    }\r\n\r\n    public postupdate(dt: number) {\r\n        super.postupdate(dt);\r\n    }\r\n\r\n    private createBody() {\r\n\r\n        const matterWorld = this.entity.world.matter.world!;\r\n        const options = Object.assign({}, this.options);\r\n        const parts: Matter.Body[] = [];\r\n\r\n\r\n        for (const bodyPart of this._bodyParts.values()) {\r\n            \r\n            options.isSensor = bodyPart.sensor;\r\n            if(bodyPart.type == BodyType.RECTANGLE) bodyPart.body = Matter.Bodies.rectangle(bodyPart.x, bodyPart.y, bodyPart.width, bodyPart.height, options)\r\n            if(bodyPart.type == BodyType.CIRCLE) bodyPart.body = Matter.Bodies.circle(bodyPart.x, bodyPart.y, bodyPart.radius, options)\r\n\r\n            parts.push(bodyPart.body!)\r\n        }\r\n\r\n        options.isSensor = false;\r\n        options.parts = parts\r\n        \r\n        const body = Matter.Body.create(options);\r\n\r\n        Matter.Body.setCentre(body, {x: 0, y: 0});\r\n\r\n        Matter.Composite.add(matterWorld, body);\r\n      \r\n        this._body = body;\r\n    }\r\n\r\n    public getBodyPart(key: string) {\r\n        return this._bodyParts.get(key);\r\n    }\r\n\r\n    public addRectangle(key: string, x: number, y: number, width: number, height: number, sensor: boolean = false): BodyPart {\r\n        var bodyPart = new BodyPart(key, x, y, BodyType.RECTANGLE)\r\n\r\n        bodyPart.width = width\r\n        bodyPart.height = height\r\n        bodyPart.sensor = sensor;\r\n\r\n        this._bodyParts.set(key, bodyPart)\r\n\r\n        return bodyPart\r\n    }\r\n\r\n    public addCircle(key: string, x: number, y: number, radius: number): BodyPart {\r\n        var bodyPart = new BodyPart(key, x, y, BodyType.CIRCLE)\r\n\r\n        bodyPart.radius = radius\r\n  \r\n        this._bodyParts.set(key, bodyPart)\r\n\r\n        return bodyPart\r\n    }\r\n}","import { Client } from \"../../server/client\";\r\nimport { Entity } from \"../entity/entity\";\r\nimport { WorldEvent } from \"../worldEvent\";\r\n\r\nexport class Component {\r\n    public data: any;\r\n    \r\n    public entity: Entity;\r\n    public priority: number = 0;\r\n    \r\n    private _index: number | null = null;\r\n    private _a: boolean = false;\r\n\r\n    public init() {\r\n        //console.log(`[${this.constructor.name}] init`);\r\n    }\r\n    public initData() {\r\n        //console.log(`[${this.constructor.name}] init`);\r\n    }\r\n    public destroy() {\r\n        //console.log(`[${this.constructor.name}] destroy`);\r\n    }\r\n    public preupdate(dt: number) {}\r\n    public update(dt: number) {\r\n        if(!this._a) {\r\n            this._a = true;\r\n            //console.log(`[${this.constructor.name}] update`);\r\n        }\r\n    }\r\n    public postupdate(dt: number) {}\r\n\r\n    public render(dt: number) {}\r\n    public postrender(dt: number) {}\r\n\r\n    public sendComponentEvent(event: string, data, fromClient?: Client) {\r\n        this.entity.world.events.emit(WorldEvent.COMPONENT_EVENT, this, event, false, data, fromClient);\r\n    }\r\n\r\n    public broadcastComponentEvent(event: string, data, fromClient?: Client) {\r\n        this.entity.world.events.emit(WorldEvent.COMPONENT_EVENT, this, event, true, data, fromClient);\r\n    }\r\n\r\n    public onReceiveComponentEvent(event: string, data, fromClient?: Client) {}\r\n\r\n    public getIndex() {\r\n        if(this._index == null) {\r\n            this._index = this.entity.world.game.entityFactory.getIndexOfComponent(this);\r\n        }\r\n        return this._index;\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Render } from '../../client/render';\r\nimport { UI, UIText } from '../../client/ui/ui';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { WorldSyncType } from '../world';\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\nimport { SyncType } from './syncComponent';\r\n\r\nexport class DebugComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 0;\r\n\r\n    private _uitext?: UIText;\r\n\r\n    private _textLines = new Map<string, string>();\r\n\r\n    public initData(): void {\r\n    \r\n    }\r\n    \r\n    public init() {\r\n        super.init();\r\n\r\n        this.setLineText('default', this.entity.constructor.name);\r\n    }\r\n\r\n    public setLineText(line: string, text: string) {\r\n        this._textLines.set(line, text);\r\n    }\r\n\r\n    public render(dt: number): void {\r\n\r\n        if(!Render.app) return;\r\n\r\n        if(!this._uitext) {\r\n\r\n            this._uitext = UI.addText(0, 0, '');\r\n            this._uitext.entity.element.fontSize = 8;\r\n        }\r\n\r\n\r\n        //const position = this.entity.transform.getPosition();\r\n\r\n        var worldPos = this.entity.pcEntity.getPosition();\r\n        var screenPos = new pc.Vec3();\r\n        \r\n        // get screen space co-ord\r\n        Render.camera.camera.worldToScreen(worldPos, screenPos);\r\n\r\n        var pixelRatio = Render.app.graphicsDevice.maxPixelRatio;\r\n        screenPos.x *= pixelRatio;\r\n        screenPos.y *= pixelRatio;\r\n\r\n        // convert to screen component co-ordinates\r\n        var screenEntity = UI.screen.entity;\r\n        var scale = screenEntity.screen.scale;\r\n\r\n        var device = Render.app.graphicsDevice;\r\n\r\n        this._uitext.entity.setLocalPosition(screenPos.x / scale, (device.height - screenPos.y) / scale, 0);  \r\n\r\n        let str = ``;\r\n\r\n        for (const pair of this._textLines) {\r\n            str += `${pair[1]}\\n`;\r\n        }\r\n        \r\n        this._uitext.entity.element.text = str;\r\n    }\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\n\r\nexport class NPCBehaviourComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 0;\r\n\r\n    private _targetPosition = new pc.Vec2(300, 300);\r\n    private _newPositionTime = 0;\r\n\r\n    public init() {\r\n        super.init();\r\n    }\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n\r\n        this.processNewPosition(dt);\r\n        this.processMovement(dt);\r\n    }\r\n\r\n    private processNewPosition(dt: number) {\r\n        this._newPositionTime -= dt;\r\n        if(this._newPositionTime <= 0) {\r\n            this._newPositionTime = Math.random()*5;\r\n\r\n            const range = 1300;\r\n\r\n            this._targetPosition.x = Math.random()*range-(range/2);\r\n            this._targetPosition.y = Math.random()*range-(range/2);\r\n        }\r\n    }\r\n\r\n    private processMovement(dt: number) {\r\n\r\n        const input = {\r\n            horizontal: 0,\r\n            vertical: 0\r\n        };\r\n\r\n        const position = this.entity.transform.getPosition();\r\n\r\n        if(position.x < this._targetPosition.x) {\r\n            input.horizontal = 1;\r\n        } else {\r\n            input.horizontal = -1;\r\n        }\r\n\r\n        if(position.y < this._targetPosition.y) {\r\n            input.vertical = 1;\r\n        } else {\r\n            input.vertical = -1;\r\n        }\r\n\r\n        if(position.distance(this._targetPosition) < 30) {\r\n            input.vertical = 0;\r\n            input.horizontal = 0;\r\n        }\r\n\r\n\r\n        this.entity.transform.applyForce(input.horizontal * 2 * dt, input.vertical * 2 * dt);\r\n        //this.entity.transform.setVelocity(3, 0);\r\n        //this.entity.transform.setPosition(position.x + input.horizontal, position.y + input.vertical);\r\n    }\r\n   \r\n    public postupdate(dt: number) {\r\n        super.postupdate(dt);\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { WorldSyncType } from '../world';\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\nimport { DebugComponent } from './debugComponent';\r\nimport { SyncType } from './syncComponent';\r\n\r\nexport interface IPlayerComponent_Data {\r\n    name: string\r\n    color: number\r\n}\r\n\r\nexport class PlayerComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 0;\r\n\r\n    public data: IPlayerComponent_Data = {\r\n        name: 'no name',\r\n        color: 0\r\n    }\r\n\r\n    public initData(): void {\r\n        if(this.entity.world.syncType != WorldSyncType.CLIENT) {\r\n            setInterval(() => {\r\n                this.data.color++\r\n            }, 1000)\r\n        }\r\n    }\r\n    \r\n    public init() {\r\n        super.init();\r\n\r\n        \r\n    }\r\n\r\n\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n\r\n        this.entity.getComponent(DebugComponent)?.setLineText('playername', `${this.data.name}, ${this.data.color}`)\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\n\r\nexport enum SyncType {\r\n    DONT_SYNC,\r\n    CLIENT_SYNC,\r\n    SERVER_SYNC\r\n}\r\n\r\nexport class SyncComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 1010;\r\n    \r\n    public syncType: SyncType = SyncType.CLIENT_SYNC;\r\n    public positionLerp: number = 0.05;\r\n\r\n    private _targetPosition = new pc.Vec2();\r\n    private _targetVelocity = new pc.Vec2();\r\n    private _targetAngle = 0;\r\n    private _lastUpdated: number = 0;\r\n\r\n    public init() {\r\n        super.init();\r\n    }\r\n\r\n    public processSync() {\r\n\r\n        if(this.syncType == SyncType.DONT_SYNC) return;\r\n\r\n        const now = Date.now();\r\n\r\n        let tl = 800;\r\n        let lerpFactor = (1 - (Math.min(tl, now - this._lastUpdated) / tl))\r\n\r\n        //lerpFactor = 1;\r\n\r\n\r\n        //if(now - this._lastUpdated > (this.entity.syncInterval == 0 ? 500 : 1)) return;\r\n\r\n        \r\n        const transform = this.entity.transform;\r\n\r\n        const position = transform.getPosition();\r\n\r\n        let posLerp = this.positionLerp;\r\n        const distance = this._targetPosition.distance(position);\r\n        if(distance > 60) {\r\n            posLerp = 1;\r\n        }\r\n\r\n        const x = pc.math.lerp(position.x, this._targetPosition.x, posLerp * lerpFactor);\r\n        const y = pc.math.lerp(position.y, this._targetPosition.y, posLerp * lerpFactor);\r\n\r\n        let angle = pc.math.lerpAngle(transform.getAngle(), this._targetAngle, 0.7 * lerpFactor);\r\n        if(Math.abs(angle - this._targetAngle) >= Math.PI/4) angle = this._targetAngle;\r\n\r\n        const velocity = transform.getVelocity();\r\n\r\n        const velX = pc.math.lerp(velocity.x, this._targetVelocity.x, 0.8 );\r\n        const velY = pc.math.lerp(velocity.y, this._targetVelocity.y, 0.8 );\r\n\r\n        \r\n        transform.setPosition(x, y);\r\n        transform.setAngle(angle);\r\n        transform.setVelocity(velX, velY);\r\n\r\n        //console.log(velX, velY)\r\n        //transform.setAngularVelocity(0);\r\n    }\r\n\r\n    public preupdate(dt: number) {\r\n        super.preupdate(dt);\r\n\r\n        this.processSync();\r\n    }\r\n\r\n    public setPosition(x: number, y: number) {\r\n        this._lastUpdated = Date.now();\r\n        this._targetPosition.set(x, y);\r\n    }\r\n\r\n    public setAngle(angle: number) {\r\n        this._lastUpdated = Date.now();\r\n        this._targetAngle = angle;\r\n    }\r\n\r\n    public setVelocity(x: number, y: number) {\r\n        this._lastUpdated = Date.now();\r\n        this._targetVelocity.set(x, y);\r\n    }\r\n\r\n    public forceLerp() {\r\n        const transform = this.entity.transform;\r\n\r\n        transform.setPosition(this._targetPosition.x, this._targetPosition.y);\r\n        transform.setAngle(this._targetAngle);\r\n        transform.setVelocity(this._targetVelocity.x, this._targetVelocity.y);\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\n\r\nexport interface ITransformComponent_Data {\r\n    x: number\r\n    y: number\r\n    velX: number\r\n    velY: number\r\n    angle: number\r\n    aimAngle: number\r\n}\r\n\r\nexport class TransformComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 1000;\r\n\r\n    private _collisionComponent?: CollisionComponent;\r\n\r\n    public data: ITransformComponent_Data = {\r\n        angle: 0,\r\n        aimAngle: 0,\r\n        x: 0,\r\n        y: 0,\r\n        velX: 0,\r\n        velY: 0\r\n    }\r\n    \r\n    public getAngle() {\r\n        return this.data.angle;\r\n    }\r\n\r\n    public setAngle(angle: number) {\r\n        this.data.angle = angle;\r\n    }\r\n\r\n    public getAimAngle() {\r\n        return this.data.angle;\r\n    }\r\n\r\n    public setAimAngle(angle: number) {\r\n        this.data.aimAngle = angle;\r\n    }\r\n\r\n    public getPosition() {\r\n        return new pc.Vec2(this.data.x, this.data.y);\r\n    }\r\n    \r\n    public setPosition(x: number, y: number) {\r\n        this.data.x = x;\r\n        this.data.y = y;\r\n    }\r\n\r\n    public getVelocity() {\r\n        return new pc.Vec2(this.data.velX, this.data.velY);\r\n    }\r\n\r\n    public setVelocity(x: number, y: number) {\r\n        this.data.velX = x;\r\n        this.data.velY = y;\r\n    }\r\n    \r\n    public applyForce(x: number, y: number) {\r\n        this._collisionComponent?.applyForce(x, y);\r\n    }\r\n\r\n    public init() {\r\n        super.init();\r\n\r\n        this._collisionComponent = this.entity.getComponent(CollisionComponent);\r\n    }\r\n\r\n    public preupdate(dt: number) {\r\n        super.preupdate(dt);\r\n    }\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n    }\r\n\r\n    public postupdate(dt: number) {\r\n        super.postupdate(dt);\r\n    }\r\n}","import { Component } from \"./component/component\";\r\nimport { Entity } from \"./entity/entity\";\r\n\r\nexport class EntityFactory {\r\n\r\n    private _allComponents: { new(...args: any[]): Component }[] = [];\r\n    private _allEntities: { new(...args: any[]): Entity }[] = [];\r\n\r\n\r\n    public registerEntity<T extends Entity>(constr: { new(...args: any[]): T }) {\r\n        this._allEntities.push(constr);\r\n    }\r\n\r\n    public registerComponent<T extends Component>(constr: { new(...args: any[]): T }) {\r\n        this._allComponents.push(constr);\r\n    }\r\n\r\n    public getIndexOfComponent<T extends Component>(c: T) {\r\n        let i = 0;\r\n        for (const constr of this._allComponents) {\r\n            if(constr.name == c.constructor.name) return i;\r\n            i++;\r\n        }\r\n        throw \"Component \" + c.constructor.name + \" not found\";\r\n    }\r\n\r\n    public getEntityByIndex(index: number) {\r\n        return this._allEntities[index];\r\n    }\r\n\r\n    public getComponentByIndex(index: number) {\r\n        return this._allComponents[index];\r\n    }\r\n\r\n    public getIndexOfEntity<T extends Entity>(c: T) {\r\n        let i = 0;\r\n        for (const constr of this._allEntities.values()) {\r\n            if(constr.name == c.constructor.name) return i;\r\n            i++;\r\n        }\r\n        throw \"Entity \" + c.constructor.name + \" not found\";\r\n    }\r\n}","import * as pc from 'playcanvas';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { Component } from '../component/component';\r\nimport { SyncComponent } from '../component/syncComponent';\r\nimport { ITransformComponent_Data, TransformComponent } from '../component/transformComponent';\r\nimport { World } from '../world';\r\n\r\nexport class DataWatcher {\r\n\r\n    private _data: any = {};\r\n    //private _changedData: any = {};\r\n\r\n    public setData(data: any) {\r\n\r\n        //console.log(\"\\n_data:\", JSON.stringify(this._data))\r\n        //console.log(\"new data:\", JSON.stringify(data))\r\n\r\n        const changedData = this.testObj(data, this._data);\r\n        //console.log(\"changedData:\", JSON.stringify(changedData))\r\n\r\n        //this._data = Object.assign({}, data);\r\n        this._data = JSON.parse(JSON.stringify(data));\r\n\r\n        return changedData;\r\n    }\r\n\r\n    public testObj(o: any, compare: any) {\r\n        //console.log(\"test obj\", JSON.stringify(o))\r\n\r\n        let result: any = undefined;\r\n   \r\n        const setResult = (key: string, value: any) => {\r\n            if(result == undefined) result = {}; \r\n\r\n            result[key] = value;\r\n        }\r\n\r\n        for (const k in o) {\r\n\r\n            //console.log(\"--\", k)\r\n\r\n\r\n            \r\n            if(o[k] instanceof Object) {\r\n                \r\n\r\n                const resultObj = this.testObj(o[k], compare[k]);\r\n\r\n                if(resultObj != undefined) {\r\n                    setResult(k, resultObj)\r\n                }\r\n            } else {\r\n\r\n                if(compare == undefined) {\r\n                    //console.log(\"compare not defined\")\r\n\r\n                    setResult(k, o[k]);\r\n                } else {\r\n\r\n                    if(compare[k] != o[k]) {\r\n\r\n                        setResult(k, o[k])\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nexport class Entity {\r\n    public destroyed: boolean = false;\r\n    \r\n    public dataWatcher: DataWatcher = new DataWatcher();\r\n    \r\n    public canSync: boolean = true;\r\n\r\n    public get id() { return this._id; }\r\n    public get world() { return this._world; }\r\n    public get components() { return this._components; }\r\n    public get transform() { return this._transform; }\r\n    public get pcEntity() { return this._pcEntity!; }\r\n    public get pcEntityRoot() { return this.pcEntity.findByName('Root')!; }\r\n    \r\n    /*\r\n    public get pcEntity() {\r\n        if(!this._pcEntity) {\r\n            this._pcEntity = new pc.Entity('Entity');\r\n            this._pcEntity.addChild(new pc.Entity('Root'))\r\n        }\r\n        return this._pcEntity;\r\n    }\r\n    */\r\n    \r\n\r\n    private _index: number | null = null;\r\n    private _pcEntity?: pc.Entity;\r\n    private _id: string = uuidv4();\r\n    private _world: World;\r\n    private _components: Component[] = [];\r\n    private _transform: TransformComponent;\r\n    private _hasInitalized: boolean = false;\r\n    private _hasInitalizedData: boolean = false;\r\n\r\n    constructor(world: World, pcEntity?: pc.Entity) {\r\n        this._world = world;\r\n        if(pcEntity) this._pcEntity = pcEntity;\r\n        this._transform = this.addComponent(new TransformComponent());\r\n    }\r\n\r\n    public getFullData() {\r\n        let fullData: any = undefined;\r\n\r\n        for (const component of this.components) {\r\n            const data = component.data;\r\n\r\n            if(data == undefined) continue;\r\n\r\n            if(fullData == undefined) fullData = {};\r\n\r\n            fullData[component.getIndex()] = data;\r\n\r\n        }\r\n        return fullData;\r\n    }\r\n\r\n    public mergeData(data: any) {\r\n        if(data == undefined) return;\r\n\r\n        //\r\n        const transformData = data[this.transform.getIndex()];\r\n\r\n        if(transformData != undefined) {\r\n            const transform = this.transform;\r\n\r\n            const angle = transform.getAngle();\r\n            const toSyncAngle = transformData.angle != undefined ? transformData.angle : angle;\r\n    \r\n            const position = transform.getPosition();\r\n            const toSyncPosition = {\r\n                x: transformData.x != undefined ? transformData.x : position.x,\r\n                y: transformData.y != undefined ? transformData.y : position.y\r\n            }\r\n\r\n            const velocity = transform.getVelocity();\r\n            const toSyncVelocity = {\r\n                x: transformData.velX != undefined ? transformData.velX : velocity.x,\r\n                y: transformData.velY != undefined ? transformData.velY : velocity.y\r\n            }\r\n    \r\n            Object.assign(transform.data, transformData);\r\n\r\n            delete data[transform.getIndex()];\r\n\r\n            const syncComponent = this.getComponent(SyncComponent);\r\n    \r\n            if(syncComponent) {\r\n                transform.setPosition(position.x, position.y);\r\n                transform.setVelocity(velocity.x, velocity.y);\r\n                transform.setAngle(angle);\r\n                \r\n                syncComponent.setPosition(toSyncPosition.x, toSyncPosition.y);\r\n                syncComponent.setVelocity(toSyncVelocity.x, toSyncVelocity.y);\r\n                syncComponent.setAngle(toSyncAngle);\r\n            }\r\n        }\r\n\r\n        //\r\n\r\n        for (const component of this._components) {\r\n            const cdata = data[component.getIndex()];\r\n            if(cdata == undefined) continue;\r\n            Object.assign(component.data, cdata);\r\n        }\r\n\r\n\r\n\r\n     \r\n        \r\n        \r\n    }\r\n\r\n    public setId(id: string) {\r\n        this._id = id;\r\n    }\r\n\r\n    public addComponent<C extends Component>(c: C) {\r\n        c.entity = this;\r\n        this._components.push(c);\r\n\r\n        this._components = this._components.sort((a, b) => b.priority - a.priority)\r\n\r\n        if(this._hasInitalized) c.init();\r\n        return c;\r\n    }\r\n\r\n    public createPcEntity() {\r\n        if(!this._pcEntity) {\r\n            this._pcEntity = new pc.Entity('Entity');\r\n            this._pcEntity.addChild(new pc.Entity('Root'))\r\n        }\r\n    }\r\n\r\n    /*\r\n    public hasComponent<C extends Component>(constr: { new(...args: any[]): C }) {\r\n        for (const component of this._components) if (component instanceof constr) return true;\r\n        return false;\r\n    }\r\n    */\r\n\r\n    public getComponent<C extends Component>(constr: { new(...args: any[]): C }) {\r\n        for (const component of this._components) if (component instanceof constr) return component as C;\r\n        return \r\n    }\r\n\r\n    public initData() {\r\n        if(this._hasInitalizedData) return;\r\n\r\n        for (const component of this._components) component.initData();\r\n        this._hasInitalizedData = true;\r\n    }\r\n\r\n    public init() {\r\n        this.initData();\r\n        for (const component of this._components) component.init();\r\n        this._hasInitalized = true;\r\n    }\r\n\r\n    public preupdate(dt: number) {\r\n        for (const component of this._components) component.preupdate(dt);\r\n    }\r\n\r\n    public update(dt: number) {\r\n        for (const component of this._components) component.update(dt);\r\n    }\r\n\r\n    public postupdate(dt: number) {\r\n        for (const component of this._components) component.postupdate(dt);\r\n    }\r\n\r\n    public render(dt: number) {\r\n        for (const component of this._components) component.render(dt);\r\n    }\r\n\r\n    public postrender(dt: number) {\r\n        for (const component of this._components) component.postrender(dt);\r\n    }\r\n\r\n    public destroy() {\r\n        if(this.destroyed) return;\r\n        this.destroyed = true;\r\n\r\n        for (const component of this._components) component.destroy();\r\n    }\r\n\r\n    public getIndex() {\r\n        \r\n        if(this._index == null) {\r\n            this._index = this.world.game.entityFactory.getIndexOfEntity(this);\r\n        }\r\n        return this._index;\r\n    }\r\n}","import { CollisionComponent } from \"../component/collisionComponent\";\r\nimport { DebugComponent } from \"../component/debugComponent\";\r\nimport { PlayerComponent } from \"../component/playerComponent\";\r\nimport { World } from \"../world\";\r\nimport { Entity } from \"./entity\";\r\n\r\nexport class EntityChar extends Entity {\r\n    constructor(world: World) {\r\n        super(world);\r\n\r\n        this.addComponent(new PlayerComponent());\r\n        this.addComponent(new DebugComponent());\r\n        //this.addComponent(new InputHandlerComponent());\r\n\r\n        //const sprite = this.addComponent(new SpriteComponent());\r\n        //sprite.add('default', 'assets/player.png', 3, 80, 80);\r\n\r\n        const collision = this.addComponent(new CollisionComponent());\r\n        //collision.options.frictionAir = 0.2;\r\n        collision.addCircle('default', 0, 0, 30);\r\n    }\r\n}","import { CollisionComponent } from \"../component/collisionComponent\";\r\nimport { DebugComponent } from \"../component/debugComponent\";\r\nimport { PlayerComponent } from \"../component/playerComponent\";\r\nimport { World } from \"../world\";\r\nimport { Entity } from \"./entity\";\r\n\r\nexport class EntityObject extends Entity {\r\n    constructor(world: World) {\r\n        super(world);\r\n\r\n        this.addComponent(new DebugComponent());\r\n        \r\n\r\n        const collision = this.addComponent(new CollisionComponent());\r\n        //collision.options.frictionAir = 0.2;\r\n        collision.addRectangle('default', 0, 0, 50, 50);\r\n    }\r\n}","import { PlayerComponent } from \"../component/playerComponent\";\r\nimport { World } from \"../world\";\r\nimport { EntityChar } from \"./entityChar\";\r\n\r\nexport class EntityPlayer extends EntityChar {\r\n    constructor(world: World) {\r\n        super(world);\r\n    }\r\n}","export class EventEmitter {\r\n    private _events = new Map<string, ((...args: any) => void)[]>();\r\n\r\n    public on(event: string, fn: (...args: any) => void) {\r\n        console.log(`added listener for ${event}`);\r\n\r\n        if(!this._events.has(event)) {\r\n            this._events.set(event, []);\r\n        }\r\n\r\n        this._events.get(event)!.push(fn);\r\n\r\n        //console.log(this._events)\r\n    }   \r\n\r\n    public emit(event: string, ...args) {\r\n        //console.log(event, args)\r\n\r\n        if(!this._events.has(event)) return;\r\n\r\n        for (const fn of this._events.get(event)!) {\r\n            fn.apply(null, args);\r\n        }\r\n\r\n    }\r\n}","import { TransformComponent } from \"./component/transformComponent\";\r\nimport { EntityFactory } from \"./entityFactory\";\r\nimport { World } from \"./world\";\r\nimport { InventoryManager } from \"./inventoryManager\";\r\nimport { EntityChar } from \"./entity/entityChar\";\r\nimport { EntityPlayer } from \"./entity/entityPlayer\";\r\nimport { CollisionComponent } from \"./component/collisionComponent\";\r\nimport { PlayerComponent } from \"./component/playerComponent\";\r\nimport { NPCBehaviourComponent } from \"./component/npcBehaviourComponent\";\r\nimport { EntityObject } from \"./entity/entityObject\";\r\nimport { SyncComponent } from \"./component/syncComponent\";\r\nimport { DebugComponent } from \"./component/debugComponent\";\r\n\r\nexport class Game {\r\n    public get worlds() { return Array.from(this._worlds.values()); }\r\n    public get entityFactory() { return this._entityFactory; }\r\n\r\n    private _worlds = new Map<string, World>();\r\n    private _entityFactory: EntityFactory;\r\n    private _inventoryManager: InventoryManager;\r\n\r\n    public updateInterval: number = 16;\r\n    public fixTime: number = 0.94;\r\n\r\n    constructor() {\r\n        this._entityFactory = new EntityFactory();\r\n\r\n        this._entityFactory.registerComponent(TransformComponent);\r\n        this._entityFactory.registerComponent(CollisionComponent);\r\n        this._entityFactory.registerComponent(PlayerComponent);\r\n        this._entityFactory.registerComponent(NPCBehaviourComponent);\r\n        this._entityFactory.registerComponent(SyncComponent);\r\n        this._entityFactory.registerComponent(DebugComponent);\r\n\r\n\r\n        this._entityFactory.registerEntity(EntityChar);\r\n        this._entityFactory.registerEntity(EntityPlayer);\r\n        this._entityFactory.registerEntity(EntityObject);\r\n\r\n        this._inventoryManager = new InventoryManager();\r\n\r\n        const inventory = this._inventoryManager.createInventory('test');\r\n        inventory.createTab(3, 3);\r\n\r\n        let f: number = -1;\r\n\r\n        let lastTick = 0;\r\n        setInterval(() => {\r\n            let now = Date.now();\r\n\r\n           \r\n\r\n            if(now - lastTick >= this.updateInterval) {\r\n                //console.log()\r\n\r\n                let dt = (now - (lastTick == 0 ? now : lastTick)) / 1000;\r\n                lastTick = now;\r\n\r\n                /*\r\n                if(f == -1) {\r\n                    f = 1;\r\n                    console.log(dt)\r\n                }\r\n                */\r\n    \r\n                if(dt != 0) this.update(dt);\r\n            }\r\n\r\n           \r\n\r\n\r\n            //this.update(dt);\r\n        })\r\n    }\r\n\r\n    public start() {\r\n        console.log(`[game] start`);\r\n    }\r\n\r\n    public update(dt: number) {\r\n        //console.log(`[game] update ${dt}`);\r\n\r\n        \r\n        for (const world of this.worlds) {\r\n            world.tick(dt);   \r\n        }\r\n        \r\n    }\r\n\r\n    public createWorld(name: string) {\r\n        console.log(`[game] create world '${name}'`);\r\n\r\n        const world = new World(this);\r\n        this._worlds.set(name, world);\r\n        return world;\r\n    }\r\n}","import * as pc from 'playcanvas'\r\n\r\nexport class Input {\r\n    public static get mousePosition() { return this._mousePosition; }\r\n    public static get mouseDown() { return this._mouseDown; }\r\n\r\n    private static _keys = new Map<number, boolean>();\r\n    private static _mousePosition = new pc.Vec2(0, 0);\r\n    private static _mouseDown: boolean = false;\r\n\r\n    public static init(app: pc.Application) {\r\n        console.log(\"[input] init\");\r\n\r\n        app.keyboard.on(pc.EVENT_KEYDOWN, this.onKeyDown, this);\r\n        app.keyboard.on(pc.EVENT_KEYUP, this.onKeyUp, this);\r\n\r\n        app.mouse.on(pc.EVENT_MOUSEMOVE, this.onMouseMove, this);\r\n        app.mouse.on(pc.EVENT_MOUSEDOWN, this.onMouseDown, this);\r\n        app.mouse.on(pc.EVENT_MOUSEUP, this.onMouseUp, this);\r\n\r\n    }\r\n\r\n    private static updateMousePosition(event: MouseEvent) {\r\n        this._mousePosition.set(event.x, event.y)\r\n    }\r\n\r\n    private static onMouseMove(event: MouseEvent) {\r\n        this.updateMousePosition(event);\r\n    }\r\n\r\n    private static onMouseDown(event: MouseEvent) {\r\n        this._mouseDown = true;\r\n        this.updateMousePosition(event);\r\n    }\r\n\r\n    private static onMouseUp(event: MouseEvent) {\r\n        this._mouseDown = false;\r\n        this.updateMousePosition(event);\r\n    }\r\n\r\n    public static update(dt: number) {\r\n\r\n    }\r\n\r\n    public static getKeyDown(key: number | string) {\r\n        const keyCodes: number[] = []\r\n\r\n        if(typeof key == 'string') {\r\n            keyCodes.push(key.toLowerCase().charCodeAt(0))\r\n            keyCodes.push(key.toUpperCase().charCodeAt(0))\r\n        } else {\r\n            keyCodes.push(key)\r\n        }\r\n\r\n        for (const keyCode of keyCodes) {\r\n            const state = this._keys.get(keyCode) === true;\r\n            if(state) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private static onKeyDown(e: KeyboardEvent) {\r\n        const keyCode = parseInt(e.key);\r\n        this._keys.set(keyCode, true);\r\n    }\r\n\r\n    private static onKeyUp(e: KeyboardEvent) {\r\n        const keyCode = parseInt(e.key);\r\n        this._keys.set(keyCode, false);\r\n    }\r\n    \r\n}","import { v4 as uuidv4 } from 'uuid';\r\n\r\nexport class Item {\r\n    public get id() { return this._id; }\r\n\r\n    private _id: string = uuidv4();\r\n}\r\n\r\nexport class Tab {\r\n\r\n}\r\n\r\nexport class Inventory {\r\n\r\n    private _tabs: Tab[] = [];\r\n\r\n\r\n    constructor() {\r\n        \r\n    }\r\n\r\n    public createTab(slotsX: number, slotsY: number) {\r\n\r\n    }\r\n\r\n}\r\n\r\nexport class InventoryManager {\r\n\r\n    public createInventory(id: string) {\r\n        const inventory = new Inventory();\r\n        return inventory;\r\n    }\r\n\r\n\r\n}","//import ByteBuffer from \"bytebuffer\";\r\n\r\nexport enum PacketType {\r\n    ENTITY_DATA,\r\n    JOIN_SERVER,\r\n    SPAWN_ENTITY,\r\n    DESTROY_ENTITY,\r\n    CONTROL_ENTITY,\r\n    WEAPON_SHOT,\r\n    COMPONENT_EVENT\r\n}\r\n\r\nexport interface IPacketData_ComponentEvent {\r\n    entity: string\r\n    component: number\r\n    event: string\r\n    data: any\r\n}\r\n\r\nexport interface IPacketData_JoinServer {\r\n    id: string\r\n}\r\n\r\nexport interface IPacketData_ControlEntity {\r\n    id: string\r\n}\r\n\r\nexport interface IPacketData_SpawnEntity {\r\n    id: string\r\n    type: number\r\n    data: any\r\n}\r\n\r\nexport interface IPacketData_DestroyEntity {\r\n    id: string\r\n}\r\n\r\nexport interface IPacketData_EntityData {\r\n    id: string\r\n    d: any\r\n}\r\n\r\nexport interface Packet {\r\n    type: PacketType\r\n    data: any\r\n}\r\n\r\n/*\r\nexport class Packet {\r\n    public buffer = new ByteBuffer();\r\n    public index: string[] = [];\r\n\r\n    public writeShort(value: number) {\r\n        this.buffer.writeShort(value);\r\n        this.index.push(\"short\");\r\n    }\r\n\r\n    public writeString(value: string) {\r\n        this.buffer.writeShort(value.length);\r\n        this.buffer.writeString(value);\r\n        this.index.push(\"short - len\");\r\n        this.index.push(\"string\");\r\n    }\r\n\r\n    public writeFloat(value: number) {\r\n        this.buffer.writeFloat(value);\r\n        this.index.push(\"float\");\r\n    }\r\n\r\n    public writeDouble(value: number) {\r\n        this.buffer.writeDouble(value);\r\n        this.index.push(\"double\");\r\n    }\r\n\r\n    public readType() {\r\n        return this.buffer.readShort() as PacketType;\r\n    }\r\n\r\n    public readShort() {\r\n        return this.buffer.readShort();\r\n    }\r\n\r\n    public readFloat() {\r\n        return this.buffer.readFloat();\r\n    }\r\n\r\n    public readDouble() {\r\n        return this.buffer.readDouble();\r\n    }\r\n\r\n    public readString() {\r\n        const len = this.readShort();\r\n        return this.buffer.readUTF8String(len);\r\n    }\r\n}\r\n*/","import Matter from \"matter-js\";\r\nimport * as pc from \"playcanvas\";\r\nimport { Component } from \"./component/component\";\r\nimport { Entity } from \"./entity/entity\";\r\nimport { Game } from \"./game\";\r\nimport { EventEmitter } from \"./eventEmitter\";\r\nimport { WorldEvent } from \"./worldEvent\";\r\nimport { Gameface } from \"../client/gameface\";\r\nimport { IPacketData_ComponentEvent, PacketType } from \"./packet\";\r\nimport { Client } from \"../server/client\";\r\nimport { EntityPlayer } from \"./entity/entityPlayer\";\r\nimport { EntityChar } from \"./entity/entityChar\";\r\nimport { NPCBehaviourComponent } from \"./component/npcBehaviourComponent\";\r\nimport { PlayerComponent } from \"./component/playerComponent\";\r\nimport { EntityObject } from \"./entity/entityObject\";\r\n\r\nlet testu = 0;\r\nlet testd = 0;\r\n\r\ninterface IWorldMatter {\r\n    engine?: Matter.Engine\r\n    world?: Matter.World\r\n    runner?: Matter.Runner\r\n}\r\n\r\nexport enum WorldSyncType {\r\n    SINGLEPLAYER,\r\n    CLIENT,\r\n    HOST\r\n}\r\n\r\nexport class World {\r\n    public events: EventEmitter = new EventEmitter();\r\n\r\n    public syncType: WorldSyncType = WorldSyncType.SINGLEPLAYER;\r\n    \r\n    public matter: IWorldMatter = {}\r\n    public get entities() { return this._entities };\r\n    public get game() { return this._game; };\r\n    \r\n    private _entities: Entity[] = [];\r\n    private _game: Game;\r\n\r\n    constructor(game: Game) {\r\n        this._game = game;\r\n        \r\n        this.events.on(WorldEvent.COMPONENT_EVENT, (component: Component, event: string, broadcast: boolean, data: any, fromClient?: Client) => {\r\n            //console.log(`[world] Component event: ${event} (${fromClient ? \"has client\" : \"no client\"})`)\r\n\r\n            if(this.syncType == WorldSyncType.CLIENT) {\r\n\r\n                const packetData: IPacketData_ComponentEvent = {\r\n                    entity: component.entity.id,\r\n                    component: this.game.entityFactory.getIndexOfComponent(component),\r\n                    event: event,\r\n                    data: data\r\n                }\r\n                \r\n                Gameface.Instance.network.sendPacket(PacketType.COMPONENT_EVENT, packetData);\r\n\r\n                \r\n                console.log(\"sent to server\")\r\n\r\n            } else {\r\n\r\n                if(fromClient) {\r\n\r\n                    const packetData: IPacketData_ComponentEvent = {\r\n                        entity: component.entity.id,\r\n                        component: this.game.entityFactory.getIndexOfComponent(component),\r\n                        event: event,\r\n                        data: data\r\n                    }\r\n                    \r\n                    fromClient.sendPacket(PacketType.COMPONENT_EVENT, packetData);\r\n                }\r\n\r\n                component.onReceiveComponentEvent.apply(component, [event, data, fromClient]);\r\n            }\r\n        })\r\n    }\r\n\r\n    public init() {\r\n        console.log(`[world] init`);\r\n\r\n        try {\r\n            window['world'] = this;\r\n        } catch(e) {\r\n\r\n        }\r\n\r\n        this.initMatterWorld();\r\n\r\n        /*\r\n        var bb = new ByteBuffer();\r\n        bb.writeString(\"ayo\");\r\n        bb.flip();\r\n\r\n        console.log(bb.toBuffer())\r\n\r\n        console.log(bb.readString(2)+\" from ByteBuffer.js\");\r\n        */\r\n    }\r\n\r\n    public tick(dt: number) {\r\n        this.preupdate(dt)\r\n\r\n        //console.log(\"u..\")\r\n        Matter.Engine.update(this.matter.engine!, 16.666666666666668, this.game.fixTime);\r\n        //console.log(\"finish\")\r\n\r\n           //console.log(\"dt:\", dt * 1000, \"or\", this.matter.engine!.timing.lastDelta, \"coor\",(dt * 1000)/32)\r\n        //console.log( dt * 1000, this.game.fixTime)\r\n\r\n        this.update(dt);\r\n\r\n        this.postupdate(dt);\r\n    }\r\n\r\n    private testAttach(dt: number) {\r\n        \r\n    }\r\n\r\n\r\n    public preupdate(dt: number) {\r\n        //  this.testAttach(dt);\r\n\r\n        for(const entity of this.entities) {\r\n          entity.preupdate(dt)\r\n        }\r\n    }\r\n\r\n\r\n    public update(dt: number) {\r\n        testu++;\r\n        testd = this.matter.engine!.timing.lastDelta;\r\n\r\n        this.testAttach(dt);\r\n\r\n        for(const entity of this.entities) {\r\n          entity.update(dt)\r\n        }\r\n    }\r\n\r\n    public postupdate(dt: number) {\r\n        //this.testAttach(dt);\r\n        for(const entity of this.entities) {\r\n          entity.postupdate(dt)\r\n        }\r\n    }\r\n\r\n    private initMatterWorld() {\r\n        const engine = this.matter.engine = Matter.Engine.create();\r\n        engine.gravity.x = 0;\r\n        engine.gravity.y = 0;\r\n\r\n        const world = this.matter.world = engine.world;\r\n        \r\n        /*\r\n        const runner = this.matter.runner = Matter.Runner.create();\r\n        \r\n        Matter.Runner.run(runner, engine);\r\n        \r\n        Matter.Events.on(runner, \"beforeUpdate\", () => {\r\n            this.preupdate(engine.timing.lastDelta * 0.001);\r\n        })\r\n\r\n        Matter.Events.on(runner, \"afterUpdate\", () => {\r\n            this.update(engine.timing.lastDelta * 0.001);\r\n            this.postupdate(engine.timing.lastDelta * 0.001);\r\n        })\r\n        */\r\n       \r\n        setInterval(() => {\r\n            console.log(`${testu} updates, dt=${testd}, ${this.entities.length} entities (interv ${this.game.updateInterval}) (fixd ${this.game.fixTime})`);\r\n            testu = 0;\r\n        }, 1000)\r\n    }\r\n\r\n    private spawnEntities() {\r\n        \r\n        for (let i = 0; i < 10; i++) {\r\n            this.spawnObject()\r\n        }\r\n\r\n        for (let i = 0; i < 40; i++) {\r\n            this.spawnNpc(Math.random()*100-50, Math.random()*100-50)\r\n        }\r\n\r\n    }\r\n\r\n    public spawnObject() {\r\n        const npc = this.spawnEntity(EntityObject);\r\n    \r\n    }\r\n\r\n    public spawnPlayer() {\r\n        const player = this.spawnEntity(EntityPlayer);\r\n    }\r\n\r\n    public spawnNpc(x: number, y: number) {\r\n        let px = x != undefined ? x : 0;\r\n        let py = y != undefined ? y : 0;\r\n\r\n        const npc = this.spawnEntity(EntityChar);\r\n        npc.transform.setPosition(px, py)\r\n        npc.addComponent(new NPCBehaviourComponent());\r\n\r\n        //npc.transform.data.velX = 10;\r\n\r\n        setInterval(() => {\r\n\r\n            /*\r\n            if(npc.transform.data.velX < 3) {\r\n                npc.transform.setPosition(0, 0)\r\n                npc.transform.data.velX = 10;\r\n            }\r\n            */\r\n\r\n        }, 100)\r\n\r\n        //npc.addComponent(new NPCBehaviourComponent());\r\n        return npc;\r\n    }\r\n\r\n    public generateWorld() {\r\n        console.log(`[world] generate world`);\r\n\r\n        this.spawnEntities();\r\n    }\r\n\r\n    \r\n    \r\n    public spawnEntity(c: typeof Entity) {\r\n        const entity = new c(this);\r\n\r\n        return this.addEntity(entity);\r\n    }\r\n\r\n    public addEntity(entity: Entity) {\r\n        //console.log(`[world] add entity ${entity.constructor.name}`);\r\n        \r\n        this._entities.push(entity);\r\n        entity.init();\r\n        return entity;\r\n    }\r\n\r\n    public getEntity(id: string) {\r\n        for (const entity of this.entities) {\r\n            if(entity.id == id) return entity;\r\n        }\r\n    }\r\n}","export enum WorldEvent {\r\n    COMPONENT_EVENT = \"COMPONENT_EVENT\"\r\n}","export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as NIL } from './nil.js';\nexport { default as version } from './version.js';\nexport { default as validate } from './validate.js';\nexport { default as stringify } from './stringify.js';\nexport { default as parse } from './parse.js';","/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;","export default '00000000-0000-0000-0000-000000000000';","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify(b);\n}\n\nexport default v1;","import v35 from './v35.js';\nimport md5 from './md5.js';\nvar v3 = v35('v3', 0x30, md5);\nexport default v3;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n\nfunction version(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nexport default version;","'use strict';\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n  , length = 64\n  , map = {}\n  , seed = 0\n  , i = 0\n  , prev;\n\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n  var now = encode(+new Date());\n\n  if (now !== prev) return seed = 0, prev = now;\n  return now +'.'+ encode(seed++);\n}\n\n//\n// Map each character to its index.\n//\nfor (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\nyeast.encode = encode;\nyeast.decode = decode;\nmodule.exports = yeast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.installTimerFunctions = exports.transports = exports.Transport = exports.protocol = exports.Socket = void 0;\nconst socket_js_1 = require(\"./socket.js\");\nObject.defineProperty(exports, \"Socket\", { enumerable: true, get: function () { return socket_js_1.Socket; } });\nexports.protocol = socket_js_1.Socket.protocol;\nvar transport_js_1 = require(\"./transport.js\");\nObject.defineProperty(exports, \"Transport\", { enumerable: true, get: function () { return transport_js_1.Transport; } });\nvar index_js_1 = require(\"./transports/index.js\");\nObject.defineProperty(exports, \"transports\", { enumerable: true, get: function () { return index_js_1.transports; } });\nvar util_js_1 = require(\"./util.js\");\nObject.defineProperty(exports, \"installTimerFunctions\", { enumerable: true, get: function () { return util_js_1.installTimerFunctions; } });\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst index_js_1 = require(\"./transports/index.js\");\nconst util_js_1 = require(\"./util.js\");\nconst parseqs_1 = __importDefault(require(\"parseqs\"));\nconst parseuri_1 = __importDefault(require(\"parseuri\"));\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine.io-client:socket\"); // debug()\nclass Socket extends component_emitter_1.Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri or options\n     * @param {Object} opts - options\n     * @api public\n     */\n    constructor(uri, opts = {}) {\n        super();\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = (0, parseuri_1.default)(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = (0, parseuri_1.default)(opts.host).host;\n        }\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\"polling\", \"websocket\"];\n        this.readyState = \"\";\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024\n            },\n            transportOptions: {},\n            closeOnBeforeunload: true\n        }, opts);\n        this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\";\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = parseqs_1.default.decode(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                addEventListener(\"beforeunload\", () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                }, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\");\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} transport name\n     * @return {Transport}\n     * @api private\n     */\n    createTransport(name) {\n        debug('creating transport \"%s\"', name);\n        const query = clone(this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = engine_io_parser_1.protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port\n        });\n        debug(\"options: %j\", opts);\n        return new index_js_1.transports[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @api private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            debug(\"error while creating transport: %s\", e);\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @api private\n     */\n    setTransport(transport) {\n        debug(\"setting transport %s\", transport.name);\n        if (this.transport) {\n            debug(\"clearing existing transport %s\", this.transport.name);\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", () => {\n            this.onClose(\"transport close\");\n        });\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} transport name\n     * @api private\n     */\n    probe(name) {\n        debug('probing transport \"%s\"', name);\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            debug('probe transport \"%s\" opened', name);\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", msg => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    debug('probe transport \"%s\" pong', name);\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    debug('pausing current transport \"%s\"', this.transport.name);\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        debug(\"changing transport and sending upgrade packet\");\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    debug('probe transport \"%s\" failed', name);\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = err => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            debug('probe transport \"%s\" failed because of error: %s', name, err);\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        transport.open();\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @api private\n     */\n    onOpen() {\n        debug(\"socket open\");\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState &&\n            this.opts.upgrade &&\n            this.transport.pause) {\n            debug(\"starting upgrade probes\");\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @api private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n            debug('packet received with socket readyState \"%s\"', this.readyState);\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @api private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @api private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @api private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @api private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            debug(\"flushing %d packets in socket\", this.writeBuffer.length);\n            this.transport.send(this.writeBuffer);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = this.writeBuffer.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} message.\n     * @param {Function} callback function.\n     * @param {Object} options.\n     * @return {Socket} for chaining.\n     * @api public\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @api private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     *\n     * @api public\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            debug(\"socket closing - telling transport to close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @api private\n     */\n    onError(err) {\n        debug(\"socket error %j\", err);\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @api private\n     */\n    onClose(reason, desc) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            debug('socket close with reason: \"%s\"', reason);\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, desc);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} server upgrades\n     * @api private\n     *\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nexports.Socket = Socket;\nSocket.protocol = engine_io_parser_1.protocol;\nfunction clone(obj) {\n    const o = {};\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            o[i] = obj[i];\n        }\n    }\n    return o;\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transport = void 0;\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst util_js_1 = require(\"./util.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = (0, debug_1.default)(\"engine.io-client:transport\"); // debug()\nclass Transport extends component_emitter_1.Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} options.\n     * @api private\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.readyState = \"\";\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} str\n     * @return {Transport} for chaining\n     * @api protected\n     */\n    onError(msg, desc) {\n        const err = new Error(msg);\n        // @ts-ignore\n        err.type = \"TransportError\";\n        // @ts-ignore\n        err.description = desc;\n        super.emit(\"error\", err);\n        return this;\n    }\n    /**\n     * Opens the transport.\n     *\n     * @api public\n     */\n    open() {\n        if (\"closed\" === this.readyState || \"\" === this.readyState) {\n            this.readyState = \"opening\";\n            this.doOpen();\n        }\n        return this;\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api public\n     */\n    close() {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     * @api public\n     */\n    send(packets) {\n        if (\"open\" === this.readyState) {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n            debug(\"transport is not open, discarding packets\");\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @api protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emit(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @api protected\n     */\n    onData(data) {\n        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @api protected\n     */\n    onPacket(packet) {\n        super.emit(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @api protected\n     */\n    onClose() {\n        this.readyState = \"closed\";\n        super.emit(\"close\");\n    }\n}\nexports.Transport = Transport;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transports = void 0;\nconst polling_xhr_js_1 = require(\"./polling-xhr.js\");\nconst websocket_js_1 = require(\"./websocket.js\");\nexports.transports = {\n    websocket: websocket_js_1.WS,\n    polling: polling_xhr_js_1.XHR\n};\n","\"use strict\";\n/* global attachEvent */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Request = exports.XHR = void 0;\nconst xmlhttprequest_js_1 = __importDefault(require(\"./xmlhttprequest.js\"));\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst globalThis_js_1 = __importDefault(require(\"../globalThis.js\"));\nconst util_js_1 = require(\"../util.js\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst polling_js_1 = require(\"./polling.js\");\nconst debug = (0, debug_1.default)(\"engine.io-client:polling-xhr\"); // debug()\n/**\n * Empty function\n */\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new xmlhttprequest_js_1.default({\n        xdomain: false\n    });\n    return null != xhr.responseType;\n})();\nclass XHR extends polling_js_1.Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @api public\n     */\n    constructor(opts) {\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n            this.xs = opts.secure !== isSSL;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @api private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @api private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", err => {\n            this.onError(\"xhr post error\", err);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @api private\n     */\n    doPoll() {\n        debug(\"xhr poll\");\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", err => {\n            this.onError(\"xhr poll error\", err);\n        });\n        this.pollXhr = req;\n    }\n}\nexports.XHR = XHR;\nclass Request extends component_emitter_1.Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @api public\n     */\n    constructor(uri, opts) {\n        super();\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.async = false !== opts.async;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @api private\n     */\n    create() {\n        const opts = (0, util_js_1.pick)(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        opts.xscheme = !!this.opts.xs;\n        const xhr = (this.xhr = new xmlhttprequest_js_1.default(opts));\n        try {\n            debug(\"xhr open %s: %s\", this.method, this.uri);\n            xhr.open(this.method, this.uri, this.async);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            debug(\"xhr data %s\", this.data);\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon successful response.\n     *\n     * @api private\n     */\n    onSuccess() {\n        this.emit(\"success\");\n        this.cleanup();\n    }\n    /**\n     * Called if we have data.\n     *\n     * @api private\n     */\n    onData(data) {\n        this.emit(\"data\", data);\n        this.onSuccess();\n    }\n    /**\n     * Called upon error.\n     *\n     * @api private\n     */\n    onError(err) {\n        this.emit(\"error\", err);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @api private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @api private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.onData(data);\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @api public\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nexports.Request = Request;\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis_js_1.default ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polling = void 0;\nconst transport_js_1 = require(\"../transport.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst yeast_1 = __importDefault(require(\"yeast\"));\nconst parseqs_1 = __importDefault(require(\"parseqs\"));\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine.io-client:polling\"); // debug()\nclass Polling extends transport_js_1.Transport {\n    constructor() {\n        super(...arguments);\n        this.polling = false;\n    }\n    /**\n     * Transport name.\n     */\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @api private\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} callback upon buffers are flushed and transport is paused\n     * @api private\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            debug(\"paused\");\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                debug(\"we are currently polling - waiting to pause\");\n                total++;\n                this.once(\"pollComplete\", function () {\n                    debug(\"pre-pause polling complete\");\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                debug(\"we are currently writing - waiting to pause\");\n                total++;\n                this.once(\"drain\", function () {\n                    debug(\"pre-pause writing complete\");\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @api public\n     */\n    poll() {\n        debug(\"polling\");\n        this.polling = true;\n        this.doPoll();\n        this.emit(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @api private\n     */\n    onData(data) {\n        debug(\"polling got data %s\", data);\n        const callback = packet => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose();\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emit(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n            else {\n                debug('ignoring poll - transport state \"%s\"', this.readyState);\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @api private\n     */\n    doClose() {\n        const close = () => {\n            debug(\"writing close packet\");\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            debug(\"transport open - closing\");\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            debug(\"transport not open - deferring close\");\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} data packets\n     * @param {Function} drain callback\n     * @api private\n     */\n    write(packets) {\n        this.writable = false;\n        (0, engine_io_parser_1.encodePayload)(packets, data => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emit(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @api private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        let port = \"\";\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0, yeast_1.default)();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                (\"http\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        const encodedQuery = parseqs_1.default.encode(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n}\nexports.Polling = Polling;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultBinaryType = exports.usingBrowserWebSocket = exports.WebSocket = exports.nextTick = void 0;\nconst globalThis_js_1 = __importDefault(require(\"../globalThis.js\"));\nexports.nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return cb => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nexports.WebSocket = globalThis_js_1.default.WebSocket || globalThis_js_1.default.MozWebSocket;\nexports.usingBrowserWebSocket = true;\nexports.defaultBinaryType = \"arraybuffer\";\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WS = void 0;\nconst transport_js_1 = require(\"../transport.js\");\nconst parseqs_1 = __importDefault(require(\"parseqs\"));\nconst yeast_1 = __importDefault(require(\"yeast\"));\nconst util_js_1 = require(\"../util.js\");\nconst websocket_constructor_js_1 = require(\"./websocket-constructor.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine.io-client:websocket\"); // debug()\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends transport_js_1.Transport {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @api {Object} connection options\n     * @api public\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Transport name.\n     *\n     * @api public\n     */\n    get name() {\n        return \"websocket\";\n    }\n    /**\n     * Opens socket.\n     *\n     * @api private\n     */\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : (0, util_js_1.pick)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative\n                    ? protocols\n                        ? new websocket_constructor_js_1.WebSocket(uri, protocols)\n                        : new websocket_constructor_js_1.WebSocket(uri)\n                    : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emit(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType || websocket_constructor_js_1.defaultBinaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @api private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = this.onClose.bind(this);\n        this.ws.onmessage = ev => this.onData(ev.data);\n        this.ws.onerror = e => this.onError(\"websocket error\", e);\n    }\n    /**\n     * Writes data to socket.\n     *\n     * @param {Array} array of packets.\n     * @api private\n     */\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, data => {\n                // always create a new object (GH-437)\n                const opts = {};\n                if (!websocket_constructor_js_1.usingBrowserWebSocket) {\n                    if (packet.options) {\n                        opts.compress = packet.options.compress;\n                    }\n                    if (this.opts.perMessageDeflate) {\n                        const len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                            opts.compress = false;\n                        }\n                    }\n                }\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (websocket_constructor_js_1.usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                    else {\n                        this.ws.send(data, opts);\n                    }\n                }\n                catch (e) {\n                    debug(\"websocket closed before onclose event\");\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    (0, websocket_constructor_js_1.nextTick)(() => {\n                        this.writable = true;\n                        this.emit(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    /**\n     * Closes socket.\n     *\n     * @api private\n     */\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @api private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        let port = \"\";\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0, yeast_1.default)();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        const encodedQuery = parseqs_1.default.encode(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @api public\n     */\n    check() {\n        return (!!websocket_constructor_js_1.WebSocket &&\n            !(\"__initialize\" in websocket_constructor_js_1.WebSocket && this.name === WS.prototype.name));\n    }\n}\nexports.WS = WS;\n","\"use strict\";\n// browser shim for xmlhttprequest module\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst has_cors_1 = __importDefault(require(\"has-cors\"));\nconst globalThis_js_1 = __importDefault(require(\"../globalThis.js\"));\nfunction default_1(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || has_cors_1.default)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis_js_1.default[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\nexports.default = default_1;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.installTimerFunctions = exports.pick = void 0;\nconst globalThis_js_1 = __importDefault(require(\"./globalThis.js\"));\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\nexports.pick = pick;\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.default);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.default);\n    }\n    else {\n        obj.setTimeoutFn = setTimeout.bind(globalThis_js_1.default);\n        obj.clearTimeoutFn = clearTimeout.bind(globalThis_js_1.default);\n    }\n}\nexports.installTimerFunctions = installTimerFunctions;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\nexports.PACKET_TYPES = PACKET_TYPES;\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nexports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;\nObject.keys(PACKET_TYPES).forEach(key => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\nexports.ERROR_PACKET = ERROR_PACKET;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commons_js_1 = require(\"./commons.js\");\nconst base64_arraybuffer_1 = require(\"base64-arraybuffer\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return commons_js_1.ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: commons_js_1.PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: commons_js_1.PACKET_TYPES_REVERSE[type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = (0, base64_arraybuffer_1.decode)(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            return data instanceof ArrayBuffer ? new Blob([data]) : data;\n        case \"arraybuffer\":\n        default:\n            return data; // assuming the data is already an ArrayBuffer\n    }\n};\nexports.default = decodePacket;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commons_js_1 = require(\"./commons.js\");\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = obj => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(commons_js_1.PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + content);\n    };\n    return fileReader.readAsDataURL(data);\n};\nexports.default = encodePacket;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;\nconst encodePacket_js_1 = require(\"./encodePacket.js\");\nexports.encodePacket = encodePacket_js_1.default;\nconst decodePacket_js_1 = require(\"./decodePacket.js\");\nexports.decodePacket = decodePacket_js_1.default;\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        (0, encodePacket_js_1.default)(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nexports.encodePayload = encodePayload;\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = (0, decodePacket_js_1.default)(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nexports.decodePayload = decodePayload;\nexports.protocol = 4;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports.connect = exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;\nconst url_js_1 = require(\"./url.js\");\nconst manager_js_1 = require(\"./manager.js\");\nObject.defineProperty(exports, \"Manager\", { enumerable: true, get: function () { return manager_js_1.Manager; } });\nconst socket_js_1 = require(\"./socket.js\");\nObject.defineProperty(exports, \"Socket\", { enumerable: true, get: function () { return socket_js_1.Socket; } });\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client\"); // debug()\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url_js_1.url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        debug(\"ignoring socket cache for %s\", source);\n        io = new manager_js_1.Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            debug(\"new io instance for %s\", source);\n            cache[id] = new manager_js_1.Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\nexports.io = lookup;\nexports.connect = lookup;\nexports.default = lookup;\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager: manager_js_1.Manager,\n    Socket: socket_js_1.Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nvar socket_io_parser_1 = require(\"socket.io-parser\");\nObject.defineProperty(exports, \"protocol\", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });\n\nmodule.exports = lookup;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Manager = void 0;\nconst engine_io_client_1 = require(\"engine.io-client\");\nconst socket_js_1 = require(\"./socket.js\");\nconst parser = __importStar(require(\"socket.io-parser\"));\nconst on_js_1 = require(\"./on.js\");\nconst backo2_1 = __importDefault(require(\"backo2\"));\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:manager\"); // debug()\nclass Manager extends component_emitter_1.Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        engine_io_client_1.installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new backo2_1.default({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        debug(\"readyState %s\", this._readyState);\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        debug(\"opening %s\", this.uri);\n        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on_js_1.on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = on_js_1.on(socket, \"error\", (err) => {\n            debug(\"error\");\n            self.cleanup();\n            self._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            debug(\"connect attempt will timeout after %d\", timeout);\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                debug(\"connect attempt timed out after %d\", timeout);\n                openSubDestroy();\n                socket.close();\n                // @ts-ignore\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"open\");\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on_js_1.on(socket, \"ping\", this.onping.bind(this)), on_js_1.on(socket, \"data\", this.ondata.bind(this)), on_js_1.on(socket, \"error\", this.onerror.bind(this)), on_js_1.on(socket, \"close\", this.onclose.bind(this)), on_js_1.on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        this.decoder.add(data);\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        this.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        debug(\"error\", err);\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new socket_js_1.Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                debug(\"socket %s is still active, skipping close\", nsp);\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        debug(\"writing packet %j\", packet);\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        debug(\"cleanup\");\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        debug(\"disconnect\");\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        if (\"opening\" === this._readyState) {\n            // `onclose` will not fire because\n            // an open event never happened\n            this.cleanup();\n        }\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason) {\n        debug(\"onclose\");\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            debug(\"reconnect failed\");\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            debug(\"will wait %dms before reconnect attempt\", delay);\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                debug(\"attempting reconnect\");\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        debug(\"reconnect attempt error\");\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        debug(\"reconnect success\");\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\nexports.Manager = Manager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.on = void 0;\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\nexports.on = on;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst on_js_1 = require(\"./on.js\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:socket\"); // debug()\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\nclass Socket extends component_emitter_1.Emitter {\n    /**\n     * `Socket` constructor.\n     *\n     * @public\n     */\n    constructor(io, nsp, opts) {\n        super();\n        this.connected = false;\n        this.disconnected = true;\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on_js_1.on(io, \"open\", this.onopen.bind(this)),\n            on_js_1.on(io, \"packet\", this.onpacket.bind(this)),\n            on_js_1.on(io, \"error\", this.onerror.bind(this)),\n            on_js_1.on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @public\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for connect()\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * @return self\n     * @public\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @return self\n     * @public\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            debug(\"emitting packet with ack id %d\", this.ids);\n            this.acks[this.ids] = args.pop();\n            packet.id = this.ids++;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n            debug(\"discard packet as the transport is not currently writable\");\n        }\n        else if (this.connected) {\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"transport is open - connecting\");\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });\n            });\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });\n        }\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @private\n     */\n    onclose(reason) {\n        debug(\"close (%s)\", reason);\n        this.connected = false;\n        this.disconnected = true;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    const id = packet.data.sid;\n                    this.onconnect(id);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser_1.PacketType.CONNECT_ERROR:\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            debug(\"sending ack %j\", args);\n            self.packet({\n                type: socket_io_parser_1.PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id) {\n        debug(\"socket connected with id %s\", id);\n        this.id = id;\n        this.connected = true;\n        this.disconnected = false;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => this.packet(packet));\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"server disconnect (%s)\", this.nsp);\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually.\n     *\n     * @return self\n     * @public\n     */\n    disconnect() {\n        if (this.connected) {\n            debug(\"performing disconnect (%s)\", this.nsp);\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for disconnect()\n     *\n     * @return self\n     * @public\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     * @public\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @returns self\n     * @public\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @param listener\n     * @public\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     * @public\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @param listener\n     * @public\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     *\n     * @public\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n}\nexports.Socket = Socket;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.url = void 0;\nconst parseuri_1 = __importDefault(require(\"parseuri\"));\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:url\"); // debug()\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            debug(\"protocol-less url %s\", uri);\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        debug(\"parse %s\", uri);\n        obj = parseuri_1.default(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\nexports.url = url;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reconstructPacket = exports.deconstructPacket = void 0;\nconst is_binary_js_1 = require(\"./is-binary.js\");\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nexports.deconstructPacket = deconstructPacket;\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (is_binary_js_1.isBinary(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    packet.attachments = undefined; // no longer useful\n    return packet;\n}\nexports.reconstructPacket = reconstructPacket;\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder) {\n        return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst binary_js_1 = require(\"./binary.js\");\nconst is_binary_js_1 = require(\"./is-binary.js\");\nconst debug_1 = require(\"debug\"); // debug()\nconst debug = debug_1.default(\"socket.io-parser\"); // debug()\n/**\n * Protocol version.\n *\n * @public\n */\nexports.protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType = exports.PacketType || (exports.PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        debug(\"encoding packet %j\", obj);\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (is_binary_js_1.hasBinary(obj)) {\n                obj.type =\n                    obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK;\n                return this.encodeAsBinary(obj);\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data);\n        }\n        debug(\"encoded %j as %s\", obj, str);\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = binary_js_1.deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\nexports.Encoder = Encoder;\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends component_emitter_1.Emitter {\n    constructor() {\n        super();\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            packet = this.decodeString(obj);\n            if (packet.type === PacketType.BINARY_EVENT ||\n                packet.type === PacketType.BINARY_ACK) {\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (is_binary_js_1.isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        debug(\"decoded %s as %j\", str, p);\n        return p;\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return typeof payload === \"object\";\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || typeof payload === \"object\";\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return Array.isArray(payload) && payload.length > 0;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n        }\n    }\n}\nexports.Decoder = Decoder;\nfunction tryParse(str) {\n    try {\n        return JSON.parse(str);\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = binary_js_1.reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasBinary = exports.isBinary = void 0;\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nexports.isBinary = isBinary;\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.hasBinary = hasBinary;\n","/**\n * @license\n * PlayCanvas Engine v1.52.1 revision 0f56653b1\n * Copyright 2011-2022 PlayCanvas Ltd. All rights reserved.\n */\nif (!Array.prototype.fill) {\n\tObject.defineProperty(Array.prototype, 'fill', {\n\t\tvalue: function (value) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow new TypeError('this is null or not defined');\n\t\t\t}\n\n\t\t\tvar O = Object(this);\n\t\t\tvar len = O.length >>> 0;\n\t\t\tvar start = arguments[1];\n\t\t\tvar relativeStart = start >> 0;\n\t\t\tvar k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\t\t\tvar end = arguments[2];\n\t\t\tvar relativeEnd = end === undefined ? len : end >> 0;\n\t\t\tvar finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n\t\t\twhile (k < finalValue) {\n\t\t\t\tO[k] = value;\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\treturn O;\n\t\t}\n\t});\n}\n\nif (!Array.prototype.find) {\n\tObject.defineProperty(Array.prototype, 'find', {\n\t\tvalue: function (predicate) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError('\"this\" is null or not defined');\n\t\t\t}\n\n\t\t\tvar o = Object(this);\n\t\t\tvar len = o.length >>> 0;\n\n\t\t\tif (typeof predicate !== 'function') {\n\t\t\t\tthrow TypeError('predicate must be a function');\n\t\t\t}\n\n\t\t\tvar thisArg = arguments[1];\n\t\t\tvar k = 0;\n\n\t\t\twhile (k < len) {\n\t\t\t\tvar kValue = o[k];\n\n\t\t\t\tif (predicate.call(thisArg, kValue, k, o)) {\n\t\t\t\t\treturn kValue;\n\t\t\t\t}\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t},\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n}\n\nif (!Array.prototype.findIndex) {\n\tObject.defineProperty(Array.prototype, 'findIndex', {\n\t\tvalue: function (predicate) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow new TypeError('\"this\" is null or not defined');\n\t\t\t}\n\n\t\t\tvar o = Object(this);\n\t\t\tvar len = o.length >>> 0;\n\n\t\t\tif (typeof predicate !== 'function') {\n\t\t\t\tthrow new TypeError('predicate must be a function');\n\t\t\t}\n\n\t\t\tvar thisArg = arguments[1];\n\t\t\tvar k = 0;\n\n\t\t\twhile (k < len) {\n\t\t\t\tvar kValue = o[k];\n\n\t\t\t\tif (predicate.call(thisArg, kValue, k, o)) {\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t},\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n}\n\nMath.log2 = Math.log2 || function (x) {\n\treturn Math.log(x) * Math.LOG2E;\n};\n\nif (!Math.sign) {\n\tMath.sign = function (x) {\n\t\treturn (x > 0) - (x < 0) || +x;\n\t};\n}\n\nif (Number.isFinite === undefined) Number.isFinite = function (value) {\n\treturn typeof value === 'number' && isFinite(value);\n};\n\nif (typeof Object.assign != 'function') {\n\tObject.defineProperty(Object, \"assign\", {\n\t\tvalue: function assign(target, varArgs) {\n\n\t\t\tif (target == null) {\n\t\t\t\tthrow new TypeError('Cannot convert undefined or null to object');\n\t\t\t}\n\n\t\t\tvar to = Object(target);\n\n\t\t\tfor (var index = 1; index < arguments.length; index++) {\n\t\t\t\tvar nextSource = arguments[index];\n\n\t\t\t\tif (nextSource != null) {\n\t\t\t\t\tfor (var nextKey in nextSource) {\n\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn to;\n\t\t},\n\t\twritable: true,\n\t\tconfigurable: true\n\t});\n}\n\n(function () {\n\tif (typeof navigator === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\tnavigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;\n\n\tvar pointerlockchange = function pointerlockchange() {\n\t\tvar e = document.createEvent('CustomEvent');\n\t\te.initCustomEvent('pointerlockchange', true, false, null);\n\t\tdocument.dispatchEvent(e);\n\t};\n\n\tvar pointerlockerror = function pointerlockerror() {\n\t\tvar e = document.createEvent('CustomEvent');\n\t\te.initCustomEvent('pointerlockerror', true, false, null);\n\t\tdocument.dispatchEvent(e);\n\t};\n\n\tdocument.addEventListener('webkitpointerlockchange', pointerlockchange, false);\n\tdocument.addEventListener('webkitpointerlocklost', pointerlockchange, false);\n\tdocument.addEventListener('mozpointerlockchange', pointerlockchange, false);\n\tdocument.addEventListener('mozpointerlocklost', pointerlockchange, false);\n\tdocument.addEventListener('webkitpointerlockerror', pointerlockerror, false);\n\tdocument.addEventListener('mozpointerlockerror', pointerlockerror, false);\n\n\tif (Element.prototype.mozRequestPointerLock) {\n\t\tElement.prototype.requestPointerLock = function () {\n\t\t\tthis.mozRequestPointerLock();\n\t\t};\n\t} else {\n\t\tElement.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;\n\t}\n\n\tif (!Element.prototype.requestPointerLock && navigator.pointer) {\n\t\tElement.prototype.requestPointerLock = function () {\n\t\t\tvar el = this;\n\t\t\tdocument.pointerLockElement = el;\n\t\t\tnavigator.pointer.lock(el, pointerlockchange, pointerlockerror);\n\t\t};\n\t}\n\n\tdocument.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;\n\n\tif (!document.exitPointerLock) {\n\t\tdocument.exitPointerLock = function () {\n\t\t\tif (navigator.pointer) {\n\t\t\t\tdocument.pointerLockElement = null;\n\t\t\t\tnavigator.pointer.unlock();\n\t\t\t}\n\t\t};\n\t}\n})();\n\n(function () {\n\tif (typeof window === 'undefined') return;\n\tvar lastTime = 0;\n\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\n\tfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n\t\twindow.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n\t\twindow.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n\t}\n\n\tif (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n\t\tvar currTime = new Date().getTime();\n\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\tvar id = window.setTimeout(function () {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\t\tlastTime = currTime + timeToCall;\n\t\treturn id;\n\t};\n\tif (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n\t\tclearTimeout(id);\n\t};\n})();\n\nif (!String.prototype.endsWith) {\n\tString.prototype.endsWith = function (search, this_len) {\n\t\tif (this_len === undefined || this_len > this.length) {\n\t\t\tthis_len = this.length;\n\t\t}\n\n\t\treturn this.substring(this_len - search.length, this_len) === search;\n\t};\n}\n\nif (!String.prototype.includes) {\n\tString.prototype.includes = function (search, start) {\n\n\t\tif (typeof start !== 'number') {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif (start + search.length > this.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.indexOf(search, start) !== -1;\n\t\t}\n\t};\n}\n\nif (!String.prototype.startsWith) {\n\tString.prototype.startsWith = function (search, pos) {\n\t\treturn this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n\t};\n}\n\nif (!Int8Array.prototype.fill) {\n\tInt8Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Uint8Array.prototype.fill) {\n\tUint8Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Uint8ClampedArray.prototype.fill) {\n\tUint8ClampedArray.prototype.fill = Array.prototype.fill;\n}\n\nif (!Int16Array.prototype.fill) {\n\tInt16Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Uint16Array.prototype.fill) {\n\tUint16Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Int32Array.prototype.fill) {\n\tInt32Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Uint32Array.prototype.fill) {\n\tUint32Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Float32Array.prototype.fill) {\n\tFloat32Array.prototype.fill = Array.prototype.fill;\n}\n\nvar glErrorShadow = {};\n\nfunction error(msg) {\n\tif (window.console && window.console.error) {\n\t\twindow.console.error(msg);\n\t}\n}\n\nfunction log$1(msg) {\n\tif (window.console && window.console.log) {\n\t\twindow.console.log(msg);\n\t}\n}\n\nfunction synthesizeGLError(err, opt_msg) {\n\tglErrorShadow[err] = true;\n\n\tif (opt_msg !== undefined) {\n\t\terror(opt_msg);\n\t}\n}\n\nfunction wrapGLError(gl) {\n\tvar f = gl.getError;\n\n\tgl.getError = function () {\n\t\tvar err;\n\n\t\tdo {\n\t\t\terr = f.apply(gl);\n\n\t\t\tif (err != gl.NO_ERROR) {\n\t\t\t\tglErrorShadow[err] = true;\n\t\t\t}\n\t\t} while (err != gl.NO_ERROR);\n\n\t\tfor (var err in glErrorShadow) {\n\t\t\tif (glErrorShadow[err]) {\n\t\t\t\tdelete glErrorShadow[err];\n\t\t\t\treturn parseInt(err);\n\t\t\t}\n\t\t}\n\n\t\treturn gl.NO_ERROR;\n\t};\n}\n\nvar WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {\n\tvar gl = ext.gl;\n\tthis.ext = ext;\n\tthis.isAlive = true;\n\tthis.hasBeenBound = false;\n\tthis.elementArrayBuffer = null;\n\tthis.attribs = new Array(ext.maxVertexAttribs);\n\n\tfor (var n = 0; n < this.attribs.length; n++) {\n\t\tvar attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);\n\t\tthis.attribs[n] = attrib;\n\t}\n\n\tthis.maxAttrib = 0;\n};\n\nWebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {\n\tthis.enabled = false;\n\tthis.buffer = null;\n\tthis.size = 4;\n\tthis.type = gl.FLOAT;\n\tthis.normalized = false;\n\tthis.stride = 16;\n\tthis.offset = 0;\n\tthis.cached = \"\";\n\tthis.recache();\n};\n\nWebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {\n\tthis.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(\":\");\n};\n\nvar OESVertexArrayObject = function OESVertexArrayObject(gl) {\n\tvar self = this;\n\tthis.gl = gl;\n\twrapGLError(gl);\n\tvar original = this.original = {\n\t\tgetParameter: gl.getParameter,\n\t\tenableVertexAttribArray: gl.enableVertexAttribArray,\n\t\tdisableVertexAttribArray: gl.disableVertexAttribArray,\n\t\tbindBuffer: gl.bindBuffer,\n\t\tgetVertexAttrib: gl.getVertexAttrib,\n\t\tvertexAttribPointer: gl.vertexAttribPointer\n\t};\n\n\tgl.getParameter = function getParameter(pname) {\n\t\tif (pname == self.VERTEX_ARRAY_BINDING_OES) {\n\t\t\tif (self.currentVertexArrayObject == self.defaultVertexArrayObject) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn self.currentVertexArrayObject;\n\t\t\t}\n\t\t}\n\n\t\treturn original.getParameter.apply(this, arguments);\n\t};\n\n\tgl.enableVertexAttribArray = function enableVertexAttribArray(index) {\n\t\tvar vao = self.currentVertexArrayObject;\n\t\tvao.maxAttrib = Math.max(vao.maxAttrib, index);\n\t\tvar attrib = vao.attribs[index];\n\t\tattrib.enabled = true;\n\t\treturn original.enableVertexAttribArray.apply(this, arguments);\n\t};\n\n\tgl.disableVertexAttribArray = function disableVertexAttribArray(index) {\n\t\tvar vao = self.currentVertexArrayObject;\n\t\tvao.maxAttrib = Math.max(vao.maxAttrib, index);\n\t\tvar attrib = vao.attribs[index];\n\t\tattrib.enabled = false;\n\t\treturn original.disableVertexAttribArray.apply(this, arguments);\n\t};\n\n\tgl.bindBuffer = function bindBuffer(target, buffer) {\n\t\tswitch (target) {\n\t\t\tcase gl.ARRAY_BUFFER:\n\t\t\t\tself.currentArrayBuffer = buffer;\n\t\t\t\tbreak;\n\n\t\t\tcase gl.ELEMENT_ARRAY_BUFFER:\n\t\t\t\tself.currentVertexArrayObject.elementArrayBuffer = buffer;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn original.bindBuffer.apply(this, arguments);\n\t};\n\n\tgl.getVertexAttrib = function getVertexAttrib(index, pname) {\n\t\tvar vao = self.currentVertexArrayObject;\n\t\tvar attrib = vao.attribs[index];\n\n\t\tswitch (pname) {\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:\n\t\t\t\treturn attrib.buffer;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_ENABLED:\n\t\t\t\treturn attrib.enabled;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_SIZE:\n\t\t\t\treturn attrib.size;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_STRIDE:\n\t\t\t\treturn attrib.stride;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_TYPE:\n\t\t\t\treturn attrib.type;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:\n\t\t\t\treturn attrib.normalized;\n\n\t\t\tdefault:\n\t\t\t\treturn original.getVertexAttrib.apply(this, arguments);\n\t\t}\n\t};\n\n\tgl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {\n\t\tvar vao = self.currentVertexArrayObject;\n\t\tvao.maxAttrib = Math.max(vao.maxAttrib, indx);\n\t\tvar attrib = vao.attribs[indx];\n\t\tattrib.buffer = self.currentArrayBuffer;\n\t\tattrib.size = size;\n\t\tattrib.type = type;\n\t\tattrib.normalized = normalized;\n\t\tattrib.stride = stride;\n\t\tattrib.offset = offset;\n\t\tattrib.recache();\n\t\treturn original.vertexAttribPointer.apply(this, arguments);\n\t};\n\n\tif (gl.instrumentExtension) {\n\t\tgl.instrumentExtension(this, \"OES_vertex_array_object\");\n\t}\n\n\tgl.canvas.addEventListener('webglcontextrestored', function () {\n\t\tlog$1(\"OESVertexArrayObject emulation library context restored\");\n\t\tself.reset_();\n\t}, true);\n\tthis.reset_();\n};\n\nOESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;\n\nOESVertexArrayObject.prototype.reset_ = function reset_() {\n\tvar contextWasLost = this.vertexArrayObjects !== undefined;\n\n\tif (contextWasLost) {\n\t\tfor (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {\n\t\t\tthis.vertexArrayObjects.isAlive = false;\n\t\t}\n\t}\n\n\tvar gl = this.gl;\n\tthis.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\tthis.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);\n\tthis.currentVertexArrayObject = null;\n\tthis.currentArrayBuffer = null;\n\tthis.vertexArrayObjects = [this.defaultVertexArrayObject];\n\tthis.bindVertexArrayOES(null);\n};\n\nOESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {\n\tvar arrayObject = new WebGLVertexArrayObjectOES(this);\n\tthis.vertexArrayObjects.push(arrayObject);\n\treturn arrayObject;\n};\n\nOESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {\n\tarrayObject.isAlive = false;\n\tthis.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);\n\n\tif (this.currentVertexArrayObject == arrayObject) {\n\t\tthis.bindVertexArrayOES(null);\n\t}\n};\n\nOESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {\n\tif (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {\n\t\tif (arrayObject.hasBeenBound && arrayObject.ext == this) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nOESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {\n\tvar gl = this.gl;\n\n\tif (arrayObject && !arrayObject.isAlive) {\n\t\tsynthesizeGLError(gl.INVALID_OPERATION, \"bindVertexArrayOES: attempt to bind deleted arrayObject\");\n\t\treturn;\n\t}\n\n\tvar original = this.original;\n\tvar oldVAO = this.currentVertexArrayObject;\n\tthis.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;\n\tthis.currentVertexArrayObject.hasBeenBound = true;\n\tvar newVAO = this.currentVertexArrayObject;\n\n\tif (oldVAO == newVAO) {\n\t\treturn;\n\t}\n\n\tif (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {\n\t\toriginal.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);\n\t}\n\n\tvar currentBinding = this.currentArrayBuffer;\n\tvar maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);\n\n\tfor (var n = 0; n <= maxAttrib; n++) {\n\t\tvar attrib = newVAO.attribs[n];\n\t\tvar oldAttrib = oldVAO ? oldVAO.attribs[n] : null;\n\n\t\tif (!oldVAO || attrib.enabled != oldAttrib.enabled) {\n\t\t\tif (attrib.enabled) {\n\t\t\t\toriginal.enableVertexAttribArray.call(gl, n);\n\t\t\t} else {\n\t\t\t\toriginal.disableVertexAttribArray.call(gl, n);\n\t\t\t}\n\t\t}\n\n\t\tif (attrib.enabled) {\n\t\t\tvar bufferChanged = false;\n\n\t\t\tif (!oldVAO || attrib.buffer != oldAttrib.buffer) {\n\t\t\t\tif (currentBinding != attrib.buffer) {\n\t\t\t\t\toriginal.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);\n\t\t\t\t\tcurrentBinding = attrib.buffer;\n\t\t\t\t}\n\n\t\t\t\tbufferChanged = true;\n\t\t\t}\n\n\t\t\tif (bufferChanged || attrib.cached != oldAttrib.cached) {\n\t\t\t\toriginal.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.currentArrayBuffer != currentBinding) {\n\t\toriginal.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);\n\t}\n};\n\nconst setupVertexArrayObject = function setupVertexArrayObject(gl) {\n\tif (gl.getSupportedExtensions) {\n\t\tvar exts = gl.getSupportedExtensions();\n\n\t\tif (exts.indexOf(\"OES_vertex_array_object\") != -1) {\n\t\t\treturn;\n\t\t}\n\t} else if (gl.getExtension) {\n\t\tvar vao = gl.getExtension(\"OES_vertex_array_object\");\n\n\t\tif (vao) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (gl.getSupportedExtensions) {\n\t\tvar original_getSupportedExtensions = gl.getSupportedExtensions;\n\n\t\tgl.getSupportedExtensions = function getSupportedExtensions() {\n\t\t\tvar list = original_getSupportedExtensions.call(this) || [];\n\t\t\tlist.push(\"OES_vertex_array_object\");\n\t\t\treturn list;\n\t\t};\n\t}\n\n\tvar original_getExtension = gl.getExtension;\n\n\tgl.getExtension = function getExtension(name) {\n\t\tif (name == \"OES_vertex_array_object\") {\n\t\t\tif (!gl.__OESVertexArrayObject) {\n\t\t\t\tgl.__OESVertexArrayObject = new OESVertexArrayObject(gl);\n\t\t\t}\n\n\t\t\treturn gl.__OESVertexArrayObject;\n\t\t}\n\n\t\tif (original_getExtension) {\n\t\t\treturn original_getExtension.call(this, name);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n};\n\nconst version = \"1.52.1\";\nconst revision = \"0f56653b1\";\nconst config = {};\nconst common = {};\nconst apps = {};\nconst data = {};\n\nconst _typeLookup = function () {\n\tconst result = {};\n\tconst names = [\"Array\", \"Object\", \"Function\", \"Date\", \"RegExp\", \"Float32Array\"];\n\n\tfor (let i = 0; i < names.length; i++) result[\"[object \" + names[i] + \"]\"] = names[i].toLowerCase();\n\n\treturn result;\n}();\n\nfunction type(obj) {\n\tif (obj === null) {\n\t\treturn \"null\";\n\t}\n\n\tconst type = typeof obj;\n\n\tif (type === \"undefined\" || type === \"number\" || type === \"string\" || type === \"boolean\") {\n\t\treturn type;\n\t}\n\n\treturn _typeLookup[Object.prototype.toString.call(obj)];\n}\n\nfunction extend(target, ex) {\n\tfor (const prop in ex) {\n\t\tconst copy = ex[prop];\n\n\t\tif (type(copy) === \"object\") {\n\t\t\ttarget[prop] = extend({}, copy);\n\t\t} else if (type(copy) === \"array\") {\n\t\t\ttarget[prop] = extend([], copy);\n\t\t} else {\n\t\t\ttarget[prop] = copy;\n\t\t}\n\t}\n\n\treturn target;\n}\n\nfunction isDefined(o) {\n\tlet a;\n\treturn o !== a;\n}\n\nclass EventHandler {\n\tconstructor() {\n\t\tthis._callbacks = {};\n\t\tthis._callbackActive = {};\n\t}\n\n\tinitEventHandler() {\n\t\tthis._callbacks = {};\n\t\tthis._callbackActive = {};\n\t}\n\n\t_addCallback(name, callback, scope, once = false) {\n\t\tif (!name || typeof name !== 'string' || !callback) return;\n\t\tif (!this._callbacks[name]) this._callbacks[name] = [];\n\t\tif (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n\n\t\tthis._callbacks[name].push({\n\t\t\tcallback: callback,\n\t\t\tscope: scope || this,\n\t\t\tonce: once\n\t\t});\n\t}\n\n\ton(name, callback, scope) {\n\t\tthis._addCallback(name, callback, scope, false);\n\n\t\treturn this;\n\t}\n\n\toff(name, callback, scope) {\n\t\tif (name) {\n\t\t\tif (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n\t\t} else {\n\t\t\tfor (const key in this._callbackActive) {\n\t\t\t\tif (!this._callbacks[key]) continue;\n\t\t\t\tif (this._callbacks[key] !== this._callbackActive[key]) continue;\n\t\t\t\tthis._callbackActive[key] = this._callbackActive[key].slice();\n\t\t\t}\n\t\t}\n\n\t\tif (!name) {\n\t\t\tthis._callbacks = {};\n\t\t} else if (!callback) {\n\t\t\tif (this._callbacks[name]) this._callbacks[name] = [];\n\t\t} else {\n\t\t\tconst events = this._callbacks[name];\n\t\t\tif (!events) return this;\n\t\t\tlet count = events.length;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tif (events[i].callback !== callback) continue;\n\t\t\t\tif (scope && events[i].scope !== scope) continue;\n\t\t\t\tevents[i--] = events[--count];\n\t\t\t}\n\n\t\t\tevents.length = count;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n\t\tif (!name || !this._callbacks[name]) return this;\n\t\tlet callbacks;\n\n\t\tif (!this._callbackActive[name]) {\n\t\t\tthis._callbackActive[name] = this._callbacks[name];\n\t\t} else {\n\t\t\tif (this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n\t\t\tcallbacks = this._callbacks[name].slice();\n\t\t}\n\n\t\tfor (let i = 0; (callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length; i++) {\n\t\t\tconst evt = (callbacks || this._callbackActive[name])[i];\n\t\t\tevt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n\n\t\t\tif (evt.once) {\n\t\t\t\tconst existingCallback = this._callbacks[name];\n\t\t\t\tconst ind = existingCallback ? existingCallback.indexOf(evt) : -1;\n\n\t\t\t\tif (ind !== -1) {\n\t\t\t\t\tif (this._callbackActive[name] === existingCallback) this._callbackActive[name] = this._callbackActive[name].slice();\n\n\t\t\t\t\tthis._callbacks[name].splice(ind, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!callbacks) this._callbackActive[name] = null;\n\t\treturn this;\n\t}\n\n\tonce(name, callback, scope) {\n\t\tthis._addCallback(name, callback, scope, true);\n\n\t\treturn this;\n\t}\n\n\thasEvent(name) {\n\t\treturn this._callbacks[name] && this._callbacks[name].length !== 0 || false;\n\t}\n\n}\n\nconst events = {\n\tattach: function (target) {\n\t\tconst ev = events;\n\t\ttarget._addCallback = ev._addCallback;\n\t\ttarget.on = ev.on;\n\t\ttarget.off = ev.off;\n\t\ttarget.fire = ev.fire;\n\t\ttarget.once = ev.once;\n\t\ttarget.hasEvent = ev.hasEvent;\n\t\ttarget._callbacks = {};\n\t\ttarget._callbackActive = {};\n\t\treturn target;\n\t},\n\t_addCallback: EventHandler.prototype._addCallback,\n\ton: EventHandler.prototype.on,\n\toff: EventHandler.prototype.off,\n\tfire: EventHandler.prototype.fire,\n\tonce: EventHandler.prototype.once,\n\thasEvent: EventHandler.prototype.hasEvent\n};\n\nconst guid = {\n\tcreate: function () {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t\t\tconst r = Math.random() * 16 | 0;\n\t\t\tconst v = c === 'x' ? r : r & 0x3 | 0x8;\n\t\t\treturn v.toString(16);\n\t\t});\n\t}\n};\n\nconst path = {\n\tdelimiter: \"/\",\n\tjoin: function () {\n\t\tconst num = arguments.length;\n\t\tlet result = arguments[0];\n\n\t\tfor (let index = 0; index < num - 1; ++index) {\n\t\t\tconst one = arguments[index];\n\t\t\tconst two = arguments[index + 1];\n\n\t\t\tif (!isDefined(one) || !isDefined(two)) {\n\t\t\t\tthrow new Error(\"undefined argument to pc.path.join\");\n\t\t\t}\n\n\t\t\tif (two[0] === path.delimiter) {\n\t\t\t\tresult = two;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {\n\t\t\t\tresult += path.delimiter + two;\n\t\t\t} else {\n\t\t\t\tresult += two;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\tnormalize: function (pathname) {\n\t\tconst lead = pathname.startsWith(path.delimiter);\n\t\tconst trail = pathname.endsWith(path.delimiter);\n\t\tconst parts = pathname.split('/');\n\t\tlet result = '';\n\t\tlet cleaned = [];\n\n\t\tfor (let i = 0; i < parts.length; i++) {\n\t\t\tif (parts[i] === '') continue;\n\t\t\tif (parts[i] === '.') continue;\n\n\t\t\tif (parts[i] === '..' && cleaned.length > 0) {\n\t\t\t\tcleaned = cleaned.slice(0, cleaned.length - 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (i > 0) cleaned.push(path.delimiter);\n\t\t\tcleaned.push(parts[i]);\n\t\t}\n\n\t\tresult = cleaned.join('');\n\n\t\tif (!lead && result[0] === path.delimiter) {\n\t\t\tresult = result.slice(1);\n\t\t}\n\n\t\tif (trail && result[result.length - 1] !== path.delimiter) {\n\t\t\tresult += path.delimiter;\n\t\t}\n\n\t\treturn result;\n\t},\n\tsplit: function (pathname) {\n\t\tconst parts = pathname.split(path.delimiter);\n\t\tconst tail = parts.slice(parts.length - 1)[0];\n\t\tconst head = parts.slice(0, parts.length - 1).join(path.delimiter);\n\t\treturn [head, tail];\n\t},\n\tgetBasename: function (pathname) {\n\t\treturn path.split(pathname)[1];\n\t},\n\tgetDirectory: function (pathname) {\n\t\tconst parts = pathname.split(path.delimiter);\n\t\treturn parts.slice(0, parts.length - 1).join(path.delimiter);\n\t},\n\tgetExtension: function (pathname) {\n\t\tconst ext = pathname.split('?')[0].split('.').pop();\n\n\t\tif (ext !== pathname) {\n\t\t\treturn \".\" + ext;\n\t\t}\n\n\t\treturn \"\";\n\t},\n\tisRelativePath: function (pathname) {\n\t\treturn pathname.charAt(0) !== \"/\" && pathname.match(/:\\/\\//) === null;\n\t},\n\textractPath: function (pathname) {\n\t\tlet result = \"\";\n\t\tconst parts = pathname.split(\"/\");\n\t\tlet i = 0;\n\n\t\tif (parts.length > 1) {\n\t\t\tif (path.isRelativePath(pathname)) {\n\t\t\t\tif (parts[0] === \".\") {\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += i === 0 ? parts[i] : \"/\" + parts[i];\n\t\t\t\t\t}\n\t\t\t\t} else if (parts[0] === \"..\") {\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += i === 0 ? parts[i] : \"/\" + parts[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult = \".\";\n\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += \"/\" + parts[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\tresult += i === 0 ? parts[i] : \"/\" + parts[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nlet desktop = false;\nlet mobile = false;\nlet windows = false;\nlet xbox = false;\nlet android = false;\nlet ios = false;\nlet touch = false;\nlet gamepads = false;\nlet workers = false;\nlet passiveEvents = false;\n\nif (typeof navigator !== 'undefined') {\n\tconst ua = navigator.userAgent;\n\tif (/(windows|mac os|linux|cros)/i.test(ua)) desktop = true;\n\tif (/xbox/i.test(ua)) xbox = true;\n\n\tif (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {\n\t\tdesktop = false;\n\t\tmobile = true;\n\t\twindows = true;\n\t} else if (/android/i.test(ua)) {\n\t\tdesktop = false;\n\t\tmobile = true;\n\t\tandroid = true;\n\t} else if (/ip([ao]d|hone)/i.test(ua)) {\n\t\tdesktop = false;\n\t\tmobile = true;\n\t\tios = true;\n\t}\n\n\tif (typeof window !== 'undefined') {\n\t\ttouch = 'ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0;\n\t}\n\n\tgamepads = 'getGamepads' in navigator;\n\tworkers = typeof Worker !== 'undefined';\n\n\ttry {\n\t\tconst opts = Object.defineProperty({}, 'passive', {\n\t\t\tget: function () {\n\t\t\t\tpassiveEvents = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener(\"testpassive\", null, opts);\n\t\twindow.removeEventListener(\"testpassive\", null, opts);\n\t} catch (e) {}\n}\n\nconst environment = typeof window !== 'undefined' ? 'browser' : 'node';\nconst platform = {\n\tenvironment: environment,\n\tglobal: environment === 'browser' ? window : global,\n\tbrowser: environment === 'browser',\n\tdesktop: desktop,\n\tmobile: mobile,\n\tios: ios,\n\tandroid: android,\n\twindows: windows,\n\txbox: xbox,\n\tgamepads: gamepads,\n\ttouch: touch,\n\tworkers: workers,\n\tpassiveEvents: passiveEvents\n};\n\nconst ASCII_LOWERCASE = \"abcdefghijklmnopqrstuvwxyz\";\nconst ASCII_UPPERCASE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;\nconst HIGH_SURROGATE_BEGIN = 0xD800;\nconst HIGH_SURROGATE_END = 0xDBFF;\nconst LOW_SURROGATE_BEGIN = 0xDC00;\nconst LOW_SURROGATE_END = 0xDFFF;\nconst ZERO_WIDTH_JOINER = 0x200D;\nconst REGIONAL_INDICATOR_BEGIN = 0x1F1E6;\nconst REGIONAL_INDICATOR_END = 0x1F1FF;\nconst FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;\nconst FITZPATRICK_MODIFIER_END = 0x1F3FF;\nconst DIACRITICAL_MARKS_BEGIN = 0x20D0;\nconst DIACRITICAL_MARKS_END = 0x20FF;\nconst VARIATION_MODIFIER_BEGIN = 0xFE00;\nconst VARIATION_MODIFIER_END = 0xFE0F;\n\nfunction getCodePointData(string, i = 0) {\n\tconst size = string.length;\n\n\tif (i < 0 || i >= size) {\n\t\treturn null;\n\t}\n\n\tconst first = string.charCodeAt(i);\n\n\tif (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {\n\t\tconst second = string.charCodeAt(i + 1);\n\n\t\tif (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {\n\t\t\treturn {\n\t\t\t\tcode: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,\n\t\t\t\tlong: true\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\tcode: first,\n\t\tlong: false\n\t};\n}\n\nfunction isCodeBetween(string, begin, end) {\n\tif (!string) return false;\n\tconst codeData = getCodePointData(string);\n\n\tif (codeData) {\n\t\tconst code = codeData.code;\n\t\treturn code >= begin && code <= end;\n\t}\n\n\treturn false;\n}\n\nfunction numCharsToTakeForNextSymbol(string, index) {\n\tif (index === string.length - 1) {\n\t\treturn 1;\n\t}\n\n\tif (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {\n\t\tconst first = string.substring(index, index + 2);\n\t\tconst second = string.substring(index + 2, index + 4);\n\n\t\tif (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {\n\t\t\treturn 4;\n\t\t}\n\n\t\tif (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 2;\n\t}\n\n\tif (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\treturn 2;\n\t}\n\n\treturn 1;\n}\n\nconst string = {\n\tASCII_LOWERCASE: ASCII_LOWERCASE,\n\tASCII_UPPERCASE: ASCII_UPPERCASE,\n\tASCII_LETTERS: ASCII_LETTERS,\n\tformat: function (s) {\n\t\tfor (let i = 1; i < arguments.length; i++) {\n\t\t\ts = s.replace('{' + (i - 1) + '}', arguments[i]);\n\t\t}\n\n\t\treturn s;\n\t},\n\ttoBool: function (s, strict = false) {\n\t\tif (s === 'true') {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (strict) {\n\t\t\tif (s === 'false') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthrow new TypeError('Not a boolean string');\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetCodePoint: function (string, i) {\n\t\tconst codePointData = getCodePointData(string, i);\n\t\treturn codePointData && codePointData.code;\n\t},\n\tgetCodePoints: function (string) {\n\t\tif (typeof string !== 'string') {\n\t\t\tthrow new TypeError('Not a string');\n\t\t}\n\n\t\tlet i = 0;\n\t\tconst arr = [];\n\t\tlet codePoint;\n\n\t\twhile (!!(codePoint = getCodePointData(string, i))) {\n\t\t\tarr.push(codePoint.code);\n\t\t\ti += codePoint.long ? 2 : 1;\n\t\t}\n\n\t\treturn arr;\n\t},\n\tgetSymbols: function (string) {\n\t\tif (typeof string !== 'string') {\n\t\t\tthrow new TypeError('Not a string');\n\t\t}\n\n\t\tlet index = 0;\n\t\tconst length = string.length;\n\t\tconst output = [];\n\t\tlet take = 0;\n\t\tlet ch;\n\n\t\twhile (index < length) {\n\t\t\ttake += numCharsToTakeForNextSymbol(string, index + take);\n\t\t\tch = string[index + take];\n\n\t\t\tif (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {\n\t\t\t\tch = string[index + take++];\n\t\t\t}\n\n\t\t\tif (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\t\t\tch = string[index + take++];\n\t\t\t}\n\n\t\t\tif (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {\n\t\t\t\tch = string[index + take++];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst char = string.substring(index, index + take);\n\t\t\toutput.push(char);\n\t\t\tindex += take;\n\t\t\ttake = 0;\n\t\t}\n\n\t\treturn output;\n\t},\n\tfromCodePoint: function () {\n\t\tconst chars = [];\n\t\tlet current;\n\t\tlet codePoint;\n\t\tlet units;\n\n\t\tfor (let i = 0; i < arguments.length; ++i) {\n\t\t\tcurrent = Number(arguments[i]);\n\t\t\tcodePoint = current - 0x10000;\n\t\t\tunits = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];\n\t\t\tchars.push(String.fromCharCode.apply(null, units));\n\t\t}\n\n\t\treturn chars.join('');\n\t}\n};\n\nclass IndexedList {\n\tconstructor() {\n\t\tthis._list = [];\n\t\tthis._index = {};\n\t}\n\n\tpush(key, item) {\n\t\tif (this._index[key]) {\n\t\t\tthrow Error(\"Key already in index \" + key);\n\t\t}\n\n\t\tconst location = this._list.push(item) - 1;\n\t\tthis._index[key] = location;\n\t}\n\n\thas(key) {\n\t\treturn this._index[key] !== undefined;\n\t}\n\n\tget(key) {\n\t\tconst location = this._index[key];\n\n\t\tif (location !== undefined) {\n\t\t\treturn this._list[location];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tremove(key) {\n\t\tconst location = this._index[key];\n\n\t\tif (location !== undefined) {\n\t\t\tthis._list.splice(location, 1);\n\n\t\t\tdelete this._index[key];\n\n\t\t\tfor (key in this._index) {\n\t\t\t\tconst idx = this._index[key];\n\n\t\t\t\tif (idx > location) {\n\t\t\t\t\tthis._index[key] = idx - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlist() {\n\t\treturn this._list;\n\t}\n\n\tclear() {\n\t\tthis._list.length = 0;\n\n\t\tfor (const prop in this._index) {\n\t\t\tdelete this._index[prop];\n\t\t}\n\t}\n\n}\n\nclass ReadStream {\n\tconstructor(arraybuffer) {\n\t\tthis.arraybuffer = arraybuffer;\n\t\tthis.dataView = new DataView(arraybuffer);\n\t\tthis.offset = 0;\n\t\tthis.stack = [];\n\t}\n\n\tget remainingBytes() {\n\t\treturn this.dataView.byteLength - this.offset;\n\t}\n\n\treset(offset = 0) {\n\t\tthis.offset = offset;\n\t}\n\n\tskip(bytes) {\n\t\tthis.offset += bytes;\n\t}\n\n\talign(bytes) {\n\t\tthis.offset = this.offset + bytes - 1 & ~(bytes - 1);\n\t}\n\n\t_inc(amount) {\n\t\tthis.offset += amount;\n\t\treturn this.offset - amount;\n\t}\n\n\treadChar() {\n\t\treturn String.fromCharCode(this.dataView.getUint8(this.offset++));\n\t}\n\n\treadChars(numChars) {\n\t\tlet result = '';\n\n\t\tfor (let i = 0; i < numChars; ++i) {\n\t\t\tresult += this.readChar();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\treadU8() {\n\t\treturn this.dataView.getUint8(this.offset++);\n\t}\n\n\treadU16() {\n\t\treturn this.dataView.getUint16(this._inc(2), true);\n\t}\n\n\treadU32() {\n\t\treturn this.dataView.getUint32(this._inc(4), true);\n\t}\n\n\treadU64() {\n\t\treturn this.readU32() + 2 ** 32 * this.readU32();\n\t}\n\n\treadU32be() {\n\t\treturn this.dataView.getUint32(this._inc(4), false);\n\t}\n\n\treadArray(result) {\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = this.readU8();\n\t\t}\n\t}\n\n\treadLine() {\n\t\tconst view = this.dataView;\n\t\tlet result = \"\";\n\n\t\twhile (true) {\n\t\t\tif (this.offset >= view.byteLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst c = String.fromCharCode(this.readU8());\n\n\t\t\tif (c === '\\n') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult += c;\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\nclass SortedLoopArray {\n\tconstructor(args) {\n\t\tthis.items = [];\n\t\tthis.length = 0;\n\t\tthis.loopIndex = -1;\n\t\tthis._sortBy = args.sortBy;\n\t\tthis._sortHandler = this._doSort.bind(this);\n\t}\n\n\t_binarySearch(item) {\n\t\tlet left = 0;\n\t\tlet right = this.items.length - 1;\n\t\tconst search = item[this._sortBy];\n\t\tlet middle;\n\t\tlet current;\n\n\t\twhile (left <= right) {\n\t\t\tmiddle = Math.floor((left + right) / 2);\n\t\t\tcurrent = this.items[middle][this._sortBy];\n\n\t\t\tif (current <= search) {\n\t\t\t\tleft = middle + 1;\n\t\t\t} else if (current > search) {\n\t\t\t\tright = middle - 1;\n\t\t\t}\n\t\t}\n\n\t\treturn left;\n\t}\n\n\t_doSort(a, b) {\n\t\tconst sortBy = this._sortBy;\n\t\treturn a[sortBy] - b[sortBy];\n\t}\n\n\tinsert(item) {\n\t\tconst index = this._binarySearch(item);\n\n\t\tthis.items.splice(index, 0, item);\n\t\tthis.length++;\n\n\t\tif (this.loopIndex >= index) {\n\t\t\tthis.loopIndex++;\n\t\t}\n\t}\n\n\tappend(item) {\n\t\tthis.items.push(item);\n\t\tthis.length++;\n\t}\n\n\tremove(item) {\n\t\tconst idx = this.items.indexOf(item);\n\t\tif (idx < 0) return;\n\t\tthis.items.splice(idx, 1);\n\t\tthis.length--;\n\n\t\tif (this.loopIndex >= idx) {\n\t\t\tthis.loopIndex--;\n\t\t}\n\t}\n\n\tsort() {\n\t\tconst current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;\n\t\tthis.items.sort(this._sortHandler);\n\n\t\tif (current !== null) {\n\t\t\tthis.loopIndex = this.items.indexOf(current);\n\t\t}\n\t}\n\n}\n\nclass Tags extends EventHandler {\n\tconstructor(parent) {\n\t\tsuper();\n\t\tthis._index = {};\n\t\tthis._list = [];\n\t\tthis._parent = parent;\n\t}\n\n\tadd() {\n\t\tlet changed = false;\n\n\t\tconst tags = this._processArguments(arguments, true);\n\n\t\tif (!tags.length) return changed;\n\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (this._index[tags[i]]) continue;\n\t\t\tchanged = true;\n\t\t\tthis._index[tags[i]] = true;\n\n\t\t\tthis._list.push(tags[i]);\n\n\t\t\tthis.fire('add', tags[i], this._parent);\n\t\t}\n\n\t\tif (changed) this.fire('change', this._parent);\n\t\treturn changed;\n\t}\n\n\tremove() {\n\t\tlet changed = false;\n\t\tif (!this._list.length) return changed;\n\n\t\tconst tags = this._processArguments(arguments, true);\n\n\t\tif (!tags.length) return changed;\n\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (!this._index[tags[i]]) continue;\n\t\t\tchanged = true;\n\t\t\tdelete this._index[tags[i]];\n\n\t\t\tthis._list.splice(this._list.indexOf(tags[i]), 1);\n\n\t\t\tthis.fire('remove', tags[i], this._parent);\n\t\t}\n\n\t\tif (changed) this.fire('change', this._parent);\n\t\treturn changed;\n\t}\n\n\tclear() {\n\t\tif (!this._list.length) return;\n\n\t\tconst tags = this._list.slice(0);\n\n\t\tthis._list = [];\n\t\tthis._index = {};\n\n\t\tfor (let i = 0; i < tags.length; i++) this.fire('remove', tags[i], this._parent);\n\n\t\tthis.fire('change', this._parent);\n\t}\n\n\thas() {\n\t\tif (!this._list.length) return false;\n\t\treturn this._has(this._processArguments(arguments));\n\t}\n\n\t_has(tags) {\n\t\tif (!this._list.length || !tags.length) return false;\n\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (tags[i].length === 1) {\n\t\t\t\tif (this._index[tags[i][0]]) return true;\n\t\t\t} else {\n\t\t\t\tlet multiple = true;\n\n\t\t\t\tfor (let t = 0; t < tags[i].length; t++) {\n\t\t\t\t\tif (this._index[tags[i][t]]) continue;\n\t\t\t\t\tmultiple = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (multiple) return true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlist() {\n\t\treturn this._list.slice(0);\n\t}\n\n\t_processArguments(args, flat) {\n\t\tconst tags = [];\n\t\tlet tmp = [];\n\t\tif (!args || !args.length) return tags;\n\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tif (args[i] instanceof Array) {\n\t\t\t\tif (!flat) tmp = [];\n\n\t\t\t\tfor (let t = 0; t < args[i].length; t++) {\n\t\t\t\t\tif (typeof args[i][t] !== 'string') continue;\n\n\t\t\t\t\tif (flat) {\n\t\t\t\t\t\ttags.push(args[i][t]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp.push(args[i][t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!flat && tmp.length) tags.push(tmp);\n\t\t\t} else if (typeof args[i] === 'string') {\n\t\t\t\tif (flat) {\n\t\t\t\t\ttags.push(args[i]);\n\t\t\t\t} else {\n\t\t\t\t\ttags.push([args[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tags;\n\t}\n\n\tget size() {\n\t\treturn this._list.length;\n\t}\n\n}\n\nconst now = typeof window !== 'undefined' && window.performance && window.performance.now && window.performance.timing ? function () {\n\treturn window.performance.now();\n} : Date.now;\n\nclass Timer {\n\tconstructor() {\n\t\tthis._isRunning = false;\n\t\tthis._a = 0;\n\t\tthis._b = 0;\n\t}\n\n\tstart() {\n\t\tthis._isRunning = true;\n\t\tthis._a = now();\n\t}\n\n\tstop() {\n\t\tthis._isRunning = false;\n\t\tthis._b = now();\n\t}\n\n\tgetMilliseconds() {\n\t\treturn this._b - this._a;\n\t}\n\n}\n\nfunction createURI(options) {\n\tlet s = \"\";\n\n\tif ((options.authority || options.scheme) && (options.host || options.hostpath)) {\n\t\tthrow new Error(\"Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option\");\n\t}\n\n\tif (options.host && options.hostpath) {\n\t\tthrow new Error(\"Can't have 'host' and 'hostpath' option\");\n\t}\n\n\tif (options.path && options.hostpath) {\n\t\tthrow new Error(\"Can't have 'path' and 'hostpath' option\");\n\t}\n\n\tif (options.scheme) {\n\t\ts += options.scheme + \":\";\n\t}\n\n\tif (options.authority) {\n\t\ts += \"//\" + options.authority;\n\t}\n\n\tif (options.host) {\n\t\ts += options.host;\n\t}\n\n\tif (options.path) {\n\t\ts += options.path;\n\t}\n\n\tif (options.hostpath) {\n\t\ts += options.hostpath;\n\t}\n\n\tif (options.query) {\n\t\ts += \"?\" + options.query;\n\t}\n\n\tif (options.fragment) {\n\t\ts += \"#\" + options.fragment;\n\t}\n\n\treturn s;\n}\n\nconst re = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\nclass URI {\n\tconstructor(uri) {\n\t\tconst result = uri.match(re);\n\t\tthis.scheme = result[2];\n\t\tthis.authority = result[4];\n\t\tthis.path = result[5];\n\t\tthis.query = result[7];\n\t\tthis.fragment = result[9];\n\t}\n\n\ttoString() {\n\t\tlet s = \"\";\n\n\t\tif (this.scheme) {\n\t\t\ts += this.scheme + \":\";\n\t\t}\n\n\t\tif (this.authority) {\n\t\t\ts += \"//\" + this.authority;\n\t\t}\n\n\t\ts += this.path;\n\n\t\tif (this.query) {\n\t\t\ts += \"?\" + this.query;\n\t\t}\n\n\t\tif (this.fragment) {\n\t\t\ts += \"#\" + this.fragment;\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tgetQuery() {\n\t\tconst result = {};\n\n\t\tif (this.query) {\n\t\t\tconst queryParams = decodeURIComponent(this.query).split(\"&\");\n\n\t\t\tfor (const queryParam of queryParams) {\n\t\t\t\tconst pair = queryParam.split(\"=\");\n\t\t\t\tresult[pair[0]] = pair[1];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tsetQuery(params) {\n\t\tlet q = \"\";\n\n\t\tfor (const key in params) {\n\t\t\tif (params.hasOwnProperty(key)) {\n\t\t\t\tif (q !== \"\") {\n\t\t\t\t\tq += \"&\";\n\t\t\t\t}\n\n\t\t\t\tq += encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]);\n\t\t\t}\n\t\t}\n\n\t\tthis.query = q;\n\t}\n\n}\n\nconst math = {\n\tDEG_TO_RAD: Math.PI / 180,\n\tRAD_TO_DEG: 180 / Math.PI,\n\tclamp: function (value, min, max) {\n\t\tif (value >= max) return max;\n\t\tif (value <= min) return min;\n\t\treturn value;\n\t},\n\tintToBytes24: function (i) {\n\t\tconst r = i >> 16 & 0xff;\n\t\tconst g = i >> 8 & 0xff;\n\t\tconst b = i & 0xff;\n\t\treturn [r, g, b];\n\t},\n\tintToBytes32: function (i) {\n\t\tconst r = i >> 24 & 0xff;\n\t\tconst g = i >> 16 & 0xff;\n\t\tconst b = i >> 8 & 0xff;\n\t\tconst a = i & 0xff;\n\t\treturn [r, g, b, a];\n\t},\n\tbytesToInt24: function (r, g, b) {\n\t\tif (r.length) {\n\t\t\tb = r[2];\n\t\t\tg = r[1];\n\t\t\tr = r[0];\n\t\t}\n\n\t\treturn r << 16 | g << 8 | b;\n\t},\n\tbytesToInt32: function (r, g, b, a) {\n\t\tif (r.length) {\n\t\t\ta = r[3];\n\t\t\tb = r[2];\n\t\t\tg = r[1];\n\t\t\tr = r[0];\n\t\t}\n\n\t\treturn (r << 24 | g << 16 | b << 8 | a) >>> 0;\n\t},\n\tlerp: function (a, b, alpha) {\n\t\treturn a + (b - a) * math.clamp(alpha, 0, 1);\n\t},\n\tlerpAngle: function (a, b, alpha) {\n\t\tif (b - a > 180) {\n\t\t\tb -= 360;\n\t\t}\n\n\t\tif (b - a < -180) {\n\t\t\tb += 360;\n\t\t}\n\n\t\treturn math.lerp(a, b, math.clamp(alpha, 0, 1));\n\t},\n\tpowerOfTwo: function (x) {\n\t\treturn x !== 0 && !(x & x - 1);\n\t},\n\tnextPowerOfTwo: function (val) {\n\t\tval--;\n\t\tval |= val >> 1;\n\t\tval |= val >> 2;\n\t\tval |= val >> 4;\n\t\tval |= val >> 8;\n\t\tval |= val >> 16;\n\t\tval++;\n\t\treturn val;\n\t},\n\trandom: function (min, max) {\n\t\tconst diff = max - min;\n\t\treturn Math.random() * diff + min;\n\t},\n\tsmoothstep: function (min, max, x) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * (3 - 2 * x);\n\t},\n\tsmootherstep: function (min, max, x) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * x * (x * (x * 6 - 15) + 10);\n\t},\n\troundUp: function (numToRound, multiple) {\n\t\tif (multiple === 0) return numToRound;\n\t\treturn Math.ceil(numToRound / multiple) * multiple;\n\t},\n\tbetween: function (num, a, b, inclusive) {\n\t\tconst min = Math.min(a, b);\n\t\tconst max = Math.max(a, b);\n\t\treturn inclusive ? num >= min && num <= max : num > min && num < max;\n\t}\n};\n\nclass Http {\n\tget(url, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\treturn this.request(\"GET\", url, options, callback);\n\t}\n\n\tpost(url, data, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\toptions.postdata = data;\n\t\treturn this.request(\"POST\", url, options, callback);\n\t}\n\n\tput(url, data, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\toptions.postdata = data;\n\t\treturn this.request(\"PUT\", url, options, callback);\n\t}\n\n\tdel(url, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\treturn this.request(\"DELETE\", url, options, callback);\n\t}\n\n\trequest(method, url, options, callback) {\n\t\tlet uri, query, postdata;\n\t\tlet errored = false;\n\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\tif (options.retry) {\n\t\t\toptions = Object.assign({\n\t\t\t\tretries: 0,\n\t\t\t\tmaxRetries: 5\n\t\t\t}, options);\n\t\t}\n\n\t\toptions.callback = callback;\n\n\t\tif (options.async == null) {\n\t\t\toptions.async = true;\n\t\t}\n\n\t\tif (options.headers == null) {\n\t\t\toptions.headers = {};\n\t\t}\n\n\t\tif (options.postdata != null) {\n\t\t\tif (options.postdata instanceof Document) {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t} else if (options.postdata instanceof FormData) {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t} else if (options.postdata instanceof Object) {\n\t\t\t\tlet contentType = options.headers[\"Content-Type\"];\n\n\t\t\t\tif (contentType === undefined) {\n\t\t\t\t\toptions.headers[\"Content-Type\"] = Http.ContentType.FORM_URLENCODED;\n\t\t\t\t\tcontentType = options.headers[\"Content-Type\"];\n\t\t\t\t}\n\n\t\t\t\tswitch (contentType) {\n\t\t\t\t\tcase Http.ContentType.FORM_URLENCODED:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpostdata = \"\";\n\t\t\t\t\t\t\tlet bFirstItem = true;\n\n\t\t\t\t\t\t\tfor (const key in options.postdata) {\n\t\t\t\t\t\t\t\tif (options.postdata.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t\tif (bFirstItem) {\n\t\t\t\t\t\t\t\t\t\tbFirstItem = false;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpostdata += \"&\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst encodedKey = encodeURIComponent(key);\n\t\t\t\t\t\t\t\t\tconst encodedValue = encodeURIComponent(options.postdata[key]);\n\t\t\t\t\t\t\t\t\tpostdata += `${encodedKey}=${encodedValue}`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase Http.ContentType.JSON:\n\t\t\t\t\t\tif (contentType == null) {\n\t\t\t\t\t\t\toptions.headers[\"Content-Type\"] = Http.ContentType.JSON;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpostdata = JSON.stringify(options.postdata);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t}\n\t\t}\n\n\t\tif (options.cache === false) {\n\t\t\tconst timestamp = now();\n\t\t\turi = new URI(url);\n\n\t\t\tif (!uri.query) {\n\t\t\t\turi.query = \"ts=\" + timestamp;\n\t\t\t} else {\n\t\t\t\turi.query = uri.query + \"&ts=\" + timestamp;\n\t\t\t}\n\n\t\t\turl = uri.toString();\n\t\t}\n\n\t\tif (options.query) {\n\t\t\turi = new URI(url);\n\t\t\tquery = extend(uri.getQuery(), options.query);\n\t\t\turi.setQuery(query);\n\t\t\turl = uri.toString();\n\t\t}\n\n\t\tconst xhr = new XMLHttpRequest();\n\t\txhr.open(method, url, options.async);\n\t\txhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;\n\t\txhr.responseType = options.responseType || this._guessResponseType(url);\n\n\t\tfor (const header in options.headers) {\n\t\t\tif (options.headers.hasOwnProperty(header)) {\n\t\t\t\txhr.setRequestHeader(header, options.headers[header]);\n\t\t\t}\n\t\t}\n\n\t\txhr.onreadystatechange = () => {\n\t\t\tthis._onReadyStateChange(method, url, options, xhr);\n\t\t};\n\n\t\txhr.onerror = () => {\n\t\t\tthis._onError(method, url, options, xhr);\n\n\t\t\terrored = true;\n\t\t};\n\n\t\ttry {\n\t\t\txhr.send(postdata);\n\t\t} catch (e) {\n\t\t\tif (!errored) {\n\t\t\t\toptions.error(xhr.status, xhr, e);\n\t\t\t}\n\t\t}\n\n\t\treturn xhr;\n\t}\n\n\t_guessResponseType(url) {\n\t\tconst uri = new URI(url);\n\t\tconst ext = path.getExtension(uri.path);\n\n\t\tif (Http.binaryExtensions.indexOf(ext) >= 0) {\n\t\t\treturn Http.ResponseType.ARRAY_BUFFER;\n\t\t}\n\n\t\tif (ext === \".xml\") {\n\t\t\treturn Http.ResponseType.DOCUMENT;\n\t\t}\n\n\t\treturn Http.ResponseType.TEXT;\n\t}\n\n\t_isBinaryContentType(contentType) {\n\t\tconst binTypes = [Http.ContentType.MP4, Http.ContentType.WAV, Http.ContentType.OGG, Http.ContentType.MP3, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.BASIS, Http.ContentType.GLB];\n\n\t\tif (binTypes.indexOf(contentType) >= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_onReadyStateChange(method, url, options, xhr) {\n\t\tif (xhr.readyState === 4) {\n\t\t\tswitch (xhr.status) {\n\t\t\t\tcase 0:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {\n\t\t\t\t\t\t\tthis._onSuccess(method, url, options, xhr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._onError(method, url, options, xhr);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase 200:\n\t\t\t\tcase 201:\n\t\t\t\tcase 206:\n\t\t\t\tcase 304:\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._onSuccess(method, url, options, xhr);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._onError(method, url, options, xhr);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSuccess(method, url, options, xhr) {\n\t\tlet response;\n\t\tlet contentType;\n\t\tconst header = xhr.getResponseHeader(\"Content-Type\");\n\n\t\tif (header) {\n\t\t\tconst parts = header.split(\";\");\n\t\t\tcontentType = parts[0].trim();\n\t\t}\n\n\t\ttry {\n\t\t\tif (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith(\".json\")) {\n\t\t\t\tresponse = JSON.parse(xhr.responseText);\n\t\t\t} else if (this._isBinaryContentType(contentType)) {\n\t\t\t\tresponse = xhr.response;\n\t\t\t} else {\n\t\t\t\tif (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {\n\t\t\t\t\tresponse = xhr.response;\n\t\t\t\t} else if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {\n\t\t\t\t\tresponse = xhr.response;\n\t\t\t\t} else {\n\t\t\t\t\tif (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {\n\t\t\t\t\t\tresponse = xhr.responseXML;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse = xhr.responseText;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.callback(null, response);\n\t\t} catch (err) {\n\t\t\toptions.callback(err);\n\t\t}\n\t}\n\n\t_onError(method, url, options, xhr) {\n\t\tif (options.retrying) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.retry && options.retries < options.maxRetries) {\n\t\t\toptions.retries++;\n\t\t\toptions.retrying = true;\n\t\t\tconst retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);\n\t\t\tconsole.log(`${method}: ${url} - Error ${xhr.status}. Retrying in ${retryDelay} ms`);\n\t\t\tsetTimeout(() => {\n\t\t\t\toptions.retrying = false;\n\t\t\t\tthis.request(method, url, options, options.callback);\n\t\t\t}, retryDelay);\n\t\t} else {\n\t\t\toptions.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);\n\t\t}\n\t}\n\n}\n\nHttp.ContentType = {\n\tFORM_URLENCODED: \"application/x-www-form-urlencoded\",\n\tGIF: \"image/gif\",\n\tJPEG: \"image/jpeg\",\n\tDDS: \"image/dds\",\n\tJSON: \"application/json\",\n\tPNG: \"image/png\",\n\tTEXT: \"text/plain\",\n\tXML: \"application/xml\",\n\tWAV: \"audio/x-wav\",\n\tOGG: \"audio/ogg\",\n\tMP3: \"audio/mpeg\",\n\tMP4: \"audio/mp4\",\n\tAAC: \"audio/aac\",\n\tBIN: \"application/octet-stream\",\n\tBASIS: \"image/basis\",\n\tGLB: \"model/gltf-binary\"\n};\nHttp.ResponseType = {\n\tTEXT: 'text',\n\tARRAY_BUFFER: 'arraybuffer',\n\tBLOB: 'blob',\n\tDOCUMENT: 'document',\n\tJSON: 'json'\n};\nHttp.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb'];\nHttp.retryDelay = 100;\nconst http = new Http();\n\nconst CURVE_LINEAR = 0;\nconst CURVE_SMOOTHSTEP = 1;\nconst CURVE_CATMULL = 2;\nconst CURVE_CARDINAL = 3;\nconst CURVE_SPLINE = 4;\nconst CURVE_STEP = 5;\n\nclass Color {\n\tconstructor(r = 0, g = 0, b = 0, a = 1) {\n\t\tconst length = r.length;\n\n\t\tif (length === 3 || length === 4) {\n\t\t\tthis.r = r[0];\n\t\t\tthis.g = r[1];\n\t\t\tthis.b = r[2];\n\t\t\tthis.a = r[3] !== undefined ? r[3] : 1;\n\t\t} else {\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\t\tthis.a = a;\n\t\t}\n\t}\n\n\tclone() {\n\t\treturn new Color(this.r, this.g, this.b, this.a);\n\t}\n\n\tcopy(rhs) {\n\t\tthis.r = rhs.r;\n\t\tthis.g = rhs.g;\n\t\tthis.b = rhs.b;\n\t\tthis.a = rhs.a;\n\t\treturn this;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;\n\t}\n\n\tset(r, g, b, a = 1) {\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\t\tthis.a = a;\n\t\treturn this;\n\t}\n\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.r = lhs.r + alpha * (rhs.r - lhs.r);\n\t\tthis.g = lhs.g + alpha * (rhs.g - lhs.g);\n\t\tthis.b = lhs.b + alpha * (rhs.b - lhs.b);\n\t\tthis.a = lhs.a + alpha * (rhs.a - lhs.a);\n\t\treturn this;\n\t}\n\n\tfromString(hex) {\n\t\tconst i = parseInt(hex.replace('#', '0x'), 16);\n\t\tlet bytes;\n\n\t\tif (hex.length > 7) {\n\t\t\tbytes = math.intToBytes32(i);\n\t\t} else {\n\t\t\tbytes = math.intToBytes24(i);\n\t\t\tbytes[3] = 255;\n\t\t}\n\n\t\tthis.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);\n\t\treturn this;\n\t}\n\n\ttoString(alpha) {\n\t\tlet s = \"#\" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);\n\n\t\tif (alpha === true) {\n\t\t\tconst a = Math.round(this.a * 255).toString(16);\n\n\t\t\tif (this.a < 16 / 255) {\n\t\t\t\ts += '0' + a;\n\t\t\t} else {\n\t\t\t\ts += a;\n\t\t\t}\n\t\t}\n\n\t\treturn s;\n\t}\n\n}\n\nColor.BLACK = Object.freeze(new Color(0, 0, 0, 1));\nColor.BLUE = Object.freeze(new Color(0, 0, 1, 1));\nColor.CYAN = Object.freeze(new Color(0, 1, 1, 1));\nColor.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));\nColor.GREEN = Object.freeze(new Color(0, 1, 0, 1));\nColor.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));\nColor.RED = Object.freeze(new Color(1, 0, 0, 1));\nColor.WHITE = Object.freeze(new Color(1, 1, 1, 1));\nColor.YELLOW = Object.freeze(new Color(1, 1, 0, 1));\n\nclass CurveEvaluator {\n\tconstructor(curve, time = 0) {\n\t\tthis._curve = curve;\n\t\tthis._left = -Infinity;\n\t\tthis._right = Infinity;\n\t\tthis._recip = 0;\n\t\tthis._p0 = 0;\n\t\tthis._p1 = 0;\n\t\tthis._m0 = 0;\n\t\tthis._m1 = 0;\n\n\t\tthis._reset(time);\n\t}\n\n\tevaluate(time, forceReset = false) {\n\t\tif (forceReset || time < this._left || time >= this._right) {\n\t\t\tthis._reset(time);\n\t\t}\n\n\t\tlet result;\n\t\tconst type = this._curve.type;\n\n\t\tif (type === CURVE_STEP) {\n\t\t\tresult = this._p0;\n\t\t} else {\n\t\t\tconst t = this._recip === 0 ? 0 : (time - this._left) * this._recip;\n\n\t\t\tif (type === CURVE_LINEAR) {\n\t\t\t\tresult = math.lerp(this._p0, this._p1, t);\n\t\t\t} else if (type === CURVE_SMOOTHSTEP) {\n\t\t\t\tresult = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));\n\t\t\t} else {\n\t\t\t\tresult = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_reset(time) {\n\t\tconst keys = this._curve.keys;\n\t\tconst len = keys.length;\n\n\t\tif (!len) {\n\t\t\tthis._left = -Infinity;\n\t\t\tthis._right = Infinity;\n\t\t\tthis._recip = 0;\n\t\t\tthis._p0 = this._p1 = this._m0 = this._m1 = 0;\n\t\t} else {\n\t\t\tif (time < keys[0][0]) {\n\t\t\t\tthis._left = -Infinity;\n\t\t\t\tthis._right = keys[0][0];\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = keys[0][1];\n\t\t\t\tthis._m0 = this._m1 = 0;\n\t\t\t} else if (time >= keys[len - 1][0]) {\n\t\t\t\tthis._left = keys[len - 1][0];\n\t\t\t\tthis._right = Infinity;\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = keys[len - 1][1];\n\t\t\t\tthis._m0 = this._m1 = 0;\n\t\t\t} else {\n\t\t\t\tlet index = 0;\n\n\t\t\t\twhile (time >= keys[index + 1][0]) {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tthis._left = keys[index][0];\n\t\t\t\tthis._right = keys[index + 1][0];\n\t\t\t\tconst diff = 1.0 / (this._right - this._left);\n\t\t\t\tthis._recip = isFinite(diff) ? diff : 0;\n\t\t\t\tthis._p0 = keys[index][1];\n\t\t\t\tthis._p1 = keys[index + 1][1];\n\n\t\t\t\tif (this._isHermite()) {\n\t\t\t\t\tthis._calcTangents(keys, index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_isHermite() {\n\t\treturn this._curve.type === CURVE_CATMULL || this._curve.type === CURVE_CARDINAL || this._curve.type === CURVE_SPLINE;\n\t}\n\n\t_calcTangents(keys, index) {\n\t\tlet a;\n\t\tconst b = keys[index];\n\t\tconst c = keys[index + 1];\n\t\tlet d;\n\n\t\tif (index === 0) {\n\t\t\ta = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];\n\t\t} else {\n\t\t\ta = keys[index - 1];\n\t\t}\n\n\t\tif (index === keys.length - 2) {\n\t\t\td = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];\n\t\t} else {\n\t\t\td = keys[index + 2];\n\t\t}\n\n\t\tif (this._curve.type === CURVE_SPLINE) {\n\t\t\tconst s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);\n\t\t\tconst s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);\n\t\t\tthis._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);\n\t\t\tthis._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);\n\t\t} else {\n\t\t\tconst s1 = (c[0] - b[0]) / (b[0] - a[0]);\n\t\t\tconst s2 = (c[0] - b[0]) / (d[0] - c[0]);\n\t\t\tconst a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);\n\t\t\tconst d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);\n\t\t\tconst tension = this._curve.type === CURVE_CATMULL ? 0.5 : this._curve.tension;\n\t\t\tthis._m0 = tension * (c[1] - a_);\n\t\t\tthis._m1 = tension * (d_ - b[1]);\n\t\t}\n\t}\n\n\t_evaluateHermite(p0, p1, m0, m1, t) {\n\t\tconst t2 = t * t;\n\t\tconst twot = t + t;\n\t\tconst omt = 1 - t;\n\t\tconst omt2 = omt * omt;\n\t\treturn p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));\n\t}\n\n}\n\nclass Curve {\n\tconstructor(data) {\n\t\tthis.keys = [];\n\t\tthis.type = CURVE_SMOOTHSTEP;\n\t\tthis.tension = 0.5;\n\t\tthis._eval = new CurveEvaluator(this);\n\n\t\tif (data) {\n\t\t\tfor (let i = 0; i < data.length - 1; i += 2) {\n\t\t\t\tthis.keys.push([data[i], data[i + 1]]);\n\t\t\t}\n\t\t}\n\n\t\tthis.sort();\n\t}\n\n\tget length() {\n\t\treturn this.keys.length;\n\t}\n\n\tadd(time, value) {\n\t\tconst keys = this.keys;\n\t\tconst len = keys.length;\n\t\tlet i = 0;\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (keys[i][0] > time) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst key = [time, value];\n\t\tthis.keys.splice(i, 0, key);\n\t\treturn key;\n\t}\n\n\tget(index) {\n\t\treturn this.keys[index];\n\t}\n\n\tsort() {\n\t\tthis.keys.sort(function (a, b) {\n\t\t\treturn a[0] - b[0];\n\t\t});\n\t}\n\n\tvalue(time) {\n\t\treturn this._eval.evaluate(time, true);\n\t}\n\n\tclosest(time) {\n\t\tconst keys = this.keys;\n\t\tconst length = keys.length;\n\t\tlet min = 2;\n\t\tlet result = null;\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst diff = Math.abs(time - keys[i][0]);\n\n\t\t\tif (min >= diff) {\n\t\t\t\tmin = diff;\n\t\t\t\tresult = keys[i];\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tclone() {\n\t\tconst result = new Curve();\n\t\tresult.keys = extend(result.keys, this.keys);\n\t\tresult.type = this.type;\n\t\tresult.tension = this.tension;\n\t\treturn result;\n\t}\n\n\tquantize(precision) {\n\t\tprecision = Math.max(precision, 2);\n\t\tconst values = new Float32Array(precision);\n\t\tconst step = 1.0 / (precision - 1);\n\t\tvalues[0] = this._eval.evaluate(0, true);\n\n\t\tfor (let i = 1; i < precision; i++) {\n\t\t\tvalues[i] = this._eval.evaluate(step * i);\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tquantizeClamped(precision, min, max) {\n\t\tconst result = this.quantize(precision);\n\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = Math.min(max, Math.max(min, result[i]));\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\nclass CurveSet {\n\tconstructor() {\n\t\tthis.curves = [];\n\t\tthis._type = CURVE_SMOOTHSTEP;\n\n\t\tif (arguments.length > 1) {\n\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\tthis.curves.push(new Curve(arguments[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tif (arguments.length === 0) {\n\t\t\t\tthis.curves.push(new Curve());\n\t\t\t} else {\n\t\t\t\tconst arg = arguments[0];\n\n\t\t\t\tif (typeof arg === 'number') {\n\t\t\t\t\tfor (let i = 0; i < arg; i++) {\n\t\t\t\t\t\tthis.curves.push(new Curve());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0; i < arg.length; i++) {\n\t\t\t\t\t\tthis.curves.push(new Curve(arg[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget length() {\n\t\treturn this.curves.length;\n\t}\n\n\tset type(value) {\n\t\tthis._type = value;\n\n\t\tfor (let i = 0; i < this.curves.length; i++) {\n\t\t\tthis.curves[i].type = value;\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget(index) {\n\t\treturn this.curves[index];\n\t}\n\n\tvalue(time, result = []) {\n\t\tconst length = this.curves.length;\n\t\tresult.length = length;\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult[i] = this.curves[i].value(time);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tclone() {\n\t\tconst result = new CurveSet();\n\t\tresult.curves = [];\n\n\t\tfor (let i = 0; i < this.curves.length; i++) {\n\t\t\tresult.curves.push(this.curves[i].clone());\n\t\t}\n\n\t\tresult._type = this._type;\n\t\treturn result;\n\t}\n\n\tquantize(precision) {\n\t\tprecision = Math.max(precision, 2);\n\t\tconst numCurves = this.curves.length;\n\t\tconst values = new Float32Array(precision * numCurves);\n\t\tconst step = 1.0 / (precision - 1);\n\n\t\tfor (let c = 0; c < numCurves; c++) {\n\t\t\tconst ev = new CurveEvaluator(this.curves[c]);\n\n\t\t\tfor (let i = 0; i < precision; i++) {\n\t\t\t\tvalues[i * numCurves + c] = ev.evaluate(step * i);\n\t\t\t}\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tquantizeClamped(precision, min, max) {\n\t\tconst result = this.quantize(precision);\n\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = Math.min(max, Math.max(min, result[i]));\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\nclass Vec3 {\n\tconstructor(x = 0, y = 0, z = 0) {\n\t\tif (x.length === 3) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\t}\n\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\tthis.z += rhs.z;\n\t\treturn this;\n\t}\n\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\tthis.z = lhs.z + rhs.z;\n\t\treturn this;\n\t}\n\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\tthis.z += scalar;\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\treturn new Vec3(this.x, this.y, this.z);\n\t}\n\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\treturn this;\n\t}\n\n\tcross(lhs, rhs) {\n\t\tconst lx = lhs.x;\n\t\tconst ly = lhs.y;\n\t\tconst lz = lhs.z;\n\t\tconst rx = rhs.x;\n\t\tconst ry = rhs.y;\n\t\tconst rz = rhs.z;\n\t\tthis.x = ly * rz - ry * lz;\n\t\tthis.y = lz * rx - rz * lx;\n\t\tthis.z = lx * ry - rx * ly;\n\t\treturn this;\n\t}\n\n\tdistance(rhs) {\n\t\tconst x = this.x - rhs.x;\n\t\tconst y = this.y - rhs.y;\n\t\tconst z = this.z - rhs.z;\n\t\treturn Math.sqrt(x * x + y * y + z * z);\n\t}\n\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\tthis.z /= rhs.z;\n\t\treturn this;\n\t}\n\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\tthis.z = lhs.z / rhs.z;\n\t\treturn this;\n\t}\n\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\tthis.z /= scalar;\n\t\treturn this;\n\t}\n\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;\n\t}\n\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\t}\n\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t}\n\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\tthis.z = lhs.z + alpha * (rhs.z - lhs.z);\n\t\treturn this;\n\t}\n\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\tthis.z *= rhs.z;\n\t\treturn this;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\tthis.z = lhs.z * rhs.z;\n\t\treturn this;\n\t}\n\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\treturn this;\n\t}\n\n\tnormalize() {\n\t\tconst lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x *= invLength;\n\t\t\tthis.y *= invLength;\n\t\t\tthis.z *= invLength;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfloor() {\n\t\tthis.x = Math.floor(this.x);\n\t\tthis.y = Math.floor(this.y);\n\t\tthis.z = Math.floor(this.z);\n\t\treturn this;\n\t}\n\n\tceil() {\n\t\tthis.x = Math.ceil(this.x);\n\t\tthis.y = Math.ceil(this.y);\n\t\tthis.z = Math.ceil(this.z);\n\t\treturn this;\n\t}\n\n\tround() {\n\t\tthis.x = Math.round(this.x);\n\t\tthis.y = Math.round(this.y);\n\t\tthis.z = Math.round(this.z);\n\t\treturn this;\n\t}\n\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\tif (rhs.z < this.z) this.z = rhs.z;\n\t\treturn this;\n\t}\n\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\tif (rhs.z > this.z) this.z = rhs.z;\n\t\treturn this;\n\t}\n\n\tproject(rhs) {\n\t\tconst a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n\t\tconst b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;\n\t\tconst s = a_dot_b / b_dot_b;\n\t\tthis.x = rhs.x * s;\n\t\tthis.y = rhs.y * s;\n\t\tthis.z = rhs.z * s;\n\t\treturn this;\n\t}\n\n\tset(x, y, z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\treturn this;\n\t}\n\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\tthis.z -= rhs.z;\n\t\treturn this;\n\t}\n\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\tthis.z = lhs.z - rhs.z;\n\t\treturn this;\n\t}\n\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\tthis.z -= scalar;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}]`;\n\t}\n\n}\n\nVec3.ZERO = Object.freeze(new Vec3(0, 0, 0));\nVec3.ONE = Object.freeze(new Vec3(1, 1, 1));\nVec3.UP = Object.freeze(new Vec3(0, 1, 0));\nVec3.DOWN = Object.freeze(new Vec3(0, -1, 0));\nVec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));\nVec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));\nVec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));\nVec3.BACK = Object.freeze(new Vec3(0, 0, 1));\n\nclass Mat3 {\n\tconstructor() {\n\t\tconst data = new Float32Array(9);\n\t\tdata[0] = data[4] = data[8] = 1;\n\t\tthis.data = data;\n\t}\n\n\tclone() {\n\t\treturn new Mat3().copy(this);\n\t}\n\n\tcopy(rhs) {\n\t\tconst src = rhs.data;\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\treturn this;\n\t}\n\n\tset(src) {\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\treturn this;\n\t}\n\n\tequals(rhs) {\n\t\tconst l = this.data;\n\t\tconst r = rhs.data;\n\t\treturn l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];\n\t}\n\n\tisIdentity() {\n\t\tconst m = this.data;\n\t\treturn m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;\n\t}\n\n\tsetIdentity() {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 1;\n\t\tm[5] = 0;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 1;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tlet t = '[';\n\n\t\tfor (let i = 0; i < 9; i++) {\n\t\t\tt += this.data[i];\n\t\t\tt += i !== 8 ? ', ' : '';\n\t\t}\n\n\t\tt += ']';\n\t\treturn t;\n\t}\n\n\ttranspose() {\n\t\tconst m = this.data;\n\t\tlet tmp;\n\t\ttmp = m[1];\n\t\tm[1] = m[3];\n\t\tm[3] = tmp;\n\t\ttmp = m[2];\n\t\tm[2] = m[6];\n\t\tm[6] = tmp;\n\t\ttmp = m[5];\n\t\tm[5] = m[7];\n\t\tm[7] = tmp;\n\t\treturn this;\n\t}\n\n\tsetFromMat4(m) {\n\t\tconst src = m.data;\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[4];\n\t\tdst[4] = src[5];\n\t\tdst[5] = src[6];\n\t\tdst[6] = src[8];\n\t\tdst[7] = src[9];\n\t\tdst[8] = src[10];\n\t\treturn this;\n\t}\n\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst x = vec.x;\n\t\tconst y = vec.y;\n\t\tconst z = vec.z;\n\t\tres.x = x * m[0] + y * m[3] + z * m[6];\n\t\tres.y = x * m[1] + y * m[4] + z * m[7];\n\t\tres.z = x * m[2] + y * m[5] + z * m[8];\n\t\treturn res;\n\t}\n\n}\n\nMat3.IDENTITY = Object.freeze(new Mat3());\nMat3.ZERO = Object.freeze(new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));\n\nclass Vec2 {\n\tconstructor(x = 0, y = 0) {\n\t\tif (x.length === 2) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\treturn this;\n\t}\n\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\treturn this;\n\t}\n\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\treturn new Vec2(this.x, this.y);\n\t}\n\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\treturn this;\n\t}\n\n\tcross(rhs) {\n\t\treturn this.x * rhs.y - this.y * rhs.x;\n\t}\n\n\tdistance(rhs) {\n\t\tconst x = this.x - rhs.x;\n\t\tconst y = this.y - rhs.y;\n\t\treturn Math.sqrt(x * x + y * y);\n\t}\n\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\treturn this;\n\t}\n\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\treturn this;\n\t}\n\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\treturn this;\n\t}\n\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y;\n\t}\n\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t}\n\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y;\n\t}\n\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\treturn this;\n\t}\n\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\treturn this;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\treturn this;\n\t}\n\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\treturn this;\n\t}\n\n\tnormalize() {\n\t\tconst lengthSq = this.x * this.x + this.y * this.y;\n\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x *= invLength;\n\t\t\tthis.y *= invLength;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfloor() {\n\t\tthis.x = Math.floor(this.x);\n\t\tthis.y = Math.floor(this.y);\n\t\treturn this;\n\t}\n\n\tceil() {\n\t\tthis.x = Math.ceil(this.x);\n\t\tthis.y = Math.ceil(this.y);\n\t\treturn this;\n\t}\n\n\tround() {\n\t\tthis.x = Math.round(this.x);\n\t\tthis.y = Math.round(this.y);\n\t\treturn this;\n\t}\n\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\treturn this;\n\t}\n\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\treturn this;\n\t}\n\n\tset(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\treturn this;\n\t}\n\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\treturn this;\n\t}\n\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}]`;\n\t}\n\n\tstatic angleRad(lhs, rhs) {\n\t\treturn Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);\n\t}\n\n}\n\nVec2.ZERO = Object.freeze(new Vec2(0, 0));\nVec2.ONE = Object.freeze(new Vec2(1, 1));\nVec2.UP = Object.freeze(new Vec2(0, 1));\nVec2.DOWN = Object.freeze(new Vec2(0, -1));\nVec2.RIGHT = Object.freeze(new Vec2(1, 0));\nVec2.LEFT = Object.freeze(new Vec2(-1, 0));\n\nclass Vec4 {\n\tconstructor(x = 0, y = 0, z = 0, w = 0) {\n\t\tif (x.length === 4) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t\tthis.w = x[3];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\tthis.z += rhs.z;\n\t\tthis.w += rhs.w;\n\t\treturn this;\n\t}\n\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\tthis.z = lhs.z + rhs.z;\n\t\tthis.w = lhs.w + rhs.w;\n\t\treturn this;\n\t}\n\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\tthis.z += scalar;\n\t\tthis.w += scalar;\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\treturn new Vec4(this.x, this.y, this.z, this.w);\n\t}\n\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\tthis.w = rhs.w;\n\t\treturn this;\n\t}\n\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\tthis.z /= rhs.z;\n\t\tthis.w /= rhs.w;\n\t\treturn this;\n\t}\n\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\tthis.z = lhs.z / rhs.z;\n\t\tthis.w = lhs.w / rhs.w;\n\t\treturn this;\n\t}\n\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\tthis.z /= scalar;\n\t\tthis.w /= scalar;\n\t\treturn this;\n\t}\n\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n\t}\n\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t}\n\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t}\n\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\tthis.z = lhs.z + alpha * (rhs.z - lhs.z);\n\t\tthis.w = lhs.w + alpha * (rhs.w - lhs.w);\n\t\treturn this;\n\t}\n\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\tthis.z *= rhs.z;\n\t\tthis.w *= rhs.w;\n\t\treturn this;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\tthis.z = lhs.z * rhs.z;\n\t\tthis.w = lhs.w * rhs.w;\n\t\treturn this;\n\t}\n\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\t\treturn this;\n\t}\n\n\tnormalize() {\n\t\tconst lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x *= invLength;\n\t\t\tthis.y *= invLength;\n\t\t\tthis.z *= invLength;\n\t\t\tthis.w *= invLength;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfloor() {\n\t\tthis.x = Math.floor(this.x);\n\t\tthis.y = Math.floor(this.y);\n\t\tthis.z = Math.floor(this.z);\n\t\tthis.w = Math.floor(this.w);\n\t\treturn this;\n\t}\n\n\tceil() {\n\t\tthis.x = Math.ceil(this.x);\n\t\tthis.y = Math.ceil(this.y);\n\t\tthis.z = Math.ceil(this.z);\n\t\tthis.w = Math.ceil(this.w);\n\t\treturn this;\n\t}\n\n\tround() {\n\t\tthis.x = Math.round(this.x);\n\t\tthis.y = Math.round(this.y);\n\t\tthis.z = Math.round(this.z);\n\t\tthis.w = Math.round(this.w);\n\t\treturn this;\n\t}\n\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\tif (rhs.z < this.z) this.z = rhs.z;\n\t\tif (rhs.w < this.w) this.w = rhs.w;\n\t\treturn this;\n\t}\n\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\tif (rhs.z > this.z) this.z = rhs.z;\n\t\tif (rhs.w > this.w) this.w = rhs.w;\n\t\treturn this;\n\t}\n\n\tset(x, y, z, w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\tthis.z -= rhs.z;\n\t\tthis.w -= rhs.w;\n\t\treturn this;\n\t}\n\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\tthis.z = lhs.z - rhs.z;\n\t\tthis.w = lhs.w - rhs.w;\n\t\treturn this;\n\t}\n\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\tthis.z -= scalar;\n\t\tthis.w -= scalar;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n\t}\n\n}\n\nVec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));\nVec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));\n\nconst _halfSize$1 = new Vec2();\n\nconst x = new Vec3();\nconst y = new Vec3();\nconst z = new Vec3();\nconst scale = new Vec3();\n\nclass Mat4 {\n\tconstructor() {\n\t\tconst data = new Float32Array(16);\n\t\tdata[0] = data[5] = data[10] = data[15] = 1;\n\t\tthis.data = data;\n\t}\n\n\tstatic _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {\n\t\tif (fovIsHorizontal) {\n\t\t\thalfSize.x = znear * Math.tan(fov * Math.PI / 360);\n\t\t\thalfSize.y = halfSize.x / aspect;\n\t\t} else {\n\t\t\thalfSize.y = znear * Math.tan(fov * Math.PI / 360);\n\t\t\thalfSize.x = halfSize.y * aspect;\n\t\t}\n\t}\n\n\tadd2(lhs, rhs) {\n\t\tconst a = lhs.data,\n\t\t\t\t\tb = rhs.data,\n\t\t\t\t\tr = this.data;\n\t\tr[0] = a[0] + b[0];\n\t\tr[1] = a[1] + b[1];\n\t\tr[2] = a[2] + b[2];\n\t\tr[3] = a[3] + b[3];\n\t\tr[4] = a[4] + b[4];\n\t\tr[5] = a[5] + b[5];\n\t\tr[6] = a[6] + b[6];\n\t\tr[7] = a[7] + b[7];\n\t\tr[8] = a[8] + b[8];\n\t\tr[9] = a[9] + b[9];\n\t\tr[10] = a[10] + b[10];\n\t\tr[11] = a[11] + b[11];\n\t\tr[12] = a[12] + b[12];\n\t\tr[13] = a[13] + b[13];\n\t\tr[14] = a[14] + b[14];\n\t\tr[15] = a[15] + b[15];\n\t\treturn this;\n\t}\n\n\tadd(rhs) {\n\t\treturn this.add2(this, rhs);\n\t}\n\n\tclone() {\n\t\treturn new Mat4().copy(this);\n\t}\n\n\tcopy(rhs) {\n\t\tconst src = rhs.data,\n\t\t\t\t\tdst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\tdst[9] = src[9];\n\t\tdst[10] = src[10];\n\t\tdst[11] = src[11];\n\t\tdst[12] = src[12];\n\t\tdst[13] = src[13];\n\t\tdst[14] = src[14];\n\t\tdst[15] = src[15];\n\t\treturn this;\n\t}\n\n\tequals(rhs) {\n\t\tconst l = this.data,\n\t\t\t\t\tr = rhs.data;\n\t\treturn l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];\n\t}\n\n\tisIdentity() {\n\t\tconst m = this.data;\n\t\treturn m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tconst a = lhs.data;\n\t\tconst b = rhs.data;\n\t\tconst r = this.data;\n\t\tconst a00 = a[0];\n\t\tconst a01 = a[1];\n\t\tconst a02 = a[2];\n\t\tconst a03 = a[3];\n\t\tconst a10 = a[4];\n\t\tconst a11 = a[5];\n\t\tconst a12 = a[6];\n\t\tconst a13 = a[7];\n\t\tconst a20 = a[8];\n\t\tconst a21 = a[9];\n\t\tconst a22 = a[10];\n\t\tconst a23 = a[11];\n\t\tconst a30 = a[12];\n\t\tconst a31 = a[13];\n\t\tconst a32 = a[14];\n\t\tconst a33 = a[15];\n\t\tlet b0, b1, b2, b3;\n\t\tb0 = b[0];\n\t\tb1 = b[1];\n\t\tb2 = b[2];\n\t\tb3 = b[3];\n\t\tr[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[4];\n\t\tb1 = b[5];\n\t\tb2 = b[6];\n\t\tb3 = b[7];\n\t\tr[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[8];\n\t\tb1 = b[9];\n\t\tb2 = b[10];\n\t\tb3 = b[11];\n\t\tr[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[12];\n\t\tb1 = b[13];\n\t\tb2 = b[14];\n\t\tb3 = b[15];\n\t\tr[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\treturn this;\n\t}\n\n\tmulAffine2(lhs, rhs) {\n\t\tconst a = lhs.data;\n\t\tconst b = rhs.data;\n\t\tconst r = this.data;\n\t\tconst a00 = a[0];\n\t\tconst a01 = a[1];\n\t\tconst a02 = a[2];\n\t\tconst a10 = a[4];\n\t\tconst a11 = a[5];\n\t\tconst a12 = a[6];\n\t\tconst a20 = a[8];\n\t\tconst a21 = a[9];\n\t\tconst a22 = a[10];\n\t\tconst a30 = a[12];\n\t\tconst a31 = a[13];\n\t\tconst a32 = a[14];\n\t\tlet b0, b1, b2;\n\t\tb0 = b[0];\n\t\tb1 = b[1];\n\t\tb2 = b[2];\n\t\tr[0] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[1] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[2] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[3] = 0;\n\t\tb0 = b[4];\n\t\tb1 = b[5];\n\t\tb2 = b[6];\n\t\tr[4] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[5] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[6] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[7] = 0;\n\t\tb0 = b[8];\n\t\tb1 = b[9];\n\t\tb2 = b[10];\n\t\tr[8] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[9] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[10] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[11] = 0;\n\t\tb0 = b[12];\n\t\tb1 = b[13];\n\t\tb2 = b[14];\n\t\tr[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;\n\t\tr[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;\n\t\tr[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\n\tmul(rhs) {\n\t\treturn this.mul2(this, rhs);\n\t}\n\n\ttransformPoint(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst x = vec.x;\n\t\tconst y = vec.y;\n\t\tconst z = vec.z;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8] + m[12];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9] + m[13];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10] + m[14];\n\t\treturn res;\n\t}\n\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst x = vec.x;\n\t\tconst y = vec.y;\n\t\tconst z = vec.z;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10];\n\t\treturn res;\n\t}\n\n\ttransformVec4(vec, res = new Vec4()) {\n\t\tconst m = this.data;\n\t\tconst x = vec.x;\n\t\tconst y = vec.y;\n\t\tconst z = vec.z;\n\t\tconst w = vec.w;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];\n\t\tres.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];\n\t\treturn res;\n\t}\n\n\tsetLookAt(position, target, up) {\n\t\tz.sub2(position, target).normalize();\n\t\ty.copy(up).normalize();\n\t\tx.cross(y, z).normalize();\n\t\ty.cross(z, x);\n\t\tconst r = this.data;\n\t\tr[0] = x.x;\n\t\tr[1] = x.y;\n\t\tr[2] = x.z;\n\t\tr[3] = 0;\n\t\tr[4] = y.x;\n\t\tr[5] = y.y;\n\t\tr[6] = y.z;\n\t\tr[7] = 0;\n\t\tr[8] = z.x;\n\t\tr[9] = z.y;\n\t\tr[10] = z.z;\n\t\tr[11] = 0;\n\t\tr[12] = position.x;\n\t\tr[13] = position.y;\n\t\tr[14] = position.z;\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetFrustum(left, right, bottom, top, znear, zfar) {\n\t\tconst temp1 = 2 * znear;\n\t\tconst temp2 = right - left;\n\t\tconst temp3 = top - bottom;\n\t\tconst temp4 = zfar - znear;\n\t\tconst r = this.data;\n\t\tr[0] = temp1 / temp2;\n\t\tr[1] = 0;\n\t\tr[2] = 0;\n\t\tr[3] = 0;\n\t\tr[4] = 0;\n\t\tr[5] = temp1 / temp3;\n\t\tr[6] = 0;\n\t\tr[7] = 0;\n\t\tr[8] = (right + left) / temp2;\n\t\tr[9] = (top + bottom) / temp3;\n\t\tr[10] = (-zfar - znear) / temp4;\n\t\tr[11] = -1;\n\t\tr[12] = 0;\n\t\tr[13] = 0;\n\t\tr[14] = -temp1 * zfar / temp4;\n\t\tr[15] = 0;\n\t\treturn this;\n\t}\n\n\tsetPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {\n\t\tMat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);\n\n\t\treturn this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);\n\t}\n\n\tsetOrtho(left, right, bottom, top, near, far) {\n\t\tconst r = this.data;\n\t\tr[0] = 2 / (right - left);\n\t\tr[1] = 0;\n\t\tr[2] = 0;\n\t\tr[3] = 0;\n\t\tr[4] = 0;\n\t\tr[5] = 2 / (top - bottom);\n\t\tr[6] = 0;\n\t\tr[7] = 0;\n\t\tr[8] = 0;\n\t\tr[9] = 0;\n\t\tr[10] = -2 / (far - near);\n\t\tr[11] = 0;\n\t\tr[12] = -(right + left) / (right - left);\n\t\tr[13] = -(top + bottom) / (top - bottom);\n\t\tr[14] = -(far + near) / (far - near);\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetFromAxisAngle(axis, angle) {\n\t\tangle *= math.DEG_TO_RAD;\n\t\tconst x = axis.x;\n\t\tconst y = axis.y;\n\t\tconst z = axis.z;\n\t\tconst c = Math.cos(angle);\n\t\tconst s = Math.sin(angle);\n\t\tconst t = 1 - c;\n\t\tconst tx = t * x;\n\t\tconst ty = t * y;\n\t\tconst m = this.data;\n\t\tm[0] = tx * x + c;\n\t\tm[1] = tx * y + s * z;\n\t\tm[2] = tx * z - s * y;\n\t\tm[3] = 0;\n\t\tm[4] = tx * y - s * z;\n\t\tm[5] = ty * y + c;\n\t\tm[6] = ty * z + s * x;\n\t\tm[7] = 0;\n\t\tm[8] = tx * z + s * y;\n\t\tm[9] = ty * z - x * s;\n\t\tm[10] = t * z * z + c;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetTranslate(x, y, z) {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = 1;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 1;\n\t\tm[11] = 0;\n\t\tm[12] = x;\n\t\tm[13] = y;\n\t\tm[14] = z;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetScale(x, y, z) {\n\t\tconst m = this.data;\n\t\tm[0] = x;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = y;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = z;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetViewport(x, y, width, height) {\n\t\tconst m = this.data;\n\t\tm[0] = width * 0.5;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = height * 0.5;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 0.5;\n\t\tm[11] = 0;\n\t\tm[12] = x + width * 0.5;\n\t\tm[13] = y + height * 0.5;\n\t\tm[14] = 0.5;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tinvert() {\n\t\tconst m = this.data;\n\t\tconst a00 = m[0];\n\t\tconst a01 = m[1];\n\t\tconst a02 = m[2];\n\t\tconst a03 = m[3];\n\t\tconst a10 = m[4];\n\t\tconst a11 = m[5];\n\t\tconst a12 = m[6];\n\t\tconst a13 = m[7];\n\t\tconst a20 = m[8];\n\t\tconst a21 = m[9];\n\t\tconst a22 = m[10];\n\t\tconst a23 = m[11];\n\t\tconst a30 = m[12];\n\t\tconst a31 = m[13];\n\t\tconst a32 = m[14];\n\t\tconst a33 = m[15];\n\t\tconst b00 = a00 * a11 - a01 * a10;\n\t\tconst b01 = a00 * a12 - a02 * a10;\n\t\tconst b02 = a00 * a13 - a03 * a10;\n\t\tconst b03 = a01 * a12 - a02 * a11;\n\t\tconst b04 = a01 * a13 - a03 * a11;\n\t\tconst b05 = a02 * a13 - a03 * a12;\n\t\tconst b06 = a20 * a31 - a21 * a30;\n\t\tconst b07 = a20 * a32 - a22 * a30;\n\t\tconst b08 = a20 * a33 - a23 * a30;\n\t\tconst b09 = a21 * a32 - a22 * a31;\n\t\tconst b10 = a21 * a33 - a23 * a31;\n\t\tconst b11 = a22 * a33 - a23 * a32;\n\t\tconst det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n\t\tif (det === 0) {\n\t\t\tthis.setIdentity();\n\t\t} else {\n\t\t\tconst invDet = 1 / det;\n\t\t\tm[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n\t\t\tm[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n\t\t\tm[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n\t\t\tm[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n\t\t\tm[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n\t\t\tm[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n\t\t\tm[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n\t\t\tm[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n\t\t\tm[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n\t\t\tm[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n\t\t\tm[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n\t\t\tm[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n\t\t\tm[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n\t\t\tm[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n\t\t\tm[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n\t\t\tm[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tset(src) {\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\tdst[9] = src[9];\n\t\tdst[10] = src[10];\n\t\tdst[11] = src[11];\n\t\tdst[12] = src[12];\n\t\tdst[13] = src[13];\n\t\tdst[14] = src[14];\n\t\tdst[15] = src[15];\n\t\treturn this;\n\t}\n\n\tsetIdentity() {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = 1;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 1;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetTRS(t, r, s) {\n\t\tconst qx = r.x;\n\t\tconst qy = r.y;\n\t\tconst qz = r.z;\n\t\tconst qw = r.w;\n\t\tconst sx = s.x;\n\t\tconst sy = s.y;\n\t\tconst sz = s.z;\n\t\tconst x2 = qx + qx;\n\t\tconst y2 = qy + qy;\n\t\tconst z2 = qz + qz;\n\t\tconst xx = qx * x2;\n\t\tconst xy = qx * y2;\n\t\tconst xz = qx * z2;\n\t\tconst yy = qy * y2;\n\t\tconst yz = qy * z2;\n\t\tconst zz = qz * z2;\n\t\tconst wx = qw * x2;\n\t\tconst wy = qw * y2;\n\t\tconst wz = qw * z2;\n\t\tconst m = this.data;\n\t\tm[0] = (1 - (yy + zz)) * sx;\n\t\tm[1] = (xy + wz) * sx;\n\t\tm[2] = (xz - wy) * sx;\n\t\tm[3] = 0;\n\t\tm[4] = (xy - wz) * sy;\n\t\tm[5] = (1 - (xx + zz)) * sy;\n\t\tm[6] = (yz + wx) * sy;\n\t\tm[7] = 0;\n\t\tm[8] = (xz + wy) * sz;\n\t\tm[9] = (yz - wx) * sz;\n\t\tm[10] = (1 - (xx + yy)) * sz;\n\t\tm[11] = 0;\n\t\tm[12] = t.x;\n\t\tm[13] = t.y;\n\t\tm[14] = t.z;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\ttranspose() {\n\t\tlet tmp;\n\t\tconst m = this.data;\n\t\ttmp = m[1];\n\t\tm[1] = m[4];\n\t\tm[4] = tmp;\n\t\ttmp = m[2];\n\t\tm[2] = m[8];\n\t\tm[8] = tmp;\n\t\ttmp = m[3];\n\t\tm[3] = m[12];\n\t\tm[12] = tmp;\n\t\ttmp = m[6];\n\t\tm[6] = m[9];\n\t\tm[9] = tmp;\n\t\ttmp = m[7];\n\t\tm[7] = m[13];\n\t\tm[13] = tmp;\n\t\ttmp = m[11];\n\t\tm[11] = m[14];\n\t\tm[14] = tmp;\n\t\treturn this;\n\t}\n\n\tinvertTo3x3(res) {\n\t\tconst m = this.data;\n\t\tconst r = res.data;\n\t\tconst m0 = m[0];\n\t\tconst m1 = m[1];\n\t\tconst m2 = m[2];\n\t\tconst m4 = m[4];\n\t\tconst m5 = m[5];\n\t\tconst m6 = m[6];\n\t\tconst m8 = m[8];\n\t\tconst m9 = m[9];\n\t\tconst m10 = m[10];\n\t\tconst a11 = m10 * m5 - m6 * m9;\n\t\tconst a21 = -m10 * m1 + m2 * m9;\n\t\tconst a31 = m6 * m1 - m2 * m5;\n\t\tconst a12 = -m10 * m4 + m6 * m8;\n\t\tconst a22 = m10 * m0 - m2 * m8;\n\t\tconst a32 = -m6 * m0 + m2 * m4;\n\t\tconst a13 = m9 * m4 - m5 * m8;\n\t\tconst a23 = -m9 * m0 + m1 * m8;\n\t\tconst a33 = m5 * m0 - m1 * m4;\n\t\tconst det = m0 * a11 + m1 * a12 + m2 * a13;\n\n\t\tif (det === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst idet = 1 / det;\n\t\tr[0] = idet * a11;\n\t\tr[1] = idet * a21;\n\t\tr[2] = idet * a31;\n\t\tr[3] = idet * a12;\n\t\tr[4] = idet * a22;\n\t\tr[5] = idet * a32;\n\t\tr[6] = idet * a13;\n\t\tr[7] = idet * a23;\n\t\tr[8] = idet * a33;\n\t\treturn this;\n\t}\n\n\tgetTranslation(t = new Vec3()) {\n\t\treturn t.set(this.data[12], this.data[13], this.data[14]);\n\t}\n\n\tgetX(x = new Vec3()) {\n\t\treturn x.set(this.data[0], this.data[1], this.data[2]);\n\t}\n\n\tgetY(y = new Vec3()) {\n\t\treturn y.set(this.data[4], this.data[5], this.data[6]);\n\t}\n\n\tgetZ(z = new Vec3()) {\n\t\treturn z.set(this.data[8], this.data[9], this.data[10]);\n\t}\n\n\tgetScale(scale = new Vec3()) {\n\t\tthis.getX(x);\n\t\tthis.getY(y);\n\t\tthis.getZ(z);\n\t\tscale.set(x.length(), y.length(), z.length());\n\t\treturn scale;\n\t}\n\n\tsetFromEulerAngles(ex, ey, ez) {\n\t\tex *= math.DEG_TO_RAD;\n\t\tey *= math.DEG_TO_RAD;\n\t\tez *= math.DEG_TO_RAD;\n\t\tconst s1 = Math.sin(-ex);\n\t\tconst c1 = Math.cos(-ex);\n\t\tconst s2 = Math.sin(-ey);\n\t\tconst c2 = Math.cos(-ey);\n\t\tconst s3 = Math.sin(-ez);\n\t\tconst c3 = Math.cos(-ez);\n\t\tconst m = this.data;\n\t\tm[0] = c2 * c3;\n\t\tm[1] = -c2 * s3;\n\t\tm[2] = s2;\n\t\tm[3] = 0;\n\t\tm[4] = c1 * s3 + c3 * s1 * s2;\n\t\tm[5] = c1 * c3 - s1 * s2 * s3;\n\t\tm[6] = -c2 * s1;\n\t\tm[7] = 0;\n\t\tm[8] = s1 * s3 - c1 * c3 * s2;\n\t\tm[9] = c3 * s1 + c1 * s2 * s3;\n\t\tm[10] = c1 * c2;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tgetEulerAngles(eulers = new Vec3()) {\n\t\tthis.getScale(scale);\n\t\tconst sx = scale.x;\n\t\tconst sy = scale.y;\n\t\tconst sz = scale.z;\n\t\tif (sx === 0 || sy === 0 || sz === 0) return eulers.set(0, 0, 0);\n\t\tconst m = this.data;\n\t\tconst y = Math.asin(-m[2] / sx);\n\t\tconst halfPi = Math.PI * 0.5;\n\t\tlet x, z;\n\n\t\tif (y < halfPi) {\n\t\t\tif (y > -halfPi) {\n\t\t\t\tx = Math.atan2(m[6] / sy, m[10] / sz);\n\t\t\t\tz = Math.atan2(m[1] / sx, m[0] / sx);\n\t\t\t} else {\n\t\t\t\tz = 0;\n\t\t\t\tx = -Math.atan2(m[4] / sy, m[5] / sy);\n\t\t\t}\n\t\t} else {\n\t\t\tz = 0;\n\t\t\tx = Math.atan2(m[4] / sy, m[5] / sy);\n\t\t}\n\n\t\treturn eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);\n\t}\n\n\ttoString() {\n\t\tlet t = '[';\n\n\t\tfor (let i = 0; i < 16; i += 1) {\n\t\t\tt += this.data[i];\n\t\t\tt += i !== 15 ? ', ' : '';\n\t\t}\n\n\t\tt += ']';\n\t\treturn t;\n\t}\n\n}\n\nMat4.IDENTITY = Object.freeze(new Mat4());\nMat4.ZERO = Object.freeze(new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));\n\nclass Quat {\n\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\tif (x.length === 4) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t\tthis.w = x[3];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tclone() {\n\t\treturn new Quat(this.x, this.y, this.z, this.w);\n\t}\n\n\tconjugate() {\n\t\tthis.x *= -1;\n\t\tthis.y *= -1;\n\t\tthis.z *= -1;\n\t\treturn this;\n\t}\n\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\tthis.w = rhs.w;\n\t\treturn this;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n\t}\n\n\tgetAxisAngle(axis) {\n\t\tlet rad = Math.acos(this.w) * 2;\n\t\tconst s = Math.sin(rad / 2);\n\n\t\tif (s !== 0) {\n\t\t\taxis.x = this.x / s;\n\t\t\taxis.y = this.y / s;\n\t\t\taxis.z = this.z / s;\n\n\t\t\tif (axis.x < 0 || axis.y < 0 || axis.z < 0) {\n\t\t\t\taxis.x *= -1;\n\t\t\t\taxis.y *= -1;\n\t\t\t\taxis.z *= -1;\n\t\t\t\trad *= -1;\n\t\t\t}\n\t\t} else {\n\t\t\taxis.x = 1;\n\t\t\taxis.y = 0;\n\t\t\taxis.z = 0;\n\t\t}\n\n\t\treturn rad * math.RAD_TO_DEG;\n\t}\n\n\tgetEulerAngles(eulers = new Vec3()) {\n\t\tlet x, y, z;\n\t\tconst qx = this.x;\n\t\tconst qy = this.y;\n\t\tconst qz = this.z;\n\t\tconst qw = this.w;\n\t\tconst a2 = 2 * (qw * qy - qx * qz);\n\n\t\tif (a2 <= -0.99999) {\n\t\t\tx = 2 * Math.atan2(qx, qw);\n\t\t\ty = -Math.PI / 2;\n\t\t\tz = 0;\n\t\t} else if (a2 >= 0.99999) {\n\t\t\tx = 2 * Math.atan2(qx, qw);\n\t\t\ty = Math.PI / 2;\n\t\t\tz = 0;\n\t\t} else {\n\t\t\tx = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));\n\t\t\ty = Math.asin(a2);\n\t\t\tz = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));\n\t\t}\n\n\t\treturn eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);\n\t}\n\n\tinvert() {\n\t\treturn this.conjugate().normalize();\n\t}\n\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t}\n\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t}\n\n\tmul(rhs) {\n\t\tconst q1x = this.x;\n\t\tconst q1y = this.y;\n\t\tconst q1z = this.z;\n\t\tconst q1w = this.w;\n\t\tconst q2x = rhs.x;\n\t\tconst q2y = rhs.y;\n\t\tconst q2z = rhs.z;\n\t\tconst q2w = rhs.w;\n\t\tthis.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n\t\tthis.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n\t\tthis.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n\t\tthis.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n\t\treturn this;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tconst q1x = lhs.x;\n\t\tconst q1y = lhs.y;\n\t\tconst q1z = lhs.z;\n\t\tconst q1w = lhs.w;\n\t\tconst q2x = rhs.x;\n\t\tconst q2y = rhs.y;\n\t\tconst q2z = rhs.z;\n\t\tconst q2w = rhs.w;\n\t\tthis.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n\t\tthis.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n\t\tthis.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n\t\tthis.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n\t\treturn this;\n\t}\n\n\tnormalize() {\n\t\tlet len = this.length();\n\n\t\tif (len === 0) {\n\t\t\tthis.x = this.y = this.z = 0;\n\t\t\tthis.w = 1;\n\t\t} else {\n\t\t\tlen = 1 / len;\n\t\t\tthis.x *= len;\n\t\t\tthis.y *= len;\n\t\t\tthis.z *= len;\n\t\t\tthis.w *= len;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tset(x, y, z, w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\tsetFromAxisAngle(axis, angle) {\n\t\tangle *= 0.5 * math.DEG_TO_RAD;\n\t\tconst sa = Math.sin(angle);\n\t\tconst ca = Math.cos(angle);\n\t\tthis.x = sa * axis.x;\n\t\tthis.y = sa * axis.y;\n\t\tthis.z = sa * axis.z;\n\t\tthis.w = ca;\n\t\treturn this;\n\t}\n\n\tsetFromEulerAngles(ex, ey, ez) {\n\t\tconst halfToRad = 0.5 * math.DEG_TO_RAD;\n\t\tex *= halfToRad;\n\t\tey *= halfToRad;\n\t\tez *= halfToRad;\n\t\tconst sx = Math.sin(ex);\n\t\tconst cx = Math.cos(ex);\n\t\tconst sy = Math.sin(ey);\n\t\tconst cy = Math.cos(ey);\n\t\tconst sz = Math.sin(ez);\n\t\tconst cz = Math.cos(ez);\n\t\tthis.x = sx * cy * cz - cx * sy * sz;\n\t\tthis.y = cx * sy * cz + sx * cy * sz;\n\t\tthis.z = cx * cy * sz - sx * sy * cz;\n\t\tthis.w = cx * cy * cz + sx * sy * sz;\n\t\treturn this;\n\t}\n\n\tsetFromMat4(m) {\n\t\tlet m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;\n\t\tm = m.data;\n\t\tm00 = m[0];\n\t\tm01 = m[1];\n\t\tm02 = m[2];\n\t\tm10 = m[4];\n\t\tm11 = m[5];\n\t\tm12 = m[6];\n\t\tm20 = m[8];\n\t\tm21 = m[9];\n\t\tm22 = m[10];\n\t\tlx = m00 * m00 + m01 * m01 + m02 * m02;\n\t\tif (lx === 0) return this;\n\t\tlx = 1 / Math.sqrt(lx);\n\t\tly = m10 * m10 + m11 * m11 + m12 * m12;\n\t\tif (ly === 0) return this;\n\t\tly = 1 / Math.sqrt(ly);\n\t\tlz = m20 * m20 + m21 * m21 + m22 * m22;\n\t\tif (lz === 0) return this;\n\t\tlz = 1 / Math.sqrt(lz);\n\t\tm00 *= lx;\n\t\tm01 *= lx;\n\t\tm02 *= lx;\n\t\tm10 *= ly;\n\t\tm11 *= ly;\n\t\tm12 *= ly;\n\t\tm20 *= lz;\n\t\tm21 *= lz;\n\t\tm22 *= lz;\n\t\tconst tr = m00 + m11 + m22;\n\n\t\tif (tr >= 0) {\n\t\t\ts = Math.sqrt(tr + 1);\n\t\t\tthis.w = s * 0.5;\n\t\t\ts = 0.5 / s;\n\t\t\tthis.x = (m12 - m21) * s;\n\t\t\tthis.y = (m20 - m02) * s;\n\t\t\tthis.z = (m01 - m10) * s;\n\t\t} else {\n\t\t\tif (m00 > m11) {\n\t\t\t\tif (m00 > m22) {\n\t\t\t\t\trs = m00 - (m11 + m22) + 1;\n\t\t\t\t\trs = Math.sqrt(rs);\n\t\t\t\t\tthis.x = rs * 0.5;\n\t\t\t\t\trs = 0.5 / rs;\n\t\t\t\t\tthis.w = (m12 - m21) * rs;\n\t\t\t\t\tthis.y = (m01 + m10) * rs;\n\t\t\t\t\tthis.z = (m02 + m20) * rs;\n\t\t\t\t} else {\n\t\t\t\t\trs = m22 - (m00 + m11) + 1;\n\t\t\t\t\trs = Math.sqrt(rs);\n\t\t\t\t\tthis.z = rs * 0.5;\n\t\t\t\t\trs = 0.5 / rs;\n\t\t\t\t\tthis.w = (m01 - m10) * rs;\n\t\t\t\t\tthis.x = (m20 + m02) * rs;\n\t\t\t\t\tthis.y = (m21 + m12) * rs;\n\t\t\t\t}\n\t\t\t} else if (m11 > m22) {\n\t\t\t\trs = m11 - (m22 + m00) + 1;\n\t\t\t\trs = Math.sqrt(rs);\n\t\t\t\tthis.y = rs * 0.5;\n\t\t\t\trs = 0.5 / rs;\n\t\t\t\tthis.w = (m20 - m02) * rs;\n\t\t\t\tthis.z = (m12 + m21) * rs;\n\t\t\t\tthis.x = (m10 + m01) * rs;\n\t\t\t} else {\n\t\t\t\trs = m22 - (m00 + m11) + 1;\n\t\t\t\trs = Math.sqrt(rs);\n\t\t\t\tthis.z = rs * 0.5;\n\t\t\t\trs = 0.5 / rs;\n\t\t\t\tthis.w = (m01 - m10) * rs;\n\t\t\t\tthis.x = (m20 + m02) * rs;\n\t\t\t\tthis.y = (m21 + m12) * rs;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tslerp(lhs, rhs, alpha) {\n\t\tconst lx = lhs.x;\n\t\tconst ly = lhs.y;\n\t\tconst lz = lhs.z;\n\t\tconst lw = lhs.w;\n\t\tlet rx = rhs.x;\n\t\tlet ry = rhs.y;\n\t\tlet rz = rhs.z;\n\t\tlet rw = rhs.w;\n\t\tlet cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;\n\n\t\tif (cosHalfTheta < 0) {\n\t\t\trw = -rw;\n\t\t\trx = -rx;\n\t\t\try = -ry;\n\t\t\trz = -rz;\n\t\t\tcosHalfTheta = -cosHalfTheta;\n\t\t}\n\n\t\tif (Math.abs(cosHalfTheta) >= 1) {\n\t\t\tthis.w = lw;\n\t\t\tthis.x = lx;\n\t\t\tthis.y = ly;\n\t\t\tthis.z = lz;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst halfTheta = Math.acos(cosHalfTheta);\n\t\tconst sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);\n\n\t\tif (Math.abs(sinHalfTheta) < 0.001) {\n\t\t\tthis.w = lw * 0.5 + rw * 0.5;\n\t\t\tthis.x = lx * 0.5 + rx * 0.5;\n\t\t\tthis.y = ly * 0.5 + ry * 0.5;\n\t\t\tthis.z = lz * 0.5 + rz * 0.5;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;\n\t\tconst ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;\n\t\tthis.w = lw * ratioA + rw * ratioB;\n\t\tthis.x = lx * ratioA + rx * ratioB;\n\t\tthis.y = ly * ratioA + ry * ratioB;\n\t\tthis.z = lz * ratioA + rz * ratioB;\n\t\treturn this;\n\t}\n\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst x = vec.x,\n\t\t\t\t\ty = vec.y,\n\t\t\t\t\tz = vec.z;\n\t\tconst qx = this.x,\n\t\t\t\t\tqy = this.y,\n\t\t\t\t\tqz = this.z,\n\t\t\t\t\tqw = this.w;\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = -qx * x - qy * y - qz * z;\n\t\tres.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\tres.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\tres.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\t\treturn res;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n\t}\n\n}\n\nQuat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));\nQuat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));\n\nconst tmpVecA$2 = new Vec3();\nconst tmpVecB$1 = new Vec3();\nconst tmpVecC = new Vec3();\nconst tmpVecD = new Vec3();\nconst tmpVecE = new Vec3();\n\nclass BoundingBox {\n\tconstructor(center = new Vec3(), halfExtents = new Vec3(0.5, 0.5, 0.5)) {\n\t\tthis.center = center;\n\t\tthis.halfExtents = halfExtents;\n\t\tthis._min = new Vec3();\n\t\tthis._max = new Vec3();\n\t}\n\n\tadd(other) {\n\t\tconst tc = this.center;\n\t\tconst tcx = tc.x;\n\t\tconst tcy = tc.y;\n\t\tconst tcz = tc.z;\n\t\tconst th = this.halfExtents;\n\t\tconst thx = th.x;\n\t\tconst thy = th.y;\n\t\tconst thz = th.z;\n\t\tlet tminx = tcx - thx;\n\t\tlet tmaxx = tcx + thx;\n\t\tlet tminy = tcy - thy;\n\t\tlet tmaxy = tcy + thy;\n\t\tlet tminz = tcz - thz;\n\t\tlet tmaxz = tcz + thz;\n\t\tconst oc = other.center;\n\t\tconst ocx = oc.x;\n\t\tconst ocy = oc.y;\n\t\tconst ocz = oc.z;\n\t\tconst oh = other.halfExtents;\n\t\tconst ohx = oh.x;\n\t\tconst ohy = oh.y;\n\t\tconst ohz = oh.z;\n\t\tconst ominx = ocx - ohx;\n\t\tconst omaxx = ocx + ohx;\n\t\tconst ominy = ocy - ohy;\n\t\tconst omaxy = ocy + ohy;\n\t\tconst ominz = ocz - ohz;\n\t\tconst omaxz = ocz + ohz;\n\t\tif (ominx < tminx) tminx = ominx;\n\t\tif (omaxx > tmaxx) tmaxx = omaxx;\n\t\tif (ominy < tminy) tminy = ominy;\n\t\tif (omaxy > tmaxy) tmaxy = omaxy;\n\t\tif (ominz < tminz) tminz = ominz;\n\t\tif (omaxz > tmaxz) tmaxz = omaxz;\n\t\ttc.x = (tminx + tmaxx) * 0.5;\n\t\ttc.y = (tminy + tmaxy) * 0.5;\n\t\ttc.z = (tminz + tmaxz) * 0.5;\n\t\tth.x = (tmaxx - tminx) * 0.5;\n\t\tth.y = (tmaxy - tminy) * 0.5;\n\t\tth.z = (tmaxz - tminz) * 0.5;\n\t}\n\n\tcopy(src) {\n\t\tthis.center.copy(src.center);\n\t\tthis.halfExtents.copy(src.halfExtents);\n\t}\n\n\tclone() {\n\t\treturn new BoundingBox(this.center.clone(), this.halfExtents.clone());\n\t}\n\n\tintersects(other) {\n\t\tconst aMax = this.getMax();\n\t\tconst aMin = this.getMin();\n\t\tconst bMax = other.getMax();\n\t\tconst bMin = other.getMin();\n\t\treturn aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;\n\t}\n\n\t_intersectsRay(ray, point) {\n\t\tconst tMin = tmpVecA$2.copy(this.getMin()).sub(ray.origin);\n\t\tconst tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);\n\t\tconst dir = ray.direction;\n\n\t\tif (dir.x === 0) {\n\t\t\ttMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.x /= dir.x;\n\t\t\ttMax.x /= dir.x;\n\t\t}\n\n\t\tif (dir.y === 0) {\n\t\t\ttMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.y /= dir.y;\n\t\t\ttMax.y /= dir.y;\n\t\t}\n\n\t\tif (dir.z === 0) {\n\t\t\ttMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.z /= dir.z;\n\t\t\ttMax.z /= dir.z;\n\t\t}\n\n\t\tconst realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));\n\t\tconst realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));\n\t\tconst minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);\n\t\tconst maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);\n\t\tconst intersects = minMax >= maxMin && maxMin >= 0;\n\t\tif (intersects) point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);\n\t\treturn intersects;\n\t}\n\n\t_fastIntersectsRay(ray) {\n\t\tconst diff = tmpVecA$2;\n\t\tconst cross = tmpVecB$1;\n\t\tconst prod = tmpVecC;\n\t\tconst absDiff = tmpVecD;\n\t\tconst absDir = tmpVecE;\n\t\tconst rayDir = ray.direction;\n\t\tdiff.sub2(ray.origin, this.center);\n\t\tabsDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));\n\t\tprod.mul2(diff, rayDir);\n\t\tif (absDiff.x > this.halfExtents.x && prod.x >= 0) return false;\n\t\tif (absDiff.y > this.halfExtents.y && prod.y >= 0) return false;\n\t\tif (absDiff.z > this.halfExtents.z && prod.z >= 0) return false;\n\t\tabsDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));\n\t\tcross.cross(rayDir, diff);\n\t\tcross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));\n\t\tif (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) return false;\n\t\tif (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) return false;\n\t\tif (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) return false;\n\t\treturn true;\n\t}\n\n\tintersectsRay(ray, point) {\n\t\tif (point) {\n\t\t\treturn this._intersectsRay(ray, point);\n\t\t}\n\n\t\treturn this._fastIntersectsRay(ray);\n\t}\n\n\tsetMinMax(min, max) {\n\t\tthis.center.add2(max, min).mulScalar(0.5);\n\t\tthis.halfExtents.sub2(max, min).mulScalar(0.5);\n\t}\n\n\tgetMin() {\n\t\treturn this._min.copy(this.center).sub(this.halfExtents);\n\t}\n\n\tgetMax() {\n\t\treturn this._max.copy(this.center).add(this.halfExtents);\n\t}\n\n\tcontainsPoint(point) {\n\t\tconst min = this.getMin();\n\t\tconst max = this.getMax();\n\n\t\tif (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetFromTransformedAabb(aabb, m, ignoreScale = false) {\n\t\tconst ac = aabb.center;\n\t\tconst ar = aabb.halfExtents;\n\t\tconst d = m.data;\n\t\tlet mx0 = d[0];\n\t\tlet mx1 = d[4];\n\t\tlet mx2 = d[8];\n\t\tlet my0 = d[1];\n\t\tlet my1 = d[5];\n\t\tlet my2 = d[9];\n\t\tlet mz0 = d[2];\n\t\tlet mz1 = d[6];\n\t\tlet mz2 = d[10];\n\n\t\tif (ignoreScale) {\n\t\t\tlet lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;\n\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmx0 *= invLength;\n\t\t\t\tmx1 *= invLength;\n\t\t\t\tmx2 *= invLength;\n\t\t\t}\n\n\t\t\tlengthSq = my0 * my0 + my1 * my1 + my2 * my2;\n\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmy0 *= invLength;\n\t\t\t\tmy1 *= invLength;\n\t\t\t\tmy2 *= invLength;\n\t\t\t}\n\n\t\t\tlengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;\n\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmz0 *= invLength;\n\t\t\t\tmz1 *= invLength;\n\t\t\t\tmz2 *= invLength;\n\t\t\t}\n\t\t}\n\n\t\tthis.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);\n\t\tthis.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);\n\t}\n\n\tcompute(vertices, numVerts) {\n\t\tnumVerts = numVerts === undefined ? vertices.length / 3 : numVerts;\n\n\t\tif (numVerts > 0) {\n\t\t\tconst min = tmpVecA$2.set(vertices[0], vertices[1], vertices[2]);\n\t\t\tconst max = tmpVecB$1.set(vertices[0], vertices[1], vertices[2]);\n\n\t\t\tfor (let i = 1; i < numVerts; i++) {\n\t\t\t\tconst x = vertices[i * 3 + 0];\n\t\t\t\tconst y = vertices[i * 3 + 1];\n\t\t\t\tconst z = vertices[i * 3 + 2];\n\t\t\t\tif (x < min.x) min.x = x;\n\t\t\t\tif (y < min.y) min.y = y;\n\t\t\t\tif (z < min.z) min.z = z;\n\t\t\t\tif (x > max.x) max.x = x;\n\t\t\t\tif (y > max.y) max.y = y;\n\t\t\t\tif (z > max.z) max.z = z;\n\t\t\t}\n\n\t\t\tthis.setMinMax(min, max);\n\t\t}\n\t}\n\n\tintersectsBoundingSphere(sphere) {\n\t\tconst sq = this._distanceToBoundingSphereSq(sphere);\n\n\t\tif (sq <= sphere.radius * sphere.radius) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_distanceToBoundingSphereSq(sphere) {\n\t\tconst boxMin = this.getMin();\n\t\tconst boxMax = this.getMax();\n\t\tlet sq = 0;\n\t\tconst axis = ['x', 'y', 'z'];\n\n\t\tfor (let i = 0; i < 3; ++i) {\n\t\t\tlet out = 0;\n\t\t\tconst pn = sphere.center[axis[i]];\n\t\t\tconst bMin = boxMin[axis[i]];\n\t\t\tconst bMax = boxMax[axis[i]];\n\t\t\tlet val = 0;\n\n\t\t\tif (pn < bMin) {\n\t\t\t\tval = bMin - pn;\n\t\t\t\tout += val * val;\n\t\t\t}\n\n\t\t\tif (pn > bMax) {\n\t\t\t\tval = pn - bMax;\n\t\t\t\tout += val * val;\n\t\t\t}\n\n\t\t\tsq += out;\n\t\t}\n\n\t\treturn sq;\n\t}\n\n\t_expand(expandMin, expandMax) {\n\t\ttmpVecA$2.add2(this.getMin(), expandMin);\n\t\ttmpVecB$1.add2(this.getMax(), expandMax);\n\t\tthis.setMinMax(tmpVecA$2, tmpVecB$1);\n\t}\n\n}\n\nconst tmpVecA$1 = new Vec3();\nconst tmpVecB = new Vec3();\n\nclass BoundingSphere {\n\tconstructor(center = new Vec3(), radius = 0.5) {\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t}\n\n\tcontainsPoint(point) {\n\t\tconst lenSq = tmpVecA$1.sub2(point, this.center).lengthSq();\n\t\tconst r = this.radius;\n\t\treturn lenSq < r * r;\n\t}\n\n\tintersectsRay(ray, point) {\n\t\tconst m = tmpVecA$1.copy(ray.origin).sub(this.center);\n\t\tconst b = m.dot(tmpVecB.copy(ray.direction).normalize());\n\t\tconst c = m.dot(m) - this.radius * this.radius;\n\t\tif (c > 0 && b > 0) return false;\n\t\tconst discr = b * b - c;\n\t\tif (discr < 0) return false;\n\t\tconst t = Math.abs(-b - Math.sqrt(discr));\n\t\tif (point) point.copy(ray.direction).mulScalar(t).add(ray.origin);\n\t\treturn true;\n\t}\n\n\tintersectsBoundingSphere(sphere) {\n\t\ttmpVecA$1.sub2(sphere.center, this.center);\n\t\tconst totalRadius = sphere.radius + this.radius;\n\n\t\tif (tmpVecA$1.lengthSq() <= totalRadius * totalRadius) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nconst BLEND_SUBTRACTIVE = 0;\nconst BLEND_ADDITIVE = 1;\nconst BLEND_NORMAL = 2;\nconst BLEND_NONE = 3;\nconst BLEND_PREMULTIPLIED = 4;\nconst BLEND_MULTIPLICATIVE = 5;\nconst BLEND_ADDITIVEALPHA = 6;\nconst BLEND_MULTIPLICATIVE2X = 7;\nconst BLEND_SCREEN = 8;\nconst BLEND_MIN = 9;\nconst BLEND_MAX = 10;\nconst FOG_NONE = 'none';\nconst FOG_LINEAR = 'linear';\nconst FOG_EXP = 'exp';\nconst FOG_EXP2 = 'exp2';\nconst FRESNEL_NONE = 0;\nconst FRESNEL_SCHLICK = 2;\nconst LAYER_HUD = 0;\nconst LAYER_GIZMO = 1;\nconst LAYER_FX = 2;\nconst LAYER_WORLD = 15;\nconst LAYERID_WORLD = 0;\nconst LAYERID_DEPTH = 1;\nconst LAYERID_SKYBOX = 2;\nconst LAYERID_IMMEDIATE = 3;\nconst LAYERID_UI = 4;\nconst LIGHTTYPE_DIRECTIONAL = 0;\nconst LIGHTTYPE_OMNI = 1;\nconst LIGHTTYPE_POINT = LIGHTTYPE_OMNI;\nconst LIGHTTYPE_SPOT = 2;\nconst LIGHTSHAPE_PUNCTUAL = 0;\nconst LIGHTSHAPE_RECT = 1;\nconst LIGHTSHAPE_DISK = 2;\nconst LIGHTSHAPE_SPHERE = 3;\nconst LIGHTFALLOFF_LINEAR = 0;\nconst LIGHTFALLOFF_INVERSESQUARED = 1;\nconst SHADOW_PCF3 = 0;\nconst SHADOW_DEPTH = 0;\nconst SHADOW_VSM8 = 1;\nconst SHADOW_VSM16 = 2;\nconst SHADOW_VSM32 = 3;\nconst SHADOW_PCF5 = 4;\nconst SHADOW_PCF1 = 5;\nconst SHADOW_COUNT = 6;\nconst shadowTypeToString = {};\nshadowTypeToString[SHADOW_PCF3] = \"PCF3\";\nshadowTypeToString[SHADOW_VSM8] = \"VSM8\";\nshadowTypeToString[SHADOW_VSM16] = \"VSM16\";\nshadowTypeToString[SHADOW_VSM32] = \"VSM32\";\nshadowTypeToString[SHADOW_PCF5] = \"PCF5\";\nshadowTypeToString[SHADOW_PCF1] = \"PCF1\";\nconst BLUR_BOX = 0;\nconst BLUR_GAUSSIAN = 1;\nconst PARTICLESORT_NONE = 0;\nconst PARTICLESORT_DISTANCE = 1;\nconst PARTICLESORT_NEWER_FIRST = 2;\nconst PARTICLESORT_OLDER_FIRST = 3;\nconst PARTICLEMODE_GPU = 0;\nconst PARTICLEMODE_CPU = 1;\nconst EMITTERSHAPE_BOX = 0;\nconst EMITTERSHAPE_SPHERE = 1;\nconst PARTICLEORIENTATION_SCREEN = 0;\nconst PARTICLEORIENTATION_WORLD = 1;\nconst PARTICLEORIENTATION_EMITTER = 2;\nconst PROJECTION_PERSPECTIVE = 0;\nconst PROJECTION_ORTHOGRAPHIC = 1;\nconst RENDERSTYLE_SOLID = 0;\nconst RENDERSTYLE_WIREFRAME = 1;\nconst RENDERSTYLE_POINTS = 2;\nconst CUBEPROJ_NONE = 0;\nconst CUBEPROJ_BOX = 1;\nconst SPECULAR_PHONG = 0;\nconst SPECULAR_BLINN = 1;\nconst DETAILMODE_MUL = 'mul';\nconst DETAILMODE_ADD = 'add';\nconst DETAILMODE_SCREEN = 'screen';\nconst DETAILMODE_OVERLAY = 'overlay';\nconst DETAILMODE_MIN = 'min';\nconst DETAILMODE_MAX = 'max';\nconst GAMMA_NONE = 0;\nconst GAMMA_SRGB = 1;\nconst GAMMA_SRGBFAST = 2;\nconst GAMMA_SRGBHDR = 3;\nconst TONEMAP_LINEAR = 0;\nconst TONEMAP_FILMIC = 1;\nconst TONEMAP_HEJL = 2;\nconst TONEMAP_ACES = 3;\nconst TONEMAP_ACES2 = 4;\nconst SPECOCC_NONE = 0;\nconst SPECOCC_AO = 1;\nconst SPECOCC_GLOSSDEPENDENT = 2;\nconst SHADERDEF_NOSHADOW = 1;\nconst SHADERDEF_SKIN = 2;\nconst SHADERDEF_UV0 = 4;\nconst SHADERDEF_UV1 = 8;\nconst SHADERDEF_VCOLOR = 16;\nconst SHADERDEF_INSTANCING = 32;\nconst SHADERDEF_LM = 64;\nconst SHADERDEF_DIRLM = 128;\nconst SHADERDEF_SCREENSPACE = 256;\nconst SHADERDEF_TANGENTS = 512;\nconst SHADERDEF_MORPH_POSITION = 1024;\nconst SHADERDEF_MORPH_NORMAL = 2048;\nconst SHADERDEF_MORPH_TEXTURE_BASED = 4096;\nconst SHADERDEF_LMAMBIENT = 8192;\nconst LINEBATCH_WORLD = 0;\nconst LINEBATCH_OVERLAY = 1;\nconst LINEBATCH_GIZMO = 2;\nconst SHADOWUPDATE_NONE = 0;\nconst SHADOWUPDATE_THISFRAME = 1;\nconst SHADOWUPDATE_REALTIME = 2;\nconst SORTKEY_FORWARD = 0;\nconst SORTKEY_DEPTH = 1;\nconst MASK_AFFECT_DYNAMIC = 1;\nconst MASK_AFFECT_LIGHTMAPPED = 2;\nconst MASK_BAKE = 4;\nconst SHADER_FORWARD = 0;\nconst SHADER_FORWARDHDR = 1;\nconst SHADER_DEPTH = 2;\nconst SHADER_SHADOW = 3;\nconst SHADER_PICK = 18;\nconst SPRITE_RENDERMODE_SIMPLE = 0;\nconst SPRITE_RENDERMODE_SLICED = 1;\nconst SPRITE_RENDERMODE_TILED = 2;\nconst BAKE_COLOR = 0;\nconst BAKE_COLORDIR = 1;\nconst VIEW_CENTER = 0;\nconst VIEW_LEFT = 1;\nconst VIEW_RIGHT = 2;\nconst SORTMODE_NONE = 0;\nconst SORTMODE_MANUAL = 1;\nconst SORTMODE_MATERIALMESH = 2;\nconst SORTMODE_BACK2FRONT = 3;\nconst SORTMODE_FRONT2BACK = 4;\nconst SORTMODE_CUSTOM = 5;\nconst COMPUPDATED_INSTANCES = 1;\nconst COMPUPDATED_LIGHTS = 2;\nconst COMPUPDATED_CAMERAS = 4;\nconst COMPUPDATED_BLEND = 8;\nconst ASPECT_AUTO = 0;\nconst ASPECT_MANUAL = 1;\nconst ORIENTATION_HORIZONTAL = 0;\nconst ORIENTATION_VERTICAL = 1;\n\nconst _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\nclass Frustum {\n\tconstructor() {\n\t\tthis.planes = [];\n\n\t\tfor (let i = 0; i < 6; i++) this.planes[i] = [];\n\t}\n\n\tsetFromMat4(matrix) {\n\t\tconst vpm = matrix.data;\n\t\tlet plane;\n\t\tconst planes = this.planes;\n\t\tplane = planes[0];\n\t\tplane[0] = vpm[3] - vpm[0];\n\t\tplane[1] = vpm[7] - vpm[4];\n\t\tplane[2] = vpm[11] - vpm[8];\n\t\tplane[3] = vpm[15] - vpm[12];\n\t\tlet t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[1];\n\t\tplane[0] = vpm[3] + vpm[0];\n\t\tplane[1] = vpm[7] + vpm[4];\n\t\tplane[2] = vpm[11] + vpm[8];\n\t\tplane[3] = vpm[15] + vpm[12];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[2];\n\t\tplane[0] = vpm[3] + vpm[1];\n\t\tplane[1] = vpm[7] + vpm[5];\n\t\tplane[2] = vpm[11] + vpm[9];\n\t\tplane[3] = vpm[15] + vpm[13];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[3];\n\t\tplane[0] = vpm[3] - vpm[1];\n\t\tplane[1] = vpm[7] - vpm[5];\n\t\tplane[2] = vpm[11] - vpm[9];\n\t\tplane[3] = vpm[15] - vpm[13];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[4];\n\t\tplane[0] = vpm[3] - vpm[2];\n\t\tplane[1] = vpm[7] - vpm[6];\n\t\tplane[2] = vpm[11] - vpm[10];\n\t\tplane[3] = vpm[15] - vpm[14];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[5];\n\t\tplane[0] = vpm[3] + vpm[2];\n\t\tplane[1] = vpm[7] + vpm[6];\n\t\tplane[2] = vpm[11] + vpm[10];\n\t\tplane[3] = vpm[15] + vpm[14];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t}\n\n\tcontainsPoint(point) {\n\t\tlet p, plane;\n\n\t\tfor (p = 0; p < 6; p++) {\n\t\t\tplane = this.planes[p];\n\n\t\t\tif (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tcontainsSphere(sphere) {\n\t\tlet c = 0;\n\t\tlet d;\n\t\tlet p;\n\t\tconst sr = sphere.radius;\n\t\tconst sc = sphere.center;\n\t\tconst scx = sc.x;\n\t\tconst scy = sc.y;\n\t\tconst scz = sc.z;\n\t\tconst planes = this.planes;\n\t\tlet plane;\n\n\t\tfor (p = 0; p < 6; p++) {\n\t\t\tplane = planes[p];\n\t\t\td = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];\n\t\t\tif (d <= -sr) return 0;\n\t\t\tif (d > sr) c++;\n\t\t}\n\n\t\treturn c === 6 ? 2 : 1;\n\t}\n\n\tstatic getPoints(camera, near, far) {\n\t\tnear = near || camera._nearClip;\n\t\tfar = far || camera._farClip;\n\t\tconst fov = camera._fov * Math.PI / 180.0;\n\t\tlet y = camera._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : camera._orthoHeight;\n\t\tlet x = y * camera._aspectRatio;\n\t\tconst points = _frustumPoints;\n\t\tpoints[0].x = x;\n\t\tpoints[0].y = -y;\n\t\tpoints[0].z = -near;\n\t\tpoints[1].x = x;\n\t\tpoints[1].y = y;\n\t\tpoints[1].z = -near;\n\t\tpoints[2].x = -x;\n\t\tpoints[2].y = y;\n\t\tpoints[2].z = -near;\n\t\tpoints[3].x = -x;\n\t\tpoints[3].y = -y;\n\t\tpoints[3].z = -near;\n\n\t\tif (camera._projection === PROJECTION_PERSPECTIVE) {\n\t\t\ty = Math.tan(fov / 2.0) * far;\n\t\t\tx = y * camera._aspectRatio;\n\t\t}\n\n\t\tpoints[4].x = x;\n\t\tpoints[4].y = -y;\n\t\tpoints[4].z = -far;\n\t\tpoints[5].x = x;\n\t\tpoints[5].y = y;\n\t\tpoints[5].z = -far;\n\t\tpoints[6].x = -x;\n\t\tpoints[6].y = y;\n\t\tpoints[6].z = -far;\n\t\tpoints[7].x = -x;\n\t\tpoints[7].y = -y;\n\t\tpoints[7].z = -far;\n\t\treturn points;\n\t}\n\n}\n\nclass Ray {\n\tconstructor(origin = new Vec3(), direction = new Vec3(0, 0, -1)) {\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\t}\n\n\tset(origin, direction) {\n\t\tthis.origin.copy(origin);\n\t\tthis.direction.copy(direction);\n\t\treturn this;\n\t}\n\n}\n\nconst tmpRay = new Ray();\nconst tmpVec3$2 = new Vec3();\nconst tmpSphere = new BoundingSphere();\nconst tmpMat4$1 = new Mat4();\n\nclass OrientedBox {\n\tconstructor(worldTransform = new Mat4(), halfExtents = new Vec3(0.5, 0.5, 0.5)) {\n\t\tthis.halfExtents = halfExtents;\n\t\tthis._modelTransform = worldTransform.clone().invert();\n\t\tthis._worldTransform = worldTransform.clone();\n\t\tthis._aabb = new BoundingBox(new Vec3(), this.halfExtents);\n\t}\n\n\tset worldTransform(value) {\n\t\tthis._worldTransform.copy(value);\n\n\t\tthis._modelTransform.copy(value).invert();\n\t}\n\n\tget worldTransform() {\n\t\treturn this._worldTransform;\n\t}\n\n\tintersectsRay(ray, point) {\n\t\tthis._modelTransform.transformPoint(ray.origin, tmpRay.origin);\n\n\t\tthis._modelTransform.transformVector(ray.direction, tmpRay.direction);\n\n\t\tif (point) {\n\t\t\tconst result = this._aabb._intersectsRay(tmpRay, point);\n\n\t\t\ttmpMat4$1.copy(this._modelTransform).invert().transformPoint(point, point);\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this._aabb._fastIntersectsRay(tmpRay);\n\t}\n\n\tcontainsPoint(point) {\n\t\tthis._modelTransform.transformPoint(point, tmpVec3$2);\n\n\t\treturn this._aabb.containsPoint(tmpVec3$2);\n\t}\n\n\tintersectsBoundingSphere(sphere) {\n\t\tthis._modelTransform.transformPoint(sphere.center, tmpSphere.center);\n\n\t\ttmpSphere.radius = sphere.radius;\n\n\t\tif (this._aabb.intersectsBoundingSphere(tmpSphere)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nconst tmpVecA = new Vec3();\n\nclass Plane {\n\tconstructor(point = new Vec3(), normal = new Vec3(0, 0, 1)) {\n\t\tthis.normal = normal;\n\t\tthis.point = point;\n\t}\n\n\tintersectsLine(start, end, point) {\n\t\tconst d = -this.normal.dot(this.point);\n\t\tconst d0 = this.normal.dot(start) + d;\n\t\tconst d1 = this.normal.dot(end) + d;\n\t\tconst t = d0 / (d0 - d1);\n\t\tconst intersects = t >= 0 && t <= 1;\n\t\tif (intersects && point) point.lerp(start, end, t);\n\t\treturn intersects;\n\t}\n\n\tintersectsRay(ray, point) {\n\t\tconst pointToOrigin = tmpVecA.sub2(this.point, ray.origin);\n\t\tconst t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);\n\t\tconst intersects = t >= 0;\n\t\tif (intersects && point) point.copy(ray.direction).mulScalar(t).add(ray.origin);\n\t\treturn intersects;\n\t}\n\n}\n\nconst ADDRESS_REPEAT = 0;\nconst ADDRESS_CLAMP_TO_EDGE = 1;\nconst ADDRESS_MIRRORED_REPEAT = 2;\nconst BLENDMODE_ZERO = 0;\nconst BLENDMODE_ONE = 1;\nconst BLENDMODE_SRC_COLOR = 2;\nconst BLENDMODE_ONE_MINUS_SRC_COLOR = 3;\nconst BLENDMODE_DST_COLOR = 4;\nconst BLENDMODE_ONE_MINUS_DST_COLOR = 5;\nconst BLENDMODE_SRC_ALPHA = 6;\nconst BLENDMODE_SRC_ALPHA_SATURATE = 7;\nconst BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;\nconst BLENDMODE_DST_ALPHA = 9;\nconst BLENDMODE_ONE_MINUS_DST_ALPHA = 10;\nconst BLENDEQUATION_ADD = 0;\nconst BLENDEQUATION_SUBTRACT = 1;\nconst BLENDEQUATION_REVERSE_SUBTRACT = 2;\nconst BLENDEQUATION_MIN = 3;\nconst BLENDEQUATION_MAX = 4;\nconst BUFFER_STATIC = 0;\nconst BUFFER_DYNAMIC = 1;\nconst BUFFER_STREAM = 2;\nconst BUFFER_GPUDYNAMIC = 3;\nconst CLEARFLAG_COLOR = 1;\nconst CLEARFLAG_DEPTH = 2;\nconst CLEARFLAG_STENCIL = 4;\nconst CUBEFACE_POSX = 0;\nconst CUBEFACE_NEGX = 1;\nconst CUBEFACE_POSY = 2;\nconst CUBEFACE_NEGY = 3;\nconst CUBEFACE_POSZ = 4;\nconst CUBEFACE_NEGZ = 5;\nconst CULLFACE_NONE = 0;\nconst CULLFACE_BACK = 1;\nconst CULLFACE_FRONT = 2;\nconst CULLFACE_FRONTANDBACK = 3;\nconst FILTER_NEAREST = 0;\nconst FILTER_LINEAR = 1;\nconst FILTER_NEAREST_MIPMAP_NEAREST = 2;\nconst FILTER_NEAREST_MIPMAP_LINEAR = 3;\nconst FILTER_LINEAR_MIPMAP_NEAREST = 4;\nconst FILTER_LINEAR_MIPMAP_LINEAR = 5;\nconst FUNC_NEVER = 0;\nconst FUNC_LESS = 1;\nconst FUNC_EQUAL = 2;\nconst FUNC_LESSEQUAL = 3;\nconst FUNC_GREATER = 4;\nconst FUNC_NOTEQUAL = 5;\nconst FUNC_GREATEREQUAL = 6;\nconst FUNC_ALWAYS = 7;\nconst INDEXFORMAT_UINT8 = 0;\nconst INDEXFORMAT_UINT16 = 1;\nconst INDEXFORMAT_UINT32 = 2;\nconst PIXELFORMAT_A8 = 0;\nconst PIXELFORMAT_L8 = 1;\nconst PIXELFORMAT_L8_A8 = 2;\nconst PIXELFORMAT_R5_G6_B5 = 3;\nconst PIXELFORMAT_R5_G5_B5_A1 = 4;\nconst PIXELFORMAT_R4_G4_B4_A4 = 5;\nconst PIXELFORMAT_R8_G8_B8 = 6;\nconst PIXELFORMAT_R8_G8_B8_A8 = 7;\nconst PIXELFORMAT_DXT1 = 8;\nconst PIXELFORMAT_DXT3 = 9;\nconst PIXELFORMAT_DXT5 = 10;\nconst PIXELFORMAT_RGB16F = 11;\nconst PIXELFORMAT_RGBA16F = 12;\nconst PIXELFORMAT_RGB32F = 13;\nconst PIXELFORMAT_RGBA32F = 14;\nconst PIXELFORMAT_R32F = 15;\nconst PIXELFORMAT_DEPTH = 16;\nconst PIXELFORMAT_DEPTHSTENCIL = 17;\nconst PIXELFORMAT_111110F = 18;\nconst PIXELFORMAT_SRGB = 19;\nconst PIXELFORMAT_SRGBA = 20;\nconst PIXELFORMAT_ETC1 = 21;\nconst PIXELFORMAT_ETC2_RGB = 22;\nconst PIXELFORMAT_ETC2_RGBA = 23;\nconst PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;\nconst PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;\nconst PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;\nconst PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;\nconst PIXELFORMAT_ASTC_4x4 = 28;\nconst PIXELFORMAT_ATC_RGB = 29;\nconst PIXELFORMAT_ATC_RGBA = 30;\nconst PRIMITIVE_POINTS = 0;\nconst PRIMITIVE_LINES = 1;\nconst PRIMITIVE_LINELOOP = 2;\nconst PRIMITIVE_LINESTRIP = 3;\nconst PRIMITIVE_TRIANGLES = 4;\nconst PRIMITIVE_TRISTRIP = 5;\nconst PRIMITIVE_TRIFAN = 6;\nconst SEMANTIC_POSITION = \"POSITION\";\nconst SEMANTIC_NORMAL = \"NORMAL\";\nconst SEMANTIC_TANGENT = \"TANGENT\";\nconst SEMANTIC_BLENDWEIGHT = \"BLENDWEIGHT\";\nconst SEMANTIC_BLENDINDICES = \"BLENDINDICES\";\nconst SEMANTIC_COLOR = \"COLOR\";\nconst SEMANTIC_TEXCOORD = \"TEXCOORD\";\nconst SEMANTIC_TEXCOORD0 = \"TEXCOORD0\";\nconst SEMANTIC_TEXCOORD1 = \"TEXCOORD1\";\nconst SEMANTIC_TEXCOORD2 = \"TEXCOORD2\";\nconst SEMANTIC_TEXCOORD3 = \"TEXCOORD3\";\nconst SEMANTIC_TEXCOORD4 = \"TEXCOORD4\";\nconst SEMANTIC_TEXCOORD5 = \"TEXCOORD5\";\nconst SEMANTIC_TEXCOORD6 = \"TEXCOORD6\";\nconst SEMANTIC_TEXCOORD7 = \"TEXCOORD7\";\nconst SEMANTIC_ATTR = \"ATTR\";\nconst SEMANTIC_ATTR0 = \"ATTR0\";\nconst SEMANTIC_ATTR1 = \"ATTR1\";\nconst SEMANTIC_ATTR2 = \"ATTR2\";\nconst SEMANTIC_ATTR3 = \"ATTR3\";\nconst SEMANTIC_ATTR4 = \"ATTR4\";\nconst SEMANTIC_ATTR5 = \"ATTR5\";\nconst SEMANTIC_ATTR6 = \"ATTR6\";\nconst SEMANTIC_ATTR7 = \"ATTR7\";\nconst SEMANTIC_ATTR8 = \"ATTR8\";\nconst SEMANTIC_ATTR9 = \"ATTR9\";\nconst SEMANTIC_ATTR10 = \"ATTR10\";\nconst SEMANTIC_ATTR11 = \"ATTR11\";\nconst SEMANTIC_ATTR12 = \"ATTR12\";\nconst SEMANTIC_ATTR13 = \"ATTR13\";\nconst SEMANTIC_ATTR14 = \"ATTR14\";\nconst SEMANTIC_ATTR15 = \"ATTR15\";\nconst SHADERTAG_MATERIAL = 1;\nconst STENCILOP_KEEP = 0;\nconst STENCILOP_ZERO = 1;\nconst STENCILOP_REPLACE = 2;\nconst STENCILOP_INCREMENT = 3;\nconst STENCILOP_INCREMENTWRAP = 4;\nconst STENCILOP_DECREMENT = 5;\nconst STENCILOP_DECREMENTWRAP = 6;\nconst STENCILOP_INVERT = 7;\nconst TEXTURELOCK_READ = 1;\nconst TEXTURELOCK_WRITE = 2;\nconst TEXTURETYPE_DEFAULT = 'default';\nconst TEXTURETYPE_RGBM = 'rgbm';\nconst TEXTURETYPE_RGBE = 'rgbe';\nconst TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';\nconst TEXHINT_NONE = 0;\nconst TEXHINT_SHADOWMAP = 1;\nconst TEXHINT_ASSET = 2;\nconst TEXHINT_LIGHTMAP = 3;\nconst TEXTUREPROJECTION_NONE = \"none\";\nconst TEXTUREPROJECTION_CUBE = \"cube\";\nconst TEXTUREPROJECTION_EQUIRECT = \"equirect\";\nconst TEXTUREPROJECTION_OCTAHEDRAL = \"octahedral\";\nconst TYPE_INT8 = 0;\nconst TYPE_UINT8 = 1;\nconst TYPE_INT16 = 2;\nconst TYPE_UINT16 = 3;\nconst TYPE_INT32 = 4;\nconst TYPE_UINT32 = 5;\nconst TYPE_FLOAT32 = 6;\nconst UNIFORMTYPE_BOOL = 0;\nconst UNIFORMTYPE_INT = 1;\nconst UNIFORMTYPE_FLOAT = 2;\nconst UNIFORMTYPE_VEC2 = 3;\nconst UNIFORMTYPE_VEC3 = 4;\nconst UNIFORMTYPE_VEC4 = 5;\nconst UNIFORMTYPE_IVEC2 = 6;\nconst UNIFORMTYPE_IVEC3 = 7;\nconst UNIFORMTYPE_IVEC4 = 8;\nconst UNIFORMTYPE_BVEC2 = 9;\nconst UNIFORMTYPE_BVEC3 = 10;\nconst UNIFORMTYPE_BVEC4 = 11;\nconst UNIFORMTYPE_MAT2 = 12;\nconst UNIFORMTYPE_MAT3 = 13;\nconst UNIFORMTYPE_MAT4 = 14;\nconst UNIFORMTYPE_TEXTURE2D = 15;\nconst UNIFORMTYPE_TEXTURECUBE = 16;\nconst UNIFORMTYPE_FLOATARRAY = 17;\nconst UNIFORMTYPE_TEXTURE2D_SHADOW = 18;\nconst UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;\nconst UNIFORMTYPE_TEXTURE3D = 20;\nconst UNIFORMTYPE_VEC2ARRAY = 21;\nconst UNIFORMTYPE_VEC3ARRAY = 22;\nconst UNIFORMTYPE_VEC4ARRAY = 23;\nconst typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];\nconst typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];\nconst typedArrayToType = {\n\t\"Int8Array\": TYPE_INT8,\n\t\"Uint8Array\": TYPE_UINT8,\n\t\"Int16Array\": TYPE_INT16,\n\t\"Uint16Array\": TYPE_UINT16,\n\t\"Int32Array\": TYPE_INT32,\n\t\"Uint32Array\": TYPE_UINT32,\n\t\"Float32Array\": TYPE_FLOAT32\n};\nconst typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];\nconst typedArrayIndexFormatsByteSize = [1, 2, 4];\nconst semanticToLocation = {};\nsemanticToLocation[SEMANTIC_POSITION] = 0;\nsemanticToLocation[SEMANTIC_NORMAL] = 1;\nsemanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;\nsemanticToLocation[SEMANTIC_BLENDINDICES] = 3;\nsemanticToLocation[SEMANTIC_COLOR] = 4;\nsemanticToLocation[SEMANTIC_TEXCOORD0] = 5;\nsemanticToLocation[SEMANTIC_TEXCOORD1] = 6;\nsemanticToLocation[SEMANTIC_TEXCOORD2] = 7;\nsemanticToLocation[SEMANTIC_TEXCOORD3] = 8;\nsemanticToLocation[SEMANTIC_TEXCOORD4] = 9;\nsemanticToLocation[SEMANTIC_TEXCOORD5] = 10;\nsemanticToLocation[SEMANTIC_TEXCOORD6] = 11;\nsemanticToLocation[SEMANTIC_TEXCOORD7] = 12;\nsemanticToLocation[SEMANTIC_TANGENT] = 13;\nsemanticToLocation[SEMANTIC_ATTR0] = 0;\nsemanticToLocation[SEMANTIC_ATTR1] = 1;\nsemanticToLocation[SEMANTIC_ATTR2] = 2;\nsemanticToLocation[SEMANTIC_ATTR3] = 3;\nsemanticToLocation[SEMANTIC_ATTR4] = 4;\nsemanticToLocation[SEMANTIC_ATTR5] = 5;\nsemanticToLocation[SEMANTIC_ATTR6] = 6;\nsemanticToLocation[SEMANTIC_ATTR7] = 7;\nsemanticToLocation[SEMANTIC_ATTR8] = 8;\nsemanticToLocation[SEMANTIC_ATTR9] = 9;\nsemanticToLocation[SEMANTIC_ATTR10] = 10;\nsemanticToLocation[SEMANTIC_ATTR11] = 11;\nsemanticToLocation[SEMANTIC_ATTR12] = 12;\nsemanticToLocation[SEMANTIC_ATTR13] = 13;\nsemanticToLocation[SEMANTIC_ATTR14] = 14;\nsemanticToLocation[SEMANTIC_ATTR15] = 15;\n\nlet id$3 = 0;\n\nclass VertexBuffer {\n\tconstructor(graphicsDevice, format, numVertices, usage = BUFFER_STATIC, initialData) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.format = format;\n\t\tthis.numVertices = numVertices;\n\t\tthis.usage = usage;\n\t\tthis.id = id$3++;\n\t\tthis._vao = null;\n\t\tthis.instancing = false;\n\t\tthis.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;\n\t\tgraphicsDevice._vram.vb += this.numBytes;\n\n\t\tif (initialData) {\n\t\t\tthis.setData(initialData);\n\t\t} else {\n\t\t\tthis.storage = new ArrayBuffer(this.numBytes);\n\t\t}\n\n\t\tthis.device.buffers.push(this);\n\t}\n\n\tdestroy() {\n\t\tconst device = this.device;\n\t\tconst idx = device.buffers.indexOf(this);\n\n\t\tif (idx !== -1) {\n\t\t\tdevice.buffers.splice(idx, 1);\n\t\t}\n\n\t\tif (this.bufferId) {\n\t\t\tconst gl = device.gl;\n\t\t\tdevice.boundVao = null;\n\t\t\tgl.bindVertexArray(null);\n\t\t\tgl.deleteBuffer(this.bufferId);\n\t\t\tdevice._vram.vb -= this.storage.byteLength;\n\t\t\tthis.bufferId = null;\n\t\t}\n\t}\n\n\tloseContext() {\n\t\tthis.bufferId = undefined;\n\t\tthis._vao = null;\n\t}\n\n\tgetFormat() {\n\t\treturn this.format;\n\t}\n\n\tgetUsage() {\n\t\treturn this.usage;\n\t}\n\n\tgetNumVertices() {\n\t\treturn this.numVertices;\n\t}\n\n\tlock() {\n\t\treturn this.storage;\n\t}\n\n\tunlock() {\n\t\tconst gl = this.device.gl;\n\n\t\tif (!this.bufferId) {\n\t\t\tthis.bufferId = gl.createBuffer();\n\t\t}\n\n\t\tlet glUsage;\n\n\t\tswitch (this.usage) {\n\t\t\tcase BUFFER_STATIC:\n\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_DYNAMIC:\n\t\t\t\tglUsage = gl.DYNAMIC_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_STREAM:\n\t\t\t\tglUsage = gl.STREAM_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_GPUDYNAMIC:\n\t\t\t\tif (this.device.webgl2) {\n\t\t\t\t\tglUsage = gl.DYNAMIC_COPY;\n\t\t\t\t} else {\n\t\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.bufferId);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, this.storage, glUsage);\n\t}\n\n\tsetData(data) {\n\t\tif (data.byteLength !== this.numBytes) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.storage = data;\n\t\tthis.unlock();\n\t\treturn true;\n\t}\n\n}\n\nfunction hashCode(str) {\n\tlet hash = 0;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\thash = (hash << 5) - hash + str.charCodeAt(i);\n\t\thash |= 0;\n\t}\n\n\treturn hash;\n}\n\nclass VertexFormat {\n\tconstructor(graphicsDevice, description, vertexCount) {\n\t\tthis.elements = [];\n\t\tthis.hasUv0 = false;\n\t\tthis.hasUv1 = false;\n\t\tthis.hasColor = false;\n\t\tthis.hasTangents = false;\n\t\tthis.verticesByteSize = 0;\n\t\tthis.vertexCount = vertexCount;\n\t\tthis.interleaved = vertexCount === undefined;\n\t\tthis.size = description.reduce((total, desc) => {\n\t\t\treturn total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;\n\t\t}, 0);\n\t\tlet offset = 0,\n\t\t\t\telementSize;\n\n\t\tfor (let i = 0, len = description.length; i < len; i++) {\n\t\t\tconst elementDesc = description[i];\n\t\t\telementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];\n\n\t\t\tif (vertexCount) {\n\t\t\t\toffset = math.roundUp(offset, elementSize);\n\t\t\t}\n\n\t\t\tconst element = {\n\t\t\t\tname: elementDesc.semantic,\n\t\t\t\toffset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,\n\t\t\t\tstride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,\n\t\t\t\tdataType: elementDesc.type,\n\t\t\t\tnumComponents: elementDesc.components,\n\t\t\t\tnormalize: elementDesc.normalize === undefined ? false : elementDesc.normalize,\n\t\t\t\tsize: elementSize\n\t\t\t};\n\t\t\tthis.elements.push(element);\n\n\t\t\tif (vertexCount) {\n\t\t\t\toffset += elementSize * vertexCount;\n\t\t\t} else {\n\t\t\t\toffset += Math.ceil(elementSize / 4) * 4;\n\t\t\t}\n\n\t\t\tif (elementDesc.semantic === SEMANTIC_TEXCOORD0) {\n\t\t\t\tthis.hasUv0 = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {\n\t\t\t\tthis.hasUv1 = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_COLOR) {\n\t\t\t\tthis.hasColor = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_TANGENT) {\n\t\t\t\tthis.hasTangents = true;\n\t\t\t}\n\t\t}\n\n\t\tif (vertexCount) {\n\t\t\tthis.verticesByteSize = offset;\n\t\t}\n\n\t\tthis.update();\n\t}\n\n\tstatic init(graphicsDevice) {\n\t\tconst formatDesc = [{\n\t\t\tsemantic: SEMANTIC_ATTR12,\n\t\t\tcomponents: 4,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_ATTR13,\n\t\t\tcomponents: 4,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_ATTR14,\n\t\t\tcomponents: 4,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_ATTR15,\n\t\t\tcomponents: 4,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}];\n\t\tVertexFormat._defaultInstancingFormat = new VertexFormat(graphicsDevice, formatDesc);\n\t}\n\n\tstatic get defaultInstancingFormat() {\n\t\treturn VertexFormat._defaultInstancingFormat;\n\t}\n\n\tupdate() {\n\t\tthis._evaluateHash();\n\t}\n\n\t_evaluateHash() {\n\t\tlet stringElementBatch;\n\t\tconst stringElementsBatch = [];\n\t\tlet stringElementRender;\n\t\tconst stringElementsRender = [];\n\t\tconst len = this.elements.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst element = this.elements[i];\n\t\t\tstringElementBatch = element.name;\n\t\t\tstringElementBatch += element.dataType;\n\t\t\tstringElementBatch += element.numComponents;\n\t\t\tstringElementBatch += element.normalize;\n\t\t\tstringElementsBatch.push(stringElementBatch);\n\t\t\tstringElementRender = stringElementBatch;\n\t\t\tstringElementRender += element.offset;\n\t\t\tstringElementRender += element.stride;\n\t\t\tstringElementRender += element.size;\n\t\t\tstringElementsRender.push(stringElementRender);\n\t\t}\n\n\t\tstringElementsBatch.sort();\n\t\tthis.batchingHash = hashCode(stringElementsBatch.join());\n\t\tthis.renderingingHash = hashCode(stringElementsRender.join());\n\t}\n\n}\n\nVertexFormat._defaultInstancingFormat = null;\n\nlet _postEffectQuadVB = null;\nconst _postEffectQuadDraw = {\n\ttype: PRIMITIVE_TRISTRIP,\n\tbase: 0,\n\tcount: 4,\n\tindexed: false\n};\n\nfunction drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend = false) {\n\tif (_postEffectQuadVB === null) {\n\t\tconst vertexFormat = new VertexFormat(device, [{\n\t\t\tsemantic: SEMANTIC_POSITION,\n\t\t\tcomponents: 2,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}]);\n\t\tconst positions = new Float32Array(8);\n\t\tpositions.set([-1, -1, 1, -1, -1, 1, 1, 1]);\n\t\t_postEffectQuadVB = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, positions);\n\t}\n\n\tconst oldRt = device.renderTarget;\n\tdevice.setRenderTarget(target);\n\tdevice.updateBegin();\n\tlet x, y, w, h;\n\tlet sx, sy, sw, sh;\n\n\tif (!rect) {\n\t\tw = target ? target.width : device.width;\n\t\th = target ? target.height : device.height;\n\t\tx = 0;\n\t\ty = 0;\n\t} else {\n\t\tx = rect.x;\n\t\ty = rect.y;\n\t\tw = rect.z;\n\t\th = rect.w;\n\t}\n\n\tif (!scissorRect) {\n\t\tsx = x;\n\t\tsy = y;\n\t\tsw = w;\n\t\tsh = h;\n\t} else {\n\t\tsx = scissorRect.x;\n\t\tsy = scissorRect.y;\n\t\tsw = scissorRect.z;\n\t\tsh = scissorRect.w;\n\t}\n\n\tconst oldVx = device.vx;\n\tconst oldVy = device.vy;\n\tconst oldVw = device.vw;\n\tconst oldVh = device.vh;\n\tdevice.setViewport(x, y, w, h);\n\tconst oldSx = device.sx;\n\tconst oldSy = device.sy;\n\tconst oldSw = device.sw;\n\tconst oldSh = device.sh;\n\tdevice.setScissor(sx, sy, sw, sh);\n\tconst oldDepthTest = device.getDepthTest();\n\tconst oldDepthWrite = device.getDepthWrite();\n\tconst oldCullMode = device.getCullMode();\n\tconst oldWR = device.writeRed;\n\tconst oldWG = device.writeGreen;\n\tconst oldWB = device.writeBlue;\n\tconst oldWA = device.writeAlpha;\n\tdevice.setDepthTest(false);\n\tdevice.setDepthWrite(false);\n\tdevice.setCullMode(CULLFACE_NONE);\n\tdevice.setColorWrite(true, true, true, true);\n\tif (!useBlend) device.setBlending(false);\n\tdevice.setVertexBuffer(_postEffectQuadVB, 0);\n\tdevice.setShader(shader);\n\tdevice.draw(_postEffectQuadDraw);\n\tdevice.setDepthTest(oldDepthTest);\n\tdevice.setDepthWrite(oldDepthWrite);\n\tdevice.setCullMode(oldCullMode);\n\tdevice.setColorWrite(oldWR, oldWG, oldWB, oldWA);\n\tdevice.updateEnd();\n\tdevice.setRenderTarget(oldRt);\n\tdevice.updateBegin();\n\tdevice.setViewport(oldVx, oldVy, oldVw, oldVh);\n\tdevice.setScissor(oldSx, oldSy, oldSw, oldSh);\n}\n\nfunction destroyPostEffectQuad() {\n\tif (_postEffectQuadVB) {\n\t\t_postEffectQuadVB.destroy();\n\n\t\t_postEffectQuadVB = null;\n\t}\n}\n\nfunction drawTexture(device, texture, target, shader, rect, scissorRect, useBlend = false) {\n\tshader = shader || device.getCopyShader();\n\tdevice.constantTexSource.setValue(texture);\n\tdrawQuadWithShader(device, target, shader, rect, scissorRect, useBlend);\n}\n\nclass Shader {\n\tconstructor(graphicsDevice, definition) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.definition = definition;\n\t\tthis.init();\n\t\tthis.device.createShader(this);\n\t}\n\n\tinit() {\n\t\tthis.attributes = [];\n\t\tthis.uniforms = [];\n\t\tthis.samplers = [];\n\t\tthis.ready = false;\n\t\tthis.failed = false;\n\t}\n\n\tdestroy() {\n\t\tthis.device.destroyShader(this);\n\t}\n\n\tloseContext() {\n\t\tthis.init();\n\t}\n\n}\n\nvar alphaTestPS = \"uniform float alpha_ref;\\nvoid alphaTest(float a) {\\n\\tif (a < alpha_ref) discard;\\n}\\n\";\n\nvar ambientConstantPS = \"void addAmbient() {\\n\\tdDiffuseLight += light_globalAmbient;\\n}\\n\";\n\nvar ambientEnvPS = \"#ifndef ENV_ATLAS\\n#define ENV_ATLAS\\nuniform sampler2D texture_envAtlas;\\n#endif\\nvoid addAmbient() {\\n\\tvec3 dir = cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0);\\n\\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\\n\\tvec4 raw = texture2D(texture_envAtlas, uv);\\n\\tvec3 linear = $DECODE(raw);\\n\\tdDiffuseLight += processEnvironment(linear);\\n}\\n\";\n\nvar ambientSHPS = \"uniform vec3 ambientSH[9];\\nvoid addAmbient() {\\n\\tvec3 n = cubeMapRotate(dNormalW);\\n\\tvec3 color =\\n\\t\\tambientSH[0] +\\n\\t\\tambientSH[1] * n.x +\\n\\t\\tambientSH[2] * n.y +\\n\\t\\tambientSH[3] * n.z +\\n\\t\\tambientSH[4] * n.x * n.z +\\n\\t\\tambientSH[5] * n.z * n.y +\\n\\t\\tambientSH[6] * n.y * n.x +\\n\\t\\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\\n\\t\\tambientSH[8] * (n.x * n.x - n.y * n.y);\\n\\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\\n}\\n\";\n\nvar aoPS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_aoMap;\\n#endif\\nvoid applyAO() {\\n\\tdAo = 1.0;\\n\\t#ifdef MAPTEXTURE\\n\\tdAo *= texture2D(texture_aoMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdAo *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tdDiffuseLight *= dAo;\\n}\\n\";\n\nvar aoSpecOccPS = \"uniform float material_occludeSpecularIntensity;\\nvoid occludeSpecular() {\\n\\tfloat specPow = exp2(dGlossiness * 11.0);\\n\\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\\n\\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\\n\\tdSpecularLight *= specOcc;\\n\\tdReflection *= specOcc;\\n}\\n\";\n\nvar aoSpecOccConstPS = \"void occludeSpecular() {\\n\\tfloat specPow = exp2(dGlossiness * 11.0);\\n\\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\\n\\tdSpecularLight *= specOcc;\\n\\tdReflection *= specOcc;\\n}\\n\";\n\nvar aoSpecOccConstSimplePS = \"void occludeSpecular() {\\n\\tfloat specOcc = dAo;\\n\\tdSpecularLight *= specOcc;\\n\\tdReflection *= specOcc;\\n}\\n\";\n\nvar aoSpecOccSimplePS = \"uniform float material_occludeSpecularIntensity;\\nvoid occludeSpecular() {\\n\\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\\n\\tdSpecularLight *= specOcc;\\n\\tdReflection *= specOcc;\\n}\\n\";\n\nvar bakeDirLmEndPS = \"\\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\\n\\tif (bakeDir > 0.5) {\\n\\t\\tif (dAtten > 0.00001) {\\n\\t\\t\\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\\n\\t\\t\\tdAtten = saturate(dAtten);\\n\\t\\t\\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\\n\\t\\t\\tgl_FragColor.a = dirLm.w + dAtten;\\n\\t\\t\\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\\n\\t\\t} else {\\n\\t\\t\\tgl_FragColor = dirLm;\\n\\t\\t}\\n\\t} else {\\n\\t\\tgl_FragColor.rgb = dirLm.xyz;\\n\\t\\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\\n\\t}\\n\";\n\nvar bakeLmEndPS = \"\\tgl_FragColor.rgb = dDiffuseLight;\\n\\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\\n\\tgl_FragColor.rgb /= 8.0;\\n\\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\\n\\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\\n\\tgl_FragColor.rgb /= gl_FragColor.a;\\n\";\n\nvar basePS = \"uniform vec3 view_position;\\nuniform vec3 light_globalAmbient;\\nfloat square(float x) {\\n\\treturn x*x;\\n}\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec3 saturate(vec3 x) {\\n\\treturn clamp(x, vec3(0.0), vec3(1.0));\\n}\\n\";\n\nvar baseVS = \"attribute vec3 vertex_position;\\nattribute vec3 vertex_normal;\\nattribute vec4 vertex_tangent;\\nattribute vec2 vertex_texCoord0;\\nattribute vec2 vertex_texCoord1;\\nattribute vec4 vertex_color;\\nuniform mat4 matrix_viewProjection;\\nuniform mat4 matrix_model;\\nuniform mat3 matrix_normal;\\nvec3 dPositionW;\\nmat4 dModelMatrix;\\nmat3 dNormalMatrix;\\n\";\n\nvar baseNineSlicedPS = \"#define NINESLICED\\nvarying vec2 vMask;\\nvarying vec2 vTiledUv;\\nuniform mediump vec4 innerOffset;\\nuniform mediump vec2 outerScale;\\nuniform mediump vec4 atlasRect;\\nvec2 nineSlicedUv;\\n\";\n\nvar baseNineSlicedVS = \"#define NINESLICED\\nvarying vec2 vMask;\\nvarying vec2 vTiledUv;\\nuniform mediump vec4 innerOffset;\\nuniform mediump vec2 outerScale;\\nuniform mediump vec4 atlasRect;\\n\";\n\nvar baseNineSlicedTiledPS = \"#define NINESLICED\\n#define NINESLICETILED\\nvarying vec2 vMask;\\nvarying vec2 vTiledUv;\\nuniform mediump vec4 innerOffset;\\nuniform mediump vec2 outerScale;\\nuniform mediump vec4 atlasRect;\\nvec2 nineSlicedUv;\\n\";\n\nvar biasConstPS = \"#define SHADOWBIAS\\nfloat getShadowBias(float resolution, float maxBias) {\\n\\treturn maxBias;\\n}\\n\";\n\nvar blurVSMPS = \"varying vec2 vUv0;\\nuniform sampler2D source;\\nuniform vec2 pixelOffset;\\n#ifdef GAUSS\\nuniform float weight[SAMPLES];\\n#endif\\n#ifdef PACKED\\nfloat decodeFloatRG(vec2 rg) {\\n\\treturn rg.y*(1.0/255.0) + rg.x;\\n}\\nvec2 encodeFloatRG( float v ) {\\n\\tvec2 enc = vec2(1.0, 255.0) * v;\\n\\tenc = fract(enc);\\n\\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\\n\\treturn enc;\\n}\\n#endif\\nvoid main(void) {\\n\\tvec3 moments = vec3(0.0);\\n\\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\\n\\tfor (int i=0; i<SAMPLES; i++) {\\n\\t\\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\\n\\t\\t#ifdef PACKED\\n\\t\\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\\n\\t\\t#endif\\n\\t\\t#ifdef GAUSS\\n\\t\\tmoments += c.xyz * weight[i];\\n\\t\\t#else\\n\\t\\tmoments += c.xyz;\\n\\t\\t#endif\\n\\t}\\n\\t#ifndef GAUSS\\n\\tmoments /= float(SAMPLES);\\n\\t#endif\\n\\t#ifdef PACKED\\n\\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\\n\\t#else\\n\\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\\n\\t#endif\\n}\\n\";\n\nvar clearCoatPS = \"#ifdef MAPFLOAT\\nuniform float material_clearCoat;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_clearCoatMap;\\n#endif\\nvoid getClearCoat() {\\n\\tccSpecularity = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tccSpecularity *= material_clearCoat;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tccSpecularity *= texture2D(texture_clearCoatMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tccSpecularity *= saturate(vVertexColor.$VC);\\n\\t#endif\\n}\\n\";\n\nvar clearCoatGlossPS = \"#ifdef MAPFLOAT\\nuniform float material_clearCoatGlossiness;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_clearCoatGlossMap;\\n#endif\\nvoid getClearCoatGlossiness() {\\n\\tccGlossiness = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tccGlossiness *= material_clearCoatGlossiness;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tccGlossiness *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tccGlossiness += 0.0000001;\\n}\\n\";\n\nvar clearCoatNormalPS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_clearCoatNormalMap;\\nuniform float material_clearCoatBumpiness;\\n#endif\\nvoid getClearCoatNormal() {\\n\\t#ifdef MAPTEXTURE\\n\\tvec3 normalMap = unpackNormal(texture2D(texture_clearCoatNormalMap, $UV));\\n\\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness));\\n\\tccNormalW = dTBN * normalMap;\\n\\t#else\\n\\tccNormalW = normalize(dVertexNormalW);\\n\\t#endif\\n\\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\\n}\\n\";\n\nvar clusteredLightUtilsPS = \"vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\\n{\\n\\tvec3 vAbs = abs(dir);\\n\\tfloat ma;\\n\\tvec2 uv;\\n\\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\\n\\t\\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\\n\\t\\tma = 0.5 / vAbs.z;\\n\\t\\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\\n\\t\\ttileOffset.x = 2.0;\\n\\t\\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\\n\\t} else if(vAbs.y >= vAbs.x) {\\n\\t\\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\\n\\t\\tma = 0.5 / vAbs.y;\\n\\t\\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\\n\\t\\ttileOffset.x = 1.0;\\n\\t\\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\\n\\t} else {\\n\\t\\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\\n\\t\\tma = 0.5 / vAbs.x;\\n\\t\\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\\n\\t\\ttileOffset.x = 0.0;\\n\\t\\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\\n\\t}\\n\\treturn uv * ma + 0.5;\\n}\\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\\n\\tfloat faceIndex;\\n\\tvec2 tileOffset;\\n\\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\\n\\tfloat atlasFaceSize = omniAtlasViewport.z;\\n\\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\\n\\tfloat offset = shadowEdgePixels / tileSize;\\n\\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\\n\\tuv *= atlasFaceSize;\\n\\tuv += tileOffset * atlasFaceSize;\\n\\tuv += omniAtlasViewport.xy;\\n\\treturn uv;\\n}\\n\";\n\nvar clusteredLightCookiesPS = \"vec3 _getCookieClustered(sampler2D tex, vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\\n\\tvec4 pixel = mix(vec4(1.0), texture2D(tex, uv), intensity);\\n\\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\\n}\\nvec3 getCookie2DClustered(sampler2D tex, mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\\n\\tvec4 projPos = transform * vec4(worldPosition, 1.0);\\n\\treturn _getCookieClustered(tex, projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\\n}\\nvec3 getCookieCubeClustered(sampler2D tex, vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\\n\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\treturn _getCookieClustered(tex, uv, intensity, isRgb, cookieChannel);\\n}\\n\";\n\nvar clusteredLightShadowsPS = \"#ifdef GL2\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\tfloat getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\treturn texture(shadowMap, vec3(uv, shadowZ));\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\\n\\tfloat getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\tdShadowCoord = vec3(uv, shadowZ);\\n\\t\\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\tdShadowCoord = vec3(uv, shadowZ);\\n\\t\\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\\n\\t}\\n\\t#endif\\n#else\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\tfloat getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat depth = unpackFloat(texture2D(shadowMap, uv));\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\treturn depth > shadowZ ? 1.0 : 0.0;\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\tdShadowCoord = vec3(uv, shadowZ);\\n\\t\\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\treturn getShadowOmniClusteredPCF3(shadowMap, shadowParams, omniAtlasViewport, shadowEdgePixels, dir);\\n\\t}\\n\\t#endif\\n#endif\\n#ifdef GL2\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\tfloat getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\t\\treturn texture(shadowMap, dShadowCoord);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\\n\\tfloat getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\t\\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\t\\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\\n\\t}\\n\\t#endif\\n#else\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\tfloat getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {\\n\\t\\tfloat depth = unpackFloat(texture2D(shadowMap, dShadowCoord.xy));\\n\\t\\treturn depth > dShadowCoord.z ? 1.0 : 0.0;\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {\\n\\t\\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {\\n\\t\\treturn getShadowSpotClusteredPCF3(shadowMap, shadowParams);\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\nvar clusteredLightPS = \"uniform sampler2D clusterWorldTexture;\\nuniform sampler2D lightsTexture8;\\nuniform highp sampler2D lightsTextureFloat;\\n#ifdef CLUSTER_SHADOWS\\n\\t#ifdef GL2\\n\\t\\tuniform sampler2DShadow shadowAtlasTexture;\\n\\t#else\\n\\t\\tuniform sampler2D shadowAtlasTexture;\\n\\t#endif\\n#endif\\n#ifdef CLUSTER_COOKIES\\n\\tuniform sampler2D cookieAtlasTexture;\\n#endif\\nuniform float clusterPixelsPerCell;\\nuniform vec3 clusterCellsCountByBoundsSize;\\nuniform vec4 lightsTextureInvSize;\\nuniform vec3 clusterTextureSize;\\nuniform vec3 clusterBoundsMin;\\nuniform vec3 clusterBoundsDelta;\\nuniform vec3 clusterCellsDot;\\nuniform vec3 clusterCellsMax;\\nuniform vec2 clusterCompressionLimit0;\\nuniform vec2 shadowAtlasParams;\\nfloat LTCLightValuesEvaluated = 0.0;\\nstruct ClusterLightData {\\n\\tfloat lightV;\\n\\tfloat type;\\n\\tfloat shape;\\n\\tvec3 halfWidth;\\n\\tvec3 halfHeight;\\n\\tfloat falloffMode;\\n\\tfloat castShadows;\\n\\tfloat shadowBias;\\n\\tfloat shadowNormalBias;\\n\\tvec3 position;\\n\\tvec3 direction;\\n\\tfloat range;\\n\\tfloat innerConeAngleCos;\\n\\tfloat outerConeAngleCos;\\n\\tvec3 color;\\n\\tvec3 omniAtlasViewport;\\n\\tfloat cookie;\\n\\tfloat cookieRgb;\\n\\tfloat cookieIntensity;\\n\\tvec4 cookieChannelMask;\\n\\tfloat mask;\\n};\\nmat4 lightProjectionMatrix;\\n#define isClusteredLightCastShadow(light) ( light.castShadows > 0.5 )\\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\\n#define isClusteredLightSpot(light) ( light.type > 0.5 )\\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\\n\\t#define acceptLightMask(light) ( light.mask < 0.75)\\n#else\\n\\t#define acceptLightMask(light) ( light.mask > 0.25)\\n#endif\\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\\n\\treturn vec4(\\n\\t\\tbytes2floatRange4(d0, -2.0, 2.0),\\n\\t\\tbytes2floatRange4(d1, -2.0, 2.0),\\n\\t\\tbytes2floatRange4(d2, -2.0, 2.0),\\n\\t\\tbytes2floatRange4(d3, -2.0, 2.0)\\n\\t);\\n}\\n#ifdef SUPPORTS_TEXLOD\\n\\t#define textureData(texture, uv) texture2DLodEXT(texture, uv, 0.0)\\n#else\\n\\t#define textureData(texture, uv) texture2D(texture, uv)\\n#endif\\nvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\\n\\treturn textureData(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV));\\n}\\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\\n\\treturn textureData(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV));\\n}\\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\\n\\tclusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\\n\\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\\n\\tclusterLightData.type = lightInfo.x;\\n\\tclusterLightData.shape = lightInfo.y;\\n\\tclusterLightData.falloffMode = lightInfo.z;\\n\\tclusterLightData.castShadows = lightInfo.w;\\n\\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\\n\\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\\n\\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\\n\\tclusterLightData.cookie = colorB.z;\\n\\tclusterLightData.mask = colorB.w;\\n\\t#ifdef CLUSTER_TEXTURE_FLOAT\\n\\t\\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\\n\\t\\tclusterLightData.position = lightPosRange.xyz;\\n\\t\\tclusterLightData.range = lightPosRange.w;\\n\\t\\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\\n\\t\\tclusterLightData.direction = lightDir_Unused.xyz;\\n\\t#else\\n\\t\\tvec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\\n\\t\\tvec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\\n\\t\\tvec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\\n\\t\\tclusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\\n\\t\\tvec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\\n\\t\\tclusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\\n\\t\\tvec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\\n\\t\\tvec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\\n\\t\\tvec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\\n\\t\\tclusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\\n\\t#endif\\n}\\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\\n\\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\\n\\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\\n\\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\\n}\\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\\n\\t#ifdef CLUSTER_TEXTURE_FLOAT\\n\\t\\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\\n\\t#else\\n\\t\\tvec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\\n\\t\\tvec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\\n\\t\\tclusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\\n\\t#endif\\n}\\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\\n\\t#ifdef CLUSTER_TEXTURE_FLOAT\\n\\t\\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\\n\\t\\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\\n\\t#else\\n\\t\\tvec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\\n\\t\\tvec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\\n\\t\\tvec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\\n\\t\\tclusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\\n\\t\\tvec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\\n\\t\\tvec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\\n\\t\\tvec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\\n\\t\\tclusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\\n\\t#endif\\n}\\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\\n\\t#ifdef CLUSTER_TEXTURE_FLOAT\\n\\t\\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\\n\\t\\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\\n\\t\\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\\n\\t\\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\\n\\t#else\\n\\t\\tvec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\\n\\t\\tvec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\\n\\t\\tvec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\\n\\t\\tvec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\\n\\t\\tvec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\\n\\t\\tvec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\\n\\t\\tvec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\\n\\t\\tvec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\\n\\t\\tvec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\\n\\t\\tvec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\\n\\t\\tvec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\\n\\t\\tvec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\\n\\t\\tvec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\\n\\t\\tvec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\\n\\t\\tvec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\\n\\t\\tvec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\\n\\t\\tvec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\\n\\t\\tvec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\\n\\t\\tvec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\\n\\t\\tvec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\\n\\t#endif\\n\\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\\n}\\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\\n\\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\\n\\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\\n\\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\\n}\\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\\n\\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\\n\\tclusterLightData.cookieIntensity = cookieA.x;\\n\\tclusterLightData.cookieRgb = cookieA.y;\\n\\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\\n}\\nvoid evaluateLight(ClusterLightData light) {\\n\\tdAtten3 = vec3(1.0);\\n\\tgetLightDirPoint(light.position);\\n\\t#ifdef CLUSTER_AREALIGHTS\\n\\tif (isClusteredLightArea(light)) {\\n\\t\\tdecodeClusterLightAreaData(light);\\n\\t\\tif (LTCLightValuesEvaluated < 0.5) {\\n\\t\\t\\tLTCLightValuesEvaluated = 1.0;\\n\\t\\t\\tcalcLTCLightValues();\\n\\t\\t}\\n\\t\\tif (isClusteredLightRect(light)) {\\n\\t\\t\\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\\n\\t\\t} else if (isClusteredLightDisk(light)) {\\n\\t\\t\\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\\n\\t\\t} else {\\n\\t\\t\\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\\n\\t\\t}\\n\\t\\tdAtten = getFalloffWindow(light.range);\\n\\t} else\\n\\t#endif\\n\\t{\\n\\t\\tif (isClusteredLightFalloffLinear(light))\\n\\t\\t\\tdAtten = getFalloffLinear(light.range);\\n\\t\\telse\\n\\t\\t\\tdAtten = getFalloffInvSquared(light.range);\\n\\t}\\n\\tif (dAtten > 0.00001) {\\n\\t\\t#ifdef CLUSTER_AREALIGHTS\\n\\t\\tif (isClusteredLightArea(light)) {\\n\\t\\t\\tif (isClusteredLightRect(light)) {\\n\\t\\t\\t\\tdAttenD = getRectLightDiffuse() * 16.0;\\n\\t\\t\\t} else if (isClusteredLightDisk(light)) {\\n\\t\\t\\t\\tdAttenD = getDiskLightDiffuse() * 16.0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdAttenD = getSphereLightDiffuse() * 16.0;\\n\\t\\t\\t}\\n\\t\\t} else\\n\\t\\t#endif\\n\\t\\t{\\n\\t\\t\\tdAtten *= getLightDiffuse();\\n\\t\\t}\\n\\t\\tif (isClusteredLightSpot(light)) {\\n\\t\\t\\tdecodeClusterLightSpot(light);\\n\\t\\t\\tdAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);\\n\\t\\t}\\n\\t\\t#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\\n\\t\\tif (dAtten > 0.00001) {\\n\\t\\t\\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\\n\\t\\t\\t\\tif (isClusteredLightSpot(light)) {\\n\\t\\t\\t\\t\\tdecodeClusterLightProjectionMatrixData(light);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdecodeClusterLightOmniAtlasViewport(light);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfloat shadowTextureResolution = shadowAtlasParams.x;\\n\\t\\t\\t\\tfloat shadowEdgePixels = shadowAtlasParams.y;\\n\\t\\t\\t\\t#ifdef CLUSTER_COOKIES\\n\\t\\t\\t\\tif (isClusteredLightCookie(light)) {\\n\\t\\t\\t\\t\\tdecodeClusterLightCookieData(light);\\n\\t\\t\\t\\t\\tif (isClusteredLightSpot(light)) {\\n\\t\\t\\t\\t\\t\\tdAtten3 = getCookie2DClustered(cookieAtlasTexture, lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tdAtten3 = getCookieCubeClustered(cookieAtlasTexture, dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#ifdef CLUSTER_SHADOWS\\n\\t\\t\\t\\tif (isClusteredLightCastShadow(light)) {\\n\\t\\t\\t\\t\\tdecodeClusterLightShadowData(light);\\n\\t\\t\\t\\t\\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\\n\\t\\t\\t\\t\\tif (isClusteredLightSpot(light)) {\\n\\t\\t\\t\\t\\t\\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);\\n\\t\\t\\t\\t\\t\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);\\n\\t\\t\\t\\t\\t\\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);\\n\\t\\t\\t\\t\\t\\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);\\n\\t\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnormalOffsetPointShadow(shadowParams);\\n\\t\\t\\t\\t\\t\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\\n\\t\\t\\t\\t\\t\\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\\n\\t\\t\\t\\t\\t\\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\\n\\t\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t#endif\\n\\t\\t#ifdef CLUSTER_AREALIGHTS\\n\\t\\tif (isClusteredLightArea(light)) {\\n\\t\\t\\t{\\n\\t\\t\\t\\tvec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;\\n\\t\\t\\t\\t#if defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\\n\\t\\t\\t\\t\\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tdDiffuseLight += areaDiffuse;\\n\\t\\t\\t}\\n\\t\\t\\t#ifdef CLUSTER_SPECULAR\\n\\t\\t\\t\\tfloat areaLightSpecular;\\n\\t\\t\\t\\tif (isClusteredLightRect(light)) {\\n\\t\\t\\t\\t\\tareaLightSpecular = getRectLightSpecular();\\n\\t\\t\\t\\t} else if (isClusteredLightDisk(light)) {\\n\\t\\t\\t\\t\\tareaLightSpecular = getDiskLightSpecular();\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tareaLightSpecular = getSphereLightSpecular();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;\\n\\t\\t\\t\\t#ifdef CLUSTER_CLEAR_COAT\\n\\t\\t\\t\\t\\tfloat areaLightSpecularCC;\\n\\t\\t\\t\\t\\tif (isClusteredLightRect(light)) {\\n\\t\\t\\t\\t\\t\\tareaLightSpecularCC = getRectLightSpecularCC();\\n\\t\\t\\t\\t\\t} else if (isClusteredLightDisk(light)) {\\n\\t\\t\\t\\t\\t\\tareaLightSpecularCC = getDiskLightSpecularCC();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tareaLightSpecularCC = getSphereLightSpecularCC();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color\t* dAtten3;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t#endif\\n\\t\\t} else\\n\\t\\t#endif\\n\\t\\t{\\n\\t\\t\\t{\\n\\t\\t\\t\\tvec3 punctualDiffuse = dAtten * light.color * dAtten3;\\n\\t\\t\\t\\t#if defined(CLUSTER_AREALIGHTS) && defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\\n\\t\\t\\t\\t\\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tdDiffuseLight += punctualDiffuse;\\n\\t\\t\\t}\\n\\t\\t\\t#ifdef CLUSTER_SPECULAR\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvec3 punctualSpecular = getLightSpecular() * dAtten * light.color * dAtten3;\\n\\t\\t\\t\\t\\t#if defined(CLUSTER_AREALIGHTS)\\n\\t\\t\\t\\t\\t\\tpunctualSpecular *= dSpecularity;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\tdSpecularLight += punctualSpecular;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t#ifdef CLUSTER_CLEAR_COAT\\n\\t\\t\\t\\t\\tvec3 punctualCC = getLightSpecularCC() * dAtten * light.color * dAtten3;\\n\\t\\t\\t\\t\\t#if defined(CLUSTER_AREALIGHTS)\\n\\t\\t\\t\\t\\t\\tpunctualCC *= ccSpecularity;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\tccSpecularLight += punctualCC;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t}\\n}\\nvoid evaluateClusterLight(float lightIndex) {\\n\\tClusterLightData clusterLightData;\\n\\tdecodeClusterLightCore(clusterLightData, lightIndex);\\n\\tif (acceptLightMask(clusterLightData))\\n\\t\\tevaluateLight(clusterLightData);\\n}\\nvoid addClusteredLights() {\\n\\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\\n\\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\\n\\t\\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\\n\\t\\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\\n\\t\\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\\n\\t\\tclusterV = (clusterV + 0.5) * clusterTextureSize.z;\\n\\t\\tconst float maxLightCells = 256.0 / 4.0;\\n\\t\\tfor (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\\n\\t\\t\\tvec4 lightIndices = textureData(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV));\\n\\t\\t\\tvec4 indices = lightIndices * 255.0;\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\n\\t\\t\\t\\tif (indices.x <= 0.0)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tevaluateClusterLight(indices.x);\\n\\t\\t\\t\\tindices = indices.yzwx;\\n\\t\\t\\t}\\n\\t\\t\\tif (lightCellIndex > clusterPixelsPerCell) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\";\n\nvar combineClearCoatPS = \"vec3 combineColorCC() {\\n\\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\\n}\\n\";\n\nvar combineDiffusePS = \"vec3 combineColor() {\\n\\treturn dAlbedo * dDiffuseLight;\\n}\\n\";\n\nvar combineDiffuseSpecularPS = \"vec3 combineColor() {\\n\\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\\n}\\n\";\n\nvar combineDiffuseSpecularNoConservePS = \"vec3 combineColor() {\\n\\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\\n}\\n\";\n\nvar combineDiffuseSpecularNoReflPS = \"vec3 combineColor() {\\n\\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\\n}\\n\";\n\nvar combineDiffuseSpecularNoReflSeparateAmbientPS = \"uniform vec3 material_ambient;\\nvec3 combineColor() {\\n\\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\\n}\\n\";\n\nvar combineDiffuseSpecularOldPS = \"vec3 combineColor() {\\n\\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\\n}\\n\";\n\nvar cookiePS = \"vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\\n\\tvec4 projPos = transform * vec4(vPositionW, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\\n}\\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\\n\\tvec4 projPos = transform * vec4(vPositionW, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\\n\\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\\n}\\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\\n\\tvec4 projPos = transform * vec4(vPositionW, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\tprojPos.xy += cookieOffset;\\n\\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\\n\\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\\n}\\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\\n\\tvec4 projPos = transform * vec4(vPositionW, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\tprojPos.xy += cookieOffset;\\n\\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\\n\\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\\n\\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\\n}\\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\\n\\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\\n}\\n\";\n\nvar cubeMapProjectBoxPS = \"uniform vec3 envBoxMin, envBoxMax;\\nvec3 cubeMapProject(vec3 nrdir) {\\n\\tnrdir = cubeMapRotate(nrdir);\\n\\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\\n\\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\\n\\tvec3 rbminmax;\\n\\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\\n\\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\\n\\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\\n\\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\\n\\tvec3 posonbox = vPositionW + nrdir * fa;\\n\\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\\n\\treturn normalize(posonbox - envBoxPos);\\n}\\n\";\n\nvar cubeMapProjectNonePS = \"vec3 cubeMapProject(vec3 dir) {\\n\\treturn cubeMapRotate(dir);\\n}\\n\";\n\nvar cubeMapRotatePS = \"#ifdef CUBEMAP_ROTATION\\nuniform mat3 cubeMapRotationMatrix;\\n#endif\\nvec3 cubeMapRotate(vec3 refDir) {\\n#ifdef CUBEMAP_ROTATION\\n\\treturn refDir * cubeMapRotationMatrix;\\n#else\\n\\treturn refDir;\\n#endif\\n}\\n\";\n\nvar decodePS = \"vec3 decodeLinear(vec4 raw) {\\n\\treturn raw.rgb;\\n}\\nvec3 decodeGamma(vec4 raw) {\\n\\treturn pow(raw.xyz, vec3(2.2));\\n}\\nvec3 decodeRGBM(vec4 raw) {\\n\\tvec3 color = (8.0 * raw.a) * raw.rgb;\\n\\treturn color * color;\\n}\\nvec3 decodeRGBE(vec4 raw) {\\n\\tif (raw.a == 0.0) {\\n\\t\\treturn vec3(0.0, 0.0, 0.0);\\n\\t} else {\\n\\t\\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\\n\\t}\\n}\\nconst float PI = 3.141592653589793;\\nvec2 toSpherical(vec3 dir) {\\n\\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\\n}\\nvec2 toSphericalUv(vec3 dir) {\\n\\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\\n\\treturn vec2(uv.x, 1.0 - uv.y);\\n}\\nconst float atlasSize = 512.0;\\nconst float seamSize = 1.0 / atlasSize;\\nvec2 mapUv(vec2 uv, vec4 rect) {\\n\\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\\n\\t\\t\\t\\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\\n}\\nvec2 mapRoughnessUv(vec2 uv, float level) {\\n\\tfloat t = 1.0 / exp2(level);\\n\\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\\n}\\nvec2 mapMip(vec2 uv, float level) {\\n\\tfloat t = 1.0 / exp2(level);\\n\\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\\n}\\n\";\n\nvar detailModesPS = \"vec3 detailMode_mul(vec3 c1, vec3 c2) {\\n\\treturn c1 * c2;\\n}\\nvec3 detailMode_add(vec3 c1, vec3 c2) {\\n\\treturn c1 + c2;\\n}\\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\\n\\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\\n}\\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\\n\\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\\n}\\nvec3 detailMode_min(vec3 c1, vec3 c2) {\\n\\treturn min(c1, c2);\\n}\\nvec3 detailMode_max(vec3 c1, vec3 c2) {\\n\\treturn max(c1, c2);\\n}\\n\";\n\nvar diffusePS = \"#ifdef MAPCOLOR\\nuniform vec3 material_diffuse;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_diffuseMap;\\n#endif\\nvoid getAlbedo() {\\n\\tdAlbedo = vec3(1.0);\\n\\t#ifdef MAPCOLOR\\n\\tdAlbedo *= material_diffuse.rgb;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV).$CH));\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\\n\\t#endif\\n}\\n\";\n\nvar diffuseDetailMapPS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_diffuseDetailMap;\\n#endif\\nvec3 addAlbedoDetail(vec3 albedo) {\\n\\t#ifdef MAPTEXTURE\\n\\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV).$CH);\\n\\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\\n\\t#else\\n\\treturn albedo;\\n\\t#endif\\n}\\n\";\n\nvar dilatePS = \"#define SHADER_NAME Dilate\\nvarying vec2 vUv0;\\nuniform sampler2D source;\\nuniform vec2 pixelOffset;\\nvoid main(void) {\\n\\tvec4 c = texture2D(source, vUv0);\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\\n\\tgl_FragColor = c;\\n}\\n\";\n\nvar bilateralDeNoisePS = \"#define SHADER_NAME BilateralDeNoise\\nfloat normpdf3(in vec3 v, in float sigma) {\\n\\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\\n}\\nvec3 decodeRGBM(vec4 rgbm) {\\n\\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\\n\\treturn color * color;\\n}\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec4 encodeRGBM(vec3 color) {\\n\\tvec4 encoded;\\n\\tencoded.rgb = pow(color.rgb, vec3(0.5));\\n\\tencoded.rgb *= 1.0 / 8.0;\\n\\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\\n\\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\\n\\tencoded.rgb /= encoded.a;\\n\\treturn encoded;\\n}\\n#define MSIZE 15\\nvarying vec2 vUv0;\\nuniform sampler2D source;\\nuniform vec2 pixelOffset;\\nuniform vec2 sigmas;\\nuniform float bZnorm;\\nuniform float kernel[MSIZE];\\nvoid main(void) {\\n\\tvec4 pixelRgbm = texture2D(source, vUv0);\\n\\tif (pixelRgbm.a <= 0.0) {\\n\\t\\tgl_FragColor = pixelRgbm;\\n\\t\\treturn ;\\n\\t}\\n\\tfloat sigma = sigmas.x;\\n\\tfloat bSigma = sigmas.y;\\n\\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\\n\\tvec3 accumulatedHdr = vec3(0.0);\\n\\tfloat accumulatedFactor = 0.0;\\n\\tconst int kSize = (MSIZE-1)/2;\\n\\tfor (int i = -kSize; i <= kSize; ++i) {\\n\\t\\tfor (int j = -kSize; j <= kSize; ++j) {\\n\\t\\t\\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\\n\\t\\t\\tvec4 rgbm = texture2D(source, coord);\\n\\t\\t\\tif (rgbm.a > 0.0) {\\n\\t\\t\\t\\tvec3 hdr = decodeRGBM(rgbm);\\n\\t\\t\\t\\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\\n\\t\\t\\t\\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\\n\\t\\t\\t\\taccumulatedHdr += factor * hdr;\\n\\t\\t\\t\\taccumulatedFactor += factor;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\\n}\\n\";\n\nvar emissivePS = \"#ifdef MAPCOLOR\\nuniform vec3 material_emissive;\\n#endif\\n#ifdef MAPFLOAT\\nuniform float material_emissiveIntensity;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_emissiveMap;\\n#endif\\nvec3 getEmission() {\\n\\tvec3 emission = vec3(1.0);\\n\\t#ifdef MAPFLOAT\\n\\temission *= material_emissiveIntensity;\\n\\t#endif\\n\\t#ifdef MAPCOLOR\\n\\temission *= material_emissive;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\\n\\t#endif\\n\\treturn emission;\\n}\\n\";\n\nvar endPS = \"\\t#ifdef CLEARCOAT\\n\\tgl_FragColor.rgb = combineColorCC();\\n\\t#else\\n\\tgl_FragColor.rgb = combineColor();\\n\\t#endif\\n\\tgl_FragColor.rgb += getEmission();\\n\\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\\n\\t#ifndef HDR\\n\\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\\n\\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\\n\\t#endif\\n\";\n\nvar endVS = \"\\n\";\n\nvar envConstPS = \"vec3 processEnvironment(vec3 color) {\\n\\treturn color;\\n}\\n\";\n\nvar envMultiplyPS = \"uniform float skyboxIntensity;\\nvec3 processEnvironment(vec3 color) {\\n\\treturn color * skyboxIntensity;\\n}\\n\";\n\nvar extensionPS = \"\\n\";\n\nvar extensionVS = \"\\n\";\n\nvar falloffInvSquaredPS = \"float getFalloffWindow(float lightRadius) {\\n\\tfloat sqrDist = dot(dLightDirW, dLightDirW);\\n\\tfloat invRadius = 1.0 / lightRadius;\\n\\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\\n}\\nfloat getFalloffInvSquared(float lightRadius) {\\n\\tfloat sqrDist = dot(dLightDirW, dLightDirW);\\n\\tfloat falloff = 1.0 / (sqrDist + 1.0);\\n\\tfloat invRadius = 1.0 / lightRadius;\\n\\tfalloff *= 16.0;\\n\\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\\n\\treturn falloff;\\n}\\n\";\n\nvar falloffLinearPS = \"float getFalloffLinear(float lightRadius) {\\n\\tfloat d = length(dLightDirW);\\n\\treturn max(((lightRadius - d) / lightRadius), 0.0);\\n}\\n\";\n\nvar fixCubemapSeamsNonePS = \"vec3 fixSeams(vec3 vec, float mipmapIndex) {\\n\\treturn vec;\\n}\\nvec3 fixSeams(vec3 vec) {\\n\\treturn vec;\\n}\\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\\n\\treturn vec;\\n}\\nvec3 calcSeam(vec3 vec) {\\n\\treturn vec3(0);\\n}\\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\\n\\treturn vec;\\n}\\n\";\n\nvar fixCubemapSeamsStretchPS = \"vec3 fixSeams(vec3 vec, float mipmapIndex) {\\n\\tvec3 avec = abs(vec);\\n\\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\\n\\tfloat M = max(max(avec.x, avec.y), avec.z);\\n\\tif (avec.x != M) vec.x *= scale;\\n\\tif (avec.y != M) vec.y *= scale;\\n\\tif (avec.z != M) vec.z *= scale;\\n\\treturn vec;\\n}\\nvec3 fixSeams(vec3 vec) {\\n\\tvec3 avec = abs(vec);\\n\\tfloat scale = 1.0 - 1.0 / 128.0;\\n\\tfloat M = max(max(avec.x, avec.y), avec.z);\\n\\tif (avec.x != M) vec.x *= scale;\\n\\tif (avec.y != M) vec.y *= scale;\\n\\tif (avec.z != M) vec.z *= scale;\\n\\treturn vec;\\n}\\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\\n\\tvec3 avec = abs(vec);\\n\\tfloat scale = invRecMipSize;\\n\\tfloat M = max(max(avec.x, avec.y), avec.z);\\n\\tif (avec.x != M) vec.x *= scale;\\n\\tif (avec.y != M) vec.y *= scale;\\n\\tif (avec.z != M) vec.z *= scale;\\n\\treturn vec;\\n}\\nvec3 calcSeam(vec3 vec) {\\n\\tvec3 avec = abs(vec);\\n\\tfloat M = max(avec.x, max(avec.y, avec.z));\\n\\treturn vec3(avec.x != M ? 1.0 : 0.0,\\n\\t\\t\\t\\tavec.y != M ? 1.0 : 0.0,\\n\\t\\t\\t\\tavec.z != M ? 1.0 : 0.0);\\n}\\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\\n\\treturn vec * (seam * -scale + vec3(1.0));\\n}\\n\";\n\nvar floatUnpackingPS = \"float bytes2float2(vec2 data) {\\n\\treturn dot(data, vec2(1.0, 1.0 / 255.0));\\n}\\nfloat bytes2float3(vec3 data) {\\n\\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\\n}\\nfloat bytes2float4(vec4 data) {\\n\\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\\n}\\nfloat bytes2floatRange2(vec2 data, float min, float max) {\\n\\treturn mix(min, max, bytes2float2(data));\\n}\\nfloat bytes2floatRange3(vec3 data, float min, float max) {\\n\\treturn mix(min, max, bytes2float3(data));\\n}\\nfloat bytes2floatRange4(vec4 data, float min, float max) {\\n\\treturn mix(min, max, bytes2float4(data));\\n}\\nfloat mantissaExponent2Float(vec4 pack)\\n{\\n\\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\\n\\tfloat exponent = floor(pack.w * 255.0 - 127.0);\\n\\treturn value * exp2(exponent);\\n}\\n\";\n\nvar fogExpPS = \"uniform vec3 fog_color;\\nuniform float fog_density;\\nfloat dBlendModeFogFactor = 1.0;\\nvec3 addFog(vec3 color) {\\n\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\tfloat fogFactor = exp(-depth * fog_density);\\n\\tfogFactor = clamp(fogFactor, 0.0, 1.0);\\n\\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\\n}\\n\";\n\nvar fogExp2PS = \"uniform vec3 fog_color;\\nuniform float fog_density;\\nfloat dBlendModeFogFactor = 1.0;\\nvec3 addFog(vec3 color) {\\n\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\\n\\tfogFactor = clamp(fogFactor, 0.0, 1.0);\\n\\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\\n}\\n\";\n\nvar fogLinearPS = \"uniform vec3 fog_color;\\nuniform float fog_start;\\nuniform float fog_end;\\nfloat dBlendModeFogFactor = 1.0;\\nvec3 addFog(vec3 color) {\\n\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\\n\\tfogFactor = clamp(fogFactor, 0.0, 1.0);\\n\\tfogFactor = gammaCorrectInput(fogFactor);\\n\\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\\n}\\n\";\n\nvar fogNonePS = \"float dBlendModeFogFactor = 1.0;\\nvec3 addFog(vec3 color) {\\n\\treturn color;\\n}\\n\";\n\nvar fresnelSchlickPS = \"uniform float material_fresnelFactor;\\nvoid getFresnel() {\\n\\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\\n\\tfloat fresnel2 = fresnel * fresnel;\\n\\tfresnel *= fresnel2 * fresnel2;\\n\\tfresnel *= dGlossiness * dGlossiness;\\n\\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\\n\\t#ifdef CLEARCOAT\\n\\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\\n\\tfresnel2 = fresnel * fresnel;\\n\\tfresnel *= fresnel2 * fresnel2;\\n\\tfresnel *= ccGlossiness * ccGlossiness;\\n\\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\\n\\t#endif\\n}\\n\";\n\nvar fullscreenQuadPS = \"varying vec2 vUv0;\\nuniform sampler2D source;\\nvoid main(void) {\\n\\tgl_FragColor = texture2D(source, vUv0);\\n}\\n\";\n\nvar fullscreenQuadVS = \"attribute vec2 vertex_position;\\nvarying vec2 vUv0;\\nvoid main(void)\\n{\\n\\tgl_Position = vec4(vertex_position, 0.5, 1.0);\\n\\tvUv0 = vertex_position.xy*0.5+0.5;\\n}\\n\";\n\nvar gamma1_0PS = \"vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\\n\\treturn texture2D(tex, uv);\\n}\\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\\n\\treturn texture2D(tex, uv, bias);\\n}\\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\\n\\treturn textureCube(tex, uvw);\\n}\\nvec3 gammaCorrectOutput(vec3 color) {\\n\\treturn color;\\n}\\nvec3 gammaCorrectInput(vec3 color) {\\n\\treturn color;\\n}\\nfloat gammaCorrectInput(float color) {\\n\\treturn color;\\n}\\nvec4 gammaCorrectInput(vec4 color) {\\n\\treturn color;\\n}\\n\";\n\nvar gamma2_2PS = \"vec3 gammaCorrectInput(vec3 color) {\\n\\treturn pow(color, vec3(2.2));\\n}\\nfloat gammaCorrectInput(float color) {\\n\\treturn pow(color, 2.2);\\n}\\nvec4 gammaCorrectInput(vec4 color) {\\n\\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\\n}\\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\\n\\tvec4 rgba = texture2D(tex, uv);\\n\\trgba.rgb = gammaCorrectInput(rgba.rgb);\\n\\treturn rgba;\\n}\\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\\n\\tvec4 rgba = texture2D(tex, uv, bias);\\n\\trgba.rgb = gammaCorrectInput(rgba.rgb);\\n\\treturn rgba;\\n}\\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\\n\\tvec4 rgba = textureCube(tex, uvw);\\n\\trgba.rgb = gammaCorrectInput(rgba.rgb);\\n\\treturn rgba;\\n}\\nvec3 gammaCorrectOutput(vec3 color) {\\n\\t#ifdef HDR\\n\\treturn color;\\n\\t#else\\n\\tcolor += vec3(0.0000001);\\n\\treturn pow(color, vec3(0.45));\\n\\t#endif\\n}\\n\";\n\nvar gles3PS = \"#define varying in\\nout highp vec4 pc_fragColor;\\n#define gl_FragColor pc_fragColor\\n#define texture2D texture\\n#define textureCube texture\\n#define texture2DProj textureProj\\n#define texture2DLodEXT textureLod\\n#define texture2DProjLodEXT textureProjLod\\n#define textureCubeLodEXT textureLod\\n#define texture2DGradEXT textureGrad\\n#define texture2DProjGradEXT textureProjGrad\\n#define textureCubeGradEXT textureGrad\\n#define GL2\\n#define SUPPORTS_TEXLOD\\n\";\n\nvar gles3VS = \"#define attribute in\\n#define varying out\\n#define texture2D texture\\n#define GL2\\n#define VERTEXSHADER\\n\";\n\nvar glossPS = \"#ifdef MAPFLOAT\\nuniform float material_shininess;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_glossMap;\\n#endif\\nvoid getGlossiness() {\\n\\tdGlossiness = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tdGlossiness *= material_shininess;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdGlossiness *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tdGlossiness += 0.0000001;\\n}\\n\";\n\nvar instancingVS = \"attribute vec4 instance_line1;\\nattribute vec4 instance_line2;\\nattribute vec4 instance_line3;\\nattribute vec4 instance_line4;\\n\";\n\nvar lightDiffuseLambertPS = \"float getLightDiffuse() {\\n\\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\\n}\\n\";\n\nvar lightDirPointPS = \"void getLightDirPoint(vec3 lightPosW) {\\n\\tdLightDirW = vPositionW - lightPosW;\\n\\tdLightDirNormW = normalize(dLightDirW);\\n\\tdLightPosW = lightPosW;\\n}\\n\";\n\nvar lightmapDirPS = \"uniform sampler2D texture_lightMap;\\nuniform sampler2D texture_dirLightMap;\\nvoid addLightMap() {\\n\\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\\n\\tvec3 dir = texture2D(texture_dirLightMap, $UV).xyz;\\n\\tif (dot(dir, vec3(1.0)) < 0.00001) {\\n\\t\\tdDiffuseLight += color;\\n\\t} else {\\n\\t\\tdLightDirNormW = normalize(dir * 2.0 - vec3(1.0));\\n\\t\\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\\n\\t\\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\\n\\t\\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\\n\\t\\tdDiffuseLight += color * nlight * 2.0;\\n\\t}\\n\\tdSpecularLight += color * getLightSpecular();\\n}\\n\";\n\nvar lightmapSinglePS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_lightMap;\\n#endif\\nvoid addLightMap() {\\n\\tvec3 lm = vec3(1.0);\\n\\t#ifdef MAPTEXTURE\\n\\tlm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tlm *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tdDiffuseLight += lm;\\n}\\n\";\n\nvar lightmapSingleVertPS = \"void addLightMap() {\\n\\tdDiffuseLight += saturate(vVertexColor.$CH);\\n}\\n\";\n\nvar lightSpecularAnisoGGXPS = \"float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\\n\\tfloat PI = 3.141592653589793;\\n\\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\\n\\tfloat anisotropy = material_anisotropy * roughness;\\n\\tfloat at = max((roughness + anisotropy), roughness / 4.0);\\n\\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\\n\\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\\n\\tfloat NoH = dot(tNormalW, h);\\n\\tfloat ToH = dot(dTBN[0], h);\\n\\tfloat BoH = dot(dTBN[1], h);\\n\\tfloat a2 = at * ab;\\n\\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\\n\\tfloat v2 = dot(v, v);\\n\\tfloat w2 = a2 / v2;\\n\\tfloat D = a2 * w2 * w2 * (1.0 / PI);\\n\\tfloat ToV = dot(dTBN[0], dViewDirW);\\n\\tfloat BoV = dot(dTBN[1], dViewDirW);\\n\\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\\n\\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\\n\\tfloat NoV = dot(tNormalW, dViewDirW);\\n\\tfloat NoL = dot(tNormalW, -dLightDirNormW);\\n\\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\\n\\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\\n\\tfloat G = 0.5 / (lambdaV + lambdaL);\\n\\treturn D * G;\\n}\\nfloat getLightSpecular() {\\n\\treturn calcLightSpecular(dGlossiness, dNormalW);\\n}\\nfloat getLightSpecularCC() {\\n\\treturn calcLightSpecular(ccGlossiness, ccNormalW);\\n}\\n\";\n\nvar lightSpecularBlinnPS = \"float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\\n\\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\\n\\tfloat nh = max( dot( h, tNormalW ), 0.0 );\\n\\tfloat specPow = exp2(tGlossiness * 11.0);\\n\\tspecPow = antiAliasGlossiness(specPow);\\n\\tspecPow = max(specPow, 0.0001);\\n\\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\\n}\\nfloat getLightSpecular() {\\n\\treturn calcLightSpecular(dGlossiness, dNormalW);\\n}\\nfloat getLightSpecularCC() {\\n\\treturn calcLightSpecular(ccGlossiness, ccNormalW);\\n}\\n\";\n\nvar lightSpecularPhongPS = \"float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\\n\\tfloat specPow = tGlossiness;\\n\\tspecPow = antiAliasGlossiness(specPow);\\n\\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\\n}\\nfloat getLightSpecular() {\\n\\treturn calcLightSpecular(dGlossiness, dReflDirW);\\n}\\nfloat getLightSpecularCC() {\\n\\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\\n}\\n\";\n\nvar ltc = \"mat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nstruct Coords {\\n\\tvec3 coord0;\\n\\tvec3 coord1;\\n\\tvec3 coord2;\\n\\tvec3 coord3;\\n};\\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\\n\\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\\n\\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 =\tfactor * cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn result;\\n}\\nCoords dLTCCoords;\\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\\n\\tCoords coords;\\n\\tcoords.coord0 = lightPos + halfWidth - halfHeight;\\n\\tcoords.coord1 = lightPos - halfWidth - halfHeight;\\n\\tcoords.coord2 = lightPos - halfWidth + halfHeight;\\n\\tcoords.coord3 = lightPos + halfWidth + halfHeight;\\n\\treturn coords;\\n}\\nfloat dSphereRadius;\\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\\n\\tdSphereRadius = max(length(halfWidth), length(halfHeight));\\n\\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\\n\\tvec3 w = normalize(cross(f, halfHeight));\\n\\tvec3 h = normalize(cross(f, w));\\n\\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\\n}\\nvec2 dLTCUV;\\n#ifdef CLEARCOAT\\nvec2 ccLTCUV;\\n#endif\\nvec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)\\n{\\n\\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\\n\\treturn LTC_Uv( tNormalW, dViewDirW, roughness );\\n}\\nvec3 dLTCSpecFres;\\n#ifdef CLEARCOAT\\nvec3 ccLTCSpecFres;\\n#endif\\nvec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)\\n{\\n\\tvec4 t2 = texture2D( areaLightsLutTex2, uv );\\n\\t#ifdef AREA_R8_G8_B8_A8_LUTS\\n\\tt2 *= vec4(0.693103,1,1,1);\\n\\tt2 += vec4(0.306897,0,0,0);\\n\\t#endif\\n\\treturn tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;\\n}\\nvoid calcLTCLightValues()\\n{\\n\\tdLTCUV = getLTCLightUV(dGlossiness, dNormalW);\\n\\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularityNoFres);\\n#ifdef CLEARCOAT\\n\\tccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);\\n\\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularityNoFres));\\n#endif\\n}\\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\\n{\\n\\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\\n}\\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\\n{\\n\\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\\n}\\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\\n{\\n\\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\\n}\\nvec3 SolveCubic(vec4 Coefficient)\\n{\\n\\tfloat pi = 3.14159;\\n\\tCoefficient.xyz /= Coefficient.w;\\n\\tCoefficient.yz /= 3.0;\\n\\tfloat A = Coefficient.w;\\n\\tfloat B = Coefficient.z;\\n\\tfloat C = Coefficient.y;\\n\\tfloat D = Coefficient.x;\\n\\tvec3 Delta = vec3(\\n\\t\\t-Coefficient.z * Coefficient.z + Coefficient.y,\\n\\t\\t-Coefficient.y * Coefficient.z + Coefficient.x,\\n\\t\\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\\n\\t);\\n\\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\\n\\tvec3 RootsA, RootsD;\\n\\tvec2 xlc, xsc;\\n\\t{\\n\\t\\tfloat A_a = 1.0;\\n\\t\\tfloat C_a = Delta.x;\\n\\t\\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\\n\\t\\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\\n\\t\\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\\n\\t\\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\\n\\t\\tfloat xl;\\n\\t\\tif ((x_1a + x_3a) > 2.0 * B)\\n\\t\\t\\txl = x_1a;\\n\\t\\telse\\n\\t\\t\\txl = x_3a;\\n\\t\\txlc = vec2(xl - B, A);\\n\\t}\\n\\t{\\n\\t\\tfloat A_d = D;\\n\\t\\tfloat C_d = Delta.z;\\n\\t\\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\\n\\t\\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\\n\\t\\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\\n\\t\\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\\n\\t\\tfloat xs;\\n\\t\\tif (x_1d + x_3d < 2.0 * C)\\n\\t\\t\\txs = x_1d;\\n\\t\\telse\\n\\t\\t\\txs = x_3d;\\n\\t\\txsc = vec2(-D, xs + C);\\n\\t}\\n\\tfloat E =\txlc.y * xsc.y;\\n\\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\\n\\tfloat G =\txlc.x * xsc.x;\\n\\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\\n\\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\\n\\tif (Root.x < Root.y && Root.x < Root.z)\\n\\t\\tRoot.xyz = Root.yxz;\\n\\telse if (Root.z < Root.x && Root.z < Root.y)\\n\\t\\tRoot.xyz = Root.xzy;\\n\\treturn Root;\\n}\\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\\n{\\n\\tvec3 T1, T2;\\n\\tT1 = normalize(V - N * dot(V, N));\\n\\tT2 = cross(N, T1);\\n\\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 L_[ 3 ];\\n\\tL_[ 0 ] = R * ( points.coord0 - P );\\n\\tL_[ 1 ] = R * ( points.coord1 - P );\\n\\tL_[ 2 ] = R * ( points.coord2 - P );\\n\\tvec3 Lo_i = vec3(0);\\n\\tvec3 C\t= 0.5 * (L_[0] + L_[2]);\\n\\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\\n\\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\\n\\tC\t= Minv * C;\\n\\tV1 = Minv * V1;\\n\\tV2 = Minv * V2;\\n\\tfloat a, b;\\n\\tfloat d11 = dot(V1, V1);\\n\\tfloat d22 = dot(V2, V2);\\n\\tfloat d12 = dot(V1, V2);\\n\\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\\n\\t{\\n\\t\\tfloat tr = d11 + d22;\\n\\t\\tfloat det = -d12 * d12 + d11 * d22;\\n\\t\\tdet = sqrt(det);\\n\\t\\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\\n\\t\\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\\n\\t\\tfloat e_max = (u + v) * (u + v);\\n\\t\\tfloat e_min = (u - v) * (u - v);\\n\\t\\tvec3 V1_, V2_;\\n\\t\\tif (d11 > d22)\\n\\t\\t{\\n\\t\\t\\tV1_ = d12 * V1 + (e_max - d11) * V2;\\n\\t\\t\\tV2_ = d12 * V1 + (e_min - d11) * V2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tV1_ = d12*V2 + (e_max - d22)*V1;\\n\\t\\t\\tV2_ = d12*V2 + (e_min - d22)*V1;\\n\\t\\t}\\n\\t\\ta = 1.0 / e_max;\\n\\t\\tb = 1.0 / e_min;\\n\\t\\tV1 = normalize(V1_);\\n\\t\\tV2 = normalize(V2_);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\ta = 1.0 / dot(V1, V1);\\n\\t\\tb = 1.0 / dot(V2, V2);\\n\\t\\tV1 *= sqrt(a);\\n\\t\\tV2 *= sqrt(b);\\n\\t}\\n\\tvec3 V3 = cross(V1, V2);\\n\\tif (dot(C, V3) < 0.0)\\n\\t\\tV3 *= -1.0;\\n\\tfloat L\t= dot(V3, C);\\n\\tfloat x0 = dot(V1, C) / L;\\n\\tfloat y0 = dot(V2, C) / L;\\n\\tfloat E1 = inversesqrt(a);\\n\\tfloat E2 = inversesqrt(b);\\n\\ta *= L * L;\\n\\tb *= L * L;\\n\\tfloat c0 = a * b;\\n\\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\\n\\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\\n\\tfloat c3 = 1.0;\\n\\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\\n\\tfloat e1 = roots.x;\\n\\tfloat e2 = roots.y;\\n\\tfloat e3 = roots.z;\\n\\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\\n\\tmat3 rotate = mat3(V1, V2, V3);\\n\\tavgDir = rotate * avgDir;\\n\\tavgDir = normalize(avgDir);\\n\\tfloat L1 = sqrt(-e2 / e3);\\n\\tfloat L2 = sqrt(-e2 / e1);\\n\\tfloat formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\\n\\tuv = uv*LUT_SCALE + LUT_BIAS;\\n\\tfloat scale = texture2D( areaLightsLutTex2, uv ).w;\\n\\treturn formFactor*scale;\\n}\\nfloat getRectLightDiffuse() {\\n\\treturn LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\\n}\\nfloat getDiskLightDiffuse() {\\n\\treturn LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\\n}\\nfloat getSphereLightDiffuse() {\\n\\tfloat falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);\\n\\treturn getLightDiffuse()*falloff;\\n}\\nmat3 getLTCLightInvMat(vec2 uv)\\n{\\n\\tvec4 t1 = texture2D( areaLightsLutTex1, uv );\\n\\t#ifdef AREA_R8_G8_B8_A8_LUTS\\n\\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\\n\\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\\n\\t#endif\\n\\treturn mat3(\\n\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\tvec3(\\t0, 1,\\t0 ),\\n\\t\\tvec3( t1.z, 0, t1.w )\\n\\t);\\n}\\nfloat calcRectLightSpecular(vec3 tNormalW, vec2 uv) {\\n\\tmat3 mInv = getLTCLightInvMat(uv);\\n\\treturn LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\\n}\\nfloat getRectLightSpecular() {\\n\\treturn calcRectLightSpecular(dNormalW, dLTCUV);\\n}\\n#ifdef CLEARCOAT\\nfloat getRectLightSpecularCC() {\\n\\treturn calcRectLightSpecular(ccNormalW, ccLTCUV);\\n}\\n#endif\\nfloat calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {\\n\\tmat3 mInv = getLTCLightInvMat(uv);\\n\\treturn LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\\n}\\nfloat getDiskLightSpecular() {\\n\\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\\n}\\n#ifdef CLEARCOAT\\nfloat getDiskLightSpecularCC() {\\n\\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\\n}\\n#endif\\nfloat getSphereLightSpecular() {\\n\\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\\n}\\n#ifdef CLEARCOAT\\nfloat getSphereLightSpecularCC() {\\n\\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\\n}\\n#endif\\n\";\n\nvar metalnessPS = \"void processMetalness(float metalness) {\\n\\tconst float dielectricF0 = 0.04;\\n\\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\\n\\tdAlbedo *= 1.0 - metalness;\\n}\\n#ifdef MAPFLOAT\\nuniform float material_metalness;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_metalnessMap;\\n#endif\\nvoid getSpecularity() {\\n\\tfloat metalness = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tmetalness *= material_metalness;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tmetalness *= texture2D(texture_metalnessMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tmetalness *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tprocessMetalness(metalness);\\n}\\n\";\n\nvar msdfPS = \"uniform sampler2D texture_msdfMap;\\n#ifdef GL_OES_standard_derivatives\\n#define USE_FWIDTH\\n#endif\\n#ifdef GL2\\n#define USE_FWIDTH\\n#endif\\nfloat median(float r, float g, float b) {\\n\\treturn max(min(r, g), min(max(r, g), b));\\n}\\nfloat map (float min, float max, float v) {\\n\\treturn (v - min) / (max - min);\\n}\\nuniform float font_sdfIntensity;\\nuniform float font_pxrange;\\nuniform float font_textureWidth;\\nuniform vec4 outline_color;\\nuniform float outline_thickness;\\nuniform vec4 shadow_color;\\nuniform vec2 shadow_offset;\\nvec4 applyMsdf(vec4 color) {\\n\\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\\n\\tvec2 uvShdw = vUv0 - shadow_offset;\\n\\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\\n\\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\\n\\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\\n\\tfloat smoothingMax = 0.2;\\n\\t#ifdef USE_FWIDTH\\n\\tvec2 w = fwidth(vUv0);\\n\\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\\n\\t#else\\n\\tfloat font_size = 16.0;\\n\\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\\n\\t#endif\\n\\tfloat mapMin = 0.05;\\n\\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\\n\\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\\n\\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\\n\\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\\n\\tfloat center = 0.5;\\n\\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\\n\\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\\n\\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\\n\\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\\n\\ttcolor = mix(tcolor, color, inside);\\n\\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\\n\\ttcolor = mix(scolor, tcolor, outline);\\n\\treturn tcolor;\\n}\\n\";\n\nvar normalVS = \"#ifdef MORPHING_TEXTURE_BASED_NORMAL\\nuniform highp sampler2D morphNormalTex;\\n#endif\\nvec3 getNormal() {\\n\\t#ifdef SKIN\\n\\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\\n\\t#elif defined(INSTANCING)\\n\\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\\n\\t#else\\n\\tdNormalMatrix = matrix_normal;\\n\\t#endif\\n\\tvec3 tempNormal = vertex_normal;\\n\\t#ifdef MORPHING\\n\\t#ifdef MORPHING_NRM03\\n\\ttempNormal += morph_weights_a[0] * morph_nrm0;\\n\\ttempNormal += morph_weights_a[1] * morph_nrm1;\\n\\ttempNormal += morph_weights_a[2] * morph_nrm2;\\n\\ttempNormal += morph_weights_a[3] * morph_nrm3;\\n\\t#endif\\n\\t#ifdef MORPHING_NRM47\\n\\ttempNormal += morph_weights_b[0] * morph_nrm4;\\n\\ttempNormal += morph_weights_b[1] * morph_nrm5;\\n\\ttempNormal += morph_weights_b[2] * morph_nrm6;\\n\\ttempNormal += morph_weights_b[3] * morph_nrm7;\\n\\t#endif\\n\\t#endif\\n\\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\\n\\tvec2 morphUV = getTextureMorphCoords();\\n\\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\\n\\ttempNormal += morphNormal;\\n\\t#endif\\n\\treturn normalize(dNormalMatrix * tempNormal);\\n}\\n\";\n\nvar normalDetailMapPS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_normalDetailMap;\\nuniform float material_normalDetailMapBumpiness;\\nvec3 blendNormals(vec3 n1, vec3 n2) {\\n\\tn1 += vec3(0, 0, 1);\\n\\tn2 *= vec3(-1, -1, 1);\\n\\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\\n}\\n#endif\\nvec3 addNormalDetail(vec3 normalMap) {\\n\\t#ifdef MAPTEXTURE\\n\\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV));\\n\\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\\n\\treturn blendNormals(normalMap, normalDetailMap);\\n\\t#else\\n\\treturn normalMap;\\n\\t#endif\\n}\\n\";\n\nvar normalInstancedVS = \"vec3 getNormal() {\\n\\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\\n\\treturn normalize(dNormalMatrix * vertex_normal);\\n}\\n\";\n\nvar normalMapPS = \"uniform sampler2D texture_normalMap;\\nuniform float material_bumpiness;\\nvoid getNormal() {\\n\\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\\n\\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\\n\\tdNormalMap = addNormalDetail(normalMap);\\n\\tdNormalW = dTBN * dNormalMap;\\n}\\n\";\n\nvar normalMapFastPS = \"uniform sampler2D texture_normalMap;\\nvoid getNormal() {\\n\\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\\n\\tdNormalMap = addNormalDetail(normalMap);\\n\\tdNormalW = dTBN * dNormalMap;\\n}\\n\";\n\nvar normalSkinnedVS = \"vec3 getNormal() {\\n\\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\\n\\treturn normalize(dNormalMatrix * vertex_normal);\\n}\\n\";\n\nvar normalVertexPS = \"void getNormal() {\\n\\tdNormalW = normalize(dVertexNormalW);\\n}\\n\";\n\nvar normalXYPS = \"vec3 unpackNormal(vec4 nmap) {\\n\\tvec3 normal;\\n\\tnormal.xy = nmap.wy * 2.0 - 1.0;\\n\\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\\n\\treturn normal;\\n}\\n\";\n\nvar normalXYZPS = \"vec3 unpackNormal(vec4 nmap) {\\n\\treturn nmap.xyz * 2.0 - 1.0;\\n}\\n\";\n\nvar opacityPS = \"#ifdef MAPFLOAT\\nuniform float material_opacity;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_opacityMap;\\n#endif\\nvoid getOpacity() {\\n\\tdAlpha = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tdAlpha *= material_opacity;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tdAlpha *= texture2D(texture_opacityMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\\n\\t#endif\\n}\\n\";\n\nvar outputAlphaPS = \"gl_FragColor.a = dAlpha;\\n\";\n\nvar outputAlphaOpaquePS = \"gl_FragColor.a = 1.0;\\n\";\n\nvar outputAlphaPremulPS = \"gl_FragColor.rgb *= dAlpha;\\ngl_FragColor.a = dAlpha;\\n\";\n\nvar outputCubemapPS = \"varying vec2 vUv0;\\nuniform samplerCube source;\\nuniform vec4 params;\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec4 encodeRGBM(vec4 color) {\\n\\tcolor.rgb = pow(color.rgb, vec3(0.5));\\n\\tcolor.rgb *= 1.0 / 8.0;\\n\\tcolor.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\\n\\tcolor.a = ceil(color.a * 255.0) / 255.0;\\n\\tcolor.rgb /= color.a;\\n\\treturn color;\\n}\\nvoid main(void) {\\n\\tvec2 st = vUv0 * 2.0 - 1.0;\\n\\tfloat face = params.x;\\n\\tvec3 vec;\\n\\tif (face==0.0) {\\n\\t\\tvec = vec3(1, -st.y, -st.x);\\n\\t} else if (face==1.0) {\\n\\t\\tvec = vec3(-1, -st.y, st.x);\\n\\t} else if (face==2.0) {\\n\\t\\tvec = vec3(st.x, 1, st.y);\\n\\t} else if (face==3.0) {\\n\\t\\tvec = vec3(st.x, -1, -st.y);\\n\\t} else if (face==4.0) {\\n\\t\\tvec = vec3(st.x, -st.y, 1);\\n\\t} else {\\n\\t\\tvec = vec3(-st.x, -st.y, -1);\\n\\t}\\n\\tgl_FragColor = textureCube(source, vec);\\n\\tif (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\\n}\\n\";\n\nvar outputTex2DPS = \"varying vec2 vUv0;\\nuniform sampler2D source;\\nvoid main(void) {\\n\\tgl_FragColor = texture2D(source, vUv0);\\n}\\n\";\n\nvar packDepthPS = \"vec4 packFloat(float depth) {\\n\\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\\n\\tconst vec4 bit_mask\t= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\\n\\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\\n\\tres -= res.xxyz * bit_mask;\\n\\treturn res;\\n}\\n\";\n\nvar packDepthMaskPS = \"vec4 packFloat(float depth) {\\n\\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\\n\\tconst vec4 bit_mask\t= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\\n\\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\\n\\tres.x = 0.0;\\n\\tres -= res.xxyz * bit_mask;\\n\\treturn res;\\n}\\n\";\n\nvar parallaxPS = \"uniform sampler2D texture_heightMap;\\nuniform float material_heightMapFactor;\\nvoid getParallax() {\\n\\tfloat parallaxScale = material_heightMapFactor;\\n\\tfloat height = texture2D(texture_heightMap, $UV).$CH;\\n\\theight = height * parallaxScale - parallaxScale*0.5;\\n\\tvec3 viewDirT = dViewDirW * dTBN;\\n\\tviewDirT.z += 0.42;\\n\\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\\n}\\n\";\n\nvar particlePS = \"varying vec4 texCoordsAlphaLife;\\nuniform sampler2D colorMap;\\nuniform sampler2D colorParam;\\nuniform float graphSampleSize;\\nuniform float graphNumSamples;\\n#ifndef CAMERAPLANES\\n#define CAMERAPLANES\\nuniform vec4 camera_params;\\n#endif\\nuniform float softening;\\nuniform float colorMult;\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\n#ifndef UNPACKFLOAT\\n#define UNPACKFLOAT\\nfloat unpackFloat(vec4 rgbaDepth) {\\n\\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\\n\\tfloat depth = dot(rgbaDepth, bitShift);\\n\\treturn depth;\\n}\\n#endif\\nvoid main(void) {\\n\\tvec4 tex\t= texture2DSRGB(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\\n\\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\\n\\tramp.rgb *= colorMult;\\n\\tramp.a += texCoordsAlphaLife.z;\\n\\tvec3 rgb = tex.rgb * ramp.rgb;\\n\\tfloat a\t= tex.a * ramp.a;\\n\";\n\nvar particleVS = \"vec3 unpack3NFloats(float src) {\\n\\tfloat r = fract(src);\\n\\tfloat g = fract(src * 256.0);\\n\\tfloat b = fract(src * 65536.0);\\n\\treturn vec3(r, g, b);\\n}\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\\n\\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\\n}\\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\\n\\tvec4 a = texture2D(tex,tc);\\n\\tvec4 b = texture2D(tex,tc + graphSampleSize);\\n\\tfloat c = fract(tc.x*graphNumSamples);\\n\\tvec3 unpackedA = unpack3NFloats(a.w);\\n\\tvec3 unpackedB = unpack3NFloats(b.w);\\n\\tw = mix(unpackedA, unpackedB, c);\\n\\treturn mix(a, b, c);\\n}\\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\\n\\tfloat c = cos(pRotation);\\n\\tfloat s = sin(pRotation);\\n\\tmat2 m = mat2(c, -s, s, c);\\n\\trotMatrix = m;\\n\\treturn m * quadXY;\\n}\\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\\n\\t#ifdef SCREEN_SPACE\\n\\t\\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\\n\\t#else\\n\\t\\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\\n\\t#endif\\n\\treturn pos;\\n}\\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\\n\\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\\n\\treturn pos;\\n}\\nvec2 safeNormalize(vec2 v) {\\n\\tfloat l = length(v);\\n\\treturn (l > 1e-06) ? v / l : v;\\n}\\nvoid main(void) {\\n\\tvec3 meshLocalPos = particle_vertexData.xyz;\\n\\tfloat id = floor(particle_vertexData.w);\\n\\tfloat rndFactor = fract(sin(id + 1.0 + seed));\\n\\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\\n\\tfloat uv = id / numParticlesPot;\\n\\treadInput(uv);\\n#ifdef LOCAL_SPACE\\n\\tinVel = mat3(matrix_model) * inVel;\\n#endif\\n\\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\\n\\tfloat particleLifetime = lifetime;\\n\\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\\n\\tvec2 quadXY = meshLocalPos.xy;\\n\\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\\n\\tvec3 paramDiv;\\n\\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\\n\\tfloat scale = params.y;\\n\\tfloat scaleDiv = paramDiv.x;\\n\\tfloat alphaDiv = paramDiv.z;\\n\\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\\n#ifndef USE_MESH\\n\\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\\n#else\\n\\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\\n#endif\\n\\tvec3 particlePos = inPos;\\n\\tvec3 particlePosMoved = vec3(0.0);\\n\\tmat2 rotMatrix;\\n\";\n\nvar particleAnimFrameClampVS = \"\\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\\n\";\n\nvar particleAnimFrameLoopVS = \"\\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\\n\";\n\nvar particleAnimTexVS = \"\\tfloat animationIndex;\\n\\tif (animTexIndexParams.y == 1.0) {\\n\\t\\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\\n\\t} else {\\n\\t\\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\\n\\t}\\n\\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\\n\\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\\n\\tatlasX = fract(atlasX);\\n\\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\\n\\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\\n\";\n\nvar particleInputFloatPS = \"void readInput(float uv) {\\n\\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\\n\\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\\n\\tinPos = tex.xyz;\\n\\tinVel = tex2.xyz;\\n\\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\\n\\tinShow = tex.w >= 0.0;\\n\\tinLife = tex2.w;\\n}\\n\";\n\nvar particleInputRgba8PS = \"#define PI2 6.283185307179586\\nuniform vec3 inBoundsSize;\\nuniform vec3 inBoundsCenter;\\nuniform float maxVel;\\nfloat decodeFloatRG(vec2 rg) {\\n\\treturn rg.y*(1.0/255.0) + rg.x;\\n}\\nfloat decodeFloatRGBA( vec4 rgba ) {\\n\treturn dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\\n}\\nvoid readInput(float uv) {\\n\\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\\n\\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\\n\\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\\n\\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\\n\\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\\n\\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\\n\\tinVel = tex2.xyz;\\n\\tinVel = (inVel - vec3(0.5)) * maxVel;\\n\\tinAngle = decodeFloatRG(tex1.ba) * PI2;\\n\\tinShow = tex2.a > 0.5;\\n\\tinLife = decodeFloatRGBA(tex3);\\n\\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\\n\\tfloat maxPosLife = lifetime+1.0;\\n\\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\\n}\\n\";\n\nvar particleOutputFloatPS = \"void writeOutput() {\\n\\tif (gl_FragCoord.y<1.0) {\\n\\t\\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\\n\\t} else {\\n\\t\\tgl_FragColor = vec4(outVel, outLife);\\n\\t}\\n}\\n\";\n\nvar particleOutputRgba8PS = \"uniform vec3 outBoundsMul;\\nuniform vec3 outBoundsAdd;\\nvec2 encodeFloatRG( float v ) {\\n\\tvec2 enc = vec2(1.0, 255.0) * v;\\n\\tenc = fract(enc);\\n\\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\\n\\treturn enc;\\n}\\nvec4 encodeFloatRGBA( float v ) {\\n\\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\\n\\tenc = fract(enc);\\n\\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\\n\\treturn enc;\\n}\\nvoid writeOutput() {\\n\\toutPos = outPos * outBoundsMul + outBoundsAdd;\\n\\toutAngle = fract(outAngle / PI2);\\n\\toutVel = (outVel / maxVel) + vec3(0.5);\\n\\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\\n\\tfloat maxPosLife = lifetime+1.0;\\n\\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\\n\\tif (gl_FragCoord.y < 1.0) {\\n\\t\\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\\n\\t} else if (gl_FragCoord.y < 2.0) {\\n\\t\\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\\n\\t} else if (gl_FragCoord.y < 3.0) {\\n\\t\\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\\n\\t} else {\\n\\t\\tgl_FragColor = encodeFloatRGBA(outLife);\\n\\t}\\n}\\n\";\n\nvar particleUpdaterAABBPS = \"uniform mat3 spawnBounds;\\nuniform vec3 spawnPosInnerRatio;\\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\\n\\tvec3 pos = inBounds - vec3(0.5);\\n\\tvec3 posAbs = abs(pos);\\n\\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\\n\\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\\n\\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\\n\\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\\n\\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\\n#ifndef LOCAL_SPACE\\n\\treturn emitterPos + spawnBounds * pos;\\n#else\\n\\treturn spawnBounds * pos;\\n#endif\\n}\\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\\n\\tlocalVelocity -= vec3(0, 0, initialVelocity);\\n}\\n\";\n\nvar particleUpdaterEndPS = \"\\twriteOutput();\\n}\\n\";\n\nvar particleUpdaterInitPS = \"varying vec2 vUv0;\\nuniform highp sampler2D particleTexIN;\\nuniform highp sampler2D internalTex0;\\nuniform highp sampler2D internalTex1;\\nuniform highp sampler2D internalTex2;\\nuniform highp sampler2D internalTex3;\\nuniform mat3 emitterMatrix, emitterMatrixInv;\\nuniform vec3 emitterScale;\\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\\nuniform float startAngle, startAngle2;\\nuniform float initialVelocity;\\nuniform float graphSampleSize;\\nuniform float graphNumSamples;\\nvec3 inPos;\\nvec3 inVel;\\nfloat inAngle;\\nbool inShow;\\nfloat inLife;\\nfloat visMode;\\nvec3 outPos;\\nvec3 outVel;\\nfloat outAngle;\\nbool outShow;\\nfloat outLife;\\n\";\n\nvar particleUpdaterNoRespawnPS = \"\\tif (outLife >= lifetime) {\\n\\t\\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\\n\\t\\tvisMode = -1.0;\\n\\t}\\n\";\n\nvar particleUpdaterOnStopPS = \"\\tvisMode = outLife < 0.0? -1.0: visMode;\\n\";\n\nvar particleUpdaterRespawnPS = \"\\tif (outLife >= lifetime) {\\n\\t\\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\\n\\t\\tvisMode = 1.0;\\n\\t}\\n\\tvisMode = outLife < 0.0? 1.0: visMode;\\n\";\n\nvar particleUpdaterSpherePS = \"uniform float spawnBoundsSphere;\\nuniform float spawnBoundsSphereInnerRatio;\\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\\n\\tfloat rnd4 = fract(rndFactor * 1000.0);\\n\\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\\n\\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\\n#ifndef LOCAL_SPACE\\n\\treturn emitterPos + norm * r * spawnBoundsSphere;\\n#else\\n\\treturn norm * r * spawnBoundsSphere;\\n#endif\\n}\\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\\n\\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\\n}\\n\";\n\nvar particleUpdaterStartPS = \"float saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec3 unpack3NFloats(float src) {\\n\\tfloat r = fract(src);\\n\\tfloat g = fract(src * 256.0);\\n\\tfloat b = fract(src * 65536.0);\\n\\treturn vec3(r, g, b);\\n}\\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\\n\\tvec4 a = texture2D(tex, tc);\\n\\tvec4 b = texture2D(tex, tc + graphSampleSize);\\n\\tfloat c = fract(tc.x * graphNumSamples);\\n\\tvec3 unpackedA = unpack3NFloats(a.w);\\n\\tvec3 unpackedB = unpack3NFloats(b.w);\\n\\tw = mix(unpackedA, unpackedB, c);\\n\\treturn mix(a.xyz, b.xyz, c);\\n}\\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\\nvec4 hash41(float p) {\\n\\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\\n\\tp4 += dot(p4, p4.wzxy+19.19);\\n\\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\\n}\\nvoid main(void) {\\n\\tif (gl_FragCoord.x > numParticles) discard;\\n\\treadInput(vUv0.x);\\n\\tvisMode = inShow? 1.0 : -1.0;\\n\\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\\n\\tfloat particleRate = rate + rateDiv * rndFactor.x;\\n\\toutLife = inLife + delta;\\n\\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\\n\\tvec3 localVelocityDiv;\\n\\tvec3 velocityDiv;\\n\\tvec3 paramDiv;\\n\\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\\n\\tvec3 velocity =\\t\ttex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\\n\\tvec3 params =\\t\\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\\n\\tfloat rotSpeed = params.x;\\n\\tfloat rotSpeedDiv = paramDiv.y;\\n\\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\\n\\tfloat radialSpeed = radialParams.x;\\n\\tfloat radialSpeedDiv = radialParams.y;\\n\\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\\n\\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\\n\\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\\n#ifndef LOCAL_SPACE\\n\\tvec3 radialVel = inPos - emitterPos;\\n#else\\n\\tvec3 radialVel = inPos;\\n#endif\\n\\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\\n\\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\\n\\tlocalVelocity +=\\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\\n\\tvelocity +=\\t\\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\\n\\trotSpeed +=\\t\\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\\n\\taddInitialVelocity(localVelocity, rndFactor.xyz);\\n#ifndef LOCAL_SPACE\\n\\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\\n#else\\n\\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\\n#endif\\n\\toutPos = inPos + outVel * delta;\\n\\toutAngle = inAngle + rotSpeed * delta;\\n\";\n\nvar particle_billboardVS = \"\\tquadXY = rotate(quadXY, inAngle, rotMatrix);\\n\\tvec3 localPos = billboard(particlePos, quadXY);\\n\";\n\nvar particle_blendAddPS = \"\\tdBlendModeFogFactor = 0.0;\\n\\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\\n\\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\\n\";\n\nvar particle_blendMultiplyPS = \"\\trgb = mix(vec3(1.0), rgb, vec3(a));\\n\\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\\n\";\n\nvar particle_blendNormalPS = \"\\tif (a < 0.01) discard;\\n\";\n\nvar particle_cpuVS = \"attribute vec4 particle_vertexData;\\nattribute vec4 particle_vertexData2;\\nattribute vec4 particle_vertexData3;\\nattribute float particle_vertexData4;\\n#ifndef USE_MESH\\n#define VDATA5TYPE vec2\\n#else\\n#define VDATA5TYPE vec4\\n#endif\\nattribute VDATA5TYPE particle_vertexData5;\\nuniform mat4 matrix_viewProjection;\\nuniform mat4 matrix_model;\\n#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nuniform mat3 matrix_normal;\\nuniform mat4 matrix_viewInverse;\\nuniform float numParticles;\\nuniform float lifetime;\\nuniform float stretch;\\nuniform float seed;\\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\\nuniform sampler2D texLifeAndSourcePosOUT;\\nuniform highp sampler2D internalTex0;\\nuniform highp sampler2D internalTex1;\\nuniform highp sampler2D internalTex2;\\nuniform vec3 emitterPos;\\nvarying vec4 texCoordsAlphaLife;\\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\\n{\\n\\tfloat c = cos(pRotation);\\n\\tfloat s = sin(pRotation);\\n\\tmat2 m = mat2(c, -s, s, c);\\n\\trotMatrix = m;\\n\\treturn m * quadXY;\\n}\\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\\n{\\n\\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\\n\\treturn pos;\\n}\\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\\n{\\n\\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\\n\\treturn pos;\\n}\\nvoid main(void)\\n{\\n\\tvec3 particlePos = particle_vertexData.xyz;\\n\\tvec3 inPos = particlePos;\\n\\tvec3 vertPos = particle_vertexData3.xyz;\\n\\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\\n\\tfloat id = floor(particle_vertexData4);\\n\\tfloat rndFactor = fract(sin(id + 1.0 + seed));\\n\\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\\n#ifdef LOCAL_SPACE\\n\\tinVel = mat3(matrix_model) * inVel;\\n#endif\\n\\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\\n\\tvec2 quadXY = vertPos.xy;\\n#ifdef USE_MESH\\n\\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\\n#else\\n\\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\\n#endif\\n\\tmat2 rotMatrix;\\n\\tfloat inAngle = particle_vertexData2.x;\\n\\tvec3 particlePosMoved = vec3(0.0);\\n\\tvec3 meshLocalPos = particle_vertexData3.xyz;\\n\";\n\nvar particle_cpu_endVS = \"\\tlocalPos *= particle_vertexData2.y * emitterScale;\\n\\tlocalPos += particlePos;\\n\\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\\n\";\n\nvar particle_customFaceVS = \"\\tquadXY = rotate(quadXY, inAngle, rotMatrix);\\n\\tvec3 localPos = customFace(particlePos, quadXY);\\n\";\n\nvar particle_endPS = \"\\trgb = addFog(rgb);\\n\\trgb = toneMap(rgb);\\n\\trgb = gammaCorrectOutput(rgb);\\n\\tgl_FragColor = vec4(rgb, a);\\n}\\n\";\n\nvar particle_endVS = \"\\tlocalPos *= scale * emitterScale;\\n\\tlocalPos += particlePos;\\n\\t#ifdef SCREEN_SPACE\\n\\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\\n\\t#else\\n\\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\\n\\t#endif\\n\";\n\nvar particle_halflambertPS = \"\\tvec3 negNormal = normal*0.5+0.5;\\n\\tvec3 posNormal = -normal*0.5+0.5;\\n\\tnegNormal *= negNormal;\\n\\tposNormal *= posNormal;\\n\";\n\nvar particle_initVS = \"attribute vec4 particle_vertexData;\\n#ifdef USE_MESH\\nattribute vec2 particle_uv;\\n#endif\\nuniform mat4 matrix_viewProjection;\\nuniform mat4 matrix_model;\\nuniform mat3 matrix_normal;\\nuniform mat4 matrix_viewInverse;\\n#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nuniform float numParticles, numParticlesPot;\\nuniform float graphSampleSize;\\nuniform float graphNumSamples;\\nuniform float stretch;\\nuniform vec3 wrapBounds;\\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\\nuniform sampler2D particleTexOUT, particleTexIN;\\nuniform highp sampler2D internalTex0;\\nuniform highp sampler2D internalTex1;\\nuniform highp sampler2D internalTex2;\\n#ifndef CAMERAPLANES\\n#define CAMERAPLANES\\nuniform vec4 camera_params;\\n#endif\\nvarying vec4 texCoordsAlphaLife;\\nvec3 inPos;\\nvec3 inVel;\\nfloat inAngle;\\nbool inShow;\\nfloat inLife;\\n\";\n\nvar particle_lambertPS = \"\\tvec3 negNormal = max(normal, vec3(0.0));\\n\\tvec3 posNormal = max(-normal, vec3(0.0));\\n\";\n\nvar particle_lightingPS = \"\\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\\n\\t\\t\\t\\t\\t\\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\\n\\t\\t\\t\\t\\t\\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\\n\\trgb *= light;\\n\";\n\nvar particle_localShiftVS = \"\\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\\n\";\n\nvar particle_meshVS = \"\\tvec3 localPos = meshLocalPos;\\n\\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\\n\\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\\n\\tbillboard(particlePos, quadXY);\\n\";\n\nvar particle_normalVS = \"\\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\\n\";\n\nvar particle_normalMapPS = \"\\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\\n\\tvec3 normal = ParticleMat * normalMap;\\n\";\n\nvar particle_pointAlongVS = \"\\tinAngle = atan(velocityV.x, velocityV.y);\\n\";\n\nvar particle_softPS = \"\\tfloat depth = getLinearScreenDepth();\\n\\tfloat particleDepth = vDepth;\\n\\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\\n\\ta *= depthDiff;\\n\";\n\nvar particle_softVS = \"\\tvDepth = getLinearDepth(localPos);\\n\";\n\nvar particle_stretchVS = \"\\tvec3 moveDir = inVel * stretch;\\n\\tvec3 posPrev = particlePos - moveDir;\\n\\tposPrev += particlePosMoved;\\n\\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\\n\\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\\n\\tparticlePos = mix(particlePos, posPrev, interpolation);\\n\";\n\nvar particle_TBNVS = \"\\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\\n\\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\\n\";\n\nvar particle_wrapVS = \"\\tvec3 origParticlePos = particlePos;\\n\\tparticlePos -= matrix_model[3].xyz;\\n\\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\\n\\tparticlePos += matrix_model[3].xyz;\\n\\tparticlePosMoved = particlePos - origParticlePos;\\n\";\n\nvar precisionTestPS = \"void main(void) {\\n\\tgl_FragColor = vec4(2147483648.0);\\n}\\n\";\n\nvar precisionTest2PS = \"uniform sampler2D source;\\nvec4 packFloat(float depth) {\\n\\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\\n\\tconst vec4 bit_mask\t= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\\n\\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\\n\\tres -= res.xxyz * bit_mask;\\n\\treturn res;\\n}\\nvoid main(void) {\\n\\tfloat c = texture2D(source, vec2(0.0)).r;\\n\\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\\n\\tgl_FragColor = packFloat(diff);\\n}\\n\";\n\nvar reflDirPS = \"void getReflDir() {\\n\\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\\n}\\n\";\n\nvar reflDirAnisoPS = \"void getReflDir() {\\n\\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\\n\\tfloat anisotropy = material_anisotropy * roughness;\\n\\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\\n\\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\\n\\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\\n\\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\\n\\tdReflDirW = reflect(-dViewDirW, bentNormal);\\n}\\n\";\n\nvar reflectionCCPS = \"#ifdef CLEARCOAT\\nuniform float material_clearCoatReflectivity;\\nvoid addReflectionCC() {\\n\\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\\n}\\n#endif\\n\";\n\nvar reflectionCubePS = \"uniform samplerCube texture_cubeMap;\\nuniform float material_reflectivity;\\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\\n\\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\\n\\tlookupVec.x *= -1.0;\\n\\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\\n}\\nvoid addReflection() {\\n\\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\\n}\\n\";\n\nvar reflectionEnvPS = \"#ifndef ENV_ATLAS\\n#define ENV_ATLAS\\nuniform sampler2D texture_envAtlas;\\n#endif\\nuniform float material_reflectivity;\\nfloat shinyMipLevel(vec2 uv) {\\n\\tvec2 dx = dFdx(uv);\\n\\tvec2 dy = dFdy(uv);\\n\\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\\n\\tvec2 dx2 = dFdx(uv2);\\n\\tvec2 dy2 = dFdy(uv2);\\n\\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\\n\\treturn clamp(0.5 * log2(maxd) - 1.0, 0.0, 6.0);\\n}\\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\\n\\tvec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\\n\\tvec2 uv = toSphericalUv(dir);\\n\\tfloat level = saturate(1.0 - tGlossiness) * 5.0;\\n\\tfloat ilevel = floor(level);\\n\\tfloat level2 = shinyMipLevel(uv * atlasSize);\\n\\tfloat ilevel2 = floor(level2);\\n\\tvec2 uv0, uv1;\\n\\tfloat weight;\\n\\tif (ilevel == 0.0) {\\n\\t\\tuv0 = mapMip(uv, ilevel2);\\n\\t\\tuv1 = mapMip(uv, ilevel2 + 1.0);\\n\\t\\tweight = level2 - ilevel2;\\n\\t} else {\\n\\t\\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\\n\\t\\tweight = 0.0;\\n\\t}\\n\\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\\n\\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\\n\\tvec3 linear0 = mix(linearA, linearB, weight);\\n\\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\\n\\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\\n}\\nvoid addReflection() {\\n\\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\\n}\\n\";\n\nvar reflectionSpherePS = \"#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nuniform sampler2D texture_sphereMap;\\nuniform float material_reflectivity;\\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\\n\\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\\n\\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\\n\\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\\n\\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\\n}\\nvoid addReflection() {\\n\\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\\n}\\n\";\n\nvar reflectionSphereLowPS = \"uniform sampler2D texture_sphereMap;\\nuniform float material_reflectivity;\\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\\n\\tvec3 reflDirV = vNormalV;\\n\\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\\n\\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\\n}\\nvoid addReflection() {\\n\\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\\n}\\n\";\n\nvar refractionPS = \"uniform float material_refraction, material_refractionIndex;\\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\\n\\tfloat vn = dot(viewVec, Normal);\\n\\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\\n\\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\\n\\treturn refrVec;\\n}\\nvoid addRefraction() {\\n\\tvec3 tmp = dReflDirW;\\n\\tvec4 tmp2 = dReflection;\\n\\tdReflection = vec4(0.0);\\n\\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\\n\\taddReflection();\\n\\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\\n\\tdReflDirW = tmp;\\n\\tdReflection = tmp2;\\n}\\n\";\n\nvar reprojectPS = \"varying vec2 vUv0;\\nuniform sampler2D sourceTex;\\nuniform samplerCube sourceCube;\\nuniform sampler2D samplesTex;\\nuniform vec2 samplesTexInverseSize;\\nuniform vec4 params;\\nuniform vec2 params2;\\nfloat targetFace() { return params.x; }\\nfloat specularPower() { return params.y; }\\nfloat sourceCubeSeamScale() { return params.z; }\\nfloat targetCubeSeamScale() { return params.w; }\\nfloat targetTotalPixels() { return params2.x; }\\nfloat sourceTotalPixels() { return params2.y; }\\nfloat PI = 3.141592653589793;\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec3 decodeLinear(vec4 source) {\\n\\treturn source.rgb;\\n}\\nvec4 encodeLinear(vec3 source) {\\n\\treturn vec4(source, 1.0);\\n}\\nvec3 decodeGamma(vec4 source) {\\n\\treturn pow(source.xyz, vec3(2.2));\\n}\\nvec4 encodeGamma(vec3 source) {\\n\\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\\n}\\nvec3 decodeRGBM(vec4 rgbm) {\\n\\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\\n\\treturn color * color;\\n}\\nvec4 encodeRGBM(vec3 source) {\\n\\tvec4 result;\\n\\tresult.rgb = pow(source.rgb, vec3(0.5));\\n\\tresult.rgb *= 1.0 / 8.0;\\n\\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\\n\\tresult.a = ceil(result.a * 255.0) / 255.0;\\n\\tresult.rgb /= result.a;\\n\\treturn result;\\n}\\nvec3 decodeRGBE(vec4 source) {\\n\\tif (source.a == 0.0) {\\n\\t\\treturn vec3(0.0, 0.0, 0.0);\\n\\t} else {\\n\\t\\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\\n\\t}\\n}\\nvec4 encodeRGBE(vec3 source) {\\n\\tfloat maxVal = max(source.x, max(source.y, source.z));\\n\\tif (maxVal < 1e-32) {\\n\\t\\treturn vec4(0, 0, 0, 0);\\n\\t} else {\\n\\t\\tfloat e = ceil(log2(maxVal));\\n\\t\\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\\n\\t}\\n}\\nvec3 modifySeams(vec3 dir, float scale) {\\n\\tvec3 adir = abs(dir);\\n\\tfloat M = max(max(adir.x, adir.y), adir.z);\\n\\treturn dir / M * vec3(\\n\\t\\tadir.x == M ? 1.0 : scale,\\n\\t\\tadir.y == M ? 1.0 : scale,\\n\\t\\tadir.z == M ? 1.0 : scale\\n\\t);\\n}\\nvec2 toSpherical(vec3 dir) {\\n\\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\\n}\\nvec3 fromSpherical(vec2 uv) {\\n\\treturn vec3(cos(uv.y) * sin(uv.x),\\n\\t\\t\\t\\tsin(uv.y),\\n\\t\\t\\t\\tcos(uv.y) * cos(uv.x));\\n}\\nvec3 getDirectionEquirect() {\\n\\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\\n}\\nvec4 sampleEquirect(vec2 sph) {\\n\\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\\n\\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\\n}\\nvec4 sampleEquirect(vec3 dir) {\\n\\treturn sampleEquirect(toSpherical(dir));\\n}\\nvec4 sampleCubemap(vec3 dir) {\\n\\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\\n}\\nvec4 sampleCubemap(vec2 sph) {\\n\\treturn sampleCubemap(fromSpherical(sph));\\n}\\nvec4 sampleEquirect(vec2 sph, float mipLevel) {\\n\\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\\n#ifdef SUPPORTS_TEXLOD\\n\\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\\n#else\\n\\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\\n#endif\\n}\\nvec4 sampleEquirect(vec3 dir, float mipLevel) {\\n\\treturn sampleEquirect(toSpherical(dir), mipLevel);\\n}\\nvec4 sampleCubemap(vec3 dir, float mipLevel) {\\n#ifdef SUPPORTS_TEXLOD\\n\\treturn textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\\n#else\\n\\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()));\\n#endif\\n}\\nvec4 sampleCubemap(vec2 sph, float mipLevel) {\\n\\treturn sampleCubemap(fromSpherical(sph), mipLevel);\\n}\\nfloat signNotZero(float k){\\n\\treturn(k >= 0.0) ? 1.0 : -1.0;\\n}\\nvec2 signNotZero(vec2 v) {\\n\\treturn vec2(signNotZero(v.x), signNotZero(v.y));\\n}\\nvec3 octDecode(vec2 o) {\\n\\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\\n\\tif (v.y < 0.0) {\\n\\t\\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\\n\\t}\\n\\treturn normalize(v);\\n}\\nvec3 getDirectionOctahedral() {\\n\\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\\n}\\nvec2 octEncode(in vec3 v) {\\n\\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\\n\\tvec2 result = v.xz * (1.0 / l1norm);\\n\\tif (v.y < 0.0) {\\n\\t\\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\\n\\t}\\n\\treturn result;\\n}\\nvec4 sampleOctahedral(vec3 dir) {\\n\\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\\n\\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\\n}\\nvec4 sampleOctahedral(vec2 sph) {\\n\\treturn sampleOctahedral(fromSpherical(sph));\\n}\\nvec4 sampleOctahedral(vec3 dir, float mipLevel) {\\n\\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\\n#ifdef SUPPORTS_TEXLOD\\n\\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\\n#else\\n\\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\\n#endif\\n}\\nvec4 sampleOctahedral(vec2 sph, float mipLevel) {\\n\\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\\n}\\nvec3 getDirectionCubemap() {\\n\\tvec2 st = vUv0 * 2.0 - 1.0;\\n\\tfloat face = targetFace();\\n\\tvec3 vec;\\n\\tif (face == 0.0) {\\n\\t\\tvec = vec3(1, -st.y, -st.x);\\n\\t} else if (face == 1.0) {\\n\\t\\tvec = vec3(-1, -st.y, st.x);\\n\\t} else if (face == 2.0) {\\n\\t\\tvec = vec3(st.x, 1, st.y);\\n\\t} else if (face == 3.0) {\\n\\t\\tvec = vec3(st.x, -1, -st.y);\\n\\t} else if (face == 4.0) {\\n\\t\\tvec = vec3(st.x, -st.y, 1);\\n\\t} else {\\n\\t\\tvec = vec3(-st.x, -st.y, -1);\\n\\t}\\n\\treturn normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\\n}\\nmat3 matrixFromVector(vec3 n) {\\n\\tfloat a = 1.0 / (1.0 + n.z);\\n\\tfloat b = -n.x * n.y * a;\\n\\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\\n\\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\\n\\treturn mat3(b1, b2, n);\\n}\\nmat3 matrixFromVectorSlow(vec3 n) {\\n\\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\\n\\tvec3 x = normalize(cross(up, n));\\n\\tvec3 y = cross(n, x);\\n\\treturn mat3(x, y, n);\\n}\\nvec4 reproject() {\\n\\tif (NUM_SAMPLES <= 1) {\\n\\t\\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\\n\\t} else {\\n\\t\\tvec2 sph = toSpherical(TARGET_FUNC());\\n\\t\\tvec2 sphu = dFdx(sph);\\n\\t\\tvec2 sphv = dFdy(sph);\\n\\t\\tconst float NUM_SAMPLES_SQRT = sqrt(float(NUM_SAMPLES));\\n\\t\\tvec3 result = vec3(0.0);\\n\\t\\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\\n\\t\\t\\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\\n\\t\\t\\t\\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\tsphu * (u / NUM_SAMPLES_SQRT - 0.5) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\tsphv * (v / NUM_SAMPLES_SQRT - 0.5)));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\\n\\t}\\n}\\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\\nvoid unpackSample(int i, out vec3 L, out float mipLevel) {\\n\\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\\n\\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\\n\\tvec4 raw;\\n\\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\\n\\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\\n\\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\\n\\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\\n\\tL.xyz = raw.xyz * 2.0 - 1.0;\\n\\tmipLevel = raw.w * 8.0;\\n}\\nvec4 prefilterSamples() {\\n\\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\\n\\tvec3 L;\\n\\tfloat mipLevel;\\n\\tvec3 result = vec3(0.0);\\n\\tfloat totalWeight = 0.0;\\n\\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\\n\\t\\tunpackSample(i, L, mipLevel);\\n\\t\\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\\n\\t\\ttotalWeight += L.z;\\n\\t}\\n\\treturn ENCODE_FUNC(result / totalWeight);\\n}\\nvec4 prefilterSamplesUnweighted() {\\n\\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\\n\\tvec3 L;\\n\\tfloat mipLevel;\\n\\tvec3 result = vec3(0.0);\\n\\tfloat totalWeight = 0.0;\\n\\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\\n\\t\\tunpackSample(i, L, mipLevel);\\n\\t\\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\\n\\t}\\n\\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\\n}\\nvoid main(void) {\\n\\tgl_FragColor = PROCESS_FUNC();\\n}\\n\";\n\nvar rgbmPS = \"vec3 texture2DRGBM(sampler2D tex, vec2 uv) {\\n\\treturn decodeRGBM(texture2D(tex, uv));\\n}\\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\\n\\treturn decodeRGBM(textureCube(tex, uvw));\\n}\\n\";\n\nvar screenDepthPS = \"uniform highp sampler2D uDepthMap;\\n#ifndef SCREENSIZE\\n#define SCREENSIZE\\nuniform vec4 uScreenSize;\\n#endif\\n#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\n#ifndef CAMERAPLANES\\n#define CAMERAPLANES\\nuniform vec4 camera_params;\\n#endif\\n#ifdef GL2\\nfloat linearizeDepth(float z) {\\n\\tz = z * 2.0 - 1.0;\\n\\treturn 1.0 / (camera_params.z * z + camera_params.w);\\n}\\n#else\\n#ifndef UNPACKFLOAT\\n#define UNPACKFLOAT\\nfloat unpackFloat(vec4 rgbaDepth) {\\n\\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\\n\\treturn dot(rgbaDepth, bitShift);\\n}\\n#endif\\n#endif\\nfloat getLinearScreenDepth(vec2 uv) {\\n\\t#ifdef GL2\\n\\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\\n\\t#else\\n\\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\\n\\t#endif\\n}\\n#ifndef VERTEXSHADER\\nfloat getLinearScreenDepth() {\\n\\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\\n\\treturn getLinearScreenDepth(uv);\\n}\\n#endif\\nfloat getLinearDepth(vec3 pos) {\\n\\treturn -(matrix_view * vec4(pos, 1.0)).z;\\n}\\n\";\n\nvar shadowCascadesPS = \"const float maxCascades = 4.0;\\nmat4 cascadeShadowMat;\\nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\\n\\tfloat depth = 1.0 / gl_FragCoord.w;\\n\\tfloat cascadeIndex = 0.0;\\n\\tfor (float i = 0.0; i < maxCascades; i++) {\\n\\t\\tif (depth < shadowCascadeDistances[int(i)]) {\\n\\t\\t\\tcascadeIndex = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\\n\\t#ifdef GL2\\n\\t\\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\\n\\t#else\\n\\t\\tif (cascadeIndex == 0.0) {\\n\\t\\t\\tcascadeShadowMat = shadowMatrixPalette[0];\\n\\t\\t}\\n\\t\\telse if (cascadeIndex == 1.0) {\\n\\t\\t\\tcascadeShadowMat = shadowMatrixPalette[1];\\n\\t\\t}\\n\\t\\telse if (cascadeIndex == 2.0) {\\n\\t\\t\\tcascadeShadowMat = shadowMatrixPalette[2];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tcascadeShadowMat = shadowMatrixPalette[3];\\n\\t\\t}\\n\\t#endif\\n}\\nvoid fadeShadow(float shadowCascadeDistances[4]) {\\n\\tfloat depth = 1.0 / gl_FragCoord.w;\\n\\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\\n\\t\\tdShadowCoord.z = -9999999.0;\\n\\t}\\n}\\n\";\n\nvar shadowCommonPS = \"void normalOffsetPointShadow(vec4 shadowParams) {\\n\\tfloat distScale = length(dLightDirW);\\n\\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\\n\\tvec3 dir = wPos - dLightPosW;\\n\\tdLightDirW = dir;\\n}\\n\";\n\nvar shadowCoordPS = \"void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\\n\\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\\n\\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\\n\\t#ifdef SHADOWBIAS\\n\\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\\n\\t#endif\\n}\\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\\n\\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\tdShadowCoord.xy = projPos.xy;\\n\\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\\n\\t#ifdef SHADOWBIAS\\n\\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\\n\\t#endif\\n}\\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\\n\\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\\n}\\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\\n\\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\\n}\\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\\n\\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\\n\\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\\n\\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\\n}\\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\\n\\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0);\\n\\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\\n}\\n\";\n\nvar shadowCoordPerspZbufferPS = \"void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\\n\\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\\n\\tprojPos.xyz /= projPos.w;\\n\\tdShadowCoord = projPos.xyz;\\n}\\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\\n\\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\\n\\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\\n\\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\\n}\\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\\n\\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\\n}\\n\";\n\nvar shadowEVSMPS = \"float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\\n\\tvec3 moments = texture2D(tex, texCoords).xyz;\\n\\treturn calculateEVSM(moments, Z, vsmBias, exponent);\\n}\\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\\n\\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\\n}\\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\\n\\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\\n}\\n\";\n\nvar shadowEVSMnPS = \"float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\\n\\tfloat pixelSize = 1.0 / resolution;\\n\\ttexCoords -= vec2(pixelSize);\\n\\tvec3 s00 = texture2D(tex, texCoords).xyz;\\n\\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\\n\\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\\n\\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\\n\\tvec2 fr = fract(texCoords * resolution);\\n\\tvec3 h0 = mix(s00, s10, fr.x);\\n\\tvec3 h1 = mix(s01, s11, fr.x);\\n\\tvec3 moments = mix(h0, h1, fr.y);\\n\\treturn calculateEVSM(moments, Z, vsmBias, exponent);\\n}\\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\\n\\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\\n}\\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\\n\\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\\n}\\n\";\n\nvar shadowStandardPS = \"vec3 lessThan2(vec3 a, vec3 b) {\\n\\treturn clamp((b - a)*1000.0, 0.0, 1.0);\\n}\\n#ifndef UNPACKFLOAT\\n#define UNPACKFLOAT\\nfloat unpackFloat(vec4 rgbaDepth) {\\n\\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\\n\\treturn dot(rgbaDepth, bitShift);\\n}\\n#endif\\n#ifdef GL2\\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\\n\\tfloat z = dShadowCoord.z;\\n\\tvec2 uv = dShadowCoord.xy * shadowParams.x;\\n\\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\\n\\tvec2 base_uv = floor(uv + 0.5);\\n\\tfloat s = (uv.x + 0.5 - base_uv.x);\\n\\tfloat t = (uv.y + 0.5 - base_uv.y);\\n\\tbase_uv -= vec2(0.5);\\n\\tbase_uv *= shadowMapSizeInv;\\n\\tfloat sum = 0.0;\\n\\tfloat uw0 = (3.0 - 2.0 * s);\\n\\tfloat uw1 = (1.0 + 2.0 * s);\\n\\tfloat u0 = (2.0 - s) / uw0 - 1.0;\\n\\tfloat u1 = s / uw1 + 1.0;\\n\\tfloat vw0 = (3.0 - 2.0 * t);\\n\\tfloat vw1 = (1.0 + 2.0 * t);\\n\\tfloat v0 = (2.0 - t) / vw0 - 1.0;\\n\\tfloat v1 = t / vw1 + 1.0;\\n\\tu0 = u0 * shadowMapSizeInv + base_uv.x;\\n\\tv0 = v0 * shadowMapSizeInv + base_uv.y;\\n\\tu1 = u1 * shadowMapSizeInv + base_uv.x;\\n\\tv1 = v1 * shadowMapSizeInv + base_uv.y;\\n\\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\\n\\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\\n\\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\\n\\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\\n\\tsum *= 1.0f / 16.0;\\n\\treturn sum;\\n}\\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\\n\\treturn _getShadowPCF3x3(shadowMap, shadowParams);\\n}\\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\\n}\\n#else\\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\\n\\tmat3 shadowKernel;\\n\\tvec3 shadowCoord = dShadowCoord;\\n\\tvec3 shadowZ = vec3(shadowCoord.z);\\n\\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\\n\\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\\n\\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\\n\\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\\n\\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\\n\\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\\n\\tvec4 shadowValues;\\n\\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\\n\\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\\n\\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\\n\\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\\n\\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\\n}\\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\\n\\tvec3 shadowCoord = dShadowCoord;\\n\\tfloat xoffset = 1.0 / shadowParams.x;\\n\\tfloat dx0 = -xoffset;\\n\\tfloat dx1 = xoffset;\\n\\tmat3 depthKernel;\\n\\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\\n\\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\\n\\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\\n\\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\\n\\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\\n\\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\\n\\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\\n\\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\\n\\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\\n\\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\\n}\\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\\n\\treturn _getShadowPCF3x3(shadowMap, shadowParams);\\n}\\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\\n\\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\\n}\\n#endif\\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\\n\\tvec3 tc = normalize(dir);\\n\\tvec3 tcAbs = abs(tc);\\n\\tvec4 dirX = vec4(1,0,0, tc.x);\\n\\tvec4 dirY = vec4(0,1,0, tc.y);\\n\\tfloat majorAxisLength = tc.z;\\n\\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\\n\\t\\tdirX = vec4(0,0,1, tc.z);\\n\\t\\tdirY = vec4(0,1,0, tc.y);\\n\\t\\tmajorAxisLength = tc.x;\\n\\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\\n\\t\\tdirX = vec4(1,0,0, tc.x);\\n\\t\\tdirY = vec4(0,0,1, tc.z);\\n\\t\\tmajorAxisLength = tc.y;\\n\\t}\\n\\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\\n\\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\\n\\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\\n\\tvec3 dx0 = -xoffset;\\n\\tvec3 dy0 = -yoffset;\\n\\tvec3 dx1 = xoffset;\\n\\tvec3 dy1 = yoffset;\\n\\tmat3 shadowKernel;\\n\\tmat3 depthKernel;\\n\\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\\n\\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\\n\\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\\n\\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\\n\\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\\n\\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\\n\\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\\n\\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\\n\\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\\n\\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\\n\\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\\n\\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\\n\\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\\n\\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\\n\\tvec2 fractionalCoord = fract( uv * shadowParams.x );\\n\\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\\n\\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\\n\\tvec4 shadowValues;\\n\\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\\n\\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\\n\\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\\n\\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\\n\\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\\n}\\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\\n\\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\\n}\\n\";\n\nvar shadowStandardGL2PS = \"float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\\n\\tfloat z = dShadowCoord.z;\\n\\tvec2 uv = dShadowCoord.xy * shadowParams.x;\\n\\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\\n\\tvec2 base_uv = floor(uv + 0.5);\\n\\tfloat s = (uv.x + 0.5 - base_uv.x);\\n\\tfloat t = (uv.y + 0.5 - base_uv.y);\\n\\tbase_uv -= vec2(0.5);\\n\\tbase_uv *= shadowMapSizeInv;\\n\\tfloat uw0 = (4.0 - 3.0 * s);\\n\\tfloat uw1 = 7.0;\\n\\tfloat uw2 = (1.0 + 3.0 * s);\\n\\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\\n\\tfloat u1 = (3.0 + s) / uw1;\\n\\tfloat u2 = s / uw2 + 2.0;\\n\\tfloat vw0 = (4.0 - 3.0 * t);\\n\\tfloat vw1 = 7.0;\\n\\tfloat vw2 = (1.0 + 3.0 * t);\\n\\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\\n\\tfloat v1 = (3.0 + t) / vw1;\\n\\tfloat v2 = t / vw2 + 2.0;\\n\\tfloat sum = 0.0;\\n\\tu0 = u0 * shadowMapSizeInv + base_uv.x;\\n\\tv0 = v0 * shadowMapSizeInv + base_uv.y;\\n\\tu1 = u1 * shadowMapSizeInv + base_uv.x;\\n\\tv1 = v1 * shadowMapSizeInv + base_uv.y;\\n\\tu2 = u2 * shadowMapSizeInv + base_uv.x;\\n\\tv2 = v2 * shadowMapSizeInv + base_uv.y;\\n\\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\\n\\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\\n\\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\\n\\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\\n\\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\\n\\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\\n\\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\\n\\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\\n\\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\\n\\tsum *= 1.0f / 144.0;\\n\\tsum = gammaCorrectInput(sum);\\n\\tsum = saturate(sum);\\n\\treturn sum;\\n}\\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\\n\\treturn _getShadowPCF5x5(shadowMap, shadowParams);\\n}\\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\\n}\\n\";\n\nvar shadowVSM8PS = \"float calculateVSM8(vec3 moments, float Z, float vsmBias) {\\n\\tfloat VSMBias = vsmBias;\\n\\tfloat depthScale = VSMBias * Z;\\n\\tfloat minVariance1 = depthScale * depthScale;\\n\\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\\n}\\nfloat decodeFloatRG(vec2 rg) {\\n\\treturn rg.y*(1.0/255.0) + rg.x;\\n}\\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\\n\\tvec4 c = texture2D(tex, texCoords);\\n\\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\\n\\treturn calculateVSM8(moments, Z, vsmBias);\\n}\\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\\n\\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\\n}\\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\\n\\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\\n}\\n\";\n\nvar shadowVSM_commonPS = \"float linstep(float a, float b, float v) {\\n\\treturn saturate((v - a) / (b - a));\\n}\\nfloat reduceLightBleeding(float pMax, float amount) {\\n\t return linstep(amount, 1.0, pMax);\\n}\\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\\n\\tfloat variance = moments.y - (moments.x * moments.x);\\n\\tvariance = max(variance, minVariance);\\n\\tfloat d = mean - moments.x;\\n\\tfloat pMax = variance / (variance + (d * d));\\n\\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\\n\\treturn (mean <= moments.x ? 1.0 : pMax);\\n}\\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\\n\\tZ = 2.0 * Z - 1.0;\\n\\tfloat warpedDepth = exp(exponent * Z);\\n\\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\\n\\tfloat VSMBias = vsmBias;\\n\\tfloat depthScale = VSMBias * exponent * warpedDepth;\\n\\tfloat minVariance1 = depthScale * depthScale;\\n\\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\\n}\\n\";\n\nvar skinBatchConstVS = \"attribute float vertex_boneIndices;\\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\\nmat4 getBoneMatrix(const in float i) {\\n\\tvec4 v1 = matrix_pose[int(3.0 * i)];\\n\\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\\n\\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\\n\\treturn mat4(\\n\\t\\tv1.x, v2.x, v3.x, 0,\\n\\t\\tv1.y, v2.y, v3.y, 0,\\n\\t\\tv1.z, v2.z, v3.z, 0,\\n\\t\\tv1.w, v2.w, v3.w, 1\\n\\t);\\n}\\n\";\n\nvar skinBatchTexVS = \"attribute float vertex_boneIndices;\\nuniform highp sampler2D texture_poseMap;\\nuniform vec4 texture_poseMapSize;\\nmat4 getBoneMatrix(const in float i) {\\n\\tfloat j = i * 3.0;\\n\\tfloat dx = texture_poseMapSize.z;\\n\\tfloat dy = texture_poseMapSize.w;\\n\\tfloat y = floor(j * dx);\\n\\tfloat x = j - (y * texture_poseMapSize.x);\\n\\ty = dy * (y + 0.5);\\n\\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\\n\\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\\n\\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\\n\\treturn mat4(\\n\\t\\tv1.x, v2.x, v3.x, 0,\\n\\t\\tv1.y, v2.y, v3.y, 0,\\n\\t\\tv1.z, v2.z, v3.z, 0,\\n\\t\\tv1.w, v2.w, v3.w, 1\\n\\t);\\n}\\n\";\n\nvar skinConstVS = \"attribute vec4 vertex_boneWeights;\\nattribute vec4 vertex_boneIndices;\\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\\n\\tv1 = matrix_pose[int(3.0 * i)];\\n\\tv2 = matrix_pose[int(3.0 * i + 1.0)];\\n\\tv3 = matrix_pose[int(3.0 * i + 2.0)];\\n}\\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\\n\\tvec4 a1, a2, a3;\\n\\tgetBoneMatrix(indices.x, a1, a2, a3);\\n\\tvec4 b1, b2, b3;\\n\\tgetBoneMatrix(indices.y, b1, b2, b3);\\n\\tvec4 c1, c2, c3;\\n\\tgetBoneMatrix(indices.z, c1, c2, c3);\\n\\tvec4 d1, d2, d3;\\n\\tgetBoneMatrix(indices.w, d1, d2, d3);\\n\\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\\n\\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\\n\\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\\n\\tfloat one = dot(weights, vec4(1.0));\\n\\treturn mat4(\\n\\t\\tv1.x, v2.x, v3.x, 0,\\n\\t\\tv1.y, v2.y, v3.y, 0,\\n\\t\\tv1.z, v2.z, v3.z, 0,\\n\\t\\tv1.w, v2.w, v3.w, one\\n\\t);\\n}\\n\";\n\nvar skinTexVS = \"attribute vec4 vertex_boneWeights;\\nattribute vec4 vertex_boneIndices;\\nuniform highp sampler2D texture_poseMap;\\nuniform vec4 texture_poseMapSize;\\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\\n\\tfloat j = i * 3.0;\\n\\tfloat dx = texture_poseMapSize.z;\\n\\tfloat dy = texture_poseMapSize.w;\\n\\tfloat y = floor(j * dx);\\n\\tfloat x = j - (y * texture_poseMapSize.x);\\n\\ty = dy * (y + 0.5);\\n\\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\\n\\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\\n\\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\\n}\\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\\n\\tvec4 a1, a2, a3;\\n\\tgetBoneMatrix(indices.x, a1, a2, a3);\\n\\tvec4 b1, b2, b3;\\n\\tgetBoneMatrix(indices.y, b1, b2, b3);\\n\\tvec4 c1, c2, c3;\\n\\tgetBoneMatrix(indices.z, c1, c2, c3);\\n\\tvec4 d1, d2, d3;\\n\\tgetBoneMatrix(indices.w, d1, d2, d3);\\n\\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\\n\\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\\n\\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\\n\\tfloat one = dot(weights, vec4(1.0));\\n\\treturn mat4(\\n\\t\\tv1.x, v2.x, v3.x, 0,\\n\\t\\tv1.y, v2.y, v3.y, 0,\\n\\t\\tv1.z, v2.z, v3.z, 0,\\n\\t\\tv1.w, v2.w, v3.w, one\\n\\t);\\n}\\n\";\n\nvar skyboxEnvPS = \"varying vec3 vViewDir;\\nuniform sampler2D texture_envAtlas;\\nuniform float mipLevel;\\nvoid main(void) {\\n\\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\\n\\tvec2 uv = toSphericalUv(normalize(dir));\\n\\tvec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\\n\\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\\n}\\n\";\n\nvar skyboxHDRPS = \"varying vec3 vViewDir;\\nuniform samplerCube texture_cubeMap;\\nvoid main(void) {\\n\\tvec3 dir=vViewDir;\\n\\tdir.x *= -1.0;\\n\\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)).rgb);\\n\\tcolor = toneMap(color);\\n\\tcolor = gammaCorrectOutput(color);\\n\\tgl_FragColor = vec4(color, 1.0);\\n}\\n\";\n\nvar skyboxVS = \"attribute vec3 aPosition;\\n#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nuniform mat4 matrix_projectionSkybox;\\nuniform mat3 cubeMapRotationMatrix;\\nvarying vec3 vViewDir;\\nvoid main(void) {\\n\\tmat4 view = matrix_view;\\n\\tview[3][0] = view[3][1] = view[3][2] = 0.0;\\n\\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\\n\\tgl_Position.z = gl_Position.w - 0.00001;\\n\\tvViewDir = aPosition * cubeMapRotationMatrix;\\n}\\n\";\n\nvar specularPS = \"#ifdef MAPCOLOR\\nuniform vec3 material_specular;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_specularMap;\\n#endif\\nvoid getSpecularity() {\\n\\tdSpecularity = vec3(1.0);\\n\\t#ifdef MAPCOLOR\\n\\tdSpecularity *= material_specular;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tdSpecularity *= texture2D(texture_specularMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdSpecularity *= saturate(vVertexColor.$VC);\\n\\t#endif\\n}\\n\";\n\nvar specularAaNonePS = \"float antiAliasGlossiness(float power) {\\n\\treturn power;\\n}\\n\";\n\nvar specularAaToksvigPS = \"float antiAliasGlossiness(float power) {\\n\\tfloat rlen = 1.0 / saturate(length(dNormalMap));\\n\\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\\n\\treturn power * mix(1.0, toksvig, material_bumpiness);\\n}\\n\";\n\nvar specularAaToksvigFastPS = \"float antiAliasGlossiness(float power) {\\n\\tfloat rlen = 1.0 / saturate(length(dNormalMap));\\n\\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\\n\\treturn power * toksvig;\\n}\\n\";\n\nvar spotPS = \"float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\\n\\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\\n\\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\\n}\\n\";\n\nvar startPS = \"void main(void) {\\n\\tdDiffuseLight = vec3(0);\\n\\tdSpecularLight = vec3(0);\\n\\tdReflection = vec4(0);\\n\\tdSpecularity = vec3(0);\\n\\t#ifdef CLEARCOAT\\n\\tccSpecularLight = vec3(0);\\n\\tccReflection = vec4(0);\\n\\t#endif\\n\";\n\nvar startVS = \"void main(void) {\\n\\tgl_Position = getPosition();\\n\";\n\nvar startNineSlicedPS = \"\\tnineSlicedUv = vUv0;\\n\\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\\n\";\n\nvar startNineSlicedTiledPS = \"\\tvec2 tileMask = step(vMask, vec2(0.99999));\\n\\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\\n\\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\\n\\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\\n\\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\\n\\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\\n\\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\\n\";\n\nvar storeEVSMPS = \"float exponent = VSM_EXPONENT;\\ndepth = 2.0 * depth - 1.0;\\ndepth =\texp(exponent * depth);\\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\\n\";\n\nvar tangentBinormalVS = \"vec3 getTangent() {\\n\\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\\n}\\nvec3 getBinormal() {\\n\\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\\n}\\nvec3 getObjectSpaceUp() {\\n\\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\\n}\\n\";\n\nvar TBNPS = \"void getTBN() {\\n\\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\\n}\\n\";\n\nvar TBNderivativePS = \"uniform float tbnBasis;\\nvoid getTBN() {\\n\\tvec2 uv = $UV;\\n\\tvec3 dp1 = dFdx( vPositionW );\\n\\tvec3 dp2 = dFdy( vPositionW );\\n\\tvec2 duv1 = dFdx( uv );\\n\\tvec2 duv2 = dFdy( uv );\\n\\tvec3 dp2perp = cross( dp2, dVertexNormalW );\\n\\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\\n\\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\\n\\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\\n\\tfloat denom = max( dot(T,T), dot(B,B) );\\n\\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\\n\\tdTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );\\n}\\n\";\n\nvar TBNfastPS = \"void getTBN() {\\n\\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\\n}\\n\";\n\nvar TBNObjectSpacePS = \"void getTBN() {\\n\\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\\n\\tvec3 T = cross(dVertexNormalW, B);\\n\\tif (dot(B,B)==0.0)\\n\\t{\\n\\t\\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\\n\\t\\tif (dVertexNormalW.x==major)\\n\\t\\t{\\n\\t\\t\\tB=cross(dVertexNormalW, vec3(0,1,0));\\n\\t\\t\\tT=cross(dVertexNormalW, B);\\n\\t\\t}\\n\\t\\telse if (dVertexNormalW.y==major)\\n\\t\\t{\\n\\t\\t\\tB=cross(dVertexNormalW, vec3(0,0,1));\\n\\t\\t\\tT=cross(dVertexNormalW, B);\\n\\t\\t}\\n\\t\\telse if (dVertexNormalW.z==major)\\n\\t\\t{\\n\\t\\t\\tB=cross(dVertexNormalW, vec3(1,0,0));\\n\\t\\t\\tT=cross(dVertexNormalW, B);\\n\\t\\t}\\n\\t}\\n\\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\\n}\\n\";\n\nvar tonemappingAcesPS = \"uniform float exposure;\\nvec3 toneMap(vec3 color) {\\n\\tfloat tA = 2.51;\\n\\tfloat tB = 0.03;\\n\\tfloat tC = 2.43;\\n\\tfloat tD = 0.59;\\n\\tfloat tE = 0.14;\\n\\tvec3 x = color * exposure;\\n\\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\\n}\\n\";\n\nvar tonemappingAces2PS = \"uniform float exposure;\\nconst mat3 ACESInputMat = mat3(\\n\\t0.59719, 0.35458, 0.04823,\\n\\t0.07600, 0.90834, 0.01566,\\n\\t0.02840, 0.13383, 0.83777\\n);\\nconst mat3 ACESOutputMat = mat3(\\n\\t 1.60475, -0.53108, -0.07367,\\n\\t-0.10208,\t1.10813, -0.00605,\\n\\t-0.00327, -0.07276,\t1.07602\\n);\\nvec3 RRTAndODTFit(vec3 v) {\\n\\tvec3 a = v * (v + 0.0245786) - 0.000090537;\\n\\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 toneMap(vec3 color) {\\n\\tcolor *= exposure;\\n\\tcolor = color * ACESInputMat;\\n\\tcolor = RRTAndODTFit(color);\\n\\tcolor = color * ACESOutputMat;\\n\\tcolor = clamp(color, 0.0, 1.0);\\n\\treturn color;\\n}\\n\";\n\nvar tonemappingFilmicPS = \"const float A =\t0.15;\\nconst float B =\t0.50;\\nconst float C =\t0.10;\\nconst float D =\t0.20;\\nconst float E =\t0.02;\\nconst float F =\t0.30;\\nconst float W =\t11.2;\\nuniform float exposure;\\nvec3 uncharted2Tonemap(vec3 x) {\\n\t return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\\n}\\nvec3 toneMap(vec3 color) {\\n\\tcolor = uncharted2Tonemap(color * exposure);\\n\\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\\n\\tcolor = color * whiteScale;\\n\\treturn color;\\n}\\n\";\n\nvar tonemappingHejlPS = \"uniform float exposure;\\nvec3 toneMap(vec3 color) {\\n\\tcolor *= exposure;\\n\\tconst float\tA = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\\n\\tconst float Scl = 1.25;\\n\\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\\n\\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\\n}\\n\";\n\nvar tonemappingLinearPS = \"uniform float exposure;\\nvec3 toneMap(vec3 color) {\\n\\treturn color * exposure;\\n}\\n\";\n\nvar tonemappingNonePS = \"vec3 toneMap(vec3 color) {\\n\\treturn color;\\n}\\n\";\n\nvar transformVS = \"#ifdef PIXELSNAP\\nuniform vec4 uScreenSize;\\n#endif\\n#ifdef MORPHING\\nuniform vec4 morph_weights_a;\\nuniform vec4 morph_weights_b;\\n#endif\\n#ifdef MORPHING_TEXTURE_BASED\\nuniform vec4 morph_tex_params;\\nvec2 getTextureMorphCoords() {\\n\\tfloat vertexId = morph_vertex_id;\\n\\tvec2 textureSize = morph_tex_params.xy;\\n\\tvec2 invTextureSize = morph_tex_params.zw;\\n\\tfloat morphGridV = floor(vertexId * invTextureSize.x);\\n\\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\\n\\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\\n}\\n#endif\\n#ifdef MORPHING_TEXTURE_BASED_POSITION\\nuniform highp sampler2D morphPositionTex;\\n#endif\\nmat4 getModelMatrix() {\\n\\t#ifdef DYNAMICBATCH\\n\\treturn getBoneMatrix(vertex_boneIndices);\\n\\t#elif defined(SKIN)\\n\\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\\n\\t#elif defined(INSTANCING)\\n\\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\\n\\t#else\\n\\treturn matrix_model;\\n\\t#endif\\n}\\nvec4 getPosition() {\\n\\tdModelMatrix = getModelMatrix();\\n\\tvec3 localPos = vertex_position;\\n\\t#ifdef NINESLICED\\n\\tlocalPos.xz *= outerScale;\\n\\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\\n\\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\\n\\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\\n\\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\\n\\tlocalPos.xz *= -0.5;\\n\\tlocalPos = localPos.xzy;\\n\\t#endif\\n\\t#ifdef MORPHING\\n\\t#ifdef MORPHING_POS03\\n\\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\\n\\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\\n\\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\\n\\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\\n\\t#endif\\n\\t#ifdef MORPHING_POS47\\n\\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\\n\\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\\n\\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\\n\\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\\n\\t#endif\\n\\t#endif\\n\\t#ifdef MORPHING_TEXTURE_BASED_POSITION\\n\\tvec2 morphUV = getTextureMorphCoords();\\n\\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\\n\\tlocalPos += morphPos;\\n\\t#endif\\n\\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\\n\\t#ifdef SCREENSPACE\\n\\tposW.zw = vec2(0.0, 1.0);\\n\\t#endif\\n\\tdPositionW = posW.xyz;\\n\\tvec4 screenPos;\\n\\t#ifdef UV1LAYOUT\\n\\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\\n\\t#else\\n\\t#ifdef SCREENSPACE\\n\\tscreenPos = posW;\\n\\t#else\\n\\tscreenPos = matrix_viewProjection * posW;\\n\\t#endif\\n\\t#ifdef PIXELSNAP\\n\\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\\n\\tscreenPos.xy *= uScreenSize.xy;\\n\\tscreenPos.xy = floor(screenPos.xy);\\n\\tscreenPos.xy *= uScreenSize.zw;\\n\\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\\n\\t#endif\\n\\t#endif\\n\\treturn screenPos;\\n}\\nvec3 getWorldPosition() {\\n\\treturn dPositionW;\\n}\\n\";\n\nvar transformDeclVS = \"attribute vec3 vertex_position;\\nuniform mat4 matrix_model;\\nuniform mat4 matrix_viewProjection;\\nvec3 dPositionW;\\nmat4 dModelMatrix;\\n\";\n\nvar uv0VS = \"#ifdef NINESLICED\\nvec2 getUv0() {\\n\\tvec2 uv = vertex_position.xz;\\n\\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\\n\\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\\n\\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\\n\\tuv = uv * -0.5 + 0.5;\\n\\tuv = uv * atlasRect.zw + atlasRect.xy;\\n\\tvMask = vertex_texCoord0.xy;\\n\\treturn uv;\\n}\\n#else\\nvec2 getUv0() {\\n\\treturn vertex_texCoord0;\\n}\\n#endif\\n\";\n\nvar uv1VS = \"vec2 getUv1() {\\n\\treturn vertex_texCoord1;\\n}\\n\";\n\nvar viewDirPS = \"void getViewDir() {\\n\\tdViewDirW = normalize(view_position - vPositionW);\\n}\\n\";\n\nvar viewNormalVS = \"#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nvec3 getViewNormal() {\\n\\treturn mat3(matrix_view) * vNormalW;\\n}\\n\";\n\nconst shaderChunks = {\n\talphaTestPS,\n\tambientConstantPS,\n\tambientEnvPS,\n\tambientSHPS,\n\taoPS,\n\taoSpecOccPS,\n\taoSpecOccConstPS,\n\taoSpecOccConstSimplePS,\n\taoSpecOccSimplePS,\n\tbakeDirLmEndPS,\n\tbakeLmEndPS,\n\tbasePS,\n\tbaseVS,\n\tbaseNineSlicedPS,\n\tbaseNineSlicedVS,\n\tbaseNineSlicedTiledPS,\n\tbiasConstPS,\n\tblurVSMPS,\n\tclearCoatPS,\n\tclearCoatGlossPS,\n\tclearCoatNormalPS,\n\tclusteredLightCookiesPS,\n\tclusteredLightShadowsPS,\n\tclusteredLightUtilsPS,\n\tclusteredLightPS,\n\tcombineClearCoatPS,\n\tcombineDiffusePS,\n\tcombineDiffuseSpecularPS,\n\tcombineDiffuseSpecularNoConservePS,\n\tcombineDiffuseSpecularNoReflPS,\n\tcombineDiffuseSpecularNoReflSeparateAmbientPS,\n\tcombineDiffuseSpecularOldPS,\n\tcookiePS,\n\tcubeMapProjectBoxPS,\n\tcubeMapProjectNonePS,\n\tcubeMapRotatePS,\n\tdetailModesPS,\n\tdiffusePS,\n\tdiffuseDetailMapPS,\n\tdilatePS,\n\tbilateralDeNoisePS,\n\tdecodePS,\n\temissivePS,\n\tendPS,\n\tendVS,\n\tenvConstPS,\n\tenvMultiplyPS,\n\textensionPS,\n\textensionVS,\n\tfalloffInvSquaredPS,\n\tfalloffLinearPS,\n\tfixCubemapSeamsNonePS,\n\tfixCubemapSeamsStretchPS,\n\tfloatUnpackingPS,\n\tfogExpPS,\n\tfogExp2PS,\n\tfogLinearPS,\n\tfogNonePS,\n\tfresnelSchlickPS,\n\tfullscreenQuadPS,\n\tfullscreenQuadVS,\n\tgamma1_0PS,\n\tgamma2_2PS,\n\tgles3PS,\n\tgles3VS,\n\tglossPS,\n\tinstancingVS,\n\tlightDiffuseLambertPS,\n\tlightDirPointPS,\n\tlightmapDirPS,\n\tlightmapSinglePS,\n\tlightmapSingleVertPS,\n\tlightSpecularAnisoGGXPS,\n\tlightSpecularBlinnPS,\n\tlightSpecularPhongPS,\n\tltc,\n\tmetalnessPS,\n\tmsdfPS,\n\tnormalVS,\n\tnormalDetailMapPS,\n\tnormalInstancedVS,\n\tnormalMapPS,\n\tnormalMapFastPS,\n\tnormalSkinnedVS,\n\tnormalVertexPS,\n\tnormalXYPS,\n\tnormalXYZPS,\n\topacityPS,\n\toutputAlphaPS,\n\toutputAlphaOpaquePS,\n\toutputAlphaPremulPS,\n\toutputCubemapPS,\n\toutputTex2DPS,\n\tpackDepthPS,\n\tpackDepthMaskPS,\n\tparallaxPS,\n\tparticlePS,\n\tparticleVS,\n\tparticleAnimFrameClampVS,\n\tparticleAnimFrameLoopVS,\n\tparticleAnimTexVS,\n\tparticleInputFloatPS,\n\tparticleInputRgba8PS,\n\tparticleOutputFloatPS,\n\tparticleOutputRgba8PS,\n\tparticleUpdaterAABBPS,\n\tparticleUpdaterEndPS,\n\tparticleUpdaterInitPS,\n\tparticleUpdaterNoRespawnPS,\n\tparticleUpdaterOnStopPS,\n\tparticleUpdaterRespawnPS,\n\tparticleUpdaterSpherePS,\n\tparticleUpdaterStartPS,\n\tparticle_billboardVS,\n\tparticle_blendAddPS,\n\tparticle_blendMultiplyPS,\n\tparticle_blendNormalPS,\n\tparticle_cpuVS,\n\tparticle_cpu_endVS,\n\tparticle_customFaceVS,\n\tparticle_endPS,\n\tparticle_endVS,\n\tparticle_halflambertPS,\n\tparticle_initVS,\n\tparticle_lambertPS,\n\tparticle_lightingPS,\n\tparticle_localShiftVS,\n\tparticle_meshVS,\n\tparticle_normalVS,\n\tparticle_normalMapPS,\n\tparticle_pointAlongVS,\n\tparticle_softPS,\n\tparticle_softVS,\n\tparticle_stretchVS,\n\tparticle_TBNVS,\n\tparticle_wrapVS,\n\tprecisionTestPS,\n\tprecisionTest2PS,\n\treflDirPS,\n\treflDirAnisoPS,\n\treflectionCCPS,\n\treflectionCubePS,\n\treflectionEnvPS,\n\treflectionSpherePS,\n\treflectionSphereLowPS,\n\trefractionPS,\n\treprojectPS,\n\trgbmPS,\n\tscreenDepthPS,\n\tshadowCascadesPS,\n\tshadowCommonPS,\n\tshadowCoordPS,\n\tshadowCoordPerspZbufferPS,\n\tshadowEVSMPS,\n\tshadowEVSMnPS,\n\tshadowStandardPS,\n\tshadowStandardGL2PS,\n\tshadowVSM8PS,\n\tshadowVSM_commonPS,\n\tskinBatchConstVS,\n\tskinBatchTexVS,\n\tskinConstVS,\n\tskinTexVS,\n\tskyboxEnvPS,\n\tskyboxHDRPS,\n\tskyboxVS,\n\tspecularPS,\n\tspecularAaNonePS,\n\tspecularAaToksvigPS,\n\tspecularAaToksvigFastPS,\n\tspotPS,\n\tstartPS,\n\tstartVS,\n\tstartNineSlicedPS,\n\tstartNineSlicedTiledPS,\n\tstoreEVSMPS,\n\ttangentBinormalVS,\n\tTBNPS,\n\tTBNderivativePS,\n\tTBNfastPS,\n\tTBNObjectSpacePS,\n\ttonemappingAcesPS,\n\ttonemappingAces2PS,\n\ttonemappingFilmicPS,\n\ttonemappingHejlPS,\n\ttonemappingLinearPS,\n\ttonemappingNonePS,\n\ttransformVS,\n\ttransformDeclVS,\n\tuv0VS,\n\tuv1VS,\n\tviewDirPS,\n\tviewNormalVS\n};\n\nfunction gammaCode(value, chunks) {\n\tif (!chunks) chunks = shaderChunks;\n\n\tif (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {\n\t\treturn chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;\n\t} else if (value === GAMMA_SRGBHDR) {\n\t\treturn \"#define HDR\\n\" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);\n\t}\n\n\treturn chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;\n}\n\nfunction tonemapCode(value, chunks) {\n\tif (!chunks) chunks = shaderChunks;\n\n\tif (value === TONEMAP_FILMIC) {\n\t\treturn chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;\n\t} else if (value === TONEMAP_LINEAR) {\n\t\treturn chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;\n\t} else if (value === TONEMAP_HEJL) {\n\t\treturn chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;\n\t} else if (value === TONEMAP_ACES) {\n\t\treturn chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;\n\t} else if (value === TONEMAP_ACES2) {\n\t\treturn chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;\n\t}\n\n\treturn chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;\n}\n\nfunction fogCode(value, chunks) {\n\tif (!chunks) chunks = shaderChunks;\n\n\tif (value === 'linear') {\n\t\treturn chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;\n\t} else if (value === 'exp') {\n\t\treturn chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;\n\t} else if (value === 'exp2') {\n\t\treturn chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;\n\t}\n\n\treturn chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;\n}\n\nfunction skinCode(device, chunks) {\n\tif (!chunks) chunks = shaderChunks;\n\n\tif (device.supportsBoneTextures) {\n\t\treturn chunks.skinTexVS;\n\t}\n\n\treturn \"#define BONE_LIMIT \" + device.getBoneLimit() + \"\\n\" + chunks.skinConstVS;\n}\n\nfunction precisionCode(device) {\n\tlet pcode = 'precision ' + device.precision + ' float;\\n';\n\n\tif (device.webgl2) {\n\t\tpcode += '#ifdef GL2\\nprecision ' + device.precision + ' sampler2DShadow;\\n#endif\\n';\n\t}\n\n\treturn pcode;\n}\n\nfunction versionCode(device) {\n\treturn device.webgl2 ? \"#version 300 es\\n\" : \"\";\n}\n\nfunction dummyFragmentCode() {\n\treturn \"void main(void) {gl_FragColor = vec4(0.0);}\";\n}\n\nfunction begin() {\n\treturn 'void main(void)\\n{\\n';\n}\n\nfunction end() {\n\treturn '}\\n';\n}\n\nconst attrib2Semantic = {\n\tvertex_position: SEMANTIC_POSITION,\n\tvertex_normal: SEMANTIC_NORMAL,\n\tvertex_tangent: SEMANTIC_TANGENT,\n\tvertex_texCoord0: SEMANTIC_TEXCOORD0,\n\tvertex_texCoord1: SEMANTIC_TEXCOORD1,\n\tvertex_texCoord2: SEMANTIC_TEXCOORD2,\n\tvertex_texCoord3: SEMANTIC_TEXCOORD3,\n\tvertex_texCoord4: SEMANTIC_TEXCOORD4,\n\tvertex_texCoord5: SEMANTIC_TEXCOORD5,\n\tvertex_texCoord6: SEMANTIC_TEXCOORD6,\n\tvertex_texCoord7: SEMANTIC_TEXCOORD7,\n\tvertex_color: SEMANTIC_COLOR,\n\tvertex_boneIndices: SEMANTIC_BLENDINDICES,\n\tvertex_boneWeights: SEMANTIC_BLENDWEIGHT\n};\n\nfunction collectAttribs(vsCode) {\n\tconst attribs = {};\n\tlet attrs = 0;\n\tlet found = vsCode.indexOf(\"attribute\");\n\n\twhile (found >= 0) {\n\t\tif (found > 0 && vsCode[found - 1] === \"/\") break;\n\t\tconst endOfLine = vsCode.indexOf(';', found);\n\t\tconst startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);\n\t\tconst attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));\n\t\tconst semantic = attrib2Semantic[attribName];\n\n\t\tif (semantic !== undefined) {\n\t\t\tattribs[attribName] = semantic;\n\t\t} else {\n\t\t\tattribs[attribName] = \"ATTR\" + attrs;\n\t\t\tattrs++;\n\t\t}\n\n\t\tfound = vsCode.indexOf(\"attribute\", found + 1);\n\t}\n\n\treturn attribs;\n}\n\nfunction createShader(device, vsName, psName, useTransformFeedback = false) {\n\tlet vsCode = shaderChunks[vsName];\n\tlet psCode = precisionCode(device) + \"\\n\" + shaderChunks[psName];\n\tconst attribs = collectAttribs(vsCode);\n\n\tif (device.webgl2) {\n\t\tvsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;\n\t\tpsCode = versionCode(device) + shaderChunks.gles3PS + psCode;\n\t}\n\n\treturn new Shader(device, {\n\t\tattributes: attribs,\n\t\tvshader: vsCode,\n\t\tfshader: psCode,\n\t\tuseTransformFeedback: useTransformFeedback\n\t});\n}\n\nfunction createShaderFromCode(device, vsCode, psCode, uName, useTransformFeedback = false, psPreamble = \"\") {\n\tconst shaderCache = device.programLib._cache;\n\tconst cached = shaderCache[uName];\n\tif (cached !== undefined) return cached;\n\tpsCode = precisionCode(device) + \"\\n\" + (psCode || dummyFragmentCode());\n\tconst attribs = collectAttribs(vsCode);\n\n\tif (device.webgl2) {\n\t\tvsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;\n\t\tpsCode = versionCode(device) + shaderChunks.gles3PS + psCode;\n\t}\n\n\tshaderCache[uName] = new Shader(device, {\n\t\tattributes: attribs,\n\t\tvshader: vsCode,\n\t\tfshader: psPreamble + psCode,\n\t\tuseTransformFeedback: useTransformFeedback\n\t});\n\treturn shaderCache[uName];\n}\n\nshaderChunks.collectAttribs = collectAttribs;\nshaderChunks.createShader = createShader;\nshaderChunks.createShaderFromCode = createShaderFromCode;\n\nconst basic = {\n\tgenerateKey: function (options) {\n\t\tlet key = 'basic';\n\t\tif (options.fog) key += '_fog';\n\t\tif (options.alphaTest) key += '_atst';\n\t\tif (options.vertexColors) key += '_vcol';\n\t\tif (options.diffuseMap) key += '_diff';\n\t\tif (options.skin) key += '_skin';\n\t\tif (options.screenSpace) key += '_ss';\n\t\tif (options.useInstancing) key += '_inst';\n\t\tif (options.useMorphPosition) key += '_morphp';\n\t\tif (options.useMorphNormal) key += '_morphn';\n\t\tif (options.useMorphTextureBased) key += '_morpht';\n\t\tkey += '_' + options.pass;\n\t\treturn key;\n\t},\n\tcreateShaderDefinition: function (device, options) {\n\t\tconst attributes = {\n\t\t\tvertex_position: SEMANTIC_POSITION\n\t\t};\n\n\t\tif (options.skin) {\n\t\t\tattributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;\n\t\t\tattributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;\n\t\t}\n\n\t\tif (options.vertexColors) {\n\t\t\tattributes.vertex_color = SEMANTIC_COLOR;\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tattributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;\n\t\t}\n\n\t\tlet code = '';\n\t\tcode += shaderChunks.transformDeclVS;\n\n\t\tif (options.skin) {\n\t\t\tcode += skinCode(device);\n\t\t\tcode += shaderChunks.transformSkinnedVS;\n\t\t} else {\n\t\t\tcode += shaderChunks.transformVS;\n\t\t}\n\n\t\tif (options.vertexColors) {\n\t\t\tcode += 'attribute vec4 vertex_color;\\n';\n\t\t\tcode += 'varying vec4 vColor;\\n';\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tcode += 'attribute vec2 vertex_texCoord0;\\n';\n\t\t\tcode += 'varying vec2 vUv0;\\n';\n\t\t}\n\n\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += '#ifndef VIEWMATRIX\\n';\n\t\t\tcode += '#define VIEWMATRIX\\n';\n\t\t\tcode += 'uniform mat4 matrix_view;\\n';\n\t\t\tcode += '#endif\\n';\n\t\t\tcode += '#ifndef CAMERAPLANES\\n';\n\t\t\tcode += '#define CAMERAPLANES\\n';\n\t\t\tcode += 'uniform vec4 camera_params;\\n\\n';\n\t\t\tcode += '#endif\\n';\n\t\t}\n\n\t\tcode += begin();\n\t\tcode += \"\t gl_Position = getPosition();\\n\";\n\n\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\tcode += \"\t\tvDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\\n\";\n\t\t}\n\n\t\tif (options.vertexColors) {\n\t\t\tcode += '\t\tvColor = vertex_color;\\n';\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tcode += '\t\tvUv0 = vertex_texCoord0;\\n';\n\t\t}\n\n\t\tcode += end();\n\t\tconst vshader = code;\n\t\tcode = precisionCode(device);\n\n\t\tif (options.vertexColors) {\n\t\t\tcode += 'varying vec4 vColor;\\n';\n\t\t} else {\n\t\t\tcode += 'uniform vec4 uColor;\\n';\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tcode += 'varying vec2 vUv0;\\n';\n\t\t\tcode += 'uniform sampler2D texture_diffuseMap;\\n';\n\t\t}\n\n\t\tif (options.fog) {\n\t\t\tcode += fogCode(options.fog);\n\t\t}\n\n\t\tif (options.alphatest) {\n\t\t\tcode += shaderChunks.alphaTestPS;\n\t\t}\n\n\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += shaderChunks.packDepthPS;\n\t\t}\n\n\t\tcode += begin();\n\n\t\tif (options.vertexColors) {\n\t\t\tcode += '\t\tgl_FragColor = vColor;\\n';\n\t\t} else {\n\t\t\tcode += '\t\tgl_FragColor = uColor;\\n';\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tcode += '\t\tgl_FragColor *= texture2D(texture_diffuseMap, vUv0);\\n';\n\t\t}\n\n\t\tif (options.alphatest) {\n\t\t\tcode += \"\t alphaTest(gl_FragColor.a);\\n\";\n\t\t}\n\n\t\tif (options.pass !== SHADER_PICK) {\n\t\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\t\tcode += \"\t\tgl_FragColor = packFloat(vDepth);\\n\";\n\t\t\t} else {\n\t\t\t\tif (options.fog) {\n\t\t\t\t\tcode += \"\t glFragColor.rgb = addFog(gl_FragColor.rgb);\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcode += end();\n\t\tconst fshader = code;\n\t\treturn {\n\t\t\tattributes: attributes,\n\t\t\tvshader: vshader,\n\t\t\tfshader: fshader\n\t\t};\n\t}\n};\n\nconst particle = {\n\tgenerateKey: function (options) {\n\t\tlet key = \"particle\";\n\n\t\tfor (const prop in options) {\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\tkey += options[prop];\n\t\t\t}\n\t\t}\n\n\t\treturn key;\n\t},\n\t_animTex: function (options) {\n\t\tlet vshader = \"\";\n\t\tvshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;\n\t\tvshader += shaderChunks.particleAnimTexVS;\n\t\treturn vshader;\n\t},\n\tcreateShaderDefinition: function (device, options) {\n\t\tlet vshader = \"\";\n\t\tlet fshader = precisionCode(device) + \"\\n\";\n\t\tfshader += '#define PARTICLE\\n';\n\n\t\tif (device.webgl2) {\n\t\t\tvshader += \"#define GL2\\n\";\n\t\t\tfshader += \"#define GL2\\n\";\n\t\t}\n\n\t\tvshader += \"#define VERTEXSHADER\\n\";\n\t\tif (options.mesh) vshader += \"#define USE_MESH\\n\";\n\t\tif (options.localSpace) vshader += \"#define LOCAL_SPACE\\n\";\n\t\tif (options.screenSpace) vshader += \"#define SCREEN_SPACE\\n\";\n\t\tif (options.animTex) vshader += \"\\nuniform vec2 animTexTilesParams;\\n\";\n\t\tif (options.animTex) vshader += \"\\nuniform vec4 animTexParams;\\n\";\n\t\tif (options.animTex) vshader += \"\\nuniform vec2 animTexIndexParams;\\n\";\n\t\tif (options.normal === 2) vshader += \"\\nvarying mat3 ParticleMat;\\n\";\n\t\tif (options.normal === 1) vshader += \"\\nvarying vec3 Normal;\\n\";\n\t\tif (options.soft) vshader += \"\\nvarying float vDepth;\\n\";\n\t\tconst faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;\n\n\t\tif (!options.useCpu) {\n\t\t\tvshader += shaderChunks.particle_initVS;\n\t\t\tvshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.screenDepthPS;\n\t\t\tvshader += shaderChunks.particleVS;\n\t\t\tif (options.localSpace) vshader += shaderChunks.particle_localShiftVS;\n\t\t\tif (options.animTex) vshader += this._animTex(options);\n\t\t\tif (options.wrap) vshader += shaderChunks.particle_wrapVS;\n\t\t\tif (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;\n\t\t\tvshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;\n\t\t\tif (options.normal === 1) vshader += shaderChunks.particle_normalVS;\n\t\t\tif (options.normal === 2) vshader += shaderChunks.particle_TBNVS;\n\t\t\tif (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;\n\t\t\tvshader += shaderChunks.particle_endVS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.particle_softVS;\n\t\t} else {\n\t\t\tif (options.soft > 0) vshader += shaderChunks.screenDepthPS;\n\t\t\tvshader += shaderChunks.particle_cpuVS;\n\t\t\tif (options.localSpace) vshader += shaderChunks.particle_localShiftVS;\n\t\t\tif (options.animTex) vshader += this._animTex(options);\n\t\t\tif (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;\n\t\t\tvshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;\n\t\t\tif (options.normal === 1) vshader += shaderChunks.particle_normalVS;\n\t\t\tif (options.normal === 2) vshader += shaderChunks.particle_TBNVS;\n\t\t\tif (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;\n\t\t\tvshader += shaderChunks.particle_cpu_endVS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.particle_softVS;\n\t\t}\n\n\t\tvshader += \"}\\n\";\n\n\t\tif (options.normal > 0) {\n\t\t\tif (options.normal === 1) {\n\t\t\t\tfshader += \"\\nvarying vec3 Normal;\\n\";\n\t\t\t} else if (options.normal === 2) {\n\t\t\t\tfshader += \"\\nvarying mat3 ParticleMat;\\n\";\n\t\t\t}\n\n\t\t\tfshader += \"\\nuniform vec3 lightCube[6];\\n\";\n\t\t}\n\n\t\tif (options.soft) fshader += \"\\nvarying float vDepth;\\n\";\n\t\tif (options.normal === 0 && options.fog === \"none\") options.srgb = false;\n\t\tfshader += gammaCode(options.gamma);\n\t\tfshader += tonemapCode(options.toneMap);\n\n\t\tif (options.fog === 'linear') {\n\t\t\tfshader += shaderChunks.fogLinearPS;\n\t\t} else if (options.fog === 'exp') {\n\t\t\tfshader += shaderChunks.fogExpPS;\n\t\t} else if (options.fog === 'exp2') {\n\t\t\tfshader += shaderChunks.fogExp2PS;\n\t\t} else {\n\t\t\tfshader += shaderChunks.fogNonePS;\n\t\t}\n\n\t\tif (options.normal === 2) fshader += \"\\nuniform sampler2D normalMap;\\n\";\n\t\tif (options.soft > 0) fshader += shaderChunks.screenDepthPS;\n\t\tfshader += shaderChunks.particlePS;\n\t\tif (options.soft > 0) fshader += shaderChunks.particle_softPS;\n\t\tif (options.normal === 1) fshader += \"\\nvec3 normal = Normal;\\n\";\n\t\tif (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;\n\t\tif (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;\n\t\tif (options.normal > 0) fshader += shaderChunks.particle_lightingPS;\n\n\t\tif (options.blend === BLEND_NORMAL) {\n\t\t\tfshader += shaderChunks.particle_blendNormalPS;\n\t\t} else if (options.blend === BLEND_ADDITIVE) {\n\t\t\tfshader += shaderChunks.particle_blendAddPS;\n\t\t} else if (options.blend === BLEND_MULTIPLICATIVE) {\n\t\t\tfshader += shaderChunks.particle_blendMultiplyPS;\n\t\t}\n\n\t\tfshader += shaderChunks.particle_endPS;\n\t\tconst attributes = collectAttribs(vshader);\n\t\treturn {\n\t\t\tattributes: attributes,\n\t\t\tvshader: vshader,\n\t\t\tfshader: fshader\n\t\t};\n\t}\n};\n\nconst skybox = {\n\tgenerateKey: function (options) {\n\t\treturn options.type === 'cubemap' ? `skybox-${options.type}-${options.rgbm}-${options.hdr}-${options.fixSeams}-${options.toneMapping}-${options.gamma}-${options.useIntensity}-${options.mip}` : `skybox-${options.type}-${options.encoding}-${options.useIntensity}-${options.gamma}-${options.toneMapping}`;\n\t},\n\tcreateShaderDefinition: function (device, options) {\n\t\tlet fshader;\n\n\t\tif (options.type === 'cubemap') {\n\t\t\tconst mip2size = [128, 64, 16, 8, 4, 2];\n\t\t\tfshader = precisionCode(device);\n\t\t\tfshader += options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;\n\t\t\tfshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;\n\t\t\tfshader += gammaCode(options.gamma);\n\t\t\tfshader += tonemapCode(options.toneMapping);\n\t\t\tfshader += shaderChunks.decodePS;\n\t\t\tfshader += shaderChunks.rgbmPS;\n\t\t\tfshader += shaderChunks.skyboxHDRPS.replace(/\\$textureCubeSAMPLE/g, options.rgbm ? \"textureCubeRGBM\" : options.hdr ? \"textureCube\" : \"textureCubeSRGB\").replace(/\\$FIXCONST/g, 1 - 1 / mip2size[options.mip] + \"\");\n\t\t} else {\n\t\t\tconst decodeTable = {\n\t\t\t\t'rgbm': 'decodeRGBM',\n\t\t\t\t'rgbe': 'decodeRGBE',\n\t\t\t\t'linear': 'decodeLinear'\n\t\t\t};\n\t\t\tfshader = precisionCode(device);\n\t\t\tfshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;\n\t\t\tfshader += gammaCode(options.gamma);\n\t\t\tfshader += tonemapCode(options.toneMapping);\n\t\t\tfshader += shaderChunks.decodePS;\n\t\t\tfshader += shaderChunks.skyboxEnvPS.replace(/\\$DECODE/g, decodeTable[options.encoding] || \"decodeGamma\");\n\t\t}\n\n\t\treturn {\n\t\t\tattributes: {\n\t\t\t\taPosition: SEMANTIC_POSITION\n\t\t\t},\n\t\t\tvshader: shaderChunks.skyboxVS,\n\t\t\tfshader: fshader\n\t\t};\n\t}\n};\n\nconst oneDiv255 = 1 / 255;\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n\nclass FloatPacking {\n\tstatic float2Half(value) {\n\t\tfloatView[0] = value;\n\t\tconst x = int32View[0];\n\t\tlet bits = x >> 16 & 0x8000;\n\t\tlet m = x >> 12 & 0x07ff;\n\t\tconst e = x >> 23 & 0xff;\n\n\t\tif (e < 103) {\n\t\t\treturn bits;\n\t\t}\n\n\t\tif (e > 142) {\n\t\t\tbits |= 0x7c00;\n\t\t\tbits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n\t\t\treturn bits;\n\t\t}\n\n\t\tif (e < 113) {\n\t\t\tm |= 0x0800;\n\t\t\tbits |= (m >> 114 - e) + (m >> 113 - e & 1);\n\t\t\treturn bits;\n\t\t}\n\n\t\tbits |= e - 112 << 10 | m >> 1;\n\t\tbits += m & 1;\n\t\treturn bits;\n\t}\n\n\tstatic float2Bytes(value, array, offset, numBytes) {\n\t\tconst enc1 = 255.0 * value % 1;\n\t\tarray[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);\n\n\t\tif (numBytes > 1) {\n\t\t\tconst enc2 = 65025.0 * value % 1;\n\t\t\tarray[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);\n\n\t\t\tif (numBytes > 2) {\n\t\t\t\tconst enc3 = 16581375.0 * value % 1;\n\t\t\t\tarray[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);\n\n\t\t\t\tif (numBytes > 3) {\n\t\t\t\t\tarray[offset + 3] = Math.round(enc3 * 255);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic float2BytesRange(value, array, offset, min, max, numBytes) {\n\t\tvalue = math.clamp((value - min) / (max - min), 0, 1);\n\t\tFloatPacking.float2Bytes(value, array, offset, numBytes);\n\t}\n\n\tstatic float2MantissaExponent(value, array, offset, numBytes) {\n\t\tconst exponent = Math.floor(Math.log2(Math.abs(value))) + 1;\n\t\tvalue /= Math.pow(2, exponent);\n\t\tFloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);\n\t\tarray[offset + numBytes - 1] = Math.round(exponent + 127);\n\t}\n\n}\n\nlet _pixelSizeTable = null;\nlet _blockSizeTable = null;\n\nclass Texture {\n\tconstructor(graphicsDevice, options) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.name = null;\n\t\tthis._width = 4;\n\t\tthis._height = 4;\n\t\tthis._depth = 1;\n\t\tthis._format = PIXELFORMAT_R8_G8_B8_A8;\n\t\tthis.type = TEXTURETYPE_DEFAULT;\n\t\tthis.projection = TEXTUREPROJECTION_NONE;\n\t\tthis._cubemap = false;\n\t\tthis._volume = false;\n\t\tthis.fixCubemapSeams = false;\n\t\tthis._flipY = false;\n\t\tthis._premultiplyAlpha = false;\n\t\tthis._isRenderTarget = false;\n\t\tthis._mipmaps = true;\n\t\tthis._minFilter = FILTER_LINEAR_MIPMAP_LINEAR;\n\t\tthis._magFilter = FILTER_LINEAR;\n\t\tthis._anisotropy = 1;\n\t\tthis._addressU = ADDRESS_REPEAT;\n\t\tthis._addressV = ADDRESS_REPEAT;\n\t\tthis._addressW = ADDRESS_REPEAT;\n\t\tthis._compareOnRead = false;\n\t\tthis._compareFunc = FUNC_LESS;\n\n\t\tif (options !== undefined) {\n\t\t\tif (options.name !== undefined) {\n\t\t\t\tthis.name = options.name;\n\t\t\t}\n\n\t\t\tthis._width = options.width !== undefined ? options.width : this._width;\n\t\t\tthis._height = options.height !== undefined ? options.height : this._height;\n\t\t\tthis._format = options.format !== undefined ? options.format : this._format;\n\n\t\t\tif (options.hasOwnProperty('type')) {\n\t\t\t\tthis.type = options.type;\n\t\t\t} else if (options.hasOwnProperty('rgbm')) {\n\t\t\t\tthis.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t\t} else if (options.hasOwnProperty('swizzleGGGR')) {\n\t\t\t\tthis.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;\n\t\t\t}\n\n\t\t\tif (options.mipmaps !== undefined) {\n\t\t\t\tthis._mipmaps = options.mipmaps;\n\t\t\t} else {\n\t\t\t\tthis._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;\n\t\t\t}\n\n\t\t\tthis._levels = options.levels;\n\t\t\tthis._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;\n\t\t\tthis.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;\n\n\t\t\tif (this._cubemap) {\n\t\t\t\tthis.projection = TEXTUREPROJECTION_CUBE;\n\t\t\t} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {\n\t\t\t\tthis.projection = options.projection;\n\t\t\t}\n\n\t\t\tthis._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;\n\t\t\tthis._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;\n\t\t\tthis._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;\n\t\t\tthis._addressU = options.addressU !== undefined ? options.addressU : this._addressU;\n\t\t\tthis._addressV = options.addressV !== undefined ? options.addressV : this._addressV;\n\t\t\tthis._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;\n\t\t\tthis._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;\n\t\t\tthis._flipY = options.flipY !== undefined ? options.flipY : this._flipY;\n\t\t\tthis._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : this._premultiplyAlpha;\n\n\t\t\tif (graphicsDevice.webgl2) {\n\t\t\t\tthis._depth = options.depth !== undefined ? options.depth : this._depth;\n\t\t\t\tthis._volume = options.volume !== undefined ? options.volume : this._volume;\n\t\t\t\tthis._addressW = options.addressW !== undefined ? options.addressW : this._addressW;\n\t\t\t}\n\t\t}\n\n\t\tthis._compressed = this._format === PIXELFORMAT_DXT1 || this._format === PIXELFORMAT_DXT3 || this._format === PIXELFORMAT_DXT5 || this._format >= PIXELFORMAT_ETC1;\n\t\tthis._invalid = false;\n\t\tthis._lockedLevel = -1;\n\n\t\tif (!this._levels) {\n\t\t\tthis._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];\n\t\t}\n\n\t\tthis.dirtyAll();\n\t\tthis._gpuSize = 0;\n\t}\n\n\tset minFilter(v) {\n\t\tif (this._minFilter !== v) {\n\t\t\tthis._minFilter = v;\n\t\t\tthis._parameterFlags |= 1;\n\t\t}\n\t}\n\n\tget minFilter() {\n\t\treturn this._minFilter;\n\t}\n\n\tset magFilter(v) {\n\t\tif (this._magFilter !== v) {\n\t\t\tthis._magFilter = v;\n\t\t\tthis._parameterFlags |= 2;\n\t\t}\n\t}\n\n\tget magFilter() {\n\t\treturn this._magFilter;\n\t}\n\n\tset addressU(v) {\n\t\tif (this._addressU !== v) {\n\t\t\tthis._addressU = v;\n\t\t\tthis._parameterFlags |= 4;\n\t\t}\n\t}\n\n\tget addressU() {\n\t\treturn this._addressU;\n\t}\n\n\tset addressV(v) {\n\t\tif (this._addressV !== v) {\n\t\t\tthis._addressV = v;\n\t\t\tthis._parameterFlags |= 8;\n\t\t}\n\t}\n\n\tget addressV() {\n\t\treturn this._addressV;\n\t}\n\n\tset addressW(addressW) {\n\t\tif (!this.device.webgl2) return;\n\n\t\tif (!this._volume) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (addressW !== this._addressW) {\n\t\t\tthis._addressW = addressW;\n\t\t\tthis._parameterFlags |= 16;\n\t\t}\n\t}\n\n\tget addressW() {\n\t\treturn this._addressW;\n\t}\n\n\tset compareOnRead(v) {\n\t\tif (this._compareOnRead !== v) {\n\t\t\tthis._compareOnRead = v;\n\t\t\tthis._parameterFlags |= 32;\n\t\t}\n\t}\n\n\tget compareOnRead() {\n\t\treturn this._compareOnRead;\n\t}\n\n\tset compareFunc(v) {\n\t\tif (this._compareFunc !== v) {\n\t\t\tthis._compareFunc = v;\n\t\t\tthis._parameterFlags |= 64;\n\t\t}\n\t}\n\n\tget compareFunc() {\n\t\treturn this._compareFunc;\n\t}\n\n\tset anisotropy(v) {\n\t\tif (this._anisotropy !== v) {\n\t\t\tthis._anisotropy = v;\n\t\t\tthis._parameterFlags |= 128;\n\t\t}\n\t}\n\n\tget anisotropy() {\n\t\treturn this._anisotropy;\n\t}\n\n\tset autoMipmap(v) {\n\t\tthis._mipmaps = v;\n\t}\n\n\tget autoMipmap() {\n\t\treturn this._mipmaps;\n\t}\n\n\tset mipmaps(v) {\n\t\tif (this._mipmaps !== v) {\n\t\t\tthis._mipmaps = v;\n\t\t\tif (v) this._needsMipmapsUpload = true;\n\t\t}\n\t}\n\n\tget mipmaps() {\n\t\treturn this._mipmaps;\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\tget depth() {\n\t\treturn this._depth;\n\t}\n\n\tget format() {\n\t\treturn this._format;\n\t}\n\n\tget cubemap() {\n\t\treturn this._cubemap;\n\t}\n\n\tget gpuSize() {\n\t\tconst mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);\n\t\treturn Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);\n\t}\n\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\n\tset flipY(flipY) {\n\t\tif (this._flipY !== flipY) {\n\t\t\tthis._flipY = flipY;\n\t\t\tthis._needsUpload = true;\n\t\t}\n\t}\n\n\tget flipY() {\n\t\treturn this._flipY;\n\t}\n\n\tset premultiplyAlpha(premultiplyAlpha) {\n\t\tif (this._premultiplyAlpha !== premultiplyAlpha) {\n\t\t\tthis._premultiplyAlpha = premultiplyAlpha;\n\t\t\tthis._needsUpload = true;\n\t\t}\n\t}\n\n\tget premultiplyAlpha() {\n\t\treturn this._premultiplyAlpha;\n\t}\n\n\tget pot() {\n\t\treturn math.powerOfTwo(this._width) && math.powerOfTwo(this._height);\n\t}\n\n\tget encoding() {\n\t\tif (this.type === TEXTURETYPE_RGBM) {\n\t\t\treturn 'rgbm';\n\t\t}\n\n\t\tif (this.type === TEXTURETYPE_RGBE) {\n\t\t\treturn 'rgbe';\n\t\t}\n\n\t\tif (this.format === PIXELFORMAT_RGBA16F || this.format === PIXELFORMAT_RGBA32F) {\n\t\t\treturn 'linear';\n\t\t}\n\n\t\treturn 'srgb';\n\t}\n\n\tstatic calcGpuSize(width, height, depth, format, mipmaps, cubemap) {\n\t\tif (!_pixelSizeTable) {\n\t\t\t_pixelSizeTable = [];\n\t\t\t_pixelSizeTable[PIXELFORMAT_A8] = 1;\n\t\t\t_pixelSizeTable[PIXELFORMAT_L8] = 1;\n\t\t\t_pixelSizeTable[PIXELFORMAT_L8_A8] = 2;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R5_G6_B5] = 2;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R5_G5_B5_A1] = 2;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R4_G4_B4_A4] = 2;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R8_G8_B8] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R8_G8_B8_A8] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_RGB16F] = 8;\n\t\t\t_pixelSizeTable[PIXELFORMAT_RGBA16F] = 8;\n\t\t\t_pixelSizeTable[PIXELFORMAT_RGB32F] = 16;\n\t\t\t_pixelSizeTable[PIXELFORMAT_RGBA32F] = 16;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R32F] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_DEPTH] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_DEPTHSTENCIL] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_111110F] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_SRGB] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_SRGBA] = 4;\n\t\t}\n\n\t\tif (!_blockSizeTable) {\n\t\t\t_blockSizeTable = [];\n\t\t\t_blockSizeTable[PIXELFORMAT_ETC1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_ETC2_RGB] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_DXT1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_ATC_RGB] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_ETC2_RGBA] = 16;\n\t\t\t_blockSizeTable[PIXELFORMAT_DXT3] = 16;\n\t\t\t_blockSizeTable[PIXELFORMAT_DXT5] = 16;\n\t\t\t_blockSizeTable[PIXELFORMAT_ASTC_4x4] = 16;\n\t\t\t_blockSizeTable[PIXELFORMAT_ATC_RGBA] = 16;\n\t\t}\n\n\t\tconst pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;\n\t\tconst blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;\n\t\tlet result = 0;\n\n\t\twhile (1) {\n\t\t\tif (pixelSize > 0) {\n\t\t\t\tresult += width * height * depth * pixelSize;\n\t\t\t} else {\n\t\t\t\tlet blockWidth = Math.floor((width + 3) / 4);\n\t\t\t\tconst blockHeight = Math.floor((height + 3) / 4);\n\t\t\t\tconst blockDepth = Math.floor((depth + 3) / 4);\n\n\t\t\t\tif (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {\n\t\t\t\t\tblockWidth = Math.max(Math.floor(blockWidth / 2), 1);\n\t\t\t\t}\n\n\t\t\t\tresult += blockWidth * blockHeight * blockDepth * blockSize;\n\t\t\t}\n\n\t\t\tif (!mipmaps || width === 1 && height === 1 && depth === 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twidth = Math.max(Math.floor(width / 2), 1);\n\t\t\theight = Math.max(Math.floor(height / 2), 1);\n\t\t\tdepth = Math.max(Math.floor(depth / 2), 1);\n\t\t}\n\n\t\treturn result * (cubemap ? 6 : 1);\n\t}\n\n\tdestroy() {\n\t\tif (this.device) {\n\t\t\tthis.device.destroyTexture(this);\n\t\t}\n\n\t\tthis.device = null;\n\t\tthis._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];\n\t}\n\n\tdirtyAll() {\n\t\tthis._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];\n\t\tthis._needsUpload = true;\n\t\tthis._needsMipmapsUpload = this._mipmaps;\n\t\tthis._mipmapsUploaded = false;\n\t\tthis._parameterFlags = 255;\n\t}\n\n\tlock(options = {}) {\n\t\tif (options.level === undefined) {\n\t\t\toptions.level = 0;\n\t\t}\n\n\t\tif (options.face === undefined) {\n\t\t\toptions.face = 0;\n\t\t}\n\n\t\tif (options.mode === undefined) {\n\t\t\toptions.mode = TEXTURELOCK_WRITE;\n\t\t}\n\n\t\tthis._lockedLevel = options.level;\n\n\t\tif (this._levels[options.level] === null) {\n\t\t\tswitch (this._format) {\n\t\t\t\tcase PIXELFORMAT_A8:\n\t\t\t\tcase PIXELFORMAT_L8:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_L8_A8:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_R5_G6_B5:\n\t\t\t\tcase PIXELFORMAT_R5_G5_B5_A1:\n\t\t\t\tcase PIXELFORMAT_R4_G4_B4_A4:\n\t\t\t\t\tthis._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_R8_G8_B8:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_R8_G8_B8_A8:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_DXT1:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_DXT3:\n\t\t\t\tcase PIXELFORMAT_DXT5:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_RGB16F:\n\t\t\t\t\tthis._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_RGB32F:\n\t\t\t\t\tthis._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\t\t\tthis._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\t\t\tthis._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this._levels[options.level];\n\t}\n\n\tsetSource(source, mipLevel = 0) {\n\t\tlet invalid = false;\n\t\tlet width, height;\n\n\t\tif (this._cubemap) {\n\t\t\tif (source[0]) {\n\t\t\t\twidth = source[0].width || 0;\n\t\t\t\theight = source[0].height || 0;\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tconst face = source[i];\n\n\t\t\t\t\tif (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {\n\t\t\t\t\t\tinvalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\n\t\t\tif (!invalid) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tif (this._levels[mipLevel][i] !== source[i]) this._levelsUpdated[mipLevel][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this.device._isBrowserInterface(source)) invalid = true;\n\n\t\t\tif (!invalid) {\n\t\t\t\tif (source !== this._levels[mipLevel]) this._levelsUpdated[mipLevel] = true;\n\t\t\t\twidth = source.width;\n\t\t\t\theight = source.height;\n\t\t\t}\n\t\t}\n\n\t\tif (invalid) {\n\t\t\tthis._width = 4;\n\t\t\tthis._height = 4;\n\n\t\t\tif (this._cubemap) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tthis._levels[mipLevel][i] = null;\n\t\t\t\t\tthis._levelsUpdated[mipLevel][i] = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._levels[mipLevel] = null;\n\t\t\t\tthis._levelsUpdated[mipLevel] = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mipLevel === 0) {\n\t\t\t\tthis._width = width;\n\t\t\t\tthis._height = height;\n\t\t\t}\n\n\t\t\tthis._levels[mipLevel] = source;\n\t\t}\n\n\t\tif (this._invalid !== invalid || !invalid) {\n\t\t\tthis._invalid = invalid;\n\t\t\tthis.upload();\n\t\t}\n\t}\n\n\tgetSource(mipLevel = 0) {\n\t\treturn this._levels[mipLevel];\n\t}\n\n\tunlock() {\n\t\tif (this._lockedLevel === -1) ;\n\n\t\tthis.upload();\n\t\tthis._lockedLevel = -1;\n\t}\n\n\tupload() {\n\t\tthis._needsUpload = true;\n\t\tthis._needsMipmapsUpload = this._mipmaps;\n\t}\n\n\tgetDds() {\n\t\tlet fsize = 128;\n\t\tlet idx = 0;\n\n\t\twhile (this._levels[idx]) {\n\t\t\tif (!this.cubemap) {\n\t\t\t\tconst mipSize = this._levels[idx].length;\n\n\t\t\t\tif (!mipSize) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfsize += mipSize;\n\t\t\t} else {\n\t\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\t\tif (!this._levels[idx][face]) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mipSize = this._levels[idx][face].length;\n\n\t\t\t\t\tif (!mipSize) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tfsize += mipSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfsize += this._levels[idx].length;\n\t\t\tidx++;\n\t\t}\n\n\t\tconst buff = new ArrayBuffer(fsize);\n\t\tconst header = new Uint32Array(buff, 0, 128 / 4);\n\t\tconst DDS_MAGIC = 542327876;\n\t\tconst DDS_HEADER_SIZE = 124;\n\t\tconst DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000;\n\t\tconst DDS_FLAGS_MIPMAP = 0x20000;\n\t\tconst DDS_PIXELFORMAT_SIZE = 32;\n\t\tconst DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40;\n\t\tconst DDS_CAPS_REQUIRED = 0x1000;\n\t\tconst DDS_CAPS_MIPMAP = 0x400000;\n\t\tconst DDS_CAPS_COMPLEX = 0x8;\n\t\tconst DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000;\n\t\tlet flags = DDS_FLAGS_REQUIRED;\n\t\tif (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;\n\t\tlet caps = DDS_CAPS_REQUIRED;\n\t\tif (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;\n\t\tif (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;\n\t\tconst caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;\n\t\theader[0] = DDS_MAGIC;\n\t\theader[1] = DDS_HEADER_SIZE;\n\t\theader[2] = flags;\n\t\theader[3] = this.height;\n\t\theader[4] = this.width;\n\t\theader[5] = this.width * this.height * 4;\n\t\theader[6] = 0;\n\t\theader[7] = this._levels.length;\n\n\t\tfor (let i = 0; i < 11; i++) {\n\t\t\theader[8 + i] = 0;\n\t\t}\n\n\t\theader[19] = DDS_PIXELFORMAT_SIZE;\n\t\theader[20] = DDS_PIXELFLAGS_RGBA8;\n\t\theader[21] = 0;\n\t\theader[22] = 32;\n\t\theader[23] = 0x00FF0000;\n\t\theader[24] = 0x0000FF00;\n\t\theader[25] = 0x000000FF;\n\t\theader[26] = 0xFF000000;\n\t\theader[27] = caps;\n\t\theader[28] = caps2;\n\t\theader[29] = 0;\n\t\theader[30] = 0;\n\t\theader[31] = 0;\n\t\tlet offset = 128;\n\n\t\tif (!this.cubemap) {\n\t\t\tfor (let i = 0; i < this._levels.length; i++) {\n\t\t\t\tconst level = this._levels[i];\n\t\t\t\tconst mip = new Uint8Array(buff, offset, level.length);\n\n\t\t\t\tfor (let j = 0; j < level.length; j++) {\n\t\t\t\t\tmip[j] = level[j];\n\t\t\t\t}\n\n\t\t\t\toffset += level.length;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\tfor (let i = 0; i < this._levels.length; i++) {\n\t\t\t\t\tconst level = this._levels[i][face];\n\t\t\t\t\tconst mip = new Uint8Array(buff, offset, level.length);\n\n\t\t\t\t\tfor (let j = 0; j < level.length; j++) {\n\t\t\t\t\t\tmip[j] = level[j];\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += level.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buff;\n\t}\n\n}\n\nconst _deviceCoord = new Vec3();\n\nconst _halfSize = new Vec3();\n\nconst _point = new Vec3();\n\nconst _invViewProjMat = new Mat4();\n\nclass Camera {\n\tconstructor() {\n\t\tthis._aspectRatio = 16 / 9;\n\t\tthis._aspectRatioMode = ASPECT_AUTO;\n\t\tthis._calculateProjection = null;\n\t\tthis._calculateTransform = null;\n\t\tthis._clearColor = new Color(0.75, 0.75, 0.75, 1);\n\t\tthis._clearColorBuffer = true;\n\t\tthis._clearDepth = 1;\n\t\tthis._clearDepthBuffer = true;\n\t\tthis._clearStencil = 0;\n\t\tthis._clearStencilBuffer = true;\n\t\tthis._cullingMask = 0xFFFFFFFF;\n\t\tthis._cullFaces = true;\n\t\tthis._farClip = 1000;\n\t\tthis._flipFaces = false;\n\t\tthis._fov = 45;\n\t\tthis._frustumCulling = true;\n\t\tthis._horizontalFov = false;\n\t\tthis._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];\n\t\tthis._nearClip = 0.1;\n\t\tthis._node = null;\n\t\tthis._orthoHeight = 10;\n\t\tthis._projection = PROJECTION_PERSPECTIVE;\n\t\tthis._rect = new Vec4(0, 0, 1, 1);\n\t\tthis._renderTarget = null;\n\t\tthis._scissorRect = new Vec4(0, 0, 1, 1);\n\t\tthis._scissorRectClear = false;\n\t\tthis._vrDisplay = null;\n\t\tthis._projMat = new Mat4();\n\t\tthis._projMatDirty = true;\n\t\tthis._projMatSkybox = new Mat4();\n\t\tthis._viewMat = new Mat4();\n\t\tthis._viewMatDirty = true;\n\t\tthis._viewProjMat = new Mat4();\n\t\tthis._viewProjMatDirty = true;\n\t\tthis.frustum = new Frustum();\n\t}\n\n\tset aspectRatio(newValue) {\n\t\tif (this._aspectRatio !== newValue) {\n\t\t\tthis._aspectRatio = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget aspectRatio() {\n\t\treturn this._aspectRatio;\n\t}\n\n\tset aspectRatioMode(newValue) {\n\t\tif (this._aspectRatioMode !== newValue) {\n\t\t\tthis._aspectRatioMode = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget aspectRatioMode() {\n\t\treturn this._aspectRatioMode;\n\t}\n\n\tset calculateProjection(newValue) {\n\t\tthis._calculateProjection = newValue;\n\t\tthis._projMatDirty = true;\n\t}\n\n\tget calculateProjection() {\n\t\treturn this._calculateProjection;\n\t}\n\n\tset calculateTransform(newValue) {\n\t\tthis._calculateTransform = newValue;\n\t}\n\n\tget calculateTransform() {\n\t\treturn this._calculateTransform;\n\t}\n\n\tset clearColor(newValue) {\n\t\tthis._clearColor.copy(newValue);\n\t}\n\n\tget clearColor() {\n\t\treturn this._clearColor;\n\t}\n\n\tset clearColorBuffer(newValue) {\n\t\tthis._clearColorBuffer = newValue;\n\t}\n\n\tget clearColorBuffer() {\n\t\treturn this._clearColorBuffer;\n\t}\n\n\tset clearDepth(newValue) {\n\t\tthis._clearDepth = newValue;\n\t}\n\n\tget clearDepth() {\n\t\treturn this._clearDepth;\n\t}\n\n\tset clearDepthBuffer(newValue) {\n\t\tthis._clearDepthBuffer = newValue;\n\t}\n\n\tget clearDepthBuffer() {\n\t\treturn this._clearDepthBuffer;\n\t}\n\n\tset clearStencil(newValue) {\n\t\tthis._clearStencil = newValue;\n\t}\n\n\tget clearStencil() {\n\t\treturn this._clearStencil;\n\t}\n\n\tset clearStencilBuffer(newValue) {\n\t\tthis._clearStencilBuffer = newValue;\n\t}\n\n\tget clearStencilBuffer() {\n\t\treturn this._clearStencilBuffer;\n\t}\n\n\tset cullingMask(newValue) {\n\t\tthis._cullingMask = newValue;\n\t}\n\n\tget cullingMask() {\n\t\treturn this._cullingMask;\n\t}\n\n\tset cullFaces(newValue) {\n\t\tthis._cullFaces = newValue;\n\t}\n\n\tget cullFaces() {\n\t\treturn this._cullFaces;\n\t}\n\n\tset farClip(newValue) {\n\t\tif (this._farClip !== newValue) {\n\t\t\tthis._farClip = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget farClip() {\n\t\treturn this._farClip;\n\t}\n\n\tset flipFaces(newValue) {\n\t\tthis._flipFaces = newValue;\n\t}\n\n\tget flipFaces() {\n\t\treturn this._flipFaces;\n\t}\n\n\tset fov(newValue) {\n\t\tif (this._fov !== newValue) {\n\t\t\tthis._fov = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget fov() {\n\t\treturn this._fov;\n\t}\n\n\tset frustumCulling(newValue) {\n\t\tthis._frustumCulling = newValue;\n\t}\n\n\tget frustumCulling() {\n\t\treturn this._frustumCulling;\n\t}\n\n\tset horizontalFov(newValue) {\n\t\tif (this._horizontalFov !== newValue) {\n\t\t\tthis._horizontalFov = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget horizontalFov() {\n\t\treturn this._horizontalFov;\n\t}\n\n\tset layers(newValue) {\n\t\tthis._layers = newValue.slice(0);\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset nearClip(newValue) {\n\t\tif (this._nearClip !== newValue) {\n\t\t\tthis._nearClip = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget nearClip() {\n\t\treturn this._nearClip;\n\t}\n\n\tset node(newValue) {\n\t\tthis._node = newValue;\n\t}\n\n\tget node() {\n\t\treturn this._node;\n\t}\n\n\tset orthoHeight(newValue) {\n\t\tif (this._orthoHeight !== newValue) {\n\t\t\tthis._orthoHeight = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget orthoHeight() {\n\t\treturn this._orthoHeight;\n\t}\n\n\tset projection(newValue) {\n\t\tif (this._projection !== newValue) {\n\t\t\tthis._projection = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget projection() {\n\t\treturn this._projection;\n\t}\n\n\tget projectionMatrix() {\n\t\tthis._evaluateProjectionMatrix();\n\n\t\treturn this._projMat;\n\t}\n\n\tset rect(newValue) {\n\t\tthis._rect.copy(newValue);\n\t}\n\n\tget rect() {\n\t\treturn this._rect;\n\t}\n\n\tset renderTarget(newValue) {\n\t\tthis._renderTarget = newValue;\n\t}\n\n\tget renderTarget() {\n\t\treturn this._renderTarget;\n\t}\n\n\tset scissorRect(newValue) {\n\t\tthis._scissorRect.copy(newValue);\n\t}\n\n\tget scissorRect() {\n\t\treturn this._scissorRect;\n\t}\n\n\tget viewMatrix() {\n\t\tif (this._viewMatDirty) {\n\t\t\tconst wtm = this._node.getWorldTransform();\n\n\t\t\tthis._viewMat.copy(wtm).invert();\n\n\t\t\tthis._viewMatDirty = false;\n\t\t}\n\n\t\treturn this._viewMat;\n\t}\n\n\tset vrDisplay(newValue) {\n\t\tthis._vrDisplay = newValue;\n\n\t\tif (newValue) {\n\t\t\tnewValue._camera = this;\n\t\t}\n\t}\n\n\tget vrDisplay() {\n\t\treturn this._vrDisplay;\n\t}\n\n\tclone() {\n\t\treturn new Camera().copy(this);\n\t}\n\n\tcopy(other) {\n\t\tthis.aspectRatio = other.aspectRatio;\n\t\tthis.aspectRatioMode = other.aspectRatioMode;\n\t\tthis.calculateProjection = other.calculateProjection;\n\t\tthis.calculateTransform = other.calculateTransform;\n\t\tthis.clearColor = other.clearColor;\n\t\tthis.clearColorBuffer = other.clearColorBuffer;\n\t\tthis.clearDepth = other.clearDepth;\n\t\tthis.clearDepthBuffer = other.clearDepthBuffer;\n\t\tthis.clearStencil = other.clearStencil;\n\t\tthis.clearStencilBuffer = other.clearStencilBuffer;\n\t\tthis.cullFaces = other.cullFaces;\n\t\tthis.cullingMask = other.cullingMask;\n\t\tthis.farClip = other.farClip;\n\t\tthis.flipFaces = other.flipFaces;\n\t\tthis.fov = other.fov;\n\t\tthis.frustumCulling = other.frustumCulling;\n\t\tthis.horizontalFov = other.horizontalFov;\n\t\tthis.layers = other.layers;\n\t\tthis.nearClip = other.nearClip;\n\t\tthis.orthoHeight = other.orthoHeight;\n\t\tthis.projection = other.projection;\n\t\tthis.rect = other.rect;\n\t\tthis.renderTarget = other.renderTarget;\n\t\tthis.scissorRect = other.scissorRect;\n\t\tthis.vrDisplay = other.vrDisplay;\n\t\treturn this;\n\t}\n\n\t_updateViewProjMat() {\n\t\tif (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {\n\t\t\tthis._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);\n\n\t\t\tthis._viewProjMatDirty = false;\n\t\t}\n\t}\n\n\tworldToScreen(worldCoord, cw, ch, screenCoord = new Vec3()) {\n\t\tthis._updateViewProjMat();\n\n\t\tthis._viewProjMat.transformPoint(worldCoord, screenCoord);\n\n\t\tconst vpm = this._viewProjMat.data;\n\t\tconst w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];\n\t\tscreenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;\n\t\tscreenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;\n\t\treturn screenCoord;\n\t}\n\n\tscreenToWorld(x, y, z, cw, ch, worldCoord = new Vec3()) {\n\t\tconst range = this._farClip - this._nearClip;\n\n\t\t_deviceCoord.set(x / cw, (ch - y) / ch, z / range);\n\n\t\t_deviceCoord.mulScalar(2);\n\n\t\t_deviceCoord.sub(Vec3.ONE);\n\n\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\tMat4._getPerspectiveHalfSize(_halfSize, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov);\n\n\t\t\t_halfSize.x *= _deviceCoord.x;\n\t\t\t_halfSize.y *= _deviceCoord.y;\n\n\t\t\tconst invView = this._node.getWorldTransform();\n\n\t\t\t_halfSize.z = -this._nearClip;\n\t\t\tinvView.transformPoint(_halfSize, _point);\n\n\t\t\tconst cameraPos = this._node.getPosition();\n\n\t\t\tworldCoord.sub2(_point, cameraPos);\n\t\t\tworldCoord.normalize();\n\t\t\tworldCoord.mulScalar(z);\n\t\t\tworldCoord.add(cameraPos);\n\t\t} else {\n\t\t\tthis._updateViewProjMat();\n\n\t\t\t_invViewProjMat.copy(this._viewProjMat).invert();\n\n\t\t\t_invViewProjMat.transformPoint(_deviceCoord, worldCoord);\n\t\t}\n\n\t\treturn worldCoord;\n\t}\n\n\t_evaluateProjectionMatrix() {\n\t\tif (this._projMatDirty) {\n\t\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\t\tthis._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov);\n\n\t\t\t\tthis._projMatSkybox.copy(this._projMat);\n\t\t\t} else {\n\t\t\t\tconst y = this._orthoHeight;\n\t\t\t\tconst x = y * this._aspectRatio;\n\n\t\t\t\tthis._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);\n\n\t\t\t\tthis._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip);\n\t\t\t}\n\n\t\t\tthis._projMatDirty = false;\n\t\t}\n\t}\n\n\tgetProjectionMatrixSkybox() {\n\t\tthis._evaluateProjectionMatrix();\n\n\t\treturn this._projMatSkybox;\n\t}\n\n\tgetScreenSize(sphere) {\n\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\tconst distance = this._node.getPosition().distance(sphere.center);\n\n\t\t\tif (distance < sphere.radius) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tconst viewAngle = Math.asin(sphere.radius / distance);\n\t\t\tconst sphereViewHeight = Math.tan(viewAngle);\n\t\t\tconst screenViewHeight = Math.tan(this._fov / 2 * math.DEG_TO_RAD);\n\t\t\treturn Math.min(sphereViewHeight / screenViewHeight, 1);\n\t\t}\n\n\t\treturn math.clamp(sphere.radius / this._orthoHeight, 0, 1);\n\t}\n\n}\n\nconst scaleCompensatePosTransform = new Mat4();\nconst scaleCompensatePos = new Vec3();\nconst scaleCompensateRot = new Quat();\nconst scaleCompensateRot2 = new Quat();\nconst scaleCompensateScale = new Vec3();\nconst scaleCompensateScaleForParent = new Vec3();\nconst tmpMat4 = new Mat4();\nconst tmpQuat = new Quat();\nconst position$1 = new Vec3();\nconst invParentWtm$1 = new Mat4();\nconst rotation = new Quat();\nconst invParentRot = new Quat();\nconst matrix = new Mat4();\nconst target = new Vec3();\nconst up = new Vec3();\n\nclass GraphNode extends EventHandler {\n\tconstructor(name = 'Untitled') {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.tags = new Tags(this);\n\t\tthis._labels = {};\n\t\tthis.localPosition = new Vec3();\n\t\tthis.localRotation = new Quat();\n\t\tthis.localScale = new Vec3(1, 1, 1);\n\t\tthis.localEulerAngles = new Vec3();\n\t\tthis.position = new Vec3();\n\t\tthis.rotation = new Quat();\n\t\tthis.eulerAngles = new Vec3();\n\t\tthis._scale = null;\n\t\tthis.localTransform = new Mat4();\n\t\tthis._dirtyLocal = false;\n\t\tthis._aabbVer = 0;\n\t\tthis._frozen = false;\n\t\tthis.worldTransform = new Mat4();\n\t\tthis._dirtyWorld = false;\n\t\tthis.normalMatrix = new Mat3();\n\t\tthis._dirtyNormal = true;\n\t\tthis._right = null;\n\t\tthis._up = null;\n\t\tthis._forward = null;\n\t\tthis._parent = null;\n\t\tthis._children = [];\n\t\tthis._graphDepth = 0;\n\t\tthis._enabled = true;\n\t\tthis._enabledInHierarchy = false;\n\t\tthis.scaleCompensation = false;\n\t}\n\n\tget right() {\n\t\tif (!this._right) {\n\t\t\tthis._right = new Vec3();\n\t\t}\n\n\t\treturn this.getWorldTransform().getX(this._right).normalize();\n\t}\n\n\tget up() {\n\t\tif (!this._up) {\n\t\t\tthis._up = new Vec3();\n\t\t}\n\n\t\treturn this.getWorldTransform().getY(this._up).normalize();\n\t}\n\n\tget forward() {\n\t\tif (!this._forward) {\n\t\t\tthis._forward = new Vec3();\n\t\t}\n\n\t\treturn this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);\n\t}\n\n\tset enabled(enabled) {\n\t\tif (this._enabled !== enabled) {\n\t\t\tthis._enabled = enabled;\n\t\t\tif (!this._parent || this._parent.enabled) this._notifyHierarchyStateChanged(this, enabled);\n\t\t}\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled && this._enabledInHierarchy;\n\t}\n\n\tget parent() {\n\t\treturn this._parent;\n\t}\n\n\tget path() {\n\t\tlet node = this._parent;\n\n\t\tif (!node) {\n\t\t\treturn '';\n\t\t}\n\n\t\tlet result = this.name;\n\n\t\twhile (node && node._parent) {\n\t\t\tresult = `${node.name}/${result}`;\n\t\t\tnode = node._parent;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tget root() {\n\t\tlet result = this;\n\n\t\twhile (result._parent) {\n\t\t\tresult = result._parent;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tget children() {\n\t\treturn this._children;\n\t}\n\n\tget graphDepth() {\n\t\treturn this._graphDepth;\n\t}\n\n\t_notifyHierarchyStateChanged(node, enabled) {\n\t\tnode._onHierarchyStateChanged(enabled);\n\n\t\tconst c = node._children;\n\n\t\tfor (let i = 0, len = c.length; i < len; i++) {\n\t\t\tif (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);\n\t\t}\n\t}\n\n\t_onHierarchyStateChanged(enabled) {\n\t\tthis._enabledInHierarchy = enabled;\n\t\tif (enabled && !this._frozen) this._unfreezeParentToRoot();\n\t}\n\n\t_cloneInternal(clone) {\n\t\tclone.name = this.name;\n\t\tconst tags = this.tags._list;\n\t\tclone.tags.clear();\n\n\t\tfor (let i = 0; i < tags.length; i++) clone.tags.add(tags[i]);\n\n\t\tclone._labels = Object.assign({}, this._labels);\n\t\tclone.localPosition.copy(this.localPosition);\n\t\tclone.localRotation.copy(this.localRotation);\n\t\tclone.localScale.copy(this.localScale);\n\t\tclone.localEulerAngles.copy(this.localEulerAngles);\n\t\tclone.position.copy(this.position);\n\t\tclone.rotation.copy(this.rotation);\n\t\tclone.eulerAngles.copy(this.eulerAngles);\n\t\tclone.localTransform.copy(this.localTransform);\n\t\tclone._dirtyLocal = this._dirtyLocal;\n\t\tclone.worldTransform.copy(this.worldTransform);\n\t\tclone._dirtyWorld = this._dirtyWorld;\n\t\tclone._dirtyNormal = this._dirtyNormal;\n\t\tclone._aabbVer = this._aabbVer + 1;\n\t\tclone._enabled = this._enabled;\n\t\tclone.scaleCompensation = this.scaleCompensation;\n\t\tclone._enabledInHierarchy = false;\n\t}\n\n\tclone() {\n\t\tconst clone = new GraphNode();\n\n\t\tthis._cloneInternal(clone);\n\n\t\treturn clone;\n\t}\n\n\tcopy(source) {\n\t\tsource._cloneInternal(this);\n\n\t\treturn this;\n\t}\n\n\tfind(attr, value) {\n\t\tlet result,\n\t\t\t\tresults = [];\n\t\tconst len = this._children.length;\n\n\t\tif (attr instanceof Function) {\n\t\t\tconst fn = attr;\n\t\t\tresult = fn(this);\n\t\t\tif (result) results.push(this);\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst descendants = this._children[i].find(fn);\n\n\t\t\t\tif (descendants.length) results = results.concat(descendants);\n\t\t\t}\n\t\t} else {\n\t\t\tlet testValue;\n\n\t\t\tif (this[attr]) {\n\t\t\t\tif (this[attr] instanceof Function) {\n\t\t\t\t\ttestValue = this[attr]();\n\t\t\t\t} else {\n\t\t\t\t\ttestValue = this[attr];\n\t\t\t\t}\n\n\t\t\t\tif (testValue === value) results.push(this);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\tconst descendants = this._children[i].find(attr, value);\n\n\t\t\t\tif (descendants.length) results = results.concat(descendants);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tfindOne(attr, value) {\n\t\tconst len = this._children.length;\n\t\tlet result = null;\n\n\t\tif (attr instanceof Function) {\n\t\t\tconst fn = attr;\n\t\t\tresult = fn(this);\n\t\t\tif (result) return this;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tresult = this._children[i].findOne(fn);\n\t\t\t\tif (result) return result;\n\t\t\t}\n\t\t} else {\n\t\t\tlet testValue;\n\n\t\t\tif (this[attr]) {\n\t\t\t\tif (this[attr] instanceof Function) {\n\t\t\t\t\ttestValue = this[attr]();\n\t\t\t\t} else {\n\t\t\t\t\ttestValue = this[attr];\n\t\t\t\t}\n\n\t\t\t\tif (testValue === value) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tresult = this._children[i].findOne(attr, value);\n\t\t\t\tif (result !== null) return result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfindByTag() {\n\t\tconst query = arguments;\n\t\tconst results = [];\n\n\t\tconst queryNode = (node, checkNode) => {\n\t\t\tif (checkNode && node.tags.has(...query)) {\n\t\t\t\tresults.push(node);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\t\tqueryNode(node._children[i], true);\n\t\t\t}\n\t\t};\n\n\t\tqueryNode(this, false);\n\t\treturn results;\n\t}\n\n\tfindByName(name) {\n\t\tif (this.name === name) return this;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst found = this._children[i].findByName(name);\n\n\t\t\tif (found !== null) return found;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfindByPath(path) {\n\t\tconst parts = Array.isArray(path) ? path : path.split('/');\n\t\tlet result = this;\n\n\t\tfor (let i = 0, imax = parts.length; i < imax; ++i) {\n\t\t\tresult = result.children.find(c => c.name === parts[i]);\n\n\t\t\tif (!result) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tforEach(callback, thisArg) {\n\t\tcallback.call(thisArg, this);\n\t\tconst children = this._children;\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tchildren[i].forEach(callback, thisArg);\n\t\t}\n\t}\n\n\tisDescendantOf(node) {\n\t\tlet parent = this._parent;\n\n\t\twhile (parent) {\n\t\t\tif (parent === node) return true;\n\t\t\tparent = parent._parent;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tisAncestorOf(node) {\n\t\treturn node.isDescendantOf(this);\n\t}\n\n\tgetEulerAngles() {\n\t\tthis.getWorldTransform().getEulerAngles(this.eulerAngles);\n\t\treturn this.eulerAngles;\n\t}\n\n\tgetLocalEulerAngles() {\n\t\tthis.localRotation.getEulerAngles(this.localEulerAngles);\n\t\treturn this.localEulerAngles;\n\t}\n\n\tgetLocalPosition() {\n\t\treturn this.localPosition;\n\t}\n\n\tgetLocalRotation() {\n\t\treturn this.localRotation;\n\t}\n\n\tgetLocalScale() {\n\t\treturn this.localScale;\n\t}\n\n\tgetLocalTransform() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\n\t\treturn this.localTransform;\n\t}\n\n\tgetPosition() {\n\t\tthis.getWorldTransform().getTranslation(this.position);\n\t\treturn this.position;\n\t}\n\n\tgetRotation() {\n\t\tthis.rotation.setFromMat4(this.getWorldTransform());\n\t\treturn this.rotation;\n\t}\n\n\tgetScale() {\n\t\tif (!this._scale) {\n\t\t\tthis._scale = new Vec3();\n\t\t}\n\n\t\treturn this.getWorldTransform().getScale(this._scale);\n\t}\n\n\tgetWorldTransform() {\n\t\tif (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;\n\t\tif (this._parent) this._parent.getWorldTransform();\n\n\t\tthis._sync();\n\n\t\treturn this.worldTransform;\n\t}\n\n\treparent(parent, index) {\n\t\tconst current = this._parent;\n\t\tif (current) current.removeChild(this);\n\n\t\tif (parent) {\n\t\t\tif (index >= 0) {\n\t\t\t\tparent.insertChild(this, index);\n\t\t\t} else {\n\t\t\t\tparent.addChild(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetLocalEulerAngles(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localRotation.setFromEulerAngles(x.x, x.y, x.z);\n\t\t} else {\n\t\t\tthis.localRotation.setFromEulerAngles(x, y, z);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetLocalPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localPosition.copy(x);\n\t\t} else {\n\t\t\tthis.localPosition.set(x, y, z);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetLocalRotation(x, y, z, w) {\n\t\tif (x instanceof Quat) {\n\t\t\tthis.localRotation.copy(x);\n\t\t} else {\n\t\t\tthis.localRotation.set(x, y, z, w);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetLocalScale(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localScale.copy(x);\n\t\t} else {\n\t\t\tthis.localScale.set(x, y, z);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\t_dirtifyLocal() {\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = true;\n\t\t\tif (!this._dirtyWorld) this._dirtifyWorld();\n\t\t}\n\t}\n\n\t_unfreezeParentToRoot() {\n\t\tlet p = this._parent;\n\n\t\twhile (p) {\n\t\t\tp._frozen = false;\n\t\t\tp = p._parent;\n\t\t}\n\t}\n\n\t_dirtifyWorld() {\n\t\tif (!this._dirtyWorld) this._unfreezeParentToRoot();\n\n\t\tthis._dirtifyWorldInternal();\n\t}\n\n\t_dirtifyWorldInternal() {\n\t\tif (!this._dirtyWorld) {\n\t\t\tthis._frozen = false;\n\t\t\tthis._dirtyWorld = true;\n\n\t\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\t\tif (!this._children[i]._dirtyWorld) this._children[i]._dirtifyWorldInternal();\n\t\t\t}\n\t\t}\n\n\t\tthis._dirtyNormal = true;\n\t\tthis._aabbVer++;\n\t}\n\n\tsetPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition$1.copy(x);\n\t\t} else {\n\t\t\tposition$1.set(x, y, z);\n\t\t}\n\n\t\tif (this._parent === null) {\n\t\t\tthis.localPosition.copy(position$1);\n\t\t} else {\n\t\t\tinvParentWtm$1.copy(this._parent.getWorldTransform()).invert();\n\t\t\tinvParentWtm$1.transformPoint(position$1, this.localPosition);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetRotation(x, y, z, w) {\n\t\tif (x instanceof Quat) {\n\t\t\trotation.copy(x);\n\t\t} else {\n\t\t\trotation.set(x, y, z, w);\n\t\t}\n\n\t\tif (this._parent === null) {\n\t\t\tthis.localRotation.copy(rotation);\n\t\t} else {\n\t\t\tconst parentRot = this._parent.getRotation();\n\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\tthis.localRotation.copy(invParentRot).mul(rotation);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetEulerAngles(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localRotation.setFromEulerAngles(x.x, x.y, x.z);\n\t\t} else {\n\t\t\tthis.localRotation.setFromEulerAngles(x, y, z);\n\t\t}\n\n\t\tif (this._parent !== null) {\n\t\t\tconst parentRot = this._parent.getRotation();\n\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\tthis.localRotation.mul2(invParentRot, this.localRotation);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\taddChild(node) {\n\t\tif (node._parent !== null) throw new Error(\"GraphNode is already parented\");\n\n\t\tthis._children.push(node);\n\n\t\tthis._onInsertChild(node);\n\t}\n\n\taddChildAndSaveTransform(node) {\n\t\tconst wPos = node.getPosition();\n\t\tconst wRot = node.getRotation();\n\t\tconst current = node._parent;\n\t\tif (current) current.removeChild(node);\n\t\tnode.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));\n\t\tnode.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));\n\n\t\tthis._children.push(node);\n\n\t\tthis._onInsertChild(node);\n\t}\n\n\tinsertChild(node, index) {\n\t\tif (node._parent !== null) throw new Error(\"GraphNode is already parented\");\n\n\t\tthis._children.splice(index, 0, node);\n\n\t\tthis._onInsertChild(node);\n\t}\n\n\t_fireOnHierarchy(name, nameHierarchy, parent) {\n\t\tthis.fire(name, parent);\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tthis._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);\n\t\t}\n\t}\n\n\t_onInsertChild(node) {\n\t\tnode._parent = this;\n\t\tconst enabledInHierarchy = node._enabled && this.enabled;\n\n\t\tif (node._enabledInHierarchy !== enabledInHierarchy) {\n\t\t\tnode._enabledInHierarchy = enabledInHierarchy;\n\n\t\t\tnode._notifyHierarchyStateChanged(node, enabledInHierarchy);\n\t\t}\n\n\t\tnode._updateGraphDepth();\n\n\t\tnode._dirtifyWorld();\n\n\t\tif (this._frozen) node._unfreezeParentToRoot();\n\n\t\tnode._fireOnHierarchy('insert', 'inserthierarchy', this);\n\n\t\tif (this.fire) this.fire('childinsert', node);\n\t}\n\n\t_updateGraphDepth() {\n\t\tthis._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;\n\n\t\tfor (let i = 0, len = this._children.length; i < len; i++) {\n\t\t\tthis._children[i]._updateGraphDepth();\n\t\t}\n\t}\n\n\tremoveChild(child) {\n\t\tconst index = this._children.indexOf(child);\n\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._children.splice(index, 1);\n\n\t\tchild._parent = null;\n\n\t\tchild._fireOnHierarchy('remove', 'removehierarchy', this);\n\n\t\tthis.fire('childremove', child);\n\t}\n\n\t_sync() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\n\t\tif (this._dirtyWorld) {\n\t\t\tif (this._parent === null) {\n\t\t\t\tthis.worldTransform.copy(this.localTransform);\n\t\t\t} else {\n\t\t\t\tif (this.scaleCompensation) {\n\t\t\t\t\tlet parentWorldScale;\n\t\t\t\t\tconst parent = this._parent;\n\t\t\t\t\tlet scale = this.localScale;\n\t\t\t\t\tlet parentToUseScaleFrom = parent;\n\n\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\twhile (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {\n\t\t\t\t\t\t\tparentToUseScaleFrom = parentToUseScaleFrom._parent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\t\tparentToUseScaleFrom = parentToUseScaleFrom._parent;\n\n\t\t\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\t\t\tparentWorldScale = parentToUseScaleFrom.worldTransform.getScale();\n\t\t\t\t\t\t\t\tscaleCompensateScale.mul2(parentWorldScale, this.localScale);\n\t\t\t\t\t\t\t\tscale = scaleCompensateScale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tscaleCompensateRot2.setFromMat4(parent.worldTransform);\n\t\t\t\t\tscaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);\n\t\t\t\t\tlet tmatrix = parent.worldTransform;\n\n\t\t\t\t\tif (parent.scaleCompensation) {\n\t\t\t\t\t\tscaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());\n\t\t\t\t\t\tscaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);\n\t\t\t\t\t\ttmatrix = scaleCompensatePosTransform;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmatrix.transformPoint(this.localPosition, scaleCompensatePos);\n\t\t\t\t\tthis.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);\n\t\t\t\t} else {\n\t\t\t\t\tthis.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirtyWorld = false;\n\t\t}\n\t}\n\n\tsyncHierarchy() {\n\t\tif (!this._enabled) return;\n\t\tif (this._frozen) return;\n\t\tthis._frozen = true;\n\n\t\tif (this._dirtyLocal || this._dirtyWorld) {\n\t\t\tthis._sync();\n\t\t}\n\n\t\tconst children = this._children;\n\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tchildren[i].syncHierarchy();\n\t\t}\n\t}\n\n\tlookAt(x, y, z, ux = 0, uy = 1, uz = 0) {\n\t\tif (x instanceof Vec3) {\n\t\t\ttarget.copy(x);\n\n\t\t\tif (y instanceof Vec3) {\n\t\t\t\tup.copy(y);\n\t\t\t} else {\n\t\t\t\tup.copy(Vec3.UP);\n\t\t\t}\n\t\t} else if (z === undefined) {\n\t\t\treturn;\n\t\t} else {\n\t\t\ttarget.set(x, y, z);\n\t\t\tup.set(ux, uy, uz);\n\t\t}\n\n\t\tmatrix.setLookAt(this.getPosition(), target, up);\n\t\trotation.setFromMat4(matrix);\n\t\tthis.setRotation(rotation);\n\t}\n\n\ttranslate(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition$1.copy(x);\n\t\t} else {\n\t\t\tposition$1.set(x, y, z);\n\t\t}\n\n\t\tposition$1.add(this.getPosition());\n\t\tthis.setPosition(position$1);\n\t}\n\n\ttranslateLocal(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition$1.copy(x);\n\t\t} else {\n\t\t\tposition$1.set(x, y, z);\n\t\t}\n\n\t\tthis.localRotation.transformVector(position$1, position$1);\n\t\tthis.localPosition.add(position$1);\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\trotate(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\trotation.setFromEulerAngles(x.x, x.y, x.z);\n\t\t} else {\n\t\t\trotation.setFromEulerAngles(x, y, z);\n\t\t}\n\n\t\tif (this._parent === null) {\n\t\t\tthis.localRotation.mul2(rotation, this.localRotation);\n\t\t} else {\n\t\t\tconst rot = this.getRotation();\n\n\t\t\tconst parentRot = this._parent.getRotation();\n\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\trotation.mul2(invParentRot, rotation);\n\t\t\tthis.localRotation.mul2(rotation, rot);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\trotateLocal(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\trotation.setFromEulerAngles(x.x, x.y, x.z);\n\t\t} else {\n\t\t\trotation.setFromEulerAngles(x, y, z);\n\t\t}\n\n\t\tthis.localRotation.mul(rotation);\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n}\n\nconst _viewMat = new Mat4();\n\nconst _viewProjMat = new Mat4();\n\nconst _viewportMatrix = new Mat4();\n\nclass LightCamera {\n\tstatic create(name, lightType, face) {\n\t\tconst camera = new Camera();\n\t\tcamera.node = new GraphNode(name);\n\t\tcamera.aspectRatio = 1;\n\t\tcamera.aspectRatioMode = ASPECT_MANUAL;\n\t\tcamera._scissorRectClear = true;\n\n\t\tswitch (lightType) {\n\t\t\tcase LIGHTTYPE_OMNI:\n\t\t\t\tcamera.node.setRotation(LightCamera.pointLightRotations[face]);\n\t\t\t\tcamera.fov = 90;\n\t\t\t\tcamera.projection = PROJECTION_PERSPECTIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase LIGHTTYPE_SPOT:\n\t\t\t\tcamera.projection = PROJECTION_PERSPECTIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase LIGHTTYPE_DIRECTIONAL:\n\t\t\t\tcamera.projection = PROJECTION_ORTHOGRAPHIC;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn camera;\n\t}\n\n\tstatic evalSpotCookieMatrix(light) {\n\t\tlet cookieCamera = LightCamera._spotCookieCamera;\n\n\t\tif (!cookieCamera) {\n\t\t\tcookieCamera = LightCamera.create(\"SpotCookieCamera\", LIGHTTYPE_SPOT);\n\t\t\tLightCamera._spotCookieCamera = cookieCamera;\n\t\t}\n\n\t\tcookieCamera.fov = light._outerConeAngle * 2;\n\t\tconst cookieNode = cookieCamera._node;\n\t\tcookieNode.setPosition(light._node.getPosition());\n\t\tcookieNode.setRotation(light._node.getRotation());\n\t\tcookieNode.rotateLocal(-90, 0, 0);\n\n\t\t_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();\n\n\t\t_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);\n\n\t\tconst cookieMatrix = light.cookieMatrix;\n\t\tconst rectViewport = light.atlasViewport;\n\n\t\t_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);\n\n\t\tcookieMatrix.mul2(_viewportMatrix, _viewProjMat);\n\t\treturn cookieMatrix;\n\t}\n\n}\n\nLightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];\nLightCamera._spotCookieCamera = null;\n\nconst epsilon$1 = 0.000001;\nconst tempVec3$1 = new Vec3();\nconst tempAreaLightSizes = new Float32Array(6);\nconst areaHalfAxisWidth = new Vec3(-0.5, 0, 0);\nconst areaHalfAxisHeight = new Vec3(0, 0, 0.5);\nconst TextureIndex8 = {\n\tFLAGS: 0,\n\tCOLOR_A: 1,\n\tCOLOR_B: 2,\n\tSPOT_ANGLES: 3,\n\tSHADOW_BIAS: 4,\n\tCOOKIE_A: 5,\n\tCOOKIE_B: 6,\n\tCOUNT_ALWAYS: 7,\n\tPOSITION_X: 7,\n\tPOSITION_Y: 8,\n\tPOSITION_Z: 9,\n\tRANGE: 10,\n\tSPOT_DIRECTION_X: 11,\n\tSPOT_DIRECTION_Y: 12,\n\tSPOT_DIRECTION_Z: 13,\n\tPROJ_MAT_00: 14,\n\tATLAS_VIEWPORT_A: 14,\n\tPROJ_MAT_01: 15,\n\tATLAS_VIEWPORT_B: 15,\n\tPROJ_MAT_02: 16,\n\tPROJ_MAT_03: 17,\n\tPROJ_MAT_10: 18,\n\tPROJ_MAT_11: 19,\n\tPROJ_MAT_12: 20,\n\tPROJ_MAT_13: 21,\n\tPROJ_MAT_20: 22,\n\tPROJ_MAT_21: 23,\n\tPROJ_MAT_22: 24,\n\tPROJ_MAT_23: 25,\n\tPROJ_MAT_30: 26,\n\tPROJ_MAT_31: 27,\n\tPROJ_MAT_32: 28,\n\tPROJ_MAT_33: 29,\n\tAREA_DATA_WIDTH_X: 30,\n\tAREA_DATA_WIDTH_Y: 31,\n\tAREA_DATA_WIDTH_Z: 32,\n\tAREA_DATA_HEIGHT_X: 33,\n\tAREA_DATA_HEIGHT_Y: 34,\n\tAREA_DATA_HEIGHT_Z: 35,\n\tCOUNT: 36\n};\nconst TextureIndexFloat = {\n\tPOSITION_RANGE: 0,\n\tSPOT_DIRECTION: 1,\n\tPROJ_MAT_0: 2,\n\tATLAS_VIEWPORT: 2,\n\tPROJ_MAT_1: 3,\n\tPROJ_MAT_2: 4,\n\tPROJ_MAT_3: 5,\n\tAREA_DATA_WIDTH: 6,\n\tAREA_DATA_HEIGHT: 7,\n\tCOUNT: 8\n};\n\nclass LightsBuffer {\n\tstatic initShaderDefines() {\n\t\tconst clusterTextureFormat = LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT ? \"FLOAT\" : \"8BIT\";\n\t\tLightsBuffer.shaderDefines = `\n\t\t\t\t\t\t\\n#define CLUSTER_TEXTURE_${clusterTextureFormat}\n\t\t\t\t\t\t${LightsBuffer.buildShaderDefines(TextureIndex8, \"CLUSTER_TEXTURE_8_\")}\n\t\t\t\t\t\t${LightsBuffer.buildShaderDefines(TextureIndexFloat, \"CLUSTER_TEXTURE_F_\")}\n\t\t\t\t`;\n\t}\n\n\tstatic buildShaderDefines(object, prefix) {\n\t\tlet str = \"\";\n\t\tObject.keys(object).forEach(key => {\n\t\t\tstr += `\\n#define ${prefix}${key} ${object[key]}.5`;\n\t\t});\n\t\treturn str;\n\t}\n\n\tstatic init(device) {\n\t\tLightsBuffer.lightTextureFormat = device.extTextureFloat && device.maxTextures > 8 ? LightsBuffer.FORMAT_FLOAT : LightsBuffer.FORMAT_8BIT;\n\t\tLightsBuffer.initShaderDefines();\n\t}\n\n\tstatic createTexture(device, width, height, format, name) {\n\t\tconst tex = new Texture(device, {\n\t\t\tname: name,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmipmaps: false,\n\t\t\tformat: format,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tanisotropy: 1\n\t\t});\n\t\treturn tex;\n\t}\n\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.cookiesEnabled = false;\n\t\tthis.shadowsEnabled = false;\n\t\tthis.areaLightsEnabled = false;\n\t\tthis.maxLights = 255;\n\t\tlet pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;\n\t\tlet pixelsPerLightFloat = 0;\n\n\t\tif (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n\t\t\tpixelsPerLightFloat = TextureIndexFloat.COUNT;\n\t\t} else {\n\t\t\tpixelsPerLight8 = TextureIndex8.COUNT;\n\t\t}\n\n\t\tthis.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);\n\t\tthis.lightsTexture8 = LightsBuffer.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_R8_G8_B8_A8, \"LightsTexture8\");\n\t\tthis._lightsTexture8Id = this.device.scope.resolve(\"lightsTexture8\");\n\n\t\tif (pixelsPerLightFloat) {\n\t\t\tthis.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);\n\t\t\tthis.lightsTextureFloat = LightsBuffer.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, \"LightsTextureFloat\");\n\t\t\tthis._lightsTextureFloatId = this.device.scope.resolve(\"lightsTextureFloat\");\n\t\t} else {\n\t\t\tthis.lightsFloat = null;\n\t\t\tthis.lightsTextureFloat = null;\n\t\t\tthis._lightsTextureFloatId = undefined;\n\t\t}\n\n\t\tthis._lightsTextureInvSizeId = this.device.scope.resolve(\"lightsTextureInvSize\");\n\t\tthis._lightsTextureInvSizeData = new Float32Array(4);\n\t\tthis._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;\n\t\tthis._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;\n\t\tthis._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;\n\t\tthis._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;\n\t\tthis.invMaxColorValue = 0;\n\t\tthis.invMaxAttenuation = 0;\n\t\tthis.boundsMin = new Vec3();\n\t\tthis.boundsDelta = new Vec3();\n\t}\n\n\tdestroy() {\n\t\tif (this.lightsTexture8) {\n\t\t\tthis.lightsTexture8.destroy();\n\t\t\tthis.lightsTexture8 = null;\n\t\t}\n\n\t\tif (this.lightsTextureFloat) {\n\t\t\tthis.lightsTextureFloat.destroy();\n\t\t\tthis.lightsTextureFloat = null;\n\t\t}\n\t}\n\n\tsetCompressionRanges(maxAttenuation, maxColorValue) {\n\t\tthis.invMaxColorValue = 1 / maxColorValue;\n\t\tthis.invMaxAttenuation = 1 / maxAttenuation;\n\t}\n\n\tsetBounds(min, delta) {\n\t\tthis.boundsMin.copy(min);\n\t\tthis.boundsDelta.copy(delta);\n\t}\n\n\tuploadTextures() {\n\t\tif (this.lightsTextureFloat) {\n\t\t\tthis.lightsTextureFloat.lock().set(this.lightsFloat);\n\t\t\tthis.lightsTextureFloat.unlock();\n\t\t}\n\n\t\tthis.lightsTexture8.lock().set(this.lights8);\n\t\tthis.lightsTexture8.unlock();\n\t}\n\n\tupdateUniforms() {\n\t\tthis._lightsTexture8Id.setValue(this.lightsTexture8);\n\n\t\tif (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n\t\t\tthis._lightsTextureFloatId.setValue(this.lightsTextureFloat);\n\t\t}\n\n\t\tthis._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);\n\t}\n\n\tgetSpotDirection(direction, spot) {\n\t\tconst mat = spot._node.getWorldTransform();\n\n\t\tmat.getY(direction).mulScalar(-1);\n\t\tdirection.normalize();\n\t}\n\n\tgetLightAreaSizes(light) {\n\t\tconst mat = light._node.getWorldTransform();\n\n\t\tmat.transformVector(areaHalfAxisWidth, tempVec3$1);\n\t\ttempAreaLightSizes[0] = tempVec3$1.x;\n\t\ttempAreaLightSizes[1] = tempVec3$1.y;\n\t\ttempAreaLightSizes[2] = tempVec3$1.z;\n\t\tmat.transformVector(areaHalfAxisHeight, tempVec3$1);\n\t\ttempAreaLightSizes[3] = tempVec3$1.x;\n\t\ttempAreaLightSizes[4] = tempVec3$1.y;\n\t\ttempAreaLightSizes[5] = tempVec3$1.z;\n\t\treturn tempAreaLightSizes;\n\t}\n\n\taddLightDataFlags(data8, index, light, isSpot, castShadows) {\n\t\tdata8[index + 0] = isSpot ? 255 : 0;\n\t\tdata8[index + 1] = light._shape * 64;\n\t\tdata8[index + 2] = light._falloffMode * 255;\n\t\tdata8[index + 3] = castShadows ? 255 : 0;\n\t}\n\n\taddLightDataColor(data8, index, light, gammaCorrection, isCookie) {\n\t\tconst invMaxColorValue = this.invMaxColorValue;\n\t\tconst color = gammaCorrection ? light._linearFinalColor : light._finalColor;\n\t\tFloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);\n\t\tFloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);\n\t\tdata8[index + 6] = isCookie ? 255 : 0;\n\t\tconst isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);\n\t\tconst isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);\n\t\tdata8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;\n\t}\n\n\taddLightDataSpotAngles(data8, index, light) {\n\t\tFloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 2, 2);\n\t}\n\n\taddLightDataShadowBias(data8, index, light) {\n\t\tconst lightRenderData = light.getRenderData(null, 0);\n\n\t\tconst biases = light._getUniformBiasValues(lightRenderData);\n\n\t\tFloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);\n\t\tFloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);\n\t}\n\n\taddLightDataPositionRange(data8, index, light, pos) {\n\t\tconst normPos = tempVec3$1.sub2(pos, this.boundsMin).div(this.boundsDelta);\n\t\tFloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);\n\t\tFloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);\n\t\tFloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);\n\t\tFloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);\n\t}\n\n\taddLightDataSpotDirection(data8, index, light) {\n\t\tthis.getSpotDirection(tempVec3$1, light);\n\t\tFloatPacking.float2Bytes(tempVec3$1.x * (0.5 - epsilon$1) + 0.5, data8, index + 0, 4);\n\t\tFloatPacking.float2Bytes(tempVec3$1.y * (0.5 - epsilon$1) + 0.5, data8, index + 4, 4);\n\t\tFloatPacking.float2Bytes(tempVec3$1.z * (0.5 - epsilon$1) + 0.5, data8, index + 8, 4);\n\t}\n\n\taddLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {\n\t\tconst matData = lightProjectionMatrix.data;\n\n\t\tfor (let m = 0; m < 12; m++) FloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);\n\n\t\tfor (let m = 12; m < 16; m++) {\n\t\t\tFloatPacking.float2MantissaExponent(matData[m], data8, index + 4 * m, 4);\n\t\t}\n\t}\n\n\taddLightDataCookies(data8, index, light) {\n\t\tconst isRgb = light._cookieChannel === \"rgb\";\n\t\tdata8[index + 0] = Math.floor(light.cookieIntensity * 255);\n\t\tdata8[index + 1] = isRgb ? 255 : 0;\n\n\t\tif (!isRgb) {\n\t\t\tconst channel = light._cookieChannel;\n\t\t\tdata8[index + 4] = channel === \"rrr\" ? 255 : 0;\n\t\t\tdata8[index + 5] = channel === \"ggg\" ? 255 : 0;\n\t\t\tdata8[index + 6] = channel === \"bbb\" ? 255 : 0;\n\t\t\tdata8[index + 7] = channel === \"aaa\" ? 255 : 0;\n\t\t}\n\t}\n\n\taddLightAtlasViewport(data8, index, atlasViewport) {\n\t\tFloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);\n\t\tFloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);\n\t}\n\n\taddLightAreaSizes(data8, index, light) {\n\t\tconst areaSizes = this.getLightAreaSizes(light);\n\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tFloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);\n\t\t}\n\t}\n\n\taddLightData(light, lightIndex, gammaCorrection) {\n\t\tconst isSpot = light._type === LIGHTTYPE_SPOT;\n\t\tconst hasAtlasViewport = light.atlasViewportAllocated;\n\t\tconst isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;\n\t\tconst isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;\n\t\tconst castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;\n\n\t\tconst pos = light._node.getPosition();\n\n\t\tlet lightProjectionMatrix = null;\n\t\tlet atlasViewport = null;\n\n\t\tif (isSpot) {\n\t\t\tif (castShadows) {\n\t\t\t\tconst lightRenderData = light.getRenderData(null, 0);\n\t\t\t\tlightProjectionMatrix = lightRenderData.shadowMatrix;\n\t\t\t} else if (isCookie) {\n\t\t\t\tlightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);\n\t\t\t}\n\t\t} else {\n\t\t\tif (castShadows || isCookie) {\n\t\t\t\tatlasViewport = light.atlasViewport;\n\t\t\t}\n\t\t}\n\n\t\tconst data8 = this.lights8;\n\t\tconst data8Start = lightIndex * this.lightsTexture8.width * 4;\n\t\tthis.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows);\n\t\tthis.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);\n\n\t\tif (isSpot) {\n\t\t\tthis.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);\n\t\t}\n\n\t\tif (light.castShadows) {\n\t\t\tthis.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);\n\t\t}\n\n\t\tif (isCookie) {\n\t\t\tthis.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);\n\t\t}\n\n\t\tif (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n\t\t\tconst dataFloat = this.lightsFloat;\n\t\t\tconst dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;\n\n\t\t\tif (isSpot) {\n\t\t\t\tthis.getSpotDirection(tempVec3$1, light);\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3$1.x;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3$1.y;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3$1.z;\n\t\t\t}\n\n\t\t\tif (lightProjectionMatrix) {\n\t\t\t\tconst matData = lightProjectionMatrix.data;\n\n\t\t\t\tfor (let m = 0; m < 16; m++) dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];\n\t\t\t}\n\n\t\t\tif (atlasViewport) {\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;\n\t\t\t}\n\n\t\t\tif (isArea) {\n\t\t\t\tconst areaSizes = this.getLightAreaSizes(light);\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];\n\t\t\t}\n\t\t} else {\n\t\t\tthis.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);\n\n\t\t\tif (isSpot) {\n\t\t\t\tthis.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);\n\t\t\t}\n\n\t\t\tif (lightProjectionMatrix) {\n\t\t\t\tthis.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);\n\t\t\t}\n\n\t\t\tif (atlasViewport) {\n\t\t\t\tthis.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);\n\t\t\t}\n\n\t\t\tif (isArea) {\n\t\t\t\tthis.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nLightsBuffer.FORMAT_FLOAT = 0;\nLightsBuffer.FORMAT_8BIT = 1;\nLightsBuffer.lightTextureFormat = LightsBuffer.FORMAT_8BIT;\nLightsBuffer.shaderDefines = \"\";\n\nconst _matTex2D = [];\nconst decodeTable = {\n\t'rgbm': 'decodeRGBM',\n\t'rgbe': 'decodeRGBE',\n\t'linear': 'decodeLinear'\n};\nconst standard = {\n\toptionsContext: {},\n\toptionsContextMin: {},\n\tgenerateKey: function (options) {\n\t\tconst buildPropertiesList = function buildPropertiesList(options) {\n\t\t\tconst props = [];\n\n\t\t\tfor (const prop in options) {\n\t\t\t\tif (options.hasOwnProperty(prop) && prop !== \"chunks\" && prop !== \"lights\") props.push(prop);\n\t\t\t}\n\n\t\t\treturn props.sort();\n\t\t};\n\n\t\tlet props;\n\n\t\tif (options === this.optionsContextMin) {\n\t\t\tif (!this.propsMin) this.propsMin = buildPropertiesList(options);\n\t\t\tprops = this.propsMin;\n\t\t} else if (options === this.optionsContext) {\n\t\t\tif (!this.props) this.props = buildPropertiesList(options);\n\t\t\tprops = this.props;\n\t\t} else {\n\t\t\tprops = buildPropertiesList(options);\n\t\t}\n\n\t\tlet key = \"standard\";\n\n\t\tfor (let i = 0; i < props.length; i++) {\n\t\t\tif (options[props[i]]) key += props[i] + options[props[i]];\n\t\t}\n\n\t\tif (options.chunks) {\n\t\t\tconst chunks = [];\n\n\t\t\tfor (const p in options.chunks) {\n\t\t\t\tif (options.chunks.hasOwnProperty(p)) {\n\t\t\t\t\tchunks.push(p + options.chunks[p]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunks.sort();\n\t\t\tkey += chunks;\n\t\t}\n\n\t\tif (options.lights) {\n\t\t\tconst isClustered = options.clusteredLightingEnabled;\n\n\t\t\tfor (let i = 0; i < options.lights.length; i++) {\n\t\t\t\tconst light = options.lights[i];\n\n\t\t\t\tif (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tkey += light.key;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn hashCode(key);\n\t},\n\t_correctChannel: function (p, chan) {\n\t\tif (_matTex2D[p] > 0) {\n\t\t\tif (_matTex2D[p] < chan.length) {\n\t\t\t\treturn chan.substring(0, _matTex2D[p]);\n\t\t\t} else if (_matTex2D[p] > chan.length) {\n\t\t\t\tlet str = chan;\n\t\t\t\tconst chr = str.charAt(str.length - 1);\n\t\t\t\tconst addLen = _matTex2D[p] - str.length;\n\n\t\t\t\tfor (let i = 0; i < addLen; i++) str += chr;\n\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t\treturn chan;\n\t\t}\n\t},\n\t_setMapTransform: function (codes, name, id, uv) {\n\t\tconst varName = `texture_${name}MapTransform`;\n\t\tconst checkId = id + uv * 100;\n\t\tcodes[0] += `uniform vec3 ${varName}0;\\n`;\n\t\tcodes[0] += `uniform vec3 ${varName}1;\\n`;\n\n\t\tif (!codes[3][checkId]) {\n\t\t\tcodes[1] += `varying vec2 vUV${uv}_${id};\\n`;\n\t\t\tcodes[2] += `\t vUV${uv}_${id} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));\\n`;\n\t\t\tcodes[3][checkId] = true;\n\t\t}\n\n\t\treturn codes;\n\t},\n\t_getUvSourceExpression: function (transformPropName, uVPropName, options) {\n\t\tconst transformId = options[transformPropName];\n\t\tconst uvChannel = options[uVPropName];\n\t\tconst isMainPass = options.pass === SHADER_FORWARD || options.pass === SHADER_FORWARDHDR;\n\t\tlet expression;\n\n\t\tif (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\texpression = \"nineSlicedUv\";\n\t\t} else if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\texpression = \"nineSlicedUv, -1000.0\";\n\t\t} else {\n\t\t\tif (transformId === 0) {\n\t\t\t\texpression = \"vUv\" + uvChannel;\n\t\t\t} else {\n\t\t\t\texpression = \"vUV\" + uvChannel + \"_\" + transformId;\n\t\t\t}\n\n\t\t\tif (options.heightMap && transformPropName !== \"heightMapTransform\") {\n\t\t\t\texpression += \" + dUvOffset\";\n\t\t\t}\n\t\t}\n\n\t\treturn expression;\n\t},\n\t_addMapDef: function (name, enabled) {\n\t\tlet s = \"\\n#undef \" + name + \"\\n\";\n\t\tif (enabled) s += \" #define \" + name + \"\\n\";\n\t\treturn s;\n\t},\n\t_addMapDefs: function (float, color, vertex, map) {\n\t\tlet s = \"\";\n\t\ts += this._addMapDef(\"MAPFLOAT\", float);\n\t\ts += this._addMapDef(\"MAPCOLOR\", color);\n\t\ts += this._addMapDef(\"MAPVERTEX\", vertex);\n\t\ts += this._addMapDef(\"MAPTEXTURE\", map);\n\t\treturn s;\n\t},\n\t_addMap: function (propName, chunkName, options, chunks, samplerFormat) {\n\t\tconst mapPropName = propName + \"Map\";\n\t\tconst uVPropName = mapPropName + \"Uv\";\n\t\tconst transformPropName = mapPropName + \"Transform\";\n\t\tconst channelPropName = mapPropName + \"Channel\";\n\t\tconst vertexColorChannelPropName = propName + \"VertexColorChannel\";\n\t\tconst tintPropName = propName + \"Tint\";\n\t\tconst vertexColorPropName = propName + \"VertexColor\";\n\t\tconst detailModePropName = propName + \"Mode\";\n\t\tconst tintOption = options[tintPropName];\n\t\tconst vertexColorOption = options[vertexColorPropName];\n\t\tconst textureOption = options[mapPropName];\n\t\tconst detailModeOption = options[detailModePropName];\n\t\tlet subCode = chunks[chunkName];\n\n\t\tif (textureOption) {\n\t\t\tconst uv = this._getUvSourceExpression(transformPropName, uVPropName, options);\n\n\t\t\tsubCode = subCode.replace(/\\$UV/g, uv).replace(/\\$CH/g, options[channelPropName]);\n\n\t\t\tif (samplerFormat !== undefined) {\n\t\t\t\tconst fmt = samplerFormat === 0 ? \"texture2DSRGB\" : samplerFormat === 1 ? \"texture2DRGBM\" : \"texture2D\";\n\t\t\t\tsubCode = subCode.replace(/\\$texture2DSAMPLE/g, fmt);\n\t\t\t}\n\t\t}\n\n\t\tif (vertexColorOption) {\n\t\t\tsubCode = subCode.replace(/\\$VC/g, options[vertexColorChannelPropName]);\n\t\t}\n\n\t\tif (detailModeOption) {\n\t\t\tsubCode = subCode.replace(/\\$DETAILMODE/g, detailModeOption);\n\t\t}\n\n\t\tconst isFloatTint = !!(tintOption & 1);\n\t\tconst isVecTint = !!(tintOption & 2);\n\t\tsubCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;\n\t\treturn subCode.replace(/\\$/g, \"\");\n\t},\n\t_directionalShadowMapProjection: function (light, shadowCoordArgs, shadowParamArg, lightIndex, coordsFunctioName) {\n\t\tlet code = \"\";\n\n\t\tif (light.numCascades > 1) {\n\t\t\tcode += `getShadowCascadeMatrix(light${lightIndex}_shadowMatrixPalette, light${lightIndex}_shadowCascadeDistances, light${lightIndex}_shadowCascadeCount);\\n`;\n\t\t\tshadowCoordArgs = `(cascadeShadowMat, ${shadowParamArg});\\n`;\n\t\t}\n\n\t\tcode += coordsFunctioName + shadowCoordArgs;\n\t\tcode += `fadeShadow(light${lightIndex}_shadowCascadeDistances);\\n`;\n\t\treturn code;\n\t},\n\t_nonPointShadowMapProjection: function (device, light, shadowMatArg, shadowParamArg, lightIndex) {\n\t\tconst shadowCoordArgs = `(${shadowMatArg}, ${shadowParamArg});\\n`;\n\n\t\tif (!light._normalOffsetBias || light._isVsm) {\n\t\t\tif (light._type === LIGHTTYPE_SPOT) {\n\t\t\t\tif (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {\n\t\t\t\t\treturn \"\t\t\t getShadowCoordPerspZbuffer\" + shadowCoordArgs;\n\t\t\t\t}\n\n\t\t\t\treturn \"\t\t\t getShadowCoordPersp\" + shadowCoordArgs;\n\t\t\t}\n\n\t\t\treturn this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, \"getShadowCoordOrtho\");\n\t\t}\n\n\t\tif (light._type === LIGHTTYPE_SPOT) {\n\t\t\tif (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {\n\t\t\t\treturn \"\t\t\t getShadowCoordPerspZbufferNormalOffset\" + shadowCoordArgs;\n\t\t\t}\n\n\t\t\treturn \"\t\t\t getShadowCoordPerspNormalOffset\" + shadowCoordArgs;\n\t\t}\n\n\t\treturn this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, \"getShadowCoordOrthoNormalOffset\");\n\t},\n\t_addVaryingIfNeeded: function (code, type, name) {\n\t\treturn code.indexOf(name) >= 0 ? \"varying \" + type + \" \" + name + \";\\n\" : \"\";\n\t},\n\t_getLightSourceShapeString: function (shape) {\n\t\tswitch (shape) {\n\t\t\tcase LIGHTSHAPE_RECT:\n\t\t\t\treturn 'Rect';\n\n\t\t\tcase LIGHTSHAPE_DISK:\n\t\t\t\treturn 'Disk';\n\n\t\t\tcase LIGHTSHAPE_SPHERE:\n\t\t\t\treturn 'Sphere';\n\n\t\t\tdefault:\n\t\t\t\treturn '';\n\t\t}\n\t},\n\t_getPassDefineString: function (pass) {\n\t\tif (pass === SHADER_PICK) {\n\t\t\treturn '#define PICK_PASS\\n';\n\t\t} else if (pass === SHADER_DEPTH) {\n\t\t\treturn '#define DEPTH_PASS\\n';\n\t\t} else if (pass >= SHADER_SHADOW && pass <= 17) {\n\t\t\treturn '#define SHADOW_PASS\\n';\n\t\t}\n\n\t\treturn '';\n\t},\n\t_vsAddTransformCode: function (code, device, chunks, options) {\n\t\tcode += chunks.transformVS;\n\t\treturn code;\n\t},\n\t_vsAddBaseCode: function (code, device, chunks, options) {\n\t\tcode += chunks.baseVS;\n\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tcode += chunks.baseNineSlicedVS;\n\t\t}\n\n\t\treturn code;\n\t},\n\t_fsAddBaseCode: function (code, device, chunks, options) {\n\t\tcode += chunks.basePS;\n\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tcode += chunks.baseNineSlicedPS;\n\t\t} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tcode += chunks.baseNineSlicedTiledPS;\n\t\t}\n\n\t\treturn code;\n\t},\n\t_decodeFunc: function (textureFormat) {\n\t\treturn decodeTable[textureFormat] || 'decodeGamma';\n\t},\n\t_fsAddStartCode: function (code, device, chunks, options) {\n\t\tcode += chunks.startPS;\n\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tcode += chunks.startNineSlicedPS;\n\t\t} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tcode += chunks.startNineSlicedTiledPS;\n\t\t}\n\n\t\treturn code;\n\t},\n\t_buildShadowPassFragmentCode: function (code, device, chunks, options, varyings) {\n\t\tconst smode = options.pass - SHADER_SHADOW;\n\t\tconst numShadowModes = SHADOW_COUNT;\n\t\tconst lightType = Math.floor(smode / numShadowModes);\n\t\tconst shadowType = smode - lightType * numShadowModes;\n\n\t\tif (device.extStandardDerivatives && !device.webgl2) {\n\t\t\tcode += 'uniform vec2 polygonOffset;\\n';\n\t\t}\n\n\t\tif (shadowType === SHADOW_VSM32) {\n\t\t\tif (device.textureFloatHighPrecision) {\n\t\t\t\tcode += '#define VSM_EXPONENT 15.0\\n\\n';\n\t\t\t} else {\n\t\t\t\tcode += '#define VSM_EXPONENT 5.54\\n\\n';\n\t\t\t}\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\tcode += '#define VSM_EXPONENT 5.54\\n\\n';\n\t\t}\n\n\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tcode += 'uniform vec3 view_position;\\n';\n\t\t\tcode += 'uniform float light_radius;\\n';\n\t\t}\n\n\t\tcode += varyings;\n\n\t\tif (options.alphaTest) {\n\t\t\tcode += \"float dAlpha;\\n\";\n\t\t\tcode += this._addMap(\"opacity\", \"opacityPS\", options, chunks);\n\t\t\tcode += chunks.alphaTestPS;\n\t\t}\n\n\t\tif (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI)) {\n\t\t\tcode += chunks.packDepthPS;\n\t\t} else if (shadowType === SHADOW_VSM8) {\n\t\t\tcode += \"vec2 encodeFloatRG( float v ) {\\n\";\n\t\t\tcode += \"\t\tvec2 enc = vec2(1.0, 255.0) * v;\\n\";\n\t\t\tcode += \"\t\tenc = fract(enc);\\n\";\n\t\t\tcode += \"\t\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\\n\";\n\t\t\tcode += \"\t\treturn enc;\\n\";\n\t\t\tcode += \"}\\n\\n\";\n\t\t}\n\n\t\tcode += begin();\n\n\t\tif (options.alphaTest) {\n\t\t\tcode += \"\t getOpacity();\\n\";\n\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t}\n\n\t\tconst isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;\n\n\t\tif (lightType === LIGHTTYPE_OMNI || isVsm && lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tcode += \"\t float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\\n\";\n\t\t} else {\n\t\t\tcode += \"\t float depth = gl_FragCoord.z;\\n\";\n\t\t}\n\n\t\tif (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI && !options.clusteredLightingEnabled)) {\n\t\t\tif (device.extStandardDerivatives && !device.webgl2) {\n\t\t\t\tcode += \"\t float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\\n\";\n\t\t\t\tcode += \"\t depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\\n\";\n\t\t\t\tcode += \"\t gl_FragColor = packFloat(depth);\\n\";\n\t\t\t} else {\n\t\t\t\tcode += \"\t gl_FragColor = packFloat(depth);\\n\";\n\t\t\t}\n\t\t} else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {\n\t\t\tcode += \"\t gl_FragColor = vec4(1.0);\\n\";\n\n\t\t\tif (options.clusteredLightingEnabled && lightType === LIGHTTYPE_OMNI && device.webgl2) {\n\t\t\t\tcode += \"\t gl_FragDepth = depth;\\n\";\n\t\t\t}\n\t\t} else if (shadowType === SHADOW_VSM8) {\n\t\t\tcode += \"\t gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\\n\";\n\t\t} else {\n\t\t\tcode += chunks.storeEVSMPS;\n\t\t}\n\n\t\tcode += end();\n\t\treturn code;\n\t},\n\tcreateShaderDefinition: function (device, options) {\n\t\tlet lighting = options.lights.length > 0;\n\n\t\tif (options.dirLightMap) {\n\t\t\tlighting = true;\n\t\t}\n\n\t\tif (options.clusteredLightingEnabled) {\n\t\t\tlighting = true;\n\t\t}\n\n\t\tif (options.shadingModel === SPECULAR_PHONG) {\n\t\t\toptions.fresnelModel = 0;\n\t\t\toptions.specularAntialias = false;\n\t\t\toptions.ambientSH = false;\n\t\t} else {\n\t\t\toptions.fresnelModel = options.fresnelModel === 0 ? FRESNEL_SCHLICK : options.fresnelModel;\n\t\t}\n\n\t\tconst reflections = !!options.reflectionSource;\n\t\tif (!options.useSpecular) options.specularMap = options.glossMap = null;\n\t\tconst shadowPass = options.pass >= SHADER_SHADOW && options.pass <= 17;\n\t\tconst needsNormal = lighting || reflections || options.ambientSH || options.heightMap || options.enableGGXSpecular || options.clusteredLightingEnabled && !shadowPass || options.clearCoatNormalMap;\n\t\tthis.options = options;\n\t\tlet code = '';\n\t\tlet codeBody = '';\n\t\tlet varyings = \"\";\n\t\tlet chunks = shaderChunks;\n\t\tlet shadowCoordArgs;\n\t\tlet chunk;\n\t\tconst attributes = {\n\t\t\tvertex_position: SEMANTIC_POSITION\n\t\t};\n\n\t\tif (options.chunks) {\n\t\t\tconst customChunks = {};\n\n\t\t\tfor (const p in chunks) {\n\t\t\t\tif (chunks.hasOwnProperty(p)) {\n\t\t\t\t\tif (!options.chunks[p]) {\n\t\t\t\t\t\tcustomChunks[p] = chunks[p];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk = options.chunks[p];\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_normal\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_normal = SEMANTIC_NORMAL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_tangent\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_tangent = SEMANTIC_TANGENT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_texCoord0\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_texCoord1\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_texCoord1 = SEMANTIC_TEXCOORD1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_color\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_color = SEMANTIC_COLOR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_boneWeights\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_boneIndices\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcustomChunks[p] = chunk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunks = customChunks;\n\t\t}\n\n\t\tcode += this._getPassDefineString(options.pass);\n\t\tcode = this._vsAddBaseCode(code, device, chunks, options);\n\t\tcodeBody += \"\t vPositionW\t\t= getWorldPosition();\\n\";\n\n\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += '#ifndef VIEWMATRIX\\n';\n\t\t\tcode += '#define VIEWMATRIX\\n';\n\t\t\tcode += 'uniform mat4 matrix_view;\\n';\n\t\t\tcode += '#endif\\n';\n\t\t\tcode += '#ifndef CAMERAPLANES\\n';\n\t\t\tcode += '#define CAMERAPLANES\\n';\n\t\t\tcode += 'uniform vec4 camera_params;\\n\\n';\n\t\t\tcode += '#endif\\n';\n\t\t\tcodeBody += \"\t\tvDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\\n\";\n\t\t}\n\n\t\tif (options.useInstancing) {\n\t\t\tattributes.instance_line1 = SEMANTIC_ATTR12;\n\t\t\tattributes.instance_line2 = SEMANTIC_ATTR13;\n\t\t\tattributes.instance_line3 = SEMANTIC_ATTR14;\n\t\t\tattributes.instance_line4 = SEMANTIC_ATTR15;\n\t\t\tcode += chunks.instancingVS;\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tattributes.vertex_normal = SEMANTIC_NORMAL;\n\t\t\tcodeBody += \"\t vNormalW = getNormal();\\n\";\n\n\t\t\tif (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {\n\t\t\t\tcode += chunks.viewNormalVS;\n\t\t\t\tcodeBody += \"\t vNormalV\t\t= getViewNormal();\\n\";\n\t\t\t}\n\n\t\t\tif ((options.heightMap || options.normalMap || options.enableGGXSpecular) && options.hasTangents) {\n\t\t\t\tattributes.vertex_tangent = SEMANTIC_TANGENT;\n\t\t\t\tcode += chunks.tangentBinormalVS;\n\t\t\t\tcodeBody += \"\t vTangentW\t = getTangent();\\n\";\n\t\t\t\tcodeBody += \"\t vBinormalW\t= getBinormal();\\n\";\n\t\t\t} else if (options.enableGGXSpecular) {\n\t\t\t\tcode += chunks.tangentBinormalVS;\n\t\t\t\tcodeBody += \"\t vObjectSpaceUpW\t= getObjectSpaceUp();\\n\";\n\t\t\t}\n\t\t}\n\n\t\tconst useUv = [];\n\t\tconst useUnmodifiedUv = [];\n\t\tconst maxUvSets = 2;\n\n\t\tfor (const p in _matTex2D) {\n\t\t\tconst mname = p + \"Map\";\n\n\t\t\tif (options[p + \"VertexColor\"]) {\n\t\t\t\tconst cname = p + \"VertexColorChannel\";\n\t\t\t\toptions[cname] = this._correctChannel(p, options[cname]);\n\t\t\t}\n\n\t\t\tif (options[mname]) {\n\t\t\t\tconst cname = mname + \"Channel\";\n\t\t\t\tconst tname = mname + \"Transform\";\n\t\t\t\tconst uname = mname + \"Uv\";\n\t\t\t\toptions[uname] = Math.min(options[uname], maxUvSets - 1);\n\t\t\t\toptions[cname] = this._correctChannel(p, options[cname]);\n\t\t\t\tconst uvSet = options[uname];\n\t\t\t\tuseUv[uvSet] = true;\n\t\t\t\tuseUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];\n\t\t\t}\n\t\t}\n\n\t\tif (options.forceUv1) {\n\t\t\tuseUv[1] = true;\n\t\t\tuseUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;\n\t\t}\n\n\t\tfor (let i = 0; i < maxUvSets; i++) {\n\t\t\tif (useUv[i]) {\n\t\t\t\tattributes[\"vertex_texCoord\" + i] = \"TEXCOORD\" + i;\n\t\t\t\tcode += chunks[\"uv\" + i + \"VS\"];\n\t\t\t\tcodeBody += \"\t vec2 uv\" + i + \" = getUv\" + i + \"();\\n\";\n\t\t\t}\n\n\t\t\tif (useUnmodifiedUv[i]) {\n\t\t\t\tcodeBody += \"\t vUv\" + i + \" = uv\" + i + \";\\n\";\n\t\t\t}\n\t\t}\n\n\t\tconst codes = [code, varyings, codeBody, []];\n\n\t\tfor (const p in _matTex2D) {\n\t\t\tconst mname = p + \"Map\";\n\n\t\t\tif (options[mname]) {\n\t\t\t\tconst tname = mname + \"Transform\";\n\n\t\t\t\tif (options[tname]) {\n\t\t\t\t\tconst uname = mname + \"Uv\";\n\n\t\t\t\t\tthis._setMapTransform(codes, p, options[tname], options[uname]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcode = codes[0];\n\t\tvaryings = codes[1];\n\t\tcodeBody = codes[2];\n\n\t\tif (options.vertexColors) {\n\t\t\tattributes.vertex_color = SEMANTIC_COLOR;\n\t\t\tcodeBody += \"\t vVertexColor = vertex_color;\\n\";\n\t\t}\n\n\t\tif (options.useMorphPosition || options.useMorphNormal) {\n\t\t\tif (options.useMorphTextureBased) {\n\t\t\t\tcode += \"#define MORPHING_TEXTURE_BASED\\n\";\n\n\t\t\t\tif (options.useMorphPosition) {\n\t\t\t\t\tcode += \"#define MORPHING_TEXTURE_BASED_POSITION\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (options.useMorphNormal) {\n\t\t\t\t\tcode += \"#define MORPHING_TEXTURE_BASED_NORMAL\\n\";\n\t\t\t\t}\n\n\t\t\t\tattributes.morph_vertex_id = SEMANTIC_ATTR15;\n\t\t\t\tcode += \"attribute float morph_vertex_id;\\n\";\n\t\t\t} else {\n\t\t\t\tcode += \"#define MORPHING\\n\";\n\n\t\t\t\tif (options.useMorphPosition) {\n\t\t\t\t\tattributes.morph_pos0 = SEMANTIC_ATTR8;\n\t\t\t\t\tattributes.morph_pos1 = SEMANTIC_ATTR9;\n\t\t\t\t\tattributes.morph_pos2 = SEMANTIC_ATTR10;\n\t\t\t\t\tattributes.morph_pos3 = SEMANTIC_ATTR11;\n\t\t\t\t\tcode += \"#define MORPHING_POS03\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos0;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos1;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos2;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos3;\\n\";\n\t\t\t\t} else if (options.useMorphNormal) {\n\t\t\t\t\tattributes.morph_nrm0 = SEMANTIC_ATTR8;\n\t\t\t\t\tattributes.morph_nrm1 = SEMANTIC_ATTR9;\n\t\t\t\t\tattributes.morph_nrm2 = SEMANTIC_ATTR10;\n\t\t\t\t\tattributes.morph_nrm3 = SEMANTIC_ATTR11;\n\t\t\t\t\tcode += \"#define MORPHING_NRM03\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm0;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm1;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm2;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm3;\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (!options.useMorphNormal) {\n\t\t\t\t\tattributes.morph_pos4 = SEMANTIC_ATTR12;\n\t\t\t\t\tattributes.morph_pos5 = SEMANTIC_ATTR13;\n\t\t\t\t\tattributes.morph_pos6 = SEMANTIC_ATTR14;\n\t\t\t\t\tattributes.morph_pos7 = SEMANTIC_ATTR15;\n\t\t\t\t\tcode += \"#define MORPHING_POS47\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos4;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos5;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos6;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos7;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tattributes.morph_nrm4 = SEMANTIC_ATTR12;\n\t\t\t\t\tattributes.morph_nrm5 = SEMANTIC_ATTR13;\n\t\t\t\t\tattributes.morph_nrm6 = SEMANTIC_ATTR14;\n\t\t\t\t\tattributes.morph_nrm7 = SEMANTIC_ATTR15;\n\t\t\t\t\tcode += \"#define MORPHING_NRM47\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm4;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm5;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm6;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm7;\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.skin) {\n\t\t\tattributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;\n\t\t\tattributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;\n\t\t\tcode += skinCode(device, chunks);\n\t\t\tcode += \"#define SKIN\\n\";\n\t\t} else if (options.useInstancing) {\n\t\t\tcode += \"#define INSTANCING\\n\";\n\t\t}\n\n\t\tif (options.screenSpace) {\n\t\t\tcode += \"#define SCREENSPACE\\n\";\n\t\t}\n\n\t\tif (options.pixelSnap) {\n\t\t\tcode += \"#define PIXELSNAP\\n\";\n\t\t}\n\n\t\tcode = this._vsAddTransformCode(code, device, chunks, options);\n\t\tif (needsNormal) code += chunks.normalVS;\n\t\tcode += \"\\n\";\n\t\tcode += chunks.startVS;\n\t\tcode += codeBody;\n\t\tcode += chunks.endVS;\n\t\tcode += \"}\";\n\t\tlet vshader = code;\n\t\tconst oldVars = varyings;\n\t\tvaryings = \"\";\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec4\", \"vVertexColor\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vPositionW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vNormalV\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vNormalW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vTangentW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vBinormalW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vObjectSpaceUpW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec2\", \"vUv0\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec2\", \"vUv1\");\n\t\tvaryings += oldVars;\n\t\tvshader = varyings + vshader;\n\t\tlet startCode = \"\";\n\n\t\tif (device.webgl2) {\n\t\t\tstartCode = versionCode(device);\n\n\t\t\tif (chunks.extensionVS) {\n\t\t\t\tstartCode += chunks.extensionVS + \"\\n\";\n\t\t\t}\n\n\t\t\tvshader = startCode + chunks.gles3VS + vshader;\n\t\t} else {\n\t\t\tif (chunks.extensionVS) {\n\t\t\t\tstartCode = chunks.extensionVS + \"\\n\";\n\t\t\t}\n\n\t\t\tvshader = startCode + vshader;\n\t\t}\n\n\t\tif (options.forceFragmentPrecision && options.forceFragmentPrecision !== \"highp\" && options.forceFragmentPrecision !== \"mediump\" && options.forceFragmentPrecision !== \"lowp\") options.forceFragmentPrecision = null;\n\n\t\tif (options.forceFragmentPrecision) {\n\t\t\tif (options.forceFragmentPrecision === \"highp\" && device.maxPrecision !== \"highp\") options.forceFragmentPrecision = \"mediump\";\n\t\t\tif (options.forceFragmentPrecision === \"mediump\" && device.maxPrecision === \"lowp\") options.forceFragmentPrecision = \"lowp\";\n\t\t}\n\n\t\tlet fshader;\n\t\tcode = '';\n\n\t\tif (device.webgl2) {\n\t\t\tcode += versionCode(device);\n\t\t}\n\n\t\tif (!device.webgl2) {\n\t\t\tif (device.extStandardDerivatives) {\n\t\t\t\tcode += \"#extension GL_OES_standard_derivatives : enable\\n\";\n\t\t\t}\n\n\t\t\tif (device.extTextureLod) {\n\t\t\t\tcode += \"#extension GL_EXT_shader_texture_lod : enable\\n\";\n\t\t\t\tcode += \"#define SUPPORTS_TEXLOD\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif (chunks.extensionPS) {\n\t\t\tcode += chunks.extensionPS + \"\\n\";\n\t\t}\n\n\t\tif (device.webgl2) {\n\t\t\tcode += chunks.gles3PS;\n\t\t}\n\n\t\tcode += options.forceFragmentPrecision ? \"precision \" + options.forceFragmentPrecision + \" float;\\n\\n\" : precisionCode(device);\n\t\tcode += this._getPassDefineString(options.pass);\n\n\t\tif (options.pass === SHADER_PICK) {\n\t\t\tcode += \"uniform vec4 uColor;\\n\";\n\t\t\tcode += varyings;\n\n\t\t\tif (options.alphaTest) {\n\t\t\t\tcode += \"float dAlpha;\\n\";\n\t\t\t\tcode += this._addMap(\"opacity\", \"opacityPS\", options, chunks);\n\t\t\t\tcode += chunks.alphaTestPS;\n\t\t\t}\n\n\t\t\tcode += begin();\n\n\t\t\tif (options.alphaTest) {\n\t\t\t\tcode += \"\t getOpacity();\\n\";\n\t\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t\t}\n\n\t\t\tcode += \"\t\tgl_FragColor = uColor;\\n\";\n\t\t\tcode += end();\n\t\t\treturn {\n\t\t\t\tattributes: attributes,\n\t\t\t\tvshader: vshader,\n\t\t\t\tfshader: code\n\t\t\t};\n\t\t} else if (options.pass === SHADER_DEPTH) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += varyings;\n\t\t\tcode += chunks.packDepthPS;\n\n\t\t\tif (options.alphaTest) {\n\t\t\t\tcode += \"float dAlpha;\\n\";\n\t\t\t\tcode += this._addMap(\"opacity\", \"opacityPS\", options, chunks);\n\t\t\t\tcode += chunks.alphaTestPS;\n\t\t\t}\n\n\t\t\tcode += begin();\n\n\t\t\tif (options.alphaTest) {\n\t\t\t\tcode += \"\t getOpacity();\\n\";\n\t\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t\t}\n\n\t\t\tcode += \"\t\tgl_FragColor = packFloat(vDepth);\\n\";\n\t\t\tcode += end();\n\t\t\treturn {\n\t\t\t\tattributes: attributes,\n\t\t\t\tvshader: vshader,\n\t\t\t\tfshader: code\n\t\t\t};\n\t\t} else if (shadowPass) {\n\t\t\treturn {\n\t\t\t\tattributes: attributes,\n\t\t\t\tvshader: vshader,\n\t\t\t\tfshader: this._buildShadowPassFragmentCode(code, device, chunks, options, varyings)\n\t\t\t};\n\t\t}\n\n\t\tif (options.customFragmentShader) {\n\t\t\tfshader = code + options.customFragmentShader;\n\t\t\treturn {\n\t\t\t\tattributes: attributes,\n\t\t\t\tvshader: vshader,\n\t\t\t\tfshader: fshader,\n\t\t\t\ttag: SHADERTAG_MATERIAL\n\t\t\t};\n\t\t}\n\n\t\tcode += varyings;\n\t\tcode = this._fsAddBaseCode(code, device, chunks, options);\n\n\t\tif (options.detailModes) {\n\t\t\tcode += chunks.detailModesPS;\n\t\t}\n\n\t\tconst codeBegin = code;\n\t\tcode = \"\";\n\n\t\tif (options.clearCoat > 0) {\n\t\t\tcode += '#define CLEARCOAT\\n';\n\t\t\tcode += \"#define CLUSTER_CLEAR_COAT\\n\";\n\t\t}\n\n\t\tif (options.opacityFadesSpecular === false) {\n\t\t\tcode += 'uniform float material_alphaFade;\\n';\n\t\t}\n\n\t\tlet numShadowLights = 0;\n\t\tconst shadowTypeUsed = [];\n\t\tlet shadowedDirectionalLightUsed = false;\n\t\tlet useVsm = false;\n\t\tlet usePerspZbufferShadow = false;\n\t\tlet hasAreaLights = options.lights.some(function (light) {\n\t\t\treturn light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;\n\t\t});\n\n\t\tif (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {\n\t\t\thasAreaLights = true;\n\t\t}\n\n\t\tif (device.areaLightLutFormat === PIXELFORMAT_R8_G8_B8_A8) {\n\t\t\tcode += \"#define AREA_R8_G8_B8_A8_LUTS\\n\";\n\t\t\tcode += \"#define AREA_LUTS_PRECISION lowp\\n\";\n\t\t} else {\n\t\t\tcode += \"#define AREA_LUTS_PRECISION highp\\n\";\n\t\t}\n\n\t\tif (hasAreaLights || options.clusteredLightingEnabled) {\n\t\t\tcode += \"#define AREA_LIGHTS\\n\";\n\t\t\tcode += \"uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex1;\\n\";\n\t\t\tcode += \"uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex2;\\n\";\n\t\t}\n\n\t\tfor (let i = 0; i < options.lights.length; i++) {\n\t\t\tconst light = options.lights[i];\n\t\t\tconst lightType = light._type;\n\t\t\tif (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) continue;\n\t\t\tconst lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;\n\t\t\tcode += \"uniform vec3 light\" + i + \"_color;\\n\";\n\n\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tcode += \"uniform vec3 light\" + i + \"_direction;\\n\";\n\t\t\t} else {\n\t\t\t\tcode += \"uniform vec3 light\" + i + \"_position;\\n\";\n\t\t\t\tcode += \"uniform float light\" + i + \"_radius;\\n\";\n\n\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\tcode += \"uniform vec3 light\" + i + \"_direction;\\n\";\n\t\t\t\t\tcode += \"uniform float light\" + i + \"_innerConeAngle;\\n\";\n\t\t\t\t\tcode += \"uniform float light\" + i + \"_outerConeAngle;\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"uniform vec3 light\" + i + \"_position;\\n\";\n\t\t\t\t}\n\n\t\t\t\tcode += \"uniform vec3 light\" + i + \"_halfWidth;\\n\";\n\t\t\t\tcode += \"uniform vec3 light\" + i + \"_halfHeight;\\n\";\n\t\t\t}\n\n\t\t\tif (light.castShadows && !options.noShadow) {\n\t\t\t\tcode += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"uniform mat4 light\" + i + \"_shadowMatrixPalette[4];\\n\";\n\t\t\t\t\tcode += \"uniform float light\" + i + \"_shadowCascadeDistances[4];\\n\";\n\t\t\t\t\tcode += \"uniform float light\" + i + \"_shadowCascadeCount;\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"uniform vec4 light\" + i + \"_shadowParams;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tshadowedDirectionalLightUsed = true;\n\t\t\t\t\tcode += \"uniform vec3 light\" + i + \"_shadowParams;\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\tcode += \"uniform samplerCube light\" + i + \"_shadowMap;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tif (light._isPcf && device.webgl2) {\n\t\t\t\t\t\tcode += \"uniform sampler2DShadow light\" + i + \"_shadowMap;\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"uniform sampler2D light\" + i + \"_shadowMap;\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnumShadowLights++;\n\t\t\t\tshadowTypeUsed[light._shadowType] = true;\n\t\t\t\tif (light._isVsm) useVsm = true;\n\t\t\t\tif (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;\n\t\t\t}\n\n\t\t\tif (light._cookie) {\n\t\t\t\tif (light._cookie._cubemap) {\n\t\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\t\tcode += \"uniform samplerCube light\" + i + \"_cookie;\\n\";\n\t\t\t\t\t\tcode += \"uniform float light\" + i + \"_cookieIntensity;\\n\";\n\t\t\t\t\t\tif (!light.castShadows || options.noShadow) code += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\tcode += \"uniform sampler2D light\" + i + \"_cookie;\\n\";\n\t\t\t\t\t\tcode += \"uniform float light\" + i + \"_cookieIntensity;\\n\";\n\t\t\t\t\t\tif (!light.castShadows || options.noShadow) code += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n\n\t\t\t\t\t\tif (light._cookieTransform) {\n\t\t\t\t\t\t\tcode += \"uniform vec4 light\" + i + \"_cookieMatrix;\\n\";\n\t\t\t\t\t\t\tcode += \"uniform vec2 light\" + i + \"_cookieOffset;\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcode += \"\\n\";\n\t\tlet tbn;\n\n\t\tif (!options.hasTangents && device.extStandardDerivatives) {\n\t\t\ttbn = chunks.TBNderivativePS;\n\t\t} else if (options.fastTbn) {\n\t\t\ttbn = chunks.TBNfastPS;\n\t\t} else {\n\t\t\ttbn = chunks.TBNPS;\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tif (options.normalMap || options.clearCoatNormalMap) {\n\t\t\t\tcode += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;\n\n\t\t\t\tif (!options.hasTangents) {\n\t\t\t\t\tconst baseName = options.normalMap ? \"normalMap\" : \"clearCoatNormalMap\";\n\n\t\t\t\t\tconst uv = this._getUvSourceExpression(`${baseName}Transform`, `${baseName}Uv`, options);\n\n\t\t\t\t\ttbn = tbn.replace(/\\$UV/g, uv);\n\t\t\t\t}\n\n\t\t\t\tcode += tbn;\n\t\t\t} else if (options.enableGGXSpecular && !options.heightMap) {\n\t\t\t\tcode += chunks.normalVertexPS;\n\t\t\t\tcode += chunks.TBNObjectSpacePS;\n\t\t\t}\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tif (options.normalMap) {\n\t\t\t\tif (options.normalDetail) {\n\t\t\t\t\tcode += this._addMap(\"normalDetail\", \"normalDetailMapPS\", options, chunks);\n\t\t\t\t}\n\n\t\t\t\tconst transformedNormalMapUv = this._getUvSourceExpression(\"normalMapTransform\", \"normalMapUv\", options);\n\n\t\t\t\tif (options.normalizeNormalMap) {\n\t\t\t\t\tcode += chunks.normalMapPS.replace(/\\$UV/g, transformedNormalMapUv);\n\t\t\t\t} else {\n\t\t\t\t\tcode += chunks.normalMapFastPS.replace(/\\$UV/g, transformedNormalMapUv);\n\t\t\t\t}\n\t\t\t} else if (!(options.enableGGXSpecular && !options.heightMap)) {\n\t\t\t\tcode += chunks.normalVertexPS;\n\t\t\t}\n\t\t}\n\n\t\tcode += gammaCode(options.gamma, chunks);\n\t\tcode += tonemapCode(options.toneMap, chunks);\n\t\tcode += fogCode(options.fog, chunks);\n\t\tcode += chunks.decodePS;\n\t\tif (options.useRgbm) code += chunks.rgbmPS;\n\n\t\tif (options.useCubeMapRotation) {\n\t\t\tcode += \"#define CUBEMAP_ROTATION\\n\";\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tcode += chunks.cubeMapRotatePS;\n\t\t\tcode += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;\n\t\t\tcode += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;\n\t\t}\n\n\t\tif (options.diffuseDetail) {\n\t\t\tcode += this._addMap(\"diffuseDetail\", \"diffuseDetailMapPS\", options, chunks);\n\t\t}\n\n\t\tcode += this._addMap(\"diffuse\", \"diffusePS\", options, chunks);\n\n\t\tif (options.blendType !== BLEND_NONE || options.alphaTest || options.alphaToCoverage) {\n\t\t\tcode += this._addMap(\"opacity\", \"opacityPS\", options, chunks);\n\t\t}\n\n\t\tcode += this._addMap(\"emissive\", \"emissivePS\", options, chunks, options.emissiveFormat);\n\n\t\tif (lighting && options.useSpecular || reflections) {\n\t\t\tif (options.specularAntialias && options.normalMap) {\n\t\t\t\tif (options.normalizeNormalMap && needsNormal) {\n\t\t\t\t\tcode += chunks.specularAaToksvigPS;\n\t\t\t\t} else {\n\t\t\t\t\tcode += chunks.specularAaToksvigFastPS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcode += chunks.specularAaNonePS;\n\t\t\t}\n\n\t\t\tconst specularPropName = options.useMetalness ? \"metalness\" : \"specular\";\n\t\t\tcode += this._addMap(specularPropName, specularPropName + \"PS\", options, chunks);\n\t\t\tcode += this._addMap(\"gloss\", \"glossPS\", options, chunks);\n\n\t\t\tif (options.fresnelModel === FRESNEL_SCHLICK) {\n\t\t\t\tcode += chunks.fresnelSchlickPS;\n\t\t\t}\n\t\t}\n\n\t\tif (options.clearCoat > 0) {\n\t\t\tcode += this._addMap(\"clearCoat\", \"clearCoatPS\", options, chunks);\n\t\t\tcode += this._addMap(\"clearCoatGloss\", \"clearCoatGlossPS\", options, chunks);\n\t\t\tcode += this._addMap(\"clearCoatNormal\", \"clearCoatNormalPS\", options, chunks);\n\t\t}\n\n\t\tif (options.heightMap) {\n\t\t\tif (!options.normalMap) {\n\t\t\t\tconst transformedHeightMapUv = this._getUvSourceExpression(\"heightMapTransform\", \"heightMapUv\", options);\n\n\t\t\t\tif (!options.hasTangents) tbn = tbn.replace(/\\$UV/g, transformedHeightMapUv);\n\t\t\t\tcode += tbn;\n\t\t\t}\n\n\t\t\tcode += this._addMap(\"height\", \"parallaxPS\", options, chunks);\n\t\t}\n\n\t\tconst useAo = options.aoMap || options.aoVertexColor;\n\n\t\tif (useAo) {\n\t\t\tcode += this._addMap(\"ao\", \"aoPS\", options, chunks);\n\n\t\t\tif (options.occludeSpecular) {\n\t\t\t\tif (options.occludeSpecular === SPECOCC_AO) {\n\t\t\t\t\tcode += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;\n\t\t\t\t} else {\n\t\t\t\t\tcode += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.reflectionSource === 'envAtlas') {\n\t\t\tcode += chunks.reflectionEnvPS.replace(/\\$DECODE/g, this._decodeFunc(options.reflectionEncoding));\n\t\t} else if (options.reflectionSource === 'cubeMap') {\n\t\t\tcode += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;\n\t\t\tcode += chunks.reflectionCubePS.replace(/\\$DECODE/g, this._decodeFunc(options.reflectionEncoding));\n\t\t} else if (options.reflectionSource === 'sphereMap') {\n\t\t\tconst scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;\n\t\t\tcode += scode.replace(/\\$DECODE/g, this._decodeFunc(options.reflectionEncoding));\n\t\t}\n\n\t\tif (reflections) {\n\t\t\tif (options.clearCoat > 0) {\n\t\t\t\tcode += chunks.reflectionCCPS;\n\t\t\t}\n\n\t\t\tif (options.refraction) {\n\t\t\t\tcode += chunks.refractionPS;\n\t\t\t}\n\t\t}\n\n\t\tif (options.clusteredLightingEnabled) {\n\t\t\tcode += chunks.clusteredLightUtilsPS;\n\t\t\tcode += chunks.clusteredLightCookiesPS;\n\t\t\tshadowTypeUsed[SHADOW_PCF3] = true;\n\t\t\tshadowTypeUsed[SHADOW_PCF5] = true;\n\t\t\tusePerspZbufferShadow = true;\n\t\t}\n\n\t\tif (numShadowLights > 0 || options.clusteredLightingEnabled) {\n\t\t\tif (shadowedDirectionalLightUsed) {\n\t\t\t\tcode += chunks.shadowCascadesPS;\n\t\t\t}\n\n\t\t\tif (shadowTypeUsed[SHADOW_PCF3]) {\n\t\t\t\tcode += chunks.shadowStandardPS;\n\t\t\t}\n\n\t\t\tif (shadowTypeUsed[SHADOW_PCF5] && device.webgl2) {\n\t\t\t\tcode += chunks.shadowStandardGL2PS;\n\t\t\t}\n\n\t\t\tif (useVsm) {\n\t\t\t\tcode += chunks.shadowVSM_commonPS;\n\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM8]) {\n\t\t\t\t\tcode += chunks.shadowVSM8PS;\n\t\t\t\t}\n\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM16]) {\n\t\t\t\t\tcode += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\\$/g, \"16\") : chunks.shadowEVSMnPS.replace(/\\$/g, \"16\");\n\t\t\t\t}\n\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM32]) {\n\t\t\t\t\tcode += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\\$/g, \"32\") : chunks.shadowEVSMnPS.replace(/\\$/g, \"32\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(device.webgl2 || device.extStandardDerivatives)) {\n\t\t\t\tcode += chunks.biasConstPS;\n\t\t\t}\n\n\t\t\tcode += chunks.shadowCoordPS + chunks.shadowCommonPS;\n\t\t\tif (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;\n\t\t}\n\n\t\tif (options.enableGGXSpecular) code += \"uniform float material_anisotropy;\\n\";\n\n\t\tif (lighting) {\n\t\t\tcode += chunks.lightDiffuseLambertPS;\n\t\t\tif (hasAreaLights || options.clusteredLightingEnabled) code += chunks.ltc;\n\t\t}\n\n\t\tcode += '\\n';\n\t\tlet useOldAmbient = false;\n\n\t\tif (options.useSpecular) {\n\t\t\tcode += \"#define CLUSTER_SPECULAR\\n\";\n\n\t\t\tif (options.conserveEnergy) {\n\t\t\t\tcode += \"#define CLUSTER_CONSERVE_ENERGY\\n\";\n\t\t\t}\n\n\t\t\tif (lighting) {\n\t\t\t\tcode += options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;\n\t\t\t}\n\n\t\t\tif (options.fresnelModel > 0) {\n\t\t\t\tif (options.conserveEnergy && !hasAreaLights) {\n\t\t\t\t\tcode += chunks.combineDiffuseSpecularPS;\n\t\t\t\t} else {\n\t\t\t\t\tcode += chunks.combineDiffuseSpecularNoConservePS;\n\t\t\t\t}\n\t\t\t} else if (reflections) {\n\t\t\t\tcode += chunks.combineDiffuseSpecularOldPS;\n\t\t\t} else {\n\t\t\t\tif (options.diffuseMap) {\n\t\t\t\t\tcode += chunks.combineDiffuseSpecularNoReflPS;\n\t\t\t\t} else {\n\t\t\t\t\tcode += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;\n\t\t\t\t\tuseOldAmbient = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcode += chunks.combineDiffusePS;\n\t\t}\n\n\t\tif (options.clearCoat > 0) {\n\t\t\tcode += chunks.combineClearCoatPS;\n\t\t}\n\n\t\tlet addAmbient = true;\n\n\t\tif (options.lightMap || options.lightVertexColor) {\n\t\t\tconst lightmapChunkPropName = options.dirLightMap && options.useSpecular ? 'lightmapDirPS' : 'lightmapSinglePS';\n\t\t\tcode += this._addMap(\"light\", lightmapChunkPropName, options, chunks, options.lightMapFormat);\n\t\t\taddAmbient = options.lightMapWithoutAmbient;\n\t\t}\n\n\t\tif (addAmbient) {\n\t\t\tif (options.ambientSource === 'ambientSH') {\n\t\t\t\tcode += chunks.ambientSHPS;\n\t\t\t} else if (options.ambientSource === 'envAtlas') {\n\t\t\t\tcode += chunks.ambientEnvPS.replace(/\\$DECODE/g, this._decodeFunc(options.ambientEncoding));\n\t\t\t} else {\n\t\t\t\tcode += chunks.ambientConstantPS;\n\t\t\t}\n\t\t}\n\n\t\tif (options.ambientTint && !useOldAmbient) {\n\t\t\tcode += \"uniform vec3 material_ambient;\\n\";\n\t\t}\n\n\t\tif (options.alphaTest) {\n\t\t\tcode += chunks.alphaTestPS;\n\t\t}\n\n\t\tif (options.msdf) {\n\t\t\tcode += chunks.msdfPS;\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tcode += chunks.viewDirPS;\n\n\t\t\tif (options.useSpecular) {\n\t\t\t\tcode += options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS;\n\t\t\t}\n\t\t}\n\n\t\tlet hasPointLights = false;\n\t\tlet usesLinearFalloff = false;\n\t\tlet usesInvSquaredFalloff = false;\n\t\tlet usesSpot = false;\n\t\tlet usesCookie = false;\n\t\tlet usesCookieNow;\n\n\t\tif (options.clusteredLightingEnabled && lighting) {\n\t\t\tusesSpot = true;\n\t\t\thasPointLights = true;\n\t\t\tusesLinearFalloff = true;\n\t\t\tusesCookie = true;\n\t\t\tcode += chunks.floatUnpackingPS;\n\t\t\tif (options.lightMaskDynamic) code += \"\\n#define CLUSTER_MESH_DYNAMIC_LIGHTS\";\n\t\t\tif (options.clusteredLightingCookiesEnabled) code += \"\\n#define CLUSTER_COOKIES\";\n\n\t\t\tif (options.clusteredLightingShadowsEnabled && !options.noShadow) {\n\t\t\t\tcode += \"\\n#define CLUSTER_SHADOWS\";\n\t\t\t\tcode += \"\\n#define CLUSTER_SHADOW_TYPE_\" + shadowTypeToString[options.clusteredLightingShadowType];\n\t\t\t}\n\n\t\t\tif (options.clusteredLightingAreaLightsEnabled) code += \"\\n#define CLUSTER_AREALIGHTS\";\n\t\t\tcode += LightsBuffer.shaderDefines;\n\t\t\tcode += chunks.clusteredLightShadowsPS;\n\t\t\tcode += chunks.clusteredLightPS;\n\t\t}\n\n\t\tif (options.twoSidedLighting) code += \"uniform float twoSidedLightingNegScaleFactor;\\n\";\n\t\tcode = this._fsAddStartCode(code, device, chunks, options);\n\n\t\tif (needsNormal) {\n\t\t\tif (!options.hasTangents && device.extStandardDerivatives && !options.fastTbn) {\n\t\t\t\tif (options.twoSidedLighting) {\n\t\t\t\t\tcode += \"\t dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcode += \"\t dVertexNormalW = normalize(vNormalW);\\n\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (options.twoSidedLighting) {\n\t\t\t\t\tcode += \"\t dVertexNormalW = gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcode += \"\t dVertexNormalW = vNormalW;\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((options.heightMap || options.normalMap) && options.hasTangents) {\n\t\t\t\tif (options.twoSidedLighting) {\n\t\t\t\t\tcode += \"\t dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\\n\";\n\t\t\t\t\tcode += \"\t dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcode += \"\t dTangentW = vTangentW;\\n\";\n\t\t\t\t\tcode += \"\t dBinormalW = vBinormalW;\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet opacityParallax = false;\n\n\t\tif (options.blendType === BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {\n\t\t\tcode += \"\t dAlpha = 1.0;\\n\";\n\t\t} else {\n\t\t\tif (options.heightMap && options.opacityMap) {\n\t\t\t\topacityParallax = true;\n\t\t\t} else {\n\t\t\t\tcode += \"\t getOpacity();\\n\";\n\n\t\t\t\tif (options.alphaTest) {\n\t\t\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet getGlossinessCalled = false;\n\n\t\tif (needsNormal) {\n\t\t\tcode += \"\t getViewDir();\\n\";\n\n\t\t\tif (options.heightMap || options.normalMap || options.clearCoatNormalMap || options.enableGGXSpecular) {\n\t\t\t\tcode += \"\t getTBN();\\n\";\n\t\t\t}\n\n\t\t\tif (options.heightMap) {\n\t\t\t\tcode += \"\t getParallax();\\n\";\n\t\t\t}\n\n\t\t\tif (opacityParallax) {\n\t\t\t\tcode += \"\t getOpacity();\\n\";\n\n\t\t\t\tif (options.alphaTest) {\n\t\t\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcode += \"\t getNormal();\\n\";\n\n\t\t\tif (options.useSpecular) {\n\t\t\t\tif (lighting && options.enableGGXSpecular) {\n\t\t\t\t\tcode += \"\t getGlossiness();\\n\";\n\t\t\t\t\tgetGlossinessCalled = true;\n\t\t\t\t}\n\n\t\t\t\tcode += \"\t getReflDir();\\n\";\n\t\t\t}\n\t\t}\n\n\t\tcode += \"\t getAlbedo();\\n\";\n\n\t\tif (options.clearCoat > 0) {\n\t\t\tcode += \"\t getClearCoat();\\n\";\n\t\t\tcode += \"\t getClearCoatGlossiness();\\n\";\n\t\t\tcode += \"\t getClearCoatNormal();\\n\";\n\t\t}\n\n\t\tif (lighting && options.useSpecular || reflections) {\n\t\t\tcode += \"\t getSpecularity();\\n\";\n\t\t\tif (!getGlossinessCalled) code += \"\t getGlossiness();\\n\";\n\n\t\t\tif (hasAreaLights) {\n\t\t\t\tcode += \"\t #ifdef AREA_LIGHTS\\n\";\n\t\t\t\tcode += \"\t dSpecularityNoFres = dSpecularity;\\n\";\n\t\t\t\tcode += \"\t #ifdef CLEARCOAT\\n\";\n\t\t\t\tcode += \"\t ccSpecularityNoFres = ccSpecularity;\\n\";\n\t\t\t\tcode += \"\t #endif\\n\";\n\t\t\t\tcode += \"\t #endif\\n\";\n\t\t\t}\n\n\t\t\tif (options.fresnelModel > 0) code += \"\t getFresnel();\\n\";\n\t\t}\n\n\t\tif (addAmbient) {\n\t\t\tcode += \"\t addAmbient();\\n\";\n\n\t\t\tif (options.separateAmbient) {\n\t\t\t\tcode += `\n\t\t\t\t\t\t\t\t\t\tvec3 dAmbientLight = dDiffuseLight;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = vec3(0);\n\t\t\t\t\t\t\t\t`;\n\t\t\t}\n\t\t}\n\n\t\tif (options.ambientTint && !useOldAmbient) {\n\t\t\tcode += \"\t dDiffuseLight *= material_ambient;\\n\";\n\t\t}\n\n\t\tif (useAo && !options.occludeDirect) {\n\t\t\tcode += \"\t\tapplyAO();\\n\";\n\t\t}\n\n\t\tif (options.lightMap || options.lightVertexColor) {\n\t\t\tcode += \"\t addLightMap();\\n\";\n\t\t}\n\n\t\tif (lighting || reflections) {\n\t\t\tif (reflections) {\n\t\t\t\tif (options.clearCoat > 0) {\n\t\t\t\t\tcode += \"\t addReflectionCC();\\n\";\n\t\t\t\t}\n\n\t\t\t\tcode += \"\t addReflection();\\n\";\n\t\t\t}\n\n\t\t\tif (hasAreaLights) {\n\t\t\t\tcode += \"\t ccReflection.rgb *= ccSpecularity;\\n\";\n\t\t\t\tcode += \"\t dReflection.rgb *= dSpecularity;\\n\";\n\t\t\t\tcode += \"\t dSpecularLight *= dSpecularity;\\n\";\n\t\t\t\tcode += \"\t float roughness = max((1.0 - dGlossiness) * (1.0 - dGlossiness), 0.001);\\n\";\n\t\t\t\tcode += \"\t calcLTCLightValues();\\n\";\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < options.lights.length; i++) {\n\t\t\t\tconst light = options.lights[i];\n\t\t\t\tconst lightType = light._type;\n\n\t\t\t\tif (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tusesCookieNow = false;\n\t\t\t\tconst lightShape = hasAreaLights && light._shape ? light.shape : LIGHTSHAPE_PUNCTUAL;\n\t\t\t\tconst shapeString = hasAreaLights && light._shape ? this._getLightSourceShapeString(lightShape) : '';\n\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tcode += \"\t calc\" + shapeString + \"LightValues(light\" + i + \"_position, light\" + i + \"_halfWidth, light\" + i + \"_halfHeight);\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"\t dLightDirNormW = light\" + i + \"_direction;\\n\";\n\t\t\t\t\tcode += \"\t dAtten = 1.0;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tif (light._cookie) {\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {\n\t\t\t\t\t\t\tusesCookie = true;\n\t\t\t\t\t\t\tusesCookieNow = true;\n\t\t\t\t\t\t} else if (lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {\n\t\t\t\t\t\t\tusesCookie = true;\n\t\t\t\t\t\t\tusesCookieNow = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcode += \"\t getLightDirPoint(light\" + i + \"_position);\\n\";\n\t\t\t\t\thasPointLights = true;\n\n\t\t\t\t\tif (usesCookieNow) {\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\t\tcode += \"\t dAtten3 = getCookie2D\" + (light._cookieFalloff ? \"\" : \"Clip\") + (light._cookieTransform ? \"Xform\" : \"\") + \"(light\" + i + \"_cookie, light\" + i + \"_shadowMatrix, light\" + i + \"_cookieIntensity\" + (light._cookieTransform ? \", light\" + i + \"_cookieMatrix, light\" + i + \"_cookieOffset\" : \"\") + \").\" + light._cookieChannel + \";\\n\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode += \"\t dAtten3 = getCookieCube(light\" + i + \"_cookie, light\" + i + \"_shadowMatrix, light\" + i + \"_cookieIntensity).\" + light._cookieChannel + \";\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lightShape === LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\t\tif (light._falloffMode === LIGHTFALLOFF_LINEAR) {\n\t\t\t\t\t\t\tcode += \"\t dAtten = getFalloffLinear(light\" + i + \"_radius);\\n\";\n\t\t\t\t\t\t\tusesLinearFalloff = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode += \"\t dAtten = getFalloffInvSquared(light\" + i + \"_radius);\\n\";\n\t\t\t\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"\t dAtten = getFalloffWindow(light\" + i + \"_radius);\\n\";\n\t\t\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tcode += \"\t if (dAtten > 0.00001) {\\n\";\n\n\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\tif (!(usesCookieNow && !light._cookieFalloff)) {\n\t\t\t\t\t\t\tcode += \"\t\t\t dAtten *= getSpotEffect(light\" + i + \"_direction, light\" + i + \"_innerConeAngle, light\" + i + \"_outerConeAngle);\\n\";\n\t\t\t\t\t\t\tusesSpot = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\t\tcode += \"\t\t\t dAttenD = getLightDiffuse();\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"\t\t\t dAttenD = get\" + shapeString + \"LightDiffuse() * 16.0;\\n\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcode += \"\t\t\t dAtten *= getLightDiffuse();\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (light.castShadows && !options.noShadow) {\n\t\t\t\t\tlet shadowReadMode = null;\n\t\t\t\t\tlet evsmExp;\n\n\t\t\t\t\tif (light._shadowType === SHADOW_VSM8) {\n\t\t\t\t\t\tshadowReadMode = \"VSM8\";\n\t\t\t\t\t\tevsmExp = \"0.0\";\n\t\t\t\t\t} else if (light._shadowType === SHADOW_VSM16) {\n\t\t\t\t\t\tshadowReadMode = \"VSM16\";\n\t\t\t\t\t\tevsmExp = \"5.54\";\n\t\t\t\t\t} else if (light._shadowType === SHADOW_VSM32) {\n\t\t\t\t\t\tshadowReadMode = \"VSM32\";\n\n\t\t\t\t\t\tif (device.textureFloatHighPrecision) {\n\t\t\t\t\t\t\tevsmExp = \"15.0\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tevsmExp = \"5.54\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (light._shadowType === SHADOW_PCF5) {\n\t\t\t\t\t\tshadowReadMode = \"PCF5x5\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshadowReadMode = \"PCF3x3\";\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shadowReadMode !== null) {\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\t\t\tshadowCoordArgs = \"(light\" + i + \"_shadowMap, light\" + i + \"_shadowParams);\\n\";\n\n\t\t\t\t\t\t\tif (light._normalOffsetBias) {\n\t\t\t\t\t\t\t\tcode += \"\t\t\t normalOffsetPointShadow(light\" + i + \"_shadowParams);\\n\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcode += \"\t\t\t dAtten *= getShadowPoint\" + shadowReadMode + shadowCoordArgs;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst shadowMatArg = `light${i}_shadowMatrix`;\n\t\t\t\t\t\t\tconst shadowParamArg = `light${i}_shadowParams`;\n\t\t\t\t\t\t\tcode += this._nonPointShadowMapProjection(device, options.lights[i], shadowMatArg, shadowParamArg, i);\n\t\t\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) shadowReadMode = \"Spot\" + shadowReadMode;\n\t\t\t\t\t\t\tcode += \"\t\t\t dAtten *= getShadow\" + shadowReadMode + \"(light\" + i + \"_shadowMap, light\" + i + \"_shadowParams\" + (light._isVsm ? \", \" + evsmExp : \"\") + \");\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tif (options.conserveEnergy && options.useSpecular) {\n\t\t\t\t\t\tcode += \"\t\t\t dDiffuseLight += mix((dAttenD * dAtten) * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \", vec3(0), dLTCSpecFres);\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"\t\t\t dDiffuseLight += (dAttenD * dAtten) * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasAreaLights && options.conserveEnergy && options.useSpecular) {\n\t\t\t\t\t\tcode += \"\t\t\t dDiffuseLight += mix(dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \", vec3(0), dSpecularity);\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"\t\t\t dDiffuseLight += dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tif (options.clearCoat > 0) code += \"\t\t\t ccSpecularLight += ccLTCSpecFres * get\" + shapeString + \"LightSpecularCC() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\tif (options.useSpecular) code += \"\t\t\t dSpecularLight += dLTCSpecFres * get\" + shapeString + \"LightSpecular() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tif (hasAreaLights) {\n\t\t\t\t\t\tif (options.clearCoat > 0) code += \"\t\t\t ccSpecularLight += ccSpecularity * getLightSpecularCC() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t\tif (options.useSpecular) code += \"\t\t\t dSpecularLight += dSpecularity * getLightSpecular() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (options.clearCoat > 0) code += \"\t\t\t ccSpecularLight += getLightSpecularCC() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t\tif (options.useSpecular) code += \"\t\t\t dSpecularLight += getLightSpecular() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"\t }\\n\";\n\t\t\t\t}\n\n\t\t\t\tcode += \"\\n\";\n\t\t\t}\n\n\t\t\tif (options.clusteredLightingEnabled && lighting) {\n\t\t\t\tusesLinearFalloff = true;\n\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\thasPointLights = true;\n\t\t\t\tcode += '\t addClusteredLights();\\n';\n\t\t\t}\n\n\t\t\tif (hasAreaLights) {\n\t\t\t\tif (options.clearCoat > 0) {\n\t\t\t\t\tcode += \"\t ccSpecularity = 1.0;\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (options.useSpecular) {\n\t\t\t\t\tcode += \"\t dSpecularity = vec3(1);\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (reflections && options.refraction) {\n\t\t\t\tcode += \"\t addRefraction();\\n\";\n\t\t\t}\n\t\t}\n\n\t\tcode += \"\\n\";\n\n\t\tif (useAo) {\n\t\t\tif (options.occludeDirect) {\n\t\t\t\tcode += \"\t\tapplyAO();\\n\";\n\t\t\t}\n\n\t\t\tif (options.occludeSpecular) {\n\t\t\t\tcode += \"\t\toccludeSpecular();\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif (options.opacityFadesSpecular === false) {\n\t\t\tif (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {\n\t\t\t\tcode += \"float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\\n\";\n\t\t\t\tcode += \"#ifdef CLEARCOAT\\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccReflection.a * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\\n#endif\\n\";\n\t\t\t\tcode += \"dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\\n\";\n\t\t\t}\n\n\t\t\tcode += \"dAlpha *= material_alphaFade;\\n\";\n\t\t}\n\n\t\tcode += chunks.endPS;\n\n\t\tif (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {\n\t\t\tcode += chunks.outputAlphaPS;\n\t\t} else if (options.blendType === BLEND_PREMULTIPLIED) {\n\t\t\tcode += chunks.outputAlphaPremulPS;\n\t\t} else {\n\t\t\tcode += chunks.outputAlphaOpaquePS;\n\t\t}\n\n\t\tif (options.msdf) {\n\t\t\tcode += \"\t gl_FragColor = applyMsdf(gl_FragColor);\\n\";\n\t\t}\n\n\t\tcode += \"\\n\";\n\t\tcode += end();\n\n\t\tif (hasPointLights) {\n\t\t\tcode = chunks.lightDirPointPS + code;\n\t\t}\n\n\t\tif (usesLinearFalloff) {\n\t\t\tcode = chunks.falloffLinearPS + code;\n\t\t}\n\n\t\tif (usesInvSquaredFalloff) {\n\t\t\tcode = chunks.falloffInvSquaredPS + code;\n\t\t}\n\n\t\tif (usesSpot) {\n\t\t\tcode = chunks.spotPS + code;\n\t\t}\n\n\t\tif (usesCookie) {\n\t\t\tcode = chunks.cookiePS + code;\n\t\t}\n\n\t\tlet structCode = \"\";\n\t\tif (code.includes(\"dReflection\")) structCode += \"vec4 dReflection;\\n\";\n\t\tif (code.includes(\"dTBN\")) structCode += \"mat3 dTBN;\\n\";\n\t\tif (code.includes(\"dAlbedo\")) structCode += \"vec3 dAlbedo;\\n\";\n\t\tif (code.includes(\"dEmission\")) structCode += \"vec3 dEmission;\\n\";\n\t\tif (code.includes(\"dNormalW\")) structCode += \"vec3 dNormalW;\\n\";\n\t\tif (code.includes(\"dVertexNormalW\")) structCode += \"vec3 dVertexNormalW;\\n\";\n\t\tif (code.includes(\"dTangentW\")) structCode += \"vec3 dTangentW;\\n\";\n\t\tif (code.includes(\"dBinormalW\")) structCode += \"vec3 dBinormalW;\\n\";\n\t\tif (code.includes(\"dViewDirW\")) structCode += \"vec3 dViewDirW;\\n\";\n\t\tif (code.includes(\"dReflDirW\")) structCode += \"vec3 dReflDirW;\\n\";\n\t\tif (code.includes(\"dDiffuseLight\")) structCode += \"vec3 dDiffuseLight;\\n\";\n\t\tif (code.includes(\"dSpecularLight\")) structCode += \"vec3 dSpecularLight;\\n\";\n\t\tif (code.includes(\"dLightDirNormW\")) structCode += \"vec3 dLightDirNormW;\\n\";\n\t\tif (code.includes(\"dLightDirW\")) structCode += \"vec3 dLightDirW;\\n\";\n\t\tif (code.includes(\"dLightPosW\")) structCode += \"vec3 dLightPosW;\\n\";\n\t\tif (code.includes(\"dShadowCoord\")) structCode += \"vec3 dShadowCoord;\\n\";\n\t\tif (code.includes(\"dNormalMap\")) structCode += \"vec3 dNormalMap;\\n\";\n\t\tif (code.includes(\"dSpecularity\")) structCode += \"vec3 dSpecularity;\\n\";\n\t\tif (code.includes(\"dSpecularityNoFres\")) structCode += \"vec3 dSpecularityNoFres;\\n\";\n\t\tif (code.includes(\"dUvOffset\")) structCode += \"vec2 dUvOffset;\\n\";\n\t\tif (code.includes(\"dGlossiness\")) structCode += \"float dGlossiness;\\n\";\n\t\tif (code.includes(\"dAlpha\")) structCode += \"float dAlpha;\\n\";\n\t\tif (code.includes(\"dAtten\")) structCode += \"float dAtten;\\n\";\n\t\tif (code.includes(\"dAttenD\")) structCode += \"float dAttenD;\\n\";\n\t\tif (code.includes(\"dAtten3\")) structCode += \"vec3 dAtten3;\\n\";\n\t\tif (code.includes(\"dAo\")) structCode += \"float dAo;\\n\";\n\t\tif (code.includes(\"dMsdf\")) structCode += \"vec4 dMsdf;\\n\";\n\t\tif (code.includes(\"ccReflection\")) structCode += \"vec4 ccReflection;\\n\";\n\t\tif (code.includes(\"ccNormalW\")) structCode += \"vec3 ccNormalW;\\n\";\n\t\tif (code.includes(\"ccReflDirW\")) structCode += \"vec3 ccReflDirW;\\n\";\n\t\tif (code.includes(\"ccSpecularLight\")) structCode += \"vec3 ccSpecularLight;\\n\";\n\t\tif (code.includes(\"ccSpecularity\")) structCode += \"float ccSpecularity;\\n\";\n\t\tif (code.includes(\"ccSpecularityNoFres\")) structCode += \"float ccSpecularityNoFres;\\n\";\n\t\tif (code.includes(\"ccGlossiness\")) structCode += \"float ccGlossiness;\\n\";\n\t\tcode = codeBegin + structCode + code;\n\t\tfshader = code;\n\t\treturn {\n\t\t\tattributes: attributes,\n\t\t\tvshader: vshader,\n\t\t\tfshader: fshader,\n\t\t\ttag: SHADERTAG_MATERIAL\n\t\t};\n\t}\n};\n\nconst programlib = {\n\tbegin: begin,\n\tdummyFragmentCode: dummyFragmentCode,\n\tend: end,\n\tfogCode: fogCode,\n\tgammaCode: gammaCode,\n\tprecisionCode: precisionCode,\n\tskinCode: skinCode,\n\ttonemapCode: tonemapCode,\n\tversionCode: versionCode,\n\tbasic: basic,\n\tparticle: particle,\n\tskybox: skybox,\n\tstandard: standard\n};\n\nconst _goldenAngle = 2.399963229728653;\nconst random = {\n\tcirclePoint: function (point) {\n\t\tconst r = Math.sqrt(Math.random());\n\t\tconst theta = Math.random() * 2 * Math.PI;\n\t\tpoint.x = r * Math.cos(theta);\n\t\tpoint.y = r * Math.sin(theta);\n\t},\n\tcirclePointDeterministic: function (point, index, numPoints) {\n\t\tconst theta = index * _goldenAngle;\n\t\tconst r = Math.sqrt(index) / Math.sqrt(numPoints);\n\t\tpoint.x = r * Math.cos(theta);\n\t\tpoint.y = r * Math.sin(theta);\n\t},\n\tspherePointDeterministic: function (point, index, numPoints, start = 0, end = 1) {\n\t\tstart = 1 - 2 * start;\n\t\tend = 1 - 2 * end;\n\t\tconst y = math.lerp(start, end, index / numPoints);\n\t\tconst radius = Math.sqrt(1 - y * y);\n\t\tconst theta = _goldenAngle * index;\n\t\tpoint.x = Math.cos(theta) * radius;\n\t\tpoint.y = y;\n\t\tpoint.z = Math.sin(theta) * radius;\n\t},\n\tradicalInverse: function (i) {\n\t\tlet bits = (i << 16 | i >>> 16) >>> 0;\n\t\tbits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;\n\t\tbits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;\n\t\tbits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;\n\t\tbits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;\n\t\treturn bits * 2.3283064365386963e-10;\n\t}\n};\n\nconst getCoding = texture => {\n\tswitch (texture.type) {\n\t\tcase TEXTURETYPE_RGBM:\n\t\t\treturn \"RGBM\";\n\n\t\tcase TEXTURETYPE_RGBE:\n\t\t\treturn \"RGBE\";\n\n\t\tdefault:\n\t\t\tswitch (texture.format) {\n\t\t\t\tcase PIXELFORMAT_RGB16F:\n\t\t\t\tcase PIXELFORMAT_RGB32F:\n\t\t\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\t\t\treturn \"Linear\";\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"Gamma\";\n\t\t\t}\n\n\t}\n};\n\nconst getProjectionName = projection => {\n\tif (projection === TEXTUREPROJECTION_NONE) {\n\t\tprojection = TEXTUREPROJECTION_EQUIRECT;\n\t}\n\n\tswitch (projection) {\n\t\tcase TEXTUREPROJECTION_CUBE:\n\t\t\treturn \"Cubemap\";\n\n\t\tcase TEXTUREPROJECTION_EQUIRECT:\n\t\t\treturn \"Equirect\";\n\n\t\tcase TEXTUREPROJECTION_OCTAHEDRAL:\n\t\t\treturn \"Octahedral\";\n\t}\n};\n\nconst packFloat32ToRGBA8 = (value, array, offset) => {\n\tif (value <= 0) {\n\t\tarray[offset + 0] = 0;\n\t\tarray[offset + 1] = 0;\n\t\tarray[offset + 2] = 0;\n\t\tarray[offset + 3] = 0;\n\t} else if (value >= 1.0) {\n\t\tarray[offset + 0] = 255;\n\t\tarray[offset + 1] = 0;\n\t\tarray[offset + 2] = 0;\n\t\tarray[offset + 3] = 0;\n\t} else {\n\t\tlet encX = 1 * value % 1;\n\t\tlet encY = 255 * value % 1;\n\t\tlet encZ = 65025 * value % 1;\n\t\tconst encW = 16581375.0 * value % 1;\n\t\tencX -= encY / 255;\n\t\tencY -= encZ / 255;\n\t\tencZ -= encW / 255;\n\t\tarray[offset + 0] = Math.min(255, Math.floor(encX * 256));\n\t\tarray[offset + 1] = Math.min(255, Math.floor(encY * 256));\n\t\tarray[offset + 2] = Math.min(255, Math.floor(encZ * 256));\n\t\tarray[offset + 3] = Math.min(255, Math.floor(encW * 256));\n\t}\n};\n\nconst packSamples = samples => {\n\tconst numSamples = samples.length;\n\tconst w = Math.min(numSamples, 512);\n\tconst h = Math.ceil(numSamples / w);\n\tconst data = new Uint8Array(w * h * 4);\n\tlet off = 0;\n\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\tpackFloat32ToRGBA8(samples[i * 4 + 0] * 0.5 + 0.5, data, off + 0);\n\t\tpackFloat32ToRGBA8(samples[i * 4 + 1] * 0.5 + 0.5, data, off + 4);\n\t\tpackFloat32ToRGBA8(samples[i * 4 + 2] * 0.5 + 0.5, data, off + 8);\n\t\tpackFloat32ToRGBA8(samples[i * 4 + 3] / 8, data, off + 12);\n\t\toff += 16;\n\t}\n\n\treturn {\n\t\twidth: w,\n\t\theight: h,\n\t\tdata: data\n\t};\n};\n\nconst hemisphereSamplePhong = (dstVec, x, y, specularPower) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));\n\tconst sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\n\nconst hemisphereSampleLambert = (dstVec, x, y) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.sqrt(1 - x);\n\tconst sinTheta = Math.sqrt(x);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\n\nconst hemisphereSampleGGX = (dstVec, x, y, a) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));\n\tconst sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\n\nconst D_GGX = (NoH, linearRoughness) => {\n\tconst a = NoH * linearRoughness;\n\tconst k = linearRoughness / (1.0 - NoH * NoH + a * a);\n\treturn k * k * (1 / Math.PI);\n};\n\nconst generatePhongSamples = (numSamples, specularPower) => {\n\tconst H = new Vec3();\n\tconst result = [];\n\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\themisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);\n\t\tresult.push(H.x, H.y, H.z, 0);\n\t}\n\n\treturn result;\n};\n\nconst generateLambertSamples = (numSamples, sourceTotalPixels) => {\n\tconst pixelsPerSample = sourceTotalPixels / numSamples;\n\tconst H = new Vec3();\n\tconst result = [];\n\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\themisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));\n\t\tconst pdf = H.z / Math.PI;\n\t\tconst mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);\n\t\tresult.push(H.x, H.y, H.z, mipLevel);\n\t}\n\n\treturn result;\n};\n\nconst requiredSamplesGGX = {\n\t\"16\": {\n\t\t\"2\": 26,\n\t\t\"8\": 20,\n\t\t\"32\": 17,\n\t\t\"128\": 16,\n\t\t\"512\": 16\n\t},\n\t\"32\": {\n\t\t\"2\": 53,\n\t\t\"8\": 40,\n\t\t\"32\": 34,\n\t\t\"128\": 32,\n\t\t\"512\": 32\n\t},\n\t\"128\": {\n\t\t\"2\": 214,\n\t\t\"8\": 163,\n\t\t\"32\": 139,\n\t\t\"128\": 130,\n\t\t\"512\": 128\n\t},\n\t\"1024\": {\n\t\t\"2\": 1722,\n\t\t\"8\": 1310,\n\t\t\"32\": 1114,\n\t\t\"128\": 1041,\n\t\t\"512\": 1025\n\t}\n};\n\nconst getRequiredSamplesGGX = (numSamples, specularPower) => {\n\tconst table = requiredSamplesGGX[numSamples];\n\treturn table && table[specularPower] || numSamples;\n};\n\nconst generateGGXSamples = (numSamples, specularPower, sourceTotalPixels) => {\n\tconst pixelsPerSample = sourceTotalPixels / numSamples;\n\tconst roughness = 1 - Math.log2(specularPower) / 11.0;\n\tconst a = roughness * roughness;\n\tconst H = new Vec3();\n\tconst L = new Vec3();\n\tconst N = new Vec3(0, 0, 1);\n\tconst result = [];\n\tconst requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);\n\n\tfor (let i = 0; i < requiredSamples; ++i) {\n\t\themisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);\n\t\tconst NoH = H.z;\n\t\tL.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);\n\n\t\tif (L.z > 0) {\n\t\t\tconst pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;\n\t\t\tconst mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);\n\t\t\tresult.push(L.x, L.y, L.z, mipLevel);\n\t\t}\n\t}\n\n\twhile (result.length < numSamples * 4) {\n\t\tresult.push(0, 0, 0, 0);\n\t}\n\n\treturn result;\n};\n\nconst createSamplesTex = (device, name, samples) => {\n\tconst packedSamples = packSamples(samples);\n\treturn new Texture(device, {\n\t\tname: name,\n\t\twidth: packedSamples.width,\n\t\theight: packedSamples.height,\n\t\tmipmaps: false,\n\t\tminFilter: FILTER_NEAREST,\n\t\tmagFilter: FILTER_NEAREST,\n\t\tlevels: [packedSamples.data]\n\t});\n};\n\nclass SimpleCache {\n\tconstructor() {\n\t\tthis.map = new Map();\n\t}\n\n\tget(key, missFunc) {\n\t\tif (!this.map.has(key)) {\n\t\t\tconst result = missFunc();\n\t\t\tthis.map.set(key, result);\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.map.get(key);\n\t}\n\n\tclear() {\n\t\tthis.map.clear();\n\t}\n\n}\n\nclass DeviceCache {\n\tconstructor() {\n\t\tthis.cache = new SimpleCache();\n\t}\n\n\tget(device, key, missFunc) {\n\t\treturn this.cache.get(device, () => {\n\t\t\tconst cache = new SimpleCache();\n\t\t\tdevice.on('destroy', () => {\n\t\t\t\tcache.map.forEach((value, key) => {\n\t\t\t\t\tvalue.destroy();\n\t\t\t\t});\n\t\t\t\tthis.cache.map.delete(device);\n\t\t\t});\n\t\t\treturn cache;\n\t\t}).get(key, missFunc);\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t}\n\n}\n\nconst samplesCache = new SimpleCache();\nconst samplesTexCache = new DeviceCache();\n\nconst generateLambertSamplesTex = (device, numSamples, sourceTotalPixels) => {\n\tconst key = `lambert-samples-${numSamples}-${sourceTotalPixels}`;\n\treturn samplesTexCache.get(device, key, () => {\n\t\treturn createSamplesTex(device, key, samplesCache.get(key, () => {\n\t\t\treturn generateLambertSamples(numSamples, sourceTotalPixels);\n\t\t}));\n\t});\n};\n\nconst generatePhongSamplesTex = (device, numSamples, specularPower) => {\n\tconst key = `phong-samples-${numSamples}-${specularPower}`;\n\treturn samplesTexCache.get(device, key, () => {\n\t\treturn createSamplesTex(device, key, samplesCache.get(key, () => {\n\t\t\treturn generatePhongSamples(numSamples, specularPower);\n\t\t}));\n\t});\n};\n\nconst generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels) => {\n\tconst key = `ggx-samples-${numSamples}-${specularPower}-${sourceTotalPixels}`;\n\treturn samplesTexCache.get(device, key, () => {\n\t\treturn createSamplesTex(device, key, samplesCache.get(key, () => {\n\t\t\treturn generateGGXSamples(numSamples, specularPower, sourceTotalPixels);\n\t\t}));\n\t});\n};\n\nconst vsCode = `\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tvUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;\n}\n`;\n\nfunction reprojectTexture(source, target, options = {}) {\n\tvar _options;\n\n\tif (source instanceof GraphicsDevice) {\n\t\tsource = arguments[1];\n\t\ttarget = arguments[2];\n\t\toptions = {};\n\n\t\tif (arguments[3] !== undefined) {\n\t\t\toptions.specularPower = arguments[3];\n\t\t}\n\n\t\tif (arguments[4] !== undefined) {\n\t\t\toptions.numSamples = arguments[4];\n\t\t}\n\t}\n\n\tconst funcNames = {\n\t\t'none': 'reproject',\n\t\t'lambert': 'prefilterSamplesUnweighted',\n\t\t'phong': 'prefilterSamplesUnweighted',\n\t\t'ggx': 'prefilterSamples'\n\t};\n\tconst specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;\n\tconst face = options.hasOwnProperty('face') ? options.face : null;\n\tconst distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';\n\tconst processFunc = funcNames[distribution] || 'reproject';\n\tconst decodeFunc = `decode${getCoding(source)}`;\n\tconst encodeFunc = `encode${getCoding(target)}`;\n\tconst sourceFunc = `sample${getProjectionName(source.projection)}`;\n\tconst targetFunc = `getDirection${getProjectionName(target.projection)}`;\n\tconst numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;\n\tconst shaderKey = `${processFunc}_${decodeFunc}_${encodeFunc}_${sourceFunc}_${targetFunc}_${numSamples}`;\n\tconst device = source.device;\n\tlet shader = device.programLib._cache[shaderKey];\n\n\tif (!shader) {\n\t\tconst defines = `#define PROCESS_FUNC ${processFunc}\\n` + `#define DECODE_FUNC ${decodeFunc}\\n` + `#define ENCODE_FUNC ${encodeFunc}\\n` + `#define SOURCE_FUNC ${sourceFunc}\\n` + `#define TARGET_FUNC ${targetFunc}\\n` + `#define NUM_SAMPLES ${numSamples}\\n` + (device.extTextureLod ? `#define SUPPORTS_TEXLOD\\n` : '');\n\t\tlet extensions = '';\n\n\t\tif (!device.webgl2) {\n\t\t\textensions = '#extension GL_OES_standard_derivatives: enable\\n';\n\n\t\t\tif (device.extTextureLod) {\n\t\t\t\textensions += '#extension GL_EXT_shader_texture_lod: enable\\n\\n';\n\t\t\t}\n\t\t}\n\n\t\tshader = createShaderFromCode(device, vsCode, `${defines}\\n${shaderChunks.reprojectPS}`, shaderKey, false, extensions);\n\t}\n\n\tconst constantSource = device.scope.resolve(source.cubemap ? \"sourceCube\" : \"sourceTex\");\n\tconstantSource.setValue(source);\n\tconst constantParams = device.scope.resolve(\"params\");\n\tconst constantParams2 = device.scope.resolve(\"params2\");\n\tconst uvModParam = device.scope.resolve(\"uvMod\");\n\n\tif ((_options = options) != null && _options.seamPixels) {\n\t\tconst p = options.seamPixels;\n\t\tconst w = options.rect ? options.rect.z : target.width;\n\t\tconst h = options.rect ? options.rect.w : target.height;\n\t\tconst innerWidth = w - p * 2;\n\t\tconst innerHeight = h - p * 2;\n\t\tuvModParam.setValue([(innerWidth + p * 2) / innerWidth, (innerHeight + p * 2) / innerHeight, -p / innerWidth, -p / innerHeight]);\n\t} else {\n\t\tuvModParam.setValue([1, 1, 0, 0]);\n\t}\n\n\tconst params = [0, specularPower, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];\n\tconst params2 = [target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];\n\n\tif (processFunc.startsWith('prefilterSamples')) {\n\t\tconst sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);\n\t\tconst samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);\n\t\tdevice.scope.resolve(\"samplesTex\").setValue(samplesTex);\n\t\tdevice.scope.resolve(\"samplesTexInverseSize\").setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);\n\t}\n\n\tfor (let f = 0; f < (target.cubemap ? 6 : 1); f++) {\n\t\tif (face === null || f === face) {\n\t\t\tvar _options2;\n\n\t\t\tconst renderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: target,\n\t\t\t\tface: f,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tparams[0] = f;\n\t\t\tconstantParams.setValue(params);\n\t\t\tconstantParams2.setValue(params2);\n\t\t\tdrawQuadWithShader(device, renderTarget, shader, (_options2 = options) == null ? void 0 : _options2.rect);\n\t\t\trenderTarget.destroy();\n\t\t}\n\t}\n}\n\nconst fixCubemapSeams = true;\n\nconst calcLevels = (width, height) => {\n\treturn 1 + Math.floor(Math.log2(Math.max(width, height)));\n};\n\nconst supportsFloat16 = device => {\n\treturn device.extTextureHalfFloat && device.textureHalfFloatRenderable;\n};\n\nconst supportsFloat32 = device => {\n\treturn device.extTextureFloat && device.textureFloatRenderable;\n};\n\nconst lightingSourcePixelFormat = device => {\n\treturn supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_R8_G8_B8_A8;\n};\n\nconst lightingPixelFormat = device => {\n\treturn PIXELFORMAT_R8_G8_B8_A8;\n};\n\nconst createCubemap = (device, size, format, mipmaps) => {\n\treturn new Texture(device, {\n\t\tname: `lighting-${size}`,\n\t\tcubemap: true,\n\t\twidth: size,\n\t\theight: size,\n\t\tformat: format,\n\t\ttype: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,\n\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\tfixCubemapSeams: fixCubemapSeams,\n\t\tmipmaps: !!mipmaps\n\t});\n};\n\nclass EnvLighting {\n\tstatic generateSkyboxCubemap(source, size) {\n\t\tconst device = source.device;\n\t\tconst result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_R8_G8_B8_A8, false);\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: 1024\n\t\t});\n\t\treturn result;\n\t}\n\n\tstatic generateLightingSource(source) {\n\t\tconst device = source.device;\n\t\tconst format = lightingSourcePixelFormat(device);\n\t\tconst result = new Texture(device, {\n\t\t\tname: `lighting-source`,\n\t\t\tcubemap: true,\n\t\t\twidth: 128,\n\t\t\theight: 128,\n\t\t\tformat: format,\n\t\t\ttype: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tfixCubemapSeams: false,\n\t\t\tmipmaps: true\n\t\t});\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: source.mipmaps ? 1 : 1024\n\t\t});\n\t\treturn result;\n\t}\n\n\tstatic generateAtlas(source, options) {\n\t\tconst device = source.device;\n\t\tconst format = lightingPixelFormat();\n\t\tconst result = (options == null ? void 0 : options.target) || new Texture(device, {\n\t\t\twidth: 512,\n\t\t\theight: 512,\n\t\t\tformat: format,\n\t\t\ttype: TEXTURETYPE_RGBM ,\n\t\t\tprojection: TEXTUREPROJECTION_EQUIRECT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tmipmaps: false\n\t\t});\n\t\tconst rect = new Vec4(0, 0, 512, 256);\n\t\tconst levels = calcLevels(result.width, result.height);\n\n\t\tfor (let i = 0; i < levels; ++i) {\n\t\t\treprojectTexture(source, result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t\trect.x += rect.w;\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\n\t\trect.set(0, 256, 256, 128);\n\n\t\tfor (let i = 1; i < 7; ++i) {\n\t\t\treprojectTexture(source, result, {\n\t\t\t\tnumSamples: (options == null ? void 0 : options.numSamples) || 1024,\n\t\t\t\tdistribution: (options == null ? void 0 : options.distribution) || 'ggx',\n\t\t\t\tspecularPower: Math.max(1, 2048 >> i * 2),\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\n\t\trect.set(128, 256 + 128, 64, 32);\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: (options == null ? void 0 : options.numSamples) || 2048,\n\t\t\tdistribution: 'lambert',\n\t\t\trect: rect,\n\t\t\tseamPixels: 1\n\t\t});\n\t\treturn result;\n\t}\n\n\tstatic generatePrefilteredAtlas(sources, options) {\n\t\tconst device = sources[0].device;\n\t\tconst format = lightingPixelFormat();\n\t\tconst result = (options == null ? void 0 : options.target) || new Texture(device, {\n\t\t\twidth: 512,\n\t\t\theight: 512,\n\t\t\tformat: format,\n\t\t\ttype: TEXTURETYPE_RGBM ,\n\t\t\tprojection: TEXTUREPROJECTION_EQUIRECT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tmipmaps: false\n\t\t});\n\t\tconst rect = new Vec4(0, 0, 512, 256);\n\t\tconst levels = calcLevels(result.width, result.height);\n\n\t\tfor (let i = 0; i < levels; ++i) {\n\t\t\treprojectTexture(sources[0], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t\trect.x += rect.w;\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\n\t\trect.set(0, 256, 256, 128);\n\n\t\tfor (let i = 1; i < sources.length; ++i) {\n\t\t\treprojectTexture(sources[i], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\n\t\trect.set(128, 256 + 128, 64, 32);\n\n\t\tif (options != null && options.legacyAmbient) {\n\t\t\treprojectTexture(sources[5], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t} else {\n\t\t\treprojectTexture(sources[0], result, {\n\t\t\t\tnumSamples: (options == null ? void 0 : options.numSamples) || 2048,\n\t\t\t\tdistribution: 'lambert',\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\nclass DefaultMaterial {\n\tstatic get(device) {\n\t\tconst material = this.cache.get(device);\n\t\treturn material;\n\t}\n\n\tstatic add(device, material) {\n\t\tthis.cache.set(device, material);\n\t}\n\n\tstatic remove(device) {\n\t\tthis.cache.delete(device);\n\t}\n\n}\n\nDefaultMaterial.cache = new Map();\n\nlet id$2 = 0;\n\nclass Material {\n\tconstructor() {\n\t\tthis.name = \"Untitled\";\n\t\tthis.id = id$2++;\n\t\tthis._shader = null;\n\t\tthis.variants = {};\n\t\tthis.parameters = {};\n\t\tthis.alphaTest = 0;\n\t\tthis.alphaToCoverage = false;\n\t\tthis.blend = false;\n\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\tthis.blendDst = BLENDMODE_ZERO;\n\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\tthis.separateAlphaBlend = false;\n\t\tthis.blendSrcAlpha = BLENDMODE_ONE;\n\t\tthis.blendDstAlpha = BLENDMODE_ZERO;\n\t\tthis.blendAlphaEquation = BLENDEQUATION_ADD;\n\t\tthis.cull = CULLFACE_BACK;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\t\tthis.stencilFront = null;\n\t\tthis.stencilBack = null;\n\t\tthis.depthBias = 0;\n\t\tthis.slopeDepthBias = 0;\n\t\tthis.redWrite = true;\n\t\tthis.greenWrite = true;\n\t\tthis.blueWrite = true;\n\t\tthis.alphaWrite = true;\n\t\tthis.meshInstances = [];\n\t\tthis._shaderVersion = 0;\n\t\tthis._scene = null;\n\t\tthis._dirtyBlend = false;\n\t\tthis.dirty = true;\n\t}\n\n\tset shader(shader) {\n\t\tthis._shader = shader;\n\t}\n\n\tget shader() {\n\t\treturn this._shader;\n\t}\n\n\tget transparent() {\n\t\treturn this.blend || this.blendSrc !== BLENDMODE_ONE || this.blendDst !== BLENDMODE_ZERO || this.blendEquation !== BLENDEQUATION_ADD;\n\t}\n\n\tset blendType(type) {\n\t\tconst prevBlend = this.blend;\n\n\t\tswitch (type) {\n\t\t\tcase BLEND_NONE:\n\t\t\t\tthis.blend = false;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ZERO;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_NORMAL:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_SRC_ALPHA;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_PREMULTIPLIED:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_ADDITIVE:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_ADDITIVEALPHA:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_SRC_ALPHA;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_MULTIPLICATIVE2X:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_DST_COLOR;\n\t\t\t\tthis.blendDst = BLENDMODE_SRC_COLOR;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_SCREEN:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE_MINUS_DST_COLOR;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_MULTIPLICATIVE:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_DST_COLOR;\n\t\t\t\tthis.blendDst = BLENDMODE_ZERO;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_MIN:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_MIN;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_MAX:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_MAX;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (prevBlend !== this.blend) {\n\t\t\tif (this._scene) {\n\t\t\t\tthis._scene.layers._dirtyBlend = true;\n\t\t\t} else {\n\t\t\t\tthis._dirtyBlend = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._updateMeshInstanceKeys();\n\t}\n\n\tget blendType() {\n\t\tif (!this.transparent) {\n\t\t\treturn BLEND_NONE;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_NORMAL;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_ADDITIVE;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_ADDITIVEALPHA;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_SRC_COLOR && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_MULTIPLICATIVE2X;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_SCREEN;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MIN) {\n\t\t\treturn BLEND_MIN;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MAX) {\n\t\t\treturn BLEND_MAX;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_ZERO && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_MULTIPLICATIVE;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_PREMULTIPLIED;\n\t\t}\n\n\t\treturn BLEND_NORMAL;\n\t}\n\n\tcopy(source) {\n\t\tthis.name = source.name;\n\t\tthis.shader = source.shader;\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.blend = source.blend;\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.separateAlphaBlend = source.separateAlphaBlend;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendAlphaEquation = source.blendAlphaEquation;\n\t\tthis.cull = source.cull;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\t\tthis.depthBias = source.depthBias;\n\t\tthis.slopeDepthBias = source.slopeDepthBias;\n\t\tif (source.stencilFront) this.stencilFront = source.stencilFront.clone();\n\n\t\tif (source.stencilBack) {\n\t\t\tif (source.stencilFront === source.stencilBack) {\n\t\t\t\tthis.stencilBack = this.stencilFront;\n\t\t\t} else {\n\t\t\t\tthis.stencilBack = source.stencilBack.clone();\n\t\t\t}\n\t\t}\n\n\t\tthis.redWrite = source.redWrite;\n\t\tthis.greenWrite = source.greenWrite;\n\t\tthis.blueWrite = source.blueWrite;\n\t\tthis.alphaWrite = source.alphaWrite;\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst clone = new this.constructor();\n\t\treturn clone.copy(this);\n\t}\n\n\t_updateMeshInstanceKeys() {\n\t\tconst meshInstances = this.meshInstances;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].updateKey();\n\t\t}\n\t}\n\n\tupdateUniforms(device, scene) {}\n\n\tupdateShader(device, scene, objDefs) {}\n\n\tupdate() {\n\t\tthis.dirty = true;\n\t\tif (this._shader) this._shader.failed = false;\n\t}\n\n\tclearParameters() {\n\t\tthis.parameters = {};\n\t}\n\n\tgetParameters() {\n\t\treturn this.parameters;\n\t}\n\n\tclearVariants() {\n\t\tthis.variants = {};\n\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\n\t\t\tfor (let j = 0; j < meshInstance._shader.length; j++) {\n\t\t\t\tmeshInstance._shader[j] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetParameter(name) {\n\t\treturn this.parameters[name];\n\t}\n\n\tsetParameter(name, data) {\n\t\tif (data === undefined && typeof name === 'object') {\n\t\t\tconst uniformObject = name;\n\n\t\t\tif (uniformObject.length) {\n\t\t\t\tfor (let i = 0; i < uniformObject.length; i++) {\n\t\t\t\t\tthis.setParameter(uniformObject[i]);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tname = uniformObject.name;\n\t\t\tdata = uniformObject.value;\n\t\t}\n\n\t\tconst param = this.parameters[name];\n\n\t\tif (param) {\n\t\t\tparam.data = data;\n\t\t} else {\n\t\t\tthis.parameters[name] = {\n\t\t\t\tscopeId: null,\n\t\t\t\tdata: data\n\t\t\t};\n\t\t}\n\t}\n\n\tdeleteParameter(name) {\n\t\tif (this.parameters[name]) {\n\t\t\tdelete this.parameters[name];\n\t\t}\n\t}\n\n\tsetParameters(device, names) {\n\t\tconst parameters = this.parameters;\n\t\tif (names === undefined) names = parameters;\n\n\t\tfor (const paramName in names) {\n\t\t\tconst parameter = parameters[paramName];\n\n\t\t\tif (parameter) {\n\t\t\t\tif (!parameter.scopeId) {\n\t\t\t\t\tparameter.scopeId = device.scope.resolve(paramName);\n\t\t\t\t}\n\n\t\t\t\tparameter.scopeId.setValue(parameter.data);\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis.variants = {};\n\t\tthis.shader = null;\n\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\n\t\t\tfor (let j = 0; j < meshInstance._shader.length; j++) {\n\t\t\t\tmeshInstance._shader[j] = null;\n\t\t\t}\n\n\t\t\tmeshInstance._material = null;\n\n\t\t\tif (meshInstance.mesh) {\n\t\t\t\tconst defaultMaterial = DefaultMaterial.get(meshInstance.mesh.device);\n\n\t\t\t\tif (this !== defaultMaterial) {\n\t\t\t\t\tmeshInstance.material = defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taddMeshInstanceRef(meshInstance) {\n\t\tthis.meshInstances.push(meshInstance);\n\t}\n\n\tremoveMeshInstanceRef(meshInstance) {\n\t\tconst meshInstances = this.meshInstances;\n\t\tconst i = meshInstances.indexOf(meshInstance);\n\n\t\tif (i !== -1) {\n\t\t\tmeshInstances.splice(i, 1);\n\t\t}\n\t}\n\n}\n\nconst arraysEqual = (a, b) => {\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; ++i) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nconst notWhite = color => {\n\treturn color.r !== 1 || color.g !== 1 || color.b !== 1;\n};\n\nconst notBlack = color => {\n\treturn color.r !== 0 || color.g !== 0 || color.b !== 0;\n};\n\nclass StandardMaterialOptionsBuilder {\n\tconstructor() {\n\t\tthis._mapXForms = null;\n\t}\n\n\tupdateMinRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {\n\t\tthis._updateSharedOptions(options, scene, stdMat, objDefs, pass);\n\n\t\tthis._updateMinOptions(options, stdMat);\n\n\t\tthis._updateUVOptions(options, stdMat, objDefs, true);\n\t}\n\n\tupdateRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {\n\t\tthis._updateSharedOptions(options, scene, stdMat, objDefs, pass);\n\n\t\tthis._updateEnvOptions(options, device, stdMat, scene);\n\n\t\tthis._updateMaterialOptions(options, stdMat);\n\n\t\tif (pass === SHADER_FORWARDHDR) {\n\t\t\tif (options.gamma) options.gamma = GAMMA_SRGBHDR;\n\t\t\toptions.toneMap = TONEMAP_LINEAR;\n\t\t}\n\n\t\toptions.hasTangents = objDefs && stdMat.normalMap && (objDefs & SHADERDEF_TANGENTS) !== 0;\n\n\t\tthis._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);\n\n\t\tthis._updateUVOptions(options, stdMat, objDefs, false);\n\t}\n\n\t_updateSharedOptions(options, scene, stdMat, objDefs, pass) {\n\t\toptions.pass = pass;\n\t\toptions.alphaTest = stdMat.alphaTest > 0;\n\t\toptions.forceFragmentPrecision = stdMat.forceFragmentPrecision || \"\";\n\t\toptions.chunks = stdMat.chunks || \"\";\n\t\toptions.blendType = stdMat.blendType;\n\t\toptions.forceUv1 = stdMat.forceUv1;\n\t\toptions.separateAmbient = false;\n\t\toptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;\n\t\toptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;\n\t\toptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;\n\t\toptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;\n\t\toptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;\n\t\toptions.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;\n\t\toptions.nineSlicedMode = stdMat.nineSlicedMode || 0;\n\n\t\tif (scene.clusteredLightingEnabled) {\n\t\t\toptions.clusteredLightingEnabled = true;\n\t\t\toptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;\n\t\t\toptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;\n\t\t\toptions.clusteredLightingShadowType = scene.lighting.shadowType;\n\t\t\toptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;\n\t\t}\n\t}\n\n\t_updateUVOptions(options, stdMat, objDefs, minimalOptions) {\n\t\tlet hasUv0 = false;\n\t\tlet hasUv1 = false;\n\t\tlet hasVcolor = false;\n\n\t\tif (objDefs) {\n\t\t\thasUv0 = (objDefs & SHADERDEF_UV0) !== 0;\n\t\t\thasUv1 = (objDefs & SHADERDEF_UV1) !== 0;\n\t\t\thasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;\n\t\t}\n\n\t\toptions.vertexColors = false;\n\t\tthis._mapXForms = [];\n\n\t\tfor (const p in _matTex2D) {\n\t\t\tthis._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);\n\t\t}\n\n\t\tthis._mapXForms = null;\n\t}\n\n\t_updateMinOptions(options, stdMat) {\n\t\toptions.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;\n\t\toptions.lights = [];\n\t}\n\n\t_updateMaterialOptions(options, stdMat) {\n\t\tconst diffuseTint = (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) && notWhite(stdMat.diffuse);\n\t\tconst useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);\n\t\tconst specularTint = useSpecular && !stdMat.useMetalness && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);\n\t\tconst emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;\n\t\tconst emissiveTintIntensity = stdMat.emissiveIntensity !== 1;\n\t\tconst isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;\n\t\toptions.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE ? 1 : 0;\n\t\toptions.blendMapsWithColors = true;\n\t\toptions.ambientTint = stdMat.ambientTint;\n\t\toptions.diffuseTint = diffuseTint ? 2 : 0;\n\t\toptions.specularTint = specularTint ? 2 : 0;\n\t\toptions.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;\n\t\toptions.glossTint = 1;\n\t\toptions.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);\n\t\toptions.alphaToCoverage = stdMat.alphaToCoverage;\n\t\toptions.normalizeNormalMap = stdMat.normalizeNormalMap;\n\t\toptions.ambientSH = !!stdMat.ambientSH;\n\t\toptions.useSpecular = useSpecular;\n\t\toptions.emissiveFormat = stdMat.emissiveMap ? stdMat.emissiveMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.emissiveMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;\n\t\toptions.lightMapFormat = stdMat.lightMap ? stdMat.lightMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.lightMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;\n\t\toptions.specularAntialias = stdMat.specularAntialias && !!stdMat.normalMap && !!stdMat.normalMap.mipmaps && !isPackedNormalMap;\n\t\toptions.conserveEnergy = stdMat.conserveEnergy;\n\t\toptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;\n\t\toptions.alphaFade = stdMat.alphaFade;\n\t\toptions.occludeSpecular = stdMat.occludeSpecular;\n\t\toptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;\n\t\toptions.occludeDirect = stdMat.occludeDirect;\n\t\toptions.shadingModel = stdMat.shadingModel;\n\t\toptions.fresnelModel = stdMat.fresnelModel;\n\t\toptions.packedNormal = isPackedNormalMap;\n\t\toptions.fastTbn = stdMat.fastTbn;\n\t\toptions.cubeMapProjection = stdMat.cubeMapProjection;\n\t\toptions.customFragmentShader = stdMat.customFragmentShader;\n\t\toptions.refraction = !!stdMat.refraction;\n\t\toptions.useMetalness = stdMat.useMetalness;\n\t\toptions.enableGGXSpecular = stdMat.enableGGXSpecular;\n\t\toptions.msdf = !!stdMat.msdfMap;\n\t\toptions.twoSidedLighting = stdMat.twoSidedLighting;\n\t\toptions.pixelSnap = stdMat.pixelSnap;\n\t\toptions.aoMapUv = stdMat.aoUvSet;\n\t\toptions.diffuseDetail = !!stdMat.diffuseMap;\n\t\toptions.normalDetail = !!stdMat.normalMap;\n\t\toptions.diffuseDetailMode = stdMat.diffuseDetailMode;\n\t\toptions.detailModes = !!options.diffuseDetail;\n\t\toptions.clearCoat = !!stdMat.clearCoat;\n\t\toptions.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;\n\t\toptions.clearCoatGlossiness = !!stdMat.clearCoatGlossiness;\n\t\toptions.clearCoatGlossTint = stdMat.clearCoatGlossiness !== 1.0 ? 1 : 0;\n\t}\n\n\t_updateEnvOptions(options, device, stdMat, scene) {\n\t\toptions.fog = stdMat.useFog ? scene.fog : \"none\";\n\t\toptions.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;\n\t\toptions.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;\n\t\toptions.useRgbm = stdMat.emissiveMap && stdMat.emissiveMap.type === TEXTURETYPE_RGBM || stdMat.lightMap && stdMat.lightMap.type === TEXTURETYPE_RGBM;\n\t\toptions.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;\n\t\toptions.skyboxIntensity = scene.skyboxIntensity !== 1;\n\t\tconst isPhong = stdMat.shadingModel === SPECULAR_PHONG;\n\t\tlet usingSceneEnv = false;\n\n\t\tif (stdMat.envAtlas && !isPhong) {\n\t\t\toptions.reflectionSource = 'envAtlas';\n\t\t\toptions.reflectionEncoding = stdMat.envAtlas.encoding;\n\t\t} else if (stdMat.cubeMap) {\n\t\t\toptions.reflectionSource = 'cubeMap';\n\t\t\toptions.reflectionEncoding = stdMat.cubeMap.encoding;\n\t\t} else if (stdMat.sphereMap) {\n\t\t\toptions.reflectionSource = 'sphereMap';\n\t\t\toptions.reflectionEncoding = stdMat.sphereMap.encoding;\n\t\t} else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {\n\t\t\toptions.reflectionSource = 'envAtlas';\n\t\t\toptions.reflectionEncoding = scene.envAtlas.encoding;\n\t\t\tusingSceneEnv = true;\n\t\t} else {\n\t\t\toptions.reflectionSource = null;\n\t\t\toptions.reflectionEncoding = null;\n\t\t}\n\n\t\tif (stdMat.ambientSH && !isPhong) {\n\t\t\toptions.ambientSource = 'ambientSH';\n\t\t\toptions.ambientEncoding = null;\n\t\t} else {\n\t\t\tconst envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);\n\n\t\t\tif (envAtlas && !isPhong) {\n\t\t\t\toptions.ambientSource = 'envAtlas';\n\t\t\t\toptions.ambientEncoding = envAtlas.encoding;\n\t\t\t} else {\n\t\t\t\toptions.ambientSource = 'constant';\n\t\t\t\toptions.ambientEncoding = null;\n\t\t\t}\n\t\t}\n\n\t\toptions.useCubeMapRotation = usingSceneEnv && scene.skyboxRotation && !scene.skyboxRotation.equals(Quat.IDENTITY);\n\t}\n\n\t_updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList) {\n\t\toptions.lightMap = false;\n\t\toptions.lightMapChannel = \"\";\n\t\toptions.lightMapUv = 0;\n\t\toptions.lightMapTransform = 0;\n\t\toptions.lightMapWithoutAmbient = false;\n\t\toptions.dirLightMap = false;\n\n\t\tif (objDefs) {\n\t\t\toptions.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;\n\n\t\t\tif ((objDefs & SHADERDEF_LM) !== 0) {\n\t\t\t\toptions.lightMapFormat = 1;\n\t\t\t\toptions.lightMap = true;\n\t\t\t\toptions.lightMapChannel = \"rgb\";\n\t\t\t\toptions.lightMapUv = 1;\n\t\t\t\toptions.lightMapTransform = 0;\n\t\t\t\toptions.lightMapWithoutAmbient = !stdMat.lightMap;\n\t\t\t\toptions.useRgbm = true;\n\n\t\t\t\tif ((objDefs & SHADERDEF_DIRLM) !== 0) {\n\t\t\t\t\toptions.dirLightMap = true;\n\t\t\t\t}\n\n\t\t\t\tif ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {\n\t\t\t\t\toptions.lightMapWithoutAmbient = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (stdMat.useLighting) {\n\t\t\tconst lightsFiltered = [];\n\t\t\tconst mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;\n\t\t\toptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);\n\n\t\t\tif (sortedLights) {\n\t\t\t\tthis._collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);\n\n\t\t\t\tthis._collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask, staticLightList);\n\n\t\t\t\tthis._collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);\n\t\t\t}\n\n\t\t\toptions.lights = lightsFiltered;\n\t\t} else {\n\t\t\toptions.lights = [];\n\t\t}\n\n\t\tif (options.lights.length === 0) {\n\t\t\toptions.noShadow = true;\n\t\t}\n\t}\n\n\t_updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {\n\t\tconst mname = p + \"Map\";\n\t\tconst vname = p + \"VertexColor\";\n\t\tconst vcname = p + \"VertexColorChannel\";\n\t\tconst cname = mname + \"Channel\";\n\t\tconst tname = mname + \"Transform\";\n\t\tconst uname = mname + \"Uv\";\n\n\t\tif (p !== \"light\") {\n\t\t\toptions[mname] = false;\n\t\t\toptions[cname] = \"\";\n\t\t\toptions[tname] = 0;\n\t\t\toptions[uname] = 0;\n\t\t}\n\n\t\toptions[vname] = false;\n\t\toptions[vcname] = \"\";\n\t\tconst isOpacity = p === \"opacity\";\n\t\tif (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) return options;\n\n\t\tif (!minimalOptions || isOpacity) {\n\t\t\tif (p !== \"height\" && stdMat[vname]) {\n\t\t\t\tif (hasVcolor) {\n\t\t\t\t\toptions[vname] = stdMat[vname];\n\t\t\t\t\toptions[vcname] = stdMat[vcname];\n\t\t\t\t\toptions.vertexColors = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (stdMat[mname]) {\n\t\t\t\tlet allow = true;\n\t\t\t\tif (stdMat[uname] === 0 && !hasUv0) allow = false;\n\t\t\t\tif (stdMat[uname] === 1 && !hasUv1) allow = false;\n\n\t\t\t\tif (allow) {\n\t\t\t\t\toptions[mname] = !!stdMat[mname];\n\t\t\t\t\toptions[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);\n\t\t\t\t\toptions[cname] = stdMat[cname];\n\t\t\t\t\toptions[uname] = stdMat[uname];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_collectLights(lType, lights, lightsFiltered, mask, staticLightList) {\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\n\t\t\tif (light.enabled) {\n\t\t\t\tif (light.mask & mask) {\n\t\t\t\t\tif (lType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\t\tif (light.isStatic) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlightsFiltered.push(light);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (staticLightList) {\n\t\t\tfor (let i = 0; i < staticLightList.length; i++) {\n\t\t\t\tconst light = staticLightList[i];\n\n\t\t\t\tif (light._type === lType) {\n\t\t\t\t\tlightsFiltered.push(light);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_getMapTransformID(xform, uv) {\n\t\tif (!xform) return 0;\n\t\tlet xforms = this._mapXForms[uv];\n\n\t\tif (!xforms) {\n\t\t\txforms = [];\n\t\t\tthis._mapXForms[uv] = xforms;\n\t\t}\n\n\t\tfor (let i = 0; i < xforms.length; i++) {\n\t\t\tif (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn xforms.push(xform);\n\t}\n\n}\n\nconst standardMaterialParameterTypes = {\n\tname: 'string',\n\tchunks: 'chunks',\n\tmappingFormat: 'string',\n\t_engine: 'boolean',\n\tambient: 'rgb',\n\tambientTint: 'boolean',\n\taoVertexColor: 'boolean',\n\taoVertexColorChannel: 'string',\n\taoMap: 'texture',\n\taoMapChannel: 'string',\n\taoMapUv: 'number',\n\taoMapTiling: 'vec2',\n\taoMapOffset: 'vec2',\n\taoMapRotation: 'number',\n\tdiffuse: 'rgb',\n\tdiffuseTint: 'boolean',\n\tdiffuseVertexColor: 'boolean',\n\tdiffuseVertexColorChannel: 'string',\n\tdiffuseMap: 'texture',\n\tdiffuseMapChannel: 'string',\n\tdiffuseMapUv: 'number',\n\tdiffuseMapTiling: 'vec2',\n\tdiffuseMapOffset: 'vec2',\n\tdiffuseMapRotation: 'number',\n\tdiffuseDetailMap: 'texture',\n\tdiffuseDetailMapChannel: 'string',\n\tdiffuseDetailMapUv: 'number',\n\tdiffuseDetailMapTiling: 'vec2',\n\tdiffuseDetailMapOffset: 'vec2',\n\tdiffuseDetailMapRotation: 'number',\n\tdiffuseDetailMode: 'string',\n\tspecular: 'rgb',\n\tspecularTint: 'boolean',\n\tspecularVertexColor: 'boolean',\n\tspecularVertexColorChannel: 'string',\n\tspecularMap: 'texture',\n\tspecularMapChannel: 'string',\n\tspecularMapUv: 'number',\n\tspecularMapTiling: 'vec2',\n\tspecularMapOffset: 'vec2',\n\tspecularMapRotation: 'number',\n\tspecularAntialias: 'boolean',\n\toccludeSpecular: 'enum:occludeSpecular',\n\tuseMetalness: 'boolean',\n\tmetalness: 'number',\n\tenableGGXSpecular: 'boolean',\n\tanisotropy: 'number',\n\tmetalnessTint: 'boolean',\n\tmetalnessVertexColor: 'boolean',\n\tmetalnessVertexColorChannel: 'string',\n\tmetalnessMap: 'texture',\n\tmetalnessMapChannel: 'string',\n\tmetalnessMapUv: 'number',\n\tmetalnessMapTiling: 'vec2',\n\tmetalnessMapOffset: 'vec2',\n\tnetalnessMapRotation: 'number',\n\tconserveEnergy: 'boolean',\n\tshininess: 'number',\n\tglossVertexColor: 'boolean',\n\tglossVertexColorChannel: 'string',\n\tglossMap: 'texture',\n\tglossMapChannel: 'string',\n\tglossMapUv: 'number',\n\tglossMapTiling: 'vec2',\n\tglossMapOffset: 'vec2',\n\tglossMapRotation: 'number',\n\tclearCoat: 'number',\n\tclearCoatVertexColor: 'boolean',\n\tclearCoatVertexColorChannel: 'string',\n\tclearCoatMap: 'texture',\n\tclearCoatMapChannel: 'string',\n\tclearCoatMapUv: 'number',\n\tclearCoatMapTiling: 'vec2',\n\tclearCoatMapOffset: 'vec2',\n\tclearCoatMapRotation: 'number',\n\tclearCoatGlossiness: 'number',\n\tclearCoatGlossVertexColor: 'boolean',\n\tclearCoatGlossVertexColorChannel: 'string',\n\tclearCoatGlossMap: 'texture',\n\tclearCoatGlossMapChannel: 'string',\n\tclearCoatGlossMapUv: 'number',\n\tclearCoatGlossMapTiling: 'vec2',\n\tclearCoatGlossMapOffset: 'vec2',\n\tclearCoatGlossMapRotation: 'number',\n\tclearCoatBumpiness: 'number',\n\tclearCoatNormalMap: 'texture',\n\tclearCoatNormalMapUv: 'number',\n\tclearCoatNormalMapTiling: 'vec2',\n\tclearCoatNormalMapOffset: 'vec2',\n\tclearCoatNormalMapRotation: 'number',\n\tfresnelModel: 'number',\n\temissive: 'rgb',\n\temissiveTint: 'boolean',\n\temissiveVertexColor: 'boolean',\n\temissiveVertexColorChannel: 'string',\n\temissiveMap: 'texture',\n\temissiveMapChannel: 'string',\n\temissiveMapUv: 'number',\n\temissiveMapTiling: 'vec2',\n\temissiveMapOffset: 'vec2',\n\temissiveMapMapRotation: 'number',\n\temissiveIntensity: 'number',\n\tnormalMap: 'texture',\n\tnormalMapTiling: 'vec2',\n\tnormalMapOffset: 'vec2',\n\tnormalMapRotation: 'number',\n\tnormalMapUv: 'number',\n\tbumpiness: 'number',\n\tnormalDetailMap: 'texture',\n\tnormalDetailMapTiling: 'vec2',\n\tnormalDetailMapOffset: 'vec2',\n\tnormalDetailMapRotation: 'number',\n\tnormalDetailMapUv: 'number',\n\tnormalDetailMapBumpiness: 'number',\n\theightMap: 'texture',\n\theightMapChannel: 'string',\n\theightMapUv: 'number',\n\theightMapTiling: 'vec2',\n\theightMapOffset: 'vec2',\n\theightMapRotation: 'number',\n\theightMapFactor: 'number',\n\talphaToCoverage: 'boolean',\n\talphaTest: 'number',\n\talphaFade: 'number',\n\topacity: 'number',\n\topacityVertexColor: 'boolean',\n\topacityVertexColorChannel: 'string',\n\topacityMap: 'texture',\n\topacityMapChannel: 'string',\n\topacityMapUv: 'number',\n\topacityMapTiling: 'vec2',\n\topacityMapOffset: 'vec2',\n\topacityMapRotation: 'number',\n\topacityFadesSpecular: 'boolean',\n\treflectivity: 'number',\n\trefraction: 'number',\n\trefractionIndex: 'number',\n\tsphereMap: 'texture',\n\tcubeMap: 'cubemap',\n\tcubeMapProjection: 'number',\n\tcubeMapProjectionBox: 'boundingbox',\n\tlightVertexColor: 'boolean',\n\tlightVertexColorChannel: 'string',\n\tlightMap: 'texture',\n\tlightMapChannel: 'string',\n\tlightMapUv: 'number',\n\tlightMapTiling: 'vec2',\n\tlightMapOffset: 'vec2',\n\tlightMapRotation: 'number',\n\tdepthTest: 'boolean',\n\tdepthWrite: 'boolean',\n\tdepthBias: 'number',\n\tslopeDepthBias: 'number',\n\tcull: 'enum:cull',\n\tblendType: 'enum:blendType',\n\tshadingModel: 'enum:shadingModel',\n\tuseFog: 'boolean',\n\tuseLighting: 'boolean',\n\tuseSkybox: 'boolean',\n\tuseGammaTonemap: 'boolean',\n\tenvAtlas: 'texture'\n};\nconst standardMaterialTextureParameters = [];\n\nfor (const key in standardMaterialParameterTypes) {\n\tconst type = standardMaterialParameterTypes[key];\n\n\tif (type === 'texture') {\n\t\tstandardMaterialTextureParameters.push(key);\n\t}\n}\n\nconst standardMaterialCubemapParameters = [];\n\nfor (const key in standardMaterialParameterTypes) {\n\tconst type = standardMaterialParameterTypes[key];\n\n\tif (type === 'cubemap') {\n\t\tstandardMaterialCubemapParameters.push(key);\n\t}\n}\n\nconst _props = {};\nconst _uniforms = {};\n\nlet _params = new Set();\n\nclass StandardMaterial extends Material {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._dirtyShader = true;\n\t\tthis._assetReferences = {};\n\t\tthis._activeParams = new Set();\n\t\tthis._activeLightingParams = new Set();\n\t\tthis.shaderOptBuilder = new StandardMaterialOptionsBuilder();\n\t\tthis.reset();\n\t}\n\n\treset() {\n\t\tObject.keys(_props).forEach(name => {\n\t\t\tthis[`_${name}`] = _props[name].value();\n\t\t});\n\t\tthis._chunks = {};\n\t\tthis._uniformCache = {};\n\t}\n\n\tset chunks(value) {\n\t\tthis._dirtyShader = true;\n\t\tthis._chunks = value;\n\t}\n\n\tget chunks() {\n\t\tthis._dirtyShader = true;\n\t\treturn this._chunks;\n\t}\n\n\tcopy(source) {\n\t\tsuper.copy(source);\n\t\tObject.keys(_props).forEach(k => {\n\t\t\tthis[k] = source[k];\n\t\t});\n\n\t\tfor (const p in source._chunks) {\n\t\t\tif (source._chunks.hasOwnProperty(p)) this._chunks[p] = source._chunks[p];\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t_setParameter(name, value) {\n\t\t_params.add(name);\n\n\t\tthis.setParameter(name, value);\n\t}\n\n\t_setParameters(parameters) {\n\t\tparameters.forEach(v => {\n\t\t\tthis._setParameter(v.name, v.value);\n\t\t});\n\t}\n\n\t_processParameters(paramsName) {\n\t\tconst prevParams = this[paramsName];\n\t\tprevParams.forEach(param => {\n\t\t\tif (!_params.has(param)) {\n\t\t\t\tdelete this.parameters[param];\n\t\t\t}\n\t\t});\n\t\tthis[paramsName] = _params;\n\t\t_params = prevParams;\n\n\t\t_params.clear();\n\t}\n\n\t_updateMap(p) {\n\t\tconst mname = p + \"Map\";\n\t\tconst map = this[mname];\n\n\t\tif (map) {\n\t\t\tthis._setParameter(\"texture_\" + mname, map);\n\n\t\t\tconst tname = mname + \"Transform\";\n\t\t\tconst uniform = this.getUniform(tname);\n\n\t\t\tif (uniform) {\n\t\t\t\tthis._setParameters(uniform);\n\t\t\t}\n\t\t}\n\t}\n\n\t_allocUniform(name, allocFunc) {\n\t\tlet uniform = this._uniformCache[name];\n\n\t\tif (!uniform) {\n\t\t\tuniform = allocFunc();\n\t\t\tthis._uniformCache[name] = uniform;\n\t\t}\n\n\t\treturn uniform;\n\t}\n\n\tgetUniform(name, device, scene) {\n\t\treturn _uniforms[name](this, device, scene);\n\t}\n\n\tupdateUniforms(device, scene) {\n\t\tconst getUniform = name => {\n\t\t\treturn this.getUniform(name, device, scene);\n\t\t};\n\n\t\tthis._setParameter('material_ambient', getUniform('ambient'));\n\n\t\tif (!this.diffuseMap || this.diffuseTint) {\n\t\t\tthis._setParameter('material_diffuse', getUniform('diffuse'));\n\t\t}\n\n\t\tif (!this.useMetalness) {\n\t\t\tif (!this.specularMap || this.specularTint) {\n\t\t\t\tthis._setParameter('material_specular', getUniform('specular'));\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this.metalnessMap || this.metalness < 1) {\n\t\t\t\tthis._setParameter('material_metalness', this.metalness);\n\t\t\t}\n\t\t}\n\n\t\tif (this.enableGGXSpecular) {\n\t\t\tthis._setParameter('material_anisotropy', this.anisotropy);\n\t\t}\n\n\t\tif (this.clearCoat > 0) {\n\t\t\tthis._setParameter('material_clearCoat', this.clearCoat);\n\n\t\t\tthis._setParameter('material_clearCoatGlossiness', this.clearCoatGlossiness);\n\n\t\t\tthis._setParameter('material_clearCoatReflectivity', this.clearCoat);\n\n\t\t\tthis._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);\n\t\t}\n\n\t\tthis._setParameter(\"material_shininess\", getUniform('shininess'));\n\n\t\tif (!this.emissiveMap || this.emissiveTint) {\n\t\t\tthis._setParameter('material_emissive', getUniform('emissive'));\n\t\t}\n\n\t\tif (this.emissiveIntensity !== 1) {\n\t\t\tthis._setParameter('material_emissiveIntensity', this.emissiveIntensity);\n\t\t}\n\n\t\tif (this.refraction > 0) {\n\t\t\tthis._setParameter('material_refraction', this.refraction);\n\n\t\t\tthis._setParameter('material_refractionIndex', this.refractionIndex);\n\t\t}\n\n\t\tthis._setParameter('material_opacity', this.opacity);\n\n\t\tif (this.opacityFadesSpecular === false) {\n\t\t\tthis._setParameter('material_alphaFade', this.alphaFade);\n\t\t}\n\n\t\tif (this.occludeSpecular) {\n\t\t\tthis._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);\n\t\t}\n\n\t\tif (this.cubeMapProjection === CUBEPROJ_BOX) {\n\t\t\tthis._setParameter(getUniform(\"cubeMapProjectionBox\"));\n\t\t}\n\n\t\tfor (const p in _matTex2D) {\n\t\t\tthis._updateMap(p);\n\t\t}\n\n\t\tif (this.ambientSH) {\n\t\t\tthis._setParameter('ambientSH[0]', this.ambientSH);\n\t\t}\n\n\t\tif (this.normalMap) {\n\t\t\tthis._setParameter('material_bumpiness', this.bumpiness);\n\t\t}\n\n\t\tif (this.normalMap && this.normalDetailMap) {\n\t\t\tthis._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);\n\t\t}\n\n\t\tif (this.heightMap) {\n\t\t\tthis._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));\n\t\t}\n\n\t\tif (this.cubeMap) {\n\t\t\tthis._setParameter('texture_cubeMap', this.cubeMap);\n\t\t}\n\n\t\tif (this.sphereMap) {\n\t\t\tthis._setParameter('texture_sphereMap', this.sphereMap);\n\t\t}\n\n\t\tthis._setParameter('material_reflectivity', this.reflectivity);\n\n\t\tthis._processParameters('_activeParams');\n\n\t\tif (this._dirtyShader) {\n\t\t\tthis.shader = null;\n\t\t\tthis.clearVariants();\n\t\t}\n\t}\n\n\tupdateEnvUniforms(device, scene) {\n\t\tconst envAtlas = this.envAtlas || (this.useSkybox ? scene.envAtlas : null);\n\n\t\tif (envAtlas) {\n\t\t\tthis._setParameter('texture_envAtlas', envAtlas);\n\n\t\t\tif (this.useSkybox && !scene.skyboxRotation.equals(Quat.IDENTITY) && scene._skyboxRotationMat3) {\n\t\t\t\tthis._setParameter('cubeMapRotationMatrix', scene._skyboxRotationMat3.data);\n\t\t\t}\n\t\t}\n\n\t\tthis._processParameters('_activeLightingParams');\n\t}\n\n\tupdateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {\n\t\tthis.updateEnvUniforms(device, scene);\n\t\tconst minimalOptions = pass > SHADER_FORWARDHDR && pass <= SHADER_PICK;\n\t\tlet options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;\n\t\tif (minimalOptions) this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);else this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);\n\n\t\tif (this.onUpdateShader) {\n\t\t\toptions = this.onUpdateShader(options);\n\t\t}\n\n\t\tconst library = device.getProgramLibrary();\n\t\tthis.shader = library.getProgram('standard', options);\n\n\t\tif (!objDefs) {\n\t\t\tthis.clearVariants();\n\t\t\tthis.variants[0] = this.shader;\n\t\t}\n\n\t\tthis._dirtyShader = false;\n\t}\n\n\tdestroy() {\n\t\tfor (const asset in this._assetReferences) {\n\t\t\tthis._assetReferences[asset]._unbind();\n\t\t}\n\n\t\tthis._assetReferences = null;\n\t\tsuper.destroy();\n\t}\n\n}\n\nStandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;\nStandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;\n\nconst defineUniform = (name, getUniformFunc) => {\n\t_uniforms[name] = getUniformFunc;\n};\n\nconst definePropInternal = (name, constructorFunc, setterFunc, getterFunc) => {\n\tObject.defineProperty(StandardMaterial.prototype, name, {\n\t\tget: getterFunc || function () {\n\t\t\treturn this[`_${name}`];\n\t\t},\n\t\tset: setterFunc\n\t});\n\t_props[name] = {\n\t\tvalue: constructorFunc\n\t};\n};\n\nconst defineValueProp = prop => {\n\tconst internalName = `_${prop.name}`;\n\n\tconst dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);\n\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst oldValue = this[internalName];\n\n\t\tif (oldValue !== value) {\n\t\t\tthis._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);\n\t\t\tthis[internalName] = value;\n\t\t}\n\t};\n\n\tdefinePropInternal(prop.name, () => prop.defaultValue, setterFunc, prop.getterFunc);\n};\n\nconst defineAggProp = prop => {\n\tconst internalName = `_${prop.name}`;\n\n\tconst dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);\n\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst oldValue = this[internalName];\n\n\t\tif (!oldValue.equals(value)) {\n\t\t\tthis._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);\n\t\t\tthis[internalName] = oldValue.copy(value);\n\t\t}\n\t};\n\n\tdefinePropInternal(prop.name, () => prop.defaultValue.clone(), setterFunc, prop.getterFunc);\n};\n\nconst defineProp = prop => {\n\treturn prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);\n};\n\nfunction _defineTex2D(name, uv, channels, defChannel, vertexColor, detailMode) {\n\t_matTex2D[name] = channels;\n\tdefineProp({\n\t\tname: `${name}Map`,\n\t\tdefaultValue: null,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);\n\t\t}\n\t});\n\tdefineProp({\n\t\tname: `${name}MapTiling`,\n\t\tdefaultValue: new Vec2(1, 1)\n\t});\n\tdefineProp({\n\t\tname: `${name}MapOffset`,\n\t\tdefaultValue: new Vec2(0, 0)\n\t});\n\tdefineProp({\n\t\tname: `${name}MapRotation`,\n\t\tdefaultValue: 0\n\t});\n\tdefineProp({\n\t\tname: `${name}MapUv`,\n\t\tdefaultValue: uv\n\t});\n\n\tif (channels > 0) {\n\t\tdefineProp({\n\t\t\tname: `${name}MapChannel`,\n\t\t\tdefaultValue: defChannel ? defChannel : channels > 1 ? \"rgb\" : \"g\"\n\t\t});\n\t}\n\n\tif (vertexColor) {\n\t\tdefineProp({\n\t\t\tname: `${name}VertexColor`,\n\t\t\tdefaultValue: false\n\t\t});\n\n\t\tif (channels > 0) {\n\t\t\tdefineProp({\n\t\t\t\tname: `${name}VertexColorChannel`,\n\t\t\t\tdefaultValue: defChannel ? defChannel : channels > 1 ? \"rgb\" : \"g\"\n\t\t\t});\n\t\t}\n\t}\n\n\tif (detailMode) {\n\t\tdefineProp({\n\t\t\tname: `${name}Mode`,\n\t\t\tdefaultValue: DETAILMODE_MUL\n\t\t});\n\t}\n\n\tconst mapTiling = `${name}MapTiling`;\n\tconst mapOffset = `${name}MapOffset`;\n\tconst mapRotation = `${name}MapRotation`;\n\tconst mapTransform = `${name}MapTransform`;\n\tdefineUniform(mapTransform, (material, device, scene) => {\n\t\tconst tiling = material[mapTiling];\n\t\tconst offset = material[mapOffset];\n\t\tconst rotation = material[mapRotation];\n\n\t\tif (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst uniform = material._allocUniform(mapTransform, () => {\n\t\t\treturn [{\n\t\t\t\tname: `texture_${mapTransform}0`,\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}, {\n\t\t\t\tname: `texture_${mapTransform}1`,\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}];\n\t\t});\n\n\t\tconst cr = Math.cos(rotation * math.DEG_TO_RAD);\n\t\tconst sr = Math.sin(rotation * math.DEG_TO_RAD);\n\t\tconst uniform0 = uniform[0].value;\n\t\tuniform0[0] = cr * tiling.x;\n\t\tuniform0[1] = -sr * tiling.y;\n\t\tuniform0[2] = offset.x;\n\t\tconst uniform1 = uniform[1].value;\n\t\tuniform1[0] = sr * tiling.x;\n\t\tuniform1[1] = cr * tiling.y;\n\t\tuniform1[2] = 1.0 - tiling.y - offset.y;\n\t\treturn uniform;\n\t});\n}\n\nfunction _defineColor(name, defaultValue) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue,\n\t\tgetterFunc: function () {\n\t\t\tthis._dirtyShader = true;\n\t\t\treturn this[`_${name}`];\n\t\t}\n\t});\n\tdefineUniform(name, (material, device, scene) => {\n\t\tconst uniform = material._allocUniform(name, () => new Float32Array(3));\n\n\t\tconst color = material[name];\n\t\tconst gamma = material.useGammaTonemap && scene.gammaCorrection;\n\n\t\tif (gamma) {\n\t\t\tuniform[0] = Math.pow(color.r, 2.2);\n\t\t\tuniform[1] = Math.pow(color.g, 2.2);\n\t\t\tuniform[2] = Math.pow(color.b, 2.2);\n\t\t} else {\n\t\t\tuniform[0] = color.r;\n\t\t\tuniform[1] = color.g;\n\t\t\tuniform[2] = color.b;\n\t\t}\n\n\t\treturn uniform;\n\t});\n}\n\nfunction _defineFloat(name, defaultValue, getUniformFunc) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);\n\t\t}\n\t});\n\tdefineUniform(name, getUniformFunc);\n}\n\nfunction _defineObject(name, getUniformFunc) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: null,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn !!oldValue === !!newValue;\n\t\t}\n\t});\n\tdefineUniform(name, getUniformFunc);\n}\n\nfunction _defineFlag(name, defaultValue) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue\n\t});\n}\n\nfunction _defineMaterialProps() {\n\t_defineColor(\"ambient\", new Color(0.7, 0.7, 0.7));\n\n\t_defineColor(\"diffuse\", new Color(1, 1, 1));\n\n\t_defineColor(\"specular\", new Color(0, 0, 0));\n\n\t_defineColor(\"emissive\", new Color(0, 0, 0));\n\n\t_defineFloat(\"emissiveIntensity\", 1);\n\n\t_defineFloat(\"shininess\", 25, (material, device, scene) => {\n\t\treturn material.shadingModel === SPECULAR_PHONG ? Math.pow(2, material.shininess * 0.01 * 11) : material.shininess * 0.01;\n\t});\n\n\t_defineFloat(\"heightMapFactor\", 1, (material, device, scene) => {\n\t\treturn material.heightMapFactor * 0.025;\n\t});\n\n\t_defineFloat(\"opacity\", 1);\n\n\t_defineFloat(\"alphaFade\", 1);\n\n\t_defineFloat(\"alphaTest\", 0);\n\n\t_defineFloat(\"bumpiness\", 1);\n\n\t_defineFloat(\"normalDetailMapBumpiness\", 1);\n\n\t_defineFloat(\"reflectivity\", 1);\n\n\t_defineFloat(\"occludeSpecularIntensity\", 1);\n\n\t_defineFloat(\"refraction\", 0);\n\n\t_defineFloat(\"refractionIndex\", 1.0 / 1.5);\n\n\t_defineFloat(\"metalness\", 1);\n\n\t_defineFloat(\"anisotropy\", 0);\n\n\t_defineFloat(\"clearCoat\", 0);\n\n\t_defineFloat(\"clearCoatGlossiness\", 1);\n\n\t_defineFloat(\"clearCoatBumpiness\", 1);\n\n\t_defineFloat(\"aoUvSet\", 0, null);\n\n\t_defineObject(\"ambientSH\");\n\n\t_defineObject(\"cubeMapProjectionBox\", (material, device, scene) => {\n\t\tconst uniform = material._allocUniform('cubeMapProjectionBox', () => {\n\t\t\treturn [{\n\t\t\t\tname: 'envBoxMin',\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}, {\n\t\t\t\tname: 'envBoxMax',\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}];\n\t\t});\n\n\t\tconst bboxMin = material.cubeMapProjectionBox.getMin();\n\t\tconst minUniform = uniform[0].value;\n\t\tminUniform[0] = bboxMin.x;\n\t\tminUniform[1] = bboxMin.y;\n\t\tminUniform[2] = bboxMin.z;\n\t\tconst bboxMax = material.cubeMapProjectionBox.getMax();\n\t\tconst maxUniform = uniform[1].value;\n\t\tmaxUniform[0] = bboxMax.x;\n\t\tmaxUniform[1] = bboxMax.y;\n\t\tmaxUniform[2] = bboxMax.z;\n\t\treturn uniform;\n\t});\n\n\t_defineFlag(\"ambientTint\", false);\n\n\t_defineFlag(\"diffuseTint\", false);\n\n\t_defineFlag(\"specularTint\", false);\n\n\t_defineFlag(\"emissiveTint\", false);\n\n\t_defineFlag(\"fastTbn\", false);\n\n\t_defineFlag(\"specularAntialias\", false);\n\n\t_defineFlag(\"useMetalness\", false);\n\n\t_defineFlag(\"enableGGXSpecular\", false);\n\n\t_defineFlag(\"occludeDirect\", false);\n\n\t_defineFlag(\"normalizeNormalMap\", true);\n\n\t_defineFlag(\"conserveEnergy\", true);\n\n\t_defineFlag(\"opacityFadesSpecular\", true);\n\n\t_defineFlag(\"occludeSpecular\", SPECOCC_AO);\n\n\t_defineFlag(\"shadingModel\", SPECULAR_BLINN);\n\n\t_defineFlag(\"fresnelModel\", FRESNEL_SCHLICK);\n\n\t_defineFlag(\"cubeMapProjection\", CUBEPROJ_NONE);\n\n\t_defineFlag(\"customFragmentShader\", null);\n\n\t_defineFlag(\"forceFragmentPrecision\", null);\n\n\t_defineFlag(\"useFog\", true);\n\n\t_defineFlag(\"useLighting\", true);\n\n\t_defineFlag(\"useGammaTonemap\", true);\n\n\t_defineFlag(\"useSkybox\", true);\n\n\t_defineFlag(\"forceUv1\", false);\n\n\t_defineFlag(\"pixelSnap\", false);\n\n\t_defineFlag(\"twoSidedLighting\", false);\n\n\t_defineFlag(\"nineSlicedMode\", undefined);\n\n\t_defineTex2D(\"diffuse\", 0, 3, \"\", true);\n\n\t_defineTex2D(\"specular\", 0, 3, \"\", true);\n\n\t_defineTex2D(\"emissive\", 0, 3, \"\", true);\n\n\t_defineTex2D(\"normal\", 0, -1, \"\", false);\n\n\t_defineTex2D(\"metalness\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"gloss\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"opacity\", 0, 1, \"a\", true);\n\n\t_defineTex2D(\"height\", 0, 1, \"\", false);\n\n\t_defineTex2D(\"ao\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"light\", 1, 3, \"\", true);\n\n\t_defineTex2D(\"msdf\", 0, 3, \"\", false);\n\n\t_defineTex2D(\"diffuseDetail\", 0, 3, \"\", false, true);\n\n\t_defineTex2D(\"normalDetail\", 0, -1, \"\", false);\n\n\t_defineTex2D(\"clearCoat\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"clearCoatGloss\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"clearCoatNormal\", 0, -1, \"\", false);\n\n\t_defineObject(\"cubeMap\");\n\n\t_defineObject(\"sphereMap\");\n\n\t_defineObject(\"envAtlas\");\n\n\tconst getterFunc = function getterFunc() {\n\t\treturn this._prefilteredCubemaps;\n\t};\n\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\t\tvalue = value || [];\n\t\tlet changed = false;\n\t\tlet complete = true;\n\n\t\tfor (let i = 0; i < 6; ++i) {\n\t\t\tconst v = value[i] || null;\n\n\t\t\tif (cubemaps[i] !== v) {\n\t\t\t\tcubemaps[i] = v;\n\t\t\t\tchanged = true;\n\t\t\t}\n\n\t\t\tcomplete = complete && !!cubemaps[i];\n\t\t}\n\n\t\tif (changed) {\n\t\t\tif (complete) {\n\t\t\t\tthis.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {\n\t\t\t\t\ttarget: this.envAtlas\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (this.envAtlas) {\n\t\t\t\t\tthis.envAtlas.destroy();\n\t\t\t\t\tthis.envAtlas = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirtyShader = true;\n\t\t}\n\t};\n\n\tconst empty = [null, null, null, null, null, null];\n\tdefinePropInternal(\"prefilteredCubemaps\", () => empty.slice(), setterFunc, getterFunc);\n}\n\n_defineMaterialProps();\n\nclass ProgramLibrary {\n\tconstructor(device) {\n\t\tthis._device = device;\n\t\tthis._cache = {};\n\t\tthis._generators = {};\n\t\tthis._isClearingCache = false;\n\t\tthis._precached = false;\n\t\tthis._programsCollection = [];\n\t\tthis._defaultStdMatOption = {};\n\t\tthis._defaultStdMatOptionMin = {};\n\t\tconst m = new StandardMaterial();\n\t\tm.shaderOptBuilder.updateRef(this._defaultStdMatOption, device, {}, m, null, [], SHADER_FORWARD, null, null);\n\t\tm.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, device, {}, m, null, [], SHADER_SHADOW, null, null);\n\t}\n\n\tregister(name, generator) {\n\t\tif (!this.isRegistered(name)) {\n\t\t\tthis._generators[name] = generator;\n\t\t}\n\t}\n\n\tunregister(name) {\n\t\tif (this.isRegistered(name)) {\n\t\t\tdelete this._generators[name];\n\t\t}\n\t}\n\n\tisRegistered(name) {\n\t\tconst generator = this._generators[name];\n\t\treturn generator !== undefined;\n\t}\n\n\tgetProgram(name, options) {\n\t\tconst generator = this._generators[name];\n\n\t\tif (generator === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst gd = this._device;\n\t\tconst key = generator.generateKey(options);\n\t\tlet shader = this._cache[key];\n\n\t\tif (!shader) {\n\t\t\tlet lights;\n\n\t\t\tif (options.lights) {\n\t\t\t\tlights = options.lights;\n\t\t\t\toptions.lights = lights.map(function (l) {\n\t\t\t\t\tconst lcopy = l.clone ? l.clone() : l;\n\t\t\t\t\tlcopy.key = l.key;\n\t\t\t\t\treturn lcopy;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.storeNewProgram(name, options);\n\t\t\tif (options.lights) options.lights = lights;\n\t\t\tif (this._precached) console.warn(`ProgramLibrary#getProgram: Cache miss for shader ${name} key ${key} after shaders precaching`);\n\t\t\tconst shaderDefinition = generator.createShaderDefinition(gd, options);\n\t\t\tshader = this._cache[key] = new Shader(gd, shaderDefinition);\n\t\t}\n\n\t\treturn shader;\n\t}\n\n\tstoreNewProgram(name, options) {\n\t\tlet opt = {};\n\n\t\tif (name === \"standard\") {\n\t\t\tconst defaultMat = this._getDefaultStdMatOptions(options.pass);\n\n\t\t\tfor (const p in options) {\n\t\t\t\tif (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === \"pass\") opt[p] = options[p];\n\t\t\t}\n\t\t} else {\n\t\t\topt = options;\n\t\t}\n\n\t\tthis._programsCollection.push(JSON.stringify({\n\t\t\tname: name,\n\t\t\toptions: opt\n\t\t}));\n\t}\n\n\tdumpPrograms() {\n\t\tlet text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\\n';\n\t\ttext += 'let shaders = [';\n\t\tif (this._programsCollection[0]) text += '\\n\\t' + this._programsCollection[0];\n\n\t\tfor (let i = 1; i < this._programsCollection.length; ++i) {\n\t\t\ttext += ',\\n\\t' + this._programsCollection[i];\n\t\t}\n\n\t\ttext += '\\n];\\n';\n\t\ttext += 'device.programLib.precompile(shaders);\\n';\n\t\ttext += 'if (pc.version != \\\"' + version + '\\\" || pc.revision != \\\"' + revision + '\\\")\\n';\n\t\ttext += '\\tconsole.warn(\\\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\\\");';\n\t\tconst element = document.createElement('a');\n\t\telement.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n\t\telement.setAttribute('download', 'precompile-shaders.js');\n\t\telement.style.display = 'none';\n\t\tdocument.body.appendChild(element);\n\t\telement.click();\n\t\tdocument.body.removeChild(element);\n\t}\n\n\tclearCache() {\n\t\tconst cache = this._cache;\n\t\tthis._isClearingCache = true;\n\n\t\tfor (const key in cache) {\n\t\t\tif (cache.hasOwnProperty(key)) {\n\t\t\t\tcache[key].destroy();\n\t\t\t}\n\t\t}\n\n\t\tthis._cache = {};\n\t\tthis._isClearingCache = false;\n\t}\n\n\tremoveFromCache(shader) {\n\t\tif (this._isClearingCache) return;\n\t\tconst cache = this._cache;\n\n\t\tfor (const key in cache) {\n\t\t\tif (cache.hasOwnProperty(key)) {\n\t\t\t\tif (cache[key] === shader) {\n\t\t\t\t\tdelete cache[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_getDefaultStdMatOptions(pass) {\n\t\treturn pass > SHADER_FORWARDHDR && pass <= SHADER_PICK ? this._defaultStdMatOptionMin : this._defaultStdMatOption;\n\t}\n\n\tprecompile(cache) {\n\t\tif (cache) {\n\t\t\tconst shaders = new Array(cache.length);\n\n\t\t\tfor (let i = 0; i < cache.length; i++) {\n\t\t\t\tif (cache[i].name === \"standard\") {\n\t\t\t\t\tconst opt = cache[i].options;\n\n\t\t\t\t\tconst defaultMat = this._getDefaultStdMatOptions(opt.pass);\n\n\t\t\t\t\tfor (const p in defaultMat) {\n\t\t\t\t\t\tif (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tshaders[i] = this.getProgram(cache[i].name, cache[i].options);\n\t\t\t}\n\t\t}\n\n\t\tthis._precached = true;\n\t}\n\n}\n\nclass Version {\n\tconstructor() {\n\t\tthis.globalId = 0;\n\t\tthis.revision = 0;\n\t}\n\n\tequals(other) {\n\t\treturn this.globalId === other.globalId && this.revision === other.revision;\n\t}\n\n\tcopy(other) {\n\t\tthis.globalId = other.globalId;\n\t\tthis.revision = other.revision;\n\t}\n\n\treset() {\n\t\tthis.globalId = 0;\n\t\tthis.revision = 0;\n\t}\n\n}\n\nlet idCounter = 0;\n\nclass VersionedObject {\n\tconstructor() {\n\t\tidCounter++;\n\t\tthis.version = new Version();\n\t\tthis.version.globalId = idCounter;\n\t}\n\n\tincrement() {\n\t\tthis.version.revision++;\n\t}\n\n}\n\nclass ScopeId {\n\tconstructor(name) {\n\t\tthis.name = name;\n\t\tthis.value = null;\n\t\tthis.versionObject = new VersionedObject();\n\t}\n\n\tsetValue(value) {\n\t\tthis.value = value;\n\t\tthis.versionObject.increment();\n\t}\n\n\tgetValue() {\n\t\treturn this.value;\n\t}\n\n}\n\nclass ScopeSpace {\n\tconstructor(name) {\n\t\tthis.name = name;\n\t\tthis.variables = new Map();\n\t}\n\n\tresolve(name) {\n\t\tif (!this.variables.has(name)) {\n\t\t\tthis.variables.set(name, new ScopeId(name));\n\t\t}\n\n\t\treturn this.variables.get(name);\n\t}\n\n\tremoveValue(value) {\n\t\tfor (const uniformName in this.variables) {\n\t\t\tconst uniform = this.variables[uniformName];\n\n\t\t\tif (uniform.value === value) {\n\t\t\t\tuniform.value = null;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass ShaderInput {\n\tconstructor(graphicsDevice, name, type, locationId) {\n\t\tthis.locationId = locationId;\n\t\tthis.scopeId = graphicsDevice.scope.resolve(name);\n\t\tthis.version = new Version();\n\n\t\tif (name.substr(name.length - 3) === \"[0]\") {\n\t\t\tswitch (type) {\n\t\t\t\tcase UNIFORMTYPE_FLOAT:\n\t\t\t\t\ttype = UNIFORMTYPE_FLOATARRAY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UNIFORMTYPE_VEC2:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC2ARRAY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UNIFORMTYPE_VEC3:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC3ARRAY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UNIFORMTYPE_VEC4:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.dataType = type;\n\t\tthis.value = [null, null, null, null];\n\t\tthis.array = [];\n\t}\n\n}\n\nclass GrabPass {\n\tconstructor(device, useAlpha) {\n\t\tthis.device = device;\n\t\tthis.useAlpha = useAlpha;\n\t\tthis.useMipmaps = device.webgl2;\n\t\tthis.texture = null;\n\t\tthis.renderTarget = null;\n\t\tthis.textureId = null;\n\t}\n\n\tdestroy() {\n\t\tthis.textureId = null;\n\n\t\tif (this.renderTarget) {\n\t\t\tthis.renderTarget.destroy();\n\t\t\tthis.renderTarget = null;\n\t\t}\n\n\t\tif (this.texture) {\n\t\t\tthis.texture.destroy();\n\t\t\tthis.texture = null;\n\t\t}\n\t}\n\n\tcreate() {\n\t\tif (!this.texture) {\n\t\t\tconst texture = new Texture(this.device, {\n\t\t\t\tname: 'texture_grabPass',\n\t\t\t\tformat: this.useAlpha ? PIXELFORMAT_R8_G8_B8_A8 : PIXELFORMAT_R8_G8_B8,\n\t\t\t\tminFilter: this.useMipmaps ? FILTER_LINEAR_MIPMAP_LINEAR : FILTER_LINEAR,\n\t\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\tmipmaps: this.useMipmaps\n\t\t\t});\n\t\t\tthis.texture = texture;\n\t\t\tthis.renderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: texture,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tthis.textureId = this.device.scope.resolve(texture.name);\n\t\t\tthis.textureId.setValue(texture);\n\t\t}\n\t}\n\n\tupdate() {\n\t\tconst device = this.device;\n\t\tconst gl = device.gl;\n\n\t\tif (!device.grabPassAvailable) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst renderTarget = device.renderTarget;\n\t\tconst resolveRenderTarget = renderTarget && renderTarget._glResolveFrameBuffer;\n\t\tconst texture = this.texture;\n\t\tconst width = device.width;\n\t\tconst height = device.height;\n\n\t\tif (device.webgl2 && !device._tempMacChromeBlitFramebufferWorkaround && width === texture._width && height === texture._height) {\n\t\t\tif (resolveRenderTarget) {\n\t\t\t\trenderTarget.resolve(true);\n\t\t\t}\n\n\t\t\tconst currentFrameBuffer = renderTarget ? renderTarget._glFrameBuffer : null;\n\t\t\tconst resolvedFrameBuffer = renderTarget ? renderTarget._glResolveFrameBuffer || renderTarget._glFrameBuffer : null;\n\t\t\tdevice.initRenderTarget(this.renderTarget);\n\t\t\tconst grabPassFrameBuffer = this.renderTarget._glFrameBuffer;\n\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, resolvedFrameBuffer);\n\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, grabPassFrameBuffer);\n\t\t\tgl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, currentFrameBuffer);\n\t\t} else {\n\t\t\tif (resolveRenderTarget) {\n\t\t\t\trenderTarget.resolve(true);\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glResolveFrameBuffer);\n\t\t\t}\n\n\t\t\tconst format = texture._glFormat;\n\t\t\tgl.copyTexImage2D(gl.TEXTURE_2D, 0, format, 0, 0, width, height, 0);\n\t\t\ttexture._width = width;\n\t\t\ttexture._height = height;\n\n\t\t\tif (resolveRenderTarget) {\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glFrameBuffer);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tgenerateMipmaps() {\n\t\tif (this.useMipmaps) {\n\t\t\tthis.device.gl.generateMipmap(this.texture._glTarget);\n\t\t}\n\t}\n\n\tprepareTexture() {\n\t\tconst updated = this.update();\n\n\t\tif (updated) {\n\t\t\tthis.generateMipmaps();\n\t\t}\n\n\t\treturn updated;\n\t}\n\n}\n\nconst EVENT_RESIZE = 'resizecanvas';\n\nfunction downsampleImage(image, size) {\n\tconst srcW = image.width;\n\tconst srcH = image.height;\n\n\tif (srcW > size || srcH > size) {\n\t\tconst scale = size / Math.max(srcW, srcH);\n\t\tconst dstW = Math.floor(srcW * scale);\n\t\tconst dstH = Math.floor(srcH * scale);\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = dstW;\n\t\tcanvas.height = dstH;\n\t\tconst context = canvas.getContext('2d');\n\t\tcontext.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);\n\t\treturn canvas;\n\t}\n\n\treturn image;\n}\n\nfunction testRenderable(gl, pixelFormat) {\n\tlet result = true;\n\tconst texture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);\n\tconst framebuffer = gl.createFramebuffer();\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n\tif (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n\t\tresult = false;\n\t}\n\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\tgl.deleteTexture(texture);\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\tgl.deleteFramebuffer(framebuffer);\n\treturn result;\n}\n\nfunction testTextureHalfFloatUpdatable(gl, pixelFormat) {\n\tlet result = true;\n\tconst texture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\tconst data = new Uint16Array(4 * 2 * 2);\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);\n\n\tif (gl.getError() !== gl.NO_ERROR) {\n\t\tresult = false;\n\t\tconsole.log(\"Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support\");\n\t}\n\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\tgl.deleteTexture(texture);\n\treturn result;\n}\n\nfunction testTextureFloatHighPrecision(device) {\n\tif (!device.textureFloatRenderable) return false;\n\tconst test1 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTestPS, \"ptest1\");\n\tconst test2 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTest2PS, \"ptest2\");\n\tconst textureOptions = {\n\t\tformat: PIXELFORMAT_RGBA32F,\n\t\twidth: 1,\n\t\theight: 1,\n\t\tmipmaps: false,\n\t\tminFilter: FILTER_NEAREST,\n\t\tmagFilter: FILTER_NEAREST\n\t};\n\tconst tex1 = new Texture(device, textureOptions);\n\ttex1.name = 'testFHP';\n\tconst targ1 = new RenderTarget({\n\t\tcolorBuffer: tex1,\n\t\tdepth: false\n\t});\n\tdrawQuadWithShader(device, targ1, test1);\n\ttextureOptions.format = PIXELFORMAT_R8_G8_B8_A8;\n\tconst tex2 = new Texture(device, textureOptions);\n\ttex2.name = 'testFHP';\n\tconst targ2 = new RenderTarget({\n\t\tcolorBuffer: tex2,\n\t\tdepth: false\n\t});\n\tdevice.constantTexSource.setValue(tex1);\n\tdrawQuadWithShader(device, targ2, test2);\n\tconst prevFramebuffer = device.activeFramebuffer;\n\tdevice.setFramebuffer(targ2._glFrameBuffer);\n\tconst pixels = new Uint8Array(4);\n\tdevice.readPixels(0, 0, 1, 1, pixels);\n\tdevice.setFramebuffer(prevFramebuffer);\n\tconst x = pixels[0] / 255;\n\tconst y = pixels[1] / 255;\n\tconst z = pixels[2] / 255;\n\tconst w = pixels[3] / 255;\n\tconst f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;\n\ttex1.destroy();\n\ttarg1.destroy();\n\ttex2.destroy();\n\ttarg2.destroy();\n\treturn f === 0;\n}\n\nclass GraphicsDevice extends EventHandler {\n\tconstructor(canvas, options = {}) {\n\t\tsuper();\n\t\tthis.canvas = void 0;\n\t\tthis.gl = void 0;\n\t\tthis.maxAnisotropy = void 0;\n\t\tthis.maxCubeMapSize = void 0;\n\t\tthis.maxTextureSize = void 0;\n\t\tthis.maxVolumeSize = void 0;\n\t\tthis.precision = void 0;\n\t\tthis.scope = void 0;\n\t\tthis.supportsInstancing = void 0;\n\t\tthis.textureFloatRenderable = void 0;\n\t\tthis.textureHalfFloatRenderable = void 0;\n\t\tthis.webgl2 = void 0;\n\t\tthis.canvas = canvas;\n\t\tthis._enableAutoInstancing = false;\n\t\tthis.autoInstancingMaxObjects = 16384;\n\t\tthis.defaultFramebuffer = null;\n\t\tthis._maxPixelRatio = 1;\n\t\tthis._width = 0;\n\t\tthis._height = 0;\n\t\tthis.updateClientRect();\n\t\tthis.shaders = [];\n\t\tthis.buffers = [];\n\t\tthis.textures = [];\n\t\tthis.targets = [];\n\t\tthis.contextLost = false;\n\n\t\tthis._contextLostHandler = event => {\n\t\t\tevent.preventDefault();\n\t\t\tthis.contextLost = true;\n\t\t\tthis.loseContext();\n\t\t\tthis.fire('devicelost');\n\t\t};\n\n\t\tthis._contextRestoredHandler = () => {\n\t\t\tthis.restoreContext();\n\t\t\tthis.contextLost = false;\n\t\t\tthis.fire('devicerestored');\n\t\t};\n\n\t\toptions.stencil = true;\n\n\t\tif (!options.powerPreference) {\n\t\t\toptions.powerPreference = 'high-performance';\n\t\t}\n\n\t\tconst preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;\n\t\tconst names = preferWebGl2 ? [\"webgl2\", \"webgl\", \"experimental-webgl\"] : [\"webgl\", \"experimental-webgl\"];\n\t\tlet gl = null;\n\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tgl = canvas.getContext(names[i], options);\n\n\t\t\tif (gl) {\n\t\t\t\tthis.webgl2 = names[i] === 'webgl2';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!gl) {\n\t\t\tthrow new Error(\"WebGL not supported\");\n\t\t}\n\n\t\tconst isChrome = platform.browser && !!window.chrome;\n\t\tconst isMac = platform.browser && navigator.appVersion.indexOf(\"Mac\") !== -1;\n\t\tthis.gl = gl;\n\t\tthis._tempEnableSafariTextureUnitWorkaround = platform.browser && !!window.safari;\n\t\tthis._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;\n\n\t\tif (!this.webgl2) {\n\t\t\tsetupVertexArrayObject(gl);\n\t\t}\n\n\t\tcanvas.addEventListener(\"webglcontextlost\", this._contextLostHandler, false);\n\t\tcanvas.addEventListener(\"webglcontextrestored\", this._contextRestoredHandler, false);\n\t\tthis.initializeExtensions();\n\t\tthis.initializeCapabilities();\n\t\tthis.initializeRenderState();\n\t\tthis.initializeContextCaches();\n\t\tthis.defaultClearOptions = {\n\t\t\tcolor: [0, 0, 0, 1],\n\t\t\tdepth: 1,\n\t\t\tstencil: 0,\n\t\t\tflags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH\n\t\t};\n\t\tthis.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];\n\t\tthis.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];\n\t\tthis.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA];\n\t\tthis.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];\n\t\tthis.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];\n\t\tthis.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];\n\t\tthis.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];\n\t\tthis.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];\n\t\tthis.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];\n\t\tthis.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];\n\t\tthis.pcUniformType = {};\n\t\tthis.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;\n\t\tthis.pcUniformType[gl.INT] = UNIFORMTYPE_INT;\n\t\tthis.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;\n\t\tthis.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;\n\t\tthis.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;\n\t\tthis.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;\n\t\tthis.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;\n\t\tthis.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;\n\t\tthis.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;\n\t\tthis.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;\n\t\tthis.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;\n\t\tthis.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;\n\t\tthis.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;\n\t\tthis.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;\n\t\tthis.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;\n\t\tthis.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;\n\t\tthis.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;\n\n\t\tif (this.webgl2) {\n\t\t\tthis.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;\n\t\t\tthis.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;\n\t\t\tthis.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;\n\t\t}\n\n\t\tthis.targetToSlot = {};\n\t\tthis.targetToSlot[gl.TEXTURE_2D] = 0;\n\t\tthis.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;\n\t\tthis.targetToSlot[gl.TEXTURE_3D] = 2;\n\t\tlet scopeX, scopeY, scopeZ, scopeW;\n\t\tlet uniformValue;\n\t\tthis.commitFunction = [];\n\n\t\tthis.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {\n\t\t\tif (uniform.value !== value) {\n\t\t\t\tgl.uniform1i(uniform.locationId, value);\n\t\t\t\tuniform.value = value;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];\n\n\t\tthis.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {\n\t\t\tif (uniform.value !== value) {\n\t\t\t\tgl.uniform1f(uniform.locationId, value);\n\t\t\t\tuniform.value = value;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n\t\t\t\tgl.uniform2fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n\t\t\t\tgl.uniform3fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tscopeW = value[3];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n\t\t\t\tgl.uniform4fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t\tuniformValue[3] = scopeW;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n\t\t\t\tgl.uniform2iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];\n\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n\t\t\t\tgl.uniform3iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];\n\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tscopeW = value[3];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n\t\t\t\tgl.uniform4iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t\tuniformValue[3] = scopeW;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];\n\n\t\tthis.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {\n\t\t\tgl.uniformMatrix2fv(uniform.locationId, false, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {\n\t\t\tgl.uniformMatrix3fv(uniform.locationId, false, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {\n\t\t\tgl.uniformMatrix4fv(uniform.locationId, false, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {\n\t\t\tgl.uniform1fv(uniform.locationId, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform2fv(uniform.locationId, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform3fv(uniform.locationId, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform4fv(uniform.locationId, value);\n\t\t};\n\n\t\tthis.scope = new ScopeSpace(\"Device\");\n\t\tthis.programLib = new ProgramLibrary(this);\n\n\t\tfor (const generator in programlib) this.programLib.register(generator, programlib[generator]);\n\n\t\tthis.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;\n\t\tlet numUniforms = this.vertexUniformsCount;\n\t\tnumUniforms -= 4 * 4;\n\t\tnumUniforms -= 8;\n\t\tnumUniforms -= 1;\n\t\tnumUniforms -= 4 * 4;\n\t\tthis.boneLimit = Math.floor(numUniforms / 3);\n\t\tthis.boneLimit = Math.min(this.boneLimit, 128);\n\n\t\tif (this.unmaskedRenderer === 'Mali-450 MP') {\n\t\t\tthis.boneLimit = 34;\n\t\t}\n\n\t\tthis._drawCallsPerFrame = 0;\n\t\tthis._shaderSwitchesPerFrame = 0;\n\t\tthis._primsPerFrame = [];\n\n\t\tfor (let i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {\n\t\t\tthis._primsPerFrame[i] = 0;\n\t\t}\n\n\t\tthis._renderTargetCreationTime = 0;\n\t\tthis._vram = {\n\t\t\ttex: 0,\n\t\t\tvb: 0,\n\t\t\tib: 0\n\t\t};\n\t\tthis._shaderStats = {\n\t\t\tvsCompiled: 0,\n\t\t\tfsCompiled: 0,\n\t\t\tlinked: 0,\n\t\t\tmaterialShaders: 0,\n\t\t\tcompileTime: 0\n\t\t};\n\t\tthis.constantTexSource = this.scope.resolve(\"source\");\n\n\t\tif (this.extTextureFloat) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tthis.textureFloatRenderable = !!this.extColorBufferFloat;\n\t\t\t} else {\n\t\t\t\tthis.textureFloatRenderable = testRenderable(gl, gl.FLOAT);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.textureFloatRenderable = false;\n\t\t}\n\n\t\tif (this.extColorBufferHalfFloat) {\n\t\t\tthis.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat;\n\t\t} else if (this.extTextureHalfFloat) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tthis.textureHalfFloatRenderable = !!this.extColorBufferFloat;\n\t\t\t} else {\n\t\t\t\tthis.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.textureHalfFloatRenderable = false;\n\t\t}\n\n\t\tthis.supportsMorphTargetTexturesCore = this.maxPrecision === \"highp\" && this.maxVertexTextures >= 2;\n\t\tthis._textureFloatHighPrecision = undefined;\n\t\tthis._textureHalfFloatUpdatable = undefined;\n\t\tthis.grabPassAvailable = true;\n\t\tthis.grabPass = new GrabPass(this, options.alpha);\n\t\tthis.grabPass.create();\n\t\tVertexFormat.init(this);\n\t\tthis.areaLightLutFormat = PIXELFORMAT_R8_G8_B8_A8;\n\n\t\tif (this.extTextureHalfFloat && this.textureHalfFloatUpdatable && this.extTextureHalfFloatLinear) {\n\t\t\tthis.areaLightLutFormat = PIXELFORMAT_RGBA16F;\n\t\t} else if (this.extTextureFloat && this.extTextureFloatLinear) {\n\t\t\tthis.areaLightLutFormat = PIXELFORMAT_RGBA32F;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tconst gl = this.gl;\n\t\tthis.fire('destroy');\n\t\tthis.grabPass.destroy();\n\n\t\tif (this.webgl2 && this.feedback) {\n\t\t\tgl.deleteTransformFeedback(this.feedback);\n\t\t}\n\n\t\tthis.clearShaderCache();\n\t\tthis.clearVertexArrayObjectCache();\n\t\tthis.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);\n\t\tthis.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);\n\t\tthis._contextLostHandler = null;\n\t\tthis._contextRestoredHandler = null;\n\t\tthis.scope = null;\n\t\tthis.canvas = null;\n\t\tthis.gl = null;\n\t}\n\n\ttoJSON(key) {\n\t\treturn undefined;\n\t}\n\n\tgetPrecision() {\n\t\tconst gl = this.gl;\n\t\tlet precision = \"highp\";\n\n\t\tif (gl.getShaderPrecisionFormat) {\n\t\t\tconst vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n\t\t\tconst vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\n\t\t\tconst fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\t\t\tconst fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n\t\t\tconst highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;\n\t\t\tconst mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;\n\n\t\t\tif (!highpAvailable) {\n\t\t\t\tif (mediumpAvailable) {\n\t\t\t\t\tprecision = \"mediump\";\n\t\t\t\t} else {\n\t\t\t\t\tprecision = \"lowp\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn precision;\n\t}\n\n\tinitializeExtensions() {\n\t\tconst gl = this.gl;\n\t\tconst supportedExtensions = gl.getSupportedExtensions();\n\n\t\tconst getExtension = function getExtension() {\n\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\tif (supportedExtensions.indexOf(arguments[i]) !== -1) {\n\t\t\t\t\treturn gl.getExtension(arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tif (this.webgl2) {\n\t\t\tthis.extBlendMinmax = true;\n\t\t\tthis.extDrawBuffers = true;\n\t\t\tthis.extInstancing = true;\n\t\t\tthis.extStandardDerivatives = true;\n\t\t\tthis.extTextureFloat = true;\n\t\t\tthis.extTextureHalfFloat = true;\n\t\t\tthis.extTextureLod = true;\n\t\t\tthis.extUintElement = true;\n\t\t\tthis.extVertexArrayObject = true;\n\t\t\tthis.extColorBufferFloat = getExtension('EXT_color_buffer_float');\n\t\t\tthis.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');\n\t\t} else {\n\t\t\tthis.extBlendMinmax = getExtension(\"EXT_blend_minmax\");\n\t\t\tthis.extDrawBuffers = getExtension('EXT_draw_buffers');\n\t\t\tthis.extInstancing = getExtension(\"ANGLE_instanced_arrays\");\n\n\t\t\tif (this.extInstancing) {\n\t\t\t\tconst ext = this.extInstancing;\n\t\t\t\tgl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);\n\t\t\t\tgl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);\n\t\t\t\tgl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);\n\t\t\t}\n\n\t\t\tthis.extStandardDerivatives = getExtension(\"OES_standard_derivatives\");\n\t\t\tthis.extTextureFloat = getExtension(\"OES_texture_float\");\n\t\t\tthis.extTextureHalfFloat = getExtension(\"OES_texture_half_float\");\n\t\t\tthis.extTextureLod = getExtension('EXT_shader_texture_lod');\n\t\t\tthis.extUintElement = getExtension(\"OES_element_index_uint\");\n\t\t\tthis.extVertexArrayObject = getExtension(\"OES_vertex_array_object\");\n\n\t\t\tif (this.extVertexArrayObject) {\n\t\t\t\tconst ext = this.extVertexArrayObject;\n\t\t\t\tgl.createVertexArray = ext.createVertexArrayOES.bind(ext);\n\t\t\t\tgl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);\n\t\t\t\tgl.isVertexArray = ext.isVertexArrayOES.bind(ext);\n\t\t\t\tgl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);\n\t\t\t}\n\n\t\t\tthis.extColorBufferFloat = null;\n\t\t\tthis.extDisjointTimerQuery = null;\n\t\t}\n\n\t\tthis.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');\n\t\tthis.extTextureFloatLinear = getExtension(\"OES_texture_float_linear\");\n\t\tthis.extTextureHalfFloatLinear = getExtension(\"OES_texture_half_float_linear\");\n\t\tthis.extFloatBlend = getExtension(\"EXT_float_blend\");\n\t\tthis.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');\n\t\tthis.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');\n\t\tthis.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');\n\t\tthis.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');\n\t\tthis.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');\n\t\tthis.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');\n\t\tthis.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');\n\t\tthis.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');\n\t\tthis.extColorBufferHalfFloat = getExtension(\"EXT_color_buffer_half_float\");\n\t\tthis.supportsInstancing = !!this.extInstancing;\n\t}\n\n\tinitializeCapabilities() {\n\t\tconst gl = this.gl;\n\t\tlet ext;\n\t\tthis.maxPrecision = this.precision = this.getPrecision();\n\t\tconst contextAttribs = gl.getContextAttributes();\n\t\tthis.supportsMsaa = contextAttribs.antialias;\n\t\tthis.supportsStencil = contextAttribs.stencil;\n\t\tthis.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\t\tthis.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n\t\tthis.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n\t\tthis.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\t\tthis.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n\t\tthis.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n\t\tthis.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n\t\tthis.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\n\t\tif (this.webgl2) {\n\t\t\tthis.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);\n\t\t\tthis.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);\n\t\t\tthis.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);\n\t\t} else {\n\t\t\text = this.extDrawBuffers;\n\t\t\tthis.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;\n\t\t\tthis.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;\n\t\t\tthis.maxVolumeSize = 1;\n\t\t}\n\n\t\text = this.extDebugRendererInfo;\n\t\tthis.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';\n\t\tthis.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';\n\t\text = this.extTextureFilterAnisotropic;\n\t\tthis.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;\n\t\tthis.samples = gl.getParameter(gl.SAMPLES);\n\t\tthis.maxSamples = this.webgl2 ? gl.getParameter(gl.MAX_SAMPLES) : 1;\n\t\tthis.supportsAreaLights = this.webgl2 || !platform.android;\n\n\t\tif (this.maxTextures <= 8) {\n\t\t\tthis.supportsAreaLights = false;\n\t\t}\n\t}\n\n\tinitializeRenderState() {\n\t\tconst gl = this.gl;\n\t\tthis.blending = false;\n\t\tgl.disable(gl.BLEND);\n\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\tthis.blendDst = BLENDMODE_ZERO;\n\t\tthis.blendSrcAlpha = BLENDMODE_ONE;\n\t\tthis.blendDstAlpha = BLENDMODE_ZERO;\n\t\tthis.separateAlphaBlend = false;\n\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\tthis.blendAlphaEquation = BLENDEQUATION_ADD;\n\t\tthis.separateAlphaEquation = false;\n\t\tgl.blendFunc(gl.ONE, gl.ZERO);\n\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\tthis.writeRed = true;\n\t\tthis.writeGreen = true;\n\t\tthis.writeBlue = true;\n\t\tthis.writeAlpha = true;\n\t\tgl.colorMask(true, true, true, true);\n\t\tthis.cullMode = CULLFACE_BACK;\n\t\tgl.enable(gl.CULL_FACE);\n\t\tgl.cullFace(gl.BACK);\n\t\tthis.depthTest = true;\n\t\tgl.enable(gl.DEPTH_TEST);\n\t\tthis.depthFunc = FUNC_LESSEQUAL;\n\t\tgl.depthFunc(gl.LEQUAL);\n\t\tthis.depthWrite = true;\n\t\tgl.depthMask(true);\n\t\tthis.stencil = false;\n\t\tgl.disable(gl.STENCIL_TEST);\n\t\tthis.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;\n\t\tthis.stencilRefFront = this.stencilRefBack = 0;\n\t\tthis.stencilMaskFront = this.stencilMaskBack = 0xFF;\n\t\tgl.stencilFunc(gl.ALWAYS, 0, 0xFF);\n\t\tthis.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;\n\t\tthis.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;\n\t\tthis.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;\n\t\tthis.stencilWriteMaskFront = 0xFF;\n\t\tthis.stencilWriteMaskBack = 0xFF;\n\t\tgl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\t\tgl.stencilMask(0xFF);\n\t\tthis.alphaToCoverage = false;\n\t\tthis.raster = true;\n\n\t\tif (this.webgl2) {\n\t\t\tgl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t\tgl.disable(gl.RASTERIZER_DISCARD);\n\t\t}\n\n\t\tthis.depthBiasEnabled = false;\n\t\tgl.disable(gl.POLYGON_OFFSET_FILL);\n\t\tthis.clearDepth = 1;\n\t\tgl.clearDepth(1);\n\t\tthis.clearRed = 0;\n\t\tthis.clearBlue = 0;\n\t\tthis.clearGreen = 0;\n\t\tthis.clearAlpha = 0;\n\t\tgl.clearColor(0, 0, 0, 0);\n\t\tthis.clearStencil = 0;\n\t\tgl.clearStencil(0);\n\t\tthis.vx = this.vy = this.vw = this.vh = 0;\n\t\tthis.sx = this.sy = this.sw = this.sh = 0;\n\n\t\tif (this.webgl2) {\n\t\t\tgl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);\n\t\t} else {\n\t\t\tif (this.extStandardDerivatives) {\n\t\t\t\tgl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);\n\t\t\t}\n\t\t}\n\n\t\tgl.enable(gl.SCISSOR_TEST);\n\t\tgl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n\t\tthis.unpackFlipY = false;\n\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\t\tthis.unpackPremultiplyAlpha = false;\n\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\t\tgl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\t}\n\n\tinitializeContextCaches() {\n\t\tthis.vertexShaderCache = {};\n\t\tthis.fragmentShaderCache = {};\n\t\tthis._vaoMap = new Map();\n\t\tthis.boundVao = null;\n\t\tthis.indexBuffer = null;\n\t\tthis.vertexBuffers = [];\n\t\tthis.shader = null;\n\t\tthis.renderTarget = null;\n\t\tthis.activeFramebuffer = null;\n\t\tthis.feedback = null;\n\t\tthis.transformFeedbackBuffer = null;\n\t\tthis.textureUnit = 0;\n\t\tthis.textureUnits = [];\n\n\t\tfor (let i = 0; i < this.maxCombinedTextures; i++) {\n\t\t\tthis.textureUnits.push([null, null, null]);\n\t\t}\n\t}\n\n\tloseContext() {\n\t\tfor (const shader of this.shaders) {\n\t\t\tshader.loseContext();\n\t\t}\n\n\t\tthis.grabPass.destroy();\n\n\t\twhile (this.textures.length > 0) {\n\t\t\tconst texture = this.textures[0];\n\t\t\tthis.destroyTexture(texture);\n\t\t\ttexture.dirtyAll();\n\t\t}\n\n\t\tfor (const buffer of this.buffers) {\n\t\t\tbuffer.loseContext();\n\t\t}\n\n\t\tfor (const target of this.targets) {\n\t\t\ttarget.loseContext();\n\t\t}\n\t}\n\n\trestoreContext() {\n\t\tthis.initializeExtensions();\n\t\tthis.initializeCapabilities();\n\t\tthis.initializeRenderState();\n\t\tthis.initializeContextCaches();\n\n\t\tfor (const shader of this.shaders) {\n\t\t\tthis.compileAndLinkShader(shader);\n\t\t}\n\n\t\tfor (const buffer of this.buffers) {\n\t\t\tbuffer.unlock();\n\t\t}\n\n\t\tthis.grabPass.create();\n\t}\n\n\tupdateClientRect() {\n\t\tthis.clientRect = this.canvas.getBoundingClientRect();\n\t}\n\n\tsetViewport(x, y, w, h) {\n\t\tif (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {\n\t\t\tthis.gl.viewport(x, y, w, h);\n\t\t\tthis.vx = x;\n\t\t\tthis.vy = y;\n\t\t\tthis.vw = w;\n\t\t\tthis.vh = h;\n\t\t}\n\t}\n\n\tsetScissor(x, y, w, h) {\n\t\tif (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {\n\t\t\tthis.gl.scissor(x, y, w, h);\n\t\t\tthis.sx = x;\n\t\t\tthis.sy = y;\n\t\t\tthis.sw = w;\n\t\t\tthis.sh = h;\n\t\t}\n\t}\n\n\tgetProgramLibrary() {\n\t\treturn this.programLib;\n\t}\n\n\tsetProgramLibrary(programLib) {\n\t\tthis.programLib = programLib;\n\t}\n\n\tsetFramebuffer(fb) {\n\t\tif (this.activeFramebuffer !== fb) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\t\t\tthis.activeFramebuffer = fb;\n\t\t}\n\t}\n\n\t_checkFbo() {\n\t\tconst gl = this.gl;\n\t\tconst status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n\t\tswitch (status) {\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n\t\t\t\tconsole.error(\"ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT\");\n\t\t\t\tbreak;\n\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n\t\t\t\tconsole.error(\"ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n\t\t\t\tbreak;\n\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n\t\t\t\tconsole.error(\"ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n\t\t\t\tbreak;\n\n\t\t\tcase gl.FRAMEBUFFER_UNSUPPORTED:\n\t\t\t\tconsole.error(\"ERROR: FRAMEBUFFER_UNSUPPORTED\");\n\t\t\t\tbreak;\n\n\t\t\tcase gl.FRAMEBUFFER_COMPLETE:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tcopyRenderTarget(source, dest, color, depth) {\n\t\tconst gl = this.gl;\n\n\t\tif (!this.webgl2 && depth) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (color) {\n\t\t\tif (!dest) {\n\t\t\t\tif (!source._colorBuffer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!source._colorBuffer || !dest._colorBuffer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (source._colorBuffer._format !== dest._colorBuffer._format) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (depth) {\n\t\t\tif (!source._depthBuffer || !dest._depthBuffer) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (source._depthBuffer._format !== dest._depthBuffer._format) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.webgl2 && dest) {\n\t\t\tconst prevRt = this.renderTarget;\n\t\t\tthis.renderTarget = dest;\n\t\t\tthis.updateBegin();\n\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source._glFrameBuffer : null);\n\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest._glFrameBuffer);\n\t\t\tconst w = source ? source.width : dest.width;\n\t\t\tconst h = source ? source.height : dest.height;\n\t\t\tgl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);\n\t\t\tthis.renderTarget = prevRt;\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt._glFrameBuffer : null);\n\t\t} else {\n\t\t\tconst shader = this.getCopyShader();\n\t\t\tthis.constantTexSource.setValue(source._colorBuffer);\n\t\t\tdrawQuadWithShader(this, dest, shader);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tinitRenderTarget(target) {\n\t\tif (target._glFrameBuffer) return;\n\t\tconst gl = this.gl;\n\t\ttarget._glFrameBuffer = gl.createFramebuffer();\n\t\tthis.setFramebuffer(target._glFrameBuffer);\n\t\tconst colorBuffer = target._colorBuffer;\n\n\t\tif (colorBuffer) {\n\t\t\tif (!colorBuffer._glTexture) {\n\t\t\t\tcolorBuffer._width = Math.min(colorBuffer.width, this.maxRenderBufferSize);\n\t\t\t\tcolorBuffer._height = Math.min(colorBuffer.height, this.maxRenderBufferSize);\n\t\t\t\tthis.setTexture(colorBuffer, 0);\n\t\t\t}\n\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer._glTexture, 0);\n\t\t}\n\n\t\tconst depthBuffer = target._depthBuffer;\n\n\t\tif (depthBuffer && this.webgl2) {\n\t\t\tif (!depthBuffer._glTexture) {\n\t\t\t\tdepthBuffer._width = Math.min(depthBuffer.width, this.maxRenderBufferSize);\n\t\t\t\tdepthBuffer._height = Math.min(depthBuffer.height, this.maxRenderBufferSize);\n\t\t\t\tthis.setTexture(depthBuffer, 0);\n\t\t\t}\n\n\t\t\tif (target._stencil) {\n\t\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTexture, 0);\n\t\t\t} else {\n\t\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTexture, 0);\n\t\t\t}\n\t\t} else if (target._depth) {\n\t\t\tconst willRenderMsaa = target._samples > 1 && this.webgl2;\n\n\t\t\tif (!willRenderMsaa) {\n\t\t\t\tif (!target._glDepthBuffer) {\n\t\t\t\t\ttarget._glDepthBuffer = gl.createRenderbuffer();\n\t\t\t\t}\n\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, target._glDepthBuffer);\n\n\t\t\t\tif (target._stencil) {\n\t\t\t\t\tgl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tgl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);\n\t\t\t\t}\n\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, null);\n\t\t\t}\n\t\t}\n\n\t\tif (this.webgl2 && target._samples > 1) {\n\t\t\ttarget._glResolveFrameBuffer = target._glFrameBuffer;\n\t\t\ttarget._glFrameBuffer = gl.createFramebuffer();\n\t\t\tthis.setFramebuffer(target._glFrameBuffer);\n\n\t\t\tif (colorBuffer) {\n\t\t\t\tif (!target._glMsaaColorBuffer) {\n\t\t\t\t\ttarget._glMsaaColorBuffer = gl.createRenderbuffer();\n\t\t\t\t}\n\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaColorBuffer);\n\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer._glInternalFormat, target.width, target.height);\n\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, target._glMsaaColorBuffer);\n\t\t\t}\n\n\t\t\tif (target._depth) {\n\t\t\t\tif (!target._glMsaaDepthBuffer) {\n\t\t\t\t\ttarget._glMsaaDepthBuffer = gl.createRenderbuffer();\n\t\t\t\t}\n\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaDepthBuffer);\n\n\t\t\t\tif (target._stencil) {\n\t\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.targets.push(target);\n\t}\n\n\tgetCopyShader() {\n\t\tif (!this._copyShader) {\n\t\t\tconst vs = shaderChunks.fullscreenQuadVS;\n\t\t\tconst fs = shaderChunks.outputTex2DPS;\n\t\t\tthis._copyShader = createShaderFromCode(this, vs, fs, \"outputTex2D\");\n\t\t}\n\n\t\treturn this._copyShader;\n\t}\n\n\tupdateBegin() {\n\t\tthis.boundVao = null;\n\n\t\tif (this._tempEnableSafariTextureUnitWorkaround) {\n\t\t\tfor (let unit = 0; unit < this.textureUnits.length; ++unit) {\n\t\t\t\tfor (let slot = 0; slot < 3; ++slot) {\n\t\t\t\t\tthis.textureUnits[unit][slot] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst target = this.renderTarget;\n\n\t\tif (target) {\n\t\t\tif (!target._glFrameBuffer) {\n\t\t\t\tthis.initRenderTarget(target);\n\t\t\t} else {\n\t\t\t\tthis.setFramebuffer(target._glFrameBuffer);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.setFramebuffer(this.defaultFramebuffer);\n\t\t}\n\t}\n\n\tupdateEnd() {\n\t\tconst gl = this.gl;\n\n\t\tif (this.boundVao) {\n\t\t\tthis.boundVao = null;\n\t\t\tthis.gl.bindVertexArray(null);\n\t\t}\n\n\t\tconst target = this.renderTarget;\n\n\t\tif (target) {\n\t\t\tconst colorBuffer = target._colorBuffer;\n\n\t\t\tif (colorBuffer && colorBuffer._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {\n\t\t\t\tthis.activeTexture(this.maxCombinedTextures - 1);\n\t\t\t\tthis.bindTexture(colorBuffer);\n\t\t\t\tgl.generateMipmap(colorBuffer._glTarget);\n\t\t\t}\n\n\t\t\tif (this.webgl2 && target._samples > 1 && target.autoResolve) {\n\t\t\t\ttarget.resolve();\n\t\t\t}\n\t\t}\n\t}\n\n\tinitializeTexture(texture) {\n\t\tconst gl = this.gl;\n\t\tlet ext;\n\t\ttexture._glTexture = gl.createTexture();\n\t\ttexture._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;\n\n\t\tswitch (texture._format) {\n\t\t\tcase PIXELFORMAT_A8:\n\t\t\t\ttexture._glFormat = gl.ALPHA;\n\t\t\t\ttexture._glInternalFormat = gl.ALPHA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_L8:\n\t\t\t\ttexture._glFormat = gl.LUMINANCE;\n\t\t\t\ttexture._glInternalFormat = gl.LUMINANCE;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_L8_A8:\n\t\t\t\ttexture._glFormat = gl.LUMINANCE_ALPHA;\n\t\t\t\ttexture._glInternalFormat = gl.LUMINANCE_ALPHA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R5_G6_B5:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = gl.RGB;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_SHORT_5_6_5;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R5_G5_B5_A1:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = gl.RGBA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R4_G4_B4_A4:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = gl.RGBA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R8_G8_B8:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = this.webgl2 ? gl.RGB8 : gl.RGB;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R8_G8_B8_A8:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = this.webgl2 ? gl.RGBA8 : gl.RGBA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DXT1:\n\t\t\t\text = this.extCompressedTextureS3TC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DXT3:\n\t\t\t\text = this.extCompressedTextureS3TC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DXT5:\n\t\t\t\text = this.extCompressedTextureS3TC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ETC1:\n\t\t\t\text = this.extCompressedTextureETC1;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_PVRTC_2BPP_RGB_1:\n\t\t\t\text = this.extCompressedTexturePVRTC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_PVRTC_2BPP_RGBA_1:\n\t\t\t\text = this.extCompressedTexturePVRTC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_PVRTC_4BPP_RGB_1:\n\t\t\t\text = this.extCompressedTexturePVRTC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_PVRTC_4BPP_RGBA_1:\n\t\t\t\text = this.extCompressedTexturePVRTC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ETC2_RGB:\n\t\t\t\text = this.extCompressedTextureETC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB8_ETC2;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ETC2_RGBA:\n\t\t\t\text = this.extCompressedTextureETC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA8_ETC2_EAC;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ASTC_4x4:\n\t\t\t\text = this.extCompressedTextureASTC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ATC_RGB:\n\t\t\t\text = this.extCompressedTextureATC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_ATC_WEBGL;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ATC_RGBA:\n\t\t\t\text = this.extCompressedTextureATC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_RGB16F:\n\t\t\t\text = this.extTextureHalfFloat;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGB16F;\n\t\t\t\t\ttexture._glPixelType = gl.HALF_FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGB;\n\t\t\t\t\ttexture._glPixelType = ext.HALF_FLOAT_OES;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\t\text = this.extTextureHalfFloat;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGBA16F;\n\t\t\t\t\ttexture._glPixelType = gl.HALF_FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGBA;\n\t\t\t\t\ttexture._glPixelType = ext.HALF_FLOAT_OES;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_RGB32F:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGB32F;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGB;\n\t\t\t\t}\n\n\t\t\t\ttexture._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGBA32F;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGBA;\n\t\t\t\t}\n\n\t\t\t\ttexture._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R32F:\n\t\t\t\ttexture._glFormat = gl.RED;\n\t\t\t\ttexture._glInternalFormat = gl.R32F;\n\t\t\t\ttexture._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DEPTH:\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\ttexture._glInternalFormat = gl.DEPTH_COMPONENT32F;\n\t\t\t\t\ttexture._glPixelType = gl.FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\ttexture._glInternalFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\ttexture._glPixelType = gl.UNSIGNED_SHORT;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DEPTHSTENCIL:\n\t\t\t\ttexture._glFormat = gl.DEPTH_STENCIL;\n\t\t\t\ttexture._glInternalFormat = gl.DEPTH24_STENCIL8;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_INT_24_8;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_111110F:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = gl.R11F_G11F_B10F;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_SRGB:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = gl.SRGB8;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_SRGBA:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = gl.SRGB8_ALPHA8;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tthis.textures.push(texture);\n\t}\n\n\tdestroyTexture(texture) {\n\t\tif (texture._glTexture) {\n\t\t\tconst idx = this.textures.indexOf(texture);\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tthis.textures.splice(idx, 1);\n\t\t\t}\n\n\t\t\tthis.scope.removeValue(texture);\n\n\t\t\tfor (let i = 0; i < this.textureUnits.length; i++) {\n\t\t\t\tconst textureUnit = this.textureUnits[i];\n\n\t\t\t\tfor (let j = 0; j < textureUnit.length; j++) {\n\t\t\t\t\tif (textureUnit[j] === texture._glTexture) {\n\t\t\t\t\t\ttextureUnit[j] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst gl = this.gl;\n\t\t\tgl.deleteTexture(texture._glTexture);\n\t\t\tdelete texture._glTexture;\n\t\t\tdelete texture._glTarget;\n\t\t\tdelete texture._glFormat;\n\t\t\tdelete texture._glInternalFormat;\n\t\t\tdelete texture._glPixelType;\n\t\t\tthis._vram.tex -= texture._gpuSize;\n\t\t}\n\t}\n\n\tsetUnpackFlipY(flipY) {\n\t\tif (this.unpackFlipY !== flipY) {\n\t\t\tthis.unpackFlipY = flipY;\n\t\t\tconst gl = this.gl;\n\t\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\t\t}\n\t}\n\n\tsetUnpackPremultiplyAlpha(premultiplyAlpha) {\n\t\tif (this.unpackPremultiplyAlpha !== premultiplyAlpha) {\n\t\t\tthis.unpackPremultiplyAlpha = premultiplyAlpha;\n\t\t\tconst gl = this.gl;\n\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);\n\t\t}\n\t}\n\n\t_isBrowserInterface(texture) {\n\t\treturn typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement || typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap;\n\t}\n\n\tuploadTexture(texture) {\n\t\tconst gl = this.gl;\n\t\tif (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) return;\n\t\tlet mipLevel = 0;\n\t\tlet mipObject;\n\t\tlet resMult;\n\t\tconst requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;\n\n\t\twhile (texture._levels[mipLevel] || mipLevel === 0) {\n\t\t\tif (!texture._needsUpload && mipLevel === 0) {\n\t\t\t\tmipLevel++;\n\t\t\t\tcontinue;\n\t\t\t} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmipObject = texture._levels[mipLevel];\n\n\t\t\tif (mipLevel === 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {\n\t\t\t\tgl.generateMipmap(texture._glTarget);\n\t\t\t\ttexture._mipmapsUploaded = true;\n\t\t\t}\n\n\t\t\tif (texture._cubemap) {\n\t\t\t\tlet face;\n\n\t\t\t\tif (this._isBrowserInterface(mipObject[0])) {\n\t\t\t\t\tfor (face = 0; face < 6; face++) {\n\t\t\t\t\t\tif (!texture._levelsUpdated[0][face]) continue;\n\t\t\t\t\t\tlet src = mipObject[face];\n\n\t\t\t\t\t\tif (src instanceof HTMLImageElement) {\n\t\t\t\t\t\t\tif (src.width > this.maxCubeMapSize || src.height > this.maxCubeMapSize) {\n\t\t\t\t\t\t\t\tsrc = downsampleImage(src, this.maxCubeMapSize);\n\n\t\t\t\t\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\t\t\t\t\ttexture._width = src.width;\n\t\t\t\t\t\t\t\t\ttexture._height = src.height;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.setUnpackFlipY(false);\n\t\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, src);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\n\t\t\t\t\tfor (face = 0; face < 6; face++) {\n\t\t\t\t\t\tif (!texture._levelsUpdated[0][face]) continue;\n\t\t\t\t\t\tconst texData = mipObject[face];\n\n\t\t\t\t\t\tif (texture._compressed) {\n\t\t\t\t\t\t\tgl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.setUnpackFlipY(false);\n\t\t\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, texData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (texture._volume) {\n\t\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\n\t\t\t\tif (texture._compressed) {\n\t\t\t\t\tgl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);\n\t\t\t\t} else {\n\t\t\t\t\tthis.setUnpackFlipY(false);\n\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\tgl.texImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._isBrowserInterface(mipObject)) {\n\t\t\t\t\tif (mipObject instanceof HTMLImageElement) {\n\t\t\t\t\t\tif (mipObject.width > this.maxTextureSize || mipObject.height > this.maxTextureSize) {\n\t\t\t\t\t\t\tmipObject = downsampleImage(mipObject, this.maxTextureSize);\n\n\t\t\t\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\t\t\t\ttexture._width = mipObject.width;\n\t\t\t\t\t\t\t\ttexture._height = mipObject.height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setUnpackFlipY(texture._flipY);\n\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, mipObject);\n\t\t\t\t} else {\n\t\t\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\n\t\t\t\t\tif (texture._compressed) {\n\t\t\t\t\t\tgl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.setUnpackFlipY(false);\n\t\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\ttexture._mipmapsUploaded = false;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._mipmapsUploaded = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmipLevel++;\n\t\t}\n\n\t\tif (texture._needsUpload) {\n\t\t\tif (texture._cubemap) {\n\t\t\t\tfor (let i = 0; i < 6; i++) texture._levelsUpdated[0][i] = false;\n\t\t\t} else {\n\t\t\t\ttexture._levelsUpdated[0] = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || this.webgl2) && texture._levels.length === 1) {\n\t\t\tgl.generateMipmap(texture._glTarget);\n\t\t\ttexture._mipmapsUploaded = true;\n\t\t}\n\n\t\tif (texture._gpuSize) {\n\t\t\tthis._vram.tex -= texture._gpuSize;\n\t\t}\n\n\t\ttexture._gpuSize = texture.gpuSize;\n\t\tthis._vram.tex += texture._gpuSize;\n\t}\n\n\tactiveTexture(textureUnit) {\n\t\tif (this.textureUnit !== textureUnit) {\n\t\t\tthis.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n\t\t\tthis.textureUnit = textureUnit;\n\t\t}\n\t}\n\n\tbindTexture(texture) {\n\t\tconst textureTarget = texture._glTarget;\n\t\tconst textureObject = texture._glTexture;\n\t\tconst textureUnit = this.textureUnit;\n\t\tconst slot = this.targetToSlot[textureTarget];\n\n\t\tif (this.textureUnits[textureUnit][slot] !== textureObject) {\n\t\t\tthis.gl.bindTexture(textureTarget, textureObject);\n\t\t\tthis.textureUnits[textureUnit][slot] = textureObject;\n\t\t}\n\t}\n\n\tbindTextureOnUnit(texture, textureUnit) {\n\t\tconst textureTarget = texture._glTarget;\n\t\tconst textureObject = texture._glTexture;\n\t\tconst slot = this.targetToSlot[textureTarget];\n\n\t\tif (this.textureUnits[textureUnit][slot] !== textureObject) {\n\t\t\tthis.activeTexture(textureUnit);\n\t\t\tthis.gl.bindTexture(textureTarget, textureObject);\n\t\t\tthis.textureUnits[textureUnit][slot] = textureObject;\n\t\t}\n\t}\n\n\tsetTextureParameters(texture) {\n\t\tconst gl = this.gl;\n\t\tconst flags = texture._parameterFlags;\n\t\tconst target = texture._glTarget;\n\n\t\tif (flags & 1) {\n\t\t\tlet filter = texture._minFilter;\n\n\t\t\tif (!texture.pot && !this.webgl2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {\n\t\t\t\tif (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {\n\t\t\t\t\tfilter = FILTER_NEAREST;\n\t\t\t\t} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {\n\t\t\t\t\tfilter = FILTER_LINEAR;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);\n\t\t}\n\n\t\tif (flags & 2) {\n\t\t\tgl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);\n\t\t}\n\n\t\tif (flags & 4) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);\n\t\t\t} else {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 8) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);\n\t\t\t} else {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 16) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 32) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 64) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 128) {\n\t\t\tconst ext = this.extTextureFilterAnisotropic;\n\n\t\t\tif (ext) {\n\t\t\t\tgl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));\n\t\t\t}\n\t\t}\n\t}\n\n\tsetTexture(texture, textureUnit) {\n\t\tif (!texture._glTexture) this.initializeTexture(texture);\n\n\t\tif (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload || texture === this.grabPass.texture) {\n\t\t\tthis.activeTexture(textureUnit);\n\t\t\tthis.bindTexture(texture);\n\n\t\t\tif (texture._parameterFlags) {\n\t\t\t\tthis.setTextureParameters(texture);\n\t\t\t\ttexture._parameterFlags = 0;\n\t\t\t}\n\n\t\t\tconst processed = texture === this.grabPass.texture && this.grabPass.prepareTexture();\n\n\t\t\tif (!processed && (texture._needsUpload || texture._needsMipmapsUpload)) {\n\t\t\t\tthis.uploadTexture(texture);\n\t\t\t\ttexture._needsUpload = false;\n\t\t\t\ttexture._needsMipmapsUpload = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.bindTextureOnUnit(texture, textureUnit);\n\t\t}\n\t}\n\n\tcreateVertexArray(vertexBuffers) {\n\t\tlet key, vao;\n\t\tconst useCache = vertexBuffers.length > 1;\n\n\t\tif (useCache) {\n\t\t\tkey = \"\";\n\n\t\t\tfor (let i = 0; i < vertexBuffers.length; i++) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[i];\n\t\t\t\tkey += vertexBuffer.id + vertexBuffer.format.renderingingHash;\n\t\t\t}\n\n\t\t\tvao = this._vaoMap.get(key);\n\t\t}\n\n\t\tif (!vao) {\n\t\t\tconst gl = this.gl;\n\t\t\tvao = gl.createVertexArray();\n\t\t\tgl.bindVertexArray(vao);\n\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n\t\t\tfor (let i = 0; i < vertexBuffers.length; i++) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[i];\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.bufferId);\n\t\t\t\tconst elements = vertexBuffer.format.elements;\n\n\t\t\t\tfor (let j = 0; j < elements.length; j++) {\n\t\t\t\t\tconst e = elements[j];\n\t\t\t\t\tconst loc = semanticToLocation[e.name];\n\n\t\t\t\t\tgl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);\n\t\t\t\t\tgl.enableVertexAttribArray(loc);\n\n\t\t\t\t\tif (vertexBuffer.instancing) {\n\t\t\t\t\t\tgl.vertexAttribDivisor(loc, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgl.bindVertexArray(null);\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n\t\t\tif (useCache) {\n\t\t\t\tthis._vaoMap.set(key, vao);\n\t\t\t}\n\t\t}\n\n\t\treturn vao;\n\t}\n\n\tsetBuffers() {\n\t\tconst gl = this.gl;\n\t\tlet vao;\n\n\t\tif (this.vertexBuffers.length === 1) {\n\t\t\tconst vertexBuffer = this.vertexBuffers[0];\n\n\t\t\tif (!vertexBuffer._vao) {\n\t\t\t\tvertexBuffer._vao = this.createVertexArray(this.vertexBuffers);\n\t\t\t}\n\n\t\t\tvao = vertexBuffer._vao;\n\t\t} else {\n\t\t\tvao = this.createVertexArray(this.vertexBuffers);\n\t\t}\n\n\t\tif (this.boundVao !== vao) {\n\t\t\tthis.boundVao = vao;\n\t\t\tgl.bindVertexArray(vao);\n\t\t}\n\n\t\tthis.vertexBuffers.length = 0;\n\t\tconst bufferId = this.indexBuffer ? this.indexBuffer.bufferId : null;\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);\n\t}\n\n\tdraw(primitive, numInstances, keepBuffers) {\n\t\tconst gl = this.gl;\n\t\tlet sampler, samplerValue, texture, numTextures;\n\t\tlet uniform, scopeId, uniformVersion, programVersion;\n\t\tconst shader = this.shader;\n\t\tif (!shader) return;\n\t\tconst samplers = shader.samplers;\n\t\tconst uniforms = shader.uniforms;\n\n\t\tif (!keepBuffers) {\n\t\t\tthis.setBuffers();\n\t\t}\n\n\t\tlet textureUnit = 0;\n\n\t\tfor (let i = 0, len = samplers.length; i < len; i++) {\n\t\t\tsampler = samplers[i];\n\t\t\tsamplerValue = sampler.scopeId.value;\n\n\t\t\tif (!samplerValue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (samplerValue instanceof Texture) {\n\t\t\t\ttexture = samplerValue;\n\t\t\t\tthis.setTexture(texture, textureUnit);\n\n\t\t\t\tif (sampler.slot !== textureUnit) {\n\t\t\t\t\tgl.uniform1i(sampler.locationId, textureUnit);\n\t\t\t\t\tsampler.slot = textureUnit;\n\t\t\t\t}\n\n\t\t\t\ttextureUnit++;\n\t\t\t} else {\n\t\t\t\tsampler.array.length = 0;\n\t\t\t\tnumTextures = samplerValue.length;\n\n\t\t\t\tfor (let j = 0; j < numTextures; j++) {\n\t\t\t\t\ttexture = samplerValue[j];\n\t\t\t\t\tthis.setTexture(texture, textureUnit);\n\t\t\t\t\tsampler.array[j] = textureUnit;\n\t\t\t\t\ttextureUnit++;\n\t\t\t\t}\n\n\t\t\t\tgl.uniform1iv(sampler.locationId, sampler.array);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = uniforms.length; i < len; i++) {\n\t\t\tuniform = uniforms[i];\n\t\t\tscopeId = uniform.scopeId;\n\t\t\tuniformVersion = uniform.version;\n\t\t\tprogramVersion = scopeId.versionObject.version;\n\n\t\t\tif (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {\n\t\t\t\tuniformVersion.globalId = programVersion.globalId;\n\t\t\t\tuniformVersion.revision = programVersion.revision;\n\n\t\t\t\tif (scopeId.value !== null) {\n\t\t\t\t\tthis.commitFunction[uniform.dataType](uniform, scopeId.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.webgl2 && this.transformFeedbackBuffer) {\n\t\t\tgl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId);\n\t\t\tgl.beginTransformFeedback(gl.POINTS);\n\t\t}\n\n\t\tconst mode = this.glPrimitive[primitive.type];\n\t\tconst count = primitive.count;\n\n\t\tif (primitive.indexed) {\n\t\t\tconst indexBuffer = this.indexBuffer;\n\t\t\tconst format = indexBuffer.glFormat;\n\t\t\tconst offset = primitive.base * indexBuffer.bytesPerIndex;\n\n\t\t\tif (numInstances > 0) {\n\t\t\t\tgl.drawElementsInstanced(mode, count, format, offset, numInstances);\n\t\t\t} else {\n\t\t\t\tgl.drawElements(mode, count, format, offset);\n\t\t\t}\n\t\t} else {\n\t\t\tconst first = primitive.base;\n\n\t\t\tif (numInstances > 0) {\n\t\t\t\tgl.drawArraysInstanced(mode, first, count, numInstances);\n\t\t\t} else {\n\t\t\t\tgl.drawArrays(mode, first, count);\n\t\t\t}\n\t\t}\n\n\t\tif (this.webgl2 && this.transformFeedbackBuffer) {\n\t\t\tgl.endTransformFeedback();\n\t\t\tgl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);\n\t\t}\n\n\t\tthis._drawCallsPerFrame++;\n\t}\n\n\tclear(options) {\n\t\tconst defaultOptions = this.defaultClearOptions;\n\t\toptions = options || defaultOptions;\n\t\tconst flags = options.flags == undefined ? defaultOptions.flags : options.flags;\n\n\t\tif (flags !== 0) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (flags & CLEARFLAG_COLOR) {\n\t\t\t\tconst color = options.color == undefined ? defaultOptions.color : options.color;\n\t\t\t\tthis.setClearColor(color[0], color[1], color[2], color[3]);\n\t\t\t}\n\n\t\t\tif (flags & CLEARFLAG_DEPTH) {\n\t\t\t\tconst depth = options.depth == undefined ? defaultOptions.depth : options.depth;\n\t\t\t\tthis.setClearDepth(depth);\n\n\t\t\t\tif (!this.depthWrite) {\n\t\t\t\t\tgl.depthMask(true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flags & CLEARFLAG_STENCIL) {\n\t\t\t\tconst stencil = options.stencil == undefined ? defaultOptions.stencil : options.stencil;\n\t\t\t\tthis.setClearStencil(stencil);\n\t\t\t}\n\n\t\t\tgl.clear(this.glClearFlag[flags]);\n\n\t\t\tif (flags & CLEARFLAG_DEPTH) {\n\t\t\t\tif (!this.depthWrite) {\n\t\t\t\t\tgl.depthMask(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treadPixels(x, y, w, h, pixels) {\n\t\tconst gl = this.gl;\n\t\tgl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\t}\n\n\tsetClearDepth(depth) {\n\t\tif (depth !== this.clearDepth) {\n\t\t\tthis.gl.clearDepth(depth);\n\t\t\tthis.clearDepth = depth;\n\t\t}\n\t}\n\n\tsetClearColor(r, g, b, a) {\n\t\tif (r !== this.clearRed || g !== this.clearGreen || b !== this.clearBlue || a !== this.clearAlpha) {\n\t\t\tthis.gl.clearColor(r, g, b, a);\n\t\t\tthis.clearRed = r;\n\t\t\tthis.clearGreen = g;\n\t\t\tthis.clearBlue = b;\n\t\t\tthis.clearAlpha = a;\n\t\t}\n\t}\n\n\tsetClearStencil(value) {\n\t\tif (value !== this.clearStencil) {\n\t\t\tthis.gl.clearStencil(value);\n\t\t\tthis.clearStencil = value;\n\t\t}\n\t}\n\n\tsetRenderTarget(renderTarget) {\n\t\tthis.renderTarget = renderTarget;\n\t}\n\n\tgetRenderTarget() {\n\t\treturn this.renderTarget;\n\t}\n\n\tgetDepthTest() {\n\t\treturn this.depthTest;\n\t}\n\n\tsetDepthTest(depthTest) {\n\t\tif (this.depthTest !== depthTest) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (depthTest) {\n\t\t\t\tgl.enable(gl.DEPTH_TEST);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\t}\n\n\t\t\tthis.depthTest = depthTest;\n\t\t}\n\t}\n\n\tsetDepthFunc(func) {\n\t\tif (this.depthFunc === func) return;\n\t\tthis.gl.depthFunc(this.glComparison[func]);\n\t\tthis.depthFunc = func;\n\t}\n\n\tgetDepthWrite() {\n\t\treturn this.depthWrite;\n\t}\n\n\tsetDepthWrite(writeDepth) {\n\t\tif (this.depthWrite !== writeDepth) {\n\t\t\tthis.gl.depthMask(writeDepth);\n\t\t\tthis.depthWrite = writeDepth;\n\t\t}\n\t}\n\n\tsetColorWrite(writeRed, writeGreen, writeBlue, writeAlpha) {\n\t\tif (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {\n\t\t\tthis.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);\n\t\t\tthis.writeRed = writeRed;\n\t\t\tthis.writeGreen = writeGreen;\n\t\t\tthis.writeBlue = writeBlue;\n\t\t\tthis.writeAlpha = writeAlpha;\n\t\t}\n\t}\n\n\tsetAlphaToCoverage(state) {\n\t\tif (!this.webgl2) return;\n\t\tif (this.alphaToCoverage === state) return;\n\t\tthis.alphaToCoverage = state;\n\n\t\tif (state) {\n\t\t\tthis.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t} else {\n\t\t\tthis.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t}\n\t}\n\n\tsetTransformFeedbackBuffer(tf) {\n\t\tif (this.transformFeedbackBuffer === tf) return;\n\t\tthis.transformFeedbackBuffer = tf;\n\n\t\tif (this.webgl2) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (tf) {\n\t\t\t\tif (!this.feedback) {\n\t\t\t\t\tthis.feedback = gl.createTransformFeedback();\n\t\t\t\t}\n\n\t\t\t\tgl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);\n\t\t\t} else {\n\t\t\t\tgl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetRaster(on) {\n\t\tif (this.raster === on) return;\n\t\tthis.raster = on;\n\n\t\tif (this.webgl2) {\n\t\t\tif (on) {\n\t\t\t\tthis.gl.disable(this.gl.RASTERIZER_DISCARD);\n\t\t\t} else {\n\t\t\t\tthis.gl.enable(this.gl.RASTERIZER_DISCARD);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetDepthBias(on) {\n\t\tif (this.depthBiasEnabled === on) return;\n\t\tthis.depthBiasEnabled = on;\n\n\t\tif (on) {\n\t\t\tthis.gl.enable(this.gl.POLYGON_OFFSET_FILL);\n\t\t} else {\n\t\t\tthis.gl.disable(this.gl.POLYGON_OFFSET_FILL);\n\t\t}\n\t}\n\n\tsetDepthBiasValues(constBias, slopeBias) {\n\t\tthis.gl.polygonOffset(slopeBias, constBias);\n\t}\n\n\tgetBlending() {\n\t\treturn this.blending;\n\t}\n\n\tsetBlending(blending) {\n\t\tif (this.blending !== blending) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (blending) {\n\t\t\t\tgl.enable(gl.BLEND);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.BLEND);\n\t\t\t}\n\n\t\t\tthis.blending = blending;\n\t\t}\n\t}\n\n\tsetStencilTest(enable) {\n\t\tif (this.stencil !== enable) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (enable) {\n\t\t\t\tgl.enable(gl.STENCIL_TEST);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.STENCIL_TEST);\n\t\t\t}\n\n\t\t\tthis.stencil = enable;\n\t\t}\n\t}\n\n\tsetStencilFunc(func, ref, mask) {\n\t\tif (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.stencilFunc(this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncFront = this.stencilFuncBack = func;\n\t\t\tthis.stencilRefFront = this.stencilRefBack = ref;\n\t\t\tthis.stencilMaskFront = this.stencilMaskBack = mask;\n\t\t}\n\t}\n\n\tsetStencilFuncFront(func, ref, mask) {\n\t\tif (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncFront = func;\n\t\t\tthis.stencilRefFront = ref;\n\t\t\tthis.stencilMaskFront = mask;\n\t\t}\n\t}\n\n\tsetStencilFuncBack(func, ref, mask) {\n\t\tif (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncBack = func;\n\t\t\tthis.stencilRefBack = ref;\n\t\t\tthis.stencilMaskBack = mask;\n\t\t}\n\t}\n\n\tsetStencilOperation(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {\n\t\t\tthis.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailFront = this.stencilFailBack = fail;\n\t\t\tthis.stencilZfailFront = this.stencilZfailBack = zfail;\n\t\t\tthis.stencilZpassFront = this.stencilZpassBack = zpass;\n\t\t}\n\n\t\tif (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {\n\t\t\tthis.gl.stencilMask(writeMask);\n\t\t\tthis.stencilWriteMaskFront = writeMask;\n\t\t\tthis.stencilWriteMaskBack = writeMask;\n\t\t}\n\t}\n\n\tsetStencilOperationFront(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {\n\t\t\tthis.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailFront = fail;\n\t\t\tthis.stencilZfailFront = zfail;\n\t\t\tthis.stencilZpassFront = zpass;\n\t\t}\n\n\t\tif (this.stencilWriteMaskFront !== writeMask) {\n\t\t\tthis.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);\n\t\t\tthis.stencilWriteMaskFront = writeMask;\n\t\t}\n\t}\n\n\tsetStencilOperationBack(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {\n\t\t\tthis.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailBack = fail;\n\t\t\tthis.stencilZfailBack = zfail;\n\t\t\tthis.stencilZpassBack = zpass;\n\t\t}\n\n\t\tif (this.stencilWriteMaskBack !== writeMask) {\n\t\t\tthis.gl.stencilMaskSeparate(this.gl.BACK, writeMask);\n\t\t\tthis.stencilWriteMaskBack = writeMask;\n\t\t}\n\t}\n\n\tsetBlendFunction(blendSrc, blendDst) {\n\t\tif (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {\n\t\t\tthis.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);\n\t\t\tthis.blendSrc = blendSrc;\n\t\t\tthis.blendDst = blendDst;\n\t\t\tthis.separateAlphaBlend = false;\n\t\t}\n\t}\n\n\tsetBlendFunctionSeparate(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {\n\t\tif (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {\n\t\t\tthis.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);\n\t\t\tthis.blendSrc = blendSrc;\n\t\t\tthis.blendDst = blendDst;\n\t\t\tthis.blendSrcAlpha = blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = blendDstAlpha;\n\t\t\tthis.separateAlphaBlend = true;\n\t\t}\n\t}\n\n\tsetBlendEquation(blendEquation) {\n\t\tif (this.blendEquation !== blendEquation || this.separateAlphaEquation) {\n\t\t\tthis.gl.blendEquation(this.glBlendEquation[blendEquation]);\n\t\t\tthis.blendEquation = blendEquation;\n\t\t\tthis.separateAlphaEquation = false;\n\t\t}\n\t}\n\n\tsetBlendEquationSeparate(blendEquation, blendAlphaEquation) {\n\t\tif (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {\n\t\t\tthis.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);\n\t\t\tthis.blendEquation = blendEquation;\n\t\t\tthis.blendAlphaEquation = blendAlphaEquation;\n\t\t\tthis.separateAlphaEquation = true;\n\t\t}\n\t}\n\n\tsetCullMode(cullMode) {\n\t\tif (this.cullMode !== cullMode) {\n\t\t\tif (cullMode === CULLFACE_NONE) {\n\t\t\t\tthis.gl.disable(this.gl.CULL_FACE);\n\t\t\t} else {\n\t\t\t\tif (this.cullMode === CULLFACE_NONE) {\n\t\t\t\t\tthis.gl.enable(this.gl.CULL_FACE);\n\t\t\t\t}\n\n\t\t\t\tconst mode = this.glCull[cullMode];\n\n\t\t\t\tif (this.cullFace !== mode) {\n\t\t\t\t\tthis.gl.cullFace(mode);\n\t\t\t\t\tthis.cullFace = mode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.cullMode = cullMode;\n\t\t}\n\t}\n\n\tgetCullMode() {\n\t\treturn this.cullMode;\n\t}\n\n\tsetIndexBuffer(indexBuffer) {\n\t\tthis.indexBuffer = indexBuffer;\n\t}\n\n\tsetVertexBuffer(vertexBuffer) {\n\t\tif (vertexBuffer) {\n\t\t\tthis.vertexBuffers.push(vertexBuffer);\n\t\t}\n\t}\n\n\tcompileShaderSource(src, isVertexShader) {\n\t\tconst gl = this.gl;\n\t\tlet glShader = isVertexShader ? this.vertexShaderCache[src] : this.fragmentShaderCache[src];\n\n\t\tif (!glShader) {\n\t\t\tglShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\n\t\t\tgl.shaderSource(glShader, src);\n\t\t\tgl.compileShader(glShader);\n\n\t\t\tif (isVertexShader) {\n\t\t\t\tthis.vertexShaderCache[src] = glShader;\n\t\t\t} else {\n\t\t\t\tthis.fragmentShaderCache[src] = glShader;\n\t\t\t}\n\t\t}\n\n\t\treturn glShader;\n\t}\n\n\tcompileAndLinkShader(shader) {\n\t\tconst definition = shader.definition;\n\t\tconst glVertexShader = this.compileShaderSource(definition.vshader, true);\n\t\tconst glFragmentShader = this.compileShaderSource(definition.fshader, false);\n\t\tconst gl = this.gl;\n\t\tconst glProgram = gl.createProgram();\n\t\tgl.attachShader(glProgram, glVertexShader);\n\t\tgl.attachShader(glProgram, glFragmentShader);\n\t\tconst attrs = definition.attributes;\n\n\t\tif (this.webgl2 && definition.useTransformFeedback) {\n\t\t\tconst outNames = [];\n\n\t\t\tfor (const attr in attrs) {\n\t\t\t\tif (attrs.hasOwnProperty(attr)) {\n\t\t\t\t\toutNames.push(\"out_\" + attr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);\n\t\t}\n\n\t\tconst locations = {};\n\n\t\tfor (const attr in attrs) {\n\t\t\tif (attrs.hasOwnProperty(attr)) {\n\t\t\t\tconst semantic = attrs[attr];\n\t\t\t\tconst loc = semanticToLocation[semantic];\n\t\t\t\tlocations[loc] = attr;\n\t\t\t\tgl.bindAttribLocation(glProgram, loc, attr);\n\t\t\t}\n\t\t}\n\n\t\tgl.linkProgram(glProgram);\n\t\tshader._glVertexShader = glVertexShader;\n\t\tshader._glFragmentShader = glFragmentShader;\n\t\tshader._glProgram = glProgram;\n\t}\n\n\tcreateShader(shader) {\n\t\tthis.compileAndLinkShader(shader);\n\t\tthis.shaders.push(shader);\n\t}\n\n\tdestroyShader(shader) {\n\t\tconst idx = this.shaders.indexOf(shader);\n\n\t\tif (idx !== -1) {\n\t\t\tthis.shaders.splice(idx, 1);\n\t\t}\n\n\t\tif (shader._glProgram) {\n\t\t\tthis.gl.deleteProgram(shader._glProgram);\n\t\t\tshader._glProgram = null;\n\t\t\tthis.removeShaderFromCache(shader);\n\t\t}\n\t}\n\n\t_processError(src, infoLog) {\n\t\tif (!src) return \"\";\n\t\tconst lines = src.split('\\n');\n\t\tconst error = {};\n\t\tlet code = '';\n\t\tlet from = 0;\n\t\tlet to = lines.length;\n\n\t\tif (infoLog && infoLog.startsWith('ERROR:')) {\n\t\t\tconst match = infoLog.match(/^ERROR:\\s([0-9]+):([0-9]+):\\s*(.+)/);\n\n\t\t\tif (match) {\n\t\t\t\terror.message = match[3];\n\t\t\t\terror.line = parseInt(match[2], 10);\n\t\t\t\tfrom = Math.max(0, error.line - 6);\n\t\t\t\tto = Math.min(lines.length, error.line + 5);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tcode += i + 1 + \":\\t\" + lines[i] + '\\n';\n\t\t}\n\n\t\terror.source = src;\n\t\treturn [code, error];\n\t}\n\n\t_isShaderCompiled(shader, glShader, source, shaderType) {\n\t\tconst gl = this.gl;\n\n\t\tif (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {\n\t\t\tconst infoLog = gl.getShaderInfoLog(glShader);\n\n\t\t\tconst [code, error] = this._processError(source, infoLog);\n\n\t\t\tconst message = `Failed to compile ${shaderType} shader:\\n\\n${infoLog}\\n${code}`;\n\t\t\tconsole.error(message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpostLink(shader) {\n\t\tconst gl = this.gl;\n\t\tconst glProgram = shader._glProgram;\n\t\tconst definition = shader.definition;\n\t\tif (!this._isShaderCompiled(shader, shader._glVertexShader, definition.vshader, \"vertex\")) return false;\n\t\tif (!this._isShaderCompiled(shader, shader._glFragmentShader, definition.fshader, \"fragment\")) return false;\n\n\t\tif (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n\t\t\tconst message = \"Failed to link shader program. Error: \" + gl.getProgramInfoLog(glProgram);\n\t\t\tconsole.error(message);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet i, info, location, shaderInput;\n\t\ti = 0;\n\t\tconst numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);\n\n\t\twhile (i < numAttributes) {\n\t\t\tinfo = gl.getActiveAttrib(glProgram, i++);\n\t\t\tlocation = gl.getAttribLocation(glProgram, info.name);\n\n\t\t\tif (definition.attributes[info.name] === undefined) {\n\t\t\t\tconsole.error(`Vertex shader attribute \"${info.name}\" is not mapped to a semantic in shader definition.`);\n\t\t\t}\n\n\t\t\tshaderInput = new ShaderInput(this, definition.attributes[info.name], this.pcUniformType[info.type], location);\n\t\t\tshader.attributes.push(shaderInput);\n\t\t}\n\n\t\ti = 0;\n\t\tconst numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);\n\n\t\twhile (i < numUniforms) {\n\t\t\tinfo = gl.getActiveUniform(glProgram, i++);\n\t\t\tlocation = gl.getUniformLocation(glProgram, info.name);\n\t\t\tshaderInput = new ShaderInput(this, info.name, this.pcUniformType[info.type], location);\n\n\t\t\tif (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || this.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {\n\t\t\t\tshader.samplers.push(shaderInput);\n\t\t\t} else {\n\t\t\t\tshader.uniforms.push(shaderInput);\n\t\t\t}\n\t\t}\n\n\t\tshader.ready = true;\n\t\treturn true;\n\t}\n\n\tsetShader(shader) {\n\t\tif (shader !== this.shader) {\n\t\t\tif (!shader.ready) {\n\t\t\t\tif (!this.postLink(shader)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.shader = shader;\n\t\t\tthis.gl.useProgram(shader._glProgram);\n\t\t\tthis.attributesInvalidated = true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tgetHdrFormat() {\n\t\tif (this.textureHalfFloatRenderable) {\n\t\t\treturn PIXELFORMAT_RGBA16F;\n\t\t} else if (this.textureFloatRenderable) {\n\t\t\treturn PIXELFORMAT_RGBA32F;\n\t\t}\n\n\t\treturn PIXELFORMAT_R8_G8_B8_A8;\n\t}\n\n\tgetBoneLimit() {\n\t\treturn this.boneLimit;\n\t}\n\n\tsetBoneLimit(maxBones) {\n\t\tthis.boneLimit = maxBones;\n\t}\n\n\tresizeCanvas(width, height) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tconst ratio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);\n\t\twidth = Math.floor(width * ratio);\n\t\theight = Math.floor(height * ratio);\n\n\t\tif (this.canvas.width !== width || this.canvas.height !== height) {\n\t\t\tthis.canvas.width = width;\n\t\t\tthis.canvas.height = height;\n\t\t\tthis.fire(EVENT_RESIZE, width, height);\n\t\t}\n\t}\n\n\tsetResolution(width, height) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis.canvas.width = width;\n\t\tthis.canvas.height = height;\n\t\tthis.fire(EVENT_RESIZE, width, height);\n\t}\n\n\tclearShaderCache() {\n\t\tconst gl = this.gl;\n\n\t\tfor (const shaderSrc in this.fragmentShaderCache) {\n\t\t\tgl.deleteShader(this.fragmentShaderCache[shaderSrc]);\n\t\t\tdelete this.fragmentShaderCache[shaderSrc];\n\t\t}\n\n\t\tfor (const shaderSrc in this.vertexShaderCache) {\n\t\t\tgl.deleteShader(this.vertexShaderCache[shaderSrc]);\n\t\t\tdelete this.vertexShaderCache[shaderSrc];\n\t\t}\n\n\t\tthis.programLib.clearCache();\n\t}\n\n\tclearVertexArrayObjectCache() {\n\t\tconst gl = this.gl;\n\n\t\tthis._vaoMap.forEach((item, key, mapObj) => {\n\t\t\tgl.deleteVertexArray(item);\n\t\t});\n\n\t\tthis._vaoMap.clear();\n\t}\n\n\tremoveShaderFromCache(shader) {\n\t\tthis.programLib.removeFromCache(shader);\n\t}\n\n\tget width() {\n\t\treturn this.gl.drawingBufferWidth || this.canvas.width;\n\t}\n\n\tget height() {\n\t\treturn this.gl.drawingBufferHeight || this.canvas.height;\n\t}\n\n\tset fullscreen(fullscreen) {\n\t\tif (fullscreen) {\n\t\t\tconst canvas = this.gl.canvas;\n\t\t\tcanvas.requestFullscreen();\n\t\t} else {\n\t\t\tdocument.exitFullscreen();\n\t\t}\n\t}\n\n\tget fullscreen() {\n\t\treturn !!document.fullscreenElement;\n\t}\n\n\tset enableAutoInstancing(value) {\n\t\tthis._enableAutoInstancing = value && this.extInstancing;\n\t}\n\n\tget enableAutoInstancing() {\n\t\treturn this._enableAutoInstancing;\n\t}\n\n\tset maxPixelRatio(ratio) {\n\t\tthis._maxPixelRatio = ratio;\n\t\tthis.resizeCanvas(this._width, this._height);\n\t}\n\n\tget maxPixelRatio() {\n\t\treturn this._maxPixelRatio;\n\t}\n\n\tget textureFloatHighPrecision() {\n\t\tif (this._textureFloatHighPrecision === undefined) {\n\t\t\tthis._textureFloatHighPrecision = testTextureFloatHighPrecision(this);\n\t\t}\n\n\t\treturn this._textureFloatHighPrecision;\n\t}\n\n\tget textureHalfFloatUpdatable() {\n\t\tif (this._textureHalfFloatUpdatable === undefined) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tthis._textureHalfFloatUpdatable = true;\n\t\t\t} else {\n\t\t\t\tthis._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);\n\t\t\t}\n\t\t}\n\n\t\treturn this._textureHalfFloatUpdatable;\n\t}\n\n}\n\nconst defaultOptions = {\n\tdepth: true,\n\tface: 0\n};\n\nclass RenderTarget {\n\tconstructor(options) {\n\t\tvar _this$_colorBuffer, _this$_depthBuffer;\n\n\t\tconst _arg2 = arguments[1];\n\t\tconst _arg3 = arguments[2];\n\n\t\tif (options instanceof GraphicsDevice) {\n\t\t\tthis._colorBuffer = _arg2;\n\t\t\toptions = _arg3;\n\t\t} else {\n\t\t\tthis._colorBuffer = options.colorBuffer;\n\t\t}\n\n\t\tif (this._colorBuffer) {\n\t\t\tthis._colorBuffer._isRenderTarget = true;\n\t\t}\n\n\t\tthis._glFrameBuffer = null;\n\t\tthis._glDepthBuffer = null;\n\t\toptions = options !== undefined ? options : defaultOptions;\n\t\tthis._depthBuffer = options.depthBuffer;\n\t\tthis._face = options.face !== undefined ? options.face : 0;\n\n\t\tif (this._depthBuffer) {\n\t\t\tconst format = this._depthBuffer._format;\n\n\t\t\tif (format === PIXELFORMAT_DEPTH) {\n\t\t\t\tthis._depth = true;\n\t\t\t\tthis._stencil = false;\n\t\t\t} else if (format === PIXELFORMAT_DEPTHSTENCIL) {\n\t\t\t\tthis._depth = true;\n\t\t\t\tthis._stencil = true;\n\t\t\t} else {\n\t\t\t\tthis._depth = false;\n\t\t\t\tthis._stencil = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._depth = options.depth !== undefined ? options.depth : true;\n\t\t\tthis._stencil = options.stencil !== undefined ? options.stencil : false;\n\t\t}\n\n\t\tthis._device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device);\n\t\tthis._samples = options.samples !== undefined ? Math.min(options.samples, this._device.maxSamples) : 1;\n\t\tthis.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;\n\t\tthis._glResolveFrameBuffer = null;\n\t\tthis._glMsaaColorBuffer = null;\n\t\tthis._glMsaaDepthBuffer = null;\n\t\tthis.name = options.name;\n\n\t\tif (!this.name) {\n\t\t\tvar _this$_colorBuffer2;\n\n\t\t\tthis.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;\n\t\t}\n\n\t\tif (!this.name) {\n\t\t\tvar _this$_depthBuffer2;\n\n\t\t\tthis.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;\n\t\t}\n\n\t\tif (!this.name) {\n\t\t\tthis.name = \"Untitled\";\n\t\t}\n\n\t\tthis.flipY = !!options.flipY;\n\t}\n\n\tdestroy() {\n\t\tconst device = this._device;\n\n\t\tif (device) {\n\t\t\tconst idx = device.targets.indexOf(this);\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tdevice.targets.splice(idx, 1);\n\t\t\t}\n\n\t\t\tthis.destroyFrameBuffers();\n\t\t}\n\t}\n\n\tdestroyFrameBuffers() {\n\t\tconst device = this._device;\n\n\t\tif (device) {\n\t\t\tconst gl = device.gl;\n\n\t\t\tif (this._glFrameBuffer) {\n\t\t\t\tgl.deleteFramebuffer(this._glFrameBuffer);\n\t\t\t\tthis._glFrameBuffer = null;\n\t\t\t}\n\n\t\t\tif (this._glDepthBuffer) {\n\t\t\t\tgl.deleteRenderbuffer(this._glDepthBuffer);\n\t\t\t\tthis._glDepthBuffer = null;\n\t\t\t}\n\n\t\t\tif (this._glResolveFrameBuffer) {\n\t\t\t\tgl.deleteFramebuffer(this._glResolveFrameBuffer);\n\t\t\t\tthis._glResolveFrameBuffer = null;\n\t\t\t}\n\n\t\t\tif (this._glMsaaColorBuffer) {\n\t\t\t\tgl.deleteRenderbuffer(this._glMsaaColorBuffer);\n\t\t\t\tthis._glMsaaColorBuffer = null;\n\t\t\t}\n\n\t\t\tif (this._glMsaaDepthBuffer) {\n\t\t\t\tgl.deleteRenderbuffer(this._glMsaaDepthBuffer);\n\t\t\t\tthis._glMsaaDepthBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroyTextureBuffers() {\n\t\tif (this._depthBuffer) {\n\t\t\tthis._depthBuffer.destroy();\n\n\t\t\tthis._depthBuffer = null;\n\t\t}\n\n\t\tif (this._colorBuffer) {\n\t\t\tthis._colorBuffer.destroy();\n\n\t\t\tthis._colorBuffer = null;\n\t\t}\n\t}\n\n\tloseContext() {\n\t\tthis._glFrameBuffer = undefined;\n\t\tthis._glDepthBuffer = undefined;\n\t\tthis._glResolveFrameBuffer = undefined;\n\t\tthis._glMsaaColorBuffer = undefined;\n\t\tthis._glMsaaDepthBuffer = undefined;\n\t}\n\n\tresolve(color = true, depth = !!this._depthBuffer) {\n\t\tif (!this._device) return;\n\t\tif (!this._device.webgl2) return;\n\t\tconst gl = this._device.gl;\n\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);\n\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);\n\t\tgl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);\n\t}\n\n\tcopy(source, color, depth) {\n\t\tif (!this._device) {\n\t\t\tif (source._device) {\n\t\t\t\tthis._device = source._device;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn this._device.copyRenderTarget(source, this, color, depth);\n\t}\n\n\tget colorBuffer() {\n\t\treturn this._colorBuffer;\n\t}\n\n\tget depthBuffer() {\n\t\treturn this._depthBuffer;\n\t}\n\n\tget face() {\n\t\treturn this._face;\n\t}\n\n\tget width() {\n\t\treturn this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;\n\t}\n\n\tget height() {\n\t\treturn this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;\n\t}\n\n}\n\nfunction areaElement(x, y) {\n\treturn Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\n}\n\nfunction texelCoordSolidAngle(u, v, size) {\n\tlet _u = 2.0 * (u + 0.5) / size - 1.0;\n\n\tlet _v = 2.0 * (v + 0.5) / size - 1.0;\n\n\t_u *= 1.0 - 1.0 / size;\n\t_v *= 1.0 - 1.0 / size;\n\tconst invResolution = 1.0 / size;\n\tconst x0 = _u - invResolution;\n\tconst y0 = _v - invResolution;\n\tconst x1 = _u + invResolution;\n\tconst y1 = _v + invResolution;\n\tlet solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);\n\n\tif (u === 0 && v === 0 || u === size - 1 && v === 0 || u === 0 && v === size - 1 || u === size - 1 && v === size - 1) {\n\t\tsolidAngle /= 3;\n\t} else if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {\n\t\tsolidAngle *= 0.5;\n\t}\n\n\treturn solidAngle;\n}\n\nfunction shFromCubemap(device, source, dontFlipX) {\n\tif (source.format !== PIXELFORMAT_R8_G8_B8_A8) {\n\t\treturn null;\n\t}\n\n\tif (!source._levels[0] || !source._levels[0][0]) {\n\t\treturn null;\n\t}\n\n\tconst cubeSize = source.width;\n\n\tif (!source._levels[0][0].length) {\n\t\tif (source._levels[0][0] instanceof HTMLImageElement) {\n\t\t\tconst shader = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.fullscreenQuadPS, \"fsQuadSimple\");\n\t\t\tconst constantTexSource = device.scope.resolve(\"source\");\n\n\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\tconst img = source._levels[0][face];\n\t\t\t\tconst tex = new Texture(device, {\n\t\t\t\t\tcubemap: false,\n\t\t\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\t\t\tformat: source.format,\n\t\t\t\t\twidth: cubeSize,\n\t\t\t\t\theight: cubeSize,\n\t\t\t\t\tmipmaps: false\n\t\t\t\t});\n\t\t\t\ttex.name = 'prefiltered-cube';\n\t\t\t\ttex._levels[0] = img;\n\t\t\t\ttex.upload();\n\t\t\t\tconst tex2 = new Texture(device, {\n\t\t\t\t\tcubemap: false,\n\t\t\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\t\t\tformat: source.format,\n\t\t\t\t\twidth: cubeSize,\n\t\t\t\t\theight: cubeSize,\n\t\t\t\t\tmipmaps: false\n\t\t\t\t});\n\t\t\t\ttex2.name = 'prefiltered-cube';\n\t\t\t\tconst targ = new RenderTarget({\n\t\t\t\t\tcolorBuffer: tex2,\n\t\t\t\t\tdepth: false\n\t\t\t\t});\n\t\t\t\tconstantTexSource.setValue(tex);\n\t\t\t\tdrawQuadWithShader(device, targ, shader);\n\t\t\t\tconst gl = device.gl;\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, targ._glFrameBuffer);\n\t\t\t\tconst pixels = new Uint8Array(cubeSize * cubeSize * 4);\n\t\t\t\tgl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\t\t\t\tsource._levels[0][face] = pixels;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst dirs = [];\n\n\tfor (let y = 0; y < cubeSize; y++) {\n\t\tfor (let x = 0; x < cubeSize; x++) {\n\t\t\tconst u = x / (cubeSize - 1) * 2 - 1;\n\t\t\tconst v = y / (cubeSize - 1) * 2 - 1;\n\t\t\tdirs[y * cubeSize + x] = new Vec3(u, v, 1.0).normalize();\n\t\t}\n\t}\n\n\tconst sh = new Float32Array(9 * 3);\n\tconst coef1 = 0;\n\tconst coef2 = 1 * 3;\n\tconst coef3 = 2 * 3;\n\tconst coef4 = 3 * 3;\n\tconst coef5 = 4 * 3;\n\tconst coef6 = 5 * 3;\n\tconst coef7 = 6 * 3;\n\tconst coef8 = 7 * 3;\n\tconst coef9 = 8 * 3;\n\tconst nx = 0;\n\tconst px = 1;\n\tconst ny = 2;\n\tconst py = 3;\n\tconst nz = 4;\n\tconst pz = 5;\n\tlet accum = 0;\n\n\tfor (let face = 0; face < 6; face++) {\n\t\tfor (let y = 0; y < cubeSize; y++) {\n\t\t\tfor (let x = 0; x < cubeSize; x++) {\n\t\t\t\tconst addr = y * cubeSize + x;\n\t\t\t\tconst weight = texelCoordSolidAngle(x, y, cubeSize);\n\t\t\t\tconst weight1 = weight * 4 / 17;\n\t\t\t\tconst weight2 = weight * 8 / 17;\n\t\t\t\tconst weight3 = weight * 15 / 17;\n\t\t\t\tconst weight4 = weight * 5 / 68;\n\t\t\t\tconst weight5 = weight * 15 / 68;\n\t\t\t\tconst dir = dirs[addr];\n\t\t\t\tlet dx, dy, dz;\n\n\t\t\t\tif (face === nx) {\n\t\t\t\t\tdx = dir.z;\n\t\t\t\t\tdy = -dir.y;\n\t\t\t\t\tdz = -dir.x;\n\t\t\t\t} else if (face === px) {\n\t\t\t\t\tdx = -dir.z;\n\t\t\t\t\tdy = -dir.y;\n\t\t\t\t\tdz = dir.x;\n\t\t\t\t} else if (face === ny) {\n\t\t\t\t\tdx = dir.x;\n\t\t\t\t\tdy = dir.z;\n\t\t\t\t\tdz = dir.y;\n\t\t\t\t} else if (face === py) {\n\t\t\t\t\tdx = dir.x;\n\t\t\t\t\tdy = -dir.z;\n\t\t\t\t\tdz = -dir.y;\n\t\t\t\t} else if (face === nz) {\n\t\t\t\t\tdx = dir.x;\n\t\t\t\t\tdy = -dir.y;\n\t\t\t\t\tdz = dir.z;\n\t\t\t\t} else if (face === pz) {\n\t\t\t\t\tdx = -dir.x;\n\t\t\t\t\tdy = -dir.y;\n\t\t\t\t\tdz = -dir.z;\n\t\t\t\t}\n\n\t\t\t\tif (!dontFlipX) dx = -dx;\n\t\t\t\tconst a = source._levels[0][face][addr * 4 + 3] / 255.0;\n\n\t\t\t\tfor (let c = 0; c < 3; c++) {\n\t\t\t\t\tlet value = source._levels[0][face][addr * 4 + c] / 255.0;\n\n\t\t\t\t\tif (source.type === TEXTURETYPE_RGBM) {\n\t\t\t\t\t\tvalue *= a * 8.0;\n\t\t\t\t\t\tvalue *= value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = Math.pow(value, 2.2);\n\t\t\t\t\t}\n\n\t\t\t\t\tsh[coef1 + c] += value * weight1;\n\t\t\t\t\tsh[coef2 + c] += value * weight2 * dx;\n\t\t\t\t\tsh[coef3 + c] += value * weight2 * dy;\n\t\t\t\t\tsh[coef4 + c] += value * weight2 * dz;\n\t\t\t\t\tsh[coef5 + c] += value * weight3 * dx * dz;\n\t\t\t\t\tsh[coef6 + c] += value * weight3 * dz * dy;\n\t\t\t\t\tsh[coef7 + c] += value * weight3 * dy * dx;\n\t\t\t\t\tsh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);\n\t\t\t\t\tsh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);\n\t\t\t\t\taccum += weight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (let c = 0; c < sh.length; c++) {\n\t\tsh[c] *= 4 * Math.PI / accum;\n\t}\n\n\treturn sh;\n}\n\nclass IndexBuffer {\n\tconstructor(graphicsDevice, format, numIndices, usage = BUFFER_STATIC, initialData) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.format = format;\n\t\tthis.numIndices = numIndices;\n\t\tthis.usage = usage;\n\t\tconst gl = this.device.gl;\n\t\tlet bytesPerIndex;\n\n\t\tif (format === INDEXFORMAT_UINT8) {\n\t\t\tbytesPerIndex = 1;\n\t\t\tthis.glFormat = gl.UNSIGNED_BYTE;\n\t\t} else if (format === INDEXFORMAT_UINT16) {\n\t\t\tbytesPerIndex = 2;\n\t\t\tthis.glFormat = gl.UNSIGNED_SHORT;\n\t\t} else if (format === INDEXFORMAT_UINT32) {\n\t\t\tbytesPerIndex = 4;\n\t\t\tthis.glFormat = gl.UNSIGNED_INT;\n\t\t}\n\n\t\tthis.bytesPerIndex = bytesPerIndex;\n\t\tthis.numBytes = this.numIndices * bytesPerIndex;\n\n\t\tif (initialData) {\n\t\t\tthis.setData(initialData);\n\t\t} else {\n\t\t\tthis.storage = new ArrayBuffer(this.numBytes);\n\t\t}\n\n\t\tgraphicsDevice._vram.ib += this.numBytes;\n\t\tthis.device.buffers.push(this);\n\t}\n\n\tdestroy() {\n\t\tconst device = this.device;\n\t\tconst idx = device.buffers.indexOf(this);\n\n\t\tif (idx !== -1) {\n\t\t\tdevice.buffers.splice(idx, 1);\n\t\t}\n\n\t\tif (this.bufferId) {\n\t\t\tconst gl = this.device.gl;\n\t\t\tgl.deleteBuffer(this.bufferId);\n\t\t\tthis.device._vram.ib -= this.storage.byteLength;\n\t\t\tthis.bufferId = null;\n\n\t\t\tif (this.device.indexBuffer === this) {\n\t\t\t\tthis.device.indexBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tloseContext() {\n\t\tthis.bufferId = undefined;\n\t}\n\n\tgetFormat() {\n\t\treturn this.format;\n\t}\n\n\tgetNumIndices() {\n\t\treturn this.numIndices;\n\t}\n\n\tlock() {\n\t\treturn this.storage;\n\t}\n\n\tunlock() {\n\t\tconst gl = this.device.gl;\n\n\t\tif (!this.bufferId) {\n\t\t\tthis.bufferId = gl.createBuffer();\n\t\t}\n\n\t\tlet glUsage;\n\n\t\tswitch (this.usage) {\n\t\t\tcase BUFFER_STATIC:\n\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_DYNAMIC:\n\t\t\t\tglUsage = gl.DYNAMIC_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_STREAM:\n\t\t\t\tglUsage = gl.STREAM_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_GPUDYNAMIC:\n\t\t\t\tif (this.device.webgl2) {\n\t\t\t\t\tglUsage = gl.DYNAMIC_COPY;\n\t\t\t\t} else {\n\t\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferId);\n\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.storage, glUsage);\n\t}\n\n\tsetData(data) {\n\t\tif (data.byteLength !== this.numBytes) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.storage = data;\n\t\tthis.unlock();\n\t\treturn true;\n\t}\n\n\t_lockTypedArray() {\n\t\tconst lock = this.lock();\n\t\tconst indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);\n\t\treturn indices;\n\t}\n\n\twriteData(data, count) {\n\t\tconst indices = this._lockTypedArray();\n\n\t\tif (data.length > count) {\n\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\tdata = data.subarray(0, count);\n\t\t\t\tindices.set(data);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < count; i++) indices[i] = data[i];\n\t\t\t}\n\t\t} else {\n\t\t\tindices.set(data);\n\t\t}\n\n\t\tthis.unlock();\n\t}\n\n\treadData(data) {\n\t\tconst indices = this._lockTypedArray();\n\n\t\tconst count = this.numIndices;\n\n\t\tif (ArrayBuffer.isView(data)) {\n\t\t\tdata.set(indices);\n\t\t} else {\n\t\t\tdata.length = 0;\n\n\t\t\tfor (let i = 0; i < count; i++) data[i] = indices[i];\n\t\t}\n\n\t\treturn count;\n\t}\n\n}\n\nfunction set1(a) {\n\tthis.array[this.index] = a;\n}\n\nfunction set2(a, b) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n}\n\nfunction set3(a, b, c) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n\tthis.array[this.index + 2] = c;\n}\n\nfunction set4(a, b, c, d) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n\tthis.array[this.index + 2] = c;\n\tthis.array[this.index + 3] = d;\n}\n\nfunction arraySet1(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n}\n\nfunction arraySet2(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n}\n\nfunction arraySet3(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n\tthis.array[index + 2] = inputArray[inputIndex + 2];\n}\n\nfunction arraySet4(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n\tthis.array[index + 2] = inputArray[inputIndex + 2];\n\tthis.array[index + 3] = inputArray[inputIndex + 3];\n}\n\nfunction arrayGet1(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n}\n\nfunction arrayGet2(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n}\n\nfunction arrayGet3(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n\toutputArray[outputIndex + 2] = this.array[offset + 2];\n}\n\nfunction arrayGet4(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n\toutputArray[outputIndex + 2] = this.array[offset + 2];\n\toutputArray[outputIndex + 3] = this.array[offset + 3];\n}\n\nclass VertexIteratorAccessor {\n\tconstructor(buffer, vertexElement, vertexFormat) {\n\t\tthis.index = 0;\n\t\tthis.numComponents = vertexElement.numComponents;\n\n\t\tif (vertexFormat.interleaved) {\n\t\t\tthis.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);\n\t\t} else {\n\t\t\tthis.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);\n\t\t}\n\n\t\tthis.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;\n\n\t\tswitch (vertexElement.numComponents) {\n\t\t\tcase 1:\n\t\t\t\tthis.set = set1;\n\t\t\t\tthis.getToArray = arrayGet1;\n\t\t\t\tthis.setFromArray = arraySet1;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tthis.set = set2;\n\t\t\t\tthis.getToArray = arrayGet2;\n\t\t\t\tthis.setFromArray = arraySet2;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tthis.set = set3;\n\t\t\t\tthis.getToArray = arrayGet3;\n\t\t\t\tthis.setFromArray = arraySet3;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tthis.set = set4;\n\t\t\t\tthis.getToArray = arrayGet4;\n\t\t\t\tthis.setFromArray = arraySet4;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tget(offset) {\n\t\treturn this.array[this.index + offset];\n\t}\n\n\tset(a, b, c, d) {}\n\n\tgetToArray(offset, outputArray, outputIndex) {}\n\n\tsetFromArray(index, inputArray, inputIndex) {}\n\n}\n\nclass VertexIterator {\n\tconstructor(vertexBuffer) {\n\t\tthis.vertexBuffer = vertexBuffer;\n\t\tthis.vertexFormatSize = vertexBuffer.getFormat().size;\n\t\tthis.buffer = this.vertexBuffer.lock();\n\t\tthis.accessors = [];\n\t\tthis.element = {};\n\t\tconst vertexFormat = this.vertexBuffer.getFormat();\n\n\t\tfor (let i = 0; i < vertexFormat.elements.length; i++) {\n\t\t\tconst vertexElement = vertexFormat.elements[i];\n\t\t\tthis.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);\n\t\t\tthis.element[vertexElement.name] = this.accessors[i];\n\t\t}\n\t}\n\n\tnext(count = 1) {\n\t\tlet i = 0;\n\t\tconst accessors = this.accessors;\n\t\tconst numAccessors = this.accessors.length;\n\n\t\twhile (i < numAccessors) {\n\t\t\tconst accessor = accessors[i++];\n\t\t\taccessor.index += count * accessor.stride;\n\t\t}\n\t}\n\n\tend() {\n\t\tthis.vertexBuffer.unlock();\n\t}\n\n\twriteData(semantic, data, numVertices) {\n\t\tconst element = this.element[semantic];\n\n\t\tif (element) {\n\t\t\tif (numVertices > this.vertexBuffer.numVertices) {\n\t\t\t\tnumVertices = this.vertexBuffer.numVertices;\n\t\t\t}\n\n\t\t\tconst numComponents = element.numComponents;\n\n\t\t\tif (this.vertexBuffer.getFormat().interleaved) {\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor (let i = 0; i < numVertices; i++) {\n\t\t\t\t\telement.setFromArray(index, data, i * numComponents);\n\t\t\t\t\tindex += element.stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (data.length > numVertices * numComponents) {\n\t\t\t\t\tconst copyCount = numVertices * numComponents;\n\n\t\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\t\tdata = data.subarray(0, copyCount);\n\t\t\t\t\t\telement.array.set(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0; i < copyCount; i++) element.array[i] = data[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.array.set(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treadData(semantic, data) {\n\t\tconst element = this.element[semantic];\n\t\tlet count = 0;\n\n\t\tif (element) {\n\t\t\tcount = this.vertexBuffer.numVertices;\n\t\t\tlet i;\n\t\t\tconst numComponents = element.numComponents;\n\n\t\t\tif (this.vertexBuffer.getFormat().interleaved) {\n\t\t\t\tif (Array.isArray(data)) data.length = 0;\n\t\t\t\telement.index = 0;\n\t\t\t\tlet offset = 0;\n\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\telement.getToArray(offset, data, i * numComponents);\n\t\t\t\t\toffset += element.stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\tdata.set(element.array);\n\t\t\t\t} else {\n\t\t\t\t\tdata.length = 0;\n\t\t\t\t\tconst copyCount = count * numComponents;\n\n\t\t\t\t\tfor (i = 0; i < copyCount; i++) data[i] = element.array[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n}\n\nconst primitive = {\n\ttype: PRIMITIVE_TRISTRIP,\n\tbase: 0,\n\tcount: 4,\n\tindexed: false\n};\n\nclass PostEffect$1 {\n\tconstructor(graphicsDevice) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.shader = null;\n\t\tthis.vertexBuffer = createFullscreenQuad(graphicsDevice);\n\t\tthis.needsDepthBuffer = false;\n\t\tthis.depthMap = null;\n\t}\n\n\trender(inputTarget, outputTarget, rect) {}\n\n}\n\nfunction createFullscreenQuad(device) {\n\tconst vertexFormat = new VertexFormat(device, [{\n\t\tsemantic: SEMANTIC_POSITION,\n\t\tcomponents: 2,\n\t\ttype: TYPE_FLOAT32\n\t}]);\n\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, 4);\n\tconst iterator = new VertexIterator(vertexBuffer);\n\titerator.element[SEMANTIC_POSITION].set(-1.0, -1.0);\n\titerator.next();\n\titerator.element[SEMANTIC_POSITION].set(1.0, -1.0);\n\titerator.next();\n\titerator.element[SEMANTIC_POSITION].set(-1.0, 1.0);\n\titerator.next();\n\titerator.element[SEMANTIC_POSITION].set(1.0, 1.0);\n\titerator.end();\n\treturn vertexBuffer;\n}\n\nfunction drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {\n\tconst oldRt = device.getRenderTarget();\n\tdevice.setRenderTarget(target);\n\tdevice.updateBegin();\n\tlet w = target ? target.width : device.width;\n\tlet h = target ? target.height : device.height;\n\tlet x = 0;\n\tlet y = 0;\n\n\tif (rect) {\n\t\tx = rect.x * w;\n\t\ty = rect.y * h;\n\t\tw *= rect.z;\n\t\th *= rect.w;\n\t}\n\n\tconst oldVx = device.vx;\n\tconst oldVy = device.vy;\n\tconst oldVw = device.vw;\n\tconst oldVh = device.vh;\n\tdevice.setViewport(x, y, w, h);\n\tconst oldSx = device.sx;\n\tconst oldSy = device.sy;\n\tconst oldSw = device.sw;\n\tconst oldSh = device.sh;\n\tdevice.setScissor(x, y, w, h);\n\tconst oldBlending = device.getBlending();\n\tconst oldDepthTest = device.getDepthTest();\n\tconst oldDepthWrite = device.getDepthWrite();\n\tconst oldCullMode = device.getCullMode();\n\tconst oldWR = device.writeRed;\n\tconst oldWG = device.writeGreen;\n\tconst oldWB = device.writeBlue;\n\tconst oldWA = device.writeAlpha;\n\tdevice.setBlending(false);\n\tdevice.setDepthTest(false);\n\tdevice.setDepthWrite(false);\n\tdevice.setCullMode(CULLFACE_NONE);\n\tdevice.setColorWrite(true, true, true, true);\n\tdevice.setVertexBuffer(vertexBuffer, 0);\n\tdevice.setShader(shader);\n\tdevice.draw(primitive);\n\tdevice.setBlending(oldBlending);\n\tdevice.setDepthTest(oldDepthTest);\n\tdevice.setDepthWrite(oldDepthWrite);\n\tdevice.setCullMode(oldCullMode);\n\tdevice.setColorWrite(oldWR, oldWG, oldWB, oldWA);\n\tdevice.updateEnd();\n\tdevice.setRenderTarget(oldRt);\n\tdevice.updateBegin();\n\tdevice.setViewport(oldVx, oldVy, oldVw, oldVh);\n\tdevice.setScissor(oldSx, oldSy, oldSw, oldSh);\n}\n\nclass TransformFeedback {\n\tconstructor(inputBuffer, usage = BUFFER_GPUDYNAMIC) {\n\t\tthis.device = inputBuffer.device;\n\t\tconst gl = this.device.gl;\n\t\tthis._inputBuffer = inputBuffer;\n\n\t\tif (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.bufferId);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);\n\t\t}\n\n\t\tthis._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);\n\t}\n\n\tstatic createShader(graphicsDevice, vsCode, name) {\n\t\treturn createShaderFromCode(graphicsDevice, vsCode, null, name, true);\n\t}\n\n\tdestroy() {\n\t\tthis._outputBuffer.destroy();\n\t}\n\n\tprocess(shader, swap = true) {\n\t\tconst device = this.device;\n\t\tconst oldRt = device.getRenderTarget();\n\t\tdevice.setRenderTarget(null);\n\t\tdevice.updateBegin();\n\t\tdevice.setVertexBuffer(this._inputBuffer, 0);\n\t\tdevice.setRaster(false);\n\t\tdevice.setTransformFeedbackBuffer(this._outputBuffer);\n\t\tdevice.setShader(shader);\n\t\tdevice.draw({\n\t\t\ttype: PRIMITIVE_POINTS,\n\t\t\tbase: 0,\n\t\t\tcount: this._inputBuffer.numVertices,\n\t\t\tindexed: false\n\t\t});\n\t\tdevice.setTransformFeedbackBuffer(null);\n\t\tdevice.setRaster(true);\n\t\tdevice.updateEnd();\n\t\tdevice.setRenderTarget(oldRt);\n\n\t\tif (swap) {\n\t\t\tlet tmp = this._inputBuffer.bufferId;\n\t\t\tthis._inputBuffer.bufferId = this._outputBuffer.bufferId;\n\t\t\tthis._outputBuffer.bufferId = tmp;\n\t\t\ttmp = this._inputBuffer._vao;\n\t\t\tthis._inputBuffer._vao = this._outputBuffer._vao;\n\t\t\tthis._outputBuffer._vao = tmp;\n\t\t}\n\t}\n\n\tget inputBuffer() {\n\t\treturn this._inputBuffer;\n\t}\n\n\tget outputBuffer() {\n\t\treturn this._outputBuffer;\n\t}\n\n}\n\nclass RefCountedObject {\n\tconstructor() {\n\t\tthis._refCount = 0;\n\t}\n\n\tincRefCount() {\n\t\tthis._refCount++;\n\t}\n\n\tdecRefCount() {\n\t\tthis._refCount--;\n\t}\n\n\tget refCount() {\n\t\treturn this._refCount;\n\t}\n\n}\n\nlet currentApplication;\n\nfunction getApplication() {\n\treturn currentApplication;\n}\n\nfunction setApplication(app) {\n\tcurrentApplication = app;\n}\n\nlet id$1 = 0;\n\nclass GeometryData {\n\tconstructor() {\n\t\tthis.initDefaults();\n\t}\n\n\tinitDefaults() {\n\t\tthis.recreate = false;\n\t\tthis.verticesUsage = BUFFER_STATIC;\n\t\tthis.indicesUsage = BUFFER_STATIC;\n\t\tthis.maxVertices = 0;\n\t\tthis.maxIndices = 0;\n\t\tthis.vertexCount = 0;\n\t\tthis.indexCount = 0;\n\t\tthis.vertexStreamsUpdated = false;\n\t\tthis.indexStreamUpdated = false;\n\t\tthis.vertexStreamDictionary = {};\n\t\tthis.indices = null;\n\t}\n\n\t_changeVertexCount(count, semantic) {\n\t\tif (!this.vertexCount) {\n\t\t\tthis.vertexCount = count;\n\t\t}\n\t}\n\n}\n\nGeometryData.DEFAULT_COMPONENTS_POSITION = 3;\nGeometryData.DEFAULT_COMPONENTS_NORMAL = 3;\nGeometryData.DEFAULT_COMPONENTS_UV = 2;\nGeometryData.DEFAULT_COMPONENTS_COLORS = 4;\n\nclass GeometryVertexStream {\n\tconstructor(data, componentCount, dataType, dataTypeNormalize) {\n\t\tthis.data = data;\n\t\tthis.componentCount = componentCount;\n\t\tthis.dataType = dataType;\n\t\tthis.dataTypeNormalize = dataTypeNormalize;\n\t}\n\n}\n\nclass Mesh extends RefCountedObject {\n\tconstructor(graphicsDevice) {\n\t\tsuper();\n\t\tthis.id = id$1++;\n\t\tthis.device = graphicsDevice || getApplication().graphicsDevice;\n\t\tthis.vertexBuffer = null;\n\t\tthis.indexBuffer = [null];\n\t\tthis.primitive = [{\n\t\t\ttype: 0,\n\t\t\tbase: 0,\n\t\t\tcount: 0\n\t\t}];\n\t\tthis.skin = null;\n\t\tthis._morph = null;\n\t\tthis._geometryData = null;\n\t\tthis._aabb = new BoundingBox();\n\t\tthis.boneAabb = null;\n\t}\n\n\tset morph(morph) {\n\t\tif (morph !== this._morph) {\n\t\t\tif (this._morph) {\n\t\t\t\tthis._morph.decRefCount();\n\t\t\t}\n\n\t\t\tthis._morph = morph;\n\n\t\t\tif (morph) {\n\t\t\t\tmorph.incRefCount();\n\t\t\t}\n\t\t}\n\t}\n\n\tget morph() {\n\t\treturn this._morph;\n\t}\n\n\tset aabb(aabb) {\n\t\tthis._aabb = aabb;\n\t}\n\n\tget aabb() {\n\t\treturn this._aabb;\n\t}\n\n\tdestroy() {\n\t\tconst morph = this.morph;\n\n\t\tif (morph) {\n\t\t\tthis.morph = null;\n\n\t\t\tif (morph.refCount < 1) {\n\t\t\t\tmorph.destroy();\n\t\t\t}\n\t\t}\n\n\t\tif (this.vertexBuffer) {\n\t\t\tthis.vertexBuffer.destroy();\n\t\t\tthis.vertexBuffer = null;\n\t\t}\n\n\t\tfor (let j = 0; j < this.indexBuffer.length; j++) {\n\t\t\tthis._destroyIndexBuffer(j);\n\t\t}\n\n\t\tthis.indexBuffer.length = 0;\n\t\tthis._geometryData = null;\n\t}\n\n\t_destroyIndexBuffer(index) {\n\t\tif (this.indexBuffer[index]) {\n\t\t\tthis.indexBuffer[index].destroy();\n\t\t\tthis.indexBuffer[index] = null;\n\t\t}\n\t}\n\n\t_initBoneAabbs(morphTargets) {\n\t\tthis.boneAabb = [];\n\t\tthis.boneUsed = [];\n\t\tlet x, y, z;\n\t\tlet bMax, bMin;\n\t\tconst boneMin = [];\n\t\tconst boneMax = [];\n\t\tconst boneUsed = this.boneUsed;\n\t\tconst numBones = this.skin.boneNames.length;\n\t\tlet maxMorphX, maxMorphY, maxMorphZ;\n\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tboneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n\t\t\tboneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\t\t}\n\n\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\tconst posElement = iterator.element[SEMANTIC_POSITION];\n\t\tconst weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];\n\t\tconst indicesElement = iterator.element[SEMANTIC_BLENDINDICES];\n\t\tconst numVerts = this.vertexBuffer.numVertices;\n\n\t\tfor (let j = 0; j < numVerts; j++) {\n\t\t\tfor (let k = 0; k < 4; k++) {\n\t\t\t\tconst boneWeight = weightsElement.array[weightsElement.index + k];\n\n\t\t\t\tif (boneWeight > 0) {\n\t\t\t\t\tconst boneIndex = indicesElement.array[indicesElement.index + k];\n\t\t\t\t\tboneUsed[boneIndex] = true;\n\t\t\t\t\tx = posElement.array[posElement.index];\n\t\t\t\t\ty = posElement.array[posElement.index + 1];\n\t\t\t\t\tz = posElement.array[posElement.index + 2];\n\t\t\t\t\tbMax = boneMax[boneIndex];\n\t\t\t\t\tbMin = boneMin[boneIndex];\n\t\t\t\t\tif (bMin.x > x) bMin.x = x;\n\t\t\t\t\tif (bMin.y > y) bMin.y = y;\n\t\t\t\t\tif (bMin.z > z) bMin.z = z;\n\t\t\t\t\tif (bMax.x < x) bMax.x = x;\n\t\t\t\t\tif (bMax.y < y) bMax.y = y;\n\t\t\t\t\tif (bMax.z < z) bMax.z = z;\n\n\t\t\t\t\tif (morphTargets) {\n\t\t\t\t\t\tlet minMorphX = maxMorphX = x;\n\t\t\t\t\t\tlet minMorphY = maxMorphY = y;\n\t\t\t\t\t\tlet minMorphZ = maxMorphZ = z;\n\n\t\t\t\t\t\tfor (let l = 0; l < morphTargets.length; l++) {\n\t\t\t\t\t\t\tconst target = morphTargets[l];\n\t\t\t\t\t\t\tconst dx = target.deltaPositions[j * 3];\n\t\t\t\t\t\t\tconst dy = target.deltaPositions[j * 3 + 1];\n\t\t\t\t\t\t\tconst dz = target.deltaPositions[j * 3 + 2];\n\n\t\t\t\t\t\t\tif (dx < 0) {\n\t\t\t\t\t\t\t\tminMorphX += dx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphX += dx;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (dy < 0) {\n\t\t\t\t\t\t\t\tminMorphY += dy;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphY += dy;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (dz < 0) {\n\t\t\t\t\t\t\t\tminMorphZ += dz;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphZ += dz;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (bMin.x > minMorphX) bMin.x = minMorphX;\n\t\t\t\t\t\tif (bMin.y > minMorphY) bMin.y = minMorphY;\n\t\t\t\t\t\tif (bMin.z > minMorphZ) bMin.z = minMorphZ;\n\t\t\t\t\t\tif (bMax.x < maxMorphX) bMax.x = maxMorphX;\n\t\t\t\t\t\tif (bMax.y < maxMorphY) bMax.y = maxMorphY;\n\t\t\t\t\t\tif (bMax.z < maxMorphZ) bMax.z = maxMorphZ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titerator.next();\n\t\t}\n\n\t\tconst positionElement = this.vertexBuffer.getFormat().elements.find(e => e.name === SEMANTIC_POSITION);\n\n\t\tif (positionElement && positionElement.normalize) {\n\t\t\tconst func = (() => {\n\t\t\t\tswitch (positionElement.dataType) {\n\t\t\t\t\tcase TYPE_INT8:\n\t\t\t\t\t\treturn x => Math.max(x / 127.0, -1.0);\n\n\t\t\t\t\tcase TYPE_UINT8:\n\t\t\t\t\t\treturn x => x / 255.0;\n\n\t\t\t\t\tcase TYPE_INT16:\n\t\t\t\t\t\treturn x => Math.max(x / 32767.0, -1.0);\n\n\t\t\t\t\tcase TYPE_UINT16:\n\t\t\t\t\t\treturn x => x / 65535.0;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn x => x;\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\t\tif (boneUsed[i]) {\n\t\t\t\t\tconst min = boneMin[i];\n\t\t\t\t\tconst max = boneMax[i];\n\t\t\t\t\tmin.set(func(min.x), func(min.y), func(min.z));\n\t\t\t\t\tmax.set(func(max.x), func(max.y), func(max.z));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tconst aabb = new BoundingBox();\n\t\t\taabb.setMinMax(boneMin[i], boneMax[i]);\n\t\t\tthis.boneAabb.push(aabb);\n\t\t}\n\t}\n\n\t_initGeometryData() {\n\t\tif (!this._geometryData) {\n\t\t\tthis._geometryData = new GeometryData();\n\n\t\t\tif (this.vertexBuffer) {\n\t\t\t\tthis._geometryData.vertexCount = this.vertexBuffer.numVertices;\n\t\t\t\tthis._geometryData.maxVertices = this.vertexBuffer.numVertices;\n\t\t\t}\n\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tthis._geometryData.indexCount = this.indexBuffer[0].numIndices;\n\t\t\t\tthis._geometryData.maxIndices = this.indexBuffer[0].numIndices;\n\t\t\t}\n\t\t}\n\t}\n\n\tclear(verticesDynamic, indicesDynamic, maxVertices = 0, maxIndices = 0) {\n\t\tthis._initGeometryData();\n\n\t\tthis._geometryData.initDefaults();\n\n\t\tthis._geometryData.recreate = true;\n\t\tthis._geometryData.maxVertices = maxVertices;\n\t\tthis._geometryData.maxIndices = maxIndices;\n\t\tthis._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;\n\t\tthis._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;\n\t}\n\n\tsetVertexStream(semantic, data, componentCount, numVertices, dataType = TYPE_FLOAT32, dataTypeNormalize = false) {\n\t\tthis._initGeometryData();\n\n\t\tconst vertexCount = numVertices || data.length / componentCount;\n\n\t\tthis._geometryData._changeVertexCount(vertexCount, semantic);\n\n\t\tthis._geometryData.vertexStreamsUpdated = true;\n\t\tthis._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize);\n\t}\n\n\tgetVertexStream(semantic, data) {\n\t\tlet count = 0;\n\t\tlet done = false;\n\n\t\tif (this._geometryData) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\n\t\t\tif (stream) {\n\t\t\t\tdone = true;\n\t\t\t\tcount = this._geometryData.vertexCount;\n\n\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\tdata.set(stream.data);\n\t\t\t\t} else {\n\t\t\t\t\tdata.length = 0;\n\t\t\t\t\tdata.push(stream.data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!done) {\n\t\t\tif (this.vertexBuffer) {\n\t\t\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\t\t\tcount = iterator.readData(semantic, data);\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tsetPositions(positions, componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\n\tsetNormals(normals, componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\n\tsetUvs(channel, uvs, componentCount = GeometryData.DEFAULT_COMPONENTS_UV, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\n\tsetColors(colors, componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\n\tsetColors32(colors, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);\n\t}\n\n\tsetIndices(indices, numIndices) {\n\t\tthis._initGeometryData();\n\n\t\tthis._geometryData.indexStreamUpdated = true;\n\t\tthis._geometryData.indices = indices;\n\t\tthis._geometryData.indexCount = numIndices || indices.length;\n\t}\n\n\tgetPositions(positions) {\n\t\treturn this.getVertexStream(SEMANTIC_POSITION, positions);\n\t}\n\n\tgetNormals(normals) {\n\t\treturn this.getVertexStream(SEMANTIC_NORMAL, normals);\n\t}\n\n\tgetUvs(channel, uvs) {\n\t\treturn this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);\n\t}\n\n\tgetColors(colors) {\n\t\treturn this.getVertexStream(SEMANTIC_COLOR, colors);\n\t}\n\n\tgetIndices(indices) {\n\t\tlet count = 0;\n\n\t\tif (this._geometryData && this._geometryData.indices) {\n\t\t\tconst streamIndices = this._geometryData.indices;\n\t\t\tcount = this._geometryData.indexCount;\n\n\t\t\tif (ArrayBuffer.isView(indices)) {\n\t\t\t\tindices.set(streamIndices);\n\t\t\t} else {\n\t\t\t\tindices.length = 0;\n\t\t\t\tindices.push(streamIndices);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tconst indexBuffer = this.indexBuffer[0];\n\t\t\t\tcount = indexBuffer.readData(indices);\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tupdate(primitiveType = PRIMITIVE_TRIANGLES, updateBoundingBox = true) {\n\t\tif (this._geometryData) {\n\t\t\tif (updateBoundingBox) {\n\t\t\t\tconst stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];\n\n\t\t\t\tif (stream) {\n\t\t\t\t\tif (stream.componentCount === 3) {\n\t\t\t\t\t\tthis._aabb.compute(stream.data, this._geometryData.vertexCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet destroyVB = this._geometryData.recreate;\n\n\t\t\tif (this._geometryData.vertexCount > this._geometryData.maxVertices) {\n\t\t\t\tdestroyVB = true;\n\t\t\t\tthis._geometryData.maxVertices = this._geometryData.vertexCount;\n\t\t\t}\n\n\t\t\tif (destroyVB) {\n\t\t\t\tif (this.vertexBuffer) {\n\t\t\t\t\tthis.vertexBuffer.destroy();\n\t\t\t\t\tthis.vertexBuffer = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet destroyIB = this._geometryData.recreate;\n\n\t\t\tif (this._geometryData.indexCount > this._geometryData.maxIndices) {\n\t\t\t\tdestroyIB = true;\n\t\t\t\tthis._geometryData.maxIndices = this._geometryData.indexCount;\n\t\t\t}\n\n\t\t\tif (destroyIB) {\n\t\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\t\tthis.indexBuffer[0].destroy();\n\t\t\t\t\tthis.indexBuffer[0] = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._geometryData.vertexStreamsUpdated) {\n\t\t\t\tthis._updateVertexBuffer();\n\t\t\t}\n\n\t\t\tif (this._geometryData.indexStreamUpdated) {\n\t\t\t\tthis._updateIndexBuffer();\n\t\t\t}\n\n\t\t\tthis.primitive[0].type = primitiveType;\n\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tif (this._geometryData.indexStreamUpdated) {\n\t\t\t\t\tthis.primitive[0].count = this._geometryData.indexCount;\n\t\t\t\t\tthis.primitive[0].indexed = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._geometryData.vertexStreamsUpdated) {\n\t\t\t\t\tthis.primitive[0].count = this._geometryData.vertexCount;\n\t\t\t\t\tthis.primitive[0].indexed = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._geometryData.vertexCount = 0;\n\t\t\tthis._geometryData.indexCount = 0;\n\t\t\tthis._geometryData.vertexStreamsUpdated = false;\n\t\t\tthis._geometryData.indexStreamUpdated = false;\n\t\t\tthis._geometryData.recreate = false;\n\t\t\tthis.updateRenderStates();\n\t\t}\n\t}\n\n\t_buildVertexFormat(vertexCount) {\n\t\tconst vertexDesc = [];\n\n\t\tfor (const semantic in this._geometryData.vertexStreamDictionary) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\t\t\tvertexDesc.push({\n\t\t\t\tsemantic: semantic,\n\t\t\t\tcomponents: stream.componentCount,\n\t\t\t\ttype: stream.dataType,\n\t\t\t\tnormalize: stream.dataTypeNormalize\n\t\t\t});\n\t\t}\n\n\t\treturn new VertexFormat(this.device, vertexDesc, vertexCount);\n\t}\n\n\t_updateVertexBuffer() {\n\t\tif (!this.vertexBuffer) {\n\t\t\tconst allocateVertexCount = this._geometryData.maxVertices;\n\n\t\t\tconst format = this._buildVertexFormat(allocateVertexCount);\n\n\t\t\tthis.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);\n\t\t}\n\n\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\tconst numVertices = this._geometryData.vertexCount;\n\n\t\tfor (const semantic in this._geometryData.vertexStreamDictionary) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\t\t\titerator.writeData(semantic, stream.data, numVertices);\n\t\t\tdelete this._geometryData.vertexStreamDictionary[semantic];\n\t\t}\n\n\t\titerator.end();\n\t}\n\n\t_updateIndexBuffer() {\n\t\tif (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {\n\t\t\tconst createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;\n\t\t\tthis.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);\n\t\t}\n\n\t\tconst srcIndices = this._geometryData.indices;\n\n\t\tif (srcIndices) {\n\t\t\tconst indexBuffer = this.indexBuffer[0];\n\t\t\tindexBuffer.writeData(srcIndices, this._geometryData.indexCount);\n\t\t\tthis._geometryData.indices = null;\n\t\t}\n\t}\n\n\tprepareRenderState(renderStyle) {\n\t\tif (renderStyle === RENDERSTYLE_WIREFRAME) {\n\t\t\tthis.generateWireframe();\n\t\t} else if (renderStyle === RENDERSTYLE_POINTS) {\n\t\t\tthis.primitive[RENDERSTYLE_POINTS] = {\n\t\t\t\ttype: PRIMITIVE_POINTS,\n\t\t\t\tbase: 0,\n\t\t\t\tcount: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,\n\t\t\t\tindexed: false\n\t\t\t};\n\t\t}\n\t}\n\n\tupdateRenderStates() {\n\t\tif (this.primitive[RENDERSTYLE_POINTS]) {\n\t\t\tthis.prepareRenderState(RENDERSTYLE_POINTS);\n\t\t}\n\n\t\tif (this.primitive[RENDERSTYLE_WIREFRAME]) {\n\t\t\tthis.prepareRenderState(RENDERSTYLE_WIREFRAME);\n\t\t}\n\t}\n\n\tgenerateWireframe() {\n\t\tthis._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);\n\n\t\tconst lines = [];\n\t\tlet format;\n\n\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\tconst offsets = [[0, 1], [1, 2], [2, 0]];\n\t\t\tconst base = this.primitive[RENDERSTYLE_SOLID].base;\n\t\t\tconst count = this.primitive[RENDERSTYLE_SOLID].count;\n\t\t\tconst indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];\n\t\t\tconst srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);\n\t\t\tconst uniqueLineIndices = {};\n\n\t\t\tfor (let j = base; j < base + count; j += 3) {\n\t\t\t\tfor (let k = 0; k < 3; k++) {\n\t\t\t\t\tconst i1 = srcIndices[j + offsets[k][0]];\n\t\t\t\t\tconst i2 = srcIndices[j + offsets[k][1]];\n\t\t\t\t\tconst line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;\n\n\t\t\t\t\tif (uniqueLineIndices[line] === undefined) {\n\t\t\t\t\t\tuniqueLineIndices[line] = 0;\n\t\t\t\t\t\tlines.push(i1, i2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tformat = indexBuffer.format;\n\t\t} else {\n\t\t\tfor (let i = 0; i < this.vertexBuffer.numVertices; i += 3) {\n\t\t\t\tlines.push(i, i + 1, i + 1, i + 2, i + 2, i);\n\t\t\t}\n\n\t\t\tformat = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;\n\t\t}\n\n\t\tconst wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);\n\t\tconst dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);\n\t\tdstIndices.set(lines);\n\t\twireBuffer.unlock();\n\t\tthis.primitive[RENDERSTYLE_WIREFRAME] = {\n\t\t\ttype: PRIMITIVE_LINES,\n\t\t\tbase: 0,\n\t\t\tcount: lines.length,\n\t\t\tindexed: true\n\t\t};\n\t\tthis.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;\n\t}\n\n}\n\nconst primitiveUv1Padding = 4.0 / 64;\nconst primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nconst shapePrimitives = [];\n\nfunction calculateNormals(positions, indices) {\n\tconst triangleCount = indices.length / 3;\n\tconst vertexCount = positions.length / 3;\n\tconst p1 = new Vec3();\n\tconst p2 = new Vec3();\n\tconst p3 = new Vec3();\n\tconst p1p2 = new Vec3();\n\tconst p1p3 = new Vec3();\n\tconst faceNormal = new Vec3();\n\tconst normals = [];\n\n\tfor (let i = 0; i < positions.length; i++) {\n\t\tnormals[i] = 0;\n\t}\n\n\tfor (let i = 0; i < triangleCount; i++) {\n\t\tconst i1 = indices[i * 3];\n\t\tconst i2 = indices[i * 3 + 1];\n\t\tconst i3 = indices[i * 3 + 2];\n\t\tp1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n\t\tp2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n\t\tp3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n\t\tp1p2.sub2(p2, p1);\n\t\tp1p3.sub2(p3, p1);\n\t\tfaceNormal.cross(p1p2, p1p3).normalize();\n\t\tnormals[i1 * 3] += faceNormal.x;\n\t\tnormals[i1 * 3 + 1] += faceNormal.y;\n\t\tnormals[i1 * 3 + 2] += faceNormal.z;\n\t\tnormals[i2 * 3] += faceNormal.x;\n\t\tnormals[i2 * 3 + 1] += faceNormal.y;\n\t\tnormals[i2 * 3 + 2] += faceNormal.z;\n\t\tnormals[i3 * 3] += faceNormal.x;\n\t\tnormals[i3 * 3 + 1] += faceNormal.y;\n\t\tnormals[i3 * 3 + 2] += faceNormal.z;\n\t}\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tconst nx = normals[i * 3];\n\t\tconst ny = normals[i * 3 + 1];\n\t\tconst nz = normals[i * 3 + 2];\n\t\tconst invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n\t\tnormals[i * 3] *= invLen;\n\t\tnormals[i * 3 + 1] *= invLen;\n\t\tnormals[i * 3 + 2] *= invLen;\n\t}\n\n\treturn normals;\n}\n\nfunction calculateTangents(positions, normals, uvs, indices) {\n\tconst triangleCount = indices.length / 3;\n\tconst vertexCount = positions.length / 3;\n\tconst v1 = new Vec3();\n\tconst v2 = new Vec3();\n\tconst v3 = new Vec3();\n\tconst w1 = new Vec2();\n\tconst w2 = new Vec2();\n\tconst w3 = new Vec2();\n\tconst sdir = new Vec3();\n\tconst tdir = new Vec3();\n\tconst tan1 = new Float32Array(vertexCount * 3);\n\tconst tan2 = new Float32Array(vertexCount * 3);\n\tconst tangents = [];\n\n\tfor (let i = 0; i < triangleCount; i++) {\n\t\tconst i1 = indices[i * 3];\n\t\tconst i2 = indices[i * 3 + 1];\n\t\tconst i3 = indices[i * 3 + 2];\n\t\tv1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n\t\tv2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n\t\tv3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n\t\tw1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);\n\t\tw2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);\n\t\tw3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);\n\t\tconst x1 = v2.x - v1.x;\n\t\tconst x2 = v3.x - v1.x;\n\t\tconst y1 = v2.y - v1.y;\n\t\tconst y2 = v3.y - v1.y;\n\t\tconst z1 = v2.z - v1.z;\n\t\tconst z2 = v3.z - v1.z;\n\t\tconst s1 = w2.x - w1.x;\n\t\tconst s2 = w3.x - w1.x;\n\n\t\tconst _t = w2.y - w1.y;\n\n\t\tconst _t2 = w3.y - w1.y;\n\n\t\tconst area = s1 * _t2 - s2 * _t;\n\n\t\tif (area === 0) {\n\t\t\tsdir.set(0, 1, 0);\n\t\t\ttdir.set(1, 0, 0);\n\t\t} else {\n\t\t\tconst r = 1 / area;\n\t\t\tsdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);\n\t\t\ttdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n\t\t}\n\n\t\ttan1[i1 * 3 + 0] += sdir.x;\n\t\ttan1[i1 * 3 + 1] += sdir.y;\n\t\ttan1[i1 * 3 + 2] += sdir.z;\n\t\ttan1[i2 * 3 + 0] += sdir.x;\n\t\ttan1[i2 * 3 + 1] += sdir.y;\n\t\ttan1[i2 * 3 + 2] += sdir.z;\n\t\ttan1[i3 * 3 + 0] += sdir.x;\n\t\ttan1[i3 * 3 + 1] += sdir.y;\n\t\ttan1[i3 * 3 + 2] += sdir.z;\n\t\ttan2[i1 * 3 + 0] += tdir.x;\n\t\ttan2[i1 * 3 + 1] += tdir.y;\n\t\ttan2[i1 * 3 + 2] += tdir.z;\n\t\ttan2[i2 * 3 + 0] += tdir.x;\n\t\ttan2[i2 * 3 + 1] += tdir.y;\n\t\ttan2[i2 * 3 + 2] += tdir.z;\n\t\ttan2[i3 * 3 + 0] += tdir.x;\n\t\ttan2[i3 * 3 + 1] += tdir.y;\n\t\ttan2[i3 * 3 + 2] += tdir.z;\n\t}\n\n\tconst t1 = new Vec3();\n\tconst t2 = new Vec3();\n\tconst n = new Vec3();\n\tconst temp = new Vec3();\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tn.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);\n\t\tt1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);\n\t\tt2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);\n\t\tconst ndott = n.dot(t1);\n\t\ttemp.copy(n).mulScalar(ndott);\n\t\ttemp.sub2(t1, temp).normalize();\n\t\ttangents[i * 4] = temp.x;\n\t\ttangents[i * 4 + 1] = temp.y;\n\t\ttangents[i * 4 + 2] = temp.z;\n\t\ttemp.cross(n, t1);\n\t\ttangents[i * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;\n\t}\n\n\treturn tangents;\n}\n\nfunction createMesh$1(device, positions, opts) {\n\tconst mesh = new Mesh(device);\n\tmesh.setPositions(positions);\n\n\tif (opts) {\n\t\tif (opts.normals) {\n\t\t\tmesh.setNormals(opts.normals);\n\t\t}\n\n\t\tif (opts.tangents) {\n\t\t\tmesh.setVertexStream(SEMANTIC_TANGENT, opts.tangents, 4);\n\t\t}\n\n\t\tif (opts.colors) {\n\t\t\tmesh.setColors32(opts.colors);\n\t\t}\n\n\t\tif (opts.uvs) {\n\t\t\tmesh.setUvs(0, opts.uvs);\n\t\t}\n\n\t\tif (opts.uvs1) {\n\t\t\tmesh.setUvs(1, opts.uvs1);\n\t\t}\n\n\t\tif (opts.blendIndices) {\n\t\t\tmesh.setVertexStream(SEMANTIC_BLENDINDICES, opts.blendIndices, 4, opts.blendIndices.length / 4, TYPE_UINT8);\n\t\t}\n\n\t\tif (opts.blendWeights) {\n\t\t\tmesh.setVertexStream(SEMANTIC_BLENDWEIGHT, opts.blendWeights, 4);\n\t\t}\n\n\t\tif (opts.indices) {\n\t\t\tmesh.setIndices(opts.indices);\n\t\t}\n\t}\n\n\tmesh.update();\n\treturn mesh;\n}\n\nfunction createTorus(device, opts) {\n\tconst rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;\n\tconst rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;\n\tconst segments = opts && opts.segments !== undefined ? opts.segments : 30;\n\tconst sides = opts && opts.sides !== undefined ? opts.sides : 20;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst indices = [];\n\n\tfor (let i = 0; i <= sides; i++) {\n\t\tfor (let j = 0; j <= segments; j++) {\n\t\t\tconst x = Math.cos(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));\n\t\t\tconst y = Math.sin(2 * Math.PI * i / sides) * rc;\n\t\t\tconst z = Math.sin(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));\n\t\t\tconst nx = Math.cos(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);\n\t\t\tconst ny = Math.sin(2 * Math.PI * i / sides);\n\t\t\tconst nz = Math.sin(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);\n\t\t\tconst u = i / sides;\n\t\t\tconst v = 1 - j / segments;\n\t\t\tpositions.push(x, y, z);\n\t\t\tnormals.push(nx, ny, nz);\n\t\t\tuvs.push(u, 1.0 - v);\n\n\t\t\tif (i < sides && j < segments) {\n\t\t\t\tconst first = i * (segments + 1) + j;\n\t\t\t\tconst second = (i + 1) * (segments + 1) + j;\n\t\t\t\tconst third = i * (segments + 1) + (j + 1);\n\t\t\t\tconst fourth = (i + 1) * (segments + 1) + (j + 1);\n\t\t\t\tindices.push(first, second, third);\n\t\t\t\tindices.push(second, fourth, third);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst options = {\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tindices: indices\n\t};\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(positions, normals, uvs, indices);\n\t}\n\n\treturn createMesh$1(device, positions, options);\n}\n\nfunction _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {\n\tconst pos = new Vec3();\n\tconst bottomToTop = new Vec3();\n\tconst norm = new Vec3();\n\tconst top = new Vec3();\n\tconst bottom = new Vec3();\n\tconst tangent = new Vec3();\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst uvs1 = [];\n\tconst indices = [];\n\tlet offset;\n\n\tif (height > 0) {\n\t\tfor (let i = 0; i <= heightSegments; i++) {\n\t\t\tfor (let j = 0; j <= capSegments; j++) {\n\t\t\t\tconst theta = j / capSegments * 2 * Math.PI - Math.PI;\n\t\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\t\tbottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);\n\t\t\t\ttop.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);\n\t\t\t\tpos.lerp(bottom, top, i / heightSegments);\n\t\t\t\tbottomToTop.sub2(top, bottom).normalize();\n\t\t\t\ttangent.set(cosTheta, 0, -sinTheta);\n\t\t\t\tnorm.cross(tangent, bottomToTop).normalize();\n\t\t\t\tpositions.push(pos.x, pos.y, pos.z);\n\t\t\t\tnormals.push(norm.x, norm.y, norm.z);\n\t\t\t\tlet u = j / capSegments;\n\t\t\t\tlet v = i / heightSegments;\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tconst _v = v;\n\t\t\t\tv = u;\n\t\t\t\tu = _v;\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\n\t\t\t\tif (i < heightSegments && j < capSegments) {\n\t\t\t\t\tconst first = i * (capSegments + 1) + j;\n\t\t\t\t\tconst second = i * (capSegments + 1) + (j + 1);\n\t\t\t\t\tconst third = (i + 1) * (capSegments + 1) + j;\n\t\t\t\t\tconst fourth = (i + 1) * (capSegments + 1) + (j + 1);\n\t\t\t\t\tindices.push(first, second, third);\n\t\t\t\t\tindices.push(second, fourth, third);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (roundedCaps) {\n\t\tconst latitudeBands = Math.floor(capSegments / 2);\n\t\tconst longitudeBands = capSegments;\n\t\tconst capOffset = height / 2;\n\n\t\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\t\tconst theta = lat * Math.PI * 0.5 / latitudeBands;\n\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\tconst cosTheta = Math.cos(theta);\n\n\t\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\t\tconst x = cosPhi * sinTheta;\n\t\t\t\tconst y = cosTheta;\n\t\t\t\tconst z = sinPhi * sinTheta;\n\t\t\t\tlet u = 1 - lon / longitudeBands;\n\t\t\t\tlet v = 1 - lat / latitudeBands;\n\t\t\t\tpositions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);\n\t\t\t\tnormals.push(x, y, z);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += 1.0 / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t}\n\t\t}\n\n\t\toffset = (heightSegments + 1) * (capSegments + 1);\n\n\t\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\t\tconst second = first + longitudeBands + 1;\n\t\t\t\tindices.push(offset + first + 1, offset + second, offset + first);\n\t\t\t\tindices.push(offset + first + 1, offset + second + 1, offset + second);\n\t\t\t}\n\t\t}\n\n\t\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\t\tconst theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;\n\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\tconst cosTheta = Math.cos(theta);\n\n\t\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\t\tconst x = cosPhi * sinTheta;\n\t\t\t\tconst y = cosTheta;\n\t\t\t\tconst z = sinPhi * sinTheta;\n\t\t\t\tlet u = 1 - lon / longitudeBands;\n\t\t\t\tlet v = 1 - lat / latitudeBands;\n\t\t\t\tpositions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);\n\t\t\t\tnormals.push(x, y, z);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += 2.0 / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t}\n\t\t}\n\n\t\toffset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);\n\n\t\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\t\tconst second = first + longitudeBands + 1;\n\t\t\t\tindices.push(offset + first + 1, offset + second, offset + first);\n\t\t\t\tindices.push(offset + first + 1, offset + second + 1, offset + second);\n\t\t\t}\n\t\t}\n\t} else {\n\t\toffset = (heightSegments + 1) * (capSegments + 1);\n\n\t\tif (baseRadius > 0) {\n\t\t\tfor (let i = 0; i < capSegments; i++) {\n\t\t\t\tconst theta = i / capSegments * 2 * Math.PI;\n\t\t\t\tconst x = Math.sin(theta);\n\t\t\t\tconst y = -height / 2;\n\t\t\t\tconst z = Math.cos(theta);\n\t\t\t\tlet u = 1 - (x + 1) / 2;\n\t\t\t\tlet v = (z + 1) / 2;\n\t\t\t\tpositions.push(x * baseRadius, y, z * baseRadius);\n\t\t\t\tnormals.push(0, -1, 0);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += 1 / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\n\t\t\t\tif (i > 1) {\n\t\t\t\t\tindices.push(offset, offset + i, offset + i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toffset += capSegments;\n\n\t\tif (peakRadius > 0) {\n\t\t\tfor (let i = 0; i < capSegments; i++) {\n\t\t\t\tconst theta = i / capSegments * 2 * Math.PI;\n\t\t\t\tconst x = Math.sin(theta);\n\t\t\t\tconst y = height / 2;\n\t\t\t\tconst z = Math.cos(theta);\n\t\t\t\tlet u = 1 - (x + 1) / 2;\n\t\t\t\tlet v = (z + 1) / 2;\n\t\t\t\tpositions.push(x * peakRadius, y, z * peakRadius);\n\t\t\t\tnormals.push(0, 1, 0);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += 2 / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\n\t\t\t\tif (i > 1) {\n\t\t\t\t\tindices.push(offset, offset + i - 1, offset + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tpositions: positions,\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tuvs1: uvs1,\n\t\tindices: indices\n\t};\n}\n\nfunction createCylinder(device, opts) {\n\tlet radius = opts && (opts.radius || opts.baseRadius);\n\tradius = radius !== undefined ? radius : 0.5;\n\tconst height = opts && opts.height !== undefined ? opts.height : 1.0;\n\tconst heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;\n\tconst capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\n\tconst options = _createConeData(radius, radius, height, heightSegments, capSegments, false);\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n\t}\n\n\treturn createMesh$1(device, options.positions, options);\n}\n\nfunction createCapsule(device, opts) {\n\tconst radius = opts && opts.radius !== undefined ? opts.radius : 0.3;\n\tconst height = opts && opts.height !== undefined ? opts.height : 1.0;\n\tconst heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;\n\tconst sides = opts && opts.sides !== undefined ? opts.sides : 20;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\n\tconst options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n\t}\n\n\treturn createMesh$1(device, options.positions, options);\n}\n\nfunction createCone(device, opts) {\n\tconst baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;\n\tconst peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;\n\tconst height = opts && opts.height !== undefined ? opts.height : 1.0;\n\tconst heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;\n\tconst capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\n\tconst options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n\t}\n\n\treturn createMesh$1(device, options.positions, options);\n}\n\nfunction createSphere(device, opts) {\n\tconst radius = opts && opts.radius !== undefined ? opts.radius : 0.5;\n\tconst latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;\n\tconst longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst indices = [];\n\n\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\tconst theta = lat * Math.PI / latitudeBands;\n\t\tconst sinTheta = Math.sin(theta);\n\t\tconst cosTheta = Math.cos(theta);\n\n\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\tconst x = cosPhi * sinTheta;\n\t\t\tconst y = cosTheta;\n\t\t\tconst z = sinPhi * sinTheta;\n\t\t\tconst u = 1 - lon / longitudeBands;\n\t\t\tconst v = 1 - lat / latitudeBands;\n\t\t\tpositions.push(x * radius, y * radius, z * radius);\n\t\t\tnormals.push(x, y, z);\n\t\t\tuvs.push(u, 1 - v);\n\t\t}\n\t}\n\n\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\tconst second = first + longitudeBands + 1;\n\t\t\tindices.push(first + 1, second, first);\n\t\t\tindices.push(first + 1, second + 1, second);\n\t\t}\n\t}\n\n\tconst options = {\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tuvs1: uvs,\n\t\tindices: indices\n\t};\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(positions, normals, uvs, indices);\n\t}\n\n\treturn createMesh$1(device, positions, options);\n}\n\nfunction createPlane(device, opts) {\n\tconst he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec2(0.5, 0.5);\n\tconst ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;\n\tconst ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst indices = [];\n\tlet vcounter = 0;\n\n\tfor (let i = 0; i <= ws; i++) {\n\t\tfor (let j = 0; j <= ls; j++) {\n\t\t\tconst x = -he.x + 2 * he.x * i / ws;\n\t\t\tconst y = 0.0;\n\t\t\tconst z = -(-he.y + 2 * he.y * j / ls);\n\t\t\tconst u = i / ws;\n\t\t\tconst v = j / ls;\n\t\t\tpositions.push(x, y, z);\n\t\t\tnormals.push(0, 1, 0);\n\t\t\tuvs.push(u, 1 - v);\n\n\t\t\tif (i < ws && j < ls) {\n\t\t\t\tindices.push(vcounter + ls + 1, vcounter + 1, vcounter);\n\t\t\t\tindices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);\n\t\t\t}\n\n\t\t\tvcounter++;\n\t\t}\n\t}\n\n\tconst options = {\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tuvs1: uvs,\n\t\tindices: indices\n\t};\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(positions, normals, uvs, indices);\n\t}\n\n\treturn createMesh$1(device, positions, options);\n}\n\nfunction createBox(device, opts) {\n\tconst he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);\n\tconst ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;\n\tconst ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;\n\tconst hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\tconst corners = [new Vec3(-he.x, -he.y, he.z), new Vec3(he.x, -he.y, he.z), new Vec3(he.x, he.y, he.z), new Vec3(-he.x, he.y, he.z), new Vec3(he.x, -he.y, -he.z), new Vec3(-he.x, -he.y, -he.z), new Vec3(-he.x, he.y, -he.z), new Vec3(he.x, he.y, -he.z)];\n\tconst faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];\n\tconst faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];\n\tconst sides = {\n\t\tFRONT: 0,\n\t\tBACK: 1,\n\t\tTOP: 2,\n\t\tBOTTOM: 3,\n\t\tRIGHT: 4,\n\t\tLEFT: 5\n\t};\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst uvs1 = [];\n\tconst indices = [];\n\tlet vcounter = 0;\n\n\tconst generateFace = (side, uSegments, vSegments) => {\n\t\tconst temp1 = new Vec3();\n\t\tconst temp2 = new Vec3();\n\t\tconst temp3 = new Vec3();\n\t\tconst r = new Vec3();\n\n\t\tfor (let i = 0; i <= uSegments; i++) {\n\t\t\tfor (let j = 0; j <= vSegments; j++) {\n\t\t\t\ttemp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);\n\t\t\t\ttemp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);\n\t\t\t\ttemp3.sub2(temp2, corners[faceAxes[side][0]]);\n\t\t\t\tr.add2(temp1, temp3);\n\t\t\t\tlet u = i / uSegments;\n\t\t\t\tlet v = j / vSegments;\n\t\t\t\tpositions.push(r.x, r.y, r.z);\n\t\t\t\tnormals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += side % 3 / 3;\n\t\t\t\tv += Math.floor(side / 3) / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\n\t\t\t\tif (i < uSegments && j < vSegments) {\n\t\t\t\t\tindices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n\t\t\t\t\tindices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);\n\t\t\t\t}\n\n\t\t\t\tvcounter++;\n\t\t\t}\n\t\t}\n\t};\n\n\tgenerateFace(sides.FRONT, ws, hs);\n\tgenerateFace(sides.BACK, ws, hs);\n\tgenerateFace(sides.TOP, ws, ls);\n\tgenerateFace(sides.BOTTOM, ws, ls);\n\tgenerateFace(sides.RIGHT, ls, hs);\n\tgenerateFace(sides.LEFT, ls, hs);\n\tconst options = {\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tuvs1: uvs1,\n\t\tindices: indices\n\t};\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(positions, normals, uvs, indices);\n\t}\n\n\treturn createMesh$1(device, positions, options);\n}\n\nfunction getShapePrimitive(device, type) {\n\tlet primData = null;\n\n\tfor (let i = 0; i < shapePrimitives.length; i++) {\n\t\tif (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {\n\t\t\tprimData = shapePrimitives[i].primData;\n\t\t}\n\t}\n\n\tif (!primData) {\n\t\tlet mesh, area;\n\n\t\tswitch (type) {\n\t\t\tcase 'box':\n\t\t\t\tmesh = createBox(device, {\n\t\t\t\t\thalfExtents: new Vec3(0.5, 0.5, 0.5)\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: 2,\n\t\t\t\t\ty: 2,\n\t\t\t\t\tz: 2,\n\t\t\t\t\tuv: 2.0 / 3\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'capsule':\n\t\t\t\tmesh = createCapsule(device, {\n\t\t\t\t\tradius: 0.5,\n\t\t\t\t\theight: 2\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI * 2,\n\t\t\t\t\ty: Math.PI,\n\t\t\t\t\tz: Math.PI * 2,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3 * 2\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'cone':\n\t\t\t\tmesh = createCone(device, {\n\t\t\t\t\tbaseRadius: 0.5,\n\t\t\t\t\tpeakRadius: 0,\n\t\t\t\t\theight: 1\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: 2.54,\n\t\t\t\t\ty: 2.54,\n\t\t\t\t\tz: 2.54,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'cylinder':\n\t\t\t\tmesh = createCylinder(device, {\n\t\t\t\t\tradius: 0.5,\n\t\t\t\t\theight: 1\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI,\n\t\t\t\t\ty: 0.79 * 2,\n\t\t\t\t\tz: Math.PI,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3 * 2\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'plane':\n\t\t\t\tmesh = createPlane(device, {\n\t\t\t\t\thalfExtents: new Vec2(0.5, 0.5),\n\t\t\t\t\twidthSegments: 1,\n\t\t\t\t\tlengthSegments: 1\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 1,\n\t\t\t\t\tz: 0,\n\t\t\t\t\tuv: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'sphere':\n\t\t\t\tmesh = createSphere(device, {\n\t\t\t\t\tradius: 0.5\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI,\n\t\t\t\t\ty: Math.PI,\n\t\t\t\t\tz: Math.PI,\n\t\t\t\t\tuv: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Invalid primitive type: \" + type);\n\t\t}\n\n\t\tmesh.incRefCount();\n\t\tprimData = {\n\t\t\tmesh: mesh,\n\t\t\tarea: area\n\t\t};\n\t\tshapePrimitives.push({\n\t\t\ttype: type,\n\t\t\tdevice: device,\n\t\t\tprimData: primData\n\t\t});\n\t}\n\n\treturn primData;\n}\n\nclass BasicMaterial extends Material {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.color = new Color(1, 1, 1, 1);\n\t\tthis.colorUniform = new Float32Array(4);\n\t\tthis.colorMap = null;\n\t\tthis.vertexColors = false;\n\t}\n\n\tcopy(source) {\n\t\tsuper.copy(source);\n\t\tthis.color.copy(source.color);\n\t\tthis.colorMap = source.colorMap;\n\t\tthis.vertexColors = source.vertexColors;\n\t\treturn this;\n\t}\n\n\tupdateUniforms(device, scene) {\n\t\tthis.clearParameters();\n\t\tthis.colorUniform[0] = this.color.r;\n\t\tthis.colorUniform[1] = this.color.g;\n\t\tthis.colorUniform[2] = this.color.b;\n\t\tthis.colorUniform[3] = this.color.a;\n\t\tthis.setParameter('uColor', this.colorUniform);\n\n\t\tif (this.colorMap) {\n\t\t\tthis.setParameter('texture_diffuseMap', this.colorMap);\n\t\t}\n\t}\n\n\tupdateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {\n\t\tconst options = {\n\t\t\tskin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,\n\t\t\tscreenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,\n\t\t\tuseInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,\n\t\t\tuseMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,\n\t\t\tuseMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,\n\t\t\tuseMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,\n\t\t\tvertexColors: this.vertexColors,\n\t\t\tdiffuseMap: !!this.colorMap,\n\t\t\tpass: pass\n\t\t};\n\t\tconst library = device.getProgramLibrary();\n\t\tthis.shader = library.getProgram('basic', options);\n\t}\n\n}\n\nclass Batch {\n\tconstructor(meshInstances, dynamic, batchGroupId) {\n\t\tthis.origMeshInstances = meshInstances;\n\t\tthis._aabb = new BoundingBox();\n\t\tthis.meshInstance = null;\n\t\tthis.dynamic = dynamic;\n\t\tthis.batchGroupId = batchGroupId;\n\t}\n\n\tdestroy(scene, layers) {\n\t\tif (this.meshInstance) {\n\t\t\tthis.removeFromLayers(scene, layers);\n\t\t\tthis.meshInstance.destroy();\n\t\t}\n\t}\n\n\taddToLayers(scene, layers) {\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances([this.meshInstance]);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveFromLayers(scene, layers) {\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeMeshInstances([this.meshInstance]);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateBoundingBox() {\n\t\tthis._aabb.copy(this.origMeshInstances[0].aabb);\n\n\t\tfor (let i = 1; i < this.origMeshInstances.length; i++) {\n\t\t\tthis._aabb.add(this.origMeshInstances[i].aabb);\n\t\t}\n\n\t\tthis.meshInstance.aabb = this._aabb;\n\t\tthis.meshInstance._aabbVer = 0;\n\t}\n\n}\n\nclass BatchGroup {\n\tconstructor(id, name, dynamic, maxAabbSize, layers = [LAYERID_WORLD]) {\n\t\tthis.dynamic = dynamic;\n\t\tthis.maxAabbSize = maxAabbSize;\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.layers = layers;\n\t\tthis._ui = false;\n\t\tthis._sprite = false;\n\t\tthis._obj = {\n\t\t\tmodel: [],\n\t\t\telement: [],\n\t\t\tsprite: [],\n\t\t\trender: []\n\t\t};\n\t}\n\n}\n\nBatchGroup.MODEL = 'model';\nBatchGroup.ELEMENT = 'element';\nBatchGroup.SPRITE = 'sprite';\nBatchGroup.RENDER = 'render';\n\nconst _invMatrix = new Mat4();\n\nclass SkinInstance {\n\tconstructor(skin) {\n\t\tthis.bones = void 0;\n\t\tthis._dirty = true;\n\t\tthis._rootBone = null;\n\t\tthis._skinUpdateIndex = -1;\n\t\tthis._updateBeforeCull = true;\n\n\t\tif (skin) {\n\t\t\tthis.initSkin(skin);\n\t\t}\n\t}\n\n\tset rootBone(rootBone) {\n\t\tthis._rootBone = rootBone;\n\t}\n\n\tget rootBone() {\n\t\treturn this._rootBone;\n\t}\n\n\tinit(device, numBones) {\n\t\tif (device.supportsBoneTextures) {\n\t\t\tconst numPixels = numBones * 3;\n\t\t\tlet width = Math.ceil(Math.sqrt(numPixels));\n\t\t\twidth = math.roundUp(width, 3);\n\t\t\tconst height = Math.ceil(numPixels / width);\n\t\t\tthis.boneTexture = new Texture(device, {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tformat: PIXELFORMAT_RGBA32F,\n\t\t\t\tmipmaps: false,\n\t\t\t\tminFilter: FILTER_NEAREST,\n\t\t\t\tmagFilter: FILTER_NEAREST\n\t\t\t});\n\t\t\tthis.boneTexture.name = 'skin';\n\t\t\tthis.matrixPalette = this.boneTexture.lock();\n\t\t} else {\n\t\t\tthis.matrixPalette = new Float32Array(numBones * 12);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this.boneTexture) {\n\t\t\tthis.boneTexture.destroy();\n\t\t\tthis.boneTexture = null;\n\t\t}\n\t}\n\n\tresolve(rootBone, entity) {\n\t\tthis.rootBone = rootBone;\n\t\tconst skin = this.skin;\n\t\tconst bones = [];\n\n\t\tfor (let j = 0; j < skin.boneNames.length; j++) {\n\t\t\tconst boneName = skin.boneNames[j];\n\t\t\tlet bone = rootBone.findByName(boneName);\n\n\t\t\tif (!bone) {\n\t\t\t\tbone = entity;\n\t\t\t}\n\n\t\t\tbones.push(bone);\n\t\t}\n\n\t\tthis.bones = bones;\n\t}\n\n\tinitSkin(skin) {\n\t\tthis.skin = skin;\n\t\tthis.bones = [];\n\t\tconst numBones = skin.inverseBindPose.length;\n\t\tthis.init(skin.device, numBones);\n\t\tthis.matrices = [];\n\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tthis.matrices[i] = new Mat4();\n\t\t}\n\t}\n\n\tuploadBones(device) {\n\t\tif (device.supportsBoneTextures) {\n\t\t\tthis.boneTexture.lock();\n\t\t\tthis.boneTexture.unlock();\n\t\t}\n\t}\n\n\t_updateMatrices(rootNode, skinUpdateIndex) {\n\t\tif (this._skinUpdateIndex !== skinUpdateIndex) {\n\t\t\tthis._skinUpdateIndex = skinUpdateIndex;\n\n\t\t\t_invMatrix.copy(rootNode.getWorldTransform()).invert();\n\n\t\t\tfor (let i = this.bones.length - 1; i >= 0; i--) {\n\t\t\t\tthis.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());\n\t\t\t\tthis.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateMatrices(rootNode, skinUpdateIndex) {\n\t\tif (this._updateBeforeCull) {\n\t\t\tthis._updateMatrices(rootNode, skinUpdateIndex);\n\t\t}\n\t}\n\n\tupdateMatrixPalette(rootNode, skinUpdateIndex) {\n\t\tthis._updateMatrices(rootNode, skinUpdateIndex);\n\n\t\tconst mp = this.matrixPalette;\n\t\tconst count = this.bones.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pe = this.matrices[i].data;\n\t\t\tconst base = i * 12;\n\t\t\tmp[base] = pe[0];\n\t\t\tmp[base + 1] = pe[4];\n\t\t\tmp[base + 2] = pe[8];\n\t\t\tmp[base + 3] = pe[12];\n\t\t\tmp[base + 4] = pe[1];\n\t\t\tmp[base + 5] = pe[5];\n\t\t\tmp[base + 6] = pe[9];\n\t\t\tmp[base + 7] = pe[13];\n\t\t\tmp[base + 8] = pe[2];\n\t\t\tmp[base + 9] = pe[6];\n\t\t\tmp[base + 10] = pe[10];\n\t\t\tmp[base + 11] = pe[14];\n\t\t}\n\n\t\tthis.uploadBones(this.skin.device);\n\t}\n\n}\n\nclass SkinBatchInstance extends SkinInstance {\n\tconstructor(device, nodes, rootNode) {\n\t\tsuper();\n\t\tconst numBones = nodes.length;\n\t\tthis.init(device, numBones);\n\t\tthis.device = device;\n\t\tthis.rootNode = rootNode;\n\t\tthis.bones = nodes;\n\t}\n\n\tupdateMatrices(rootNode, skinUpdateIndex) {}\n\n\tupdateMatrixPalette(rootNode, skinUpdateIndex) {\n\t\tconst mp = this.matrixPalette;\n\t\tconst count = this.bones.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pe = this.bones[i].getWorldTransform().data;\n\t\t\tconst base = i * 12;\n\t\t\tmp[base] = pe[0];\n\t\t\tmp[base + 1] = pe[4];\n\t\t\tmp[base + 2] = pe[8];\n\t\t\tmp[base + 3] = pe[12];\n\t\t\tmp[base + 4] = pe[1];\n\t\t\tmp[base + 5] = pe[5];\n\t\t\tmp[base + 6] = pe[9];\n\t\t\tmp[base + 7] = pe[13];\n\t\t\tmp[base + 8] = pe[2];\n\t\t\tmp[base + 9] = pe[6];\n\t\t\tmp[base + 10] = pe[10];\n\t\t\tmp[base + 11] = pe[14];\n\t\t}\n\n\t\tthis.uploadBones(this.device);\n\t}\n\n}\n\nclass RefCountedCache {\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\tdestroy() {\n\t\tthis.cache.forEach((refCount, object) => {\n\t\t\tobject.destroy();\n\t\t});\n\t\tthis.cache.clear();\n\t}\n\n\tincRef(object) {\n\t\tconst refCount = (this.cache.get(object) || 0) + 1;\n\t\tthis.cache.set(object, refCount);\n\t}\n\n\tdecRef(object) {\n\t\tif (object) {\n\t\t\tlet refCount = this.cache.get(object);\n\n\t\t\tif (refCount) {\n\t\t\t\trefCount--;\n\n\t\t\t\tif (refCount === 0) {\n\t\t\t\t\tthis.cache.delete(object);\n\t\t\t\t\tobject.destroy();\n\t\t\t\t} else {\n\t\t\t\t\tthis.cache.set(object, refCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass LightmapCache {\n\tstatic incRef(texture) {\n\t\tthis.cache.incRef(texture);\n\t}\n\n\tstatic decRef(texture) {\n\t\tthis.cache.decRef(texture);\n\t}\n\n\tstatic destroy() {\n\t\tthis.cache.destroy();\n\t}\n\n}\n\nLightmapCache.cache = new RefCountedCache();\n\nconst _tmpAabb = new BoundingBox();\n\nconst _tempBoneAabb = new BoundingBox();\n\nconst _tempSphere = new BoundingSphere();\n\nconst _meshSet = new Set();\n\nclass InstancingData {\n\tconstructor(numObjects) {\n\t\tthis.count = numObjects;\n\t\tthis.vertexBuffer = null;\n\t}\n\n}\n\nclass Command {\n\tconstructor(layer, blendType, command) {\n\t\tthis._key = [];\n\t\tthis._key[SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);\n\t\tthis.command = command;\n\t}\n\n\tset key(val) {\n\t\tthis._key[SORTKEY_FORWARD] = val;\n\t}\n\n\tget key() {\n\t\treturn this._key[SORTKEY_FORWARD];\n\t}\n\n}\n\nclass MeshInstance {\n\tconstructor(mesh, material, node = null) {\n\t\tif (mesh instanceof GraphNode) {\n\t\t\tconst temp = mesh;\n\t\t\tmesh = material;\n\t\t\tmaterial = node;\n\t\t\tnode = temp;\n\t\t}\n\n\t\tthis._key = [0, 0];\n\t\tthis._shader = [null, null, null];\n\t\tthis.isStatic = false;\n\t\tthis._staticLightList = null;\n\t\tthis._staticSource = null;\n\t\tthis.node = node;\n\t\tthis._mesh = mesh;\n\t\tmesh.incRefCount();\n\t\tthis.material = material;\n\t\tthis._shaderDefs = MASK_AFFECT_DYNAMIC << 16;\n\t\tthis._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;\n\t\tthis._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;\n\t\tthis._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;\n\t\tthis._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;\n\t\tthis._lightHash = 0;\n\t\tthis.visible = true;\n\t\tthis.layer = LAYER_WORLD;\n\t\tthis._renderStyle = RENDERSTYLE_SOLID;\n\t\tthis.castShadow = false;\n\t\tthis._receiveShadow = true;\n\t\tthis._screenSpace = false;\n\t\tthis._noDepthDrawGl1 = false;\n\t\tthis.cull = true;\n\t\tthis.pick = true;\n\t\tthis._updateAabb = true;\n\t\tthis._updateAabbFunc = null;\n\t\tthis._calculateSortDistance = null;\n\t\tthis.updateKey();\n\t\tthis._skinInstance = null;\n\t\tthis._morphInstance = null;\n\t\tthis.instancingData = null;\n\t\tthis._customAabb = null;\n\t\tthis.aabb = new BoundingBox();\n\t\tthis._aabbVer = -1;\n\t\tthis.drawOrder = 0;\n\t\tthis.visibleThisFrame = 0;\n\t\tthis.isVisibleFunc = null;\n\t\tthis.parameters = {};\n\t\tthis.stencilFront = null;\n\t\tthis.stencilBack = null;\n\t\tthis.flipFaces = false;\n\t}\n\n\tset renderStyle(renderStyle) {\n\t\tthis._renderStyle = renderStyle;\n\t\tthis.mesh.prepareRenderState(renderStyle);\n\t}\n\n\tget renderStyle() {\n\t\treturn this._renderStyle;\n\t}\n\n\tset mesh(mesh) {\n\t\tif (mesh === this._mesh) return;\n\n\t\tif (this._mesh) {\n\t\t\tthis._mesh.decRefCount();\n\t\t}\n\n\t\tthis._mesh = mesh;\n\n\t\tif (mesh) {\n\t\t\tmesh.incRefCount();\n\t\t}\n\t}\n\n\tget mesh() {\n\t\treturn this._mesh;\n\t}\n\n\tset aabb(aabb) {\n\t\tthis._aabb = aabb;\n\t}\n\n\tget aabb() {\n\t\tif (!this._updateAabb) {\n\t\t\treturn this._aabb;\n\t\t}\n\n\t\tif (this._updateAabbFunc) {\n\t\t\treturn this._updateAabbFunc(this._aabb);\n\t\t}\n\n\t\tlet localAabb = this._customAabb;\n\t\tlet toWorldSpace = !!localAabb;\n\n\t\tif (!localAabb) {\n\t\t\tlocalAabb = _tmpAabb;\n\n\t\t\tif (this.skinInstance) {\n\t\t\t\tif (!this.mesh.boneAabb) {\n\t\t\t\t\tconst morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;\n\n\t\t\t\t\tthis.mesh._initBoneAabbs(morphTargets);\n\t\t\t\t}\n\n\t\t\t\tconst boneUsed = this.mesh.boneUsed;\n\t\t\t\tlet first = true;\n\n\t\t\t\tfor (let i = 0; i < this.mesh.boneAabb.length; i++) {\n\t\t\t\t\tif (boneUsed[i]) {\n\t\t\t\t\t\t_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);\n\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\tlocalAabb.center.copy(_tempBoneAabb.center);\n\t\t\t\t\t\t\tlocalAabb.halfExtents.copy(_tempBoneAabb.halfExtents);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlocalAabb.add(_tempBoneAabb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttoWorldSpace = true;\n\t\t\t} else if (this.node._aabbVer !== this._aabbVer) {\n\t\t\t\tif (this.mesh) {\n\t\t\t\t\tlocalAabb.center.copy(this.mesh.aabb.center);\n\t\t\t\t\tlocalAabb.halfExtents.copy(this.mesh.aabb.halfExtents);\n\t\t\t\t} else {\n\t\t\t\t\tlocalAabb.center.set(0, 0, 0);\n\t\t\t\t\tlocalAabb.halfExtents.set(0, 0, 0);\n\t\t\t\t}\n\n\t\t\t\tif (this.mesh && this.mesh.morph) {\n\t\t\t\t\tlocalAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());\n\t\t\t\t}\n\n\t\t\t\ttoWorldSpace = true;\n\t\t\t\tthis._aabbVer = this.node._aabbVer;\n\t\t\t}\n\t\t}\n\n\t\tif (toWorldSpace) {\n\t\t\tthis._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());\n\t\t}\n\n\t\treturn this._aabb;\n\t}\n\n\tset material(material) {\n\t\tfor (let i = 0; i < this._shader.length; i++) {\n\t\t\tthis._shader[i] = null;\n\t\t}\n\n\t\tconst prevMat = this._material;\n\n\t\tif (prevMat) {\n\t\t\tprevMat.removeMeshInstanceRef(this);\n\t\t}\n\n\t\tthis._material = material;\n\n\t\tif (this._material) {\n\t\t\tthis._material.addMeshInstanceRef(this);\n\n\t\t\tthis.updateKey();\n\t\t\tconst prevBlend = prevMat && prevMat.blendType !== BLEND_NONE;\n\t\t\tconst thisBlend = this._material.blendType !== BLEND_NONE;\n\n\t\t\tif (prevBlend !== thisBlend) {\n\t\t\t\tlet scene = this._material._scene;\n\t\t\t\tif (!scene && prevMat && prevMat._scene) scene = prevMat._scene;\n\n\t\t\t\tif (scene) {\n\t\t\t\t\tscene.layers._dirtyBlend = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._material._dirtyBlend = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset layer(layer) {\n\t\tthis._layer = layer;\n\t\tthis.updateKey();\n\t}\n\n\tget layer() {\n\t\treturn this._layer;\n\t}\n\n\tset calculateSortDistance(calculateSortDistance) {\n\t\tthis._calculateSortDistance = calculateSortDistance;\n\t}\n\n\tget calculateSortDistance() {\n\t\treturn this._calculateSortDistance;\n\t}\n\n\tset receiveShadow(val) {\n\t\tthis._receiveShadow = val;\n\t\tthis._shaderDefs = val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW;\n\t\tthis._shader[SHADER_FORWARD] = null;\n\t\tthis._shader[SHADER_FORWARDHDR] = null;\n\t}\n\n\tget receiveShadow() {\n\t\treturn this._receiveShadow;\n\t}\n\n\tset skinInstance(val) {\n\t\tthis._skinInstance = val;\n\t\tthis._shaderDefs = val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN;\n\n\t\tfor (let i = 0; i < this._shader.length; i++) {\n\t\t\tthis._shader[i] = null;\n\t\t}\n\n\t\tthis._setupSkinUpdate();\n\t}\n\n\tget skinInstance() {\n\t\treturn this._skinInstance;\n\t}\n\n\tset morphInstance(val) {\n\t\tthis._morphInstance = val;\n\n\t\tif (this._morphInstance) {\n\t\t\tthis._morphInstance.meshInstance = this;\n\t\t}\n\n\t\tthis._shaderDefs = val && val.morph.useTextureMorph ? this._shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED : this._shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED;\n\t\tthis._shaderDefs = val && val.morph.morphPositions ? this._shaderDefs | SHADERDEF_MORPH_POSITION : this._shaderDefs & ~SHADERDEF_MORPH_POSITION;\n\t\tthis._shaderDefs = val && val.morph.morphNormals ? this._shaderDefs | SHADERDEF_MORPH_NORMAL : this._shaderDefs & ~SHADERDEF_MORPH_NORMAL;\n\n\t\tfor (let i = 0; i < this._shader.length; i++) {\n\t\t\tthis._shader[i] = null;\n\t\t}\n\t}\n\n\tget morphInstance() {\n\t\treturn this._morphInstance;\n\t}\n\n\tset screenSpace(val) {\n\t\tthis._screenSpace = val;\n\t\tthis._shaderDefs = val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE;\n\t\tthis._shader[SHADER_FORWARD] = null;\n\t}\n\n\tget screenSpace() {\n\t\treturn this._screenSpace;\n\t}\n\n\tset key(val) {\n\t\tthis._key[SORTKEY_FORWARD] = val;\n\t}\n\n\tget key() {\n\t\treturn this._key[SORTKEY_FORWARD];\n\t}\n\n\tset mask(val) {\n\t\tconst toggles = this._shaderDefs & 0x0000FFFF;\n\t\tthis._shaderDefs = toggles | val << 16;\n\t\tthis._shader[SHADER_FORWARD] = null;\n\t\tthis._shader[SHADER_FORWARDHDR] = null;\n\t}\n\n\tget mask() {\n\t\treturn this._shaderDefs >> 16;\n\t}\n\n\tset instancingCount(value) {\n\t\tif (this.instancingData) this.instancingData.count = value;\n\t}\n\n\tget instancingCount() {\n\t\treturn this.instancingData ? this.instancingData.count : 0;\n\t}\n\n\tdestroy() {\n\t\tconst mesh = this.mesh;\n\n\t\tif (mesh) {\n\t\t\tthis.mesh = null;\n\n\t\t\tif (mesh.refCount < 1) {\n\t\t\t\tmesh.destroy();\n\t\t\t}\n\t\t}\n\n\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);\n\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);\n\n\t\tif (this._skinInstance) {\n\t\t\tthis._skinInstance.destroy();\n\n\t\t\tthis._skinInstance = null;\n\t\t}\n\n\t\tif (this.morphInstance) {\n\t\t\tthis.morphInstance.destroy();\n\t\t\tthis.morphInstance = null;\n\t\t}\n\n\t\tthis.material = null;\n\t}\n\n\tstatic _prepareRenderStyleForArray(meshInstances, renderStyle) {\n\t\tif (meshInstances) {\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i]._renderStyle = renderStyle;\n\t\t\t\tconst mesh = meshInstances[i].mesh;\n\n\t\t\t\tif (!_meshSet.has(mesh)) {\n\t\t\t\t\t_meshSet.add(mesh);\n\n\t\t\t\t\tmesh.prepareRenderState(renderStyle);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_meshSet.clear();\n\t\t}\n\t}\n\n\t_isVisible(camera) {\n\t\tif (this.visible) {\n\t\t\tif (this.isVisibleFunc) {\n\t\t\t\treturn this.isVisibleFunc(camera);\n\t\t\t}\n\n\t\t\t_tempSphere.center = this.aabb.center;\n\t\t\t_tempSphere.radius = this._aabb.halfExtents.length();\n\t\t\treturn camera.frustum.containsSphere(_tempSphere);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tupdateKey() {\n\t\tconst material = this.material;\n\t\tthis._key[SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType, false, material.id);\n\t}\n\n\tsetInstancing(vertexBuffer) {\n\t\tif (vertexBuffer) {\n\t\t\tthis.instancingData = new InstancingData(vertexBuffer.numVertices);\n\t\t\tthis.instancingData.vertexBuffer = vertexBuffer;\n\t\t\tvertexBuffer.instancing = true;\n\t\t\tthis.cull = false;\n\t\t} else {\n\t\t\tthis.instancingData = null;\n\t\t\tthis.cull = true;\n\t\t}\n\t}\n\n\tclearParameters() {\n\t\tthis.parameters = {};\n\t}\n\n\tgetParameters() {\n\t\treturn this.parameters;\n\t}\n\n\tgetParameter(name) {\n\t\treturn this.parameters[name];\n\t}\n\n\tsetParameter(name, data, passFlags = -262141) {\n\t\tif (data === undefined && typeof name === 'object') {\n\t\t\tconst uniformObject = name;\n\n\t\t\tif (uniformObject.length) {\n\t\t\t\tfor (let i = 0; i < uniformObject.length; i++) {\n\t\t\t\t\tthis.setParameter(uniformObject[i]);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tname = uniformObject.name;\n\t\t\tdata = uniformObject.value;\n\t\t}\n\n\t\tconst param = this.parameters[name];\n\n\t\tif (param) {\n\t\t\tparam.data = data;\n\t\t\tparam.passFlags = passFlags;\n\t\t} else {\n\t\t\tthis.parameters[name] = {\n\t\t\t\tscopeId: null,\n\t\t\t\tdata: data,\n\t\t\t\tpassFlags: passFlags\n\t\t\t};\n\t\t}\n\t}\n\n\tsetRealtimeLightmap(name, texture) {\n\t\tconst old = this.getParameter(name);\n\t\tif (old === texture) return;\n\n\t\tif (old) {\n\t\t\tLightmapCache.decRef(old.data);\n\t\t}\n\n\t\tif (texture) {\n\t\t\tLightmapCache.incRef(texture);\n\t\t\tthis.setParameter(name, texture);\n\t\t} else {\n\t\t\tthis.deleteParameter(name);\n\t\t}\n\t}\n\n\tdeleteParameter(name) {\n\t\tif (this.parameters[name]) {\n\t\t\tdelete this.parameters[name];\n\t\t}\n\t}\n\n\tsetParameters(device, passFlag) {\n\t\tconst parameters = this.parameters;\n\n\t\tfor (const paramName in parameters) {\n\t\t\tconst parameter = parameters[paramName];\n\n\t\t\tif (parameter.passFlags & passFlag) {\n\t\t\t\tif (!parameter.scopeId) {\n\t\t\t\t\tparameter.scopeId = device.scope.resolve(paramName);\n\t\t\t\t}\n\n\t\t\t\tparameter.scopeId.setValue(parameter.data);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetLightmapped(value) {\n\t\tif (value) {\n\t\t\tthis.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);\n\t\t} else {\n\t\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);\n\t\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);\n\t\t\tthis._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);\n\t\t\tthis.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);\n\t\t}\n\t}\n\n\tsetCustomAabb(aabb) {\n\t\tif (aabb) {\n\t\t\tif (this._customAabb) {\n\t\t\t\tthis._customAabb.copy(aabb);\n\t\t\t} else {\n\t\t\t\tthis._customAabb = aabb.clone();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._customAabb = null;\n\t\t\tthis._aabbVer = -1;\n\t\t}\n\n\t\tthis._setupSkinUpdate();\n\t}\n\n\t_setupSkinUpdate() {\n\t\tif (this._skinInstance) {\n\t\t\tthis._skinInstance._updateBeforeCull = !this._customAabb;\n\t\t}\n\t}\n\n}\n\nMeshInstance.lightmapParamNames = [\"texture_lightMap\", \"texture_dirLightMap\"];\n\nfunction getKey(layer, blendType, isCommand, materialId) {\n\treturn (layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 0x1ffffff) << 0;\n}\n\nfunction paramsIdentical(a, b) {\n\tif (a && !b) return false;\n\tif (!a && b) return false;\n\ta = a.data;\n\tb = b.data;\n\tif (a === b) return true;\n\n\tif (a instanceof Float32Array && b instanceof Float32Array) {\n\t\tif (a.length !== b.length) return false;\n\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction equalParamSets(params1, params2) {\n\tfor (const param in params1) {\n\t\tif (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) return false;\n\t}\n\n\tfor (const param in params2) {\n\t\tif (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param])) return false;\n\t}\n\n\treturn true;\n}\n\nfunction equalLightLists(lightList1, lightList2) {\n\tfor (let k = 0; k < lightList1.length; k++) {\n\t\tif (lightList2.indexOf(lightList1[k]) < 0) return false;\n\t}\n\n\tfor (let k = 0; k < lightList2.length; k++) {\n\t\tif (lightList1.indexOf(lightList2[k]) < 0) return false;\n\t}\n\n\treturn true;\n}\n\nconst mat3 = new Mat3();\nconst worldMatX$1 = new Vec3();\nconst worldMatY$1 = new Vec3();\nconst worldMatZ$1 = new Vec3();\n\nfunction getScaleSign(mi) {\n\tconst wt = mi.node.worldTransform;\n\twt.getX(worldMatX$1);\n\twt.getY(worldMatY$1);\n\twt.getZ(worldMatZ$1);\n\tworldMatX$1.cross(worldMatX$1, worldMatY$1);\n\treturn worldMatX$1.dot(worldMatZ$1) >= 0 ? 1 : -1;\n}\n\nclass BatchManager {\n\tconstructor(device, root, scene) {\n\t\tthis.device = device;\n\t\tthis.rootNode = root;\n\t\tthis.scene = scene;\n\t\tthis._init = false;\n\t\tthis._batchGroups = {};\n\t\tthis._batchGroupCounter = 0;\n\t\tthis._batchList = [];\n\t\tthis._dirtyGroups = [];\n\t}\n\n\tdestroy() {\n\t\tthis.device = null;\n\t\tthis.rootNode = null;\n\t\tthis.scene = null;\n\t\tthis._batchGroups = {};\n\t\tthis._batchList = [];\n\t\tthis._dirtyGroups = [];\n\t}\n\n\taddGroup(name, dynamic, maxAabbSize, id, layers) {\n\t\tif (id === undefined) {\n\t\t\tid = this._batchGroupCounter;\n\t\t\tthis._batchGroupCounter++;\n\t\t}\n\n\t\tif (this._batchGroups[id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);\n\t\tthis._batchGroups[id] = group;\n\t\treturn group;\n\t}\n\n\tremoveGroup(id) {\n\t\tif (!this._batchGroups[id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newBatchList = [];\n\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (this._batchList[i].batchGroupId === id) {\n\t\t\t\tthis.destroyBatch(this._batchList[i]);\n\t\t\t} else {\n\t\t\t\tnewBatchList.push(this._batchList[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis._batchList = newBatchList;\n\n\t\tthis._removeModelsFromBatchGroup(this.rootNode, id);\n\n\t\tdelete this._batchGroups[id];\n\t}\n\n\tmarkGroupDirty(id) {\n\t\tif (this._dirtyGroups.indexOf(id) < 0) {\n\t\t\tthis._dirtyGroups.push(id);\n\t\t}\n\t}\n\n\tgetGroupByName(name) {\n\t\tconst groups = this._batchGroups;\n\n\t\tfor (const group in groups) {\n\t\t\tif (!groups.hasOwnProperty(group)) continue;\n\n\t\t\tif (groups[group].name === name) {\n\t\t\t\treturn groups[group];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tgetBatches(batchGroupId) {\n\t\tconst results = [];\n\t\tconst len = this._batchList.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst batch = this._batchList[i];\n\n\t\t\tif (batch.batchGroupId === batchGroupId) {\n\t\t\t\tresults.push(batch);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t_removeModelsFromBatchGroup(node, id) {\n\t\tif (!node.enabled) return;\n\n\t\tif (node.model && node.model.batchGroupId === id) {\n\t\t\tnode.model.batchGroupId = -1;\n\t\t}\n\n\t\tif (node.render && node.render.batchGroupId === id) {\n\t\t\tnode.render.batchGroupId = -1;\n\t\t}\n\n\t\tif (node.element && node.element.batchGroupId === id) {\n\t\t\tnode.element.batchGroupId = -1;\n\t\t}\n\n\t\tif (node.sprite && node.sprite.batchGroupId === id) {\n\t\t\tnode.sprite.batchGroupId = -1;\n\t\t}\n\n\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\tthis._removeModelsFromBatchGroup(node._children[i], id);\n\t\t}\n\t}\n\n\tinsert(type, groupId, node) {\n\t\tconst group = this._batchGroups[groupId];\n\n\t\tif (group) {\n\t\t\tif (group._obj[type].indexOf(node) < 0) {\n\t\t\t\tgroup._obj[type].push(node);\n\n\t\t\t\tthis.markGroupDirty(groupId);\n\t\t\t}\n\t\t}\n\t}\n\n\tremove(type, groupId, node) {\n\t\tconst group = this._batchGroups[groupId];\n\n\t\tif (group) {\n\t\t\tconst idx = group._obj[type].indexOf(node);\n\n\t\t\tif (idx >= 0) {\n\t\t\t\tgroup._obj[type].splice(idx, 1);\n\n\t\t\t\tthis.markGroupDirty(groupId);\n\t\t\t}\n\t\t}\n\t}\n\n\t_extractRender(node, arr, group, groupMeshInstances) {\n\t\tif (node.render) {\n\t\t\tif (node.render.isStatic) {\n\t\t\t\tconst drawCalls = this.scene.drawCalls;\n\t\t\t\tconst nodeMeshInstances = node.render.meshInstances;\n\n\t\t\t\tfor (let i = 0; i < drawCalls.length; i++) {\n\t\t\t\t\tif (!drawCalls[i]._staticSource) continue;\n\t\t\t\t\tif (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;\n\t\t\t\t\tarr.push(drawCalls[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < nodeMeshInstances.length; i++) {\n\t\t\t\t\tif (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {\n\t\t\t\t\t\tarr.push(nodeMeshInstances[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);\n\t\t\t}\n\n\t\t\tnode.render.removeFromLayers();\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t_extractModel(node, arr, group, groupMeshInstances) {\n\t\tif (node.model && node.model.model) {\n\t\t\tif (node.model.isStatic) {\n\t\t\t\tconst drawCalls = this.scene.drawCalls;\n\t\t\t\tconst nodeMeshInstances = node.model.meshInstances;\n\n\t\t\t\tfor (let i = 0; i < drawCalls.length; i++) {\n\t\t\t\t\tif (!drawCalls[i]._staticSource) continue;\n\t\t\t\t\tif (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;\n\t\t\t\t\tarr.push(drawCalls[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < nodeMeshInstances.length; i++) {\n\t\t\t\t\tif (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {\n\t\t\t\t\t\tarr.push(nodeMeshInstances[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);\n\t\t\t}\n\n\t\t\tnode.model.removeModelFromLayers();\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t_extractElement(node, arr, group) {\n\t\tif (!node.element) return;\n\t\tlet valid = false;\n\n\t\tif (node.element._text && node.element._text._model.meshInstances.length > 0) {\n\t\t\tarr.push(node.element._text._model.meshInstances[0]);\n\t\t\tnode.element.removeModelFromLayers(node.element._text._model);\n\t\t\tvalid = true;\n\t\t} else if (node.element._image) {\n\t\t\tarr.push(node.element._image._renderable.meshInstance);\n\t\t\tnode.element.removeModelFromLayers(node.element._image._renderable.model);\n\n\t\t\tif (node.element._image._renderable.unmaskMeshInstance) {\n\t\t\t\tarr.push(node.element._image._renderable.unmaskMeshInstance);\n\n\t\t\t\tif (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {\n\t\t\t\t\tnode.element._dirtifyMask();\n\n\t\t\t\t\tnode.element._onPrerender();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalid = true;\n\t\t}\n\n\t\tif (valid) {\n\t\t\tgroup._ui = true;\n\t\t}\n\t}\n\n\t_collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {\n\t\tfor (let g = 0; g < groupIds.length; g++) {\n\t\t\tconst id = groupIds[g];\n\t\t\tconst group = this._batchGroups[id];\n\t\t\tif (!group) continue;\n\t\t\tlet arr = groupMeshInstances[id];\n\t\t\tif (!arr) arr = groupMeshInstances[id] = [];\n\n\t\t\tfor (let m = 0; m < group._obj.model.length; m++) {\n\t\t\t\tarr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);\n\t\t\t}\n\n\t\t\tfor (let r = 0; r < group._obj.render.length; r++) {\n\t\t\t\tarr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);\n\t\t\t}\n\n\t\t\tfor (let e = 0; e < group._obj.element.length; e++) {\n\t\t\t\tthis._extractElement(group._obj.element[e], arr, group);\n\t\t\t}\n\n\t\t\tfor (let s = 0; s < group._obj.sprite.length; s++) {\n\t\t\t\tconst node = group._obj.sprite[s];\n\n\t\t\t\tif (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {\n\t\t\t\t\tarr.push(node.sprite._meshInstance);\n\t\t\t\t\tnode.sprite.removeModelFromLayers();\n\t\t\t\t\tgroup._sprite = true;\n\t\t\t\t\tnode.sprite._batchGroup = group;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgenerate(groupIds) {\n\t\tconst groupMeshInstances = {};\n\n\t\tif (!groupIds) {\n\t\t\tgroupIds = Object.keys(this._batchGroups);\n\t\t}\n\n\t\tconst newBatchList = [];\n\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {\n\t\t\t\tnewBatchList.push(this._batchList[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.destroyBatch(this._batchList[i]);\n\t\t}\n\n\t\tthis._batchList = newBatchList;\n\n\t\tthis._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);\n\n\t\tif (groupIds === this._dirtyGroups) {\n\t\t\tthis._dirtyGroups.length = 0;\n\t\t} else {\n\t\t\tconst newDirtyGroups = [];\n\n\t\t\tfor (let i = 0; i < this._dirtyGroups.length; i++) {\n\t\t\t\tif (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);\n\t\t\t}\n\n\t\t\tthis._dirtyGroups = newDirtyGroups;\n\t\t}\n\n\t\tlet group, lists, groupData, batch;\n\n\t\tfor (const groupId in groupMeshInstances) {\n\t\t\tif (!groupMeshInstances.hasOwnProperty(groupId)) continue;\n\t\t\tgroup = groupMeshInstances[groupId];\n\t\t\tgroupData = this._batchGroups[groupId];\n\n\t\t\tif (!groupData) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);\n\n\t\t\tfor (let i = 0; i < lists.length; i++) {\n\t\t\t\tbatch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));\n\n\t\t\t\tif (batch) {\n\t\t\t\t\tbatch.addToLayers(this.scene, groupData.layers);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprepare(meshInstances, dynamic, maxAabbSize = Number.POSITIVE_INFINITY, translucent) {\n\t\tif (meshInstances.length === 0) return [];\n\t\tconst halfMaxAabbSize = maxAabbSize * 0.5;\n\t\tconst maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;\n\t\tconst maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;\n\t\tconst aabb = new BoundingBox();\n\t\tconst testAabb = new BoundingBox();\n\t\tlet skipTranslucentAabb = null;\n\t\tlet sf;\n\t\tconst lists = [];\n\t\tlet j = 0;\n\n\t\tif (translucent) {\n\t\t\tmeshInstances.sort(function (a, b) {\n\t\t\t\treturn a.drawOrder - b.drawOrder;\n\t\t\t});\n\t\t}\n\n\t\tlet meshInstancesLeftA = meshInstances;\n\t\tlet meshInstancesLeftB;\n\t\tconst skipMesh = translucent ? function (mi) {\n\t\t\tif (skipTranslucentAabb) {\n\t\t\t\tskipTranslucentAabb.add(mi.aabb);\n\t\t\t} else {\n\t\t\t\tskipTranslucentAabb = mi.aabb.clone();\n\t\t\t}\n\n\t\t\tmeshInstancesLeftB.push(mi);\n\t\t} : function (mi) {\n\t\t\tmeshInstancesLeftB.push(mi);\n\t\t};\n\n\t\twhile (meshInstancesLeftA.length > 0) {\n\t\t\tlists[j] = [meshInstancesLeftA[0]];\n\t\t\tmeshInstancesLeftB = [];\n\t\t\tconst material = meshInstancesLeftA[0].material;\n\t\t\tconst layer = meshInstancesLeftA[0].layer;\n\t\t\tconst defs = meshInstancesLeftA[0]._shaderDefs;\n\t\t\tconst params = meshInstancesLeftA[0].parameters;\n\t\t\tconst stencil = meshInstancesLeftA[0].stencilFront;\n\t\t\tconst lightList = meshInstancesLeftA[0]._staticLightList;\n\t\t\tlet vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();\n\t\t\tconst drawOrder = meshInstancesLeftA[0].drawOrder;\n\t\t\taabb.copy(meshInstancesLeftA[0].aabb);\n\t\t\tconst scaleSign = getScaleSign(meshInstancesLeftA[0]);\n\t\t\tconst vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;\n\t\t\tconst indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;\n\t\t\tskipTranslucentAabb = null;\n\n\t\t\tfor (let i = 1; i < meshInstancesLeftA.length; i++) {\n\t\t\t\tconst mi = meshInstancesLeftA[i];\n\n\t\t\t\tif (dynamic && lists[j].length >= maxInstanceCount) {\n\t\t\t\t\tmeshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttestAabb.copy(aabb);\n\t\t\t\ttestAabb.add(mi.aabb);\n\n\t\t\t\tif (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (stencil) {\n\t\t\t\t\tif (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {\n\t\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (scaleSign !== getScaleSign(mi)) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!equalParamSets(params, mi.parameters)) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst staticLights = mi._staticLightList;\n\n\t\t\t\tif (lightList && staticLights) {\n\t\t\t\t\tif (!equalLightLists(lightList, staticLights)) {\n\t\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (lightList || staticLights) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\taabb.add(mi.aabb);\n\t\t\t\tvertCount += mi.mesh.vertexBuffer.getNumVertices();\n\t\t\t\tlists[j].push(mi);\n\t\t\t}\n\n\t\t\tj++;\n\t\t\tmeshInstancesLeftA = meshInstancesLeftB;\n\t\t}\n\n\t\treturn lists;\n\t}\n\n\tcollectBatchedMeshData(meshInstances, dynamic) {\n\t\tlet streams = null;\n\t\tlet batchNumVerts = 0;\n\t\tlet batchNumIndices = 0;\n\t\tlet material = null;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tif (meshInstances[i].visible) {\n\t\t\t\tconst mesh = meshInstances[i].mesh;\n\t\t\t\tconst numVerts = mesh.vertexBuffer.numVertices;\n\t\t\t\tbatchNumVerts += numVerts;\n\t\t\t\tbatchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count : mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0;\n\n\t\t\t\tif (!streams) {\n\t\t\t\t\tmaterial = meshInstances[i].material;\n\t\t\t\t\tstreams = {};\n\t\t\t\t\tconst elems = mesh.vertexBuffer.format.elements;\n\n\t\t\t\t\tfor (let j = 0; j < elems.length; j++) {\n\t\t\t\t\t\tconst semantic = elems[j].name;\n\t\t\t\t\t\tstreams[semantic] = {\n\t\t\t\t\t\t\tnumComponents: elems[j].numComponents,\n\t\t\t\t\t\t\tdataType: elems[j].dataType,\n\t\t\t\t\t\t\tnormalize: elems[j].normalize,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dynamic) {\n\t\t\t\t\t\tstreams[SEMANTIC_BLENDINDICES] = {\n\t\t\t\t\t\t\tnumComponents: 1,\n\t\t\t\t\t\t\tdataType: TYPE_FLOAT32,\n\t\t\t\t\t\t\tnormalize: false,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tstreams: streams,\n\t\t\tbatchNumVerts: batchNumVerts,\n\t\t\tbatchNumIndices: batchNumIndices,\n\t\t\tmaterial: material\n\t\t};\n\t}\n\n\tcreate(meshInstances, dynamic, batchGroupId) {\n\t\tif (!this._init) {\n\t\t\tconst boneLimit = \"#define BONE_LIMIT \" + this.device.getBoneLimit() + \"\\n\";\n\t\t\tthis.transformVS = boneLimit + \"#define DYNAMICBATCH\\n\" + shaderChunks.transformVS;\n\t\t\tthis.skinTexVS = shaderChunks.skinBatchTexVS;\n\t\t\tthis.skinConstVS = shaderChunks.skinBatchConstVS;\n\t\t\tthis.vertexFormats = {};\n\t\t\tthis._init = true;\n\t\t}\n\n\t\tlet stream = null;\n\t\tlet semantic;\n\t\tlet mesh, numVerts;\n\t\tlet batch = null;\n\t\tconst batchData = this.collectBatchedMeshData(meshInstances, dynamic);\n\n\t\tif (batchData.streams) {\n\t\t\tconst streams = batchData.streams;\n\t\t\tlet material = batchData.material;\n\t\t\tconst batchNumVerts = batchData.batchNumVerts;\n\t\t\tconst batchNumIndices = batchData.batchNumIndices;\n\t\t\tbatch = new Batch(meshInstances, dynamic, batchGroupId);\n\n\t\t\tthis._batchList.push(batch);\n\n\t\t\tlet indexBase, numIndices, indexData;\n\t\t\tlet verticesOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tlet transform;\n\t\t\tconst vec = new Vec3();\n\t\t\tconst indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;\n\t\t\tconst indices = new indexArrayType(batchNumIndices);\n\n\t\t\tfor (semantic in streams) {\n\t\t\t\tstream = streams[semantic];\n\t\t\t\tstream.typeArrayType = typedArrayTypes[stream.dataType];\n\t\t\t\tstream.elementByteSize = typedArrayTypesByteSize[stream.dataType];\n\t\t\t\tstream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (!meshInstances[i].visible) continue;\n\t\t\t\tmesh = meshInstances[i].mesh;\n\t\t\t\tnumVerts = mesh.vertexBuffer.numVertices;\n\n\t\t\t\tif (!dynamic) {\n\t\t\t\t\ttransform = meshInstances[i].node.getWorldTransform();\n\t\t\t\t}\n\n\t\t\t\tfor (semantic in streams) {\n\t\t\t\t\tif (semantic !== SEMANTIC_BLENDINDICES) {\n\t\t\t\t\t\tstream = streams[semantic];\n\t\t\t\t\t\tconst subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);\n\t\t\t\t\t\tconst totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;\n\t\t\t\t\t\tstream.count += totalComponents;\n\n\t\t\t\t\t\tif (!dynamic && stream.numComponents >= 3) {\n\t\t\t\t\t\t\tif (semantic === SEMANTIC_POSITION) {\n\t\t\t\t\t\t\t\tfor (let j = 0; j < totalComponents; j += stream.numComponents) {\n\t\t\t\t\t\t\t\t\tvec.set(subarray[j], subarray[j + 1], subarray[j + 2]);\n\t\t\t\t\t\t\t\t\ttransform.transformPoint(vec, vec);\n\t\t\t\t\t\t\t\t\tsubarray[j] = vec.x;\n\t\t\t\t\t\t\t\t\tsubarray[j + 1] = vec.y;\n\t\t\t\t\t\t\t\t\tsubarray[j + 2] = vec.z;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {\n\t\t\t\t\t\t\t\ttransform.invertTo3x3(mat3);\n\t\t\t\t\t\t\t\tmat3.transpose();\n\n\t\t\t\t\t\t\t\tfor (let j = 0; j < totalComponents; j += stream.numComponents) {\n\t\t\t\t\t\t\t\t\tvec.set(subarray[j], subarray[j + 1], subarray[j + 2]);\n\t\t\t\t\t\t\t\t\tmat3.transformVector(vec, vec);\n\t\t\t\t\t\t\t\t\tsubarray[j] = vec.x;\n\t\t\t\t\t\t\t\t\tsubarray[j + 1] = vec.y;\n\t\t\t\t\t\t\t\t\tsubarray[j + 2] = vec.z;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dynamic) {\n\t\t\t\t\tstream = streams[SEMANTIC_BLENDINDICES];\n\n\t\t\t\t\tfor (let j = 0; j < numVerts; j++) stream.buffer[stream.count++] = i;\n\t\t\t\t}\n\n\t\t\t\tif (mesh.primitive[0].indexed) {\n\t\t\t\t\tindexBase = mesh.primitive[0].base;\n\t\t\t\t\tnumIndices = mesh.primitive[0].count;\n\t\t\t\t\tconst srcFormat = mesh.indexBuffer[0].getFormat();\n\t\t\t\t\tindexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);\n\t\t\t\t} else if (mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {\n\t\t\t\t\tindexBase = 0;\n\t\t\t\t\tnumIndices = 6;\n\t\t\t\t\tindexData = [0, 1, 3, 2, 3, 1];\n\t\t\t\t} else {\n\t\t\t\t\tnumIndices = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < numIndices; j++) {\n\t\t\t\t\tindices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;\n\t\t\t\t}\n\n\t\t\t\tindexOffset += numIndices;\n\t\t\t\tverticesOffset += numVerts;\n\t\t\t}\n\n\t\t\tmesh = new Mesh(this.device);\n\n\t\t\tfor (semantic in streams) {\n\t\t\t\tstream = streams[semantic];\n\t\t\t\tmesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);\n\t\t\t}\n\n\t\t\tif (indices.length > 0) mesh.setIndices(indices);\n\t\t\tmesh.update(PRIMITIVE_TRIANGLES, false);\n\n\t\t\tif (dynamic) {\n\t\t\t\tmaterial = material.clone();\n\t\t\t\tmaterial.chunks.transformVS = this.transformVS;\n\t\t\t\tmaterial.chunks.skinTexVS = this.skinTexVS;\n\t\t\t\tmaterial.chunks.skinConstVS = this.skinConstVS;\n\t\t\t\tmaterial.update();\n\t\t\t}\n\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, this.rootNode);\n\t\t\tmeshInstance.castShadow = batch.origMeshInstances[0].castShadow;\n\t\t\tmeshInstance.parameters = batch.origMeshInstances[0].parameters;\n\t\t\tmeshInstance.isStatic = batch.origMeshInstances[0].isStatic;\n\t\t\tmeshInstance.layer = batch.origMeshInstances[0].layer;\n\t\t\tmeshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;\n\t\t\tmeshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;\n\t\t\tmeshInstance.cull = batch.origMeshInstances[0].cull;\n\t\t\tconst batchGroup = this._batchGroups[batchGroupId];\n\t\t\tif (batchGroup && batchGroup._ui) meshInstance.cull = false;\n\n\t\t\tif (dynamic) {\n\t\t\t\tconst nodes = [];\n\n\t\t\t\tfor (let i = 0; i < batch.origMeshInstances.length; i++) {\n\t\t\t\t\tnodes.push(batch.origMeshInstances[i].node);\n\t\t\t\t}\n\n\t\t\t\tmeshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);\n\t\t\t}\n\n\t\t\tmeshInstance._updateAabb = false;\n\t\t\tmeshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;\n\t\t\tmeshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;\n\t\t\tmeshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;\n\t\t\tmeshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;\n\t\t\tmeshInstance.castShadow = batch.origMeshInstances[0].castShadow;\n\t\t\tbatch.meshInstance = meshInstance;\n\t\t\tbatch.updateBoundingBox();\n\t\t}\n\n\t\treturn batch;\n\t}\n\n\tupdateAll() {\n\t\tif (this._dirtyGroups.length > 0) {\n\t\t\tthis.generate(this._dirtyGroups);\n\t\t}\n\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (!this._batchList[i].dynamic) continue;\n\n\t\t\tthis._batchList[i].updateBoundingBox();\n\t\t}\n\t}\n\n\tclone(batch, clonedMeshInstances) {\n\t\tconst batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);\n\n\t\tthis._batchList.push(batch2);\n\n\t\tconst nodes = [];\n\n\t\tfor (let i = 0; i < clonedMeshInstances.length; i++) {\n\t\t\tnodes.push(clonedMeshInstances[i].node);\n\t\t}\n\n\t\tbatch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);\n\t\tbatch2.meshInstance._updateAabb = false;\n\t\tbatch2.meshInstance.parameters = clonedMeshInstances[0].parameters;\n\t\tbatch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;\n\t\tbatch2.meshInstance.cull = clonedMeshInstances[0].cull;\n\t\tbatch2.meshInstance.layer = clonedMeshInstances[0].layer;\n\t\tbatch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;\n\n\t\tif (batch.dynamic) {\n\t\t\tbatch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);\n\t\t}\n\n\t\tbatch2.meshInstance.castShadow = batch.meshInstance.castShadow;\n\t\tbatch2.meshInstance._shader = batch.meshInstance._shader;\n\t\tbatch2.meshInstance.castShadow = batch.meshInstance.castShadow;\n\t\treturn batch2;\n\t}\n\n\tdestroyBatch(batch) {\n\t\tbatch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);\n\t}\n\n}\n\nconst tempVec3 = new Vec3();\nconst tempMin3 = new Vec3();\nconst tempMax3 = new Vec3();\nconst tempBox = new BoundingBox();\nconst epsilon = 0.000001;\n\nclass ClusterLight {\n\tconstructor() {\n\t\tthis.light = null;\n\t\tthis.min = new Vec3();\n\t\tthis.max = new Vec3();\n\t}\n\n}\n\nclass WorldClusters {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.name = \"Untitled\";\n\t\tthis.reportCount = 0;\n\t\tthis.boundsMin = new Vec3();\n\t\tthis.boundsMax = new Vec3();\n\t\tthis.boundsDelta = new Vec3();\n\t\tthis._cells = new Vec3(1, 1, 1);\n\t\tthis._cellsLimit = new Vec3();\n\t\tthis.cells = this._cells;\n\t\tthis._maxCellLightCount = 0;\n\t\tthis._pixelsPerCellCount = 0;\n\t\tthis.maxCellLightCount = 4;\n\t\tthis._maxAttenuation = 0;\n\t\tthis._maxColorValue = 0;\n\t\tthis._usedLights = [];\n\n\t\tthis._usedLights.push(new ClusterLight());\n\n\t\tthis.lightsBuffer = new LightsBuffer(device);\n\t\tthis.registerUniforms(device);\n\t}\n\n\tset maxCellLightCount(count) {\n\t\tconst maxCellLightCount = math.roundUp(count, 4);\n\n\t\tif (maxCellLightCount !== this._maxCellLightCount) {\n\t\t\tthis._maxCellLightCount = maxCellLightCount;\n\t\t\tthis._pixelsPerCellCount = this._maxCellLightCount / 4;\n\t\t\tthis._cellsDirty = true;\n\t\t}\n\t}\n\n\tget maxCellLightCount() {\n\t\treturn this._maxCellLightCount;\n\t}\n\n\tset cells(value) {\n\t\ttempVec3.copy(value).floor();\n\n\t\tif (!this._cells.equals(tempVec3)) {\n\t\t\tthis._cells.copy(tempVec3);\n\n\t\t\tthis._cellsLimit.copy(tempVec3).sub(Vec3.ONE);\n\n\t\t\tthis._cellsDirty = true;\n\t\t}\n\t}\n\n\tget cells() {\n\t\treturn this._cells;\n\t}\n\n\tdestroy() {\n\t\tthis.lightsBuffer.destroy();\n\t\tthis.releaseClusterTexture();\n\t}\n\n\treleaseClusterTexture() {\n\t\tif (this.clusterTexture) {\n\t\t\tthis.clusterTexture.destroy();\n\t\t\tthis.clusterTexture = null;\n\t\t}\n\t}\n\n\tregisterUniforms(device) {\n\t\tthis._clusterWorldTextureId = device.scope.resolve(\"clusterWorldTexture\");\n\t\tthis._clusterPixelsPerCellId = device.scope.resolve(\"clusterPixelsPerCell\");\n\t\tthis._clusterTextureSizeId = device.scope.resolve(\"clusterTextureSize\");\n\t\tthis._clusterTextureSizeData = new Float32Array(3);\n\t\tthis._clusterBoundsMinId = device.scope.resolve(\"clusterBoundsMin\");\n\t\tthis._clusterBoundsMinData = new Float32Array(3);\n\t\tthis._clusterBoundsDeltaId = device.scope.resolve(\"clusterBoundsDelta\");\n\t\tthis._clusterBoundsDeltaData = new Float32Array(3);\n\t\tthis._clusterCellsCountByBoundsSizeId = device.scope.resolve(\"clusterCellsCountByBoundsSize\");\n\t\tthis._clusterCellsCountByBoundsSizeData = new Float32Array(3);\n\t\tthis._clusterCellsDotId = device.scope.resolve(\"clusterCellsDot\");\n\t\tthis._clusterCellsDotData = new Float32Array(3);\n\t\tthis._clusterCellsMaxId = device.scope.resolve(\"clusterCellsMax\");\n\t\tthis._clusterCellsMaxData = new Float32Array(3);\n\t\tthis._clusterCompressionLimit0Id = device.scope.resolve(\"clusterCompressionLimit0\");\n\t\tthis._clusterCompressionLimit0Data = new Float32Array(2);\n\t}\n\n\tupdateParams(lightingParams) {\n\t\tif (lightingParams) {\n\t\t\tthis.cells = lightingParams.cells;\n\t\t\tthis.maxCellLightCount = lightingParams.maxLightsPerCell;\n\t\t\tthis.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;\n\t\t\tthis.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;\n\t\t\tthis.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;\n\t\t}\n\t}\n\n\tupdateCells() {\n\t\tif (this._cellsDirty) {\n\t\t\tthis._cellsDirty = false;\n\t\t\tconst cx = this._cells.x;\n\t\t\tconst cy = this._cells.y;\n\t\t\tconst cz = this._cells.z;\n\t\t\tconst numCells = cx * cy * cz;\n\t\t\tconst totalPixels = this._pixelsPerCellCount * numCells;\n\t\t\tlet width = Math.ceil(Math.sqrt(totalPixels));\n\t\t\twidth = math.roundUp(width, this._pixelsPerCellCount);\n\t\t\tconst height = Math.ceil(totalPixels / width);\n\t\t\tthis._clusterCellsMaxData[0] = cx;\n\t\t\tthis._clusterCellsMaxData[1] = cy;\n\t\t\tthis._clusterCellsMaxData[2] = cz;\n\t\t\tthis._clusterCellsDotData[0] = this._pixelsPerCellCount;\n\t\t\tthis._clusterCellsDotData[1] = cx * cz * this._pixelsPerCellCount;\n\t\t\tthis._clusterCellsDotData[2] = cx * this._pixelsPerCellCount;\n\t\t\tthis.clusters = new Uint8ClampedArray(4 * totalPixels);\n\t\t\tthis.counts = new Int32Array(numCells);\n\t\t\tthis._clusterTextureSizeData[0] = width;\n\t\t\tthis._clusterTextureSizeData[1] = 1.0 / width;\n\t\t\tthis._clusterTextureSizeData[2] = 1.0 / height;\n\t\t\tthis.releaseClusterTexture();\n\t\t\tthis.clusterTexture = LightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8_G8_B8_A8, \"ClusterTexture\");\n\t\t}\n\t}\n\n\tuploadTextures() {\n\t\tthis.clusterTexture.lock().set(this.clusters);\n\t\tthis.clusterTexture.unlock();\n\t\tthis.lightsBuffer.uploadTextures();\n\t}\n\n\tupdateUniforms() {\n\t\tthis.lightsBuffer.updateUniforms();\n\n\t\tthis._clusterWorldTextureId.setValue(this.clusterTexture);\n\n\t\tconst boundsDelta = this.boundsDelta;\n\t\tthis._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;\n\t\tthis._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;\n\t\tthis._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;\n\n\t\tthis._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);\n\n\t\tthis._clusterBoundsMinData[0] = this.boundsMin.x;\n\t\tthis._clusterBoundsMinData[1] = this.boundsMin.y;\n\t\tthis._clusterBoundsMinData[2] = this.boundsMin.z;\n\t\tthis._clusterBoundsDeltaData[0] = boundsDelta.x;\n\t\tthis._clusterBoundsDeltaData[1] = boundsDelta.y;\n\t\tthis._clusterBoundsDeltaData[2] = boundsDelta.z;\n\t\tthis._clusterCompressionLimit0Data[0] = this._maxAttenuation;\n\t\tthis._clusterCompressionLimit0Data[1] = this._maxColorValue;\n\n\t\tthis._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount);\n\n\t\tthis._clusterTextureSizeId.setValue(this._clusterTextureSizeData);\n\n\t\tthis._clusterBoundsMinId.setValue(this._clusterBoundsMinData);\n\n\t\tthis._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);\n\n\t\tthis._clusterCellsDotId.setValue(this._clusterCellsDotData);\n\n\t\tthis._clusterCellsMaxId.setValue(this._clusterCellsMaxData);\n\n\t\tthis._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);\n\t}\n\n\tevalLightCellMinMax(clusteredLight, min, max) {\n\t\tmin.copy(clusteredLight.min);\n\t\tmin.sub(this.boundsMin);\n\t\tmin.div(this.boundsDelta);\n\t\tmin.mul2(min, this.cells);\n\t\tmin.floor();\n\t\tmax.copy(clusteredLight.max);\n\t\tmax.sub(this.boundsMin);\n\t\tmax.div(this.boundsDelta);\n\t\tmax.mul2(max, this.cells);\n\t\tmax.ceil();\n\t\tmin.max(Vec3.ZERO);\n\t\tmax.min(this._cellsLimit);\n\t}\n\n\tcollectLights(lights) {\n\t\tconst maxLights = this.lightsBuffer.maxLights;\n\t\tconst usedLights = this._usedLights;\n\t\tlet lightIndex = 1;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\t\t\tconst runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));\n\n\t\t\tif (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight) {\n\t\t\t\tif (lightIndex < maxLights) {\n\t\t\t\t\tlet clusteredLight;\n\n\t\t\t\t\tif (lightIndex < usedLights.length) {\n\t\t\t\t\t\tclusteredLight = usedLights[lightIndex];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclusteredLight = new ClusterLight();\n\t\t\t\t\t\tusedLights.push(clusteredLight);\n\t\t\t\t\t}\n\n\t\t\t\t\tclusteredLight.light = light;\n\t\t\t\t\tlight.getBoundingBox(tempBox);\n\t\t\t\t\tclusteredLight.min.copy(tempBox.getMin());\n\t\t\t\t\tclusteredLight.max.copy(tempBox.getMax());\n\t\t\t\t\tlightIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`Clustered lighting: more than ${maxLights - 1} lights in the frame, ignoring some.`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tusedLights.length = lightIndex;\n\t}\n\n\tevaluateBounds() {\n\t\tconst usedLights = this._usedLights;\n\t\tconst min = this.boundsMin;\n\t\tconst max = this.boundsMax;\n\n\t\tif (usedLights.length > 1) {\n\t\t\tmin.copy(usedLights[1].min);\n\t\t\tmax.copy(usedLights[1].max);\n\n\t\t\tfor (let i = 2; i < usedLights.length; i++) {\n\t\t\t\tmin.min(usedLights[i].min);\n\t\t\t\tmax.max(usedLights[i].max);\n\t\t\t}\n\t\t} else {\n\t\t\tmin.set(0, 0, 0);\n\t\t\tmax.set(1, 1, 1);\n\t\t}\n\n\t\tthis.boundsDelta.sub2(max, min);\n\t\tthis.lightsBuffer.setBounds(min, this.boundsDelta);\n\t}\n\n\tevaluateCompressionLimits(gammaCorrection) {\n\t\tlet maxAttenuation = 0;\n\t\tlet maxColorValue = 0;\n\t\tconst usedLights = this._usedLights;\n\n\t\tfor (let i = 1; i < usedLights.length; i++) {\n\t\t\tconst light = usedLights[i].light;\n\t\t\tmaxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);\n\t\t\tconst color = gammaCorrection ? light._linearFinalColor : light._finalColor;\n\t\t\tmaxColorValue = Math.max(color[0], maxColorValue);\n\t\t\tmaxColorValue = Math.max(color[1], maxColorValue);\n\t\t\tmaxColorValue = Math.max(color[2], maxColorValue);\n\t\t}\n\n\t\tthis._maxAttenuation = maxAttenuation + epsilon;\n\t\tthis._maxColorValue = maxColorValue + epsilon;\n\t\tthis.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);\n\t}\n\n\tupdateClusters(gammaCorrection) {\n\t\tthis.counts.fill(0);\n\t\tthis.clusters.fill(0);\n\t\tconst divX = this._cells.x;\n\t\tconst divZ = this._cells.z;\n\t\tconst counts = this.counts;\n\t\tconst limit = this._maxCellLightCount;\n\t\tconst clusters = this.clusters;\n\t\tconst pixelsPerCellCount = this._pixelsPerCellCount;\n\t\tconst usedLights = this._usedLights;\n\n\t\tfor (let i = 1; i < usedLights.length; i++) {\n\t\t\tconst clusteredLight = usedLights[i];\n\t\t\tconst light = clusteredLight.light;\n\t\t\tthis.lightsBuffer.addLightData(light, i, gammaCorrection);\n\t\t\tthis.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);\n\t\t\tconst xStart = tempMin3.x;\n\t\t\tconst xEnd = tempMax3.x;\n\t\t\tconst yStart = tempMin3.y;\n\t\t\tconst yEnd = tempMax3.y;\n\t\t\tconst zStart = tempMin3.z;\n\t\t\tconst zEnd = tempMax3.z;\n\n\t\t\tfor (let x = xStart; x <= xEnd; x++) {\n\t\t\t\tfor (let z = zStart; z <= zEnd; z++) {\n\t\t\t\t\tfor (let y = yStart; y <= yEnd; y++) {\n\t\t\t\t\t\tconst clusterIndex = x + divX * (z + y * divZ);\n\t\t\t\t\t\tconst count = counts[clusterIndex];\n\n\t\t\t\t\t\tif (count < limit) {\n\t\t\t\t\t\t\tclusters[pixelsPerCellCount * clusterIndex * 4 + count] = i;\n\t\t\t\t\t\t\tcounts[clusterIndex] = count + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate(lights, gammaCorrection, lightingParams) {\n\t\tthis.updateParams(lightingParams);\n\t\tthis.updateCells();\n\t\tthis.collectLights(lights);\n\t\tthis.evaluateBounds();\n\t\tthis.evaluateCompressionLimits(gammaCorrection);\n\t\tthis.updateClusters(gammaCorrection);\n\t\tthis.uploadTextures();\n\t}\n\n\tactivate() {\n\t\tthis.updateUniforms();\n\t}\n\n}\n\nclass DepthMaterial extends Material {\n\tupdateShader(device) {\n\t\tconst options = {\n\t\t\tskin: !!this.meshInstances[0].skinInstance\n\t\t};\n\t\tconst library = device.getProgramLibrary();\n\t\tthis.shader = library.getProgram('depth', options);\n\t}\n\n}\n\nconst textureBlitVertexShader = `\n\t\tattribute vec2 vertex_position;\n\t\tvarying vec2 uv0;\n\t\tvoid main(void) {\n\t\t\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\t\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t}`;\nconst textureBlitFragmentShader = `\n\t\tvarying vec2 uv0;\n\t\tuniform sampler2D blitTexture;\n\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = texture2D(blitTexture, uv0);\n\t\t}`;\nconst textureCubeBlitFragmentShader = `\n\t\tvarying vec2 uv0;\n\t\tuniform samplerCube blitTexture;\n\t\tuniform mat4 invViewProj;\n\t\tvoid main(void) {\n\t\t\t\tvec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n\t\t\t\tvec4 worldPos = invViewProj * projPos;\n\t\t\t\tgl_FragColor = textureCube(blitTexture, worldPos.xyz);\n\t\t}`;\n\nconst _viewport$1 = new Vec4();\n\nclass CookieRenderer {\n\tconstructor(device, lightTextureAtlas) {\n\t\tthis.device = device;\n\t\tthis.lightTextureAtlas = lightTextureAtlas;\n\t\tthis.blitShader2d = null;\n\t\tthis.blitShaderCube = null;\n\t\tthis.blitTextureId = null;\n\t\tthis.invViewProjId = null;\n\t}\n\n\tdestroy() {}\n\n\tgetShader(shader, fragment) {\n\t\tif (!this[shader]) this[shader] = createShaderFromCode(this.device, textureBlitVertexShader, fragment, `cookie_renderer_${shader}`);\n\t\tif (!this.blitTextureId) this.blitTextureId = this.device.scope.resolve(\"blitTexture\");\n\t\tif (!this.invViewProjId) this.invViewProjId = this.device.scope.resolve(\"invViewProj\");\n\t\treturn this[shader];\n\t}\n\n\tget shader2d() {\n\t\treturn this.getShader(\"blitShader2d\", textureBlitFragmentShader);\n\t}\n\n\tget shaderCube() {\n\t\treturn this.getShader(\"blitShaderCube\", textureCubeBlitFragmentShader);\n\t}\n\n\tstatic createTexture(device, resolution) {\n\t\tconst texture = new Texture(device, {\n\t\t\tname: \"CookieAtlas\",\n\t\t\twidth: resolution,\n\t\t\theight: resolution,\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\tcubemap: false,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\treturn texture;\n\t}\n\n\tinitInvViewProjMatrices() {\n\t\tif (!CookieRenderer._invViewProjMatrices) {\n\t\t\tCookieRenderer._invViewProjMatrices = [];\n\n\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\tconst camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);\n\t\t\t\tconst projMat = camera.projectionMatrix;\n\t\t\t\tconst viewMat = camera.node.getLocalTransform().clone().invert();\n\t\t\t\tCookieRenderer._invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();\n\t\t\t}\n\t\t}\n\t}\n\n\trender(light, renderTarget) {\n\t\tif (light.enabled && light.cookie && light.visibleThisFrame) {\n\t\t\tconst faceCount = light.numShadowFaces;\n\t\t\tconst shader = faceCount > 1 ? this.shaderCube : this.shader2d;\n\t\t\tconst device = this.device;\n\n\t\t\tif (faceCount > 1) {\n\t\t\t\tthis.initInvViewProjMatrices();\n\t\t\t}\n\n\t\t\tthis.blitTextureId.setValue(light.cookie);\n\n\t\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\t\t_viewport$1.copy(light.atlasViewport);\n\n\t\t\t\tif (faceCount > 1) {\n\t\t\t\t\tconst smallSize = _viewport$1.z / 3;\n\t\t\t\t\tconst offset = this.lightTextureAtlas.cubeSlotsOffsets[face];\n\t\t\t\t\t_viewport$1.x += smallSize * offset.x;\n\t\t\t\t\t_viewport$1.y += smallSize * offset.y;\n\t\t\t\t\t_viewport$1.z = smallSize;\n\t\t\t\t\t_viewport$1.w = smallSize;\n\t\t\t\t\tthis.invViewProjId.setValue(CookieRenderer._invViewProjMatrices[face].data);\n\t\t\t\t}\n\n\t\t\t\t_viewport$1.mulScalar(renderTarget.colorBuffer.width);\n\n\t\t\t\tdrawQuadWithShader(device, renderTarget, shader, _viewport$1);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nCookieRenderer._invViewProjMatrices = null;\n\nclass ShadowMap {\n\tconstructor(texture, targets) {\n\t\tthis.texture = texture;\n\t\tthis.cached = false;\n\t\tthis.renderTargets = targets;\n\t}\n\n\tdestroy() {\n\t\tif (this.texture) {\n\t\t\tthis.texture.destroy();\n\t\t\tthis.texture = null;\n\t\t}\n\n\t\tconst targets = this.renderTargets;\n\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\ttargets[i].destroy();\n\t\t}\n\n\t\tthis.renderTargets.length = 0;\n\t}\n\n\tstatic getShadowFormat(device, shadowType) {\n\t\tif (shadowType === SHADOW_VSM32) {\n\t\t\treturn PIXELFORMAT_RGBA32F;\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\treturn PIXELFORMAT_RGBA16F;\n\t\t} else if (shadowType === SHADOW_PCF5) {\n\t\t\treturn PIXELFORMAT_DEPTH;\n\t\t} else if (shadowType === SHADOW_PCF3 && device.webgl2) {\n\t\t\treturn PIXELFORMAT_DEPTH;\n\t\t}\n\n\t\treturn PIXELFORMAT_R8_G8_B8_A8;\n\t}\n\n\tstatic getShadowFiltering(device, shadowType) {\n\t\tif (shadowType === SHADOW_PCF3 && !device.webgl2) {\n\t\t\treturn FILTER_NEAREST;\n\t\t} else if (shadowType === SHADOW_VSM32) {\n\t\t\treturn device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\treturn device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;\n\t\t}\n\n\t\treturn FILTER_LINEAR;\n\t}\n\n\tstatic create(device, light) {\n\t\tlet shadowMap = null;\n\n\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\tshadowMap = this.createCubemap(device, light._shadowResolution);\n\t\t} else {\n\t\t\tshadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);\n\t\t}\n\n\t\treturn shadowMap;\n\t}\n\n\tstatic createAtlas(device, resolution, shadowType) {\n\t\tconst shadowMap = this.create2dMap(device, resolution, shadowType);\n\t\tconst targets = shadowMap.renderTargets;\n\t\tconst rt = targets[0];\n\n\t\tfor (let i = 0; i < 5; i++) {\n\t\t\ttargets.push(rt);\n\t\t}\n\n\t\treturn shadowMap;\n\t}\n\n\tstatic create2dMap(device, size, shadowType) {\n\t\tconst format = this.getShadowFormat(device, shadowType);\n\t\tconst filter = this.getShadowFiltering(device, shadowType);\n\t\tconst texture = new Texture(device, {\n\t\t\tformat: format,\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: filter,\n\t\t\tmagFilter: filter,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\ttexture.name = 'ShadowMap2D';\n\t\tlet target = null;\n\n\t\tif (shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2) {\n\t\t\ttexture.compareOnRead = true;\n\t\t\ttexture.compareFunc = FUNC_LESS;\n\t\t\ttarget = new RenderTarget({\n\t\t\t\tdepthBuffer: texture\n\t\t\t});\n\t\t} else {\n\t\t\ttarget = new RenderTarget({\n\t\t\t\tcolorBuffer: texture,\n\t\t\t\tdepth: true\n\t\t\t});\n\t\t}\n\n\t\treturn new ShadowMap(texture, [target]);\n\t}\n\n\tstatic createCubemap(device, size) {\n\t\tconst cubemap = new Texture(device, {\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tcubemap: true,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tcubemap.name = 'ShadowMapCube';\n\t\tconst targets = [];\n\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst target = new RenderTarget({\n\t\t\t\tcolorBuffer: cubemap,\n\t\t\t\tface: i,\n\t\t\t\tdepth: true\n\t\t\t});\n\t\t\ttargets.push(target);\n\t\t}\n\n\t\treturn new ShadowMap(cubemap, targets);\n\t}\n\n}\n\nconst _tempArray = [];\nconst _tempArray2 = [];\n\nconst _viewport = new Vec4();\n\nconst _scissor = new Vec4();\n\nclass Slot {\n\tconstructor(rect) {\n\t\tthis.size = Math.floor(rect.w * 1024);\n\t\tthis.used = false;\n\t\tthis.lightId = -1;\n\t\tthis.rect = rect;\n\t}\n\n}\n\nclass LightTextureAtlas {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.version = 1;\n\t\tthis.shadowAtlasResolution = 2048;\n\t\tthis.shadowAtlas = null;\n\t\tthis.shadowEdgePixels = 3;\n\t\tthis.cookieAtlasResolution = 2048;\n\t\tthis.cookieAtlas = null;\n\t\tthis.cookieRenderTarget = null;\n\t\tthis.slots = [];\n\t\tthis.atlasSplit = [];\n\t\tthis.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];\n\t\tthis.scissorVec = new Vec4();\n\t\tthis.allocateShadowAtlas(1);\n\t\tthis.allocateCookieAtlas(1);\n\t\tthis.allocateUniforms();\n\t}\n\n\tdestroy() {\n\t\tthis.destroyShadowAtlas();\n\t\tthis.destroyCookieAtlas();\n\t}\n\n\tdestroyShadowAtlas() {\n\t\tif (this.shadowAtlas) {\n\t\t\tthis.shadowAtlas.destroy();\n\t\t\tthis.shadowAtlas = null;\n\t\t}\n\t}\n\n\tdestroyCookieAtlas() {\n\t\tif (this.cookieAtlas) {\n\t\t\tthis.cookieAtlas.destroy();\n\t\t\tthis.cookieAtlas = null;\n\t\t}\n\n\t\tif (this.cookieRenderTarget) {\n\t\t\tthis.cookieRenderTarget.destroy();\n\t\t\tthis.cookieRenderTarget = null;\n\t\t}\n\t}\n\n\tallocateShadowAtlas(resolution) {\n\t\tif (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {\n\t\t\tthis.version++;\n\t\t\tthis.destroyShadowAtlas();\n\t\t\tthis.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);\n\t\t\tthis.shadowAtlas.cached = true;\n\t\t\tconst scissorOffset = 4 / this.shadowAtlasResolution;\n\t\t\tthis.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);\n\t\t}\n\t}\n\n\tallocateCookieAtlas(resolution) {\n\t\tif (!this.cookieAtlas || this.cookieAtlas.width !== resolution) {\n\t\t\tthis.version++;\n\t\t\tthis.destroyCookieAtlas();\n\t\t\tthis.cookieAtlas = CookieRenderer.createTexture(this.device, resolution);\n\t\t\tthis.cookieRenderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: this.cookieAtlas,\n\t\t\t\tdepth: false,\n\t\t\t\tflipY: true\n\t\t\t});\n\t\t}\n\t}\n\n\tallocateUniforms() {\n\t\tthis._shadowAtlasTextureId = this.device.scope.resolve(\"shadowAtlasTexture\");\n\t\tthis._shadowAtlasParamsId = this.device.scope.resolve(\"shadowAtlasParams\");\n\t\tthis._shadowAtlasParams = new Float32Array(2);\n\t\tthis._cookieAtlasTextureId = this.device.scope.resolve(\"cookieAtlasTexture\");\n\t}\n\n\tupdateUniforms() {\n\t\tconst isShadowFilterPcf = true;\n\t\tconst rt = this.shadowAtlas.renderTargets[0];\n\t\tconst shadowBuffer = this.device.webgl2 && isShadowFilterPcf ? rt.depthBuffer : rt.colorBuffer;\n\n\t\tthis._shadowAtlasTextureId.setValue(shadowBuffer);\n\n\t\tthis._shadowAtlasParams[0] = this.shadowAtlasResolution;\n\t\tthis._shadowAtlasParams[1] = this.shadowEdgePixels;\n\n\t\tthis._shadowAtlasParamsId.setValue(this._shadowAtlasParams);\n\n\t\tthis._cookieAtlasTextureId.setValue(this.cookieAtlas);\n\t}\n\n\tsubdivide(numLights, lightingParams) {\n\t\tlet atlasSplit = lightingParams.atlasSplit;\n\n\t\tif (!atlasSplit) {\n\t\t\tconst gridSize = Math.ceil(Math.sqrt(numLights));\n\t\t\tatlasSplit = _tempArray2;\n\t\t\tatlasSplit[0] = gridSize;\n\t\t\tatlasSplit.length = 1;\n\t\t}\n\n\t\tconst arraysEqual = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\n\n\t\tif (!arraysEqual(atlasSplit, this.atlasSplit)) {\n\t\t\tthis.version++;\n\t\t\tthis.slots.length = 0;\n\t\t\tthis.atlasSplit.length = 0;\n\t\t\tthis.atlasSplit.push(...atlasSplit);\n\t\t\tconst splitCount = this.atlasSplit[0];\n\n\t\t\tif (splitCount > 1) {\n\t\t\t\tconst invSize = 1 / splitCount;\n\n\t\t\t\tfor (let i = 0; i < splitCount; i++) {\n\t\t\t\t\tfor (let j = 0; j < splitCount; j++) {\n\t\t\t\t\t\tconst rect = new Vec4(i * invSize, j * invSize, invSize, invSize);\n\t\t\t\t\t\tconst nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];\n\n\t\t\t\t\t\tif (nextLevelSplit > 1) {\n\t\t\t\t\t\t\tfor (let x = 0; x < nextLevelSplit; x++) {\n\t\t\t\t\t\t\t\tfor (let y = 0; y < nextLevelSplit; y++) {\n\t\t\t\t\t\t\t\t\tconst invSizeNext = invSize / nextLevelSplit;\n\t\t\t\t\t\t\t\t\tconst rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);\n\t\t\t\t\t\t\t\t\tthis.slots.push(new Slot(rectNext));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.slots.push(new Slot(rect));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.slots.push(new Slot(new Vec4(0, 0, 1, 1)));\n\t\t\t}\n\n\t\t\tthis.slots.sort((a, b) => {\n\t\t\t\treturn b.size - a.size;\n\t\t\t});\n\t\t}\n\t}\n\n\tcollectLights(spotLights, omniLights, lightingParams) {\n\t\tconst cookiesEnabled = lightingParams.cookiesEnabled;\n\t\tconst shadowsEnabled = lightingParams.shadowsEnabled;\n\t\tlet needsShadowAtlas = false;\n\t\tlet needsCookieAtlas = false;\n\t\tconst lights = _tempArray;\n\t\tlights.length = 0;\n\n\t\tconst processLights = list => {\n\t\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\t\tconst light = list[i];\n\n\t\t\t\tif (light.visibleThisFrame) {\n\t\t\t\t\tconst lightShadow = shadowsEnabled && light.castShadows;\n\t\t\t\t\tconst lightCookie = cookiesEnabled && !!light.cookie;\n\t\t\t\t\tneedsShadowAtlas || (needsShadowAtlas = lightShadow);\n\t\t\t\t\tneedsCookieAtlas || (needsCookieAtlas = lightCookie);\n\n\t\t\t\t\tif (lightShadow || lightCookie) {\n\t\t\t\t\t\tlights.push(light);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (cookiesEnabled || shadowsEnabled) {\n\t\t\tprocessLights(spotLights);\n\t\t\tprocessLights(omniLights);\n\t\t}\n\n\t\tlights.sort((a, b) => {\n\t\t\treturn b.maxScreenSize - a.maxScreenSize;\n\t\t});\n\n\t\tif (needsShadowAtlas) {\n\t\t\tthis.allocateShadowAtlas(this.shadowAtlasResolution);\n\t\t}\n\n\t\tif (needsCookieAtlas) {\n\t\t\tthis.allocateCookieAtlas(this.cookieAtlasResolution);\n\t\t}\n\n\t\tif (needsShadowAtlas || needsCookieAtlas) {\n\t\t\tthis.subdivide(lights.length, lightingParams);\n\t\t}\n\n\t\treturn lights;\n\t}\n\n\tsetupSlot(light, rect) {\n\t\tlight.atlasViewport.copy(rect);\n\t\tconst faceCount = light.numShadowFaces;\n\n\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\tif (light.castShadows || light._cookie) {\n\t\t\t\t_viewport.copy(rect);\n\n\t\t\t\t_scissor.copy(rect);\n\n\t\t\t\tif (light._type === LIGHTTYPE_SPOT) {\n\t\t\t\t\t_viewport.add(this.scissorVec);\n\t\t\t\t}\n\n\t\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\t\tconst smallSize = _viewport.z / 3;\n\t\t\t\t\tconst offset = this.cubeSlotsOffsets[face];\n\t\t\t\t\t_viewport.x += smallSize * offset.x;\n\t\t\t\t\t_viewport.y += smallSize * offset.y;\n\t\t\t\t\t_viewport.z = smallSize;\n\t\t\t\t\t_viewport.w = smallSize;\n\n\t\t\t\t\t_scissor.copy(_viewport);\n\t\t\t\t}\n\n\t\t\t\tif (light.castShadows) {\n\t\t\t\t\tconst lightRenderData = light.getRenderData(null, face);\n\t\t\t\t\tlightRenderData.shadowViewport.copy(_viewport);\n\t\t\t\t\tlightRenderData.shadowScissor.copy(_scissor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tassignSlot(light, slotIndex, slotReassigned) {\n\t\tlight.atlasViewportAllocated = true;\n\t\tconst slot = this.slots[slotIndex];\n\t\tslot.lightId = light.id;\n\t\tslot.used = true;\n\n\t\tif (slotReassigned) {\n\t\t\tlight.atlasSlotUpdated = true;\n\t\t\tlight.atlasVersion = this.version;\n\t\t\tlight.atlasSlotIndex = slotIndex;\n\t\t}\n\t}\n\n\tupdate(spotLights, omniLights, lightingParams) {\n\t\tthis.shadowAtlasResolution = lightingParams.shadowAtlasResolution;\n\t\tthis.cookieAtlasResolution = lightingParams.cookieAtlasResolution;\n\t\tconst lights = this.collectLights(spotLights, omniLights, lightingParams);\n\n\t\tif (lights.length > 0) {\n\t\t\tconst slots = this.slots;\n\n\t\t\tfor (let i = 0; i < slots.length; i++) {\n\t\t\t\tslots[i].used = false;\n\t\t\t}\n\n\t\t\tconst assignCount = Math.min(lights.length, slots.length);\n\n\t\t\tfor (let i = 0; i < assignCount; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tif (light.castShadows) light._shadowMap = this.shadowAtlas;\n\t\t\t\tconst previousSlot = slots[light.atlasSlotIndex];\n\n\t\t\t\tif (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {\n\t\t\t\t\tconst _previousSlot = slots[light.atlasSlotIndex];\n\n\t\t\t\t\tif (_previousSlot.size === slots[i].size && !_previousSlot.used) {\n\t\t\t\t\t\tthis.assignSlot(light, light.atlasSlotIndex, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet usedCount = 0;\n\n\t\t\tfor (let i = 0; i < assignCount; i++) {\n\t\t\t\twhile (usedCount < slots.length && slots[usedCount].used) usedCount++;\n\n\t\t\t\tconst light = lights[i];\n\n\t\t\t\tif (!light.atlasViewportAllocated) {\n\t\t\t\t\tthis.assignSlot(light, usedCount, true);\n\t\t\t\t}\n\n\t\t\t\tconst slot = slots[light.atlasSlotIndex];\n\t\t\t\tthis.setupSlot(light, slot.rect);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateUniforms();\n\t}\n\n}\n\nclass ShadowMapCache {\n\tconstructor() {\n\t\tthis.shadowMapCache = new Map();\n\t}\n\n\tdestroy() {\n\t\tthis.clear();\n\t\tthis.shadowMapCache = null;\n\t}\n\n\tclear() {\n\t\tthis.shadowMapCache.forEach(shadowMaps => {\n\t\t\tshadowMaps.forEach(shadowMap => {\n\t\t\t\tshadowMap.destroy();\n\t\t\t});\n\t\t});\n\t\tthis.shadowMapCache.clear();\n\t}\n\n\tgetKey(light) {\n\t\tconst isCubeMap = light._type === LIGHTTYPE_OMNI;\n\t\tconst shadowType = light._shadowType;\n\t\tconst resolution = light._shadowResolution;\n\t\treturn `${isCubeMap}-${shadowType}-${resolution}`;\n\t}\n\n\tget(device, light) {\n\t\tconst key = this.getKey(light);\n\t\tconst shadowMaps = this.shadowMapCache.get(key);\n\n\t\tif (shadowMaps && shadowMaps.length) {\n\t\t\treturn shadowMaps.pop();\n\t\t}\n\n\t\tconst shadowMap = ShadowMap.create(device, light);\n\t\tshadowMap.cached = true;\n\t\treturn shadowMap;\n\t}\n\n\tadd(light, shadowMap) {\n\t\tconst key = this.getKey(light);\n\t\tconst shadowMaps = this.shadowMapCache.get(key);\n\n\t\tif (shadowMaps) {\n\t\t\tshadowMaps.push(shadowMap);\n\t\t} else {\n\t\t\tthis.shadowMapCache.set(key, [shadowMap]);\n\t\t}\n\t}\n\n}\n\nconst aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\nconst _depthRange = {\n\tmin: 0,\n\tmax: 0\n};\n\nfunction getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {\n\taabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;\n\taabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;\n\taabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;\n\taabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;\n\taabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;\n\taabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;\n\tlet minz = 9999999999;\n\tlet maxz = -9999999999;\n\n\tfor (let i = 0; i < 8; ++i) {\n\t\tcameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);\n\t\tconst z = aabbPoints[i].z;\n\t\tif (z < minz) minz = z;\n\t\tif (z > maxz) maxz = z;\n\t}\n\n\t_depthRange.min = minz;\n\t_depthRange.max = maxz;\n\treturn _depthRange;\n}\n\nfunction gauss(x, sigma) {\n\treturn Math.exp(-(x * x) / (2.0 * sigma * sigma));\n}\n\nconst maxBlurSize = 25;\n\nfunction gaussWeights(kernelSize) {\n\tif (kernelSize > maxBlurSize) {\n\t\tkernelSize = maxBlurSize;\n\t}\n\n\tconst sigma = (kernelSize - 1) / (2 * 3);\n\tconst halfWidth = (kernelSize - 1) * 0.5;\n\tconst values = new Array(kernelSize);\n\tlet sum = 0.0;\n\n\tfor (let i = 0; i < kernelSize; ++i) {\n\t\tvalues[i] = gauss(i - halfWidth, sigma);\n\t\tsum += values[i];\n\t}\n\n\tfor (let i = 0; i < kernelSize; ++i) {\n\t\tvalues[i] /= sum;\n\t}\n\n\treturn values;\n}\n\nconst visibleSceneAabb = new BoundingBox();\nconst shadowCamView = new Mat4();\nconst shadowCamViewProj = new Mat4();\nconst pixelOffset = new Float32Array(2);\nconst blurScissorRect = {\n\tx: 1,\n\ty: 1,\n\tz: 0,\n\tw: 0\n};\nconst opChanId = {\n\tr: 1,\n\tg: 2,\n\tb: 3,\n\ta: 4\n};\nconst center = new Vec3();\nconst viewportMatrix = new Mat4();\n\nfunction getDepthKey(meshInstance) {\n\tconst material = meshInstance.material;\n\tconst x = meshInstance.skinInstance ? 10 : 0;\n\tlet y = 0;\n\n\tif (material.opacityMap) {\n\t\tconst opChan = material.opacityMapChannel;\n\n\t\tif (opChan) {\n\t\t\ty = opChanId[opChan];\n\t\t}\n\t}\n\n\treturn x + y;\n}\n\nclass ShadowRenderer {\n\tconstructor(forwardRenderer, lightTextureAtlas) {\n\t\tthis.device = forwardRenderer.device;\n\t\tthis.forwardRenderer = forwardRenderer;\n\t\tthis.lightTextureAtlas = lightTextureAtlas;\n\t\tconst scope = this.device.scope;\n\t\tthis.polygonOffsetId = scope.resolve(\"polygonOffset\");\n\t\tthis.polygonOffset = new Float32Array(2);\n\t\tthis.sourceId = scope.resolve(\"source\");\n\t\tthis.pixelOffsetId = scope.resolve(\"pixelOffset\");\n\t\tthis.weightId = scope.resolve(\"weight[0]\");\n\t\tthis.blurVsmShaderCode = [shaderChunks.blurVSMPS, \"#define GAUSS\\n\" + shaderChunks.blurVSMPS];\n\t\tconst packed = \"#define PACKED\\n\";\n\t\tthis.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];\n\t\tthis.blurVsmShader = [{}, {}];\n\t\tthis.blurPackedVsmShader = [{}, {}];\n\t\tthis.blurVsmWeights = {};\n\t\tthis.shadowMapLightRadiusId = scope.resolve('light_radius');\n\t\tthis.shadowMapCache = new ShadowMapCache();\n\t}\n\n\tdestroy() {\n\t\tthis.shadowMapCache.destroy();\n\t\tthis.shadowMapCache = null;\n\t}\n\n\tstatic createShadowCamera(device, shadowType, type, face) {\n\t\tconst shadowCam = LightCamera.create(\"ShadowCamera\", type, face);\n\n\t\tif (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {\n\t\t\tshadowCam.clearColor = new Color(0, 0, 0, 0);\n\t\t} else {\n\t\t\tshadowCam.clearColor = new Color(1, 1, 1, 1);\n\t\t}\n\n\t\tshadowCam.clearDepthBuffer = true;\n\t\tshadowCam.clearStencilBuffer = false;\n\t\treturn shadowCam;\n\t}\n\n\tstatic setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {\n\t\tlet hwPcf = shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2;\n\n\t\tif (type === LIGHTTYPE_OMNI && !isClustered) {\n\t\t\thwPcf = false;\n\t\t}\n\n\t\tshadowCam.clearColorBuffer = !hwPcf;\n\t}\n\n\tcullShadowCasters(meshInstances, visible, camera) {\n\t\tlet count = 0;\n\t\tconst numInstances = meshInstances.length;\n\n\t\tfor (let i = 0; i < numInstances; i++) {\n\t\t\tconst meshInstance = meshInstances[i];\n\n\t\t\tif (!meshInstance.cull || meshInstance._isVisible(camera)) {\n\t\t\t\tmeshInstance.visibleThisFrame = true;\n\t\t\t\tvisible[count] = meshInstance;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\tvisible.length = count;\n\t\tvisible.sort(this.forwardRenderer.depthSortCompare);\n\t}\n\n\tcullLocal(light, drawCalls) {\n\t\tconst isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;\n\t\tlight.visibleThisFrame = true;\n\n\t\tif (!isClustered) {\n\t\t\tif (!light._shadowMap) {\n\t\t\t\tlight._shadowMap = ShadowMap.create(this.device, light);\n\t\t\t}\n\t\t}\n\n\t\tconst type = light._type;\n\t\tconst faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;\n\n\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\tconst lightRenderData = light.getRenderData(null, face);\n\t\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\t\tshadowCam.nearClip = light.attenuationEnd / 1000;\n\t\t\tshadowCam.farClip = light.attenuationEnd;\n\t\t\tconst shadowCamNode = shadowCam._node;\n\t\t\tconst lightNode = light._node;\n\t\t\tshadowCamNode.setPosition(lightNode.getPosition());\n\n\t\t\tif (type === LIGHTTYPE_SPOT) {\n\t\t\t\tshadowCam.fov = light._outerConeAngle * 2;\n\t\t\t\tshadowCamNode.setRotation(lightNode.getRotation());\n\t\t\t\tshadowCamNode.rotateLocal(-90, 0, 0);\n\t\t\t} else if (type === LIGHTTYPE_OMNI) {\n\t\t\t\tif (isClustered) {\n\t\t\t\t\tconst tileSize = this.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;\n\t\t\t\t\tconst texelSize = 2 / tileSize;\n\t\t\t\t\tconst filterSize = texelSize * this.lightTextureAtlas.shadowEdgePixels;\n\t\t\t\t\tshadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;\n\t\t\t\t} else {\n\t\t\t\t\tshadowCam.fov = 90;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.forwardRenderer.updateCameraFrustum(shadowCam);\n\t\t\tthis.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);\n\t\t}\n\t}\n\n\tgenerateSplitDistances(light, nearDist, farDist) {\n\t\tlight._shadowCascadeDistances.fill(farDist);\n\n\t\tfor (let i = 1; i < light.numCascades; i++) {\n\t\t\tconst fraction = i / light.numCascades;\n\t\t\tconst linearDist = nearDist + (farDist - nearDist) * fraction;\n\t\t\tconst logDist = nearDist * (farDist / nearDist) ** fraction;\n\t\t\tconst dist = math.lerp(linearDist, logDist, light.cascadeDistribution);\n\t\t\tlight._shadowCascadeDistances[i - 1] = dist;\n\t\t}\n\t}\n\n\tcullDirectional(light, drawCalls, camera) {\n\t\tlight.visibleThisFrame = true;\n\n\t\tif (!light._shadowMap) {\n\t\t\tlight._shadowMap = ShadowMap.create(this.device, light);\n\t\t}\n\n\t\tconst nearDist = camera._nearClip;\n\t\tthis.generateSplitDistances(light, nearDist, light.shadowDistance);\n\n\t\tfor (let cascade = 0; cascade < light.numCascades; cascade++) {\n\t\t\tconst lightRenderData = light.getRenderData(camera, cascade);\n\t\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\t\tshadowCam.renderTarget = light._shadowMap.renderTargets[0];\n\t\t\tlightRenderData.shadowViewport.copy(light.cascades[cascade]);\n\t\t\tlightRenderData.shadowScissor.copy(light.cascades[cascade]);\n\t\t\tconst shadowCamNode = shadowCam._node;\n\t\t\tconst lightNode = light._node;\n\t\t\tshadowCamNode.setPosition(lightNode.getPosition());\n\t\t\tshadowCamNode.setRotation(lightNode.getRotation());\n\t\t\tshadowCamNode.rotateLocal(-90, 0, 0);\n\t\t\tconst frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];\n\t\t\tconst frustumFarDist = light._shadowCascadeDistances[cascade];\n\t\t\tconst frustumPoints = Frustum.getPoints(camera, frustumNearDist, frustumFarDist);\n\t\t\tcenter.set(0, 0, 0);\n\t\t\tconst cameraWorldMat = camera.node.getWorldTransform();\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tcameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);\n\t\t\t\tcenter.add(frustumPoints[i]);\n\t\t\t}\n\n\t\t\tcenter.mulScalar(1 / 8);\n\t\t\tlet radius = 0;\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tconst dist = frustumPoints[i].sub(center).length();\n\t\t\t\tif (dist > radius) radius = dist;\n\t\t\t}\n\n\t\t\tconst right = shadowCamNode.right;\n\t\t\tconst up = shadowCamNode.up;\n\t\t\tconst lightDir = shadowCamNode.forward;\n\t\t\tconst sizeRatio = 0.25 * light._shadowResolution / radius;\n\t\t\tconst x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;\n\t\t\tconst y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;\n\t\t\tconst scaledUp = up.mulScalar(x);\n\t\t\tconst scaledRight = right.mulScalar(y);\n\t\t\tconst dot = center.dot(lightDir);\n\t\t\tconst scaledDir = lightDir.mulScalar(dot);\n\t\t\tcenter.add2(scaledUp, scaledRight).add(scaledDir);\n\t\t\tshadowCamNode.setPosition(center);\n\t\t\tshadowCamNode.translateLocal(0, 0, 1000000);\n\t\t\tshadowCam.nearClip = 0;\n\t\t\tshadowCam.farClip = 2000000;\n\t\t\tshadowCam.orthoHeight = radius;\n\t\t\tthis.forwardRenderer.updateCameraFrustum(shadowCam);\n\t\t\tthis.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);\n\t\t\tlet emptyAabb = true;\n\t\t\tconst visibleCasters = lightRenderData.visibleCasters;\n\n\t\t\tfor (let i = 0; i < visibleCasters.length; i++) {\n\t\t\t\tconst meshInstance = visibleCasters[i];\n\n\t\t\t\tif (emptyAabb) {\n\t\t\t\t\temptyAabb = false;\n\t\t\t\t\tvisibleSceneAabb.copy(meshInstance.aabb);\n\t\t\t\t} else {\n\t\t\t\t\tvisibleSceneAabb.add(meshInstance.aabb);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tshadowCamView.copy(shadowCamNode.getWorldTransform()).invert();\n\t\t\tconst depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());\n\t\t\tshadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);\n\t\t\tshadowCam.farClip = depthRange.max - depthRange.min + 0.2;\n\t\t}\n\t}\n\n\tsetupRenderState(device, light) {\n\t\tconst isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;\n\n\t\tif (device.webgl2) {\n\t\t\tif (light._type === LIGHTTYPE_OMNI && !isClustered) {\n\t\t\t\tdevice.setDepthBias(false);\n\t\t\t} else {\n\t\t\t\tdevice.setDepthBias(true);\n\t\t\t\tdevice.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);\n\t\t\t}\n\t\t} else if (device.extStandardDerivatives) {\n\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\tthis.polygonOffset[0] = 0;\n\t\t\t\tthis.polygonOffset[1] = 0;\n\t\t\t\tthis.polygonOffsetId.setValue(this.polygonOffset);\n\t\t\t} else {\n\t\t\t\tthis.polygonOffset[0] = light.shadowBias * -1000.0;\n\t\t\t\tthis.polygonOffset[1] = light.shadowBias * -1000.0;\n\t\t\t\tthis.polygonOffsetId.setValue(this.polygonOffset);\n\t\t\t}\n\t\t}\n\n\t\tdevice.setBlending(false);\n\t\tdevice.setDepthWrite(true);\n\t\tdevice.setDepthTest(true);\n\t\tdevice.setDepthFunc(FUNC_LESSEQUAL);\n\t\tconst useShadowSampler = isClustered ? light._isPcf && device.webgl2 : light._isPcf && device.webgl2 && light._type !== LIGHTTYPE_OMNI;\n\n\t\tif (useShadowSampler) {\n\t\t\tdevice.setColorWrite(false, false, false, false);\n\t\t} else {\n\t\t\tdevice.setColorWrite(true, true, true, true);\n\t\t}\n\t}\n\n\trestoreRenderState(device) {\n\t\tif (device.webgl2) {\n\t\t\tdevice.setDepthBias(false);\n\t\t} else if (device.extStandardDerivatives) {\n\t\t\tthis.polygonOffset[0] = 0;\n\t\t\tthis.polygonOffset[1] = 0;\n\t\t\tthis.polygonOffsetId.setValue(this.polygonOffset);\n\t\t}\n\t}\n\n\tdispatchUniforms(light, shadowCam, lightRenderData, face) {\n\t\tconst shadowCamNode = shadowCam._node;\n\n\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tthis.forwardRenderer.dispatchViewPos(shadowCamNode.getPosition());\n\t\t\tthis.shadowMapLightRadiusId.setValue(light.attenuationEnd);\n\t\t}\n\n\t\tshadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();\n\t\tshadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);\n\t\tconst rectViewport = lightRenderData.shadowViewport;\n\t\tshadowCam.rect = rectViewport;\n\t\tshadowCam.scissorRect = lightRenderData.shadowScissor;\n\t\tviewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);\n\t\tlightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);\n\n\t\tif (light._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\tlight._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);\n\t\t}\n\t}\n\n\tsubmitCasters(visibleCasters, light) {\n\t\tconst device = this.device;\n\t\tconst forwardRenderer = this.forwardRenderer;\n\t\tconst shadowPass = 1 << SHADER_SHADOW;\n\t\tconst shadowType = light._shadowType;\n\t\tconst smode = shadowType + light._type * SHADOW_COUNT;\n\t\tconst count = visibleCasters.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst meshInstance = visibleCasters[i];\n\t\t\tconst mesh = meshInstance.mesh;\n\t\t\tconst material = meshInstance.material;\n\t\t\tforwardRenderer.setBaseConstants(device, material);\n\t\t\tforwardRenderer.setSkinning(device, meshInstance, material);\n\n\t\t\tif (material.dirty) {\n\t\t\t\tmaterial.updateUniforms(device, forwardRenderer.scene);\n\t\t\t\tmaterial.dirty = false;\n\t\t\t}\n\n\t\t\tif (material.chunks) {\n\t\t\t\tforwardRenderer.setCullMode(true, false, meshInstance);\n\t\t\t\tmaterial.setParameters(device);\n\t\t\t\tmeshInstance.setParameters(device, shadowPass);\n\t\t\t}\n\n\t\t\tlet shadowShader = meshInstance._shader[SHADER_SHADOW + smode];\n\n\t\t\tif (!shadowShader) {\n\t\t\t\tforwardRenderer.updateShader(meshInstance, meshInstance._shaderDefs, null, SHADER_SHADOW + smode);\n\t\t\t\tshadowShader = meshInstance._shader[SHADER_SHADOW + smode];\n\t\t\t\tmeshInstance._key[SORTKEY_DEPTH] = getDepthKey(meshInstance);\n\t\t\t}\n\n\t\t\tdevice.setShader(shadowShader);\n\t\t\tforwardRenderer.setVertexBuffers(device, mesh);\n\t\t\tforwardRenderer.setMorphing(device, meshInstance.morphInstance);\n\t\t\tconst style = meshInstance.renderStyle;\n\t\t\tdevice.setIndexBuffer(mesh.indexBuffer[style]);\n\t\t\ti += forwardRenderer.drawInstance(device, meshInstance, mesh, style);\n\t\t\tforwardRenderer._shadowDrawCalls++;\n\t\t}\n\t}\n\n\trender(light, camera) {\n\t\tif (light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame) {\n\t\t\tconst device = this.device;\n\n\t\t\tif (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {\n\t\t\t\tlight.shadowUpdateMode = SHADOWUPDATE_NONE;\n\t\t\t}\n\n\t\t\tconst type = light._type;\n\t\t\tconst shadowType = light._shadowType;\n\t\t\tconst faceCount = light.numShadowFaces;\n\t\t\tconst forwardRenderer = this.forwardRenderer;\n\t\t\tforwardRenderer._shadowMapUpdates += faceCount;\n\t\t\tconst isClustered = forwardRenderer.scene.clusteredLightingEnabled;\n\t\t\tthis.setupRenderState(device, light);\n\n\t\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\t\tconst lightRenderData = light.getRenderData(type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);\n\t\t\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\t\t\tShadowRenderer.setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered);\n\t\t\t\tconst renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;\n\t\t\t\tshadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];\n\t\t\t\tthis.dispatchUniforms(light, shadowCam, lightRenderData, face);\n\t\t\t\tforwardRenderer.setCamera(shadowCam, shadowCam.renderTarget, true);\n\t\t\t\tthis.submitCasters(lightRenderData.visibleCasters, light);\n\t\t\t}\n\n\t\t\tif (light._isVsm && light._vsmBlurSize > 1) {\n\t\t\t\tconst _isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;\n\n\t\t\t\tif (!_isClustered || type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tthis.applyVsmBlur(light, camera);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.restoreRenderState(device);\n\t\t}\n\t}\n\n\tgetVsmBlurShader(isVsm8, blurMode, filterSize) {\n\t\tlet blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];\n\n\t\tif (!blurShader) {\n\t\t\tthis.blurVsmWeights[filterSize] = gaussWeights(filterSize);\n\t\t\tconst blurVS = shaderChunks.fullscreenQuadVS;\n\t\t\tlet blurFS = \"#define SAMPLES \" + filterSize + \"\\n\";\n\n\t\t\tif (isVsm8) {\n\t\t\t\tblurFS += this.blurPackedVsmShaderCode[blurMode];\n\t\t\t} else {\n\t\t\t\tblurFS += this.blurVsmShaderCode[blurMode];\n\t\t\t}\n\n\t\t\tconst blurShaderName = \"blurVsm\" + blurMode + \"\" + filterSize + \"\" + isVsm8;\n\t\t\tblurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);\n\n\t\t\tif (isVsm8) {\n\t\t\t\tthis.blurPackedVsmShader[blurMode][filterSize] = blurShader;\n\t\t\t} else {\n\t\t\t\tthis.blurVsmShader[blurMode][filterSize] = blurShader;\n\t\t\t}\n\t\t}\n\n\t\treturn blurShader;\n\t}\n\n\tapplyVsmBlur(light, camera) {\n\t\tconst device = this.device;\n\t\tconst lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);\n\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\tconst origShadowMap = shadowCam.renderTarget;\n\t\tconst tempShadowMap = this.shadowMapCache.get(device, light);\n\t\tconst tempRt = tempShadowMap.renderTargets[0];\n\t\tconst isVsm8 = light._shadowType === SHADOW_VSM8;\n\t\tconst blurMode = light.vsmBlurMode;\n\t\tconst filterSize = light._vsmBlurSize;\n\t\tconst blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);\n\t\tblurScissorRect.z = light._shadowResolution - 2;\n\t\tblurScissorRect.w = blurScissorRect.z;\n\t\tthis.sourceId.setValue(origShadowMap.colorBuffer);\n\t\tpixelOffset[0] = 1 / light._shadowResolution;\n\t\tpixelOffset[1] = 0;\n\t\tthis.pixelOffsetId.setValue(pixelOffset);\n\t\tif (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);\n\t\tdrawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);\n\t\tthis.sourceId.setValue(tempRt.colorBuffer);\n\t\tpixelOffset[1] = pixelOffset[0];\n\t\tpixelOffset[0] = 0;\n\t\tthis.pixelOffsetId.setValue(pixelOffset);\n\t\tdrawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);\n\t\tthis.shadowMapCache.add(light, tempShadowMap);\n\t}\n\n}\n\nconst tempSphere$2 = new BoundingSphere();\n\nclass StaticMeshes {\n\tstatic lightCompare(lightA, lightB) {\n\t\treturn lightA.key - lightB.key;\n\t}\n\n\tstatic prepare(device, scene, meshInstances, lights) {\n\t\tconst drawCalls = meshInstances;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tconst newDrawCalls = [];\n\t\tconst minVec = new Vec3();\n\t\tconst maxVec = new Vec3();\n\t\tconst localLightBounds = new BoundingBox();\n\t\tconst invMatrix = new Mat4();\n\t\tconst triLightComb = [];\n\t\tconst lightAabb = [];\n\t\tconst triBounds = [];\n\t\tconst staticLights = [];\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\n\t\t\tif (!drawCall.isStatic) {\n\t\t\t\tnewDrawCalls.push(drawCall);\n\t\t\t} else {\n\t\t\t\tconst aabb = drawCall.aabb;\n\t\t\t\tstaticLights.length = 0;\n\n\t\t\t\tfor (let lightTypePass = LIGHTTYPE_OMNI; lightTypePass <= LIGHTTYPE_SPOT; lightTypePass++) {\n\t\t\t\t\tfor (let j = 0; j < lights.length; j++) {\n\t\t\t\t\t\tconst light = lights[j];\n\t\t\t\t\t\tif (light._type !== lightTypePass) continue;\n\n\t\t\t\t\t\tif (light.enabled) {\n\t\t\t\t\t\t\tif (light.mask & drawCall.mask) {\n\t\t\t\t\t\t\t\tif (light.isStatic) {\n\t\t\t\t\t\t\t\t\tif (!lightAabb[j]) {\n\t\t\t\t\t\t\t\t\t\tlightAabb[j] = new BoundingBox();\n\n\t\t\t\t\t\t\t\t\t\tlight._node.getWorldTransform();\n\n\t\t\t\t\t\t\t\t\t\tlight.getBoundingSphere(tempSphere$2);\n\t\t\t\t\t\t\t\t\t\tlightAabb[j].center.copy(tempSphere$2.center);\n\t\t\t\t\t\t\t\t\t\tlightAabb[j].halfExtents.set(tempSphere$2.radius, tempSphere$2.radius, tempSphere$2.radius);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (!lightAabb[j].intersects(aabb)) continue;\n\t\t\t\t\t\t\t\t\tstaticLights.push(j);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (staticLights.length === 0) {\n\t\t\t\t\tnewDrawCalls.push(drawCall);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst mesh = drawCall.mesh;\n\t\t\t\tconst vertexBuffer = mesh.vertexBuffer;\n\t\t\t\tconst indexBuffer = mesh.indexBuffer[drawCall.renderStyle];\n\t\t\t\tconst indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());\n\t\t\t\tconst numTris = mesh.primitive[drawCall.renderStyle].count / 3;\n\t\t\t\tconst baseIndex = mesh.primitive[drawCall.renderStyle].base;\n\t\t\t\tconst elems = vertexBuffer.format.elements;\n\t\t\t\tconst vertSize = vertexBuffer.format.size / 4;\n\t\t\t\tconst verts = new Float32Array(vertexBuffer.storage);\n\t\t\t\tlet offsetP;\n\n\t\t\t\tfor (let k = 0; k < elems.length; k++) {\n\t\t\t\t\tif (elems[k].name === SEMANTIC_POSITION) {\n\t\t\t\t\t\toffsetP = elems[k].offset / 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttriLightComb.length = numTris;\n\n\t\t\t\tfor (let k = 0; k < numTris; k++) {\n\t\t\t\t\ttriLightComb[k] = 0;\n\t\t\t\t}\n\n\t\t\t\tlet triLightCombUsed = false;\n\t\t\t\ttriBounds.length = numTris * 6;\n\n\t\t\t\tfor (let k = 0; k < numTris; k++) {\n\t\t\t\t\tlet minx = Number.MAX_VALUE;\n\t\t\t\t\tlet miny = Number.MAX_VALUE;\n\t\t\t\t\tlet minz = Number.MAX_VALUE;\n\t\t\t\t\tlet maxx = -Number.MAX_VALUE;\n\t\t\t\t\tlet maxy = -Number.MAX_VALUE;\n\t\t\t\t\tlet maxz = -Number.MAX_VALUE;\n\n\t\t\t\t\tfor (let v = 0; v < 3; v++) {\n\t\t\t\t\t\tlet _index = indices[k * 3 + v + baseIndex];\n\t\t\t\t\t\t_index = _index * vertSize + offsetP;\n\t\t\t\t\t\tconst _x = verts[_index];\n\t\t\t\t\t\tconst _y = verts[_index + 1];\n\t\t\t\t\t\tconst _z = verts[_index + 2];\n\t\t\t\t\t\tif (_x < minx) minx = _x;\n\t\t\t\t\t\tif (_y < miny) miny = _y;\n\t\t\t\t\t\tif (_z < minz) minz = _z;\n\t\t\t\t\t\tif (_x > maxx) maxx = _x;\n\t\t\t\t\t\tif (_y > maxy) maxy = _y;\n\t\t\t\t\t\tif (_z > maxz) maxz = _z;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst index = k * 6;\n\t\t\t\t\ttriBounds[index] = minx;\n\t\t\t\t\ttriBounds[index + 1] = miny;\n\t\t\t\t\ttriBounds[index + 2] = minz;\n\t\t\t\t\ttriBounds[index + 3] = maxx;\n\t\t\t\t\ttriBounds[index + 4] = maxy;\n\t\t\t\t\ttriBounds[index + 5] = maxz;\n\t\t\t\t}\n\n\t\t\t\tfor (let s = 0; s < staticLights.length; s++) {\n\t\t\t\t\tconst j = staticLights[s];\n\t\t\t\t\tinvMatrix.copy(drawCall.node.worldTransform).invert();\n\t\t\t\t\tlocalLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);\n\t\t\t\t\tconst minv = localLightBounds.getMin();\n\t\t\t\t\tconst maxv = localLightBounds.getMax();\n\t\t\t\t\tconst bit = 1 << s;\n\n\t\t\t\t\tfor (let k = 0; k < numTris; k++) {\n\t\t\t\t\t\tconst index = k * 6;\n\n\t\t\t\t\t\tif (triBounds[index] <= maxv.x && triBounds[index + 3] >= minv.x && triBounds[index + 1] <= maxv.y && triBounds[index + 4] >= minv.y && triBounds[index + 2] <= maxv.z && triBounds[index + 5] >= minv.z) {\n\t\t\t\t\t\t\ttriLightComb[k] |= bit;\n\t\t\t\t\t\t\ttriLightCombUsed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (triLightCombUsed) {\n\t\t\t\t\tconst combIndices = {};\n\n\t\t\t\t\tfor (let k = 0; k < numTris; k++) {\n\t\t\t\t\t\tconst j = k * 3 + baseIndex;\n\t\t\t\t\t\tconst combIbName = triLightComb[k];\n\t\t\t\t\t\tif (!combIndices[combIbName]) combIndices[combIbName] = [];\n\t\t\t\t\t\tconst combIb = combIndices[combIbName];\n\t\t\t\t\t\tcombIb.push(indices[j]);\n\t\t\t\t\t\tcombIb.push(indices[j + 1]);\n\t\t\t\t\t\tcombIb.push(indices[j + 2]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const combIbName in combIndices) {\n\t\t\t\t\t\tconst combIb = combIndices[combIbName];\n\t\t\t\t\t\tconst ib = new IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);\n\t\t\t\t\t\tconst ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());\n\t\t\t\t\t\tib2.set(combIb);\n\t\t\t\t\t\tib.unlock();\n\t\t\t\t\t\tlet minx = Number.MAX_VALUE;\n\t\t\t\t\t\tlet miny = Number.MAX_VALUE;\n\t\t\t\t\t\tlet minz = Number.MAX_VALUE;\n\t\t\t\t\t\tlet maxx = -Number.MAX_VALUE;\n\t\t\t\t\t\tlet maxy = -Number.MAX_VALUE;\n\t\t\t\t\t\tlet maxz = -Number.MAX_VALUE;\n\n\t\t\t\t\t\tfor (let k = 0; k < combIb.length; k++) {\n\t\t\t\t\t\t\tconst index = combIb[k];\n\t\t\t\t\t\t\tconst _x = verts[index * vertSize + offsetP];\n\t\t\t\t\t\t\tconst _y = verts[index * vertSize + offsetP + 1];\n\t\t\t\t\t\t\tconst _z = verts[index * vertSize + offsetP + 2];\n\t\t\t\t\t\t\tif (_x < minx) minx = _x;\n\t\t\t\t\t\t\tif (_y < miny) miny = _y;\n\t\t\t\t\t\t\tif (_z < minz) minz = _z;\n\t\t\t\t\t\t\tif (_x > maxx) maxx = _x;\n\t\t\t\t\t\t\tif (_y > maxy) maxy = _y;\n\t\t\t\t\t\t\tif (_z > maxz) maxz = _z;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tminVec.set(minx, miny, minz);\n\t\t\t\t\t\tmaxVec.set(maxx, maxy, maxz);\n\t\t\t\t\t\tconst chunkAabb = new BoundingBox();\n\t\t\t\t\t\tchunkAabb.setMinMax(minVec, maxVec);\n\t\t\t\t\t\tconst mesh2 = new Mesh(device);\n\t\t\t\t\t\tmesh2.vertexBuffer = vertexBuffer;\n\t\t\t\t\t\tmesh2.indexBuffer[0] = ib;\n\t\t\t\t\t\tmesh2.primitive[0].type = PRIMITIVE_TRIANGLES;\n\t\t\t\t\t\tmesh2.primitive[0].base = 0;\n\t\t\t\t\t\tmesh2.primitive[0].count = combIb.length;\n\t\t\t\t\t\tmesh2.primitive[0].indexed = true;\n\t\t\t\t\t\tmesh2.aabb = chunkAabb;\n\t\t\t\t\t\tconst instance = new MeshInstance(mesh2, drawCall.material, drawCall.node);\n\t\t\t\t\t\tinstance.isStatic = drawCall.isStatic;\n\t\t\t\t\t\tinstance.visible = drawCall.visible;\n\t\t\t\t\t\tinstance.layer = drawCall.layer;\n\t\t\t\t\t\tinstance.castShadow = drawCall.castShadow;\n\t\t\t\t\t\tinstance._receiveShadow = drawCall._receiveShadow;\n\t\t\t\t\t\tinstance.cull = drawCall.cull;\n\t\t\t\t\t\tinstance.pick = drawCall.pick;\n\t\t\t\t\t\tinstance.mask = drawCall.mask;\n\t\t\t\t\t\tinstance.parameters = drawCall.parameters;\n\t\t\t\t\t\tinstance._shaderDefs = drawCall._shaderDefs;\n\t\t\t\t\t\tinstance._staticSource = drawCall;\n\n\t\t\t\t\t\tif (drawCall._staticLightList) {\n\t\t\t\t\t\t\tinstance._staticLightList = drawCall._staticLightList;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinstance._staticLightList = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let k = 0; k < staticLights.length; k++) {\n\t\t\t\t\t\t\tconst bit = 1 << k;\n\n\t\t\t\t\t\t\tif (combIbName & bit) {\n\t\t\t\t\t\t\t\tconst lht = lights[staticLights[k]];\n\n\t\t\t\t\t\t\t\tif (instance._staticLightList.indexOf(lht) < 0) {\n\t\t\t\t\t\t\t\t\tinstance._staticLightList.push(lht);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinstance._staticLightList.sort(StaticMeshes.lightCompare);\n\n\t\t\t\t\t\tnewDrawCalls.push(instance);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewDrawCalls.push(drawCall);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmeshInstances.length = newDrawCalls.length;\n\n\t\tfor (let i = 0; i < newDrawCalls.length; i++) {\n\t\t\tmeshInstances[i] = newDrawCalls[i];\n\t\t}\n\t}\n\n\tstatic revert(meshInstances) {\n\t\tconst drawCalls = meshInstances;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tconst newDrawCalls = [];\n\t\tlet prevStaticSource;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\n\t\t\tif (drawCall._staticSource) {\n\t\t\t\tif (drawCall._staticSource !== prevStaticSource) {\n\t\t\t\t\tnewDrawCalls.push(drawCall._staticSource);\n\t\t\t\t\tprevStaticSource = drawCall._staticSource;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewDrawCalls.push(drawCall);\n\t\t\t}\n\t\t}\n\n\t\tmeshInstances.length = newDrawCalls.length;\n\n\t\tfor (let i = 0; i < newDrawCalls.length; i++) {\n\t\t\tmeshInstances[i] = newDrawCalls[i];\n\t\t}\n\t}\n\n}\n\nnew Vec3(1, 1, 1);\nnew Vec3(40, 0, 0);\n\nconst viewInvMat = new Mat4();\nconst viewMat = new Mat4();\nconst viewMat3 = new Mat3();\nconst viewProjMat = new Mat4();\nlet projMat;\nconst flipYMat = new Mat4().setScale(1, -1, 1);\nconst flippedViewProjMat = new Mat4();\nconst flippedSkyboxProjMat = new Mat4();\nconst viewInvL = new Mat4();\nconst viewInvR = new Mat4();\nconst viewL = new Mat4();\nconst viewR = new Mat4();\nconst viewPosL = new Vec3();\nconst viewPosR = new Vec3();\nlet projL, projR;\nconst viewMat3L = new Mat3();\nconst viewMat3R = new Mat3();\nconst viewProjMatL = new Mat4();\nconst viewProjMatR = new Mat4();\nconst worldMatX = new Vec3();\nconst worldMatY = new Vec3();\nconst worldMatZ = new Vec3();\nconst tempSphere$1 = new BoundingSphere();\nconst boneTextureSize = [0, 0, 0, 0];\nlet boneTexture, instancingData, modelMatrix, normalMatrix;\nlet keyA$1, keyB$1;\nlet _autoInstanceBuffer = null;\nlet _skinUpdateIndex = 0;\nconst _drawCallList = {\n\tdrawCalls: [],\n\tisNewMaterial: [],\n\tlightMaskChanged: []\n};\n\nconst _tempMaterialSet = new Set();\n\nclass ForwardRenderer {\n\tconstructor(graphicsDevice) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.scene = null;\n\t\tthis._shadowDrawCalls = 0;\n\t\tthis._forwardDrawCalls = 0;\n\t\tthis._skinDrawCalls = 0;\n\t\tthis._numDrawCallsCulled = 0;\n\t\tthis._instancedDrawCalls = 0;\n\t\tthis._camerasRendered = 0;\n\t\tthis._materialSwitches = 0;\n\t\tthis._shadowMapUpdates = 0;\n\t\tthis._shadowMapTime = 0;\n\t\tthis._depthMapTime = 0;\n\t\tthis._forwardTime = 0;\n\t\tthis._cullTime = 0;\n\t\tthis._sortTime = 0;\n\t\tthis._skinTime = 0;\n\t\tthis._morphTime = 0;\n\t\tthis._instancingTime = 0;\n\t\tthis._removedByInstancing = 0;\n\t\tthis._layerCompositionUpdateTime = 0;\n\t\tthis._lightClustersTime = 0;\n\t\tthis._lightClusters = 0;\n\t\tconst device = this.device;\n\t\tconst library = device.getProgramLibrary();\n\t\tthis.library = library;\n\t\tthis.lightTextureAtlas = new LightTextureAtlas(device);\n\t\tthis._shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);\n\t\tthis._cookieRenderer = new CookieRenderer(device, this.lightTextureAtlas);\n\t\tconst scope = device.scope;\n\t\tthis.projId = scope.resolve('matrix_projection');\n\t\tthis.projSkyboxId = scope.resolve('matrix_projectionSkybox');\n\t\tthis.viewId = scope.resolve('matrix_view');\n\t\tthis.viewId3 = scope.resolve('matrix_view3');\n\t\tthis.viewInvId = scope.resolve('matrix_viewInverse');\n\t\tthis.viewProjId = scope.resolve('matrix_viewProjection');\n\t\tthis.viewPos = new Float32Array(3);\n\t\tthis.viewPosId = scope.resolve('view_position');\n\t\tthis.nearClipId = scope.resolve('camera_near');\n\t\tthis.farClipId = scope.resolve('camera_far');\n\t\tthis.cameraParamsId = scope.resolve('camera_params');\n\t\tthis.tbnBasis = scope.resolve('tbnBasis');\n\t\tthis.fogColorId = scope.resolve('fog_color');\n\t\tthis.fogStartId = scope.resolve('fog_start');\n\t\tthis.fogEndId = scope.resolve('fog_end');\n\t\tthis.fogDensityId = scope.resolve('fog_density');\n\t\tthis.modelMatrixId = scope.resolve('matrix_model');\n\t\tthis.normalMatrixId = scope.resolve('matrix_normal');\n\t\tthis.poseMatrixId = scope.resolve('matrix_pose[0]');\n\t\tthis.boneTextureId = scope.resolve('texture_poseMap');\n\t\tthis.boneTextureSizeId = scope.resolve('texture_poseMapSize');\n\t\tthis.morphWeightsA = scope.resolve('morph_weights_a');\n\t\tthis.morphWeightsB = scope.resolve('morph_weights_b');\n\t\tthis.morphPositionTex = scope.resolve('morphPositionTex');\n\t\tthis.morphNormalTex = scope.resolve('morphNormalTex');\n\t\tthis.morphTexParams = scope.resolve('morph_tex_params');\n\t\tthis.alphaTestId = scope.resolve('alpha_ref');\n\t\tthis.opacityMapId = scope.resolve('texture_opacityMap');\n\t\tthis.ambientId = scope.resolve(\"light_globalAmbient\");\n\t\tthis.exposureId = scope.resolve(\"exposure\");\n\t\tthis.skyboxIntensityId = scope.resolve(\"skyboxIntensity\");\n\t\tthis.lightColorId = [];\n\t\tthis.lightDir = [];\n\t\tthis.lightDirId = [];\n\t\tthis.lightShadowMapId = [];\n\t\tthis.lightShadowMatrixId = [];\n\t\tthis.lightShadowParamsId = [];\n\t\tthis.lightRadiusId = [];\n\t\tthis.lightPos = [];\n\t\tthis.lightPosId = [];\n\t\tthis.lightWidth = [];\n\t\tthis.lightWidthId = [];\n\t\tthis.lightHeight = [];\n\t\tthis.lightHeightId = [];\n\t\tthis.lightInAngleId = [];\n\t\tthis.lightOutAngleId = [];\n\t\tthis.lightCookieId = [];\n\t\tthis.lightCookieIntId = [];\n\t\tthis.lightCookieMatrixId = [];\n\t\tthis.lightCookieOffsetId = [];\n\t\tthis.shadowMatrixPaletteId = [];\n\t\tthis.shadowCascadeDistancesId = [];\n\t\tthis.shadowCascadeCountId = [];\n\t\tthis.depthMapId = scope.resolve('uDepthMap');\n\t\tthis.screenSizeId = scope.resolve('uScreenSize');\n\t\tthis._screenSize = new Float32Array(4);\n\t\tthis.twoSidedLightingNegScaleFactorId = scope.resolve(\"twoSidedLightingNegScaleFactor\");\n\t\tthis.fogColor = new Float32Array(3);\n\t\tthis.ambientColor = new Float32Array(3);\n\t\tthis.cameraParams = new Float32Array(4);\n\t}\n\n\tdestroy() {\n\t\tthis._shadowRenderer.destroy();\n\n\t\tthis._shadowRenderer = null;\n\n\t\tthis._cookieRenderer.destroy();\n\n\t\tthis._cookieRenderer = null;\n\t\tthis.lightTextureAtlas.destroy();\n\t\tthis.lightTextureAtlas = null;\n\t}\n\n\tsortCompare(drawCallA, drawCallB) {\n\t\tif (drawCallA.layer === drawCallB.layer) {\n\t\t\tif (drawCallA.drawOrder && drawCallB.drawOrder) {\n\t\t\t\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n\t\t\t} else if (drawCallA.zdist && drawCallB.zdist) {\n\t\t\t\treturn drawCallB.zdist - drawCallA.zdist;\n\t\t\t} else if (drawCallA.zdist2 && drawCallB.zdist2) {\n\t\t\t\treturn drawCallA.zdist2 - drawCallB.zdist2;\n\t\t\t}\n\t\t}\n\n\t\treturn drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];\n\t}\n\n\tsortCompareMesh(drawCallA, drawCallB) {\n\t\tif (drawCallA.layer === drawCallB.layer) {\n\t\t\tif (drawCallA.drawOrder && drawCallB.drawOrder) {\n\t\t\t\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n\t\t\t} else if (drawCallA.zdist && drawCallB.zdist) {\n\t\t\t\treturn drawCallB.zdist - drawCallA.zdist;\n\t\t\t}\n\t\t}\n\n\t\tkeyA$1 = drawCallA._key[SORTKEY_FORWARD];\n\t\tkeyB$1 = drawCallB._key[SORTKEY_FORWARD];\n\n\t\tif (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {\n\t\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t\t}\n\n\t\treturn keyB$1 - keyA$1;\n\t}\n\n\tdepthSortCompare(drawCallA, drawCallB) {\n\t\tkeyA$1 = drawCallA._key[SORTKEY_DEPTH];\n\t\tkeyB$1 = drawCallB._key[SORTKEY_DEPTH];\n\n\t\tif (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {\n\t\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t\t}\n\n\t\treturn keyB$1 - keyA$1;\n\t}\n\n\tupdateCameraFrustum(camera) {\n\t\tif (camera.vrDisplay && camera.vrDisplay.presenting) {\n\t\t\tprojMat = camera.vrDisplay.combinedProj;\n\t\t\tconst parent = camera._node.parent;\n\n\t\t\tif (parent) {\n\t\t\t\tviewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();\n\t\t\t} else {\n\t\t\t\tviewMat.copy(camera.vrDisplay.combinedView);\n\t\t\t}\n\n\t\t\tviewInvMat.copy(viewMat).invert();\n\t\t\tthis.viewInvId.setValue(viewInvMat.data);\n\t\t\tviewProjMat.mul2(projMat, viewMat);\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t} else if (camera.xr && camera.xr.views.length) {\n\t\t\tconst view = camera.xr.views[0];\n\t\t\tviewProjMat.mul2(view.projMat, view.viewOffMat);\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t\treturn;\n\t\t}\n\n\t\tprojMat = camera.projectionMatrix;\n\n\t\tif (camera.calculateProjection) {\n\t\t\tcamera.calculateProjection(projMat, VIEW_CENTER);\n\t\t}\n\n\t\tif (camera.calculateTransform) {\n\t\t\tcamera.calculateTransform(viewInvMat, VIEW_CENTER);\n\t\t} else {\n\t\t\tconst pos = camera._node.getPosition();\n\n\t\t\tconst rot = camera._node.getRotation();\n\n\t\t\tviewInvMat.setTRS(pos, rot, Vec3.ONE);\n\t\t\tthis.viewInvId.setValue(viewInvMat.data);\n\t\t}\n\n\t\tviewMat.copy(viewInvMat).invert();\n\t\tviewProjMat.mul2(projMat, viewMat);\n\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t}\n\n\tsetCamera(camera, target, clear) {\n\t\tconst vrDisplay = camera.vrDisplay;\n\t\tlet transform;\n\n\t\tif (vrDisplay && vrDisplay.presenting) {\n\t\t\tprojL = vrDisplay.leftProj;\n\t\t\tprojR = vrDisplay.rightProj;\n\t\t\tprojMat = vrDisplay.combinedProj;\n\n\t\t\tif (camera.calculateProjection) {\n\t\t\t\tcamera.calculateProjection(projL, VIEW_LEFT);\n\t\t\t\tcamera.calculateProjection(projR, VIEW_RIGHT);\n\t\t\t\tcamera.calculateProjection(projMat, VIEW_CENTER);\n\t\t\t}\n\n\t\t\tif (camera.calculateTransform) {\n\t\t\t\tcamera.calculateTransform(viewInvL, VIEW_LEFT);\n\t\t\t\tcamera.calculateTransform(viewInvR, VIEW_RIGHT);\n\t\t\t\tcamera.calculateTransform(viewInvMat, VIEW_CENTER);\n\t\t\t\tviewL.copy(viewInvL).invert();\n\t\t\t\tviewR.copy(viewInvR).invert();\n\t\t\t\tviewMat.copy(viewInvMat).invert();\n\t\t\t} else {\n\t\t\t\tconst parent = camera._node.parent;\n\n\t\t\t\tif (parent) {\n\t\t\t\t\ttransform = parent.getWorldTransform();\n\t\t\t\t\tviewInvL.mul2(transform, vrDisplay.leftViewInv);\n\t\t\t\t\tviewInvR.mul2(transform, vrDisplay.rightViewInv);\n\t\t\t\t\tviewL.copy(viewInvL).invert();\n\t\t\t\t\tviewR.copy(viewInvR).invert();\n\t\t\t\t\tviewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();\n\t\t\t\t} else {\n\t\t\t\t\tviewInvL.copy(vrDisplay.leftViewInv);\n\t\t\t\t\tviewInvR.copy(vrDisplay.rightViewInv);\n\t\t\t\t\tviewL.copy(vrDisplay.leftView);\n\t\t\t\t\tviewR.copy(vrDisplay.rightView);\n\t\t\t\t\tviewMat.copy(vrDisplay.combinedView);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tviewMat3L.setFromMat4(viewL);\n\t\t\tviewMat3R.setFromMat4(viewR);\n\t\t\tviewProjMatL.mul2(projL, viewL);\n\t\t\tviewProjMatR.mul2(projR, viewR);\n\t\t\tviewPosL.x = viewInvL.data[12];\n\t\t\tviewPosL.y = viewInvL.data[13];\n\t\t\tviewPosL.z = viewInvL.data[14];\n\t\t\tviewPosR.x = viewInvR.data[12];\n\t\t\tviewPosR.y = viewInvR.data[13];\n\t\t\tviewPosR.z = viewInvR.data[14];\n\t\t\tviewProjMat.mul2(projMat, viewMat);\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t} else if (camera.xr && camera.xr.session) {\n\t\t\tconst parent = camera._node.parent;\n\t\t\tif (parent) transform = parent.getWorldTransform();\n\t\t\tconst views = camera.xr.views;\n\n\t\t\tfor (let v = 0; v < views.length; v++) {\n\t\t\t\tconst view = views[v];\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tview.viewInvOffMat.mul2(transform, view.viewInvMat);\n\t\t\t\t\tview.viewOffMat.copy(view.viewInvOffMat).invert();\n\t\t\t\t} else {\n\t\t\t\t\tview.viewInvOffMat.copy(view.viewInvMat);\n\t\t\t\t\tview.viewOffMat.copy(view.viewMat);\n\t\t\t\t}\n\n\t\t\t\tview.viewMat3.setFromMat4(view.viewOffMat);\n\t\t\t\tview.projViewOffMat.mul2(view.projMat, view.viewOffMat);\n\t\t\t\tview.position[0] = view.viewInvOffMat.data[12];\n\t\t\t\tview.position[1] = view.viewInvOffMat.data[13];\n\t\t\t\tview.position[2] = view.viewInvOffMat.data[14];\n\t\t\t\tcamera.frustum.setFromMat4(view.projViewOffMat);\n\t\t\t}\n\t\t} else {\n\t\t\tprojMat = camera.projectionMatrix;\n\n\t\t\tif (camera.calculateProjection) {\n\t\t\t\tcamera.calculateProjection(projMat, VIEW_CENTER);\n\t\t\t}\n\n\t\t\tthis.projId.setValue(projMat.data);\n\t\t\tthis.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);\n\n\t\t\tif (camera.calculateTransform) {\n\t\t\t\tcamera.calculateTransform(viewInvMat, VIEW_CENTER);\n\t\t\t} else {\n\t\t\t\tconst pos = camera._node.getPosition();\n\n\t\t\t\tconst rot = camera._node.getRotation();\n\n\t\t\t\tviewInvMat.setTRS(pos, rot, Vec3.ONE);\n\t\t\t}\n\n\t\t\tthis.viewInvId.setValue(viewInvMat.data);\n\t\t\tviewMat.copy(viewInvMat).invert();\n\t\t\tthis.viewId.setValue(viewMat.data);\n\t\t\tviewMat3.setFromMat4(viewMat);\n\t\t\tthis.viewId3.setValue(viewMat3.data);\n\t\t\tviewProjMat.mul2(projMat, viewMat);\n\n\t\t\tif (target && target.flipY) {\n\t\t\t\tflippedViewProjMat.mul2(flipYMat, viewProjMat);\n\t\t\t\tflippedSkyboxProjMat.mul2(flipYMat, camera.getProjectionMatrixSkybox());\n\t\t\t\tthis.viewProjId.setValue(flippedViewProjMat.data);\n\t\t\t\tthis.projSkyboxId.setValue(flippedSkyboxProjMat.data);\n\t\t\t} else {\n\t\t\t\tthis.viewProjId.setValue(viewProjMat.data);\n\t\t\t\tthis.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);\n\t\t\t}\n\n\t\t\tthis.dispatchViewPos(camera._node.getPosition());\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t}\n\n\t\tthis.tbnBasis.setValue(target && target.flipY ? -1 : 1);\n\t\tthis.nearClipId.setValue(camera._nearClip);\n\t\tthis.farClipId.setValue(camera._farClip);\n\t\tconst n = camera._nearClip;\n\t\tconst f = camera._farClip;\n\t\tthis.cameraParams[0] = 1 / f;\n\t\tthis.cameraParams[1] = f;\n\t\tthis.cameraParams[2] = (1 - f / n) * 0.5;\n\t\tthis.cameraParams[3] = (1 + f / n) * 0.5;\n\t\tthis.cameraParamsId.setValue(this.cameraParams);\n\t\tthis.clearView(camera, target, clear, false);\n\t}\n\n\tclearView(camera, target, clear, forceWrite, options) {\n\t\tconst device = this.device;\n\t\tdevice.setRenderTarget(target);\n\t\tdevice.updateBegin();\n\n\t\tif (forceWrite) {\n\t\t\tdevice.setColorWrite(true, true, true, true);\n\t\t\tdevice.setDepthWrite(true);\n\t\t}\n\n\t\tconst pixelWidth = target ? target.width : device.width;\n\t\tconst pixelHeight = target ? target.height : device.height;\n\t\tconst rect = camera.rect;\n\t\tlet x = Math.floor(rect.x * pixelWidth);\n\t\tlet y = Math.floor(rect.y * pixelHeight);\n\t\tlet w = Math.floor(rect.z * pixelWidth);\n\t\tlet h = Math.floor(rect.w * pixelHeight);\n\t\tdevice.setViewport(x, y, w, h);\n\n\t\tif (camera._scissorRectClear) {\n\t\t\tconst scissorRect = camera.scissorRect;\n\t\t\tx = Math.floor(scissorRect.x * pixelWidth);\n\t\t\ty = Math.floor(scissorRect.y * pixelHeight);\n\t\t\tw = Math.floor(scissorRect.z * pixelWidth);\n\t\t\th = Math.floor(scissorRect.w * pixelHeight);\n\t\t}\n\n\t\tdevice.setScissor(x, y, w, h);\n\n\t\tif (clear) {\n\t\t\tif (!options) options = camera._clearOptions;\n\t\t\tdevice.clear(options ? options : {\n\t\t\t\tcolor: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],\n\t\t\t\tdepth: camera._clearDepth,\n\t\t\t\tflags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),\n\t\t\t\tstencil: camera._clearStencil\n\t\t\t});\n\t\t}\n\t}\n\n\tdispatchGlobalLights(scene) {\n\t\tthis.ambientColor[0] = scene.ambientLight.r;\n\t\tthis.ambientColor[1] = scene.ambientLight.g;\n\t\tthis.ambientColor[2] = scene.ambientLight.b;\n\n\t\tif (scene.gammaCorrection) {\n\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\tthis.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);\n\t\t\t}\n\t\t}\n\n\t\tthis.ambientId.setValue(this.ambientColor);\n\t\tthis.exposureId.setValue(scene.exposure);\n\t\tif (scene.skyboxModel) this.skyboxIntensityId.setValue(scene.skyboxIntensity);\n\t}\n\n\t_resolveLight(scope, i) {\n\t\tconst light = \"light\" + i;\n\t\tthis.lightColorId[i] = scope.resolve(light + \"_color\");\n\t\tthis.lightDir[i] = new Float32Array(3);\n\t\tthis.lightDirId[i] = scope.resolve(light + \"_direction\");\n\t\tthis.lightShadowMapId[i] = scope.resolve(light + \"_shadowMap\");\n\t\tthis.lightShadowMatrixId[i] = scope.resolve(light + \"_shadowMatrix\");\n\t\tthis.lightShadowParamsId[i] = scope.resolve(light + \"_shadowParams\");\n\t\tthis.lightRadiusId[i] = scope.resolve(light + \"_radius\");\n\t\tthis.lightPos[i] = new Float32Array(3);\n\t\tthis.lightPosId[i] = scope.resolve(light + \"_position\");\n\t\tthis.lightWidth[i] = new Float32Array(3);\n\t\tthis.lightWidthId[i] = scope.resolve(light + \"_halfWidth\");\n\t\tthis.lightHeight[i] = new Float32Array(3);\n\t\tthis.lightHeightId[i] = scope.resolve(light + \"_halfHeight\");\n\t\tthis.lightInAngleId[i] = scope.resolve(light + \"_innerConeAngle\");\n\t\tthis.lightOutAngleId[i] = scope.resolve(light + \"_outerConeAngle\");\n\t\tthis.lightCookieId[i] = scope.resolve(light + \"_cookie\");\n\t\tthis.lightCookieIntId[i] = scope.resolve(light + \"_cookieIntensity\");\n\t\tthis.lightCookieMatrixId[i] = scope.resolve(light + \"_cookieMatrix\");\n\t\tthis.lightCookieOffsetId[i] = scope.resolve(light + \"_cookieOffset\");\n\t\tthis.shadowMatrixPaletteId[i] = scope.resolve(light + \"_shadowMatrixPalette[0]\");\n\t\tthis.shadowCascadeDistancesId[i] = scope.resolve(light + \"_shadowCascadeDistances[0]\");\n\t\tthis.shadowCascadeCountId[i] = scope.resolve(light + \"_shadowCascadeCount\");\n\t}\n\n\tsetLTCDirectionallLight(wtm, cnt, dir, campos, far) {\n\t\tthis.lightPos[cnt][0] = campos.x - dir.x * far;\n\t\tthis.lightPos[cnt][1] = campos.y - dir.y * far;\n\t\tthis.lightPos[cnt][2] = campos.z - dir.z * far;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\t\tconst hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));\n\t\tthis.lightWidth[cnt][0] = hWidth.x * far;\n\t\tthis.lightWidth[cnt][1] = hWidth.y * far;\n\t\tthis.lightWidth[cnt][2] = hWidth.z * far;\n\t\tthis.lightWidthId[cnt].setValue(this.lightWidth[cnt]);\n\t\tconst hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));\n\t\tthis.lightHeight[cnt][0] = hHeight.x * far;\n\t\tthis.lightHeight[cnt][1] = hHeight.y * far;\n\t\tthis.lightHeight[cnt][2] = hHeight.z * far;\n\t\tthis.lightHeightId[cnt].setValue(this.lightHeight[cnt]);\n\t}\n\n\tdispatchDirectLights(dirs, scene, mask, camera) {\n\t\tlet cnt = 0;\n\t\tconst scope = this.device.scope;\n\n\t\tfor (let i = 0; i < dirs.length; i++) {\n\t\t\tif (!(dirs[i].mask & mask)) continue;\n\t\t\tconst directional = dirs[i];\n\n\t\t\tconst wtm = directional._node.getWorldTransform();\n\n\t\t\tif (!this.lightColorId[cnt]) {\n\t\t\t\tthis._resolveLight(scope, cnt);\n\t\t\t}\n\n\t\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);\n\t\t\twtm.getY(directional._direction).mulScalar(-1);\n\n\t\t\tdirectional._direction.normalize();\n\n\t\t\tthis.lightDir[cnt][0] = directional._direction.x;\n\t\t\tthis.lightDir[cnt][1] = directional._direction.y;\n\t\t\tthis.lightDir[cnt][2] = directional._direction.z;\n\t\t\tthis.lightDirId[cnt].setValue(this.lightDir[cnt]);\n\n\t\t\tif (directional.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\tthis.setLTCDirectionallLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);\n\t\t\t}\n\n\t\t\tif (directional.castShadows) {\n\t\t\t\tconst lightRenderData = directional.getRenderData(camera, 0);\n\n\t\t\t\tconst biases = directional._getUniformBiasValues(lightRenderData);\n\n\t\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\t\t\t\tthis.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);\n\t\t\t\tthis.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);\n\t\t\t\tthis.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);\n\t\t\t\tthis.shadowCascadeCountId[cnt].setValue(directional.numCascades);\n\t\t\t\tconst params = directional._shadowRenderParams;\n\t\t\t\tparams.length = 3;\n\t\t\t\tparams[0] = directional._shadowResolution;\n\t\t\t\tparams[1] = biases.normalBias;\n\t\t\t\tparams[2] = biases.bias;\n\t\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t\t}\n\n\t\t\tcnt++;\n\t\t}\n\n\t\treturn cnt;\n\t}\n\n\tsetLTCPositionalLight(wtm, cnt) {\n\t\tconst hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));\n\t\tthis.lightWidth[cnt][0] = hWidth.x;\n\t\tthis.lightWidth[cnt][1] = hWidth.y;\n\t\tthis.lightWidth[cnt][2] = hWidth.z;\n\t\tthis.lightWidthId[cnt].setValue(this.lightWidth[cnt]);\n\t\tconst hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));\n\t\tthis.lightHeight[cnt][0] = hHeight.x;\n\t\tthis.lightHeight[cnt][1] = hHeight.y;\n\t\tthis.lightHeight[cnt][2] = hHeight.z;\n\t\tthis.lightHeightId[cnt].setValue(this.lightHeight[cnt]);\n\t}\n\n\tdispatchOmniLight(scene, scope, omni, cnt) {\n\t\tconst wtm = omni._node.getWorldTransform();\n\n\t\tif (!this.lightColorId[cnt]) {\n\t\t\tthis._resolveLight(scope, cnt);\n\t\t}\n\n\t\tthis.lightRadiusId[cnt].setValue(omni.attenuationEnd);\n\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);\n\t\twtm.getTranslation(omni._position);\n\t\tthis.lightPos[cnt][0] = omni._position.x;\n\t\tthis.lightPos[cnt][1] = omni._position.y;\n\t\tthis.lightPos[cnt][2] = omni._position.z;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\n\t\tif (omni.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\tthis.setLTCPositionalLight(wtm, cnt);\n\t\t}\n\n\t\tif (omni.castShadows) {\n\t\t\tconst lightRenderData = omni.getRenderData(null, 0);\n\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\n\t\t\tconst biases = omni._getUniformBiasValues(lightRenderData);\n\n\t\t\tconst params = omni._shadowRenderParams;\n\t\t\tparams.length = 4;\n\t\t\tparams[0] = omni._shadowResolution;\n\t\t\tparams[1] = biases.normalBias;\n\t\t\tparams[2] = biases.bias;\n\t\t\tparams[3] = 1.0 / omni.attenuationEnd;\n\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t}\n\n\t\tif (omni._cookie) {\n\t\t\tthis.lightCookieId[cnt].setValue(omni._cookie);\n\t\t\tthis.lightShadowMatrixId[cnt].setValue(wtm.data);\n\t\t\tthis.lightCookieIntId[cnt].setValue(omni.cookieIntensity);\n\t\t}\n\t}\n\n\tdispatchSpotLight(scene, scope, spot, cnt) {\n\t\tconst wtm = spot._node.getWorldTransform();\n\n\t\tif (!this.lightColorId[cnt]) {\n\t\t\tthis._resolveLight(scope, cnt);\n\t\t}\n\n\t\tthis.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);\n\t\tthis.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);\n\t\tthis.lightRadiusId[cnt].setValue(spot.attenuationEnd);\n\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);\n\t\twtm.getTranslation(spot._position);\n\t\tthis.lightPos[cnt][0] = spot._position.x;\n\t\tthis.lightPos[cnt][1] = spot._position.y;\n\t\tthis.lightPos[cnt][2] = spot._position.z;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\n\t\tif (spot.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\tthis.setLTCPositionalLight(wtm, cnt);\n\t\t}\n\n\t\twtm.getY(spot._direction).mulScalar(-1);\n\n\t\tspot._direction.normalize();\n\n\t\tthis.lightDir[cnt][0] = spot._direction.x;\n\t\tthis.lightDir[cnt][1] = spot._direction.y;\n\t\tthis.lightDir[cnt][2] = spot._direction.z;\n\t\tthis.lightDirId[cnt].setValue(this.lightDir[cnt]);\n\n\t\tif (spot.castShadows) {\n\t\t\tconst lightRenderData = spot.getRenderData(null, 0);\n\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\t\t\tthis.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);\n\n\t\t\tconst biases = spot._getUniformBiasValues(lightRenderData);\n\n\t\t\tconst params = spot._shadowRenderParams;\n\t\t\tparams.length = 4;\n\t\t\tparams[0] = spot._shadowResolution;\n\t\t\tparams[1] = biases.normalBias;\n\t\t\tparams[2] = biases.bias;\n\t\t\tparams[3] = 1.0 / spot.attenuationEnd;\n\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t}\n\n\t\tif (spot._cookie) {\n\t\t\tif (!spot.castShadows) {\n\t\t\t\tconst cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);\n\t\t\t\tthis.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);\n\t\t\t}\n\n\t\t\tthis.lightCookieId[cnt].setValue(spot._cookie);\n\t\t\tthis.lightCookieIntId[cnt].setValue(spot.cookieIntensity);\n\n\t\t\tif (spot._cookieTransform) {\n\t\t\t\tspot._cookieTransformUniform[0] = spot._cookieTransform.x;\n\t\t\t\tspot._cookieTransformUniform[1] = spot._cookieTransform.y;\n\t\t\t\tspot._cookieTransformUniform[2] = spot._cookieTransform.z;\n\t\t\t\tspot._cookieTransformUniform[3] = spot._cookieTransform.w;\n\t\t\t\tthis.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);\n\t\t\t\tspot._cookieOffsetUniform[0] = spot._cookieOffset.x;\n\t\t\t\tspot._cookieOffsetUniform[1] = spot._cookieOffset.y;\n\t\t\t\tthis.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tdispatchLocalLights(sortedLights, scene, mask, usedDirLights, staticLightList) {\n\t\tlet cnt = usedDirLights;\n\t\tconst scope = this.device.scope;\n\t\tconst omnis = sortedLights[LIGHTTYPE_OMNI];\n\t\tconst numOmnis = omnis.length;\n\n\t\tfor (let i = 0; i < numOmnis; i++) {\n\t\t\tconst omni = omnis[i];\n\t\t\tif (!(omni.mask & mask)) continue;\n\t\t\tif (omni.isStatic) continue;\n\t\t\tthis.dispatchOmniLight(scene, scope, omni, cnt);\n\t\t\tcnt++;\n\t\t}\n\n\t\tlet staticId = 0;\n\n\t\tif (staticLightList) {\n\t\t\tlet omni = staticLightList[staticId];\n\n\t\t\twhile (omni && omni._type === LIGHTTYPE_OMNI) {\n\t\t\t\tthis.dispatchOmniLight(scene, scope, omni, cnt);\n\t\t\t\tcnt++;\n\t\t\t\tstaticId++;\n\t\t\t\tomni = staticLightList[staticId];\n\t\t\t}\n\t\t}\n\n\t\tconst spts = sortedLights[LIGHTTYPE_SPOT];\n\t\tconst numSpts = spts.length;\n\n\t\tfor (let i = 0; i < numSpts; i++) {\n\t\t\tconst spot = spts[i];\n\t\t\tif (!(spot.mask & mask)) continue;\n\t\t\tif (spot.isStatic) continue;\n\t\t\tthis.dispatchSpotLight(scene, scope, spot, cnt);\n\t\t\tcnt++;\n\t\t}\n\n\t\tif (staticLightList) {\n\t\t\tlet spot = staticLightList[staticId];\n\n\t\t\twhile (spot && spot._type === LIGHTTYPE_SPOT) {\n\t\t\t\tthis.dispatchSpotLight(scene, scope, spot, cnt);\n\t\t\t\tcnt++;\n\t\t\t\tstaticId++;\n\t\t\t\tspot = staticLightList[staticId];\n\t\t\t}\n\t\t}\n\t}\n\n\tcull(camera, drawCalls, visibleList) {\n\t\tlet visibleLength = 0;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tconst cullingMask = camera.cullingMask || 0xFFFFFFFF;\n\n\t\tif (!camera.frustumCulling) {\n\t\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\t\tconst drawCall = drawCalls[i];\n\t\t\t\tif (!drawCall.visible && !drawCall.command) continue;\n\t\t\t\tif (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;\n\t\t\t\tvisibleList[visibleLength] = drawCall;\n\t\t\t\tvisibleLength++;\n\t\t\t\tdrawCall.visibleThisFrame = true;\n\t\t\t}\n\n\t\t\treturn visibleLength;\n\t\t}\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\n\t\t\tif (!drawCall.command) {\n\t\t\t\tif (!drawCall.visible) continue;\n\t\t\t\tlet visible = true;\n\t\t\t\tif (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;\n\n\t\t\t\tif (drawCall.cull) {\n\t\t\t\t\tvisible = drawCall._isVisible(camera);\n\t\t\t\t}\n\n\t\t\t\tif (visible) {\n\t\t\t\t\tvisibleList[visibleLength] = drawCall;\n\t\t\t\t\tvisibleLength++;\n\t\t\t\t\tdrawCall.visibleThisFrame = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvisibleList[visibleLength] = drawCall;\n\t\t\t\tvisibleLength++;\n\t\t\t\tdrawCall.visibleThisFrame = true;\n\t\t\t}\n\t\t}\n\n\t\treturn visibleLength;\n\t}\n\n\tcullLights(camera, lights) {\n\t\tconst clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\n\t\t\tif (light.enabled) {\n\t\t\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tlight.getBoundingSphere(tempSphere$1);\n\n\t\t\t\t\tif (camera.frustum.containsSphere(tempSphere$1)) {\n\t\t\t\t\t\tlight.visibleThisFrame = true;\n\t\t\t\t\t\tconst screenSize = camera.getScreenSize(tempSphere$1);\n\t\t\t\t\t\tlight.maxScreenSize = Math.max(light.maxScreenSize, screenSize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!clusteredLightingEnabled) {\n\t\t\t\t\t\t\tif (light.castShadows && !light.shadowMap) {\n\t\t\t\t\t\t\t\tlight.visibleThisFrame = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateCpuSkinMatrices(drawCalls) {\n\t\t_skinUpdateIndex++;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tif (drawCallsCount === 0) return;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst si = drawCalls[i].skinInstance;\n\n\t\t\tif (si) {\n\t\t\t\tsi.updateMatrices(drawCalls[i].node, _skinUpdateIndex);\n\t\t\t\tsi._dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateGpuSkinMatrices(drawCalls) {\n\t\tconst drawCallsCount = drawCalls.length;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tif (!drawCalls[i].visibleThisFrame) continue;\n\t\t\tconst skin = drawCalls[i].skinInstance;\n\n\t\t\tif (skin) {\n\t\t\t\tif (skin._dirty) {\n\t\t\t\t\tskin.updateMatrixPalette(drawCalls[i].node, _skinUpdateIndex);\n\t\t\t\t\tskin._dirty = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateMorphing(drawCalls) {\n\t\tconst drawCallsCount = drawCalls.length;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst morphInst = drawCalls[i].morphInstance;\n\n\t\t\tif (morphInst && morphInst._dirty && drawCalls[i].visibleThisFrame) {\n\t\t\t\tmorphInst.update();\n\t\t\t}\n\t\t}\n\t}\n\n\tsetBaseConstants(device, material) {\n\t\tdevice.setCullMode(material.cull);\n\n\t\tif (material.opacityMap) {\n\t\t\tthis.opacityMapId.setValue(material.opacityMap);\n\t\t\tthis.alphaTestId.setValue(material.alphaTest);\n\t\t}\n\t}\n\n\tsetSkinning(device, meshInstance, material) {\n\t\tif (meshInstance.skinInstance) {\n\t\t\tthis._skinDrawCalls++;\n\n\t\t\tif (device.supportsBoneTextures) {\n\t\t\t\tboneTexture = meshInstance.skinInstance.boneTexture;\n\t\t\t\tthis.boneTextureId.setValue(boneTexture);\n\t\t\t\tboneTextureSize[0] = boneTexture.width;\n\t\t\t\tboneTextureSize[1] = boneTexture.height;\n\t\t\t\tboneTextureSize[2] = 1.0 / boneTexture.width;\n\t\t\t\tboneTextureSize[3] = 1.0 / boneTexture.height;\n\t\t\t\tthis.boneTextureSizeId.setValue(boneTextureSize);\n\t\t\t} else {\n\t\t\t\tthis.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawInstance(device, meshInstance, mesh, style, normal) {\n\t\tinstancingData = meshInstance.instancingData;\n\n\t\tif (instancingData) {\n\t\t\tif (instancingData.count > 0) {\n\t\t\t\tthis._instancedDrawCalls++;\n\t\t\t\tdevice.setVertexBuffer(instancingData.vertexBuffer);\n\t\t\t\tdevice.draw(mesh.primitive[style], instancingData.count);\n\n\t\t\t\tif (instancingData.vertexBuffer === _autoInstanceBuffer) {\n\t\t\t\t\tthis._removedByInstancing += instancingData.count;\n\t\t\t\t\tmeshInstance.instancingData = null;\n\t\t\t\t\treturn instancingData.count - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmodelMatrix = meshInstance.node.worldTransform;\n\t\t\tthis.modelMatrixId.setValue(modelMatrix.data);\n\n\t\t\tif (normal) {\n\t\t\t\tnormalMatrix = meshInstance.node.normalMatrix;\n\n\t\t\t\tif (meshInstance.node._dirtyNormal) {\n\t\t\t\t\tmodelMatrix.invertTo3x3(normalMatrix);\n\t\t\t\t\tnormalMatrix.transpose();\n\t\t\t\t\tmeshInstance.node._dirtyNormal = false;\n\t\t\t\t}\n\n\t\t\t\tthis.normalMatrixId.setValue(normalMatrix.data);\n\t\t\t}\n\n\t\t\tdevice.draw(mesh.primitive[style]);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdrawInstance2(device, meshInstance, mesh, style) {\n\t\tinstancingData = meshInstance.instancingData;\n\n\t\tif (instancingData) {\n\t\t\tif (instancingData.count > 0) {\n\t\t\t\tthis._instancedDrawCalls++;\n\t\t\t\tdevice.draw(mesh.primitive[style], instancingData.count, true);\n\n\t\t\t\tif (instancingData.vertexBuffer === _autoInstanceBuffer) {\n\t\t\t\t\tthis._removedByInstancing += instancingData.count;\n\t\t\t\t\tmeshInstance.instancingData = null;\n\t\t\t\t\treturn instancingData.count - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdevice.draw(mesh.primitive[style], undefined, true);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\trenderShadows(lights, camera) {\n\t\tconst isClustered = this.scene.clusteredLightingEnabled;\n\t\tconst device = this.device;\n\t\tdevice.grabPassAvailable = false;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\n\t\t\tif (isClustered && light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tif (!light.atlasViewportAllocated) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {\n\t\t\t\t\tlight.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._shadowRenderer.render(light, camera);\n\t\t}\n\n\t\tdevice.grabPassAvailable = true;\n\t}\n\n\trenderCookies(lights) {\n\t\tconst cookieRenderTarget = this.lightTextureAtlas.cookieRenderTarget;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\t\t\tif (!light.atlasViewportAllocated) continue;\n\t\t\tif (!light.atlasSlotUpdated) continue;\n\n\t\t\tthis._cookieRenderer.render(light, cookieRenderTarget);\n\t\t}\n\t}\n\n\tupdateShader(meshInstance, objDefs, staticLightList, pass, sortedLights) {\n\t\tmeshInstance.material._scene = this.scene;\n\n\t\tif (meshInstance.material._dirtyBlend) {\n\t\t\tthis.scene.layers._dirtyBlend = true;\n\t\t}\n\n\t\tmeshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);\n\t\tmeshInstance._shader[pass] = meshInstance.material.shader;\n\t}\n\n\tsetCullMode(cullFaces, flip, drawCall) {\n\t\tconst material = drawCall.material;\n\t\tlet mode = CULLFACE_NONE;\n\n\t\tif (cullFaces) {\n\t\t\tlet flipFaces = 1;\n\n\t\t\tif (material.cull > CULLFACE_NONE && material.cull < CULLFACE_FRONTANDBACK) {\n\t\t\t\tif (drawCall.flipFaces) flipFaces *= -1;\n\t\t\t\tif (flip) flipFaces *= -1;\n\t\t\t\tconst wt = drawCall.node.worldTransform;\n\t\t\t\twt.getX(worldMatX);\n\t\t\t\twt.getY(worldMatY);\n\t\t\t\twt.getZ(worldMatZ);\n\t\t\t\tworldMatX.cross(worldMatX, worldMatY);\n\n\t\t\t\tif (worldMatX.dot(worldMatZ) < 0) {\n\t\t\t\t\tflipFaces *= -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flipFaces < 0) {\n\t\t\t\tmode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;\n\t\t\t} else {\n\t\t\t\tmode = material.cull;\n\t\t\t}\n\t\t}\n\n\t\tthis.device.setCullMode(mode);\n\n\t\tif (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {\n\t\t\tconst wt2 = drawCall.node.worldTransform;\n\t\t\twt2.getX(worldMatX);\n\t\t\twt2.getY(worldMatY);\n\t\t\twt2.getZ(worldMatZ);\n\t\t\tworldMatX.cross(worldMatX, worldMatY);\n\n\t\t\tif (worldMatX.dot(worldMatZ) < 0) {\n\t\t\t\tthis.twoSidedLightingNegScaleFactorId.setValue(-1.0);\n\t\t\t} else {\n\t\t\t\tthis.twoSidedLightingNegScaleFactorId.setValue(1.0);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetVertexBuffers(device, mesh) {\n\t\tdevice.setVertexBuffer(mesh.vertexBuffer);\n\t}\n\n\tsetMorphing(device, morphInstance) {\n\t\tif (morphInstance) {\n\t\t\tif (morphInstance.morph.useTextureMorph) {\n\t\t\t\tdevice.setVertexBuffer(morphInstance.morph.vertexBufferIds);\n\t\t\t\tthis.morphPositionTex.setValue(morphInstance.texturePositions);\n\t\t\t\tthis.morphNormalTex.setValue(morphInstance.textureNormals);\n\t\t\t\tthis.morphTexParams.setValue(morphInstance._textureParams);\n\t\t\t} else {\n\t\t\t\tfor (let t = 0; t < morphInstance._activeVertexBuffers.length; t++) {\n\t\t\t\t\tconst vb = morphInstance._activeVertexBuffers[t];\n\n\t\t\t\t\tif (vb) {\n\t\t\t\t\t\tconst semantic = SEMANTIC_ATTR + (t + 8);\n\t\t\t\t\t\tvb.format.elements[0].name = semantic;\n\t\t\t\t\t\tvb.format.elements[0].scopeId = device.scope.resolve(semantic);\n\t\t\t\t\t\tvb.format.update();\n\t\t\t\t\t\tdevice.setVertexBuffer(vb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);\n\t\t\t\tthis.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);\n\t\t\t}\n\t\t}\n\t}\n\n\tdispatchViewPos(position) {\n\t\tconst vp = this.viewPos;\n\t\tvp[0] = position.x;\n\t\tvp[1] = position.y;\n\t\tvp[2] = position.z;\n\t\tthis.viewPosId.setValue(vp);\n\t}\n\n\trenderForwardPrepareMaterials(camera, drawCalls, drawCallsCount, sortedLights, cullingMask, layer, pass) {\n\t\tconst addCall = (drawCall, isNewMaterial, lightMaskChanged) => {\n\t\t\t_drawCallList.drawCalls.push(drawCall);\n\n\t\t\t_drawCallList.isNewMaterial.push(isNewMaterial);\n\n\t\t\t_drawCallList.lightMaskChanged.push(lightMaskChanged);\n\t\t};\n\n\t\t_drawCallList.drawCalls.length = 0;\n\t\t_drawCallList.isNewMaterial.length = 0;\n\t\t_drawCallList.lightMaskChanged.length = 0;\n\t\tconst device = this.device;\n\t\tconst scene = this.scene;\n\t\tconst lightHash = layer ? layer._lightHash : 0;\n\t\tlet prevMaterial = null,\n\t\t\t\tprevObjDefs,\n\t\t\t\tprevStatic,\n\t\t\t\tprevLightMask;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\t\t\tif (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue;\n\n\t\t\tif (drawCall.command) {\n\t\t\t\taddCall(drawCall, false, false);\n\t\t\t} else {\n\t\t\t\tif (!drawCall.material) drawCall.material = DefaultMaterial.get(device);\n\t\t\t\tconst material = drawCall.material;\n\t\t\t\tconst objDefs = drawCall._shaderDefs;\n\t\t\t\tconst lightMask = drawCall.mask;\n\n\t\t\t\tif (material && material === prevMaterial && objDefs !== prevObjDefs) {\n\t\t\t\t\tprevMaterial = null;\n\t\t\t\t}\n\n\t\t\t\tif (drawCall.isStatic || prevStatic) {\n\t\t\t\t\tprevMaterial = null;\n\t\t\t\t}\n\n\t\t\t\tif (material !== prevMaterial) {\n\t\t\t\t\tthis._materialSwitches++;\n\n\t\t\t\t\tif (material.dirty) {\n\t\t\t\t\t\tmaterial.updateUniforms(device, scene);\n\t\t\t\t\t\tmaterial.dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {\n\t\t\t\t\t\tif (!drawCall.isStatic) {\n\t\t\t\t\t\t\tconst variantKey = pass + \"_\" + objDefs + \"_\" + lightHash;\n\t\t\t\t\t\t\tdrawCall._shader[pass] = material.variants[variantKey];\n\n\t\t\t\t\t\t\tif (!drawCall._shader[pass]) {\n\t\t\t\t\t\t\t\tthis.updateShader(drawCall, objDefs, null, pass, sortedLights);\n\t\t\t\t\t\t\t\tmaterial.variants[variantKey] = drawCall._shader[pass];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdrawCall._shaderDefs = objDefs;\n\t\t\t\t\t\tdrawCall._lightHash = lightHash;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\taddCall(drawCall, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);\n\t\t\t\tprevMaterial = material;\n\t\t\t\tprevObjDefs = objDefs;\n\t\t\t\tprevLightMask = lightMask;\n\t\t\t\tprevStatic = drawCall.isStatic;\n\t\t\t}\n\t\t}\n\n\t\treturn _drawCallList;\n\t}\n\n\trenderForward(camera, allDrawCalls, allDrawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer, flipFaces) {\n\t\tconst device = this.device;\n\t\tconst scene = this.scene;\n\t\tconst vrDisplay = camera.vrDisplay;\n\t\tconst passFlag = 1 << pass;\n\t\tconst halfWidth = device.width * 0.5;\n\t\tconst preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, allDrawCallsCount, sortedLights, cullingMask, layer, pass);\n\t\tconst preparedCallsCount = preparedCalls.drawCalls.length;\n\n\t\tfor (let i = 0; i < preparedCallsCount; i++) {\n\t\t\tconst drawCall = preparedCalls.drawCalls[i];\n\n\t\t\tif (drawCall.command) {\n\t\t\t\tdrawCall.command();\n\t\t\t} else {\n\t\t\t\tconst newMaterial = preparedCalls.isNewMaterial[i];\n\t\t\t\tconst lightMaskChanged = preparedCalls.lightMaskChanged[i];\n\t\t\t\tconst material = drawCall.material;\n\t\t\t\tdrawCall._shaderDefs;\n\t\t\t\tconst lightMask = drawCall.mask;\n\n\t\t\t\tif (newMaterial) {\n\t\t\t\t\tconst shader = drawCall._shader[pass];\n\n\t\t\t\t\tif (!shader.failed && !device.setShader(shader)) {\n\t\t\t\t\t\tshader.failed = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterial.setParameters(device);\n\n\t\t\t\t\tif (lightMaskChanged) {\n\t\t\t\t\t\tconst usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);\n\t\t\t\t\t\tthis.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.alphaTestId.setValue(material.alphaTest);\n\t\t\t\t\tdevice.setBlending(material.blend);\n\n\t\t\t\t\tif (material.blend) {\n\t\t\t\t\t\tif (material.separateAlphaBlend) {\n\t\t\t\t\t\t\tdevice.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);\n\t\t\t\t\t\t\tdevice.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdevice.setBlendFunction(material.blendSrc, material.blendDst);\n\t\t\t\t\t\t\tdevice.setBlendEquation(material.blendEquation);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdevice.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);\n\t\t\t\t\tdevice.setDepthWrite(material.depthWrite);\n\n\t\t\t\t\tif (material.depthWrite && !material.depthTest) {\n\t\t\t\t\t\tdevice.setDepthFunc(FUNC_ALWAYS);\n\t\t\t\t\t\tdevice.setDepthTest(true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdevice.setDepthFunc(FUNC_LESSEQUAL);\n\t\t\t\t\t\tdevice.setDepthTest(material.depthTest);\n\t\t\t\t\t}\n\n\t\t\t\t\tdevice.setAlphaToCoverage(material.alphaToCoverage);\n\n\t\t\t\t\tif (material.depthBias || material.slopeDepthBias) {\n\t\t\t\t\t\tdevice.setDepthBias(true);\n\t\t\t\t\t\tdevice.setDepthBiasValues(material.depthBias, material.slopeDepthBias);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdevice.setDepthBias(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setCullMode(camera._cullFaces, flipFaces, drawCall);\n\t\t\t\tconst stencilFront = drawCall.stencilFront || material.stencilFront;\n\t\t\t\tconst stencilBack = drawCall.stencilBack || material.stencilBack;\n\n\t\t\t\tif (stencilFront || stencilBack) {\n\t\t\t\t\tdevice.setStencilTest(true);\n\n\t\t\t\t\tif (stencilFront === stencilBack) {\n\t\t\t\t\t\tdevice.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);\n\t\t\t\t\t\tdevice.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (stencilFront) {\n\t\t\t\t\t\t\tdevice.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);\n\t\t\t\t\t\t\tdevice.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdevice.setStencilFuncFront(FUNC_ALWAYS, 0, 0xFF);\n\t\t\t\t\t\t\tdevice.setStencilOperationFront(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (stencilBack) {\n\t\t\t\t\t\t\tdevice.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);\n\t\t\t\t\t\t\tdevice.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdevice.setStencilFuncBack(FUNC_ALWAYS, 0, 0xFF);\n\t\t\t\t\t\t\tdevice.setStencilOperationBack(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdevice.setStencilTest(false);\n\t\t\t\t}\n\n\t\t\t\tconst mesh = drawCall.mesh;\n\t\t\t\tdrawCall.setParameters(device, passFlag);\n\t\t\t\tthis.setVertexBuffers(device, mesh);\n\t\t\t\tthis.setMorphing(device, drawCall.morphInstance);\n\t\t\t\tthis.setSkinning(device, drawCall, material);\n\t\t\t\tconst style = drawCall.renderStyle;\n\t\t\t\tdevice.setIndexBuffer(mesh.indexBuffer[style]);\n\n\t\t\t\tif (drawCallback) {\n\t\t\t\t\tdrawCallback(drawCall, i);\n\t\t\t\t}\n\n\t\t\t\tif (vrDisplay && vrDisplay.presenting) {\n\t\t\t\t\tdevice.setViewport(0, 0, halfWidth, device.height);\n\t\t\t\t\tthis.projId.setValue(projL.data);\n\t\t\t\t\tthis.projSkyboxId.setValue(projL.data);\n\t\t\t\t\tthis.viewInvId.setValue(viewInvL.data);\n\t\t\t\t\tthis.viewId.setValue(viewL.data);\n\t\t\t\t\tthis.viewId3.setValue(viewMat3L.data);\n\t\t\t\t\tthis.viewProjId.setValue(viewProjMatL.data);\n\t\t\t\t\tthis.dispatchViewPos(viewPosL);\n\t\t\t\t\ti += this.drawInstance(device, drawCall, mesh, style, true);\n\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t\tdevice.setViewport(halfWidth, 0, halfWidth, device.height);\n\t\t\t\t\tthis.projId.setValue(projR.data);\n\t\t\t\t\tthis.projSkyboxId.setValue(projR.data);\n\t\t\t\t\tthis.viewInvId.setValue(viewInvR.data);\n\t\t\t\t\tthis.viewId.setValue(viewR.data);\n\t\t\t\t\tthis.viewId3.setValue(viewMat3R.data);\n\t\t\t\t\tthis.viewProjId.setValue(viewProjMatR.data);\n\t\t\t\t\tthis.dispatchViewPos(viewPosR);\n\t\t\t\t\ti += this.drawInstance2(device, drawCall, mesh, style);\n\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t} else if (camera.xr && camera.xr.session && camera.xr.views.length) {\n\t\t\t\t\tconst views = camera.xr.views;\n\n\t\t\t\t\tfor (let v = 0; v < views.length; v++) {\n\t\t\t\t\t\tconst view = views[v];\n\t\t\t\t\t\tdevice.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);\n\t\t\t\t\t\tthis.projId.setValue(view.projMat.data);\n\t\t\t\t\t\tthis.projSkyboxId.setValue(view.projMat.data);\n\t\t\t\t\t\tthis.viewId.setValue(view.viewOffMat.data);\n\t\t\t\t\t\tthis.viewInvId.setValue(view.viewInvOffMat.data);\n\t\t\t\t\t\tthis.viewId3.setValue(view.viewMat3.data);\n\t\t\t\t\t\tthis.viewProjId.setValue(view.projViewOffMat.data);\n\t\t\t\t\t\tthis.viewPosId.setValue(view.position);\n\n\t\t\t\t\t\tif (v === 0) {\n\t\t\t\t\t\t\ti += this.drawInstance(device, drawCall, mesh, style, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ti += this.drawInstance2(device, drawCall, mesh, style);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti += this.drawInstance(device, drawCall, mesh, style, true);\n\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t}\n\n\t\t\t\tif (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {\n\t\t\t\t\tmaterial.setParameters(device, drawCall.parameters);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdevice.updateEnd();\n\t\t_drawCallList.length = 0;\n\t}\n\n\tsetupInstancing(device) {\n\t\tif (device.enableAutoInstancing) {\n\t\t\tif (!_autoInstanceBuffer) {\n\t\t\t\t_autoInstanceBuffer = new VertexBuffer(device, VertexFormat.defaultInstancingFormat, device.autoInstancingMaxObjects, BUFFER_DYNAMIC);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateShaders(drawCalls, onlyLitShaders) {\n\t\tconst count = drawCalls.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst mat = drawCalls[i].material;\n\n\t\t\tif (mat) {\n\t\t\t\tif (!_tempMaterialSet.has(mat)) {\n\t\t\t\t\t_tempMaterialSet.add(mat);\n\n\t\t\t\t\tif (mat.updateShader !== Material.prototype.updateShader) {\n\t\t\t\t\t\tif (onlyLitShaders) {\n\t\t\t\t\t\t\tif (!mat.useLighting || mat.emitter && !mat.emitter.lighting) continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmat.clearVariants();\n\t\t\t\t\t\tmat.shader = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_tempMaterialSet.clear();\n\t}\n\n\tbeginFrame(comp, lightsChanged) {\n\t\tconst meshInstances = comp._meshInstances;\n\t\tconst scene = this.scene;\n\n\t\tif (scene.updateShaders || lightsChanged) {\n\t\t\tconst onlyLitShaders = !scene.updateShaders && lightsChanged;\n\t\t\tthis.updateShaders(meshInstances, onlyLitShaders);\n\t\t\tscene.updateShaders = false;\n\t\t\tscene._shaderVersion++;\n\t\t}\n\n\t\tthis.updateCpuSkinMatrices(meshInstances);\n\t\tconst miCount = meshInstances.length;\n\n\t\tfor (let i = 0; i < miCount; i++) {\n\t\t\tmeshInstances[i].visibleThisFrame = false;\n\t\t}\n\n\t\tconst lights = comp._lights;\n\t\tconst lightCount = lights.length;\n\n\t\tfor (let i = 0; i < lightCount; i++) {\n\t\t\tlights[i].beginFrame();\n\t\t}\n\t}\n\n\tbeginLayers(comp) {\n\t\tconst len = comp.layerList.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tcomp.layerList[i]._postRenderCounter = 0;\n\t\t}\n\n\t\tconst scene = this.scene;\n\t\tconst shaderVersion = scene._shaderVersion;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst layer = comp.layerList[i];\n\t\t\tlayer._shaderVersion = shaderVersion;\n\t\t\tlayer._preRenderCalledForCameras = 0;\n\t\t\tlayer._postRenderCalledForCameras = 0;\n\t\t\tconst transparent = comp.subLayerList[i];\n\n\t\t\tif (transparent) {\n\t\t\t\tlayer._postRenderCounter |= 2;\n\t\t\t} else {\n\t\t\t\tlayer._postRenderCounter |= 1;\n\t\t\t}\n\n\t\t\tlayer._postRenderCounterMax = layer._postRenderCounter;\n\n\t\t\tfor (let j = 0; j < layer.cameras.length; j++) {\n\t\t\t\tlayer.instances.prepare(j);\n\t\t\t}\n\n\t\t\tif (layer._needsStaticPrepare && layer._staticLightHash && !this.scene.clusteredLightingEnabled) {\n\t\t\t\tif (layer._staticPrepareDone) {\n\t\t\t\t\tStaticMeshes.revert(layer.opaqueMeshInstances);\n\t\t\t\t\tStaticMeshes.revert(layer.transparentMeshInstances);\n\t\t\t\t}\n\n\t\t\t\tStaticMeshes.prepare(this.device, scene, layer.opaqueMeshInstances, layer._lights);\n\t\t\t\tStaticMeshes.prepare(this.device, scene, layer.transparentMeshInstances, layer._lights);\n\t\t\t\tcomp._dirty = true;\n\t\t\t\tscene.updateShaders = true;\n\t\t\t\tlayer._needsStaticPrepare = false;\n\t\t\t\tlayer._staticPrepareDone = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tgpuUpdate(drawCalls) {\n\t\tthis.updateGpuSkinMatrices(drawCalls);\n\t\tthis.updateMorphing(drawCalls);\n\t}\n\n\tsetSceneConstants() {\n\t\tconst scene = this.scene;\n\t\tthis.dispatchGlobalLights(scene);\n\n\t\tif (scene.fog !== FOG_NONE) {\n\t\t\tthis.fogColor[0] = scene.fogColor.r;\n\t\t\tthis.fogColor[1] = scene.fogColor.g;\n\t\t\tthis.fogColor[2] = scene.fogColor.b;\n\n\t\t\tif (scene.gammaCorrection) {\n\t\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\t\tthis.fogColor[i] = Math.pow(this.fogColor[i], 2.2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.fogColorId.setValue(this.fogColor);\n\n\t\t\tif (scene.fog === FOG_LINEAR) {\n\t\t\t\tthis.fogStartId.setValue(scene.fogStart);\n\t\t\t\tthis.fogEndId.setValue(scene.fogEnd);\n\t\t\t} else {\n\t\t\t\tthis.fogDensityId.setValue(scene.fogDensity);\n\t\t\t}\n\t\t}\n\n\t\tconst device = this.device;\n\t\tthis._screenSize[0] = device.width;\n\t\tthis._screenSize[1] = device.height;\n\t\tthis._screenSize[2] = 1 / device.width;\n\t\tthis._screenSize[3] = 1 / device.height;\n\t\tthis.screenSizeId.setValue(this._screenSize);\n\t}\n\n\tupdateLightStats(comp, compUpdatedFlags) {}\n\n\tcullShadowmaps(comp) {\n\t\tfor (let i = 0; i < comp._lights.length; i++) {\n\t\t\tconst light = comp._lights[i];\n\n\t\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tif (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {\n\t\t\t\t\tconst casters = comp._lightCompositionData[i].shadowCastersList;\n\n\t\t\t\t\tthis._shadowRenderer.cullLocal(light, casters);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst renderActions = comp._renderActions;\n\n\t\tfor (let i = 0; i < renderActions.length; i++) {\n\t\t\tconst renderAction = renderActions[i];\n\t\t\tconst count = renderAction.directionalLightsIndices.length;\n\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tconst lightIndex = renderAction.directionalLightsIndices[j];\n\t\t\t\tconst light = comp._lights[lightIndex];\n\t\t\t\tconst casters = comp._lightCompositionData[lightIndex].shadowCastersList;\n\n\t\t\t\tthis._shadowRenderer.cullDirectional(light, casters, renderAction.camera.camera);\n\t\t\t}\n\t\t}\n\t}\n\n\tcullComposition(comp) {\n\t\tconst renderActions = comp._renderActions;\n\n\t\tfor (let i = 0; i < renderActions.length; i++) {\n\t\t\tconst renderAction = renderActions[i];\n\t\t\tconst layerIndex = renderAction.layerIndex;\n\t\t\tconst layer = comp.layerList[layerIndex];\n\t\t\tif (!layer.enabled || !comp.subLayerEnabled[layerIndex]) continue;\n\t\t\tconst transparent = comp.subLayerList[layerIndex];\n\t\t\tconst cameraPass = renderAction.cameraIndex;\n\t\t\tconst camera = layer.cameras[cameraPass];\n\n\t\t\tif (camera) {\n\t\t\t\tcamera.frameBegin(renderAction.renderTarget);\n\n\t\t\t\tif (renderAction.firstCameraUse) {\n\t\t\t\t\tthis.updateCameraFrustum(camera.camera);\n\t\t\t\t\tthis._camerasRendered++;\n\t\t\t\t}\n\n\t\t\t\tthis.cullLights(camera.camera, layer._lights);\n\t\t\t\tconst objects = layer.instances;\n\t\t\t\tconst visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n\n\t\t\t\tif (!visible.done) {\n\t\t\t\t\tif (layer.onPreCull) {\n\t\t\t\t\t\tlayer.onPreCull(cameraPass);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;\n\t\t\t\t\tvisible.length = this.cull(camera.camera, drawCalls, visible.list);\n\t\t\t\t\tvisible.done = true;\n\n\t\t\t\t\tif (layer.onPostCull) {\n\t\t\t\t\t\tlayer.onPostCull(cameraPass);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcamera.frameEnd();\n\t\t\t}\n\t\t}\n\n\t\tthis.cullShadowmaps(comp);\n\t}\n\n\tupdateLightTextureAtlas(comp) {\n\t\tthis.lightTextureAtlas.update(comp._splitLights[LIGHTTYPE_SPOT], comp._splitLights[LIGHTTYPE_OMNI], this.scene.lighting);\n\t}\n\n\tupdateClusters(comp) {\n\t\tfor (let i = 0; i < comp._worldClusters.length; i++) {\n\t\t\tconst cluster = comp._worldClusters[i];\n\t\t\tcluster.update(comp._lights, this.scene.gammaCorrection, this.scene.lighting);\n\t\t}\n\t}\n\n\trenderComposition(comp) {\n\t\tconst device = this.device;\n\t\tconst clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n\n\t\tthis.scene._updateSkybox(this.device);\n\n\t\tthis.beginLayers(comp);\n\n\t\tconst updated = comp._update(device, clusteredLightingEnabled);\n\n\t\tconst lightsChanged = (updated & COMPUPDATED_LIGHTS) !== 0;\n\t\tthis.updateLightStats(comp, updated);\n\t\tthis.beginFrame(comp, lightsChanged);\n\t\tthis.setSceneConstants();\n\t\tthis.cullComposition(comp);\n\t\tthis.gpuUpdate(comp._meshInstances);\n\n\t\tif (clusteredLightingEnabled) {\n\t\t\tthis.updateLightTextureAtlas(comp);\n\n\t\t\tif (this.scene.lighting.cookiesEnabled) {\n\t\t\t\tthis.renderCookies(comp._splitLights[LIGHTTYPE_SPOT]);\n\t\t\t\tthis.renderCookies(comp._splitLights[LIGHTTYPE_OMNI]);\n\t\t\t}\n\t\t}\n\n\t\tif (!clusteredLightingEnabled || clusteredLightingEnabled && this.scene.lighting.shadowsEnabled) {\n\t\t\tthis.renderShadows(comp._splitLights[LIGHTTYPE_SPOT]);\n\t\t\tthis.renderShadows(comp._splitLights[LIGHTTYPE_OMNI]);\n\t\t}\n\n\t\tif (clusteredLightingEnabled) {\n\t\t\tthis.updateClusters(comp);\n\t\t}\n\t\tlet clustersDebugRendered = false;\n\t\tconst renderActions = comp._renderActions;\n\n\t\tfor (let i = 0; i < renderActions.length; i++) {\n\t\t\tconst renderAction = renderActions[i];\n\t\t\tconst layerIndex = renderAction.layerIndex;\n\t\t\tconst layer = comp.layerList[layerIndex];\n\t\t\tconst transparent = comp.subLayerList[layerIndex];\n\t\t\tconst cameraPass = renderAction.cameraIndex;\n\t\t\tconst camera = layer.cameras[cameraPass];\n\n\t\t\tif (renderAction.directionalLights.length > 0) {\n\t\t\t\tthis.renderShadows(renderAction.directionalLights, camera.camera);\n\t\t\t}\n\n\t\t\tif (!layer.enabled || !comp.subLayerEnabled[layerIndex]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (camera) {\n\t\t\t\tcamera.frameBegin(renderAction.renderTarget);\n\n\t\t\t\tif (renderAction.firstCameraUse && camera.onPreRender) {\n\t\t\t\t\tcamera.onPreRender();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!transparent && layer.onPreRenderOpaque) {\n\t\t\t\tlayer.onPreRenderOpaque(cameraPass);\n\t\t\t} else if (transparent && layer.onPreRenderTransparent) {\n\t\t\t\tlayer.onPreRenderTransparent(cameraPass);\n\t\t\t}\n\n\t\t\tif (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {\n\t\t\t\tif (layer.onPreRender) {\n\t\t\t\t\tlayer.onPreRender(cameraPass);\n\t\t\t\t}\n\n\t\t\t\tlayer._preRenderCalledForCameras |= 1 << cameraPass;\n\t\t\t}\n\n\t\t\tif (camera) {\n\t\t\t\tvar _renderAction$renderT;\n\n\t\t\t\tif (renderAction.clearColor || renderAction.clearDepth || renderAction.clearStencil) {\n\t\t\t\t\tconst backupColor = camera.camera._clearColorBuffer;\n\t\t\t\t\tconst backupDepth = camera.camera._clearDepthBuffer;\n\t\t\t\t\tconst backupStencil = camera.camera._clearStencilBuffer;\n\t\t\t\t\tcamera.camera._clearColorBuffer = renderAction.clearColor;\n\t\t\t\t\tcamera.camera._clearDepthBuffer = renderAction.clearDepth;\n\t\t\t\t\tcamera.camera._clearStencilBuffer = renderAction.clearStencil;\n\t\t\t\t\tthis.clearView(camera.camera, renderAction.renderTarget, true, true);\n\t\t\t\t\tcamera.camera._clearColorBuffer = backupColor;\n\t\t\t\t\tcamera.camera._clearDepthBuffer = backupDepth;\n\t\t\t\t\tcamera.camera._clearStencilBuffer = backupStencil;\n\t\t\t\t}\n\n\t\t\t\tlayer._sortVisible(transparent, camera.camera.node, cameraPass);\n\n\t\t\t\tconst objects = layer.instances;\n\t\t\t\tconst visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n\t\t\t\tthis.scene.immediate.onPreRenderLayer(layer, visible, transparent);\n\t\t\t\tthis.scene._activeCamera = camera.camera;\n\t\t\t\tthis.setCamera(camera.camera, renderAction.renderTarget);\n\n\t\t\t\tif (clusteredLightingEnabled && renderAction.lightClusters) {\n\t\t\t\t\trenderAction.lightClusters.activate(this.lightTextureAtlas);\n\n\t\t\t\t\tif (!clustersDebugRendered && this.scene.lighting.debugLayer === layer.id) {\n\t\t\t\t\t\tclustersDebugRendered = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst flipFaces = !!(camera.camera._flipFaces ^ (renderAction == null ? void 0 : (_renderAction$renderT = renderAction.renderTarget) == null ? void 0 : _renderAction$renderT.flipY));\n\t\t\t\tconst draws = this._forwardDrawCalls;\n\t\t\t\tthis.renderForward(camera.camera, visible.list, visible.length, layer._splitLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer, flipFaces);\n\t\t\t\tlayer._forwardDrawCalls += this._forwardDrawCalls - draws;\n\t\t\t\tdevice.setColorWrite(true, true, true, true);\n\t\t\t\tdevice.setStencilTest(false);\n\t\t\t\tdevice.setAlphaToCoverage(false);\n\t\t\t\tdevice.setDepthBias(false);\n\t\t\t\tcamera.frameEnd();\n\n\t\t\t\tif (renderAction.lastCameraUse && camera.onPostRender) {\n\t\t\t\t\tcamera.onPostRender();\n\t\t\t\t}\n\n\t\t\t\tif (renderAction.triggerPostprocess && camera.onPostprocessing) {\n\t\t\t\t\tcamera.onPostprocessing();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!transparent && layer.onPostRenderOpaque) {\n\t\t\t\tlayer.onPostRenderOpaque(cameraPass);\n\t\t\t} else if (transparent && layer.onPostRenderTransparent) {\n\t\t\t\tlayer.onPostRenderTransparent(cameraPass);\n\t\t\t}\n\n\t\t\tif (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {\n\t\t\t\tlayer._postRenderCounter &= ~(transparent ? 2 : 1);\n\n\t\t\t\tif (layer._postRenderCounter === 0) {\n\t\t\t\t\tlayer.onPostRender(cameraPass);\n\t\t\t\t\tlayer._postRenderCalledForCameras |= 1 << cameraPass;\n\t\t\t\t\tlayer._postRenderCounter = layer._postRenderCounterMax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nlet keyA, keyB, sortPos, sortDir;\n\nfunction sortManual(drawCallA, drawCallB) {\n\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n}\n\nfunction sortMaterialMesh(drawCallA, drawCallB) {\n\tkeyA = drawCallA._key[SORTKEY_FORWARD];\n\tkeyB = drawCallB._key[SORTKEY_FORWARD];\n\n\tif (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {\n\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t}\n\n\treturn keyB - keyA;\n}\n\nfunction sortBackToFront(drawCallA, drawCallB) {\n\treturn drawCallB.zdist - drawCallA.zdist;\n}\n\nfunction sortFrontToBack(drawCallA, drawCallB) {\n\treturn drawCallA.zdist - drawCallB.zdist;\n}\n\nconst sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];\n\nfunction sortLights(lightA, lightB) {\n\treturn lightB.key - lightA.key;\n}\n\nlet layerCounter = 0;\n\nclass VisibleInstanceList {\n\tconstructor() {\n\t\tthis.list = [];\n\t\tthis.length = 0;\n\t\tthis.done = false;\n\t}\n\n}\n\nclass InstanceList {\n\tconstructor() {\n\t\tthis.opaqueMeshInstances = [];\n\t\tthis.transparentMeshInstances = [];\n\t\tthis.shadowCasters = [];\n\t\tthis.visibleOpaque = [];\n\t\tthis.visibleTransparent = [];\n\t}\n\n\tprepare(index) {\n\t\tif (!this.visibleOpaque[index]) {\n\t\t\tthis.visibleOpaque[index] = new VisibleInstanceList();\n\t\t}\n\n\t\tif (!this.visibleTransparent[index]) {\n\t\t\tthis.visibleTransparent[index] = new VisibleInstanceList();\n\t\t}\n\n\t\tthis.visibleOpaque[index].done = false;\n\t\tthis.visibleTransparent[index].done = false;\n\t}\n\n\tdelete(index) {\n\t\tif (index < this.visibleOpaque.length) {\n\t\t\tthis.visibleOpaque.splice(index, 1);\n\t\t}\n\n\t\tif (index < this.visibleTransparent.length) {\n\t\t\tthis.visibleTransparent.splice(index, 1);\n\t\t}\n\t}\n\n}\n\nclass Layer {\n\tconstructor(options = {}) {\n\t\tif (options.id !== undefined) {\n\t\t\tthis.id = options.id;\n\t\t\tlayerCounter = Math.max(this.id + 1, layerCounter);\n\t\t} else {\n\t\t\tthis.id = layerCounter++;\n\t\t}\n\n\t\tthis.name = options.name;\n\t\tthis._enabled = options.enabled === undefined ? true : options.enabled;\n\t\tthis._refCounter = this._enabled ? 1 : 0;\n\t\tthis.opaqueSortMode = options.opaqueSortMode === undefined ? SORTMODE_MATERIALMESH : options.opaqueSortMode;\n\t\tthis.transparentSortMode = options.transparentSortMode === undefined ? SORTMODE_BACK2FRONT : options.transparentSortMode;\n\t\tthis.renderTarget = options.renderTarget;\n\t\tthis.shaderPass = options.shaderPass === undefined ? SHADER_FORWARD : options.shaderPass;\n\t\tthis.passThrough = options.passThrough === undefined ? false : options.passThrough;\n\t\tthis._clearColorBuffer = options.clearColorBuffer ? options.clearColorBuffer : false;\n\t\tthis._clearDepthBuffer = options.clearDepthBuffer ? options.clearDepthBuffer : false;\n\t\tthis._clearStencilBuffer = options.clearStencilBuffer ? options.clearStencilBuffer : false;\n\t\tthis.onPreCull = options.onPreCull;\n\t\tthis.onPreRender = options.onPreRender;\n\t\tthis.onPreRenderOpaque = options.onPreRenderOpaque;\n\t\tthis.onPreRenderTransparent = options.onPreRenderTransparent;\n\t\tthis.onPostCull = options.onPostCull;\n\t\tthis.onPostRender = options.onPostRender;\n\t\tthis.onPostRenderOpaque = options.onPostRenderOpaque;\n\t\tthis.onPostRenderTransparent = options.onPostRenderTransparent;\n\t\tthis.onDrawCall = options.onDrawCall;\n\t\tthis.onEnable = options.onEnable;\n\t\tthis.onDisable = options.onDisable;\n\n\t\tif (this._enabled && this.onEnable) {\n\t\t\tthis.onEnable();\n\t\t}\n\n\t\tthis.layerReference = options.layerReference;\n\t\tthis.instances = options.layerReference ? options.layerReference.instances : new InstanceList();\n\t\tthis.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;\n\t\tthis.opaqueMeshInstances = this.instances.opaqueMeshInstances;\n\t\tthis.transparentMeshInstances = this.instances.transparentMeshInstances;\n\t\tthis.shadowCasters = this.instances.shadowCasters;\n\t\tthis.customSortCallback = null;\n\t\tthis.customCalculateSortValues = null;\n\t\tthis._lights = [];\n\t\tthis._lightsSet = new Set();\n\t\tthis._clusteredLightsSet = new Set();\n\t\tthis._splitLights = [[], [], []];\n\t\tthis.cameras = [];\n\t\tthis._dirty = false;\n\t\tthis._dirtyLights = false;\n\t\tthis._dirtyCameras = false;\n\t\tthis._lightHash = 0;\n\t\tthis._staticLightHash = 0;\n\t\tthis._needsStaticPrepare = true;\n\t\tthis._staticPrepareDone = false;\n\t\tthis._shaderVersion = -1;\n\t\tthis._lightCube = null;\n\t}\n\n\tset renderTarget(rt) {\n\t\tthis._renderTarget = rt;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tget renderTarget() {\n\t\treturn this._renderTarget;\n\t}\n\n\tset enabled(val) {\n\t\tif (val !== this._enabled) {\n\t\t\tthis._enabled = val;\n\n\t\t\tif (val) {\n\t\t\t\tthis.incrementCounter();\n\t\t\t\tif (this.onEnable) this.onEnable();\n\t\t\t} else {\n\t\t\t\tthis.decrementCounter();\n\t\t\t\tif (this.onDisable) this.onDisable();\n\t\t\t}\n\t\t}\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tset clearColor(val) {\n\t\tthis._clearColor.copy(val);\n\t}\n\n\tget clearColor() {\n\t\treturn this._clearColor;\n\t}\n\n\tset clearColorBuffer(val) {\n\t\tthis._clearColorBuffer = val;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tget clearColorBuffer() {\n\t\treturn this._clearColorBuffer;\n\t}\n\n\tset clearDepthBuffer(val) {\n\t\tthis._clearDepthBuffer = val;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tget clearDepthBuffer() {\n\t\treturn this._clearDepthBuffer;\n\t}\n\n\tset clearStencilBuffer(val) {\n\t\tthis._clearStencilBuffer = val;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tget clearStencilBuffer() {\n\t\treturn this._clearStencilBuffer;\n\t}\n\n\tincrementCounter() {\n\t\tif (this._refCounter === 0) {\n\t\t\tthis._enabled = true;\n\t\t\tif (this.onEnable) this.onEnable();\n\t\t}\n\n\t\tthis._refCounter++;\n\t}\n\n\tdecrementCounter() {\n\t\tif (this._refCounter === 1) {\n\t\t\tthis._enabled = false;\n\t\t\tif (this.onDisable) this.onDisable();\n\t\t} else if (this._refCounter === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._refCounter--;\n\t}\n\n\taddMeshInstances(meshInstances, skipShadowCasters) {\n\t\tconst sceneShaderVer = this._shaderVersion;\n\t\tconst casters = this.shadowCasters;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst m = meshInstances[i];\n\t\t\tconst mat = m.material;\n\t\t\tconst arr = mat.blendType === BLEND_NONE ? this.opaqueMeshInstances : this.transparentMeshInstances;\n\n\t\t\tif (this.opaqueMeshInstances.indexOf(m) < 0 && this.transparentMeshInstances.indexOf(m) < 0) {\n\t\t\t\tarr.push(m);\n\t\t\t}\n\n\t\t\tif (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);\n\n\t\t\tif (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {\n\t\t\t\tif (mat.updateShader !== Material.prototype.updateShader) {\n\t\t\t\t\tmat.clearVariants();\n\t\t\t\t\tmat.shader = null;\n\t\t\t\t}\n\n\t\t\t\tmat._shaderVersion = sceneShaderVer;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.passThrough) this._dirty = true;\n\t}\n\n\tremoveMeshInstanceFromArray(m, arr) {\n\t\tlet spliceOffset = -1;\n\t\tlet spliceCount = 0;\n\t\tconst len = arr.length;\n\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tconst drawCall = arr[j];\n\n\t\t\tif (drawCall === m) {\n\t\t\t\tspliceOffset = j;\n\t\t\t\tspliceCount = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (drawCall._staticSource === m) {\n\t\t\t\tif (spliceOffset < 0) spliceOffset = j;\n\t\t\t\tspliceCount++;\n\t\t\t} else if (spliceOffset >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (spliceOffset >= 0) {\n\t\t\tarr.splice(spliceOffset, spliceCount);\n\t\t}\n\t}\n\n\tremoveMeshInstances(meshInstances, skipShadowCasters) {\n\t\tconst opaque = this.opaqueMeshInstances;\n\t\tconst transparent = this.transparentMeshInstances;\n\t\tconst casters = this.shadowCasters;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst m = meshInstances[i];\n\t\t\tthis.removeMeshInstanceFromArray(m, opaque);\n\t\t\tthis.removeMeshInstanceFromArray(m, transparent);\n\n\t\t\tif (!skipShadowCasters) {\n\t\t\t\tconst j = casters.indexOf(m);\n\t\t\t\tif (j >= 0) casters.splice(j, 1);\n\t\t\t}\n\t\t}\n\n\t\tthis._dirty = true;\n\t}\n\n\tclearMeshInstances(skipShadowCasters) {\n\t\tif (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {\n\t\t\tif (skipShadowCasters || this.shadowCasters.length === 0) return;\n\t\t}\n\n\t\tthis.opaqueMeshInstances.length = 0;\n\t\tthis.transparentMeshInstances.length = 0;\n\t\tif (!skipShadowCasters) this.shadowCasters.length = 0;\n\t\tif (!this.passThrough) this._dirty = true;\n\t}\n\n\taddLight(light) {\n\t\tconst l = light.light;\n\n\t\tif (!this._lightsSet.has(l)) {\n\t\t\tthis._lightsSet.add(l);\n\n\t\t\tif (l.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tthis._clusteredLightsSet.add(l);\n\t\t\t}\n\n\t\t\tthis._lights.push(l);\n\n\t\t\tthis._dirtyLights = true;\n\n\t\t\tthis._generateLightHash();\n\t\t}\n\t}\n\n\tremoveLight(light) {\n\t\tconst l = light.light;\n\n\t\tif (this._lightsSet.has(l)) {\n\t\t\tthis._lightsSet.delete(l);\n\n\t\t\tif (l.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tthis._clusteredLightsSet.delete(l);\n\t\t\t}\n\n\t\t\tthis._lights.splice(this._lights.indexOf(l), 1);\n\n\t\t\tthis._dirtyLights = true;\n\n\t\t\tthis._generateLightHash();\n\t\t}\n\t}\n\n\tclearLights() {\n\t\tthis._lightsSet.clear();\n\n\t\tthis._clusteredLightsSet.clear();\n\n\t\tthis._lights.length = 0;\n\t\tthis._dirtyLights = true;\n\t}\n\n\tget clusteredLightsSet() {\n\t\treturn this._clusteredLightsSet;\n\t}\n\n\taddShadowCasters(meshInstances) {\n\t\tconst arr = this.shadowCasters;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst m = meshInstances[i];\n\t\t\tif (!m.castShadow) continue;\n\t\t\tif (arr.indexOf(m) < 0) arr.push(m);\n\t\t}\n\n\t\tthis._dirtyLights = true;\n\t}\n\n\tremoveShadowCasters(meshInstances) {\n\t\tconst arr = this.shadowCasters;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst id = arr.indexOf(meshInstances[i]);\n\t\t\tif (id >= 0) arr.splice(id, 1);\n\t\t}\n\n\t\tthis._dirtyLights = true;\n\t}\n\n\t_generateLightHash() {\n\t\tif (this._lights.length > 0) {\n\t\t\tthis._lights.sort(sortLights);\n\n\t\t\tlet str = \"\";\n\t\t\tlet strStatic = \"\";\n\n\t\t\tfor (let i = 0; i < this._lights.length; i++) {\n\t\t\t\tif (this._lights[i].isStatic) {\n\t\t\t\t\tstrStatic += this._lights[i].key;\n\t\t\t\t} else {\n\t\t\t\t\tstr += this._lights[i].key;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (str.length === 0) {\n\t\t\t\tthis._lightHash = 0;\n\t\t\t} else {\n\t\t\t\tthis._lightHash = hashCode(str);\n\t\t\t}\n\n\t\t\tif (strStatic.length === 0) {\n\t\t\t\tthis._staticLightHash = 0;\n\t\t\t} else {\n\t\t\t\tthis._staticLightHash = hashCode(strStatic);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._lightHash = 0;\n\t\t\tthis._staticLightHash = 0;\n\t\t}\n\t}\n\n\taddCamera(camera) {\n\t\tif (this.cameras.indexOf(camera) >= 0) return;\n\t\tthis.cameras.push(camera);\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tremoveCamera(camera) {\n\t\tconst index = this.cameras.indexOf(camera);\n\n\t\tif (index >= 0) {\n\t\t\tthis.cameras.splice(index, 1);\n\t\t\tthis._dirtyCameras = true;\n\t\t\tthis.instances.delete(index);\n\t\t}\n\t}\n\n\tclearCameras() {\n\t\tthis.cameras.length = 0;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\t_calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\t\t\tif (drawCall.command) continue;\n\t\t\tif (drawCall.layer <= LAYER_FX) continue;\n\n\t\t\tif (drawCall.calculateSortDistance) {\n\t\t\t\tdrawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst meshPos = drawCall.aabb.center;\n\t\t\tconst tempx = meshPos.x - camPos.x;\n\t\t\tconst tempy = meshPos.y - camPos.y;\n\t\t\tconst tempz = meshPos.z - camPos.z;\n\t\t\tdrawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;\n\t\t}\n\t}\n\n\t_sortVisible(transparent, cameraNode, cameraPass) {\n\t\tconst objects = this.instances;\n\t\tconst sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;\n\t\tif (sortMode === SORTMODE_NONE) return;\n\t\tconst visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n\n\t\tif (sortMode === SORTMODE_CUSTOM) {\n\t\t\tsortPos = cameraNode.getPosition();\n\t\t\tsortDir = cameraNode.forward;\n\n\t\t\tif (this.customCalculateSortValues) {\n\t\t\t\tthis.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);\n\t\t\t}\n\n\t\t\tif (visible.list.length !== visible.length) {\n\t\t\t\tvisible.list.length = visible.length;\n\t\t\t}\n\n\t\t\tif (this.customSortCallback) {\n\t\t\t\tvisible.list.sort(this.customSortCallback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {\n\t\t\t\tsortPos = cameraNode.getPosition();\n\t\t\t\tsortDir = cameraNode.forward;\n\n\t\t\t\tthis._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);\n\t\t\t}\n\n\t\t\tif (visible.list.length !== visible.length) {\n\t\t\t\tvisible.list.length = visible.length;\n\t\t\t}\n\n\t\t\tvisible.list.sort(sortCallbacks[sortMode]);\n\t\t}\n\t}\n\n}\n\nconst set = {\n\tequals: function (set1, set2) {\n\t\tif (set1.size !== set2.size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const item of set1) {\n\t\t\tif (!set2.has(item)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n\nclass RenderAction {\n\tconstructor() {\n\t\tthis.layerIndex = 0;\n\t\tthis.cameraIndex = 0;\n\t\tthis.camera = null;\n\t\tthis.renderTarget = null;\n\t\tthis.lightClusters = null;\n\t\tthis.clearColor = false;\n\t\tthis.clearDepth = false;\n\t\tthis.clearStencil = false;\n\t\tthis.triggerPostprocess = false;\n\t\tthis.firstCameraUse = false;\n\t\tthis.lastCameraUse = false;\n\t\tthis.directionalLightsSet = new Set();\n\t\tthis.directionalLights = [];\n\t\tthis.directionalLightsIndices = [];\n\t}\n\n\treset() {\n\t\tthis.lightClusters = null;\n\t\tthis.directionalLightsSet.clear();\n\t\tthis.directionalLights.length = 0;\n\t\tthis.directionalLightsIndices.length = 0;\n\t}\n\n\tcollectDirectionalLights(cameraLayers, dirLights, allLights) {\n\t\tthis.directionalLightsSet.clear();\n\t\tthis.directionalLights.length = 0;\n\t\tthis.directionalLightsIndices.length = 0;\n\n\t\tfor (let i = 0; i < dirLights.length; i++) {\n\t\t\tconst light = dirLights[i];\n\n\t\t\tif (light.castShadows) {\n\t\t\t\tfor (let l = 0; l < cameraLayers.length; l++) {\n\t\t\t\t\tif (cameraLayers[l]._splitLights[LIGHTTYPE_DIRECTIONAL].indexOf(light) >= 0) {\n\t\t\t\t\t\tif (!this.directionalLightsSet.has(light)) {\n\t\t\t\t\t\t\tthis.directionalLightsSet.add(light);\n\t\t\t\t\t\t\tthis.directionalLights.push(light);\n\t\t\t\t\t\t\tconst lightIndex = allLights.indexOf(light);\n\t\t\t\t\t\t\tthis.directionalLightsIndices.push(lightIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass LightCompositionData {\n\tconstructor() {\n\t\tthis.shadowCastersSet = new Set();\n\t\tthis.shadowCastersList = [];\n\t}\n\n\tclearShadowCasters() {\n\t\tthis.shadowCastersSet.clear();\n\t\tthis.shadowCastersList.length = 0;\n\t}\n\n\taddShadowCasters(casters) {\n\t\tfor (let i = 0; i < casters.length; i++) {\n\t\t\tconst item = casters[i];\n\n\t\t\tif (!this.shadowCastersSet.has(item)) {\n\t\t\t\tthis.shadowCastersSet.add(item);\n\t\t\t\tthis.shadowCastersList.push(item);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nconst tempSet$1 = new Set();\nconst tempClusterArray = [];\n\nclass LayerComposition extends EventHandler {\n\tconstructor(name = \"Untitled\") {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.logRenderActions = false;\n\t\tthis.layerList = [];\n\t\tthis.subLayerList = [];\n\t\tthis.subLayerEnabled = [];\n\t\tthis._opaqueOrder = {};\n\t\tthis._transparentOrder = {};\n\t\tthis._dirty = false;\n\t\tthis._dirtyBlend = false;\n\t\tthis._dirtyLights = false;\n\t\tthis._dirtyCameras = false;\n\t\tthis._meshInstances = [];\n\t\tthis._meshInstancesSet = new Set();\n\t\tthis._lights = [];\n\t\tthis._lightsMap = new Map();\n\t\tthis._lightCompositionData = [];\n\t\tthis._splitLights = [[], [], []];\n\t\tthis.cameras = [];\n\t\tthis._renderActions = [];\n\t\tthis._worldClusters = [];\n\t\tthis._emptyWorldClusters = null;\n\t}\n\n\tdestroy() {\n\t\tif (this._emptyWorldClusters) {\n\t\t\tthis._emptyWorldClusters.destroy();\n\n\t\t\tthis._emptyWorldClusters = null;\n\t\t}\n\n\t\tthis._worldClusters.forEach(cluster => {\n\t\t\tcluster.destroy();\n\t\t});\n\n\t\tthis._worldClusters = null;\n\t}\n\n\tgetEmptyWorldClusters(device) {\n\t\tif (!this._emptyWorldClusters) {\n\t\t\tthis._emptyWorldClusters = new WorldClusters(device);\n\t\t\tthis._emptyWorldClusters.name = \"ClusterEmpty\";\n\n\t\t\tthis._emptyWorldClusters.update([], false, null);\n\t\t}\n\n\t\treturn this._emptyWorldClusters;\n\t}\n\n\t_splitLightsArray(target) {\n\t\tconst lights = target._lights;\n\t\ttarget._splitLights[LIGHTTYPE_DIRECTIONAL].length = 0;\n\t\ttarget._splitLights[LIGHTTYPE_OMNI].length = 0;\n\t\ttarget._splitLights[LIGHTTYPE_SPOT].length = 0;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\n\t\t\tif (light.enabled) {\n\t\t\t\ttarget._splitLights[light._type].push(light);\n\t\t\t}\n\t\t}\n\t}\n\n\t_update(device, clusteredLightingEnabled = false) {\n\t\tconst len = this.layerList.length;\n\t\tlet result = 0;\n\n\t\tif (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\n\t\t\t\tif (layer._dirty) {\n\t\t\t\t\tthis._dirty = true;\n\t\t\t\t}\n\n\t\t\t\tif (layer._dirtyLights) {\n\t\t\t\t\tthis._dirtyLights = true;\n\t\t\t\t}\n\n\t\t\t\tif (layer._dirtyCameras) {\n\t\t\t\t\tthis._dirtyCameras = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction addUniqueMeshInstance(destArray, destSet, srcArray) {\n\t\t\tlet dirtyBlend = false;\n\t\t\tconst srcLen = srcArray.length;\n\n\t\t\tfor (let s = 0; s < srcLen; s++) {\n\t\t\t\tconst meshInst = srcArray[s];\n\n\t\t\t\tif (!destSet.has(meshInst)) {\n\t\t\t\t\tdestSet.add(meshInst);\n\t\t\t\t\tdestArray.push(meshInst);\n\t\t\t\t\tconst material = meshInst.material;\n\n\t\t\t\t\tif (material && material._dirtyBlend) {\n\t\t\t\t\t\tdirtyBlend = true;\n\t\t\t\t\t\tmaterial._dirtyBlend = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dirtyBlend;\n\t\t}\n\n\t\tif (this._dirty) {\n\t\t\tresult |= COMPUPDATED_INSTANCES;\n\t\t\tthis._meshInstances.length = 0;\n\n\t\t\tthis._meshInstancesSet.clear();\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\n\t\t\t\tif (!layer.passThrough) {\n\t\t\t\t\tthis._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.opaqueMeshInstances) || this._dirtyBlend;\n\t\t\t\t\tthis._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.transparentMeshInstances) || this._dirtyBlend;\n\t\t\t\t}\n\n\t\t\t\tlayer._dirty = false;\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tfunction moveByBlendType(dest, src, moveTransparent) {\n\t\t\tfor (let s = 0; s < src.length;) {\n\t\t\t\tvar _src$s$material;\n\n\t\t\t\tif (((_src$s$material = src[s].material) == null ? void 0 : _src$s$material.transparent) === moveTransparent) {\n\t\t\t\t\tdest.push(src[s]);\n\t\t\t\t\tsrc[s] = src[src.length - 1];\n\t\t\t\t\tsrc.length--;\n\t\t\t\t} else {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._dirtyBlend) {\n\t\t\tresult |= COMPUPDATED_BLEND;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\n\t\t\t\tif (!layer.passThrough) {\n\t\t\t\t\tmoveByBlendType(layer.opaqueMeshInstances, layer.transparentMeshInstances, false);\n\t\t\t\t\tmoveByBlendType(layer.transparentMeshInstances, layer.opaqueMeshInstances, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirtyBlend = false;\n\t\t}\n\n\t\tif (this._dirtyLights) {\n\t\t\tresult |= COMPUPDATED_LIGHTS;\n\t\t\tthis._dirtyLights = false;\n\t\t\tthis.updateLights();\n\t\t}\n\n\t\tif (result) {\n\t\t\tthis.updateShadowCasters();\n\t\t}\n\n\t\tif (this._dirtyCameras || result & COMPUPDATED_LIGHTS) {\n\t\t\tthis._dirtyCameras = false;\n\t\t\tresult |= COMPUPDATED_CAMERAS;\n\t\t\tthis.cameras.length = 0;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\t\t\t\tlayer._dirtyCameras = false;\n\n\t\t\t\tfor (let j = 0; j < layer.cameras.length; j++) {\n\t\t\t\t\tconst camera = layer.cameras[j];\n\t\t\t\t\tconst index = this.cameras.indexOf(camera);\n\n\t\t\t\t\tif (index < 0) {\n\t\t\t\t\t\tthis.cameras.push(camera);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.cameras.length > 1) {\n\t\t\t\tthis.cameras.sort((a, b) => a.priority - b.priority);\n\t\t\t}\n\n\t\t\tconst cameraLayers = [];\n\t\t\tlet renderActionCount = 0;\n\n\t\t\tfor (let i = 0; i < this.cameras.length; i++) {\n\t\t\t\tconst camera = this.cameras[i];\n\t\t\t\tcameraLayers.length = 0;\n\t\t\t\tlet cameraFirstRenderAction = true;\n\t\t\t\tconst cameraFirstRenderActionIndex = renderActionCount;\n\t\t\t\tlet lastRenderAction = null;\n\t\t\t\tlet postProcessMarked = false;\n\n\t\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\t\tconst layer = this.layerList[j];\n\n\t\t\t\t\tif (layer) {\n\t\t\t\t\t\tif (layer.cameras.length > 0) {\n\t\t\t\t\t\t\tif (camera.layers.indexOf(layer.id) >= 0) {\n\t\t\t\t\t\t\t\tcameraLayers.push(layer);\n\n\t\t\t\t\t\t\t\tif (!postProcessMarked && layer.id === camera.disablePostEffectsLayer) {\n\t\t\t\t\t\t\t\t\tpostProcessMarked = true;\n\n\t\t\t\t\t\t\t\t\tif (lastRenderAction) {\n\t\t\t\t\t\t\t\t\t\tlastRenderAction.triggerPostprocess = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst cameraIndex = layer.cameras.indexOf(camera);\n\n\t\t\t\t\t\t\t\tif (cameraIndex >= 0) {\n\t\t\t\t\t\t\t\t\tlastRenderAction = this.addRenderAction(this._renderActions, renderActionCount, layer, j, cameraIndex, cameraFirstRenderAction, postProcessMarked);\n\t\t\t\t\t\t\t\t\trenderActionCount++;\n\t\t\t\t\t\t\t\t\tcameraFirstRenderAction = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cameraFirstRenderActionIndex < renderActionCount) {\n\t\t\t\t\tthis._renderActions[cameraFirstRenderActionIndex].collectDirectionalLights(cameraLayers, this._splitLights[LIGHTTYPE_DIRECTIONAL], this._lights);\n\n\t\t\t\t\tlastRenderAction.lastCameraUse = true;\n\t\t\t\t}\n\n\t\t\t\tif (!postProcessMarked && lastRenderAction) {\n\t\t\t\t\tlastRenderAction.triggerPostprocess = true;\n\t\t\t\t}\n\n\t\t\t\tif (camera.renderTarget && camera.postEffectsEnabled) {\n\t\t\t\t\tthis.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._renderActions.length = renderActionCount;\n\n\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\tthis.allocateLightClusters(device);\n\t\t\t}\n\t\t}\n\n\t\tif (result & COMPUPDATED_LIGHTS || result & COMPUPDATED_CAMERAS) {\n\t\t\tthis._logRenderActions();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tupdateShadowCasters() {\n\t\tconst lightCount = this._lights.length;\n\n\t\tfor (let i = 0; i < lightCount; i++) {\n\t\t\tthis._lightCompositionData[i].clearShadowCasters();\n\t\t}\n\n\t\tconst len = this.layerList.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst layer = this.layerList[i];\n\n\t\t\tif (!tempSet$1.has(layer)) {\n\t\t\t\ttempSet$1.add(layer);\n\t\t\t\tconst lights = layer._lights;\n\n\t\t\t\tfor (let j = 0; j < lights.length; j++) {\n\t\t\t\t\tif (lights[j].castShadows) {\n\t\t\t\t\t\tconst lightIndex = this._lightsMap.get(lights[j]);\n\n\t\t\t\t\t\tconst lightCompData = this._lightCompositionData[lightIndex];\n\t\t\t\t\t\tlightCompData.addShadowCasters(layer.shadowCasters);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttempSet$1.clear();\n\t}\n\n\tupdateLights() {\n\t\tthis._lights.length = 0;\n\n\t\tthis._lightsMap.clear();\n\n\t\tconst count = this.layerList.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst layer = this.layerList[i];\n\n\t\t\tif (!tempSet$1.has(layer)) {\n\t\t\t\ttempSet$1.add(layer);\n\t\t\t\tconst lights = layer._lights;\n\n\t\t\t\tfor (let j = 0; j < lights.length; j++) {\n\t\t\t\t\tconst light = lights[j];\n\n\t\t\t\t\tlet lightIndex = this._lightsMap.get(light);\n\n\t\t\t\t\tif (lightIndex === undefined) {\n\t\t\t\t\t\tlightIndex = this._lights.length;\n\n\t\t\t\t\t\tthis._lightsMap.set(light, lightIndex);\n\n\t\t\t\t\t\tthis._lights.push(light);\n\n\t\t\t\t\t\tlet lightCompData = this._lightCompositionData[lightIndex];\n\n\t\t\t\t\t\tif (!lightCompData) {\n\t\t\t\t\t\t\tlightCompData = new LightCompositionData();\n\t\t\t\t\t\t\tthis._lightCompositionData[lightIndex] = lightCompData;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._splitLightsArray(layer);\n\n\t\t\tlayer._dirtyLights = false;\n\t\t}\n\n\t\ttempSet$1.clear();\n\n\t\tthis._splitLightsArray(this);\n\n\t\tconst lightCount = this._lights.length;\n\t\tthis._lightCompositionData.length = lightCount;\n\t}\n\n\tfindCompatibleCluster(layer, renderActionCount) {\n\t\tfor (let i = 0; i < renderActionCount; i++) {\n\t\t\tconst ra = this._renderActions[i];\n\t\t\tconst raLayer = this.layerList[ra.layerIndex];\n\n\t\t\tif (layer === raLayer) {\n\t\t\t\treturn ra.lightClusters;\n\t\t\t}\n\n\t\t\tif (ra.lightClusters) {\n\t\t\t\tif (set.equals(layer._clusteredLightsSet, raLayer._clusteredLightsSet)) {\n\t\t\t\t\treturn ra.lightClusters;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tallocateLightClusters(device) {\n\t\ttempClusterArray.push(...this._worldClusters);\n\t\tthis._worldClusters.length = 0;\n\t\tconst count = this._renderActions.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst ra = this._renderActions[i];\n\t\t\tconst layer = this.layerList[ra.layerIndex];\n\n\t\t\tif (layer._clusteredLightsSet.size) {\n\t\t\t\tconst transparent = this.subLayerList[ra.layerIndex];\n\t\t\t\tconst meshInstances = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;\n\n\t\t\t\tif (meshInstances.length) {\n\t\t\t\t\tlet clusters = this.findCompatibleCluster(layer, i);\n\n\t\t\t\t\tif (!clusters) {\n\t\t\t\t\t\tif (tempClusterArray.length) {\n\t\t\t\t\t\t\tclusters = tempClusterArray.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!clusters) {\n\t\t\t\t\t\t\tclusters = new WorldClusters(device);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclusters.name = \"Cluster-\" + this._worldClusters.length;\n\n\t\t\t\t\t\tthis._worldClusters.push(clusters);\n\t\t\t\t\t}\n\n\t\t\t\t\tra.lightClusters = clusters;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ra.lightClusters) {\n\t\t\t\tra.lightClusters = this.getEmptyWorldClusters(device);\n\t\t\t}\n\t\t}\n\n\t\ttempClusterArray.forEach(item => {\n\t\t\titem.destroy();\n\t\t});\n\t\ttempClusterArray.length = 0;\n\t}\n\n\taddRenderAction(renderActions, renderActionIndex, layer, layerIndex, cameraIndex, cameraFirstRenderAction, postProcessMarked) {\n\t\tlet renderAction = renderActions[renderActionIndex];\n\n\t\tif (!renderAction) {\n\t\t\trenderAction = renderActions[renderActionIndex] = new RenderAction();\n\t\t}\n\n\t\tlet rt = layer.renderTarget;\n\t\tconst camera = layer.cameras[cameraIndex];\n\n\t\tif (camera && camera.renderTarget) {\n\t\t\tif (layer.id !== LAYERID_DEPTH) {\n\t\t\t\trt = camera.renderTarget;\n\t\t\t}\n\t\t}\n\n\t\tlet used = false;\n\n\t\tfor (let i = renderActionIndex - 1; i >= 0; i--) {\n\t\t\tif (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {\n\t\t\t\tused = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst needsClear = cameraFirstRenderAction || !used;\n\t\tlet clearColor = needsClear ? camera.clearColorBuffer : false;\n\t\tlet clearDepth = needsClear ? camera.clearDepthBuffer : false;\n\t\tlet clearStencil = needsClear ? camera.clearStencilBuffer : false;\n\t\tclearColor |= layer.clearColorBuffer;\n\t\tclearDepth |= layer.clearDepthBuffer;\n\t\tclearStencil |= layer.clearStencilBuffer;\n\n\t\tif (postProcessMarked && camera.postEffectsEnabled) {\n\t\t\trt = null;\n\t\t}\n\n\t\trenderAction.reset();\n\t\trenderAction.triggerPostprocess = false;\n\t\trenderAction.layerIndex = layerIndex;\n\t\trenderAction.cameraIndex = cameraIndex;\n\t\trenderAction.camera = camera;\n\t\trenderAction.renderTarget = rt;\n\t\trenderAction.clearColor = clearColor;\n\t\trenderAction.clearDepth = clearDepth;\n\t\trenderAction.clearStencil = clearStencil;\n\t\trenderAction.firstCameraUse = cameraFirstRenderAction;\n\t\trenderAction.lastCameraUse = false;\n\t\treturn renderAction;\n\t}\n\n\tpropagateRenderTarget(startIndex, fromCamera) {\n\t\tfor (let a = startIndex; a >= 0; a--) {\n\t\t\tconst ra = this._renderActions[a];\n\t\t\tconst layer = this.layerList[ra.layerIndex];\n\n\t\t\tif (ra.renderTarget && layer.id !== LAYERID_DEPTH) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (layer.id === LAYERID_DEPTH) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst thisCamera = ra == null ? void 0 : ra.camera.camera;\n\n\t\t\tif (thisCamera) {\n\t\t\t\tif (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tra.renderTarget = fromCamera.renderTarget;\n\t\t}\n\t}\n\n\t_logRenderActions() {}\n\n\t_isLayerAdded(layer) {\n\t\tif (this.layerList.indexOf(layer) >= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_isSublayerAdded(layer, transparent) {\n\t\tfor (let i = 0; i < this.layerList.length; i++) {\n\t\t\tif (this.layerList[i] === layer && this.subLayerList[i] === transparent) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpush(layer) {\n\t\tif (this._isLayerAdded(layer)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis.layerList.push(layer);\n\t\tthis._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;\n\t\tthis._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tinsert(layer, index) {\n\t\tif (this._isLayerAdded(layer)) return;\n\t\tthis.layerList.splice(index, 0, layer, layer);\n\t\tthis.subLayerList.splice(index, 0, false, true);\n\t\tconst count = this.layerList.length;\n\n\t\tthis._updateOpaqueOrder(index, count - 1);\n\n\t\tthis._updateTransparentOrder(index, count - 1);\n\n\t\tthis.subLayerEnabled.splice(index, 0, true, true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tremove(layer) {\n\t\tlet id = this.layerList.indexOf(layer);\n\t\tdelete this._opaqueOrder[id];\n\t\tdelete this._transparentOrder[id];\n\n\t\twhile (id >= 0) {\n\t\t\tthis.layerList.splice(id, 1);\n\t\t\tthis.subLayerList.splice(id, 1);\n\t\t\tthis.subLayerEnabled.splice(id, 1);\n\t\t\tid = this.layerList.indexOf(layer);\n\t\t\tthis._dirty = true;\n\t\t\tthis._dirtyLights = true;\n\t\t\tthis._dirtyCameras = true;\n\t\t\tthis.fire(\"remove\", layer);\n\t\t}\n\n\t\tconst count = this.layerList.length;\n\n\t\tthis._updateOpaqueOrder(0, count - 1);\n\n\t\tthis._updateTransparentOrder(0, count - 1);\n\t}\n\n\tpushOpaque(layer) {\n\t\tif (this._isSublayerAdded(layer, false)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tinsertOpaque(layer, index) {\n\t\tif (this._isSublayerAdded(layer, false)) return;\n\t\tthis.layerList.splice(index, 0, layer);\n\t\tthis.subLayerList.splice(index, 0, false);\n\t\tconst count = this.subLayerList.length;\n\n\t\tthis._updateOpaqueOrder(index, count - 1);\n\n\t\tthis.subLayerEnabled.splice(index, 0, true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tremoveOpaque(layer) {\n\t\tfor (let i = 0, len = this.layerList.length; i < len; i++) {\n\t\t\tif (this.layerList[i] === layer && !this.subLayerList[i]) {\n\t\t\t\tthis.layerList.splice(i, 1);\n\t\t\t\tthis.subLayerList.splice(i, 1);\n\t\t\t\tlen--;\n\n\t\t\t\tthis._updateOpaqueOrder(i, len - 1);\n\n\t\t\t\tthis.subLayerEnabled.splice(i, 1);\n\t\t\t\tthis._dirty = true;\n\t\t\t\tthis._dirtyLights = true;\n\t\t\t\tthis._dirtyCameras = true;\n\n\t\t\t\tif (this.layerList.indexOf(layer) < 0) {\n\t\t\t\t\tthis.fire(\"remove\", layer);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpushTransparent(layer) {\n\t\tif (this._isSublayerAdded(layer, true)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tinsertTransparent(layer, index) {\n\t\tif (this._isSublayerAdded(layer, true)) return;\n\t\tthis.layerList.splice(index, 0, layer);\n\t\tthis.subLayerList.splice(index, 0, true);\n\t\tconst count = this.subLayerList.length;\n\n\t\tthis._updateTransparentOrder(index, count - 1);\n\n\t\tthis.subLayerEnabled.splice(index, 0, true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tremoveTransparent(layer) {\n\t\tfor (let i = 0, len = this.layerList.length; i < len; i++) {\n\t\t\tif (this.layerList[i] === layer && this.subLayerList[i]) {\n\t\t\t\tthis.layerList.splice(i, 1);\n\t\t\t\tthis.subLayerList.splice(i, 1);\n\t\t\t\tlen--;\n\n\t\t\t\tthis._updateTransparentOrder(i, len - 1);\n\n\t\t\t\tthis.subLayerEnabled.splice(i, 1);\n\t\t\t\tthis._dirty = true;\n\t\t\t\tthis._dirtyLights = true;\n\t\t\t\tthis._dirtyCameras = true;\n\n\t\t\t\tif (this.layerList.indexOf(layer) < 0) {\n\t\t\t\t\tthis.fire(\"remove\", layer);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t_getSublayerIndex(layer, transparent) {\n\t\tlet id = this.layerList.indexOf(layer);\n\t\tif (id < 0) return -1;\n\n\t\tif (this.subLayerList[id] !== transparent) {\n\t\t\tid = this.layerList.indexOf(layer, id + 1);\n\t\t\tif (id < 0) return -1;\n\n\t\t\tif (this.subLayerList[id] !== transparent) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\treturn id;\n\t}\n\n\tgetOpaqueIndex(layer) {\n\t\treturn this._getSublayerIndex(layer, false);\n\t}\n\n\tgetTransparentIndex(layer) {\n\t\treturn this._getSublayerIndex(layer, true);\n\t}\n\n\tgetLayerById(id) {\n\t\tfor (let i = 0; i < this.layerList.length; i++) {\n\t\t\tif (this.layerList[i].id === id) return this.layerList[i];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tgetLayerByName(name) {\n\t\tfor (let i = 0; i < this.layerList.length; i++) {\n\t\t\tif (this.layerList[i].name === name) return this.layerList[i];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_updateOpaqueOrder(startIndex, endIndex) {\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tif (this.subLayerList[i] === false) {\n\t\t\t\tthis._opaqueOrder[this.layerList[i].id] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateTransparentOrder(startIndex, endIndex) {\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tif (this.subLayerList[i] === true) {\n\t\t\t\tthis._transparentOrder[this.layerList[i].id] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t_sortLayersDescending(layersA, layersB, order) {\n\t\tlet topLayerA = -1;\n\t\tlet topLayerB = -1;\n\n\t\tfor (let i = 0, len = layersA.length; i < len; i++) {\n\t\t\tconst id = layersA[i];\n\n\t\t\tif (order.hasOwnProperty(id)) {\n\t\t\t\ttopLayerA = Math.max(topLayerA, order[id]);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = layersB.length; i < len; i++) {\n\t\t\tconst id = layersB[i];\n\n\t\t\tif (order.hasOwnProperty(id)) {\n\t\t\t\ttopLayerB = Math.max(topLayerB, order[id]);\n\t\t\t}\n\t\t}\n\n\t\tif (topLayerA === -1 && topLayerB !== -1) {\n\t\t\treturn 1;\n\t\t} else if (topLayerB === -1 && topLayerA !== -1) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn topLayerB - topLayerA;\n\t}\n\n\tsortTransparentLayers(layersA, layersB) {\n\t\treturn this._sortLayersDescending(layersA, layersB, this._transparentOrder);\n\t}\n\n\tsortOpaqueLayers(layersA, layersB) {\n\t\treturn this._sortLayersDescending(layersA, layersB, this._opaqueOrder);\n\t}\n\n}\n\nconst spotCenter = new Vec3();\nconst spotEndPoint = new Vec3();\nconst tmpVec = new Vec3();\nconst tmpBiases = {\n\tbias: 0,\n\tnormalBias: 0\n};\nconst chanId = {\n\tr: 0,\n\tg: 1,\n\tb: 2,\n\ta: 3\n};\nconst directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];\nlet id = 0;\n\nclass LightRenderData {\n\tconstructor(device, camera, face, light) {\n\t\tthis.light = light;\n\t\tthis.camera = camera;\n\t\tthis.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);\n\t\tthis.shadowMatrix = new Mat4();\n\t\tthis.shadowViewport = new Vec4(0, 0, 1, 1);\n\t\tthis.shadowScissor = new Vec4(0, 0, 1, 1);\n\t\tthis.face = face;\n\t\tthis.visibleCasters = [];\n\t}\n\n\tget shadowBuffer() {\n\t\tconst rt = this.shadowCamera.renderTarget;\n\n\t\tif (rt) {\n\t\t\tconst light = this.light;\n\n\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\treturn rt.colorBuffer;\n\t\t\t}\n\n\t\t\treturn light._isPcf && light.device.webgl2 ? rt.depthBuffer : rt.colorBuffer;\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n\nclass Light {\n\tconstructor(graphicsDevice) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.id = id++;\n\t\tthis._type = LIGHTTYPE_DIRECTIONAL;\n\t\tthis._color = new Color(0.8, 0.8, 0.8);\n\t\tthis._intensity = 1;\n\t\tthis._castShadows = false;\n\t\tthis._enabled = false;\n\t\tthis.mask = MASK_AFFECT_DYNAMIC;\n\t\tthis.isStatic = false;\n\t\tthis.key = 0;\n\t\tthis.bakeDir = true;\n\t\tthis.bakeNumSamples = 1;\n\t\tthis.bakeArea = 0;\n\t\tthis.attenuationStart = 10;\n\t\tthis.attenuationEnd = 10;\n\t\tthis._falloffMode = LIGHTFALLOFF_LINEAR;\n\t\tthis._shadowType = SHADOW_PCF3;\n\t\tthis._vsmBlurSize = 11;\n\t\tthis.vsmBlurMode = BLUR_GAUSSIAN;\n\t\tthis.vsmBias = 0.01 * 0.25;\n\t\tthis._cookie = null;\n\t\tthis.cookieIntensity = 1;\n\t\tthis._cookieFalloff = true;\n\t\tthis._cookieChannel = \"rgb\";\n\t\tthis._cookieTransform = null;\n\t\tthis._cookieTransformUniform = new Float32Array(4);\n\t\tthis._cookieOffset = null;\n\t\tthis._cookieOffsetUniform = new Float32Array(2);\n\t\tthis._cookieTransformSet = false;\n\t\tthis._cookieOffsetSet = false;\n\t\tthis._innerConeAngle = 40;\n\t\tthis._outerConeAngle = 45;\n\t\tthis.cascades = null;\n\t\tthis._shadowMatrixPalette = null;\n\t\tthis._shadowCascadeDistances = null;\n\t\tthis.numCascades = 1;\n\t\tthis.cascadeDistribution = 0.5;\n\t\tthis._shape = LIGHTSHAPE_PUNCTUAL;\n\t\tthis._finalColor = new Float32Array([0.8, 0.8, 0.8]);\n\t\tconst c = Math.pow(this._finalColor[0], 2.2);\n\t\tthis._linearFinalColor = new Float32Array([c, c, c]);\n\t\tthis._position = new Vec3(0, 0, 0);\n\t\tthis._direction = new Vec3(0, 0, 0);\n\t\tthis._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);\n\t\tthis._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);\n\t\tthis._shadowMap = null;\n\t\tthis._shadowRenderParams = [];\n\t\tthis.shadowDistance = 40;\n\t\tthis._shadowResolution = 1024;\n\t\tthis.shadowBias = -0.0005;\n\t\tthis._normalOffsetBias = 0.0;\n\t\tthis.shadowUpdateMode = SHADOWUPDATE_REALTIME;\n\t\tthis._isVsm = false;\n\t\tthis._isPcf = true;\n\t\tthis._cookieMatrix = null;\n\t\tthis._atlasViewport = null;\n\t\tthis.atlasViewportAllocated = false;\n\t\tthis.atlasVersion = 0;\n\t\tthis.atlasSlotIndex = 0;\n\t\tthis.atlasSlotUpdated = false;\n\t\tthis._scene = null;\n\t\tthis._node = null;\n\t\tthis._renderData = [];\n\t\tthis.visibleThisFrame = false;\n\t\tthis.maxScreenSize = 0;\n\t}\n\n\tdestroy() {\n\t\tthis._destroyShadowMap();\n\n\t\tthis._renderData = null;\n\t}\n\n\tset numCascades(value) {\n\t\tif (!this.cascades || this.numCascades != value) {\n\t\t\tthis.cascades = directionalCascades[value - 1];\n\t\t\tthis._shadowMatrixPalette = new Float32Array(4 * 16);\n\t\t\tthis._shadowCascadeDistances = new Float32Array(4);\n\n\t\t\tthis._destroyShadowMap();\n\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\n\tget numCascades() {\n\t\treturn this.cascades.length;\n\t}\n\n\tset shadowMap(shadowMap) {\n\t\tif (this._shadowMap !== shadowMap) {\n\t\t\tthis._destroyShadowMap();\n\n\t\t\tthis._shadowMap = shadowMap;\n\t\t}\n\t}\n\n\tget shadowMap() {\n\t\treturn this._shadowMap;\n\t}\n\n\tget numShadowFaces() {\n\t\tconst type = this._type;\n\n\t\tif (type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\treturn this.numCascades;\n\t\t} else if (type === LIGHTTYPE_OMNI) {\n\t\t\treturn 6;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tset type(value) {\n\t\tif (this._type === value) return;\n\t\tthis._type = value;\n\n\t\tthis._destroyShadowMap();\n\n\t\tthis.updateKey();\n\t\tconst stype = this._shadowType;\n\t\tthis._shadowType = null;\n\t\tthis.shadowType = stype;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset shape(value) {\n\t\tif (this._shape === value) return;\n\t\tthis._shape = value;\n\n\t\tthis._destroyShadowMap();\n\n\t\tthis.updateKey();\n\t\tconst stype = this._shadowType;\n\t\tthis._shadowType = null;\n\t\tthis.shadowType = stype;\n\t}\n\n\tget shape() {\n\t\treturn this._shape;\n\t}\n\n\tset shadowType(value) {\n\t\tif (this._shadowType === value) return;\n\t\tconst device = this.device;\n\t\tif (this._type === LIGHTTYPE_OMNI) value = SHADOW_PCF3;\n\n\t\tif (value === SHADOW_PCF5 && !device.webgl2) {\n\t\t\tvalue = SHADOW_PCF3;\n\t\t}\n\n\t\tif (value === SHADOW_VSM32 && !device.textureFloatRenderable) value = SHADOW_VSM16;\n\t\tif (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) value = SHADOW_VSM8;\n\t\tthis._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;\n\t\tthis._isPcf = value === SHADOW_PCF5 || value === SHADOW_PCF3;\n\t\tthis._shadowType = value;\n\n\t\tthis._destroyShadowMap();\n\n\t\tthis.updateKey();\n\t}\n\n\tget shadowType() {\n\t\treturn this._shadowType;\n\t}\n\n\tset enabled(value) {\n\t\tif (this._enabled !== value) {\n\t\t\tthis._enabled = value;\n\t\t\tthis.layersDirty();\n\t\t}\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tset castShadows(value) {\n\t\tif (this._castShadows !== value) {\n\t\t\tthis._castShadows = value;\n\n\t\t\tthis._destroyShadowMap();\n\n\t\t\tthis.layersDirty();\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\n\tget castShadows() {\n\t\treturn this._castShadows && this.mask !== MASK_BAKE && this.mask !== 0;\n\t}\n\n\tset shadowResolution(value) {\n\t\tif (this._shadowResolution !== value) {\n\t\t\tif (this._type === LIGHTTYPE_OMNI) {\n\t\t\t\tvalue = Math.min(value, this.device.maxCubeMapSize);\n\t\t\t} else {\n\t\t\t\tvalue = Math.min(value, this.device.maxTextureSize);\n\t\t\t}\n\n\t\t\tthis._shadowResolution = value;\n\n\t\t\tthis._destroyShadowMap();\n\t\t}\n\t}\n\n\tget shadowResolution() {\n\t\treturn this._shadowResolution;\n\t}\n\n\tset vsmBlurSize(value) {\n\t\tif (this._vsmBlurSize === value) return;\n\t\tif (value % 2 === 0) value++;\n\t\tthis._vsmBlurSize = value;\n\t}\n\n\tget vsmBlurSize() {\n\t\treturn this._vsmBlurSize;\n\t}\n\n\tset normalOffsetBias(value) {\n\t\tif (this._normalOffsetBias === value) return;\n\n\t\tif (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {\n\t\t\tthis.updateKey();\n\t\t}\n\n\t\tthis._normalOffsetBias = value;\n\t}\n\n\tget normalOffsetBias() {\n\t\treturn this._normalOffsetBias;\n\t}\n\n\tset falloffMode(value) {\n\t\tif (this._falloffMode === value) return;\n\t\tthis._falloffMode = value;\n\t\tthis.updateKey();\n\t}\n\n\tget falloffMode() {\n\t\treturn this._falloffMode;\n\t}\n\n\tset innerConeAngle(value) {\n\t\tif (this._innerConeAngle === value) return;\n\t\tthis._innerConeAngle = value;\n\t\tthis._innerConeAngleCos = Math.cos(value * Math.PI / 180);\n\t}\n\n\tget innerConeAngle() {\n\t\treturn this._innerConeAngle;\n\t}\n\n\tset outerConeAngle(value) {\n\t\tif (this._outerConeAngle === value) return;\n\t\tthis._outerConeAngle = value;\n\t\tthis._outerConeAngleCos = Math.cos(value * Math.PI / 180);\n\t}\n\n\tget outerConeAngle() {\n\t\treturn this._outerConeAngle;\n\t}\n\n\tset intensity(value) {\n\t\tif (this._intensity !== value) {\n\t\t\tthis._intensity = value;\n\n\t\t\tthis._updateFinalColor();\n\t\t}\n\t}\n\n\tget intensity() {\n\t\treturn this._intensity;\n\t}\n\n\tget cookieMatrix() {\n\t\tif (!this._cookieMatrix) {\n\t\t\tthis._cookieMatrix = new Mat4();\n\t\t}\n\n\t\treturn this._cookieMatrix;\n\t}\n\n\tget atlasViewport() {\n\t\tif (!this._atlasViewport) {\n\t\t\tthis._atlasViewport = new Vec4(0, 0, 1, 1);\n\t\t}\n\n\t\treturn this._atlasViewport;\n\t}\n\n\tset cookie(value) {\n\t\tif (this._cookie === value) return;\n\t\tthis._cookie = value;\n\t\tthis.updateKey();\n\t}\n\n\tget cookie() {\n\t\treturn this._cookie;\n\t}\n\n\tset cookieFalloff(value) {\n\t\tif (this._cookieFalloff === value) return;\n\t\tthis._cookieFalloff = value;\n\t\tthis.updateKey();\n\t}\n\n\tget cookieFalloff() {\n\t\treturn this._cookieFalloff;\n\t}\n\n\tset cookieChannel(value) {\n\t\tif (this._cookieChannel === value) return;\n\n\t\tif (value.length < 3) {\n\t\t\tconst chr = value.charAt(value.length - 1);\n\t\t\tconst addLen = 3 - value.length;\n\n\t\t\tfor (let i = 0; i < addLen; i++) value += chr;\n\t\t}\n\n\t\tthis._cookieChannel = value;\n\t\tthis.updateKey();\n\t}\n\n\tget cookieChannel() {\n\t\treturn this._cookieChannel;\n\t}\n\n\tset cookieTransform(value) {\n\t\tif (this._cookieTransform === value) return;\n\t\tthis._cookieTransform = value;\n\t\tthis._cookieTransformSet = !!value;\n\n\t\tif (value && !this._cookieOffset) {\n\t\t\tthis.cookieOffset = new Vec2();\n\t\t\tthis._cookieOffsetSet = false;\n\t\t}\n\n\t\tthis.updateKey();\n\t}\n\n\tget cookieTransform() {\n\t\treturn this._cookieTransform;\n\t}\n\n\tset cookieOffset(value) {\n\t\tif (this._cookieOffset === value) return;\n\t\tconst xformNew = !!(this._cookieTransformSet || value);\n\n\t\tif (xformNew && !value && this._cookieOffset) {\n\t\t\tthis._cookieOffset.set(0, 0);\n\t\t} else {\n\t\t\tthis._cookieOffset = value;\n\t\t}\n\n\t\tthis._cookieOffsetSet = !!value;\n\n\t\tif (value && !this._cookieTransform) {\n\t\t\tthis.cookieTransform = new Vec4(1, 1, 0, 0);\n\t\t\tthis._cookieTransformSet = false;\n\t\t}\n\n\t\tthis.updateKey();\n\t}\n\n\tget cookieOffset() {\n\t\treturn this._cookieOffset;\n\t}\n\n\tbeginFrame() {\n\t\tthis.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;\n\t\tthis.maxScreenSize = 0;\n\t\tthis.atlasViewportAllocated = false;\n\t\tthis.atlasSlotUpdated = false;\n\t}\n\n\t_destroyShadowMap() {\n\t\tif (this._renderData) {\n\t\t\tthis._renderData.length = 0;\n\t\t}\n\n\t\tif (this._shadowMap) {\n\t\t\tif (!this._shadowMap.cached) {\n\t\t\t\tthis._shadowMap.destroy();\n\t\t\t}\n\n\t\t\tthis._shadowMap = null;\n\t\t}\n\n\t\tif (this.shadowUpdateMode === SHADOWUPDATE_NONE) {\n\t\t\tthis.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t}\n\t}\n\n\tgetRenderData(camera, face) {\n\t\tfor (let i = 0; i < this._renderData.length; i++) {\n\t\t\tconst current = this._renderData[i];\n\n\t\t\tif (current.camera === camera && current.face === face) {\n\t\t\t\treturn current;\n\t\t\t}\n\t\t}\n\n\t\tconst rd = new LightRenderData(this.device, camera, face, this);\n\n\t\tthis._renderData.push(rd);\n\n\t\treturn rd;\n\t}\n\n\tclone() {\n\t\tconst clone = new Light(this.device);\n\t\tclone.type = this._type;\n\t\tclone.setColor(this._color);\n\t\tclone.intensity = this._intensity;\n\t\tclone.castShadows = this.castShadows;\n\t\tclone._enabled = this._enabled;\n\t\tclone.attenuationStart = this.attenuationStart;\n\t\tclone.attenuationEnd = this.attenuationEnd;\n\t\tclone.falloffMode = this._falloffMode;\n\t\tclone.shadowType = this._shadowType;\n\t\tclone.vsmBlurSize = this._vsmBlurSize;\n\t\tclone.vsmBlurMode = this.vsmBlurMode;\n\t\tclone.vsmBias = this.vsmBias;\n\t\tclone.shadowUpdateMode = this.shadowUpdateMode;\n\t\tclone.mask = this.mask;\n\t\tclone.innerConeAngle = this._innerConeAngle;\n\t\tclone.outerConeAngle = this._outerConeAngle;\n\t\tclone.numCascades = this.numCascades;\n\t\tclone.cascadeDistribution = this.cascadeDistribution;\n\t\tclone.shape = this._shape;\n\t\tclone.shadowBias = this.shadowBias;\n\t\tclone.normalOffsetBias = this._normalOffsetBias;\n\t\tclone.shadowResolution = this._shadowResolution;\n\t\tclone.shadowDistance = this.shadowDistance;\n\t\treturn clone;\n\t}\n\n\t_getUniformBiasValues(lightRenderData) {\n\t\tconst farClip = lightRenderData.shadowCamera._farClip;\n\n\t\tswitch (this._type) {\n\t\t\tcase LIGHTTYPE_OMNI:\n\t\t\t\ttmpBiases.bias = this.shadowBias;\n\t\t\t\ttmpBiases.normalBias = this._normalOffsetBias;\n\t\t\t\tbreak;\n\n\t\t\tcase LIGHTTYPE_SPOT:\n\t\t\t\tif (this._isVsm) {\n\t\t\t\t\ttmpBiases.bias = -0.00001 * 20;\n\t\t\t\t} else {\n\t\t\t\t\ttmpBiases.bias = this.shadowBias * 20;\n\t\t\t\t\tif (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;\n\t\t\t\t}\n\n\t\t\t\ttmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;\n\t\t\t\tbreak;\n\n\t\t\tcase LIGHTTYPE_DIRECTIONAL:\n\t\t\t\tif (this._isVsm) {\n\t\t\t\t\ttmpBiases.bias = -0.00001 * 20;\n\t\t\t\t} else {\n\t\t\t\t\ttmpBiases.bias = this.shadowBias / farClip * 100;\n\t\t\t\t\tif (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;\n\t\t\t\t}\n\n\t\t\t\ttmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpBiases;\n\t}\n\n\tgetColor() {\n\t\treturn this._color;\n\t}\n\n\tgetBoundingSphere(sphere) {\n\t\tif (this._type === LIGHTTYPE_SPOT) {\n\t\t\tconst range = this.attenuationEnd;\n\t\t\tconst angle = this._outerConeAngle;\n\t\t\tconst f = Math.cos(angle * math.DEG_TO_RAD);\n\t\t\tconst node = this._node;\n\t\t\tspotCenter.copy(node.up);\n\t\t\tspotCenter.mulScalar(-range * 0.5 * f);\n\t\t\tspotCenter.add(node.getPosition());\n\t\t\tsphere.center = spotCenter;\n\t\t\tspotEndPoint.copy(node.up);\n\t\t\tspotEndPoint.mulScalar(-range);\n\t\t\ttmpVec.copy(node.right);\n\t\t\ttmpVec.mulScalar(Math.sin(angle * math.DEG_TO_RAD) * range);\n\t\t\tspotEndPoint.add(tmpVec);\n\t\t\tsphere.radius = spotEndPoint.length() * 0.5;\n\t\t} else if (this._type === LIGHTTYPE_OMNI) {\n\t\t\tsphere.center = this._node.getPosition();\n\t\t\tsphere.radius = this.attenuationEnd;\n\t\t}\n\t}\n\n\tgetBoundingBox(box) {\n\t\tif (this._type === LIGHTTYPE_SPOT) {\n\t\t\tconst range = this.attenuationEnd;\n\t\t\tconst angle = this._outerConeAngle;\n\t\t\tconst node = this._node;\n\t\t\tconst scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);\n\t\t\tbox.center.set(0, -range * 0.5, 0);\n\t\t\tbox.halfExtents.set(scl, range * 0.5, scl);\n\t\t\tbox.setFromTransformedAabb(box, node.getWorldTransform(), true);\n\t\t} else if (this._type === LIGHTTYPE_OMNI) {\n\t\t\tbox.center.copy(this._node.getPosition());\n\t\t\tbox.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);\n\t\t}\n\t}\n\n\t_updateFinalColor() {\n\t\tconst color = this._color;\n\t\tconst r = color.r;\n\t\tconst g = color.g;\n\t\tconst b = color.b;\n\t\tconst i = this._intensity;\n\t\tconst finalColor = this._finalColor;\n\t\tconst linearFinalColor = this._linearFinalColor;\n\t\tfinalColor[0] = r * i;\n\t\tfinalColor[1] = g * i;\n\t\tfinalColor[2] = b * i;\n\n\t\tif (i >= 1) {\n\t\t\tlinearFinalColor[0] = Math.pow(r, 2.2) * i;\n\t\t\tlinearFinalColor[1] = Math.pow(g, 2.2) * i;\n\t\t\tlinearFinalColor[2] = Math.pow(b, 2.2) * i;\n\t\t} else {\n\t\t\tlinearFinalColor[0] = Math.pow(finalColor[0], 2.2);\n\t\t\tlinearFinalColor[1] = Math.pow(finalColor[1], 2.2);\n\t\t\tlinearFinalColor[2] = Math.pow(finalColor[2], 2.2);\n\t\t}\n\t}\n\n\tsetColor() {\n\t\tif (arguments.length === 1) {\n\t\t\tthis._color.set(arguments[0].r, arguments[0].g, arguments[0].b);\n\t\t} else if (arguments.length === 3) {\n\t\t\tthis._color.set(arguments[0], arguments[1], arguments[2]);\n\t\t}\n\n\t\tthis._updateFinalColor();\n\t}\n\n\tupdateShadow() {\n\t\tif (this.shadowUpdateMode !== SHADOWUPDATE_REALTIME) {\n\t\t\tthis.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t}\n\t}\n\n\tlayersDirty() {\n\t\tvar _this$_scene;\n\n\t\tif ((_this$_scene = this._scene) != null && _this$_scene.layers) {\n\t\t\tthis._scene.layers._dirtyLights = true;\n\t\t}\n\t}\n\n\tupdateKey() {\n\t\tlet key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8;\n\n\t\tif (this._cookieChannel.length === 3) {\n\t\t\tkey |= chanId[this._cookieChannel.charAt(1)] << 16;\n\t\t\tkey |= chanId[this._cookieChannel.charAt(2)] << 14;\n\t\t}\n\n\t\tif (key !== this.key && this._scene !== null) {\n\t\t\tthis.layersDirty();\n\t\t}\n\n\t\tthis.key = key;\n\t}\n\n}\n\nclass LightingParams {\n\tconstructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {\n\t\tthis._maxTextureSize = maxTextureSize;\n\t\tthis._supportsAreaLights = supportsAreaLights;\n\t\tthis._dirtyLightsFnc = dirtyLightsFnc;\n\t\tthis._areaLightsEnabled = false;\n\t\tthis._cells = new Vec3(10, 3, 10);\n\t\tthis._maxLightsPerCell = 255;\n\t\tthis._shadowsEnabled = true;\n\t\tthis._shadowType = SHADOW_PCF3;\n\t\tthis._shadowAtlasResolution = 2048;\n\t\tthis._cookiesEnabled = false;\n\t\tthis._cookieAtlasResolution = 2048;\n\t\tthis.atlasSplit = null;\n\t\tthis.debugLayer = undefined;\n\t}\n\n\tset cells(value) {\n\t\tthis._cells.copy(value);\n\t}\n\n\tget cells() {\n\t\treturn this._cells;\n\t}\n\n\tset maxLightsPerCell(value) {\n\t\tthis._maxLightsPerCell = math.clamp(value, 1, 255);\n\t}\n\n\tget maxLightsPerCell() {\n\t\treturn this._maxLightsPerCell;\n\t}\n\n\tset cookieAtlasResolution(value) {\n\t\tthis._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);\n\t}\n\n\tget cookieAtlasResolution() {\n\t\treturn this._cookieAtlasResolution;\n\t}\n\n\tset shadowAtlasResolution(value) {\n\t\tthis._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);\n\t}\n\n\tget shadowAtlasResolution() {\n\t\treturn this._shadowAtlasResolution;\n\t}\n\n\tset shadowType(value) {\n\t\tif (this._shadowType !== value) {\n\t\t\tthis._shadowType = value;\n\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\n\tget shadowType() {\n\t\treturn this._shadowType;\n\t}\n\n\tset cookiesEnabled(value) {\n\t\tif (this._cookiesEnabled !== value) {\n\t\t\tthis._cookiesEnabled = value;\n\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\n\tget cookiesEnabled() {\n\t\treturn this._cookiesEnabled;\n\t}\n\n\tset areaLightsEnabled(value) {\n\t\tif (this._supportsAreaLights) {\n\t\t\tif (this._areaLightsEnabled !== value) {\n\t\t\t\tthis._areaLightsEnabled = value;\n\n\t\t\t\tthis._dirtyLightsFnc();\n\t\t\t}\n\t\t}\n\t}\n\n\tget areaLightsEnabled() {\n\t\treturn this._areaLightsEnabled;\n\t}\n\n\tset shadowsEnabled(value) {\n\t\tif (this._shadowsEnabled !== value) {\n\t\t\tthis._shadowsEnabled = value;\n\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\n\tget shadowsEnabled() {\n\t\treturn this._shadowsEnabled;\n\t}\n\n}\n\nconst tempSphere = new BoundingSphere();\n\nclass BakeLight {\n\tconstructor(scene, light) {\n\t\tthis.scene = scene;\n\t\tthis.light = light;\n\t\tthis.store();\n\t\tlight.numCascades = 1;\n\n\t\tif (light.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tlight._node.getWorldTransform();\n\n\t\t\tlight.getBoundingSphere(tempSphere);\n\t\t\tthis.lightBounds = new BoundingBox();\n\t\t\tthis.lightBounds.center.copy(tempSphere.center);\n\t\t\tthis.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);\n\t\t}\n\t}\n\n\tstore() {\n\t\tthis.mask = this.light.mask;\n\t\tthis.shadowUpdateMode = this.light.shadowUpdateMode;\n\t\tthis.enabled = this.light.enabled;\n\t\tthis.intensity = this.light.intensity;\n\t\tthis.rotation = this.light._node.getLocalRotation().clone();\n\t\tthis.numCascades = this.light.numCascades;\n\t}\n\n\trestore() {\n\t\tconst light = this.light;\n\t\tlight.mask = this.mask;\n\t\tlight.shadowUpdateMode = this.shadowUpdateMode;\n\t\tlight.enabled = this.enabled;\n\t\tlight.intensity = this.intensity;\n\n\t\tlight._node.setLocalRotation(this.rotation);\n\n\t\tlight.numCascades = this.numCascades;\n\t}\n\n\tstartBake() {\n\t\tthis.light.enabled = true;\n\n\t\tthis.light._destroyShadowMap();\n\t}\n\n\tendBake(shadowMapCache) {\n\t\tconst light = this.light;\n\t\tlight.enabled = false;\n\n\t\tif (light.shadowMap) {\n\t\t\tif (light.shadowMap.cached) shadowMapCache.add(light, light.shadowMap);\n\t\t\tlight.shadowMap = null;\n\t\t}\n\t}\n\n}\n\nconst _tempPoint$1 = new Vec2();\n\nclass BakeLightSimple extends BakeLight {\n\tget numVirtualLights() {\n\t\tif (this.light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\treturn this.light.bakeNumSamples;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tprepareVirtualLight(index, numVirtualLights) {\n\t\tconst light = this.light;\n\n\t\tlight._node.setLocalRotation(this.rotation);\n\n\t\tif (index > 0) {\n\t\t\tconst directionalSpreadAngle = light.bakeArea;\n\t\t\trandom.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);\n\n\t\t\t_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);\n\n\t\t\tlight._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);\n\t\t}\n\n\t\tlight._node.getWorldTransform();\n\n\t\tconst gamma = this.scene.gammaCorrection ? 2.2 : 1;\n\t\tconst linearIntensity = Math.pow(this.intensity, gamma);\n\t\tlight.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);\n\t}\n\n}\n\nclass AreaLightLuts {\n\tstatic createTexture(device, format, size) {\n\t\tconst tex = new Texture(device, {\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tformat: format,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tanisotropy: 1\n\t\t});\n\t\ttex.name = 'AreaLightLUT';\n\t\treturn tex;\n\t}\n\n\tstatic setUniforms(device, texture1, texture2) {\n\t\tdevice.scope.resolve('areaLightsLutTex1').setValue(texture1);\n\t\tdevice.scope.resolve('areaLightsLutTex2').setValue(texture2);\n\t}\n\n\tstatic createPlaceholder(device) {\n\t\tconst texture = AreaLightLuts.createTexture(device, PIXELFORMAT_R8_G8_B8_A8, 2);\n\t\tconst pixels = texture.lock();\n\t\tpixels.fill(0);\n\t\ttexture.unlock();\n\t\tAreaLightLuts.setUniforms(device, texture, texture);\n\t}\n\n\tstatic set(device, resource) {\n\t\tfunction buildTexture(device, data, format) {\n\t\t\tconst texture = AreaLightLuts.createTexture(device, format, 64);\n\t\t\ttexture.lock().set(data);\n\t\t\ttexture.unlock();\n\t\t\ttexture.upload();\n\t\t\treturn texture;\n\t\t}\n\n\t\tfunction offsetScale(data, offset, scale) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Float32Array(count);\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst n = i % 4;\n\t\t\t\tret[i] = (data[i] + offset[n]) * scale[n];\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tfunction convertToHalfFloat(data) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Uint16Array(count);\n\t\t\tconst float2Half = FloatPacking.float2Half;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tret[i] = float2Half(data[i]);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tfunction convertToUint(data) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Uint8ClampedArray(count);\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tret[i] = data[i] * 255;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst versions = new Int16Array(resource, 0, 2);\n\t\tconst majorVersion = versions[0];\n\t\tconst minorVersion = versions[1];\n\n\t\tif (majorVersion !== 0 || minorVersion !== 1) ; else {\n\t\t\tconst srcData1 = new Float32Array(resource, 4, 16384);\n\t\t\tconst srcData2 = new Float32Array(resource, 4 + 16384 * 4, 16384);\n\t\t\tlet data1, data2;\n\t\t\tconst format = device.areaLightLutFormat;\n\n\t\t\tif (format === PIXELFORMAT_RGBA32F) {\n\t\t\t\tdata1 = srcData1;\n\t\t\t\tdata2 = srcData2;\n\t\t\t} else if (format === PIXELFORMAT_RGBA16F) {\n\t\t\t\tdata1 = convertToHalfFloat(srcData1);\n\t\t\t\tdata2 = convertToHalfFloat(srcData2);\n\t\t\t} else {\n\t\t\t\tconst o1 = [0.0, 0.2976, 0.01381, 0.0];\n\t\t\t\tconst s1 = [0.999, 3.08737, 1.6546, 0.603249];\n\t\t\t\tconst o2 = [-0.306897, 0.0, 0.0, 0.0];\n\t\t\t\tconst s2 = [1.442787, 1.0, 1.0, 1.0];\n\t\t\t\tdata1 = convertToUint(offsetScale(srcData1, o1, s1));\n\t\t\t\tdata2 = convertToUint(offsetScale(srcData2, o2, s2));\n\t\t\t}\n\n\t\t\tconst tex1 = buildTexture(device, data1, format);\n\t\t\tconst tex2 = buildTexture(device, data2, format);\n\t\t\tAreaLightLuts.setUniforms(device, tex1, tex2);\n\t\t}\n\t}\n\n}\n\nlet nonUniformScale;\nlet uniformScale = 1;\nconst particleTexChannels$1 = 4;\nconst rotMat = new Mat4();\nconst rotMatInv = new Mat4();\nconst randomPosTformed = new Vec3();\nconst randomPos = new Vec3();\nconst rndFactor3Vec = new Vec3();\nconst particlePosPrev = new Vec3();\nconst velocityVec = new Vec3();\nconst localVelocityVec = new Vec3();\nconst velocityVec2 = new Vec3();\nconst localVelocityVec2 = new Vec3();\nconst radialVelocityVec = new Vec3();\nconst particlePos = new Vec3();\nconst particleFinalPos = new Vec3();\nconst moveDirVec = new Vec3();\nconst tmpVec3$1 = new Vec3();\n\nfunction frac(f) {\n\treturn f - Math.floor(f);\n}\n\nfunction saturate$1(x) {\n\treturn Math.max(Math.min(x, 1), 0);\n}\n\nfunction glMod(x, y) {\n\treturn x - y * Math.floor(x / y);\n}\n\nfunction encodeFloatRGBA(v) {\n\tlet encX = frac(v);\n\tlet encY = frac(255.0 * v);\n\tlet encZ = frac(65025.0 * v);\n\tlet encW = frac(160581375.0 * v);\n\tencX -= encY / 255.0;\n\tencY -= encZ / 255.0;\n\tencZ -= encW / 255.0;\n\tencW -= encW / 255.0;\n\treturn [encX, encY, encZ, encW];\n}\n\nfunction encodeFloatRG(v) {\n\tlet encX = frac(v);\n\tlet encY = frac(255.0 * v);\n\tencX -= encY / 255.0;\n\tencY -= encY / 255.0;\n\treturn [encX, encY];\n}\n\nclass ParticleCPUUpdater {\n\tconstructor(emitter) {\n\t\tthis._emitter = emitter;\n\t}\n\n\tcalcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {\n\t\tconst emitter = this._emitter;\n\t\tconst rX = Math.random();\n\t\tconst rY = Math.random();\n\t\tconst rZ = Math.random();\n\t\tconst rW = Math.random();\n\n\t\tif (emitter.useCpu) {\n\t\t\tparticleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;\n\t\t\tparticleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;\n\t\t\tparticleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;\n\t\t}\n\n\t\trandomPos.x = rX - 0.5;\n\t\trandomPos.y = rY - 0.5;\n\t\trandomPos.z = rZ - 0.5;\n\n\t\tif (emitter.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tconst max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));\n\t\t\tconst edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];\n\t\t\tconst edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];\n\t\t\tconst edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];\n\t\t\trandomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);\n\t\t\trandomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);\n\t\t\trandomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);\n\t\t\tif (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));else randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));\n\t\t} else {\n\t\t\trandomPos.normalize();\n\t\t\tconst spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;\n\t\t\tconst r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n\t\t\tif (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));else randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));\n\t\t}\n\n\t\tconst particleRate = math.lerp(emitter.rate, emitter.rate2, rX);\n\t\tlet startSpawnTime = -particleRate * i;\n\n\t\tif (emitter.pack8) {\n\t\t\tconst packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;\n\t\t\tconst packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;\n\t\t\tconst packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;\n\t\t\tlet packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);\n\t\t\tpackA = packA % (Math.PI * 2) / (Math.PI * 2);\n\t\t\tconst rg0 = encodeFloatRG(packX);\n\t\t\tparticleTex[i * particleTexChannels$1] = rg0[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 1] = rg0[1];\n\t\t\tconst ba0 = encodeFloatRG(packY);\n\t\t\tparticleTex[i * particleTexChannels$1 + 2] = ba0[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 3] = ba0[1];\n\t\t\tconst rg1 = encodeFloatRG(packZ);\n\t\t\tparticleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];\n\t\t\tconst ba1 = encodeFloatRG(packA);\n\t\t\tparticleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];\n\t\t\tconst a2 = 1.0;\n\t\t\tparticleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;\n\t\t\tconst maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));\n\t\t\tconst maxPosLife = emitter.lifetime + 1.0;\n\t\t\tstartSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);\n\t\t\tconst rgba3 = encodeFloatRGBA(startSpawnTime);\n\t\t\tparticleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];\n\t\t\tparticleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];\n\t\t\tparticleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];\n\t\t} else {\n\t\t\tparticleTex[i * particleTexChannels$1] = randomPosTformed.x;\n\t\t\tparticleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;\n\t\t\tparticleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;\n\t\t\tparticleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);\n\t\t\tparticleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;\n\t\t}\n\t}\n\n\tupdate(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {\n\t\tlet a, b, c;\n\t\tconst emitter = this._emitter;\n\n\t\tif (emitter.meshInstance.node) {\n\t\t\tconst fullMat = emitter.meshInstance.node.worldTransform;\n\n\t\t\tfor (let j = 0; j < 12; j++) {\n\t\t\t\trotMat.data[j] = fullMat.data[j];\n\t\t\t}\n\n\t\t\trotMatInv.copy(rotMat);\n\t\t\trotMatInv.invert();\n\t\t\tnonUniformScale = emitter.meshInstance.node.localScale;\n\t\t\tuniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);\n\t\t}\n\n\t\temitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();\n\t\tconst posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;\n\t\tconst vertSize = !emitter.useMesh ? 15 : 17;\n\t\tlet cf, cc;\n\t\tlet rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;\n\t\tconst precision1 = emitter.precision - 1;\n\n\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\tconst id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);\n\t\t\tconst rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];\n\t\t\trndFactor3Vec.x = rndFactor;\n\t\t\trndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];\n\t\t\trndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];\n\t\t\tconst particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;\n\t\t\tconst particleLifetime = emitter.lifetime;\n\t\t\tlet life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;\n\t\t\tconst nlife = saturate$1(life / particleLifetime);\n\t\t\tlet scale = 0;\n\t\t\tlet alphaDiv = 0;\n\t\t\tconst angle = 0;\n\t\t\tconst respawn = life - delta <= 0.0 || life >= particleLifetime;\n\n\t\t\tif (respawn) {\n\t\t\t\tthis.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);\n\t\t\t}\n\n\t\t\tlet particleEnabled = life > 0.0 && life < particleLifetime;\n\n\t\t\tif (particleEnabled) {\n\t\t\t\tc = nlife * precision1;\n\t\t\t\tcf = Math.floor(c);\n\t\t\t\tcc = Math.ceil(c);\n\t\t\t\tc %= 1;\n\t\t\t\ta = emitter.qRotSpeed[cf];\n\t\t\t\tb = emitter.qRotSpeed[cc];\n\t\t\t\trotSpeed = a + (b - a) * c;\n\t\t\t\ta = emitter.qRotSpeed2[cf];\n\t\t\t\tb = emitter.qRotSpeed2[cc];\n\t\t\t\trotSpeed2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qScale[cf];\n\t\t\t\tb = emitter.qScale[cc];\n\t\t\t\tscale = a + (b - a) * c;\n\t\t\t\ta = emitter.qScale2[cf];\n\t\t\t\tb = emitter.qScale2[cc];\n\t\t\t\tscale2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qAlpha[cf];\n\t\t\t\tb = emitter.qAlpha[cc];\n\t\t\t\talpha = a + (b - a) * c;\n\t\t\t\ta = emitter.qAlpha2[cf];\n\t\t\t\tb = emitter.qAlpha2[cc];\n\t\t\t\talpha2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qRadialSpeed[cf];\n\t\t\t\tb = emitter.qRadialSpeed[cc];\n\t\t\t\tradialSpeed = a + (b - a) * c;\n\t\t\t\ta = emitter.qRadialSpeed2[cf];\n\t\t\t\tb = emitter.qRadialSpeed2[cc];\n\t\t\t\tradialSpeed2 = a + (b - a) * c;\n\t\t\t\tradialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);\n\t\t\t\tparticlePosPrev.x = particleTex[id * particleTexChannels$1];\n\t\t\t\tparticlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];\n\t\t\t\tparticlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];\n\t\t\t\tif (!emitter.localSpace) radialVelocityVec.copy(particlePosPrev).sub(emitterPos);else radialVelocityVec.copy(particlePosPrev);\n\t\t\t\tradialVelocityVec.normalize().mulScalar(radialSpeed);\n\t\t\t\tcf *= 3;\n\t\t\t\tcc *= 3;\n\t\t\t\ta = emitter.qLocalVelocity[cf];\n\t\t\t\tb = emitter.qLocalVelocity[cc];\n\t\t\t\tlocalVelocityVec.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity[cf + 1];\n\t\t\t\tb = emitter.qLocalVelocity[cc + 1];\n\t\t\t\tlocalVelocityVec.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity[cf + 2];\n\t\t\t\tb = emitter.qLocalVelocity[cc + 2];\n\t\t\t\tlocalVelocityVec.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf];\n\t\t\t\tb = emitter.qLocalVelocity2[cc];\n\t\t\t\tlocalVelocityVec2.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf + 1];\n\t\t\t\tb = emitter.qLocalVelocity2[cc + 1];\n\t\t\t\tlocalVelocityVec2.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf + 2];\n\t\t\t\tb = emitter.qLocalVelocity2[cc + 2];\n\t\t\t\tlocalVelocityVec2.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf];\n\t\t\t\tb = emitter.qVelocity[cc];\n\t\t\t\tvelocityVec.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf + 1];\n\t\t\t\tb = emitter.qVelocity[cc + 1];\n\t\t\t\tvelocityVec.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf + 2];\n\t\t\t\tb = emitter.qVelocity[cc + 2];\n\t\t\t\tvelocityVec.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf];\n\t\t\t\tb = emitter.qVelocity2[cc];\n\t\t\t\tvelocityVec2.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf + 1];\n\t\t\t\tb = emitter.qVelocity2[cc + 1];\n\t\t\t\tvelocityVec2.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf + 2];\n\t\t\t\tb = emitter.qVelocity2[cc + 2];\n\t\t\t\tvelocityVec2.z = a + (b - a) * c;\n\t\t\t\tlocalVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;\n\t\t\t\tlocalVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;\n\t\t\t\tlocalVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;\n\n\t\t\t\tif (emitter.initialVelocity > 0) {\n\t\t\t\t\tif (emitter.emitterShape === EMITTERSHAPE_SPHERE) {\n\t\t\t\t\t\trandomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();\n\t\t\t\t\t\tlocalVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocalVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvelocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;\n\t\t\t\tvelocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;\n\t\t\t\tvelocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;\n\t\t\t\trotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;\n\t\t\t\tscale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;\n\t\t\t\talphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);\n\n\t\t\t\tif (emitter.meshInstance.node) {\n\t\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\t\trotMat.transformPoint(localVelocityVec, localVelocityVec);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocalVelocityVec.x /= nonUniformScale.x;\n\t\t\t\t\t\tlocalVelocityVec.y /= nonUniformScale.y;\n\t\t\t\t\t\tlocalVelocityVec.z /= nonUniformScale.z;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\tlocalVelocityVec.add(velocityVec.mul(nonUniformScale));\n\t\t\t\t\tlocalVelocityVec.add(radialVelocityVec.mul(nonUniformScale));\n\t\t\t\t} else {\n\t\t\t\t\trotMatInv.transformPoint(velocityVec, velocityVec);\n\t\t\t\t\tlocalVelocityVec.add(velocityVec).add(radialVelocityVec);\n\t\t\t\t}\n\n\t\t\t\tmoveDirVec.copy(localVelocityVec);\n\t\t\t\tparticlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));\n\t\t\t\tparticleFinalPos.copy(particlePos);\n\t\t\t\tparticleTex[id * particleTexChannels$1] = particleFinalPos.x;\n\t\t\t\tparticleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;\n\t\t\t\tparticleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;\n\t\t\t\tparticleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;\n\n\t\t\t\tif (emitter.wrap && emitter.wrapBounds) {\n\t\t\t\t\tif (!emitter.localSpace) particleFinalPos.sub(emitterPos);\n\t\t\t\t\tparticleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;\n\t\t\t\t\tparticleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;\n\t\t\t\t\tparticleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;\n\t\t\t\t\tif (!emitter.localSpace) particleFinalPos.add(emitterPos);\n\t\t\t\t}\n\n\t\t\t\tif (emitter.sort > 0) {\n\t\t\t\t\tif (emitter.sort === 1) {\n\t\t\t\t\t\ttmpVec3$1.copy(particleFinalPos).sub(posCam);\n\t\t\t\t\t\temitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);\n\t\t\t\t\t} else if (emitter.sort === 2) {\n\t\t\t\t\t\temitter.particleDistance[id] = life;\n\t\t\t\t\t} else if (emitter.sort === 3) {\n\t\t\t\t\t\temitter.particleDistance[id] = -life;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isOnStop) {\n\t\t\t\tif (life < 0) {\n\t\t\t\t\tparticleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (life >= particleLifetime) {\n\t\t\t\t\tlife -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);\n\t\t\t\t\tparticleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;\n\t\t\t\t}\n\n\t\t\t\tif (life < 0 && emitter.loop) {\n\t\t\t\t\tparticleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) particleEnabled = false;\n\t\t\tparticleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;\n\n\t\t\tfor (let v = 0; v < emitter.numParticleVerts; v++) {\n\t\t\t\tconst vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);\n\t\t\t\tlet quadX = emitter.vbCPU[vbOffset];\n\t\t\t\tlet quadY = emitter.vbCPU[vbOffset + 1];\n\t\t\t\tlet quadZ = emitter.vbCPU[vbOffset + 2];\n\n\t\t\t\tif (!particleEnabled) {\n\t\t\t\t\tquadX = quadY = quadZ = 0;\n\t\t\t\t}\n\n\t\t\t\tconst w = i * emitter.numParticleVerts * vertSize + v * vertSize;\n\t\t\t\tdata[w] = particleFinalPos.x;\n\t\t\t\tdata[w + 1] = particleFinalPos.y;\n\t\t\t\tdata[w + 2] = particleFinalPos.z;\n\t\t\t\tdata[w + 3] = nlife;\n\t\t\t\tdata[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];\n\t\t\t\tdata[w + 5] = scale;\n\t\t\t\tdata[w + 6] = alphaDiv;\n\t\t\t\tdata[w + 7] = moveDirVec.x;\n\t\t\t\tdata[w + 8] = quadX;\n\t\t\t\tdata[w + 9] = quadY;\n\t\t\t\tdata[w + 10] = quadZ;\n\t\t\t\tdata[w + 11] = moveDirVec.y;\n\t\t\t\tdata[w + 12] = id;\n\t\t\t\tdata[w + 13] = moveDirVec.z;\n\t\t\t\tdata[w + 14] = emitter.vbCPU[vbOffset + 3];\n\n\t\t\t\tif (emitter.useMesh) {\n\t\t\t\t\tdata[w + 15] = emitter.vbCPU[vbOffset + 4];\n\t\t\t\t\tdata[w + 16] = emitter.vbCPU[vbOffset + 5];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (emitter.sort > PARTICLESORT_NONE && emitter.camera) {\n\t\t\tconst vbStride = emitter.useMesh ? 6 : 4;\n\t\t\tconst particleDistance = emitter.particleDistance;\n\n\t\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\t\tvbToSort[i][0] = i;\n\t\t\t\tvbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])];\n\t\t\t}\n\n\t\t\temitter.vbOld.set(emitter.vbCPU);\n\t\t\tvbToSort.sort(function (p1, p2) {\n\t\t\t\treturn p1[1] - p2[1];\n\t\t\t});\n\n\t\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\t\tconst src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;\n\t\t\t\tconst dest = i * emitter.numParticleVerts * vbStride;\n\n\t\t\t\tfor (let j = 0; j < emitter.numParticleVerts * vbStride; j++) {\n\t\t\t\t\temitter.vbCPU[dest + j] = emitter.vbOld[src + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nconst spawnMatrix3 = new Mat3();\nconst emitterMatrix3 = new Mat3();\nconst emitterMatrix3Inv = new Mat3();\n\nclass ParticleGPUUpdater {\n\tconstructor(emitter, gd) {\n\t\tthis._emitter = emitter;\n\t\tthis.frameRandomUniform = new Float32Array(3);\n\t\tthis.emitterPosUniform = new Float32Array(3);\n\t\tthis.emitterScaleUniform = new Float32Array([1, 1, 1]);\n\t\tthis.worldBoundsMulUniform = new Float32Array(3);\n\t\tthis.worldBoundsAddUniform = new Float32Array(3);\n\t\tthis.inBoundsSizeUniform = new Float32Array(3);\n\t\tthis.inBoundsCenterUniform = new Float32Array(3);\n\t\tthis.constantParticleTexIN = gd.scope.resolve(\"particleTexIN\");\n\t\tthis.constantParticleTexOUT = gd.scope.resolve(\"particleTexOUT\");\n\t\tthis.constantEmitterPos = gd.scope.resolve(\"emitterPos\");\n\t\tthis.constantEmitterScale = gd.scope.resolve(\"emitterScale\");\n\t\tthis.constantSpawnBounds = gd.scope.resolve(\"spawnBounds\");\n\t\tthis.constantSpawnPosInnerRatio = gd.scope.resolve(\"spawnPosInnerRatio\");\n\t\tthis.constantSpawnBoundsSphere = gd.scope.resolve(\"spawnBoundsSphere\");\n\t\tthis.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve(\"spawnBoundsSphereInnerRatio\");\n\t\tthis.constantInitialVelocity = gd.scope.resolve(\"initialVelocity\");\n\t\tthis.constantFrameRandom = gd.scope.resolve(\"frameRandom\");\n\t\tthis.constantDelta = gd.scope.resolve(\"delta\");\n\t\tthis.constantRate = gd.scope.resolve(\"rate\");\n\t\tthis.constantRateDiv = gd.scope.resolve(\"rateDiv\");\n\t\tthis.constantLifetime = gd.scope.resolve(\"lifetime\");\n\t\tthis.constantGraphSampleSize = gd.scope.resolve(\"graphSampleSize\");\n\t\tthis.constantGraphNumSamples = gd.scope.resolve(\"graphNumSamples\");\n\t\tthis.constantInternalTex0 = gd.scope.resolve(\"internalTex0\");\n\t\tthis.constantInternalTex1 = gd.scope.resolve(\"internalTex1\");\n\t\tthis.constantInternalTex2 = gd.scope.resolve(\"internalTex2\");\n\t\tthis.constantInternalTex3 = gd.scope.resolve(\"internalTex3\");\n\t\tthis.constantEmitterMatrix = gd.scope.resolve(\"emitterMatrix\");\n\t\tthis.constantEmitterMatrixInv = gd.scope.resolve(\"emitterMatrixInv\");\n\t\tthis.constantNumParticles = gd.scope.resolve(\"numParticles\");\n\t\tthis.constantNumParticlesPot = gd.scope.resolve(\"numParticlesPot\");\n\t\tthis.constantLocalVelocityDivMult = gd.scope.resolve(\"localVelocityDivMult\");\n\t\tthis.constantVelocityDivMult = gd.scope.resolve(\"velocityDivMult\");\n\t\tthis.constantRotSpeedDivMult = gd.scope.resolve(\"rotSpeedDivMult\");\n\t\tthis.constantSeed = gd.scope.resolve(\"seed\");\n\t\tthis.constantStartAngle = gd.scope.resolve(\"startAngle\");\n\t\tthis.constantStartAngle2 = gd.scope.resolve(\"startAngle2\");\n\t\tthis.constantOutBoundsMul = gd.scope.resolve(\"outBoundsMul\");\n\t\tthis.constantOutBoundsAdd = gd.scope.resolve(\"outBoundsAdd\");\n\t\tthis.constantInBoundsSize = gd.scope.resolve(\"inBoundsSize\");\n\t\tthis.constantInBoundsCenter = gd.scope.resolve(\"inBoundsCenter\");\n\t\tthis.constantMaxVel = gd.scope.resolve(\"maxVel\");\n\t\tthis.constantFaceTangent = gd.scope.resolve(\"faceTangent\");\n\t\tthis.constantFaceBinorm = gd.scope.resolve(\"faceBinorm\");\n\t}\n\n\t_setInputBounds() {\n\t\tthis.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;\n\t\tthis.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;\n\t\tthis.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;\n\t\tthis.constantInBoundsSize.setValue(this.inBoundsSizeUniform);\n\t\tthis.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;\n\t\tthis.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;\n\t\tthis.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;\n\t\tthis.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);\n\t}\n\n\trandomize() {\n\t\tthis.frameRandomUniform[0] = Math.random();\n\t\tthis.frameRandomUniform[1] = Math.random();\n\t\tthis.frameRandomUniform[2] = Math.random();\n\t}\n\n\tupdate(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {\n\t\tconst emitter = this._emitter;\n\t\tdevice.setBlending(false);\n\t\tdevice.setColorWrite(true, true, true, true);\n\t\tdevice.setCullMode(CULLFACE_NONE);\n\t\tdevice.setDepthTest(false);\n\t\tdevice.setDepthWrite(false);\n\t\tthis.randomize();\n\t\tthis.constantGraphSampleSize.setValue(1.0 / emitter.precision);\n\t\tthis.constantGraphNumSamples.setValue(emitter.precision);\n\t\tthis.constantNumParticles.setValue(emitter.numParticles);\n\t\tthis.constantNumParticlesPot.setValue(emitter.numParticlesPot);\n\t\tthis.constantInternalTex0.setValue(emitter.internalTex0);\n\t\tthis.constantInternalTex1.setValue(emitter.internalTex1);\n\t\tthis.constantInternalTex2.setValue(emitter.internalTex2);\n\t\tthis.constantInternalTex3.setValue(emitter.internalTex3);\n\t\tconst node = emitter.meshInstance.node;\n\t\tconst emitterScale = node === null ? Vec3.ONE : node.localScale;\n\n\t\tif (emitter.pack8) {\n\t\t\tthis.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;\n\t\t\tthis.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;\n\t\t\tthis.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;\n\t\t\tthis.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);\n\t\t\tthis.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;\n\t\t\tthis.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;\n\t\t\tthis.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;\n\t\t\tthis.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);\n\n\t\t\tthis._setInputBounds();\n\n\t\t\tlet maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);\n\t\t\tmaxVel = Math.max(maxVel, 1);\n\t\t\tthis.constantMaxVel.setValue(maxVel);\n\t\t}\n\n\t\tconst emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();\n\t\tconst emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();\n\n\t\tif (emitter.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tspawnMatrix3.setFromMat4(spawnMatrix);\n\t\t\tthis.constantSpawnBounds.setValue(spawnMatrix3.data);\n\t\t\tthis.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);\n\t\t} else {\n\t\t\tthis.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);\n\t\t\tthis.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);\n\t\t}\n\n\t\tthis.constantInitialVelocity.setValue(emitter.initialVelocity);\n\t\temitterMatrix3.setFromMat4(emitterMatrix);\n\t\temitterMatrix.invertTo3x3(emitterMatrix3Inv);\n\t\tthis.emitterPosUniform[0] = emitterPos.x;\n\t\tthis.emitterPosUniform[1] = emitterPos.y;\n\t\tthis.emitterPosUniform[2] = emitterPos.z;\n\t\tthis.constantEmitterPos.setValue(this.emitterPosUniform);\n\t\tthis.constantFrameRandom.setValue(this.frameRandomUniform);\n\t\tthis.constantDelta.setValue(delta);\n\t\tthis.constantRate.setValue(emitter.rate);\n\t\tthis.constantRateDiv.setValue(emitter.rate2 - emitter.rate);\n\t\tthis.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);\n\t\tthis.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);\n\t\tthis.constantSeed.setValue(emitter.seed);\n\t\tthis.constantLifetime.setValue(emitter.lifetime);\n\t\tthis.emitterScaleUniform[0] = emitterScale.x;\n\t\tthis.emitterScaleUniform[1] = emitterScale.y;\n\t\tthis.emitterScaleUniform[2] = emitterScale.z;\n\t\tthis.constantEmitterScale.setValue(this.emitterScaleUniform);\n\t\tthis.constantEmitterMatrix.setValue(emitterMatrix3.data);\n\t\tthis.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);\n\t\tthis.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);\n\t\tthis.constantVelocityDivMult.setValue(emitter.velocityUMax);\n\t\tthis.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);\n\t\tlet texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;\n\t\ttexIN = emitter.beenReset ? emitter.particleTexStart : texIN;\n\t\tconst texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;\n\t\tthis.constantParticleTexIN.setValue(texIN);\n\t\tdrawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);\n\t\temitter.material.setParameter(\"particleTexOUT\", texIN);\n\t\temitter.material.setParameter(\"particleTexIN\", texOUT);\n\t\temitter.beenReset = false;\n\t\temitter.swapTex = !emitter.swapTex;\n\t\tdevice.setDepthTest(true);\n\t\tdevice.setDepthWrite(true);\n\t\temitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);\n\t\temitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);\n\t\tif (emitter.pack8) this._setInputBounds();\n\t}\n\n}\n\nconst particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];\n\nfunction _createTexture(device, width, height, pixelData, format = PIXELFORMAT_RGBA32F, mult8Bit, filter) {\n\tlet mipFilter = FILTER_NEAREST;\n\tif (filter && format === PIXELFORMAT_R8_G8_B8_A8) mipFilter = FILTER_LINEAR;\n\tconst texture = new Texture(device, {\n\t\twidth: width,\n\t\theight: height,\n\t\tformat: format,\n\t\tcubemap: false,\n\t\tmipmaps: false,\n\t\tminFilter: mipFilter,\n\t\tmagFilter: mipFilter,\n\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t});\n\ttexture.name = \"PSTexture\";\n\tconst pixels = texture.lock();\n\n\tif (format === PIXELFORMAT_R8_G8_B8_A8) {\n\t\tconst temp = new Uint8Array(pixelData.length);\n\n\t\tfor (let i = 0; i < pixelData.length; i++) {\n\t\t\ttemp[i] = pixelData[i] * mult8Bit * 255;\n\t\t}\n\n\t\tpixelData = temp;\n\t}\n\n\tpixels.set(pixelData);\n\ttexture.unlock();\n\treturn texture;\n}\n\nfunction saturate(x) {\n\treturn Math.max(Math.min(x, 1), 0);\n}\n\nconst default0Curve = new Curve([0, 0, 1, 0]);\nconst default1Curve = new Curve([0, 1, 1, 1]);\nconst default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);\nconst default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);\nlet particleTexHeight = 2;\nconst particleTexChannels = 4;\nconst extentsInnerRatioUniform = new Float32Array(3);\nconst spawnMatrix = new Mat4();\nconst tmpVec3 = new Vec3();\nconst bMin = new Vec3();\nconst bMax = new Vec3();\nlet setPropertyTarget;\nlet setPropertyOptions;\n\nfunction setProperty(pName, defaultVal) {\n\tif (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {\n\t\tsetPropertyTarget[pName] = setPropertyOptions[pName];\n\t} else {\n\t\tsetPropertyTarget[pName] = defaultVal;\n\t}\n}\n\nfunction pack3NFloats(a, b, c) {\n\tconst packed = a * 255 << 16 | b * 255 << 8 | c * 255;\n\treturn packed / (1 << 24);\n}\n\nfunction packTextureXYZ_NXYZ(qXYZ, qXYZ2) {\n\tconst num = qXYZ.length / 3;\n\tconst colors = new Array(num * 4);\n\n\tfor (let i = 0; i < num; i++) {\n\t\tcolors[i * 4] = qXYZ[i * 3];\n\t\tcolors[i * 4 + 1] = qXYZ[i * 3 + 1];\n\t\tcolors[i * 4 + 2] = qXYZ[i * 3 + 2];\n\t\tcolors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);\n\t}\n\n\treturn colors;\n}\n\nfunction packTextureRGBA(qRGB, qA) {\n\tconst colors = new Array(qA.length * 4);\n\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qRGB[i * 3];\n\t\tcolors[i * 4 + 1] = qRGB[i * 3 + 1];\n\t\tcolors[i * 4 + 2] = qRGB[i * 3 + 2];\n\t\tcolors[i * 4 + 3] = qA[i];\n\t}\n\n\treturn colors;\n}\n\nfunction packTexture5Floats(qA, qB, qC, qD, qE) {\n\tconst colors = new Array(qA.length * 4);\n\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qA[i];\n\t\tcolors[i * 4 + 1] = qB[i];\n\t\tcolors[i * 4 + 2] = 0;\n\t\tcolors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);\n\t}\n\n\treturn colors;\n}\n\nfunction packTexture2Floats(qA, qB) {\n\tconst colors = new Array(qA.length * 4);\n\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qA[i];\n\t\tcolors[i * 4 + 1] = qB[i];\n\t\tcolors[i * 4 + 2] = 0;\n\t\tcolors[i * 4 + 3] = 0;\n\t}\n\n\treturn colors;\n}\n\nfunction calcEndTime(emitter) {\n\tconst interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;\n\treturn Date.now() + interval * 1000;\n}\n\nfunction subGraph(A, B) {\n\tconst r = new Float32Array(A.length);\n\n\tfor (let i = 0; i < A.length; i++) {\n\t\tr[i] = A[i] - B[i];\n\t}\n\n\treturn r;\n}\n\nfunction maxUnsignedGraphValue(A, outUMax) {\n\tconst chans = outUMax.length;\n\tconst values = A.length / chans;\n\n\tfor (let i = 0; i < values; i++) {\n\t\tfor (let j = 0; j < chans; j++) {\n\t\t\tconst a = Math.abs(A[i * chans + j]);\n\t\t\toutUMax[j] = Math.max(outUMax[j], a);\n\t\t}\n\t}\n}\n\nfunction normalizeGraph(A, uMax) {\n\tconst chans = uMax.length;\n\tconst values = A.length / chans;\n\n\tfor (let i = 0; i < values; i++) {\n\t\tfor (let j = 0; j < chans; j++) {\n\t\t\tA[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];\n\t\t\tA[i * chans + j] *= 0.5;\n\t\t\tA[i * chans + j] += 0.5;\n\t\t}\n\t}\n}\n\nfunction divGraphFrom2Curves(curve1, curve2, outUMax) {\n\tconst sub = subGraph(curve2, curve1);\n\tmaxUnsignedGraphValue(sub, outUMax);\n\tnormalizeGraph(sub, outUMax);\n\treturn sub;\n}\n\nclass ParticleEmitter {\n\tconstructor(graphicsDevice, options) {\n\t\tthis.graphicsDevice = graphicsDevice;\n\t\tconst gd = graphicsDevice;\n\t\tconst precision = 32;\n\t\tthis.precision = precision;\n\t\tthis._addTimeTime = 0;\n\t\tParticleEmitter.staticInit(gd);\n\t\tsetPropertyTarget = this;\n\t\tsetPropertyOptions = options;\n\t\tsetProperty(\"numParticles\", 1);\n\n\t\tif (this.numParticles > graphicsDevice.maxTextureSize) {\n\t\t\tthis.numParticles = graphicsDevice.maxTextureSize;\n\t\t}\n\n\t\tsetProperty(\"rate\", 1);\n\t\tsetProperty(\"rate2\", this.rate);\n\t\tsetProperty(\"lifetime\", 50);\n\t\tsetProperty(\"emitterExtents\", new Vec3(0, 0, 0));\n\t\tsetProperty(\"emitterExtentsInner\", new Vec3(0, 0, 0));\n\t\tsetProperty(\"emitterRadius\", 0);\n\t\tsetProperty(\"emitterRadiusInner\", 0);\n\t\tsetProperty(\"emitterShape\", EMITTERSHAPE_BOX);\n\t\tsetProperty(\"initialVelocity\", 1);\n\t\tsetProperty(\"wrap\", false);\n\t\tsetProperty(\"localSpace\", false);\n\t\tsetProperty(\"screenSpace\", false);\n\t\tsetProperty(\"wrapBounds\", null);\n\t\tsetProperty(\"colorMap\", ParticleEmitter.DEFAULT_PARAM_TEXTURE);\n\t\tsetProperty(\"normalMap\", null);\n\t\tsetProperty(\"loop\", true);\n\t\tsetProperty(\"preWarm\", false);\n\t\tsetProperty(\"sort\", PARTICLESORT_NONE);\n\t\tsetProperty(\"mode\", PARTICLEMODE_GPU);\n\t\tsetProperty(\"scene\", null);\n\t\tsetProperty(\"lighting\", false);\n\t\tsetProperty(\"halfLambert\", false);\n\t\tsetProperty(\"intensity\", 1.0);\n\t\tsetProperty(\"stretch\", 0.0);\n\t\tsetProperty(\"alignToMotion\", false);\n\t\tsetProperty(\"depthSoftening\", 0);\n\t\tsetProperty(\"mesh\", null);\n\t\tsetProperty(\"particleNormal\", new Vec3(0, 1, 0));\n\t\tsetProperty(\"orientation\", PARTICLEORIENTATION_SCREEN);\n\t\tsetProperty(\"depthWrite\", false);\n\t\tsetProperty(\"noFog\", false);\n\t\tsetProperty(\"blendType\", BLEND_NORMAL);\n\t\tsetProperty(\"node\", null);\n\t\tsetProperty(\"startAngle\", 0);\n\t\tsetProperty(\"startAngle2\", this.startAngle);\n\t\tsetProperty(\"animTilesX\", 1);\n\t\tsetProperty(\"animTilesY\", 1);\n\t\tsetProperty(\"animStartFrame\", 0);\n\t\tsetProperty(\"animNumFrames\", 1);\n\t\tsetProperty(\"animNumAnimations\", 1);\n\t\tsetProperty(\"animIndex\", 0);\n\t\tsetProperty(\"randomizeAnimIndex\", false);\n\t\tsetProperty(\"animSpeed\", 1);\n\t\tsetProperty(\"animLoop\", true);\n\t\tthis._gpuUpdater = new ParticleGPUUpdater(this, gd);\n\t\tthis._cpuUpdater = new ParticleCPUUpdater(this);\n\t\tthis.constantLightCube = gd.scope.resolve(\"lightCube[0]\");\n\t\tthis.emitterPosUniform = new Float32Array(3);\n\t\tthis.wrapBoundsUniform = new Float32Array(3);\n\t\tthis.emitterScaleUniform = new Float32Array([1, 1, 1]);\n\t\tsetProperty(\"colorGraph\", default1Curve3);\n\t\tsetProperty(\"colorGraph2\", this.colorGraph);\n\t\tsetProperty(\"scaleGraph\", default1Curve);\n\t\tsetProperty(\"scaleGraph2\", this.scaleGraph);\n\t\tsetProperty(\"alphaGraph\", default1Curve);\n\t\tsetProperty(\"alphaGraph2\", this.alphaGraph);\n\t\tsetProperty(\"localVelocityGraph\", default0Curve3);\n\t\tsetProperty(\"localVelocityGraph2\", this.localVelocityGraph);\n\t\tsetProperty(\"velocityGraph\", default0Curve3);\n\t\tsetProperty(\"velocityGraph2\", this.velocityGraph);\n\t\tsetProperty(\"rotationSpeedGraph\", default0Curve);\n\t\tsetProperty(\"rotationSpeedGraph2\", this.rotationSpeedGraph);\n\t\tsetProperty(\"radialSpeedGraph\", default0Curve);\n\t\tsetProperty(\"radialSpeedGraph2\", this.radialSpeedGraph);\n\t\tthis.lightCube = new Float32Array(6 * 3);\n\t\tthis.lightCubeDir = new Array(6);\n\t\tthis.lightCubeDir[0] = new Vec3(-1, 0, 0);\n\t\tthis.lightCubeDir[1] = new Vec3(1, 0, 0);\n\t\tthis.lightCubeDir[2] = new Vec3(0, -1, 0);\n\t\tthis.lightCubeDir[3] = new Vec3(0, 1, 0);\n\t\tthis.lightCubeDir[4] = new Vec3(0, 0, -1);\n\t\tthis.lightCubeDir[5] = new Vec3(0, 0, 1);\n\t\tthis.animTilesParams = new Float32Array(2);\n\t\tthis.animParams = new Float32Array(4);\n\t\tthis.animIndexParams = new Float32Array(2);\n\t\tthis.internalTex0 = null;\n\t\tthis.internalTex1 = null;\n\t\tthis.internalTex2 = null;\n\t\tthis.colorParam = null;\n\t\tthis.vbToSort = null;\n\t\tthis.vbOld = null;\n\t\tthis.particleDistance = null;\n\t\tthis.camera = null;\n\t\tthis.swapTex = false;\n\t\tthis.useMesh = true;\n\t\tthis.useCpu = false;\n\t\tthis.pack8 = true;\n\t\tthis.localBounds = new BoundingBox();\n\t\tthis.worldBoundsNoTrail = new BoundingBox();\n\t\tthis.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];\n\t\tthis.worldBounds = new BoundingBox();\n\t\tthis.worldBoundsSize = new Vec3();\n\t\tthis.prevWorldBoundsSize = new Vec3();\n\t\tthis.prevWorldBoundsCenter = new Vec3();\n\t\tthis.prevEmitterExtents = this.emitterExtents;\n\t\tthis.prevEmitterRadius = this.emitterRadius;\n\t\tthis.worldBoundsMul = new Vec3();\n\t\tthis.worldBoundsAdd = new Vec3();\n\t\tthis.timeToSwitchBounds = 0;\n\t\tthis.shaderParticleUpdateRespawn = null;\n\t\tthis.shaderParticleUpdateNoRespawn = null;\n\t\tthis.shaderParticleUpdateOnStop = null;\n\t\tthis.numParticleVerts = 0;\n\t\tthis.numParticleIndices = 0;\n\t\tthis.material = null;\n\t\tthis.meshInstance = null;\n\t\tthis.drawOrder = 0;\n\t\tthis.seed = Math.random();\n\t\tthis.fixedTimeStep = 1.0 / 60;\n\t\tthis.maxSubSteps = 10;\n\t\tthis.simTime = 0;\n\t\tthis.simTimeTotal = 0;\n\t\tthis.beenReset = false;\n\t\tthis._layer = null;\n\t\tthis.rebuild();\n\t}\n\n\tstatic staticInit(device) {\n\t\tif (!ParticleEmitter.DEFAULT_PARAM_TEXTURE) {\n\t\t\tconst resolution = 16;\n\t\t\tconst centerPoint = resolution * 0.5 + 0.5;\n\t\t\tconst dtex = new Float32Array(resolution * resolution * 4);\n\n\t\t\tfor (let y = 0; y < resolution; y++) {\n\t\t\t\tfor (let x = 0; x < resolution; x++) {\n\t\t\t\t\tconst xgrad = x + 1 - centerPoint;\n\t\t\t\t\tconst ygrad = y + 1 - centerPoint;\n\t\t\t\t\tconst c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);\n\t\t\t\t\tconst p = y * resolution + x;\n\t\t\t\t\tdtex[p * 4] = 1;\n\t\t\t\t\tdtex[p * 4 + 1] = 1;\n\t\t\t\t\tdtex[p * 4 + 2] = 1;\n\t\t\t\t\tdtex[p * 4 + 3] = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE = _createTexture(device, resolution, resolution, dtex, PIXELFORMAT_R8_G8_B8_A8, 1.0, true);\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE.minFilter = FILTER_LINEAR;\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE.magFilter = FILTER_LINEAR;\n\t\t}\n\t}\n\n\tstatic staticDestroy() {\n\t\tif (ParticleEmitter.DEFAULT_PARAM_TEXTURE) {\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE.destroy();\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE = null;\n\t\t}\n\t}\n\n\tonChangeCamera() {\n\t\tthis.regenShader();\n\t\tthis.resetMaterial();\n\t}\n\n\tcalculateBoundsMad() {\n\t\tthis.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;\n\t\tthis.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;\n\t\tthis.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;\n\t\tthis.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);\n\t\tthis.worldBoundsAdd.x += 0.5;\n\t\tthis.worldBoundsAdd.y += 0.5;\n\t\tthis.worldBoundsAdd.z += 0.5;\n\t}\n\n\tcalculateWorldBounds() {\n\t\tif (!this.node) return;\n\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\n\t\tif (!this.useCpu) {\n\t\t\tlet recalculateLocalBounds = false;\n\n\t\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\t\trecalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);\n\t\t\t} else {\n\t\t\t\trecalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);\n\t\t\t}\n\n\t\t\tif (recalculateLocalBounds) {\n\t\t\t\tthis.calculateLocalBounds();\n\t\t\t}\n\t\t}\n\n\t\tconst nodeWT = this.node.getWorldTransform();\n\n\t\tif (this.localSpace) {\n\t\t\tthis.worldBoundsNoTrail.copy(this.localBounds);\n\t\t} else {\n\t\t\tthis.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);\n\t\t}\n\n\t\tthis.worldBoundsTrail[0].add(this.worldBoundsNoTrail);\n\t\tthis.worldBoundsTrail[1].add(this.worldBoundsNoTrail);\n\t\tconst now = this.simTimeTotal;\n\n\t\tif (now >= this.timeToSwitchBounds) {\n\t\t\tthis.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);\n\t\t\tthis.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);\n\t\t\tthis.timeToSwitchBounds = now + this.lifetime;\n\t\t}\n\n\t\tthis.worldBounds.copy(this.worldBoundsTrail[0]);\n\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\n\t\tif (this.localSpace) {\n\t\t\tthis.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);\n\t\t\tthis.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);\n\t\t} else {\n\t\t\tthis.meshInstance.aabb.copy(this.worldBounds);\n\t\t\tthis.meshInstance.mesh.aabb.copy(this.worldBounds);\n\t\t}\n\n\t\tthis.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;\n\t\tif (this.pack8) this.calculateBoundsMad();\n\t}\n\n\tresetWorldBounds() {\n\t\tif (!this.node) return;\n\t\tthis.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());\n\t\tthis.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);\n\t\tthis.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);\n\t\tthis.worldBounds.copy(this.worldBoundsTrail[0]);\n\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\t\tthis.simTimeTotal = 0;\n\t\tthis.timeToSwitchBounds = 0;\n\t}\n\n\tcalculateLocalBounds() {\n\t\tlet minx = Number.MAX_VALUE;\n\t\tlet miny = Number.MAX_VALUE;\n\t\tlet minz = Number.MAX_VALUE;\n\t\tlet maxx = -Number.MAX_VALUE;\n\t\tlet maxy = -Number.MAX_VALUE;\n\t\tlet maxz = -Number.MAX_VALUE;\n\t\tlet maxR = 0;\n\t\tlet maxScale = 0;\n\t\tconst stepWeight = this.lifetime / this.precision;\n\t\tconst wVels = [this.qVelocity, this.qVelocity2];\n\t\tconst lVels = [this.qLocalVelocity, this.qLocalVelocity2];\n\t\tconst accumX = [0, 0];\n\t\tconst accumY = [0, 0];\n\t\tconst accumZ = [0, 0];\n\t\tconst accumR = [0, 0];\n\t\tconst accumW = [0, 0];\n\t\tlet x, y, z;\n\n\t\tfor (let i = 0; i < this.precision + 1; i++) {\n\t\t\tconst index = Math.min(i, this.precision - 1);\n\n\t\t\tfor (let j = 0; j < 2; j++) {\n\t\t\t\tx = lVels[j][index * 3 + 0] * stepWeight + accumX[j];\n\t\t\t\ty = lVels[j][index * 3 + 1] * stepWeight + accumY[j];\n\t\t\t\tz = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];\n\t\t\t\tminx = Math.min(x, minx);\n\t\t\t\tminy = Math.min(y, miny);\n\t\t\t\tminz = Math.min(z, minz);\n\t\t\t\tmaxx = Math.max(x, maxx);\n\t\t\t\tmaxy = Math.max(y, maxy);\n\t\t\t\tmaxz = Math.max(z, maxz);\n\t\t\t\taccumX[j] = x;\n\t\t\t\taccumY[j] = y;\n\t\t\t\taccumZ[j] = z;\n\t\t\t}\n\n\t\t\tfor (let j = 0; j < 2; j++) {\n\t\t\t\taccumW[j] += stepWeight * Math.sqrt(wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] + wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] + wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);\n\t\t\t}\n\n\t\t\taccumR[0] += this.qRadialSpeed[index] * stepWeight;\n\t\t\taccumR[1] += this.qRadialSpeed2[index] * stepWeight;\n\t\t\tmaxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));\n\t\t\tmaxScale = Math.max(maxScale, this.qScale[index]);\n\t\t}\n\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tx = this.emitterExtents.x * 0.5;\n\t\t\ty = this.emitterExtents.y * 0.5;\n\t\t\tz = this.emitterExtents.z * 0.5;\n\t\t} else {\n\t\t\tx = this.emitterRadius;\n\t\t\ty = this.emitterRadius;\n\t\t\tz = this.emitterRadius;\n\t\t}\n\n\t\tconst w = Math.max(accumW[0], accumW[1]);\n\t\tbMin.x = minx - maxScale - x - maxR - w;\n\t\tbMin.y = miny - maxScale - y - maxR - w;\n\t\tbMin.z = minz - maxScale - z - maxR - w;\n\t\tbMax.x = maxx + maxScale + x + maxR + w;\n\t\tbMax.y = maxy + maxScale + y + maxR + w;\n\t\tbMax.z = maxz + maxScale + z + maxR + w;\n\t\tthis.localBounds.setMinMax(bMin, bMax);\n\t}\n\n\trebuild() {\n\t\tconst gd = this.graphicsDevice;\n\t\tif (this.colorMap === null) this.colorMap = ParticleEmitter.DEFAULT_PARAM_TEXTURE;\n\t\tthis.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;\n\t\tthis.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;\n\n\t\tthis._destroyResources();\n\n\t\tthis.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;\n\t\tparticleTexHeight = this.useCpu || this.pack8 ? 4 : 2;\n\t\tthis.useMesh = false;\n\n\t\tif (this.mesh) {\n\t\t\tconst totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;\n\n\t\t\tif (totalVertCount > 65535) ; else {\n\t\t\t\tthis.useMesh = true;\n\t\t\t}\n\t\t}\n\n\t\tthis.numParticlesPot = math.nextPowerOfTwo(this.numParticles);\n\t\tthis.rebuildGraphs();\n\t\tthis.calculateLocalBounds();\n\t\tthis.resetWorldBounds();\n\n\t\tif (this.node) {\n\t\t\tthis.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());\n\t\t\tthis.worldBoundsTrail[0].copy(this.worldBounds);\n\t\t\tthis.worldBoundsTrail[1].copy(this.worldBounds);\n\t\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\t\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\t\t\tif (this.pack8) this.calculateBoundsMad();\n\t\t}\n\n\t\tthis.vbToSort = new Array(this.numParticles);\n\n\t\tfor (let iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];\n\n\t\tthis.particleDistance = new Float32Array(this.numParticles);\n\n\t\tthis._gpuUpdater.randomize();\n\n\t\tthis.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);\n\t\tconst emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();\n\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tif (this.node === null || this.localSpace) {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);\n\t\t\t} else {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));\n\t\t\t}\n\n\t\t\textentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;\n\t\t\textentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;\n\t\t\textentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;\n\t\t}\n\n\t\tfor (let i = 0; i < this.numParticles; i++) {\n\t\t\tthis._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);\n\n\t\t\tif (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;\n\t\t}\n\n\t\tthis.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);\n\n\t\tfor (let i = 0; i < this.particleTexStart.length; i++) {\n\t\t\tthis.particleTexStart[i] = this.particleTex[i];\n\t\t}\n\n\t\tif (!this.useCpu) {\n\t\t\tif (this.pack8) {\n\t\t\t\tthis.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);\n\t\t\t\tthis.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);\n\t\t\t\tthis.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_R8_G8_B8_A8, 1, false);\n\t\t\t} else {\n\t\t\t\tthis.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);\n\t\t\t\tthis.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);\n\t\t\t\tthis.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);\n\t\t\t}\n\n\t\t\tthis.rtParticleTexIN = new RenderTarget({\n\t\t\t\tcolorBuffer: this.particleTexIN,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tthis.rtParticleTexOUT = new RenderTarget({\n\t\t\t\tcolorBuffer: this.particleTexOUT,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tthis.swapTex = false;\n\t\t}\n\n\t\tconst shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;\n\t\tconst shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst params = this.emitterShape + \"\" + this.pack8 + \"\" + this.localSpace;\n\t\tthis.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, \"fsQuad0\" + params);\n\t\tthis.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, \"fsQuad1\" + params);\n\t\tthis.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, \"fsQuad2\" + params);\n\t\tthis.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;\n\t\tthis.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;\n\n\t\tthis._allocate(this.numParticles);\n\n\t\tconst mesh = new Mesh(gd);\n\t\tmesh.vertexBuffer = this.vertexBuffer;\n\t\tmesh.indexBuffer[0] = this.indexBuffer;\n\t\tmesh.primitive[0].type = PRIMITIVE_TRIANGLES;\n\t\tmesh.primitive[0].base = 0;\n\t\tmesh.primitive[0].count = this.numParticles * this.numParticleIndices;\n\t\tmesh.primitive[0].indexed = true;\n\t\tthis.material = new Material();\n\t\tthis.material.name = this.node.name;\n\t\tthis.material.cull = CULLFACE_NONE;\n\t\tthis.material.alphaWrite = false;\n\t\tthis.material.blend = true;\n\t\tthis.material.blendType = this.blendType;\n\t\tthis.material.depthWrite = this.depthWrite;\n\t\tthis.material.emitter = this;\n\t\tthis.regenShader();\n\t\tthis.resetMaterial();\n\t\tconst wasVisible = this.meshInstance ? this.meshInstance.visible : true;\n\t\tthis.meshInstance = new MeshInstance(mesh, this.material, this.node);\n\t\tthis.meshInstance.pick = false;\n\t\tthis.meshInstance.updateKey();\n\t\tthis.meshInstance.cull = true;\n\t\tthis.meshInstance._noDepthDrawGl1 = true;\n\n\t\tif (this.localSpace) {\n\t\t\tthis.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());\n\t\t} else {\n\t\t\tthis.meshInstance.aabb.copy(this.worldBounds);\n\t\t}\n\n\t\tthis.meshInstance._updateAabb = false;\n\t\tthis.meshInstance.visible = wasVisible;\n\n\t\tthis._initializeTextures();\n\n\t\tthis.resetTime();\n\t\tthis.addTime(0, false);\n\t\tif (this.preWarm) this.prewarm(this.lifetime);\n\t}\n\n\t_isAnimated() {\n\t\treturn this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== ParticleEmitter.DEFAULT_PARAM_TEXTURE || this.normalMap);\n\t}\n\n\trebuildGraphs() {\n\t\tconst precision = this.precision;\n\t\tconst gd = this.graphicsDevice;\n\t\tthis.qLocalVelocity = this.localVelocityGraph.quantize(precision);\n\t\tthis.qVelocity = this.velocityGraph.quantize(precision);\n\t\tthis.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);\n\t\tthis.qRotSpeed = this.rotationSpeedGraph.quantize(precision);\n\t\tthis.qScale = this.scaleGraph.quantize(precision);\n\t\tthis.qAlpha = this.alphaGraph.quantize(precision);\n\t\tthis.qRadialSpeed = this.radialSpeedGraph.quantize(precision);\n\t\tthis.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);\n\t\tthis.qVelocity2 = this.velocityGraph2.quantize(precision);\n\t\tthis.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);\n\t\tthis.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);\n\t\tthis.qScale2 = this.scaleGraph2.quantize(precision);\n\t\tthis.qAlpha2 = this.alphaGraph2.quantize(precision);\n\t\tthis.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);\n\n\t\tfor (let i = 0; i < precision; i++) {\n\t\t\tthis.qRotSpeed[i] *= math.DEG_TO_RAD;\n\t\t\tthis.qRotSpeed2[i] *= math.DEG_TO_RAD;\n\t\t}\n\n\t\tthis.localVelocityUMax = new Float32Array(3);\n\t\tthis.velocityUMax = new Float32Array(3);\n\t\tthis.colorUMax = new Float32Array(3);\n\t\tthis.rotSpeedUMax = [0];\n\t\tthis.scaleUMax = [0];\n\t\tthis.alphaUMax = [0];\n\t\tthis.radialSpeedUMax = [0];\n\t\tthis.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);\n\t\tthis.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);\n\t\tthis.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);\n\t\tthis.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);\n\t\tthis.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);\n\t\tthis.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);\n\t\tthis.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);\n\n\t\tif (this.pack8) {\n\t\t\tconst umax = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qVelocity, umax);\n\t\t\tconst umax2 = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qVelocity2, umax2);\n\t\t\tconst lumax = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qLocalVelocity, lumax);\n\t\t\tconst lumax2 = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qLocalVelocity2, lumax2);\n\t\t\tconst rumax = [0];\n\t\t\tmaxUnsignedGraphValue(this.qRadialSpeed, rumax);\n\t\t\tconst rumax2 = [0];\n\t\t\tmaxUnsignedGraphValue(this.qRadialSpeed2, rumax2);\n\t\t\tlet maxVel = Math.max(umax[0], umax2[0]);\n\t\t\tmaxVel = Math.max(maxVel, umax[1]);\n\t\t\tmaxVel = Math.max(maxVel, umax2[1]);\n\t\t\tmaxVel = Math.max(maxVel, umax[2]);\n\t\t\tmaxVel = Math.max(maxVel, umax2[2]);\n\t\t\tlet lmaxVel = Math.max(lumax[0], lumax2[0]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax[1]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax2[1]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax[2]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax2[2]);\n\t\t\tconst maxRad = Math.max(rumax[0], rumax2[0]);\n\t\t\tthis.maxVel = maxVel + lmaxVel + maxRad;\n\t\t}\n\n\t\tif (!this.useCpu) {\n\t\t\tthis.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));\n\t\t\tthis.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));\n\t\t\tthis.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));\n\t\t\tthis.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));\n\t\t}\n\n\t\tthis.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_R8_G8_B8_A8, 1.0, true);\n\t}\n\n\t_initializeTextures() {\n\t\tif (this.colorMap) {\n\t\t\tthis.material.setParameter('colorMap', this.colorMap);\n\n\t\t\tif (this.lighting && this.normalMap) {\n\t\t\t\tthis.material.setParameter('normalMap', this.normalMap);\n\t\t\t}\n\t\t}\n\t}\n\n\tregenShader() {\n\t\tconst programLib = this.graphicsDevice.getProgramLibrary();\n\t\tconst hasNormal = this.normalMap !== null;\n\t\tthis.normalOption = 0;\n\n\t\tif (this.lighting) {\n\t\t\tthis.normalOption = hasNormal ? 2 : 1;\n\t\t}\n\n\t\tthis.material.updateShader = function () {\n\t\t\tif (this.emitter.scene) {\n\t\t\t\tif (this.emitter.camera !== this.emitter.scene._activeCamera) {\n\t\t\t\t\tthis.emitter.camera = this.emitter.scene._activeCamera;\n\t\t\t\t\tthis.emitter.onChangeCamera();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst inTools = this.emitter.inTools;\n\t\t\tconst shader = programLib.getProgram(\"particle\", {\n\t\t\t\tuseCpu: this.emitter.useCpu,\n\t\t\t\tnormal: this.emitter.normalOption,\n\t\t\t\thalflambert: this.emitter.halfLambert,\n\t\t\t\tstretch: this.emitter.stretch,\n\t\t\t\talignToMotion: this.emitter.alignToMotion,\n\t\t\t\tsoft: this.emitter.depthSoftening,\n\t\t\t\tmesh: this.emitter.useMesh,\n\t\t\t\tgamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,\n\t\t\t\ttoneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,\n\t\t\t\tfog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : \"none\",\n\t\t\t\twrap: this.emitter.wrap && this.emitter.wrapBounds,\n\t\t\t\tlocalSpace: this.emitter.localSpace,\n\t\t\t\tscreenSpace: inTools ? false : this.emitter.screenSpace,\n\t\t\t\tblend: this.blendType,\n\t\t\t\tanimTex: this.emitter._isAnimated(),\n\t\t\t\tanimTexLoop: this.emitter.animLoop,\n\t\t\t\tpack8: this.emitter.pack8,\n\t\t\t\tcustomFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN\n\t\t\t});\n\t\t\tthis.shader = shader;\n\t\t};\n\n\t\tthis.material.updateShader();\n\t}\n\n\tresetMaterial() {\n\t\tconst material = this.material;\n\t\tmaterial.setParameter('stretch', this.stretch);\n\n\t\tif (this._isAnimated()) {\n\t\t\tmaterial.setParameter('animTexTilesParams', this.animTilesParams);\n\t\t\tmaterial.setParameter('animTexParams', this.animParams);\n\t\t\tmaterial.setParameter('animTexIndexParams', this.animIndexParams);\n\t\t}\n\n\t\tmaterial.setParameter('colorMult', this.intensity);\n\n\t\tif (!this.useCpu) {\n\t\t\tmaterial.setParameter('internalTex0', this.internalTex0);\n\t\t\tmaterial.setParameter('internalTex1', this.internalTex1);\n\t\t\tmaterial.setParameter('internalTex2', this.internalTex2);\n\t\t\tmaterial.setParameter('internalTex3', this.internalTex3);\n\t\t}\n\n\t\tmaterial.setParameter('colorParam', this.colorParam);\n\t\tmaterial.setParameter('numParticles', this.numParticles);\n\t\tmaterial.setParameter('numParticlesPot', this.numParticlesPot);\n\t\tmaterial.setParameter('lifetime', this.lifetime);\n\t\tmaterial.setParameter('rate', this.rate);\n\t\tmaterial.setParameter('rateDiv', this.rate2 - this.rate);\n\t\tmaterial.setParameter('seed', this.seed);\n\t\tmaterial.setParameter('scaleDivMult', this.scaleUMax[0]);\n\t\tmaterial.setParameter('alphaDivMult', this.alphaUMax[0]);\n\t\tmaterial.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);\n\t\tmaterial.setParameter(\"graphNumSamples\", this.precision);\n\t\tmaterial.setParameter(\"graphSampleSize\", 1.0 / this.precision);\n\t\tmaterial.setParameter(\"emitterScale\", new Float32Array([1, 1, 1]));\n\n\t\tif (this.pack8) {\n\t\t\tthis._gpuUpdater._setInputBounds();\n\n\t\t\tmaterial.setParameter(\"inBoundsSize\", this._gpuUpdater.inBoundsSizeUniform);\n\t\t\tmaterial.setParameter(\"inBoundsCenter\", this._gpuUpdater.inBoundsCenterUniform);\n\t\t\tmaterial.setParameter(\"maxVel\", this.maxVel);\n\t\t}\n\n\t\tif (this.wrap && this.wrapBounds) {\n\t\t\tthis.wrapBoundsUniform[0] = this.wrapBounds.x;\n\t\t\tthis.wrapBoundsUniform[1] = this.wrapBounds.y;\n\t\t\tthis.wrapBoundsUniform[2] = this.wrapBounds.z;\n\t\t\tmaterial.setParameter('wrapBounds', this.wrapBoundsUniform);\n\t\t}\n\n\t\tif (this.colorMap) {\n\t\t\tmaterial.setParameter('colorMap', this.colorMap);\n\t\t}\n\n\t\tif (this.lighting) {\n\t\t\tif (this.normalMap) {\n\t\t\t\tmaterial.setParameter('normalMap', this.normalMap);\n\t\t\t}\n\t\t}\n\n\t\tif (this.depthSoftening > 0) {\n\t\t\tmaterial.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));\n\t\t}\n\n\t\tif (this.stretch > 0.0) material.cull = CULLFACE_NONE;\n\n\t\tthis._compParticleFaceParams();\n\t}\n\n\t_compParticleFaceParams() {\n\t\tlet tangent, binormal;\n\n\t\tif (this.orientation === PARTICLEORIENTATION_SCREEN) {\n\t\t\ttangent = new Float32Array([1, 0, 0]);\n\t\t\tbinormal = new Float32Array([0, 0, 1]);\n\t\t} else {\n\t\t\tlet n;\n\n\t\t\tif (this.orientation === PARTICLEORIENTATION_WORLD) {\n\t\t\t\tn = this.particleNormal.normalize();\n\t\t\t} else {\n\t\t\t\tconst emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();\n\t\t\t\tn = emitterMat.transformVector(this.particleNormal).normalize();\n\t\t\t}\n\n\t\t\tconst t = new Vec3(1, 0, 0);\n\t\t\tif (Math.abs(t.dot(n)) === 1) t.set(0, 0, 1);\n\t\t\tconst b = new Vec3().cross(n, t).normalize();\n\t\t\tt.cross(b, n).normalize();\n\t\t\ttangent = new Float32Array([t.x, t.y, t.z]);\n\t\t\tbinormal = new Float32Array([b.x, b.y, b.z]);\n\t\t}\n\n\t\tthis.material.setParameter(\"faceTangent\", tangent);\n\t\tthis.material.setParameter(\"faceBinorm\", binormal);\n\t}\n\n\t_allocate(numParticles) {\n\t\tconst psysVertCount = numParticles * this.numParticleVerts;\n\t\tconst psysIndexCount = numParticles * this.numParticleIndices;\n\n\t\tif (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {\n\t\t\tif (!this.useCpu) {\n\t\t\t\tconst elements = [{\n\t\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}];\n\n\t\t\t\tif (this.useMesh) {\n\t\t\t\t\telements.push({\n\t\t\t\t\t\tsemantic: SEMANTIC_ATTR1,\n\t\t\t\t\t\tcomponents: 2,\n\t\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst particleFormat = new VertexFormat(this.graphicsDevice, elements);\n\t\t\t\tthis.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);\n\t\t\t\tthis.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);\n\t\t\t} else {\n\t\t\t\tconst elements = [{\n\t\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR1,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR2,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR3,\n\t\t\t\t\tcomponents: 1,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR4,\n\t\t\t\t\tcomponents: this.useMesh ? 4 : 2,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}];\n\t\t\t\tconst particleFormat = new VertexFormat(this.graphicsDevice, elements);\n\t\t\t\tthis.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);\n\t\t\t\tthis.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);\n\t\t\t}\n\n\t\t\tconst data = new Float32Array(this.vertexBuffer.lock());\n\t\t\tlet meshData, stride, texCoordOffset;\n\n\t\t\tif (this.useMesh) {\n\t\t\t\tmeshData = new Float32Array(this.mesh.vertexBuffer.lock());\n\t\t\t\tstride = meshData.length / this.mesh.vertexBuffer.numVertices;\n\n\t\t\t\tfor (let elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {\n\t\t\t\t\tif (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {\n\t\t\t\t\t\ttexCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < psysVertCount; i++) {\n\t\t\t\tconst id = Math.floor(i / this.numParticleVerts);\n\n\t\t\t\tif (!this.useMesh) {\n\t\t\t\t\tconst vertID = i % 4;\n\t\t\t\t\tdata[i * 4] = particleVerts[vertID][0];\n\t\t\t\t\tdata[i * 4 + 1] = particleVerts[vertID][1];\n\t\t\t\t\tdata[i * 4 + 2] = 0;\n\t\t\t\t\tdata[i * 4 + 3] = id;\n\t\t\t\t} else {\n\t\t\t\t\tconst vert = i % this.numParticleVerts;\n\t\t\t\t\tdata[i * 6] = meshData[vert * stride];\n\t\t\t\t\tdata[i * 6 + 1] = meshData[vert * stride + 1];\n\t\t\t\t\tdata[i * 6 + 2] = meshData[vert * stride + 2];\n\t\t\t\t\tdata[i * 6 + 3] = id;\n\t\t\t\t\tdata[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];\n\t\t\t\t\tdata[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.useCpu) {\n\t\t\t\tthis.vbCPU = new Float32Array(data);\n\t\t\t\tthis.vbOld = new Float32Array(this.vbCPU.length);\n\t\t\t}\n\n\t\t\tthis.vertexBuffer.unlock();\n\n\t\t\tif (this.useMesh) {\n\t\t\t\tthis.mesh.vertexBuffer.unlock();\n\t\t\t}\n\n\t\t\tlet dst = 0;\n\t\t\tconst indices = new Uint16Array(this.indexBuffer.lock());\n\t\t\tif (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());\n\n\t\t\tfor (let i = 0; i < numParticles; i++) {\n\t\t\t\tif (!this.useMesh) {\n\t\t\t\t\tconst baseIndex = i * 4;\n\t\t\t\t\tindices[dst++] = baseIndex;\n\t\t\t\t\tindices[dst++] = baseIndex + 1;\n\t\t\t\t\tindices[dst++] = baseIndex + 2;\n\t\t\t\t\tindices[dst++] = baseIndex;\n\t\t\t\t\tindices[dst++] = baseIndex + 2;\n\t\t\t\t\tindices[dst++] = baseIndex + 3;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let j = 0; j < this.numParticleIndices; j++) {\n\t\t\t\t\t\tindices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.indexBuffer.unlock();\n\t\t\tif (this.useMesh) this.mesh.indexBuffer[0].unlock();\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.beenReset = true;\n\t\tthis.seed = Math.random();\n\t\tthis.material.setParameter('seed', this.seed);\n\n\t\tif (this.useCpu) {\n\t\t\tfor (let i = 0; i < this.particleTexStart.length; i++) {\n\t\t\t\tthis.particleTex[i] = this.particleTexStart[i];\n\t\t\t}\n\t\t} else {\n\t\t\tthis._initializeTextures();\n\t\t}\n\n\t\tthis.resetWorldBounds();\n\t\tthis.resetTime();\n\t\tconst origLoop = this.loop;\n\t\tthis.loop = true;\n\t\tthis.addTime(0, false);\n\t\tthis.loop = origLoop;\n\n\t\tif (this.preWarm) {\n\t\t\tthis.prewarm(this.lifetime);\n\t\t}\n\t}\n\n\tprewarm(time) {\n\t\tconst lifetimeFraction = time / this.lifetime;\n\t\tconst iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);\n\t\tconst stepDelta = time / iterations;\n\n\t\tfor (let i = 0; i < iterations; i++) {\n\t\t\tthis.addTime(stepDelta, false);\n\t\t}\n\t}\n\n\tresetTime() {\n\t\tthis.endTime = calcEndTime(this);\n\t}\n\n\tfinishFrame() {\n\t\tif (this.useCpu) this.vertexBuffer.unlock();\n\t}\n\n\taddTime(delta, isOnStop) {\n\t\tconst device = this.graphicsDevice;\n\t\tthis.simTimeTotal += delta;\n\t\tthis.calculateWorldBounds();\n\n\t\tif (this._isAnimated()) {\n\t\t\tconst tilesParams = this.animTilesParams;\n\t\t\ttilesParams[0] = 1.0 / this.animTilesX;\n\t\t\ttilesParams[1] = 1.0 / this.animTilesY;\n\t\t\tconst params = this.animParams;\n\t\t\tparams[0] = this.animStartFrame;\n\t\t\tparams[1] = this.animNumFrames * this.animSpeed;\n\t\t\tparams[2] = this.animNumFrames - 1;\n\t\t\tparams[3] = this.animNumAnimations - 1;\n\t\t\tconst animIndexParams = this.animIndexParams;\n\t\t\tanimIndexParams[0] = this.animIndex;\n\t\t\tanimIndexParams[1] = this.randomizeAnimIndex;\n\t\t}\n\n\t\tif (this.scene) {\n\t\t\tif (this.camera !== this.scene._activeCamera) {\n\t\t\t\tthis.camera = this.scene._activeCamera;\n\t\t\t\tthis.onChangeCamera();\n\t\t\t}\n\t\t}\n\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\textentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;\n\t\t\textentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;\n\t\t\textentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;\n\n\t\t\tif (this.meshInstance.node === null) {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);\n\t\t\t} else {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));\n\t\t\t}\n\t\t}\n\n\t\tlet emitterPos;\n\t\tconst emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;\n\t\tthis.emitterScaleUniform[0] = emitterScale.x;\n\t\tthis.emitterScaleUniform[1] = emitterScale.y;\n\t\tthis.emitterScaleUniform[2] = emitterScale.z;\n\t\tthis.material.setParameter(\"emitterScale\", this.emitterScaleUniform);\n\n\t\tif (this.localSpace && this.meshInstance.node) {\n\t\t\temitterPos = this.meshInstance.node.getPosition();\n\t\t\tthis.emitterPosUniform[0] = emitterPos.x;\n\t\t\tthis.emitterPosUniform[1] = emitterPos.y;\n\t\t\tthis.emitterPosUniform[2] = emitterPos.z;\n\t\t\tthis.material.setParameter(\"emitterPos\", this.emitterPosUniform);\n\t\t}\n\n\t\tthis._compParticleFaceParams();\n\n\t\tif (!this.useCpu) {\n\t\t\tthis._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);\n\t\t} else {\n\t\t\tconst data = new Float32Array(this.vertexBuffer.lock());\n\n\t\t\tthis._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);\n\t\t}\n\n\t\tif (!this.loop) {\n\t\t\tif (Date.now() > this.endTime) {\n\t\t\t\tif (this.onFinished) this.onFinished();\n\t\t\t\tthis.meshInstance.visible = false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.meshInstance) {\n\t\t\tthis.meshInstance.drawOrder = this.drawOrder;\n\t\t}\n\t}\n\n\t_destroyResources() {\n\t\tif (this.particleTexIN) {\n\t\t\tthis.particleTexIN.destroy();\n\t\t\tthis.particleTexIN = null;\n\t\t}\n\n\t\tif (this.particleTexOUT) {\n\t\t\tthis.particleTexOUT.destroy();\n\t\t\tthis.particleTexOUT = null;\n\t\t}\n\n\t\tif (this.particleTexStart && this.particleTexStart.destroy) {\n\t\t\tthis.particleTexStart.destroy();\n\t\t\tthis.particleTexStart = null;\n\t\t}\n\n\t\tif (this.rtParticleTexIN) {\n\t\t\tthis.rtParticleTexIN.destroy();\n\t\t\tthis.rtParticleTexIN = null;\n\t\t}\n\n\t\tif (this.rtParticleTexOUT) {\n\t\t\tthis.rtParticleTexOUT.destroy();\n\t\t\tthis.rtParticleTexOUT = null;\n\t\t}\n\n\t\tif (this.internalTex0) {\n\t\t\tthis.internalTex0.destroy();\n\t\t\tthis.internalTex0 = null;\n\t\t}\n\n\t\tif (this.internalTex1) {\n\t\t\tthis.internalTex1.destroy();\n\t\t\tthis.internalTex1 = null;\n\t\t}\n\n\t\tif (this.internalTex2) {\n\t\t\tthis.internalTex2.destroy();\n\t\t\tthis.internalTex2 = null;\n\t\t}\n\n\t\tif (this.internalTex3) {\n\t\t\tthis.internalTex3.destroy();\n\t\t\tthis.internalTex3 = null;\n\t\t}\n\n\t\tif (this.colorParam) {\n\t\t\tthis.colorParam.destroy();\n\t\t\tthis.colorParam = null;\n\t\t}\n\n\t\tif (this.vertexBuffer) {\n\t\t\tthis.vertexBuffer.destroy();\n\t\t\tthis.vertexBuffer = undefined;\n\t\t}\n\n\t\tif (this.indexBuffer) {\n\t\t\tthis.indexBuffer.destroy();\n\t\t\tthis.indexBuffer = undefined;\n\t\t}\n\n\t\tif (this.material) {\n\t\t\tthis.material.destroy();\n\t\t\tthis.material = null;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis.camera = null;\n\n\t\tthis._destroyResources();\n\t}\n\n}\n\nParticleEmitter.DEFAULT_PARAM_TEXTURE = null;\n\nconst _floatRounding = 0.2;\n\nclass Morph extends RefCountedObject {\n\tconstructor(targets, graphicsDevice) {\n\t\tsuper();\n\t\tthis.device = graphicsDevice || getApplication().graphicsDevice;\n\t\tthis._targets = targets;\n\n\t\tif (this.device.supportsMorphTargetTexturesCore) {\n\t\t\tif (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable) {\n\t\t\t\tthis._renderTextureFormat = Morph.FORMAT_HALF_FLOAT;\n\t\t\t} else if (this.device.extTextureFloat && this.device.textureFloatRenderable) {\n\t\t\t\tthis._renderTextureFormat = Morph.FORMAT_FLOAT;\n\t\t\t}\n\n\t\t\tif (this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable) {\n\t\t\t\tthis._textureFormat = Morph.FORMAT_HALF_FLOAT;\n\t\t\t} else if (this.device.extTextureFloat) {\n\t\t\t\tthis._textureFormat = Morph.FORMAT_FLOAT;\n\t\t\t}\n\n\t\t\tif (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {\n\t\t\t\tthis._useTextureMorph = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._init();\n\n\t\tthis._updateMorphFlags();\n\n\t\tthis._calculateAabb();\n\t}\n\n\tget morphPositions() {\n\t\treturn this._morphPositions;\n\t}\n\n\tget morphNormals() {\n\t\treturn this._morphNormals;\n\t}\n\n\tget maxActiveTargets() {\n\t\tif (this._useTextureMorph) return this._targets.length;\n\t\treturn this._morphPositions && this._morphNormals ? 4 : 8;\n\t}\n\n\tget useTextureMorph() {\n\t\treturn this._useTextureMorph;\n\t}\n\n\t_init() {\n\t\tif (this._useTextureMorph) {\n\t\t\tthis._useTextureMorph = this._initTextureBased();\n\t\t}\n\n\t\tif (!this._useTextureMorph) {\n\t\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\t\tthis._targets[i]._initVertexBuffers(this.device);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tthis._targets[i]._postInit();\n\t\t}\n\t}\n\n\t_initTextureBased() {\n\t\tconst deltaArrays = [],\n\t\t\t\t\tdeltaInfos = [];\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tconst target = this._targets[i];\n\n\t\t\tif (target.options.deltaPositions) {\n\t\t\t\tdeltaArrays.push(target.options.deltaPositions);\n\t\t\t\tdeltaInfos.push({\n\t\t\t\t\ttarget: target,\n\t\t\t\t\tname: 'texturePositions'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (target.options.deltaNormals) {\n\t\t\t\tdeltaArrays.push(target.options.deltaNormals);\n\t\t\t\tdeltaInfos.push({\n\t\t\t\t\ttarget: target,\n\t\t\t\t\tname: 'textureNormals'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst ids = [],\n\t\t\t\t\tusedDataIndices = [];\n\t\tlet freeIndex = 1;\n\t\tconst dataCount = deltaArrays[0].length;\n\n\t\tfor (let v = 0; v < dataCount; v += 3) {\n\t\t\tlet vertexUsed = false;\n\n\t\t\tfor (let i = 0; i < deltaArrays.length; i++) {\n\t\t\t\tconst data = deltaArrays[i];\n\n\t\t\t\tif (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {\n\t\t\t\t\tvertexUsed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vertexUsed) {\n\t\t\t\tids.push(freeIndex + _floatRounding);\n\t\t\t\tusedDataIndices.push(v / 3);\n\t\t\t\tfreeIndex++;\n\t\t\t} else {\n\t\t\t\tids.push(0 + _floatRounding);\n\t\t\t}\n\t\t}\n\n\t\tconst maxTextureSize = Math.min(this.device.maxTextureSize, 4096);\n\t\tlet morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));\n\t\tmorphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);\n\t\tconst morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);\n\n\t\tif (morphTextureHeight > maxTextureSize) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.morphTextureWidth = morphTextureWidth;\n\t\tthis.morphTextureHeight = morphTextureHeight;\n\t\tlet halfFloat = false;\n\t\tlet numComponents = 3;\n\t\tconst float2Half = FloatPacking.float2Half;\n\n\t\tif (this._textureFormat === Morph.FORMAT_HALF_FLOAT) {\n\t\t\thalfFloat = true;\n\t\t\tnumComponents = 4;\n\t\t}\n\n\t\tconst arraySize = this.morphTextureWidth * this.morphTextureHeight * numComponents;\n\t\tconst packedDeltas = halfFloat ? new Uint16Array(arraySize) : new Float32Array(arraySize);\n\n\t\tfor (let i = 0; i < deltaArrays.length; i++) {\n\t\t\tconst data = deltaArrays[i];\n\n\t\t\tfor (let v = 0; v < usedDataIndices.length; v++) {\n\t\t\t\tconst index = usedDataIndices[v];\n\n\t\t\t\tif (halfFloat) {\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents] = float2Half(data[index * 3]);\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents + 1] = float2Half(data[index * 3 + 1]);\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents + 2] = float2Half(data[index * 3 + 2]);\n\t\t\t\t} else {\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents] = data[index * 3];\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents + 1] = data[index * 3 + 1];\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents + 2] = data[index * 3 + 2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst target = deltaInfos[i].target;\n\t\t\tconst format = this._textureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;\n\n\t\t\ttarget._setTexture(deltaInfos[i].name, this._createTexture(\"MorphTarget\", format, packedDeltas));\n\t\t}\n\n\t\tconst formatDesc = [{\n\t\t\tsemantic: SEMANTIC_ATTR15,\n\t\t\tcomponents: 1,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}];\n\t\tthis.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));\n\t\treturn true;\n\t}\n\n\tdestroy() {\n\t\tif (this.vertexBufferIds) {\n\t\t\tthis.vertexBufferIds.destroy();\n\t\t\tthis.vertexBufferIds = null;\n\t\t}\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tthis._targets[i].destroy();\n\t\t}\n\n\t\tthis._targets.length = 0;\n\t}\n\n\tget targets() {\n\t\treturn this._targets;\n\t}\n\n\t_updateMorphFlags() {\n\t\tthis._morphPositions = false;\n\t\tthis._morphNormals = false;\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tconst target = this._targets[i];\n\n\t\t\tif (target.morphPositions) {\n\t\t\t\tthis._morphPositions = true;\n\t\t\t}\n\n\t\t\tif (target.morphNormals) {\n\t\t\t\tthis._morphNormals = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t_calculateAabb() {\n\t\tconst min = new Vec3();\n\t\tconst max = new Vec3();\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tconst targetAabb = this._targets[i].aabb;\n\t\t\tmin.min(targetAabb.getMin());\n\t\t\tmax.max(targetAabb.getMax());\n\t\t}\n\n\t\tthis.aabb = new BoundingBox();\n\t\tthis.aabb.setMinMax(min, max);\n\t}\n\n\t_createTexture(name, format, pixelData) {\n\t\tconst texture = new Texture(this.device, {\n\t\t\twidth: this.morphTextureWidth,\n\t\t\theight: this.morphTextureHeight,\n\t\t\tformat: format,\n\t\t\tcubemap: false,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\ttexture.name = name;\n\n\t\tif (pixelData) {\n\t\t\ttexture.lock().set(pixelData);\n\t\t\ttexture.unlock();\n\t\t}\n\n\t\treturn texture;\n\t}\n\n}\n\nMorph.FORMAT_FLOAT = 0;\nMorph.FORMAT_HALF_FLOAT = 1;\n\nconst textureMorphVertexShader = `\n\t\tattribute vec2 vertex_position;\n\t\tvarying vec2 uv0;\n\t\tvoid main(void) {\n\t\t\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\t\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t}\n\t\t`;\n\nclass MorphInstance {\n\tconstructor(morph) {\n\t\tthis.morph = morph;\n\t\tmorph.incRefCount();\n\t\tthis.device = morph.device;\n\t\tthis.meshInstance = null;\n\t\tthis._weights = [];\n\n\t\tfor (let v = 0; v < morph._targets.length; v++) {\n\t\t\tthis.setWeight(v, morph._targets[v].defaultWeight);\n\t\t}\n\n\t\tthis._activeTargets = [];\n\n\t\tif (morph.useTextureMorph) {\n\t\t\tthis.shaderCache = {};\n\t\t\tthis.maxSubmitCount = this.device.maxTextures;\n\t\t\tthis._shaderMorphWeights = new Float32Array(this.maxSubmitCount);\n\n\t\t\tconst createRT = (name, textureVar) => {\n\t\t\t\tconst format = morph._renderTextureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;\n\t\t\t\tthis[textureVar] = morph._createTexture(name, format);\n\t\t\t\treturn new RenderTarget({\n\t\t\t\t\tcolorBuffer: this[textureVar],\n\t\t\t\t\tdepth: false\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tif (morph.morphPositions) {\n\t\t\t\tthis.rtPositions = createRT(\"MorphRTPos\", \"texturePositions\");\n\t\t\t}\n\n\t\t\tif (morph.morphNormals) {\n\t\t\t\tthis.rtNormals = createRT(\"MorphRTNrm\", \"textureNormals\");\n\t\t\t}\n\n\t\t\tthis._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);\n\n\t\t\tfor (let i = 0; i < this.maxSubmitCount; i++) {\n\t\t\t\tthis[\"morphBlendTex\" + i] = this.device.scope.resolve(\"morphBlendTex\" + i);\n\t\t\t}\n\n\t\t\tthis.morphFactor = this.device.scope.resolve(\"morphFactor[0]\");\n\t\t\tthis.zeroTextures = false;\n\t\t} else {\n\t\t\tthis.maxSubmitCount = 8;\n\t\t\tthis._shaderMorphWeights = new Float32Array(this.maxSubmitCount);\n\t\t\tthis._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);\n\t\t\tthis._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);\n\t\t\tthis._activeVertexBuffers = new Array(this.maxSubmitCount);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis.meshInstance = null;\n\t\tthis.shader = null;\n\t\tconst morph = this.morph;\n\n\t\tif (morph) {\n\t\t\tthis.morph = null;\n\t\t\tmorph.decRefCount();\n\n\t\t\tif (morph.refCount < 1) {\n\t\t\t\tmorph.destroy();\n\t\t\t}\n\t\t}\n\n\t\tif (this.rtPositions) {\n\t\t\tthis.rtPositions.destroy();\n\t\t\tthis.rtPositions = null;\n\t\t}\n\n\t\tif (this.texturePositions) {\n\t\t\tthis.texturePositions.destroy();\n\t\t\tthis.texturePositions = null;\n\t\t}\n\n\t\tif (this.rtNormals) {\n\t\t\tthis.rtNormals.destroy();\n\t\t\tthis.rtNormals = null;\n\t\t}\n\n\t\tif (this.textureNormals) {\n\t\t\tthis.textureNormals.destroy();\n\t\t\tthis.textureNormals = null;\n\t\t}\n\t}\n\n\tclone() {\n\t\tconst clone = new MorphInstance(this.morph);\n\t\treturn clone;\n\t}\n\n\tgetWeight(index) {\n\t\treturn this._weights[index];\n\t}\n\n\tsetWeight(index, weight) {\n\t\tthis._weights[index] = weight;\n\t\tthis._dirty = true;\n\t}\n\n\t_getFragmentShader(numTextures) {\n\t\tlet fragmentShader = '';\n\n\t\tif (numTextures > 0) {\n\t\t\tfragmentShader += 'varying vec2 uv0;\\n' + 'uniform highp float morphFactor[' + numTextures + '];\\n';\n\t\t}\n\n\t\tfor (let i = 0; i < numTextures; i++) {\n\t\t\tfragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\\n';\n\t\t}\n\n\t\tfragmentShader += 'void main (void) {\\n' + '\t\thighp vec4 color = vec4(0, 0, 0, 1);\\n';\n\n\t\tfor (let i = 0; i < numTextures; i++) {\n\t\t\tfragmentShader += '\t\tcolor.xyz += morphFactor[' + i + '] * texture2D(morphBlendTex' + i + ', uv0).xyz;\\n';\n\t\t}\n\n\t\tfragmentShader += '\t\tgl_FragColor = color;\\n' + '}\\n';\n\t\treturn fragmentShader;\n\t}\n\n\t_getShader(count) {\n\t\tlet shader = this.shaderCache[count];\n\n\t\tif (!shader) {\n\t\t\tconst fs = this._getFragmentShader(count);\n\n\t\t\tshader = createShaderFromCode(this.device, textureMorphVertexShader, fs, \"textureMorph\" + count);\n\t\t\tthis.shaderCache[count] = shader;\n\t\t}\n\n\t\treturn shader;\n\t}\n\n\t_updateTextureRenderTarget(renderTarget, srcTextureName) {\n\t\tconst device = this.device;\n\n\t\tconst submitBatch = (usedCount, blending) => {\n\t\t\tthis.morphFactor.setValue(this._shaderMorphWeights);\n\t\t\tdevice.setBlending(blending);\n\n\t\t\tif (blending) {\n\t\t\t\tdevice.setBlendFunction(BLENDMODE_ONE, BLENDMODE_ONE);\n\t\t\t\tdevice.setBlendEquation(BLENDEQUATION_ADD);\n\t\t\t}\n\n\t\t\tconst shader = this._getShader(usedCount);\n\n\t\t\tdrawQuadWithShader(device, renderTarget, shader, undefined, undefined, blending);\n\t\t};\n\n\t\tlet usedCount = 0;\n\t\tlet blending = false;\n\t\tconst count = this._activeTargets.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst activeTarget = this._activeTargets[i];\n\t\t\tconst tex = activeTarget.target[srcTextureName];\n\n\t\t\tif (tex) {\n\t\t\t\tthis[\"morphBlendTex\" + usedCount].setValue(tex);\n\t\t\t\tthis._shaderMorphWeights[usedCount] = activeTarget.weight;\n\t\t\t\tusedCount++;\n\n\t\t\t\tif (usedCount >= this.maxSubmitCount) {\n\t\t\t\t\tsubmitBatch(usedCount, blending);\n\t\t\t\t\tusedCount = 0;\n\t\t\t\t\tblending = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (usedCount > 0 || count === 0 && !this.zeroTextures) {\n\t\t\tsubmitBatch(usedCount, blending);\n\t\t}\n\t}\n\n\t_updateTextureMorph() {\n\t\tthis.device;\n\n\t\tif (this._activeTargets.length > 0 || !this.zeroTextures) {\n\t\t\tthis._updateTextureRenderTarget(this.rtPositions, 'texturePositions');\n\n\t\t\tthis._updateTextureRenderTarget(this.rtNormals, 'textureNormals');\n\n\t\t\tthis.zeroTextures = this._activeTargets.length === 0;\n\t\t}\n\t}\n\n\t_updateVertexMorph() {\n\t\tconst count = this.maxSubmitCount;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tthis._shaderMorphWeights[i] = 0;\n\t\t\tthis._activeVertexBuffers[i] = null;\n\t\t}\n\n\t\tlet posIndex = 0;\n\t\tlet nrmIndex = this.morph.morphPositions ? 4 : 0;\n\n\t\tfor (let i = 0; i < this._activeTargets.length; i++) {\n\t\t\tconst target = this._activeTargets[i].target;\n\n\t\t\tif (target._vertexBufferPositions) {\n\t\t\t\tthis._activeVertexBuffers[posIndex] = target._vertexBufferPositions;\n\t\t\t\tthis._shaderMorphWeights[posIndex] = this._activeTargets[i].weight;\n\t\t\t\tposIndex++;\n\t\t\t}\n\n\t\t\tif (target._vertexBufferNormals) {\n\t\t\t\tthis._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;\n\t\t\t\tthis._shaderMorphWeights[nrmIndex] = this._activeTargets[i].weight;\n\t\t\t\tnrmIndex++;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate() {\n\t\tthis._dirty = false;\n\t\tconst targets = this.morph._targets;\n\t\tlet activeCount = 0;\n\t\tconst epsilon = 0.00001;\n\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\tconst absWeight = Math.abs(this.getWeight(i));\n\n\t\t\tif (absWeight > epsilon) {\n\t\t\t\tif (this._activeTargets.length <= activeCount) {\n\t\t\t\t\tthis._activeTargets[activeCount] = {};\n\t\t\t\t}\n\n\t\t\t\tconst activeTarget = this._activeTargets[activeCount++];\n\t\t\t\tactiveTarget.absWeight = absWeight;\n\t\t\t\tactiveTarget.weight = this.getWeight(i);\n\t\t\t\tactiveTarget.target = targets[i];\n\t\t\t}\n\t\t}\n\n\t\tthis._activeTargets.length = activeCount;\n\t\tconst maxActiveTargets = this.morph.maxActiveTargets;\n\n\t\tif (this._activeTargets.length > maxActiveTargets) {\n\t\t\tthis._activeTargets.sort(function (l, r) {\n\t\t\t\treturn l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;\n\t\t\t});\n\n\t\t\tthis._activeTargets.length = maxActiveTargets;\n\t\t}\n\n\t\tif (this.morph.useTextureMorph) {\n\t\t\tthis._updateTextureMorph();\n\t\t} else {\n\t\t\tthis._updateVertexMorph();\n\t\t}\n\t}\n\n}\n\nclass Model {\n\tconstructor() {\n\t\tthis.graph = null;\n\t\tthis.meshInstances = [];\n\t\tthis.skinInstances = [];\n\t\tthis.morphInstances = [];\n\t\tthis.cameras = [];\n\t\tthis.lights = [];\n\t\tthis._shadersVersion = 0;\n\t\tthis._immutable = false;\n\t}\n\n\tgetGraph() {\n\t\treturn this.graph;\n\t}\n\n\tsetGraph(graph) {\n\t\tthis.graph = graph;\n\t}\n\n\tgetCameras() {\n\t\treturn this.cameras;\n\t}\n\n\tsetCameras(cameras) {\n\t\tthis.cameras = cameras;\n\t}\n\n\tgetLights() {\n\t\treturn this.lights;\n\t}\n\n\tsetLights(lights) {\n\t\tthis.lights = lights;\n\t}\n\n\tgetMaterials() {\n\t\tconst materials = [];\n\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\n\t\t\tif (materials.indexOf(meshInstance.material) === -1) {\n\t\t\t\tmaterials.push(meshInstance.material);\n\t\t\t}\n\t\t}\n\n\t\treturn materials;\n\t}\n\n\tclone() {\n\t\tconst srcNodes = [];\n\t\tconst cloneNodes = [];\n\n\t\tconst _duplicate = function _duplicate(node) {\n\t\t\tconst newNode = node.clone();\n\t\t\tsrcNodes.push(node);\n\t\t\tcloneNodes.push(newNode);\n\n\t\t\tfor (let idx = 0; idx < node._children.length; idx++) {\n\t\t\t\tnewNode.addChild(_duplicate(node._children[idx]));\n\t\t\t}\n\n\t\t\treturn newNode;\n\t\t};\n\n\t\tconst cloneGraph = _duplicate(this.graph);\n\n\t\tconst cloneMeshInstances = [];\n\t\tconst cloneSkinInstances = [];\n\t\tconst cloneMorphInstances = [];\n\n\t\tfor (let i = 0; i < this.skinInstances.length; i++) {\n\t\t\tconst skin = this.skinInstances[i].skin;\n\t\t\tconst cloneSkinInstance = new SkinInstance(skin);\n\t\t\tconst bones = [];\n\n\t\t\tfor (let j = 0; j < skin.boneNames.length; j++) {\n\t\t\t\tconst boneName = skin.boneNames[j];\n\t\t\t\tconst bone = cloneGraph.findByName(boneName);\n\t\t\t\tbones.push(bone);\n\t\t\t}\n\n\t\t\tcloneSkinInstance.bones = bones;\n\t\t\tcloneSkinInstances.push(cloneSkinInstance);\n\t\t}\n\n\t\tfor (let i = 0; i < this.morphInstances.length; i++) {\n\t\t\tconst morph = this.morphInstances[i].morph;\n\t\t\tconst cloneMorphInstance = new MorphInstance(morph);\n\t\t\tcloneMorphInstances.push(cloneMorphInstance);\n\t\t}\n\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\t\t\tconst nodeIndex = srcNodes.indexOf(meshInstance.node);\n\t\t\tconst cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);\n\n\t\t\tif (meshInstance.skinInstance) {\n\t\t\t\tconst skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);\n\t\t\t\tcloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];\n\t\t\t}\n\n\t\t\tif (meshInstance.morphInstance) {\n\t\t\t\tconst morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);\n\t\t\t\tcloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];\n\t\t\t}\n\n\t\t\tcloneMeshInstances.push(cloneMeshInstance);\n\t\t}\n\n\t\tconst clone = new Model();\n\t\tclone.graph = cloneGraph;\n\t\tclone.meshInstances = cloneMeshInstances;\n\t\tclone.skinInstances = cloneSkinInstances;\n\t\tclone.morphInstances = cloneMorphInstances;\n\t\tclone.getGraph().syncHierarchy();\n\t\treturn clone;\n\t}\n\n\tdestroy() {\n\t\tconst meshInstances = this.meshInstances;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].destroy();\n\t\t}\n\n\t\tthis.meshInstances.length = 0;\n\t}\n\n\tgenerateWireframe() {\n\t\tMeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);\n\t}\n\n}\n\nconst identityGraphNode = new GraphNode();\nidentityGraphNode.worldTransform = Mat4.IDENTITY;\nidentityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;\n\nclass ImmediateBatch {\n\tconstructor(device, material, layer) {\n\t\tthis.material = material;\n\t\tthis.layer = layer;\n\t\tthis.positions = [];\n\t\tthis.colors = [];\n\t\tthis.mesh = new Mesh(device);\n\t\tthis.meshInstance = null;\n\t}\n\n\taddLines(positions, color) {\n\t\tconst destPos = this.positions;\n\t\tconst count = positions.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pos = positions[i];\n\t\t\tdestPos.push(pos.x, pos.y, pos.z);\n\t\t}\n\n\t\tconst destCol = this.colors;\n\n\t\tif (color.length) {\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst col = color[i];\n\t\t\t\tdestCol.push(col.r, col.g, col.b, col.a);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tdestCol.push(color.r, color.g, color.b, color.a);\n\t\t\t}\n\t\t}\n\t}\n\n\taddLinesArrays(positions, color) {\n\t\tthis.positions.push(...positions);\n\t\tconst destCol = this.colors;\n\n\t\tif (color.length) {\n\t\t\tdestCol.push(...color);\n\t\t} else {\n\t\t\tconst count = positions.length / 3;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tdestCol.push(color.r, color.g, color.b, color.a);\n\t\t\t}\n\t\t}\n\t}\n\n\tonPreRender(visibleList, transparent) {\n\t\tif (this.positions.length > 0 && this.material.transparent === transparent) {\n\t\t\tthis.mesh.setPositions(this.positions);\n\t\t\tthis.mesh.setColors(this.colors);\n\t\t\tthis.mesh.update(PRIMITIVE_LINES, false);\n\n\t\t\tif (!this.meshInstance) {\n\t\t\t\tthis.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);\n\t\t\t}\n\n\t\t\tthis.positions.length = 0;\n\t\t\tthis.colors.length = 0;\n\t\t\tvisibleList.list.push(this.meshInstance);\n\t\t\tvisibleList.length++;\n\t\t}\n\t}\n\n}\n\nclass ImmediateBatches {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.map = new Map();\n\t}\n\n\tgetBatch(material, layer) {\n\t\tlet batch = this.map.get(material);\n\n\t\tif (!batch) {\n\t\t\tbatch = new ImmediateBatch(this.device, material, layer);\n\t\t\tthis.map.set(material, batch);\n\t\t}\n\n\t\treturn batch;\n\t}\n\n\tonPreRender(visibleList, transparent) {\n\t\tthis.map.forEach(batch => {\n\t\t\tbatch.onPreRender(visibleList, transparent);\n\t\t});\n\t}\n\n}\n\nconst tempPoints = [];\n\nclass Immediate {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.quadMesh = null;\n\t\tthis.textureShader = null;\n\t\tthis.depthTextureShader = null;\n\t\tthis.cubeLocalPos = null;\n\t\tthis.cubeWorldPos = null;\n\t\tthis.batchesMap = new Map();\n\t\tthis.allBatches = new Set();\n\t\tthis.updatedLayers = new Set();\n\t\tthis._materialDepth = null;\n\t\tthis._materialNoDepth = null;\n\t\tthis.layerMeshInstances = new Map();\n\t}\n\n\tcreateMaterial(depthTest) {\n\t\tconst material = new BasicMaterial();\n\t\tmaterial.vertexColors = true;\n\t\tmaterial.blend = true;\n\t\tmaterial.blendType = BLEND_NORMAL;\n\t\tmaterial.depthTest = depthTest;\n\t\tmaterial.update();\n\t\treturn material;\n\t}\n\n\tget materialDepth() {\n\t\tif (!this._materialDepth) {\n\t\t\tthis._materialDepth = this.createMaterial(true);\n\t\t}\n\n\t\treturn this._materialDepth;\n\t}\n\n\tget materialNoDepth() {\n\t\tif (!this._materialNoDepth) {\n\t\t\tthis._materialNoDepth = this.createMaterial(false);\n\t\t}\n\n\t\treturn this._materialNoDepth;\n\t}\n\n\tgetBatch(layer, depthTest) {\n\t\tlet batches = this.batchesMap.get(layer);\n\n\t\tif (!batches) {\n\t\t\tbatches = new ImmediateBatches(this.device);\n\t\t\tthis.batchesMap.set(layer, batches);\n\t\t}\n\n\t\tthis.allBatches.add(batches);\n\t\tconst material = depthTest ? this.materialDepth : this.materialNoDepth;\n\t\treturn batches.getBatch(material, layer);\n\t}\n\n\tstatic getTextureVS() {\n\t\treturn `\n\t\t\t\t\t\tattribute vec2 aPosition;\n\t\t\t\t\t\tuniform mat4 matrix_model;\n\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\t\t\tgl_Position = matrix_model * vec4(aPosition, 0, 1);\n\t\t\t\t\t\t\t\tuv0 = aPosition.xy + 0.5;\n\t\t\t\t\t\t}\n\t\t\t\t`;\n\t}\n\n\tgetTextureShader() {\n\t\tif (!this.textureShader) {\n\t\t\tconst shaderDefinition = {\n\t\t\t\tattributes: {\n\t\t\t\t\taPosition: SEMANTIC_POSITION\n\t\t\t\t},\n\t\t\t\tvshader: Immediate.getTextureVS(),\n\t\t\t\tfshader: `\n\t\t\t\t\t\t\t\t\t\tprecision lowp float;\n\t\t\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\t\t\tuniform sampler2D colorMap;\n\t\t\t\t\t\t\t\t\t\tvoid main (void) {\n\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t`\n\t\t\t};\n\t\t\tthis.textureShader = new Shader(this.device, shaderDefinition);\n\t\t}\n\n\t\treturn this.textureShader;\n\t}\n\n\tgetDepthTextureShader() {\n\t\tif (!this.depthTextureShader) {\n\t\t\tconst gl2 = this.device.webgl2 ? \"#define GL2\" : \"\";\n\t\t\tconst shaderDefinition = {\n\t\t\t\tattributes: {\n\t\t\t\t\taPosition: SEMANTIC_POSITION\n\t\t\t\t},\n\t\t\t\tvshader: Immediate.getTextureVS(),\n\t\t\t\tfshader: `\n\t\t\t\t\t\t\t\t\t\tprecision ${this.device.precision} float;\n\t\t\t\t\t\t\t\t\t\t${gl2}\n\t\t\t\t\t\t\t\t\t\t${shaderChunks.screenDepthPS}\n\t\t\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\t\t\t\tfloat depth = getLinearScreenDepth(uv0) * camera_params.x;\n\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t`\n\t\t\t};\n\t\t\tthis.depthTextureShader = new Shader(this.device, shaderDefinition);\n\t\t}\n\n\t\treturn this.depthTextureShader;\n\t}\n\n\tgetQuadMesh() {\n\t\tif (!this.quadMesh) {\n\t\t\tthis.quadMesh = new Mesh(this.device);\n\t\t\tthis.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);\n\t\t\tthis.quadMesh.update(PRIMITIVE_TRISTRIP);\n\t\t}\n\n\t\treturn this.quadMesh;\n\t}\n\n\tdrawMesh(material, matrix, mesh, meshInstance, layer) {\n\t\tif (!meshInstance) {\n\t\t\tconst graphNode = this.getGraphNode(matrix);\n\t\t\tmeshInstance = new MeshInstance(mesh, material, graphNode);\n\t\t}\n\n\t\tlet layerMeshInstances = this.layerMeshInstances.get(layer);\n\n\t\tif (!layerMeshInstances) {\n\t\t\tlayerMeshInstances = [];\n\t\t\tthis.layerMeshInstances.set(layer, layerMeshInstances);\n\t\t}\n\n\t\tlayerMeshInstances.push(meshInstance);\n\t}\n\n\tdrawWireAlignedBox(min, max, color, depthTest, layer) {\n\t\ttempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);\n\t\tconst batch = this.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(tempPoints, color);\n\t\ttempPoints.length = 0;\n\t}\n\n\tdrawWireSphere(center, radius, color, numSegments, depthTest, layer) {\n\t\tconst step = 2 * Math.PI / numSegments;\n\t\tlet angle = 0;\n\n\t\tfor (let i = 0; i < numSegments; i++) {\n\t\t\tconst sin0 = Math.sin(angle);\n\t\t\tconst cos0 = Math.cos(angle);\n\t\t\tangle += step;\n\t\t\tconst sin1 = Math.sin(angle);\n\t\t\tconst cos1 = Math.cos(angle);\n\t\t\ttempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);\n\t\t\ttempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);\n\t\t\ttempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);\n\t\t\ttempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);\n\t\t\ttempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);\n\t\t\ttempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);\n\t\t}\n\n\t\tconst batch = this.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(tempPoints, color);\n\t\ttempPoints.length = 0;\n\t}\n\n\tgetGraphNode(matrix) {\n\t\tconst graphNode = new GraphNode();\n\t\tgraphNode.worldTransform = matrix;\n\t\tgraphNode._dirtyWorld = graphNode._dirtyNormal = false;\n\t\treturn graphNode;\n\t}\n\n\tonPreRenderLayer(layer, visibleList, transparent) {\n\t\tthis.batchesMap.forEach((batches, batchLayer) => {\n\t\t\tif (batchLayer === layer) {\n\t\t\t\tbatches.onPreRender(visibleList, transparent);\n\t\t\t}\n\t\t});\n\n\t\tif (!this.updatedLayers.has(layer)) {\n\t\t\tthis.updatedLayers.add(layer);\n\t\t\tconst meshInstances = this.layerMeshInstances.get(layer);\n\n\t\t\tif (meshInstances) {\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tvisibleList.list[visibleList.length + i] = meshInstances[i];\n\t\t\t\t}\n\n\t\t\t\tvisibleList.length += meshInstances.length;\n\t\t\t\tmeshInstances.length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tonPostRender() {\n\t\tthis.allBatches.clear();\n\t\tthis.updatedLayers.clear();\n\t}\n\n}\n\nclass Scene extends EventHandler {\n\tconstructor(graphicsDevice) {\n\t\tsuper();\n\t\tthis.ambientBake = false;\n\t\tthis.ambientBakeOcclusionBrightness = 0;\n\t\tthis.ambientBakeOcclusionContrast = 0;\n\t\tthis.ambientLight = new Color(0, 0, 0);\n\t\tthis.exposure = 1;\n\t\tthis.fogColor = new Color(0, 0, 0);\n\t\tthis.fogDensity = 0;\n\t\tthis.fogEnd = 1000;\n\t\tthis.fogStart = 1;\n\t\tthis.lightmapSizeMultiplier = 1;\n\t\tthis.lightmapMaxResolution = 2048;\n\t\tthis.lightmapMode = BAKE_COLORDIR;\n\t\tthis.lightmapFilterEnabled = false;\n\t\tthis.root = null;\n\t\tthis.device = graphicsDevice || getApplication().graphicsDevice;\n\t\tthis._gravity = new Vec3(0, -9.8, 0);\n\t\tthis._layers = null;\n\t\tthis._fog = FOG_NONE;\n\t\tthis._gammaCorrection = GAMMA_SRGB;\n\t\tthis._toneMapping = 0;\n\t\tthis._skyboxCubeMap = null;\n\t\tthis._prefilteredCubemaps = [null, null, null, null, null, null];\n\t\tthis._envAtlas = null;\n\t\tthis._internalEnvAtlas = null;\n\t\tthis.skyboxModel = null;\n\t\tthis._skyboxIntensity = 1;\n\t\tthis._skyboxMip = 0;\n\t\tthis._skyboxRotation = new Quat();\n\t\tthis._skyboxRotationMat3 = null;\n\t\tthis._skyboxRotationMat4 = null;\n\t\tthis._ambientBakeNumSamples = 1;\n\t\tthis._ambientBakeSpherePart = 0.4;\n\t\tthis._lightmapFilterRange = 10;\n\t\tthis._lightmapFilterSmoothness = 0.2;\n\t\tthis._clusteredLightingEnabled = false;\n\t\tthis._lightingParams = new LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, () => {\n\t\t\tthis._layers._dirtyLights = true;\n\t\t});\n\t\tthis._stats = {\n\t\t\tmeshInstances: 0,\n\t\t\tlights: 0,\n\t\t\tdynamicLights: 0,\n\t\t\tbakedLights: 0,\n\t\t\tlastStaticPrepareFullTime: 0,\n\t\t\tlastStaticPrepareSearchTime: 0,\n\t\t\tlastStaticPrepareWriteTime: 0,\n\t\t\tlastStaticPrepareTriAabbTime: 0,\n\t\t\tlastStaticPrepareCombineTime: 0,\n\t\t\tupdateShadersTime: 0\n\t\t};\n\t\tthis.updateShaders = true;\n\t\tthis._shaderVersion = 0;\n\t\tthis._statsUpdated = false;\n\t\tthis._models = [];\n\t\tthis.immediate = new Immediate(this.device);\n\t}\n\n\tget defaultDrawLayer() {\n\t\treturn this.layers.getLayerById(LAYERID_IMMEDIATE);\n\t}\n\n\tset ambientBakeNumSamples(value) {\n\t\tthis._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);\n\t}\n\n\tget ambientBakeNumSamples() {\n\t\treturn this._ambientBakeNumSamples;\n\t}\n\n\tset ambientBakeSpherePart(value) {\n\t\tthis._ambientBakeSpherePart = math.clamp(value, 0.001, 1);\n\t}\n\n\tget ambientBakeSpherePart() {\n\t\treturn this._ambientBakeSpherePart;\n\t}\n\n\tset clusteredLightingEnabled(value) {\n\t\tif (this._clusteredLightingEnabled && !value) {\n\t\t\tconsole.error(\"Turning off enabled clustered lighting is not currently supported\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clusteredLightingEnabled = value;\n\t}\n\n\tget clusteredLightingEnabled() {\n\t\treturn this._clusteredLightingEnabled;\n\t}\n\n\tset drawCalls(value) {}\n\n\tget drawCalls() {\n\t\tlet drawCalls = this.layers._meshInstances;\n\n\t\tif (!drawCalls.length) {\n\t\t\tthis.layers._update(this.device, this.clusteredLightingEnabled);\n\n\t\t\tdrawCalls = this.layers._meshInstances;\n\t\t}\n\n\t\treturn drawCalls;\n\t}\n\n\tset envAtlas(value) {\n\t\tif (value !== this._envAtlas) {\n\t\t\tthis._envAtlas = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\n\tget envAtlas() {\n\t\treturn this._envAtlas;\n\t}\n\n\tset fog(type) {\n\t\tif (type !== this._fog) {\n\t\t\tthis._fog = type;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\n\tget fog() {\n\t\treturn this._fog;\n\t}\n\n\tset gammaCorrection(value) {\n\t\tif (value !== this._gammaCorrection) {\n\t\t\tthis._gammaCorrection = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\n\tget gammaCorrection() {\n\t\treturn this._gammaCorrection;\n\t}\n\n\tset layers(layers) {\n\t\tconst prev = this._layers;\n\t\tthis._layers = layers;\n\t\tthis.fire(\"set:layers\", prev, layers);\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tget lighting() {\n\t\treturn this._lightingParams;\n\t}\n\n\tset lightmapFilterRange(value) {\n\t\tthis._lightmapFilterRange = Math.max(value, 0.001);\n\t}\n\n\tget lightmapFilterRange() {\n\t\treturn this._lightmapFilterRange;\n\t}\n\n\tset lightmapFilterSmoothness(value) {\n\t\tthis._lightmapFilterSmoothness = Math.max(value, 0.001);\n\t}\n\n\tget lightmapFilterSmoothness() {\n\t\treturn this._lightmapFilterSmoothness;\n\t}\n\n\tset prefilteredCubemaps(value) {\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\t\tvalue = value || [];\n\t\tlet changed = false;\n\t\tlet complete = true;\n\n\t\tfor (let i = 0; i < 6; ++i) {\n\t\t\tconst v = value[i] || null;\n\n\t\t\tif (cubemaps[i] !== v) {\n\t\t\t\tcubemaps[i] = v;\n\t\t\t\tchanged = true;\n\t\t\t}\n\n\t\t\tcomplete = complete && !!cubemaps[i];\n\t\t}\n\n\t\tif (changed) {\n\t\t\tthis._resetSkyboxModel();\n\n\t\t\tif (complete) {\n\t\t\t\tthis._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {\n\t\t\t\t\ttarget: this._internalEnvAtlas\n\t\t\t\t});\n\n\t\t\t\tif (!this._envAtlas) {\n\t\t\t\t\tthis.envAtlas = this._internalEnvAtlas;\n\t\t\t\t}\n\t\t\t} else if (this._internalEnvAtlas) {\n\t\t\t\tif (this._envAtlas === this._internalEnvAtlas) {\n\t\t\t\t\tthis.envAtlas = null;\n\t\t\t\t}\n\n\t\t\t\tthis._internalEnvAtlas.destroy();\n\n\t\t\t\tthis._internalEnvAtlas = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget prefilteredCubemaps() {\n\t\treturn this._prefilteredCubemaps;\n\t}\n\n\tset skybox(value) {\n\t\tif (value !== this._skyboxCubeMap) {\n\t\t\tthis._skyboxCubeMap = value;\n\n\t\t\tthis._resetSkyboxModel();\n\t\t}\n\t}\n\n\tget skybox() {\n\t\treturn this._skyboxCubeMap;\n\t}\n\n\tset skyboxIntensity(value) {\n\t\tif (value !== this._skyboxIntensity) {\n\t\t\tthis._skyboxIntensity = value;\n\n\t\t\tthis._resetSkyboxModel();\n\t\t}\n\t}\n\n\tget skyboxIntensity() {\n\t\treturn this._skyboxIntensity;\n\t}\n\n\tset skyboxMip(value) {\n\t\tif (value !== this._skyboxMip) {\n\t\t\tthis._skyboxMip = value;\n\n\t\t\tthis._resetSkyboxModel();\n\t\t}\n\t}\n\n\tget skyboxMip() {\n\t\treturn this._skyboxMip;\n\t}\n\n\tset skyboxRotation(value) {\n\t\tif (!this._skyboxRotation.equals(value)) {\n\t\t\tthis._skyboxRotation.copy(value);\n\n\t\t\tthis._resetSkyboxModel();\n\t\t}\n\t}\n\n\tget skyboxRotation() {\n\t\treturn this._skyboxRotation;\n\t}\n\n\tset toneMapping(value) {\n\t\tif (value !== this._toneMapping) {\n\t\t\tthis._toneMapping = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\n\tget toneMapping() {\n\t\treturn this._toneMapping;\n\t}\n\n\tdestroy() {\n\t\tthis._resetSkyboxModel();\n\n\t\tthis.root = null;\n\t\tthis.off();\n\t}\n\n\tdrawLine(start, end, color = Color.WHITE, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLines([start, end], [color, color]);\n\t}\n\n\tdrawLines(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLines(positions, colors);\n\t}\n\n\tdrawLineArrays(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(positions, colors);\n\t}\n\n\tapplySettings(settings) {\n\t\tthis._gravity.set(settings.physics.gravity[0], settings.physics.gravity[1], settings.physics.gravity[2]);\n\n\t\tthis.ambientLight.set(settings.render.global_ambient[0], settings.render.global_ambient[1], settings.render.global_ambient[2]);\n\t\tthis._fog = settings.render.fog;\n\t\tthis.fogColor.set(settings.render.fog_color[0], settings.render.fog_color[1], settings.render.fog_color[2]);\n\t\tthis.fogStart = settings.render.fog_start;\n\t\tthis.fogEnd = settings.render.fog_end;\n\t\tthis.fogDensity = settings.render.fog_density;\n\t\tthis._gammaCorrection = settings.render.gamma_correction;\n\t\tthis._toneMapping = settings.render.tonemapping;\n\t\tthis.lightmapSizeMultiplier = settings.render.lightmapSizeMultiplier;\n\t\tthis.lightmapMaxResolution = settings.render.lightmapMaxResolution;\n\t\tthis.lightmapMode = settings.render.lightmapMode;\n\t\tthis.exposure = settings.render.exposure;\n\t\tthis._skyboxIntensity = settings.render.skyboxIntensity === undefined ? 1 : settings.render.skyboxIntensity;\n\t\tthis._skyboxMip = settings.render.skyboxMip === undefined ? 0 : settings.render.skyboxMip;\n\n\t\tif (settings.render.skyboxRotation) {\n\t\t\tthis._skyboxRotation.setFromEulerAngles(settings.render.skyboxRotation[0], settings.render.skyboxRotation[1], settings.render.skyboxRotation[2]);\n\t\t}\n\n\t\tthis._resetSkyboxModel();\n\t}\n\n\t_getSkyboxTex() {\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\n\t\tif (this._skyboxMip) {\n\t\t\tconst skyboxMapping = [0, 1, 3, 4, 5, 6];\n\t\t\treturn cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;\n\t\t}\n\n\t\treturn this._skyboxCubeMap || cubemaps[0] || this._envAtlas;\n\t}\n\n\t_updateSkybox(device) {\n\t\tif (this.skyboxModel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst skyboxTex = this._getSkyboxTex();\n\n\t\tif (!skyboxTex) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst material = new Material();\n\t\tconst scene = this;\n\n\t\tmaterial.updateShader = function (dev, sc, defs, staticLightList, pass) {\n\t\t\tconst library = device.getProgramLibrary();\n\n\t\t\tif (skyboxTex.cubemap) {\n\t\t\t\tthis.shader = library.getProgram('skybox', {\n\t\t\t\t\ttype: 'cubemap',\n\t\t\t\t\trgbm: skyboxTex.type === TEXTURETYPE_RGBM,\n\t\t\t\t\thdr: skyboxTex.type === TEXTURETYPE_RGBM || skyboxTex.format === PIXELFORMAT_RGBA32F,\n\t\t\t\t\tuseIntensity: scene.skyboxIntensity !== 1,\n\t\t\t\t\tmip: skyboxTex.fixCubemapSeams ? scene.skyboxMip : 0,\n\t\t\t\t\tfixSeams: skyboxTex.fixCubemapSeams,\n\t\t\t\t\tgamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,\n\t\t\t\t\ttoneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.shader = library.getProgram('skybox', {\n\t\t\t\t\ttype: 'envAtlas',\n\t\t\t\t\tencoding: skyboxTex.encoding,\n\t\t\t\t\tuseIntensity: scene.skyboxIntensity !== 1,\n\t\t\t\t\tgamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,\n\t\t\t\t\ttoneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tmaterial.updateShader();\n\n\t\tif (skyboxTex.cubemap) {\n\t\t\tmaterial.setParameter(\"texture_cubeMap\", skyboxTex);\n\t\t} else {\n\t\t\tmaterial.setParameter(\"texture_envAtlas\", skyboxTex);\n\t\t\tmaterial.setParameter(\"mipLevel\", this._skyboxMip);\n\t\t}\n\n\t\tif (!this.skyboxRotation.equals(Quat.IDENTITY)) {\n\t\t\tif (!this._skyboxRotationMat4) this._skyboxRotationMat4 = new Mat4();\n\t\t\tif (!this._skyboxRotationMat3) this._skyboxRotationMat3 = new Mat3();\n\n\t\t\tthis._skyboxRotationMat4.setTRS(Vec3.ZERO, this._skyboxRotation, Vec3.ONE);\n\n\t\t\tthis._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3);\n\n\t\t\tmaterial.setParameter(\"cubeMapRotationMatrix\", this._skyboxRotationMat3.data);\n\t\t} else {\n\t\t\tmaterial.setParameter(\"cubeMapRotationMatrix\", Mat3.IDENTITY.data);\n\t\t}\n\n\t\tmaterial.cull = CULLFACE_FRONT;\n\t\tmaterial.depthWrite = false;\n\t\tconst skyLayer = this.layers.getLayerById(LAYERID_SKYBOX);\n\n\t\tif (skyLayer) {\n\t\t\tconst node = new GraphNode(\"Skybox\");\n\t\t\tconst mesh = createBox(device);\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, node);\n\t\t\tmeshInstance.cull = false;\n\t\t\tmeshInstance._noDepthDrawGl1 = true;\n\t\t\tmeshInstance.pick = false;\n\t\t\tconst model = new Model();\n\t\t\tmodel.graph = node;\n\t\t\tmodel.meshInstances = [meshInstance];\n\t\t\tthis.skyboxModel = model;\n\t\t\tskyLayer.addMeshInstances(model.meshInstances);\n\t\t\tthis.skyLayer = skyLayer;\n\t\t\tthis.fire(\"set:skybox\", skyboxTex);\n\t\t}\n\t}\n\n\t_resetSkyboxModel() {\n\t\tif (this.skyboxModel) {\n\t\t\tthis.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);\n\t\t\tthis.skyboxModel.destroy();\n\t\t}\n\n\t\tthis.skyboxModel = null;\n\t\tthis.updateShaders = true;\n\t}\n\n\tsetSkybox(cubemaps) {\n\t\tif (!cubemaps) {\n\t\t\tthis.skybox = null;\n\t\t\tthis.prefilteredCubemaps = [null, null, null, null, null, null];\n\t\t} else {\n\t\t\tthis.skybox = cubemaps[0] || null;\n\t\t\tthis.prefilteredCubemaps = cubemaps.slice(1);\n\t\t}\n\t}\n\n\taddModel(model) {\n\t\tif (this.containsModel(model)) return;\n\t\tconst layer = this.layers.getLayerById(LAYERID_WORLD);\n\t\tif (!layer) return;\n\t\tlayer.addMeshInstances(model.meshInstances);\n\n\t\tthis._models.push(model);\n\t}\n\n\taddShadowCaster(model) {\n\t\tconst layer = this.layers.getLayerById(LAYERID_WORLD);\n\t\tif (!layer) return;\n\t\tlayer.addShadowCasters(model.meshInstances);\n\t}\n\n\tremoveModel(model) {\n\t\tconst index = this._models.indexOf(model);\n\n\t\tif (index !== -1) {\n\t\t\tconst layer = this.layers.getLayerById(LAYERID_WORLD);\n\t\t\tif (!layer) return;\n\t\t\tlayer.removeMeshInstances(model.meshInstances);\n\n\t\t\tthis._models.splice(index, 1);\n\t\t}\n\t}\n\n\tremoveShadowCasters(model) {\n\t\tconst layer = this.layers.getLayerById(LAYERID_WORLD);\n\t\tif (!layer) return;\n\t\tlayer.removeShadowCasters(model.meshInstances);\n\t}\n\n\tcontainsModel(model) {\n\t\treturn this._models.indexOf(model) >= 0;\n\t}\n\n\tgetModels(model) {\n\t\treturn this._models;\n\t}\n\n}\n\nfunction hasAudioContext() {\n\treturn !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');\n}\n\nclass Channel {\n\tconstructor(manager, sound, options = {}) {\n\t\tthis.volume = options.volume === undefined ? 1 : options.volume;\n\t\tthis.loop = options.loop === undefined ? false : options.loop;\n\t\tthis.pitch = options.pitch === undefined ? 1 : options.pitch;\n\t\tthis.sound = sound;\n\t\tthis.paused = false;\n\t\tthis.suspended = false;\n\t\tthis.manager = manager;\n\t\tthis.source = null;\n\n\t\tif (hasAudioContext()) {\n\t\t\tthis.startTime = 0;\n\t\t\tthis.startOffset = 0;\n\t\t\tconst context = manager.context;\n\t\t\tthis.gain = context.createGain();\n\t\t} else if (sound.audio) {\n\t\t\tthis.source = sound.audio.cloneNode(false);\n\t\t\tthis.source.pause();\n\t\t}\n\t}\n\n\tgetVolume() {\n\t\treturn this.volume;\n\t}\n\n\tgetLoop() {\n\t\treturn this.loop;\n\t}\n\n\tsetLoop(loop) {\n\t\tthis.loop = loop;\n\n\t\tif (this.source) {\n\t\t\tthis.source.loop = loop;\n\t\t}\n\t}\n\n\tgetPitch() {\n\t\treturn this.pitch;\n\t}\n\n\tonManagerVolumeChange() {\n\t\tthis.setVolume(this.getVolume());\n\t}\n\n\tonManagerSuspend() {\n\t\tif (this.isPlaying() && !this.suspended) {\n\t\t\tthis.suspended = true;\n\t\t\tthis.pause();\n\t\t}\n\t}\n\n\tonManagerResume() {\n\t\tif (this.suspended) {\n\t\t\tthis.suspended = false;\n\t\t\tthis.unpause();\n\t\t}\n\t}\n\n\tplay() {\n\t\tif (this.source) {\n\t\t\tthrow new Error('Call stop() before calling play()');\n\t\t}\n\n\t\tthis._createSource();\n\n\t\tif (!this.source) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.startTime = this.manager.context.currentTime;\n\t\tthis.source.start(0, this.startOffset % this.source.buffer.duration);\n\t\tthis.setVolume(this.volume);\n\t\tthis.setLoop(this.loop);\n\t\tthis.setPitch(this.pitch);\n\t\tthis.manager.on('volumechange', this.onManagerVolumeChange, this);\n\t\tthis.manager.on('suspend', this.onManagerSuspend, this);\n\t\tthis.manager.on('resume', this.onManagerResume, this);\n\t\tif (this.manager.suspended) this.onManagerSuspend();\n\t}\n\n\tpause() {\n\t\tif (this.source) {\n\t\t\tthis.paused = true;\n\t\t\tthis.startOffset += this.manager.context.currentTime - this.startTime;\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t}\n\t}\n\n\tunpause() {\n\t\tif (this.source || !this.paused) {\n\t\t\tconsole.warn('Call pause() before unpausing.');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._createSource();\n\n\t\tif (!this.source) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.startTime = this.manager.context.currentTime;\n\t\tthis.source.start(0, this.startOffset % this.source.buffer.duration);\n\t\tthis.setVolume(this.volume);\n\t\tthis.setLoop(this.loop);\n\t\tthis.setPitch(this.pitch);\n\t\tthis.paused = false;\n\t}\n\n\tstop() {\n\t\tif (this.source) {\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t}\n\n\t\tthis.manager.off('volumechange', this.onManagerVolumeChange, this);\n\t\tthis.manager.off('suspend', this.onManagerSuspend, this);\n\t\tthis.manager.off('resume', this.onManagerResume, this);\n\t}\n\n\tsetVolume(volume) {\n\t\tvolume = math.clamp(volume, 0, 1);\n\t\tthis.volume = volume;\n\n\t\tif (this.gain) {\n\t\t\tthis.gain.gain.value = volume * this.manager.volume;\n\t\t}\n\t}\n\n\tsetPitch(pitch) {\n\t\tthis.pitch = pitch;\n\n\t\tif (this.source) {\n\t\t\tthis.source.playbackRate.value = pitch;\n\t\t}\n\t}\n\n\tisPlaying() {\n\t\treturn !this.paused && this.source.playbackState === this.source.PLAYING_STATE;\n\t}\n\n\tgetDuration() {\n\t\treturn this.source ? this.source.buffer.duration : 0;\n\t}\n\n\t_createSource() {\n\t\tconst context = this.manager.context;\n\n\t\tif (this.sound.buffer) {\n\t\t\tthis.source = context.createBufferSource();\n\t\t\tthis.source.buffer = this.sound.buffer;\n\t\t\tthis.source.connect(this.gain);\n\t\t\tthis.gain.connect(context.destination);\n\n\t\t\tif (!this.loop) {\n\t\t\t\tthis.source.onended = this.pause.bind(this);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nif (!hasAudioContext()) {\n\tObject.assign(Channel.prototype, {\n\t\tplay: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.setVolume(this.volume);\n\t\t\t\tthis.setLoop(this.loop);\n\t\t\t\tthis.setPitch(this.pitch);\n\t\t\t\tthis.source.play();\n\t\t\t}\n\n\t\t\tthis.manager.on('volumechange', this.onManagerVolumeChange, this);\n\t\t\tthis.manager.on('suspend', this.onManagerSuspend, this);\n\t\t\tthis.manager.on('resume', this.onManagerResume, this);\n\t\t\tif (this.manager.suspended) this.onManagerSuspend();\n\t\t},\n\t\tpause: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = true;\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\t\t},\n\t\tunpause: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.source.play();\n\t\t\t}\n\t\t},\n\t\tstop: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\n\t\t\tthis.manager.off('volumechange', this.onManagerVolumeChange, this);\n\t\t\tthis.manager.off('suspend', this.onManagerSuspend, this);\n\t\t\tthis.manager.off('resume', this.onManagerResume, this);\n\t\t},\n\t\tsetVolume: function (volume) {\n\t\t\tvolume = math.clamp(volume, 0, 1);\n\t\t\tthis.volume = volume;\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.volume = volume * this.manager.volume;\n\t\t\t}\n\t\t},\n\t\tsetPitch: function (pitch) {\n\t\t\tthis.pitch = pitch;\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.playbackRate = pitch;\n\t\t\t}\n\t\t},\n\t\tgetDuration: function () {\n\t\t\treturn this.source && !isNaN(this.source.duration) ? this.source.duration : 0;\n\t\t},\n\t\tisPlaying: function () {\n\t\t\treturn !this.source.paused;\n\t\t}\n\t});\n}\n\nconst DISTANCE_LINEAR = 'linear';\nconst DISTANCE_INVERSE = 'inverse';\nconst DISTANCE_EXPONENTIAL = 'exponential';\n\nconst MAX_DISTANCE$1 = 10000;\n\nclass Channel3d extends Channel {\n\tconstructor(manager, sound, options) {\n\t\tsuper(manager, sound, options);\n\t\tthis.position = new Vec3();\n\t\tthis.velocity = new Vec3();\n\n\t\tif (hasAudioContext()) {\n\t\t\tthis.panner = manager.context.createPanner();\n\t\t} else {\n\t\t\tthis.maxDistance = MAX_DISTANCE$1;\n\t\t\tthis.minDistance = 1;\n\t\t\tthis.rollOffFactor = 1;\n\t\t\tthis.distanceModel = DISTANCE_INVERSE;\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\treturn this.position;\n\t}\n\n\tgetVelocity() {\n\t\treturn this.velocity;\n\t}\n\n\tsetPosition(position) {\n\t\tthis.position.copy(position);\n\t\tthis.panner.setPosition(position.x, position.y, position.z);\n\t}\n\n\tsetVelocity(velocity) {\n\t\tthis.velocity.copy(velocity);\n\t\tthis.panner.setVelocity(velocity.x, velocity.y, velocity.z);\n\t}\n\n\tgetMaxDistance() {\n\t\treturn this.panner.maxDistance;\n\t}\n\n\tsetMaxDistance(max) {\n\t\tthis.panner.maxDistance = max;\n\t}\n\n\tgetMinDistance() {\n\t\treturn this.panner.refDistance;\n\t}\n\n\tsetMinDistance(min) {\n\t\tthis.panner.refDistance = min;\n\t}\n\n\tgetRollOffFactor() {\n\t\treturn this.panner.rolloffFactor;\n\t}\n\n\tsetRollOffFactor(factor) {\n\t\tthis.panner.rolloffFactor = factor;\n\t}\n\n\tgetDistanceModel() {\n\t\treturn this.pannel.distanceModel;\n\t}\n\n\tsetDistanceModel(distanceModel) {\n\t\tthis.panner.distanceModel = distanceModel;\n\t}\n\n\t_createSource() {\n\t\tconst context = this.manager.context;\n\t\tthis.source = context.createBufferSource();\n\t\tthis.source.buffer = this.sound.buffer;\n\t\tthis.source.connect(this.panner);\n\t\tthis.panner.connect(this.gain);\n\t\tthis.gain.connect(context.destination);\n\n\t\tif (!this.loop) {\n\t\t\tthis.source.onended = this.pause.bind(this);\n\t\t}\n\t}\n\n}\n\nif (!hasAudioContext()) {\n\tlet offset = new Vec3();\n\n\tconst fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {\n\t\toffset = offset.sub2(posOne, posTwo);\n\t\tconst distance = offset.length();\n\n\t\tif (distance < refDistance) {\n\t\t\treturn 1;\n\t\t} else if (distance > maxDistance) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet result = 0;\n\n\t\tif (distanceModel === DISTANCE_LINEAR) {\n\t\t\tresult = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);\n\t\t} else if (distanceModel === DISTANCE_INVERSE) {\n\t\t\tresult = refDistance / (refDistance + rolloffFactor * (distance - refDistance));\n\t\t} else if (distanceModel === DISTANCE_EXPONENTIAL) {\n\t\t\tresult = Math.pow(distance / refDistance, -rolloffFactor);\n\t\t}\n\n\t\treturn math.clamp(result, 0, 1);\n\t};\n\n\tObject.assign(Channel3d.prototype, {\n\t\tsetPosition: function (position) {\n\t\t\tthis.position.copy(position);\n\n\t\t\tif (this.source) {\n\t\t\t\tconst listener = this.manager.listener;\n\t\t\t\tconst lpos = listener.getPosition();\n\t\t\t\tconst factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);\n\t\t\t\tconst v = this.getVolume();\n\t\t\t\tthis.source.volume = v * factor;\n\t\t\t}\n\t\t},\n\t\tsetVelocity: function (velocity) {\n\t\t\tthis.velocity.copy(velocity);\n\t\t},\n\t\tgetMaxDistance: function () {\n\t\t\treturn this.maxDistance;\n\t\t},\n\t\tsetMaxDistance: function (max) {\n\t\t\tthis.maxDistance = max;\n\t\t},\n\t\tgetMinDistance: function () {\n\t\t\treturn this.minDistance;\n\t\t},\n\t\tsetMinDistance: function (min) {\n\t\t\tthis.minDistance = min;\n\t\t},\n\t\tgetRollOffFactor: function () {\n\t\t\treturn this.rollOffFactor;\n\t\t},\n\t\tsetRollOffFactor: function (factor) {\n\t\t\tthis.rollOffFactor = factor;\n\t\t},\n\t\tgetDistanceModel: function () {\n\t\t\treturn this.distanceModel;\n\t\t},\n\t\tsetDistanceModel: function (distanceModel) {\n\t\t\tthis.distanceModel = distanceModel;\n\t\t}\n\t});\n}\n\nclass Listener {\n\tconstructor(manager) {\n\t\tthis._manager = manager;\n\t\tthis.position = new Vec3();\n\t\tthis.velocity = new Vec3();\n\t\tthis.orientation = new Mat4();\n\t}\n\n\tgetPosition() {\n\t\treturn this.position;\n\t}\n\n\tsetPosition(position) {\n\t\tthis.position.copy(position);\n\t\tconst listener = this.listener;\n\n\t\tif (listener) {\n\t\t\tlistener.setPosition(position.x, position.y, position.z);\n\t\t}\n\t}\n\n\tgetVelocity() {\n\t\treturn this.velocity;\n\t}\n\n\tsetVelocity(velocity) {\n\t\tthis.velocity.copy(velocity);\n\t\tconst listener = this.listener;\n\n\t\tif (listener) {\n\t\t\tlistener.setPosition(velocity.x, velocity.y, velocity.z);\n\t\t}\n\t}\n\n\tsetOrientation(orientation) {\n\t\tthis.orientation.copy(orientation);\n\t\tconst listener = this.listener;\n\n\t\tif (listener) {\n\t\t\tlistener.setOrientation(-orientation.data[8], -orientation.data[9], -orientation.data[10], orientation.data[4], orientation.data[5], orientation.data[6]);\n\t\t}\n\t}\n\n\tgetOrientation() {\n\t\treturn this.orientation;\n\t}\n\n\tget listener() {\n\t\tconst context = this._manager.context;\n\t\treturn context ? context.listener : null;\n\t}\n\n}\n\nclass SoundManager extends EventHandler {\n\tconstructor(options) {\n\t\tsuper();\n\t\tthis._context = null;\n\t\tthis._forceWebAudioApi = options.forceWebAudioApi;\n\t\tthis._resumeContext = null;\n\t\tthis._unlock = null;\n\n\t\tif (hasAudioContext() || this._forceWebAudioApi) {\n\t\t\tthis._resumeContext = () => {\n\t\t\t\twindow.removeEventListener('mousedown', this._resumeContext);\n\t\t\t\twindow.removeEventListener('touchend', this._resumeContext);\n\n\t\t\t\tif (this.context) {\n\t\t\t\t\tthis.context.resume();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.addEventListener('mousedown', this._resumeContext);\n\t\t\twindow.addEventListener('touchend', this._resumeContext);\n\n\t\t\tif (platform.ios) {\n\t\t\t\tthis._unlock = () => {\n\t\t\t\t\twindow.removeEventListener('touchend', this._unlock);\n\t\t\t\t\tconst context = this.context;\n\n\t\t\t\t\tif (context) {\n\t\t\t\t\t\tconst buffer = context.createBuffer(1, 1, 44100);\n\t\t\t\t\t\tconst source = context.createBufferSource();\n\t\t\t\t\t\tsource.buffer = buffer;\n\t\t\t\t\t\tsource.connect(context.destination);\n\t\t\t\t\t\tsource.start(0);\n\t\t\t\t\t\tsource.disconnect();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\twindow.addEventListener('touchend', this._unlock);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn('No support for 3D audio found');\n\t\t}\n\n\t\tthis.listener = new Listener(this);\n\t\tthis._volume = 1;\n\t\tthis.suspended = false;\n\t}\n\n\tset volume(volume) {\n\t\tvolume = math.clamp(volume, 0, 1);\n\t\tthis._volume = volume;\n\t\tthis.fire('volumechange', volume);\n\t}\n\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\n\tget context() {\n\t\tif (!this._context) {\n\t\t\tif (hasAudioContext() || this._forceWebAudioApi) {\n\t\t\t\tif (typeof AudioContext !== 'undefined') {\n\t\t\t\t\tthis._context = new AudioContext();\n\t\t\t\t} else if (typeof webkitAudioContext !== 'undefined') {\n\t\t\t\t\tthis._context = new webkitAudioContext();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._context;\n\t}\n\n\tsuspend() {\n\t\tthis.suspended = true;\n\t\tthis.fire('suspend');\n\t}\n\n\tresume() {\n\t\tconst resumeFunction = () => {\n\t\t\tthis.suspended = false;\n\t\t\tthis.fire('resume');\n\t\t};\n\n\t\tif ((hasAudioContext() || this._forceWebAudioApi) && (this.context.state === 'interrupted' || this.context.state === 'suspended')) {\n\t\t\tthis.context.resume().then(resumeFunction);\n\t\t} else resumeFunction();\n\t}\n\n\tdestroy() {\n\t\tif (this._resumeContext) {\n\t\t\twindow.removeEventListener('mousedown', this._resumeContext);\n\t\t\twindow.removeEventListener('touchend', this._resumeContext);\n\t\t}\n\n\t\tif (this._unlock) {\n\t\t\twindow.removeEventListener('touchend', this._unlock);\n\t\t}\n\n\t\tthis.fire('destroy');\n\n\t\tif (this._context && this._context.close) {\n\t\t\tthis._context.close();\n\n\t\t\tthis._context = null;\n\t\t}\n\t}\n\n\tplaySound(sound, options = {}) {\n\t\tlet channel = null;\n\n\t\tif (Channel) {\n\t\t\tchannel = new Channel(this, sound, options);\n\t\t\tchannel.play();\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tplaySound3d(sound, position, options = {}) {\n\t\tlet channel = null;\n\n\t\tif (Channel3d) {\n\t\t\tchannel = new Channel3d(this, sound, options);\n\t\t\tchannel.setPosition(position);\n\n\t\t\tif (options.volume) {\n\t\t\t\tchannel.setVolume(options.volume);\n\t\t\t}\n\n\t\t\tif (options.loop) {\n\t\t\t\tchannel.setLoop(options.loop);\n\t\t\t}\n\n\t\t\tif (options.maxDistance) {\n\t\t\t\tchannel.setMaxDistance(options.maxDistance);\n\t\t\t}\n\n\t\t\tif (options.minDistance) {\n\t\t\t\tchannel.setMinDistance(options.minDistance);\n\t\t\t}\n\n\t\t\tif (options.rollOffFactor) {\n\t\t\t\tchannel.setRollOffFactor(options.rollOffFactor);\n\t\t\t}\n\n\t\t\tif (options.distanceModel) {\n\t\t\t\tchannel.setDistanceModel(options.distanceModel);\n\t\t\t}\n\n\t\t\tchannel.play();\n\t\t}\n\n\t\treturn channel;\n\t}\n\n}\n\nclass Key {\n\tconstructor(time, position, rotation, scale) {\n\t\tthis.time = time;\n\t\tthis.position = position;\n\t\tthis.rotation = rotation;\n\t\tthis.scale = scale;\n\t}\n\n}\n\nclass Node {\n\tconstructor() {\n\t\tthis._name = \"\";\n\t\tthis._keys = [];\n\t}\n\n}\n\nclass Animation {\n\tconstructor() {\n\t\tthis.name = '';\n\t\tthis.duration = 0;\n\t\tthis._nodes = [];\n\t\tthis._nodeDict = {};\n\t}\n\n\tgetNode(name) {\n\t\treturn this._nodeDict[name];\n\t}\n\n\taddNode(node) {\n\t\tthis._nodes.push(node);\n\n\t\tthis._nodeDict[node._name] = node;\n\t}\n\n\tget nodes() {\n\t\treturn this._nodes;\n\t}\n\n}\n\nclass MorphTarget {\n\tconstructor(options) {\n\t\tif (arguments.length === 2) {\n\t\t\toptions = arguments[1];\n\t\t}\n\n\t\tthis.options = options;\n\t\tthis._name = options.name;\n\t\tthis._defaultWeight = options.defaultWeight || 0;\n\t\tthis.aabb = options.aabb;\n\n\t\tif (!this.aabb) {\n\t\t\tthis.aabb = new BoundingBox();\n\t\t\tif (options.deltaPositions) this.aabb.compute(options.deltaPositions);\n\t\t}\n\n\t\tthis.deltaPositions = options.deltaPositions;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tget defaultWeight() {\n\t\treturn this._defaultWeight;\n\t}\n\n\tget morphPositions() {\n\t\treturn !!this._vertexBufferPositions || !!this.texturePositions;\n\t}\n\n\tget morphNormals() {\n\t\treturn !!this._vertexBufferNormals || !!this.textureNormals;\n\t}\n\n\t_postInit() {\n\t\tthis.options = null;\n\t}\n\n\t_initVertexBuffers(graphicsDevice) {\n\t\tconst options = this.options;\n\t\tthis._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);\n\t\tthis._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);\n\n\t\tif (this._vertexBufferPositions) {\n\t\t\tthis.deltaPositions = this._vertexBufferPositions.lock();\n\t\t}\n\t}\n\n\t_createVertexBuffer(device, data, dataType = TYPE_FLOAT32) {\n\t\tif (data) {\n\t\t\tconst formatDesc = [{\n\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\tcomponents: 3,\n\t\t\t\ttype: dataType\n\t\t\t}];\n\t\t\treturn new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_setTexture(name, texture) {\n\t\tthis[name] = texture;\n\t}\n\n\tdestroy() {\n\t\tif (this._vertexBufferPositions) {\n\t\t\tthis._vertexBufferPositions.destroy();\n\n\t\t\tthis._vertexBufferPositions = null;\n\t\t}\n\n\t\tif (this._vertexBufferNormals) {\n\t\t\tthis._vertexBufferNormals.destroy();\n\n\t\t\tthis._vertexBufferNormals = null;\n\t\t}\n\n\t\tif (this.texturePositions) {\n\t\t\tthis.texturePositions.destroy();\n\t\t\tthis.texturePositions = null;\n\t\t}\n\n\t\tif (this.textureNormals) {\n\t\t\tthis.textureNormals.destroy();\n\t\t\tthis.textureNormals = null;\n\t\t}\n\t}\n\n}\n\nclass Skin {\n\tconstructor(graphicsDevice, ibp, boneNames) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.inverseBindPose = ibp;\n\t\tthis.boneNames = boneNames;\n\t}\n\n}\n\nclass Render extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._meshes = null;\n\t}\n\n\tset meshes(value) {\n\t\tthis.decRefMeshes();\n\t\tthis._meshes = value;\n\t\tthis.incRefMeshes();\n\t\tthis.fire('set:meshes', value);\n\t}\n\n\tget meshes() {\n\t\treturn this._meshes;\n\t}\n\n\tdestroy() {\n\t\tthis.meshes = null;\n\t}\n\n\tdecRefMeshes() {\n\t\tif (this._meshes) {\n\t\t\tconst count = this._meshes.length;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst mesh = this._meshes[i];\n\n\t\t\t\tif (mesh) {\n\t\t\t\t\tmesh.decRefCount();\n\n\t\t\t\t\tif (mesh.refCount < 1) {\n\t\t\t\t\t\tmesh.destroy();\n\t\t\t\t\t\tthis._meshes[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tincRefMeshes() {\n\t\tif (this._meshes) {\n\t\t\tconst count = this._meshes.length;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tif (this._meshes[i]) {\n\t\t\t\t\tthis._meshes[i].incRefCount();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimCurve {\n\tconstructor(paths, input, output, interpolation) {\n\t\tthis._paths = paths;\n\t\tthis._input = input;\n\t\tthis._output = output;\n\t\tthis._interpolation = interpolation;\n\t}\n\n\tget paths() {\n\t\treturn this._paths;\n\t}\n\n\tget input() {\n\t\treturn this._input;\n\t}\n\n\tget output() {\n\t\treturn this._output;\n\t}\n\n\tget interpolation() {\n\t\treturn this._interpolation;\n\t}\n\n}\n\nclass AnimData {\n\tconstructor(components, data) {\n\t\tthis._components = components;\n\t\tthis._data = data;\n\t}\n\n\tget components() {\n\t\treturn this._components;\n\t}\n\n\tget data() {\n\t\treturn this._data;\n\t}\n\n}\n\nclass AnimEvents {\n\tconstructor(events) {\n\t\tthis._events = [...events];\n\n\t\tthis._events.sort((a, b) => a.time - b.time);\n\t}\n\n\tget events() {\n\t\treturn this._events;\n\t}\n\n}\n\nclass AnimTrack {\n\tconstructor(name, duration, inputs, outputs, curves, animEvents = new AnimEvents([])) {\n\t\tthis._name = name;\n\t\tthis._duration = duration;\n\t\tthis._inputs = inputs;\n\t\tthis._outputs = outputs;\n\t\tthis._curves = curves;\n\t\tthis._animEvents = animEvents;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tget inputs() {\n\t\treturn this._inputs;\n\t}\n\n\tget outputs() {\n\t\treturn this._outputs;\n\t}\n\n\tget curves() {\n\t\treturn this._curves;\n\t}\n\n\tset events(animEvents) {\n\t\tthis._animEvents = animEvents;\n\t}\n\n\tget events() {\n\t\treturn this._animEvents.events;\n\t}\n\n\teval(time, snapshot) {\n\t\tsnapshot._time = time;\n\t\tconst inputs = this._inputs;\n\t\tconst outputs = this._outputs;\n\t\tconst curves = this._curves;\n\t\tconst cache = snapshot._cache;\n\t\tconst results = snapshot._results;\n\n\t\tfor (let i = 0; i < inputs.length; ++i) {\n\t\t\tcache[i].update(time, inputs[i]._data);\n\t\t}\n\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst output = outputs[curve._output];\n\t\t\tconst result = results[i];\n\n\t\t\tcache[curve._input].eval(result, curve._interpolation, output);\n\t\t}\n\t}\n\n}\n\nconst INTERPOLATION_STEP = 0;\nconst INTERPOLATION_LINEAR = 1;\nconst INTERPOLATION_CUBIC = 2;\n\nconst DEFAULT_LOCALE = 'en-US';\nconst DEFAULT_LOCALE_FALLBACKS = {\n\t'en': 'en-US',\n\t'es': 'en-ES',\n\t'zh': 'zh-CN',\n\t'zh-HK': 'zh-TW',\n\t'zh-TW': 'zh-HK',\n\t'zh-MO': 'zh-HK',\n\t'fr': 'fr-FR',\n\t'de': 'de-DE',\n\t'it': 'it-IT',\n\t'ru': 'ru-RU',\n\t'ja': 'ja-JP'\n};\n\nconst PLURALS = {};\n\nfunction definePluralFn(locales, fn) {\n\tfor (let i = 0, len = locales.length; i < len; i++) {\n\t\tPLURALS[locales[i]] = fn;\n\t}\n}\n\nfunction getLang(locale) {\n\tconst idx = locale.indexOf('-');\n\n\tif (idx !== -1) {\n\t\treturn locale.substring(0, idx);\n\t}\n\n\treturn locale;\n}\n\nfunction replaceLang(locale, desiredLang) {\n\tconst idx = locale.indexOf('-');\n\n\tif (idx !== -1) {\n\t\treturn desiredLang + locale.substring(idx);\n\t}\n\n\treturn desiredLang;\n}\n\nfunction findAvailableLocale(desiredLocale, availableLocales) {\n\tif (availableLocales[desiredLocale]) {\n\t\treturn desiredLocale;\n\t}\n\n\tlet fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];\n\n\tif (fallback && availableLocales[fallback]) {\n\t\treturn fallback;\n\t}\n\n\tconst lang = getLang(desiredLocale);\n\tfallback = DEFAULT_LOCALE_FALLBACKS[lang];\n\n\tif (availableLocales[fallback]) {\n\t\treturn fallback;\n\t}\n\n\tif (availableLocales[lang]) {\n\t\treturn lang;\n\t}\n\n\treturn DEFAULT_LOCALE;\n}\n\ndefinePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {\n\treturn 0;\n});\ndefinePluralFn(['fa', 'hi'], function (n) {\n\tif (n >= 0 && n <= 1) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n});\ndefinePluralFn(['fr', 'pt'], function (n) {\n\tif (n >= 0 && n < 2) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n});\ndefinePluralFn(['da'], function (n) {\n\tif (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n});\ndefinePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {\n\tif (n === 1) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n});\ndefinePluralFn(['ru', 'uk'], function (n) {\n\tif (Number.isInteger(n)) {\n\t\tconst mod10 = n % 10;\n\t\tconst mod100 = n % 100;\n\n\t\tif (mod10 === 1 && mod100 !== 11) {\n\t\t\treturn 0;\n\t\t} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {\n\t\t\treturn 1;\n\t\t} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\treturn 3;\n});\ndefinePluralFn(['pl'], function (n) {\n\tif (Number.isInteger(n)) {\n\t\tif (n === 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst mod10 = n % 10;\n\t\tconst mod100 = n % 100;\n\n\t\tif (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {\n\t\t\treturn 1;\n\t\t} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\treturn 3;\n});\ndefinePluralFn(['ar'], function (n) {\n\tif (n === 0) {\n\t\treturn 0;\n\t} else if (n === 1) {\n\t\treturn 1;\n\t} else if (n === 2) {\n\t\treturn 2;\n\t}\n\n\tif (Number.isInteger(n)) {\n\t\tconst mod100 = n % 100;\n\n\t\tif (mod100 >= 3 && mod100 <= 10) {\n\t\t\treturn 3;\n\t\t} else if (mod100 >= 11 && mod100 <= 99) {\n\t\t\treturn 4;\n\t\t}\n\t}\n\n\treturn 5;\n});\nconst DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];\n\nfunction getPluralFn(lang) {\n\treturn PLURALS[lang] || DEFAULT_PLURAL_FN;\n}\n\nconst ABSOLUTE_URL = new RegExp('^' + '\\\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\\\-\\\\+\\\\.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');\nconst ASSET_ANIMATION = 'animation';\nconst ASSET_AUDIO = 'audio';\nconst ASSET_IMAGE = 'image';\nconst ASSET_JSON = 'json';\nconst ASSET_MODEL = 'model';\nconst ASSET_MATERIAL = 'material';\nconst ASSET_TEXT = 'text';\nconst ASSET_TEXTURE = 'texture';\nconst ASSET_CUBEMAP = 'cubemap';\nconst ASSET_SHADER = 'shader';\nconst ASSET_CSS = 'css';\nconst ASSET_HTML = 'html';\nconst ASSET_SCRIPT = 'script';\nconst ASSET_CONTAINER = 'container';\n\nclass AssetFile {\n\tconstructor(url, filename, hash, size, opt, contents) {\n\t\tthis.url = url || '';\n\t\tthis.filename = filename || '';\n\t\tthis.hash = hash === undefined ? null : hash;\n\t\tthis.size = size === undefined ? null : size;\n\t\tthis.opt = opt === undefined ? null : opt;\n\t\tthis.contents = contents || null;\n\t}\n\n\tequals(other) {\n\t\treturn this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;\n\t}\n\n}\n\nlet assetIdCounter = -1;\nconst VARIANT_SUPPORT = {\n\tpvr: 'extCompressedTexturePVRTC',\n\tdxt: 'extCompressedTextureS3TC',\n\tetc2: 'extCompressedTextureETC',\n\tetc1: 'extCompressedTextureETC1',\n\tbasis: 'canvas'\n};\nconst VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];\n\nclass Asset extends EventHandler {\n\tconstructor(name, type, file, data, options) {\n\t\tsuper();\n\t\tthis._id = assetIdCounter--;\n\t\tthis.name = name || '';\n\t\tthis.type = type;\n\t\tthis.tags = new Tags(this);\n\t\tthis._preload = false;\n\t\tthis._file = null;\n\t\tthis._data = data || {};\n\t\tthis.options = options || {};\n\t\tthis._resources = [];\n\t\tthis._i18n = {};\n\t\tthis.loaded = false;\n\t\tthis.loading = false;\n\t\tthis.registry = null;\n\t\tif (file) this.file = file;\n\t}\n\n\tset id(value) {\n\t\tthis._id = value;\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tset file(value) {\n\t\tif (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {\n\t\t\tvar _this$registry, _this$registry$_loade;\n\n\t\t\tconst app = ((_this$registry = this.registry) == null ? void 0 : (_this$registry$_loade = _this$registry._loader) == null ? void 0 : _this$registry$_loade._app) || getApplication();\n\t\t\tconst device = app == null ? void 0 : app.graphicsDevice;\n\n\t\t\tif (device) {\n\t\t\t\tfor (let i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {\n\t\t\t\t\tconst variant = VARIANT_DEFAULT_PRIORITY[i];\n\n\t\t\t\t\tif (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {\n\t\t\t\t\t\tvalue = value.variants[variant];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (app.enableBundles) {\n\t\t\t\t\t\tconst bundles = app.bundles.listBundlesForAsset(this);\n\n\t\t\t\t\t\tif (bundles && bundles.find(b => {\n\t\t\t\t\t\t\tvar _b$file;\n\n\t\t\t\t\t\t\treturn b == null ? void 0 : (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];\n\t\t\t\t\t\t})) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst oldFile = this._file;\n\t\tconst newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;\n\n\t\tif (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {\n\t\t\tthis._file = newFile;\n\t\t\tthis.fire('change', this, 'file', newFile, oldFile);\n\t\t\tthis.reload();\n\t\t}\n\t}\n\n\tget file() {\n\t\treturn this._file;\n\t}\n\n\tset data(value) {\n\t\tconst old = this._data;\n\t\tthis._data = value;\n\n\t\tif (value !== old) {\n\t\t\tthis.fire('change', this, 'data', value, old);\n\t\t\tif (this.loaded) this.registry._loader.patch(this, this.registry);\n\t\t}\n\t}\n\n\tget data() {\n\t\treturn this._data;\n\t}\n\n\tset resource(value) {\n\t\tconst _old = this._resources[0];\n\t\tthis._resources[0] = value;\n\t\tthis.fire('change', this, 'resource', value, _old);\n\t}\n\n\tget resource() {\n\t\treturn this._resources[0];\n\t}\n\n\tset resources(value) {\n\t\tconst _old = this._resources;\n\t\tthis._resources = value;\n\t\tthis.fire('change', this, 'resources', value, _old);\n\t}\n\n\tget resources() {\n\t\treturn this._resources;\n\t}\n\n\tset preload(value) {\n\t\tvalue = !!value;\n\t\tif (this._preload === value) return;\n\t\tthis._preload = value;\n\t\tif (this._preload && !this.loaded && !this.loading && this.registry) this.registry.load(this);\n\t}\n\n\tget preload() {\n\t\treturn this._preload;\n\t}\n\n\tset loadFaces(value) {\n\t\tvalue = !!value;\n\n\t\tif (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {\n\t\t\tthis._loadFaces = value;\n\t\t\tif (this.loaded) this.registry._loader.patch(this, this.registry);\n\t\t}\n\t}\n\n\tget loadFaces() {\n\t\treturn this._loadFaces;\n\t}\n\n\tgetFileUrl() {\n\t\tconst file = this.file;\n\t\tif (!file || !file.url) return null;\n\t\tlet url = file.url;\n\t\tif (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) url = this.registry.prefix + url;\n\n\t\tif (this.type !== 'script' && file.hash) {\n\t\t\tconst separator = url.indexOf('?') !== -1 ? '&' : '?';\n\t\t\turl += separator + 't=' + file.hash;\n\t\t}\n\n\t\treturn url;\n\t}\n\n\tgetAbsoluteUrl(relativePath) {\n\t\tif (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {\n\t\t\treturn relativePath;\n\t\t}\n\n\t\tconst base = path.getDirectory(this.file.url);\n\t\treturn path.join(base, relativePath);\n\t}\n\n\tgetLocalizedAssetId(locale) {\n\t\tlocale = findAvailableLocale(locale, this._i18n);\n\t\treturn this._i18n[locale] || null;\n\t}\n\n\taddLocalizedAssetId(locale, assetId) {\n\t\tthis._i18n[locale] = assetId;\n\t\tthis.fire('add:localized', locale, assetId);\n\t}\n\n\tremoveLocalizedAssetId(locale) {\n\t\tconst assetId = this._i18n[locale];\n\n\t\tif (assetId) {\n\t\t\tdelete this._i18n[locale];\n\t\t\tthis.fire('remove:localized', locale, assetId);\n\t\t}\n\t}\n\n\tready(callback, scope) {\n\t\tscope = scope || this;\n\n\t\tif (this.resource) {\n\t\t\tcallback.call(scope, this);\n\t\t} else {\n\t\t\tthis.once(\"load\", function (asset) {\n\t\t\t\tcallback.call(scope, asset);\n\t\t\t});\n\t\t}\n\t}\n\n\treload() {\n\t\tif (this.loaded) {\n\t\t\tthis.loaded = false;\n\t\t\tthis.registry.load(this);\n\t\t}\n\t}\n\n\tunload() {\n\t\tif (!this.loaded && this._resources.length === 0) return;\n\t\tthis.fire('unload', this);\n\t\tthis.registry.fire('unload:' + this.id, this);\n\t\tconst old = this._resources;\n\t\tthis.resources = [];\n\t\tthis.loaded = false;\n\n\t\tif (this.file) {\n\t\t\tthis.registry._loader.clearCache(this.getFileUrl(), this.type);\n\t\t}\n\n\t\tfor (let i = 0; i < old.length; ++i) {\n\t\t\tconst resource = old[i];\n\n\t\t\tif (resource && resource.destroy) {\n\t\t\t\tresource.destroy();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic fetchArrayBuffer(loadUrl, callback, asset, maxRetries = 0) {\n\t\tvar _asset$file;\n\n\t\tif (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tcallback(null, asset.file.contents);\n\t\t\t});\n\t\t} else {\n\t\t\thttp.get(loadUrl, {\n\t\t\t\tcache: true,\n\t\t\t\tresponseType: 'arraybuffer',\n\t\t\t\tretry: maxRetries > 0,\n\t\t\t\tmaxRetries: maxRetries\n\t\t\t}, callback);\n\t\t}\n\t}\n\n}\n\nclass SkinInstanceCachedObject extends RefCountedObject {\n\tconstructor(skin, skinInstance) {\n\t\tsuper();\n\t\tthis.skin = skin;\n\t\tthis.skinInstance = skinInstance;\n\t}\n\n}\n\nclass SkinInstanceCache {\n\tstatic createCachedSkinInstance(skin, rootBone, entity) {\n\t\tlet skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);\n\n\t\tif (!skinInst) {\n\t\t\tskinInst = new SkinInstance(skin);\n\t\t\tskinInst.resolve(rootBone, entity);\n\t\t\tSkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);\n\t\t}\n\n\t\treturn skinInst;\n\t}\n\n\tstatic getCachedSkinInstance(skin, rootBone) {\n\t\tlet skinInstance = null;\n\n\t\tconst cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\n\t\tif (cachedObjArray) {\n\t\t\tconst cachedObj = cachedObjArray.find(element => element.skin === skin);\n\n\t\t\tif (cachedObj) {\n\t\t\t\tcachedObj.incRefCount();\n\t\t\t\tskinInstance = cachedObj.skinInstance;\n\t\t\t}\n\t\t}\n\n\t\treturn skinInstance;\n\t}\n\n\tstatic addCachedSkinInstance(skin, rootBone, skinInstance) {\n\t\tlet cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\n\t\tif (!cachedObjArray) {\n\t\t\tcachedObjArray = [];\n\n\t\t\tSkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);\n\t\t}\n\n\t\tlet cachedObj = cachedObjArray.find(element => element.skin === skin);\n\n\t\tif (!cachedObj) {\n\t\t\tcachedObj = new SkinInstanceCachedObject(skin, skinInstance);\n\t\t\tcachedObjArray.push(cachedObj);\n\t\t}\n\n\t\tcachedObj.incRefCount();\n\t}\n\n\tstatic removeCachedSkinInstance(skinInstance) {\n\t\tif (skinInstance) {\n\t\t\tconst rootBone = skinInstance.rootBone;\n\n\t\t\tif (rootBone) {\n\t\t\t\tconst cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\n\t\t\t\tif (cachedObjArray) {\n\t\t\t\t\tconst cachedObjIndex = cachedObjArray.findIndex(element => element.skinInstance === skinInstance);\n\n\t\t\t\t\tif (cachedObjIndex >= 0) {\n\t\t\t\t\t\tconst cachedObj = cachedObjArray[cachedObjIndex];\n\t\t\t\t\t\tcachedObj.decRefCount();\n\n\t\t\t\t\t\tif (cachedObj.refCount === 0) {\n\t\t\t\t\t\t\tcachedObjArray.splice(cachedObjIndex, 1);\n\n\t\t\t\t\t\t\tif (!cachedObjArray.length) {\n\t\t\t\t\t\t\t\tSkinInstanceCache._skinInstanceCache.delete(rootBone);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (skinInstance) {\n\t\t\t\t\t\t\t\tskinInstance.destroy();\n\t\t\t\t\t\t\t\tcachedObj.skinInstance = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nSkinInstanceCache._skinInstanceCache = new Map();\n\nclass GlbContainerResource {\n\tconstructor(data, asset, assets, defaultMaterial) {\n\t\tconst createAsset = function createAsset(type, resource, index) {\n\t\t\tconst subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);\n\t\t\tassets.add(subAsset);\n\t\t\treturn subAsset;\n\t\t};\n\n\t\tconst renders = [];\n\n\t\tfor (let i = 0; i < data.renders.length; ++i) {\n\t\t\trenders.push(createAsset('render', data.renders[i], i));\n\t\t}\n\n\t\tconst materials = [];\n\n\t\tfor (let i = 0; i < data.materials.length; ++i) {\n\t\t\tmaterials.push(createAsset('material', data.materials[i], i));\n\t\t}\n\n\t\tconst animations = [];\n\n\t\tfor (let i = 0; i < data.animations.length; ++i) {\n\t\t\tanimations.push(createAsset('animation', data.animations[i], i));\n\t\t}\n\n\t\tthis.data = data;\n\t\tthis._model = null;\n\t\tthis._assetName = asset.name;\n\t\tthis._assets = assets;\n\t\tthis._defaultMaterial = defaultMaterial;\n\t\tthis.renders = renders;\n\t\tthis.materials = materials;\n\t\tthis.textures = data.textures;\n\t\tthis.animations = animations;\n\t}\n\n\tget model() {\n\t\tif (!this._model) {\n\t\t\tconst model = GlbContainerResource.createModel(this.data, this._defaultMaterial);\n\t\t\tconst modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);\n\n\t\t\tthis._assets.add(modelAsset);\n\n\t\t\tthis._model = modelAsset;\n\t\t}\n\n\t\treturn this._model;\n\t}\n\n\tstatic createAsset(assetName, type, resource, index) {\n\t\tconst subAsset = new Asset(assetName + '/' + type + '/' + index, type, {\n\t\t\turl: ''\n\t\t});\n\t\tsubAsset.resource = resource;\n\t\tsubAsset.loaded = true;\n\t\treturn subAsset;\n\t}\n\n\tinstantiateModelEntity(options) {\n\t\tconst entity = new Entity();\n\t\tentity.addComponent(\"model\", Object.assign({\n\t\t\ttype: \"asset\",\n\t\t\tasset: this.model\n\t\t}, options));\n\t\treturn entity;\n\t}\n\n\tinstantiateRenderEntity(options) {\n\t\tconst defaultMaterial = this._defaultMaterial;\n\t\tconst skinnedMeshInstances = [];\n\n\t\tconst createMeshInstance = function createMeshInstance(root, entity, mesh, materials, skins, gltfNode) {\n\t\t\tconst material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];\n\t\t\tconst meshInstance = new MeshInstance(mesh, material);\n\n\t\t\tif (mesh.morph) {\n\t\t\t\tmeshInstance.morphInstance = new MorphInstance(mesh.morph);\n\t\t\t}\n\n\t\t\tif (gltfNode.hasOwnProperty('skin')) {\n\t\t\t\tskinnedMeshInstances.push({\n\t\t\t\t\tmeshInstance: meshInstance,\n\t\t\t\t\trootBone: root,\n\t\t\t\t\tentity: entity\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn meshInstance;\n\t\t};\n\n\t\tconst cloneHierarchy = function cloneHierarchy(root, node, glb) {\n\t\t\tconst entity = new Entity();\n\n\t\t\tnode._cloneInternal(entity);\n\n\t\t\tif (!root) root = entity;\n\t\t\tlet attachedMi = null;\n\n\t\t\tfor (let i = 0; i < glb.nodes.length; i++) {\n\t\t\t\tconst glbNode = glb.nodes[i];\n\n\t\t\t\tif (glbNode === node) {\n\t\t\t\t\tconst gltfNode = glb.gltf.nodes[i];\n\n\t\t\t\t\tif (gltfNode.hasOwnProperty('mesh')) {\n\t\t\t\t\t\tconst meshGroup = glb.renders[gltfNode.mesh].meshes;\n\n\t\t\t\t\t\tfor (var mi = 0; mi < meshGroup.length; mi++) {\n\t\t\t\t\t\t\tconst mesh = meshGroup[mi];\n\n\t\t\t\t\t\t\tif (mesh) {\n\t\t\t\t\t\t\t\tconst cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.skins, gltfNode);\n\n\t\t\t\t\t\t\t\tif (!attachedMi) {\n\t\t\t\t\t\t\t\t\tattachedMi = [];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tattachedMi.push(cloneMi);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (glb.lights) {\n\t\t\t\t\t\tconst lightEntity = glb.lights.get(gltfNode);\n\n\t\t\t\t\t\tif (lightEntity) {\n\t\t\t\t\t\t\tentity.addChild(lightEntity.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (glb.cameras) {\n\t\t\t\t\t\tconst cameraEntity = glb.cameras.get(gltfNode);\n\n\t\t\t\t\t\tif (cameraEntity) {\n\t\t\t\t\t\t\tcameraEntity.camera.system.cloneComponent(cameraEntity, entity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (attachedMi) {\n\t\t\t\tentity.addComponent(\"render\", Object.assign({\n\t\t\t\t\ttype: \"asset\",\n\t\t\t\t\tmeshInstances: attachedMi,\n\t\t\t\t\trootBone: root\n\t\t\t\t}, options));\n\t\t\t}\n\n\t\t\tconst children = node.children;\n\n\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\tconst childClone = cloneHierarchy(root, children[i], glb);\n\t\t\t\tentity.addChild(childClone);\n\t\t\t}\n\n\t\t\treturn entity;\n\t\t};\n\n\t\tconst sceneClones = [];\n\n\t\tfor (const scene of this.data.scenes) {\n\t\t\tsceneClones.push(cloneHierarchy(null, scene, this.data));\n\t\t}\n\n\t\tskinnedMeshInstances.forEach(data => {\n\t\t\tdata.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);\n\t\t});\n\t\treturn GlbContainerResource.createSceneHierarchy(sceneClones, \"Entity\");\n\t}\n\n\tstatic createSceneHierarchy(sceneNodes, nodeType) {\n\t\tlet root = null;\n\n\t\tif (sceneNodes.length === 1) {\n\t\t\troot = sceneNodes[0];\n\t\t} else {\n\t\t\troot = new nodeType('SceneGroup');\n\n\t\t\tfor (const scene of sceneNodes) {\n\t\t\t\troot.addChild(scene);\n\t\t\t}\n\t\t}\n\n\t\treturn root;\n\t}\n\n\tstatic createModel(glb, defaultMaterial) {\n\t\tconst createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {\n\t\t\tconst material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, node);\n\n\t\t\tif (mesh.morph) {\n\t\t\t\tconst morphInstance = new MorphInstance(mesh.morph);\n\t\t\t\tmeshInstance.morphInstance = morphInstance;\n\t\t\t\tmodel.morphInstances.push(morphInstance);\n\t\t\t}\n\n\t\t\tif (gltfNode.hasOwnProperty('skin')) {\n\t\t\t\tconst skinIndex = gltfNode.skin;\n\t\t\t\tconst skin = skins[skinIndex];\n\t\t\t\tmesh.skin = skin;\n\t\t\t\tconst skinInstance = skinInstances[skinIndex];\n\t\t\t\tmeshInstance.skinInstance = skinInstance;\n\t\t\t\tmodel.skinInstances.push(skinInstance);\n\t\t\t}\n\n\t\t\tmodel.meshInstances.push(meshInstance);\n\t\t};\n\n\t\tconst model = new Model();\n\t\tconst skinInstances = [];\n\n\t\tfor (const skin of glb.skins) {\n\t\t\tconst skinInstance = new SkinInstance(skin);\n\t\t\tskinInstance.bones = skin.bones;\n\t\t\tskinInstances.push(skinInstance);\n\t\t}\n\n\t\tmodel.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, \"GraphNode\");\n\n\t\tfor (let i = 0; i < glb.nodes.length; i++) {\n\t\t\tconst node = glb.nodes[i];\n\n\t\t\tif (node.root === model.graph) {\n\t\t\t\tconst gltfNode = glb.gltf.nodes[i];\n\n\t\t\t\tif (gltfNode.hasOwnProperty('mesh')) {\n\t\t\t\t\tconst meshGroup = glb.renders[gltfNode.mesh].meshes;\n\n\t\t\t\t\tfor (var mi = 0; mi < meshGroup.length; mi++) {\n\t\t\t\t\t\tconst mesh = meshGroup[mi];\n\n\t\t\t\t\t\tif (mesh) {\n\t\t\t\t\t\t\tcreateMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tdestroy() {\n\t\tconst registry = this._assets;\n\n\t\tconst destroyAsset = function destroyAsset(asset) {\n\t\t\tregistry.remove(asset);\n\t\t\tasset.unload();\n\t\t};\n\n\t\tconst destroyAssets = function destroyAssets(assets) {\n\t\t\tassets.forEach(function (asset) {\n\t\t\t\tdestroyAsset(asset);\n\t\t\t});\n\t\t};\n\n\t\tif (this.animations) {\n\t\t\tdestroyAssets(this.animations);\n\t\t\tthis.animations = null;\n\t\t}\n\n\t\tif (this.textures) {\n\t\t\tdestroyAssets(this.textures);\n\t\t\tthis.textures = null;\n\t\t}\n\n\t\tif (this.materials) {\n\t\t\tdestroyAssets(this.materials);\n\t\t\tthis.materials = null;\n\t\t}\n\n\t\tif (this.renders) {\n\t\t\tdestroyAssets(this.renders);\n\t\t\tthis.renders = null;\n\t\t}\n\n\t\tif (this._model) {\n\t\t\tdestroyAsset(this._model);\n\t\t\tthis._model = null;\n\t\t}\n\n\t\tthis.data = null;\n\t\tthis.assets = null;\n\t}\n\n}\n\nclass GlbResources {\n\tconstructor(gltf) {\n\t\tthis.gltf = gltf;\n\t\tthis.nodes = null;\n\t\tthis.scenes = null;\n\t\tthis.animations = null;\n\t\tthis.textures = null;\n\t\tthis.materials = null;\n\t\tthis.renders = null;\n\t\tthis.skins = null;\n\t\tthis.lights = null;\n\t\tthis.cameras = null;\n\t}\n\n\tdestroy() {\n\t\tif (this.renders) {\n\t\t\tthis.renders.forEach(render => {\n\t\t\t\trender.meshes = null;\n\t\t\t});\n\t\t}\n\t}\n\n}\n\nconst isDataURI = function isDataURI(uri) {\n\treturn /^data:.*,.*$/i.test(uri);\n};\n\nconst getDataURIMimeType = function getDataURIMimeType(uri) {\n\treturn uri.substring(uri.indexOf(\":\") + 1, uri.indexOf(\";\"));\n};\n\nconst getNumComponents = function getNumComponents(accessorType) {\n\tswitch (accessorType) {\n\t\tcase 'SCALAR':\n\t\t\treturn 1;\n\n\t\tcase 'VEC2':\n\t\t\treturn 2;\n\n\t\tcase 'VEC3':\n\t\t\treturn 3;\n\n\t\tcase 'VEC4':\n\t\t\treturn 4;\n\n\t\tcase 'MAT2':\n\t\t\treturn 4;\n\n\t\tcase 'MAT3':\n\t\t\treturn 9;\n\n\t\tcase 'MAT4':\n\t\t\treturn 16;\n\n\t\tdefault:\n\t\t\treturn 3;\n\t}\n};\n\nconst getComponentType = function getComponentType(componentType) {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn TYPE_INT8;\n\n\t\tcase 5121:\n\t\t\treturn TYPE_UINT8;\n\n\t\tcase 5122:\n\t\t\treturn TYPE_INT16;\n\n\t\tcase 5123:\n\t\t\treturn TYPE_UINT16;\n\n\t\tcase 5124:\n\t\t\treturn TYPE_INT32;\n\n\t\tcase 5125:\n\t\t\treturn TYPE_UINT32;\n\n\t\tcase 5126:\n\t\t\treturn TYPE_FLOAT32;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n};\n\nconst getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn 1;\n\n\t\tcase 5121:\n\t\t\treturn 1;\n\n\t\tcase 5122:\n\t\t\treturn 2;\n\n\t\tcase 5123:\n\t\t\treturn 2;\n\n\t\tcase 5124:\n\t\t\treturn 4;\n\n\t\tcase 5125:\n\t\t\treturn 4;\n\n\t\tcase 5126:\n\t\t\treturn 4;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n};\n\nconst getComponentDataType = function getComponentDataType(componentType) {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn Int8Array;\n\n\t\tcase 5121:\n\t\t\treturn Uint8Array;\n\n\t\tcase 5122:\n\t\t\treturn Int16Array;\n\n\t\tcase 5123:\n\t\t\treturn Uint16Array;\n\n\t\tcase 5124:\n\t\t\treturn Int32Array;\n\n\t\tcase 5125:\n\t\t\treturn Uint32Array;\n\n\t\tcase 5126:\n\t\t\treturn Float32Array;\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n};\n\nconst gltfToEngineSemanticMap = {\n\t'POSITION': SEMANTIC_POSITION,\n\t'NORMAL': SEMANTIC_NORMAL,\n\t'TANGENT': SEMANTIC_TANGENT,\n\t'COLOR_0': SEMANTIC_COLOR,\n\t'JOINTS_0': SEMANTIC_BLENDINDICES,\n\t'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,\n\t'TEXCOORD_0': SEMANTIC_TEXCOORD0,\n\t'TEXCOORD_1': SEMANTIC_TEXCOORD1,\n\t'TEXCOORD_2': SEMANTIC_TEXCOORD2,\n\t'TEXCOORD_3': SEMANTIC_TEXCOORD3,\n\t'TEXCOORD_4': SEMANTIC_TEXCOORD4,\n\t'TEXCOORD_5': SEMANTIC_TEXCOORD5,\n\t'TEXCOORD_6': SEMANTIC_TEXCOORD6,\n\t'TEXCOORD_7': SEMANTIC_TEXCOORD7\n};\n\nconst getDequantizeFunc = srcType => {\n\tswitch (srcType) {\n\t\tcase TYPE_INT8:\n\t\t\treturn x => Math.max(x / 127.0, -1.0);\n\n\t\tcase TYPE_UINT8:\n\t\t\treturn x => x / 255.0;\n\n\t\tcase TYPE_INT16:\n\t\t\treturn x => Math.max(x / 32767.0, -1.0);\n\n\t\tcase TYPE_UINT16:\n\t\t\treturn x => x / 65535.0;\n\n\t\tdefault:\n\t\t\treturn x => x;\n\t}\n};\n\nconst dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {\n\tconst convFunc = getDequantizeFunc(srcType);\n\tconst len = srcArray.length;\n\n\tfor (let i = 0; i < len; ++i) {\n\t\tdstArray[i] = convFunc(srcArray[i]);\n\t}\n\n\treturn dstArray;\n};\n\nconst getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten = false) {\n\tconst numComponents = getNumComponents(gltfAccessor.type);\n\tconst dataType = getComponentDataType(gltfAccessor.componentType);\n\n\tif (!dataType) {\n\t\treturn null;\n\t}\n\n\tconst bufferView = bufferViews[gltfAccessor.bufferView];\n\tlet result;\n\n\tif (gltfAccessor.sparse) {\n\t\tconst sparse = gltfAccessor.sparse;\n\t\tconst indicesAccessor = {\n\t\t\tcount: sparse.count,\n\t\t\ttype: \"SCALAR\"\n\t\t};\n\t\tconst indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);\n\t\tconst valuesAccessor = {\n\t\t\tcount: sparse.count,\n\t\t\ttype: gltfAccessor.scalar,\n\t\t\tcomponentType: gltfAccessor.componentType\n\t\t};\n\t\tconst values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);\n\n\t\tif (gltfAccessor.hasOwnProperty('bufferView')) {\n\t\t\tconst baseAccessor = {\n\t\t\t\tbufferView: gltfAccessor.bufferView,\n\t\t\t\tbyteOffset: gltfAccessor.byteOffset,\n\t\t\t\tcomponentType: gltfAccessor.componentType,\n\t\t\t\tcount: gltfAccessor.count,\n\t\t\t\ttype: gltfAccessor.type\n\t\t\t};\n\t\t\tresult = getAccessorData(baseAccessor, bufferViews, true).slice();\n\t\t} else {\n\t\t\tresult = new dataType(gltfAccessor.count * numComponents);\n\t\t}\n\n\t\tfor (let i = 0; i < sparse.count; ++i) {\n\t\t\tconst targetIndex = indices[i];\n\n\t\t\tfor (let j = 0; j < numComponents; ++j) {\n\t\t\t\tresult[targetIndex * numComponents + j] = values[i * numComponents + j];\n\t\t\t}\n\t\t}\n\t} else if (flatten && bufferView.hasOwnProperty('byteStride')) {\n\t\tconst bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;\n\t\tconst storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);\n\t\tconst tmpArray = new Uint8Array(storage);\n\t\tlet dstOffset = 0;\n\n\t\tfor (let i = 0; i < gltfAccessor.count; ++i) {\n\t\t\tlet srcOffset = (gltfAccessor.byteOffset || 0) + i * bufferView.byteStride;\n\n\t\t\tfor (let b = 0; b < bytesPerElement; ++b) {\n\t\t\t\ttmpArray[dstOffset++] = bufferView[srcOffset++];\n\t\t\t}\n\t\t}\n\n\t\tresult = new dataType(storage);\n\t} else {\n\t\tresult = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);\n\t}\n\n\treturn result;\n};\n\nconst getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {\n\tconst data = getAccessorData(gltfAccessor, bufferViews, true);\n\n\tif (data instanceof Float32Array || !gltfAccessor.normalized) {\n\t\treturn data;\n\t}\n\n\tconst float32Data = new Float32Array(data.length);\n\tdequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));\n\treturn float32Data;\n};\n\nconst getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {\n\tlet min = gltfAccessor.min;\n\tlet max = gltfAccessor.max;\n\n\tif (!min || !max) {\n\t\treturn null;\n\t}\n\n\tif (gltfAccessor.normalized) {\n\t\tconst ctype = getComponentType(gltfAccessor.componentType);\n\t\tmin = dequantizeArray([], min, ctype);\n\t\tmax = dequantizeArray([], max, ctype);\n\t}\n\n\treturn new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n};\n\nconst getPrimitiveType = function getPrimitiveType(primitive) {\n\tif (!primitive.hasOwnProperty('mode')) {\n\t\treturn PRIMITIVE_TRIANGLES;\n\t}\n\n\tswitch (primitive.mode) {\n\t\tcase 0:\n\t\t\treturn PRIMITIVE_POINTS;\n\n\t\tcase 1:\n\t\t\treturn PRIMITIVE_LINES;\n\n\t\tcase 2:\n\t\t\treturn PRIMITIVE_LINELOOP;\n\n\t\tcase 3:\n\t\t\treturn PRIMITIVE_LINESTRIP;\n\n\t\tcase 4:\n\t\t\treturn PRIMITIVE_TRIANGLES;\n\n\t\tcase 5:\n\t\t\treturn PRIMITIVE_TRISTRIP;\n\n\t\tcase 6:\n\t\t\treturn PRIMITIVE_TRIFAN;\n\n\t\tdefault:\n\t\t\treturn PRIMITIVE_TRIANGLES;\n\t}\n};\n\nconst generateIndices = function generateIndices(numVertices) {\n\tconst dummyIndices = new Uint16Array(numVertices);\n\n\tfor (let i = 0; i < numVertices; i++) {\n\t\tdummyIndices[i] = i;\n\t}\n\n\treturn dummyIndices;\n};\n\nconst generateNormals = function generateNormals(sourceDesc, indices) {\n\tconst p = sourceDesc[SEMANTIC_POSITION];\n\n\tif (!p || p.components !== 3) {\n\t\treturn;\n\t}\n\n\tlet positions;\n\n\tif (p.size !== p.stride) {\n\t\tconst srcStride = p.stride / typedArrayTypesByteSize[p.type];\n\t\tconst src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);\n\t\tpositions = new typedArrayTypes[p.type](p.count * 3);\n\n\t\tfor (let i = 0; i < p.count; ++i) {\n\t\t\tpositions[i * 3 + 0] = src[i * srcStride + 0];\n\t\t\tpositions[i * 3 + 1] = src[i * srcStride + 1];\n\t\t\tpositions[i * 3 + 2] = src[i * srcStride + 2];\n\t\t}\n\t} else {\n\t\tpositions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);\n\t}\n\n\tconst numVertices = p.count;\n\n\tif (!indices) {\n\t\tindices = generateIndices(numVertices);\n\t}\n\n\tconst normalsTemp = calculateNormals(positions, indices);\n\tconst normals = new Float32Array(normalsTemp.length);\n\tnormals.set(normalsTemp);\n\tsourceDesc[SEMANTIC_NORMAL] = {\n\t\tbuffer: normals.buffer,\n\t\tsize: 12,\n\t\toffset: 0,\n\t\tstride: 12,\n\t\tcount: numVertices,\n\t\tcomponents: 3,\n\t\ttype: TYPE_FLOAT32\n\t};\n};\n\nconst flipTexCoordVs = function flipTexCoordVs(vertexBuffer) {\n\tlet i, j;\n\tconst floatOffsets = [];\n\tconst shortOffsets = [];\n\tconst byteOffsets = [];\n\n\tfor (i = 0; i < vertexBuffer.format.elements.length; ++i) {\n\t\tconst element = vertexBuffer.format.elements[i];\n\n\t\tif (element.name === SEMANTIC_TEXCOORD0 || element.name === SEMANTIC_TEXCOORD1) {\n\t\t\tswitch (element.dataType) {\n\t\t\t\tcase TYPE_FLOAT32:\n\t\t\t\t\tfloatOffsets.push({\n\t\t\t\t\t\toffset: element.offset / 4 + 1,\n\t\t\t\t\t\tstride: element.stride / 4\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TYPE_UINT16:\n\t\t\t\t\tshortOffsets.push({\n\t\t\t\t\t\toffset: element.offset / 2 + 1,\n\t\t\t\t\t\tstride: element.stride / 2\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TYPE_UINT8:\n\t\t\t\t\tbyteOffsets.push({\n\t\t\t\t\t\toffset: element.offset + 1,\n\t\t\t\t\t\tstride: element.stride\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst flip = function flip(offsets, type, one) {\n\t\tconst typedArray = new type(vertexBuffer.storage);\n\n\t\tfor (i = 0; i < offsets.length; ++i) {\n\t\t\tlet index = offsets[i].offset;\n\t\t\tconst stride = offsets[i].stride;\n\n\t\t\tfor (j = 0; j < vertexBuffer.numVertices; ++j) {\n\t\t\t\ttypedArray[index] = one - typedArray[index];\n\t\t\t\tindex += stride;\n\t\t\t}\n\t\t}\n\t};\n\n\tif (floatOffsets.length > 0) {\n\t\tflip(floatOffsets, Float32Array, 1.0);\n\t}\n\n\tif (shortOffsets.length > 0) {\n\t\tflip(shortOffsets, Uint16Array, 65535);\n\t}\n\n\tif (byteOffsets.length > 0) {\n\t\tflip(byteOffsets, Uint8Array, 255);\n\t}\n};\n\nconst cloneTexture = function cloneTexture(texture) {\n\tconst shallowCopyLevels = function shallowCopyLevels(texture) {\n\t\tconst result = [];\n\n\t\tfor (let mip = 0; mip < texture._levels.length; ++mip) {\n\t\t\tlet level = [];\n\n\t\t\tif (texture.cubemap) {\n\t\t\t\tfor (let face = 0; face < 6; ++face) {\n\t\t\t\t\tlevel.push(texture._levels[mip][face]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlevel = texture._levels[mip];\n\t\t\t}\n\n\t\t\tresult.push(level);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tconst result = new Texture(texture.device, texture);\n\tresult._levels = shallowCopyLevels(texture);\n\treturn result;\n};\n\nconst cloneTextureAsset = function cloneTextureAsset(src) {\n\tconst result = new Asset(src.name + '_clone', src.type, src.file, src.data, src.options);\n\tresult.loaded = true;\n\tresult.resource = cloneTexture(src.resource);\n\tsrc.registry.add(result);\n\treturn result;\n};\n\nconst createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc, flipV) {\n\tconst positionDesc = sourceDesc[SEMANTIC_POSITION];\n\n\tif (!positionDesc) {\n\t\treturn null;\n\t}\n\n\tconst numVertices = positionDesc.count;\n\tconst vertexDesc = [];\n\n\tfor (const semantic in sourceDesc) {\n\t\tif (sourceDesc.hasOwnProperty(semantic)) {\n\t\t\tvertexDesc.push({\n\t\t\t\tsemantic: semantic,\n\t\t\t\tcomponents: sourceDesc[semantic].components,\n\t\t\t\ttype: sourceDesc[semantic].type,\n\t\t\t\tnormalize: !!sourceDesc[semantic].normalize\n\t\t\t});\n\t\t}\n\t}\n\n\tconst elementOrder = [SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_COLOR, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1];\n\tvertexDesc.sort(function (lhs, rhs) {\n\t\tconst lhsOrder = elementOrder.indexOf(lhs.semantic);\n\t\tconst rhsOrder = elementOrder.indexOf(rhs.semantic);\n\t\treturn lhsOrder < rhsOrder ? -1 : rhsOrder < lhsOrder ? 1 : 0;\n\t});\n\tlet i, j, k;\n\tlet source, target, sourceOffset;\n\tconst vertexFormat = new VertexFormat(device, vertexDesc);\n\tlet isCorrectlyInterleaved = true;\n\n\tfor (i = 0; i < vertexFormat.elements.length; ++i) {\n\t\ttarget = vertexFormat.elements[i];\n\t\tsource = sourceDesc[target.name];\n\t\tsourceOffset = source.offset - positionDesc.offset;\n\n\t\tif (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {\n\t\t\tisCorrectlyInterleaved = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, BUFFER_STATIC);\n\tconst vertexData = vertexBuffer.lock();\n\tconst targetArray = new Uint32Array(vertexData);\n\tlet sourceArray;\n\n\tif (isCorrectlyInterleaved) {\n\t\tsourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);\n\t\ttargetArray.set(sourceArray);\n\t} else {\n\t\tlet targetStride, sourceStride;\n\n\t\tfor (i = 0; i < vertexBuffer.format.elements.length; ++i) {\n\t\t\ttarget = vertexBuffer.format.elements[i];\n\t\t\ttargetStride = target.stride / 4;\n\t\t\tsource = sourceDesc[target.name];\n\t\t\tsourceStride = source.stride / 4;\n\t\t\tsourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);\n\t\t\tlet src = 0;\n\t\t\tlet dst = target.offset / 4;\n\t\t\tconst kend = Math.floor((source.size + 3) / 4);\n\n\t\t\tfor (j = 0; j < numVertices; ++j) {\n\t\t\t\tfor (k = 0; k < kend; ++k) {\n\t\t\t\t\ttargetArray[dst + k] = sourceArray[src + k];\n\t\t\t\t}\n\n\t\t\t\tsrc += sourceStride;\n\t\t\t\tdst += targetStride;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flipV) {\n\t\tflipTexCoordVs(vertexBuffer);\n\t}\n\n\tvertexBuffer.unlock();\n\treturn vertexBuffer;\n};\n\nconst createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) {\n\tconst useAttributes = {};\n\tconst attribIds = [];\n\n\tfor (const attrib in attributes) {\n\t\tif (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {\n\t\t\tuseAttributes[attrib] = attributes[attrib];\n\t\t\tattribIds.push(attrib + \":\" + attributes[attrib]);\n\t\t}\n\t}\n\n\tattribIds.sort();\n\tconst vbKey = attribIds.join();\n\tlet vb = vertexBufferDict[vbKey];\n\n\tif (!vb) {\n\t\tconst sourceDesc = {};\n\n\t\tfor (const attrib in useAttributes) {\n\t\t\tconst accessor = accessors[attributes[attrib]];\n\t\t\tconst accessorData = getAccessorData(accessor, bufferViews);\n\t\t\tconst bufferView = bufferViews[accessor.bufferView];\n\t\t\tconst semantic = gltfToEngineSemanticMap[attrib];\n\t\t\tconst size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);\n\t\t\tconst stride = bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;\n\t\t\tsourceDesc[semantic] = {\n\t\t\t\tbuffer: accessorData.buffer,\n\t\t\t\tsize: size,\n\t\t\t\toffset: accessorData.byteOffset,\n\t\t\t\tstride: stride,\n\t\t\t\tcount: accessor.count,\n\t\t\t\tcomponents: getNumComponents(accessor.type),\n\t\t\t\ttype: getComponentType(accessor.componentType),\n\t\t\t\tnormalize: accessor.normalized\n\t\t\t};\n\t\t}\n\n\t\tif (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {\n\t\t\tgenerateNormals(sourceDesc, indices);\n\t\t}\n\n\t\tvb = createVertexBufferInternal(device, sourceDesc, flipV);\n\t\tvertexBufferDict[vbKey] = vb;\n\t}\n\n\treturn vb;\n};\n\nconst createVertexBufferDraco = function createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV) {\n\tconst numPoints = outputGeometry.num_points();\n\n\tconst extractDracoAttributeInfo = function extractDracoAttributeInfo(uniqueId) {\n\t\tconst attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);\n\t\tconst numValues = numPoints * attribute.num_components();\n\t\tconst dracoFormat = attribute.data_type();\n\t\tlet ptr, values, componentSizeInBytes, storageType;\n\n\t\tswitch (dracoFormat) {\n\t\t\tcase decoderModule.DT_UINT8:\n\t\t\t\tstorageType = TYPE_UINT8;\n\t\t\t\tcomponentSizeInBytes = 1;\n\t\t\t\tptr = decoderModule._malloc(numValues * componentSizeInBytes);\n\t\t\t\tdecoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);\n\t\t\t\tvalues = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();\n\t\t\t\tbreak;\n\n\t\t\tcase decoderModule.DT_UINT16:\n\t\t\t\tstorageType = TYPE_UINT16;\n\t\t\t\tcomponentSizeInBytes = 2;\n\t\t\t\tptr = decoderModule._malloc(numValues * componentSizeInBytes);\n\t\t\t\tdecoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);\n\t\t\t\tvalues = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();\n\t\t\t\tbreak;\n\n\t\t\tcase decoderModule.DT_FLOAT32:\n\t\t\tdefault:\n\t\t\t\tstorageType = TYPE_FLOAT32;\n\t\t\t\tcomponentSizeInBytes = 4;\n\t\t\t\tptr = decoderModule._malloc(numValues * componentSizeInBytes);\n\t\t\t\tdecoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);\n\t\t\t\tvalues = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdecoderModule._free(ptr);\n\n\t\treturn {\n\t\t\tvalues: values,\n\t\t\tnumComponents: attribute.num_components(),\n\t\t\tcomponentSizeInBytes: componentSizeInBytes,\n\t\t\tstorageType: storageType,\n\t\t\tnormalized: attribute.normalized()\n\t\t};\n\t};\n\n\tconst sourceDesc = {};\n\tconst attributes = extDraco.attributes;\n\n\tfor (const attrib in attributes) {\n\t\tif (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {\n\t\t\tconst semantic = gltfToEngineSemanticMap[attrib];\n\t\t\tconst attributeInfo = extractDracoAttributeInfo(attributes[attrib]);\n\t\t\tconst size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;\n\t\t\tsourceDesc[semantic] = {\n\t\t\t\tvalues: attributeInfo.values,\n\t\t\t\tbuffer: attributeInfo.values.buffer,\n\t\t\t\tsize: size,\n\t\t\t\toffset: 0,\n\t\t\t\tstride: size,\n\t\t\t\tcount: numPoints,\n\t\t\t\tcomponents: attributeInfo.numComponents,\n\t\t\t\ttype: attributeInfo.storageType,\n\t\t\t\tnormalize: attributeInfo.normalized\n\t\t\t};\n\t\t}\n\t}\n\n\tif (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {\n\t\tgenerateNormals(sourceDesc, indices);\n\t}\n\n\treturn createVertexBufferInternal(device, sourceDesc, flipV);\n};\n\nconst createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {\n\tlet i, j, bindMatrix;\n\tconst joints = gltfSkin.joints;\n\tconst numJoints = joints.length;\n\tconst ibp = [];\n\n\tif (gltfSkin.hasOwnProperty('inverseBindMatrices')) {\n\t\tconst inverseBindMatrices = gltfSkin.inverseBindMatrices;\n\t\tconst ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);\n\t\tconst ibmValues = [];\n\n\t\tfor (i = 0; i < numJoints; i++) {\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tibmValues[j] = ibmData[i * 16 + j];\n\t\t\t}\n\n\t\t\tbindMatrix = new Mat4();\n\t\t\tbindMatrix.set(ibmValues);\n\t\t\tibp.push(bindMatrix);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < numJoints; i++) {\n\t\t\tbindMatrix = new Mat4();\n\t\t\tibp.push(bindMatrix);\n\t\t}\n\t}\n\n\tconst boneNames = [];\n\n\tfor (i = 0; i < numJoints; i++) {\n\t\tboneNames[i] = nodes[joints[i]].name;\n\t}\n\n\tconst key = boneNames.join(\"#\");\n\tlet skin = glbSkins.get(key);\n\n\tif (!skin) {\n\t\tskin = new Skin(device, ibp, boneNames);\n\t\tglbSkins.set(key, skin);\n\t}\n\n\treturn skin;\n};\n\nconst tempMat = new Mat4();\nconst tempVec$1 = new Vec3();\n\nconst createMesh = function createMesh(device, gltfMesh, accessors, bufferViews, callback, flipV, vertexBufferDict) {\n\tconst meshes = [];\n\tgltfMesh.primitives.forEach(function (primitive) {\n\t\tlet primitiveType, vertexBuffer, numIndices;\n\t\tlet indices = null;\n\t\tlet canUseMorph = true;\n\n\t\tif (primitive.hasOwnProperty('extensions')) {\n\t\t\tconst extensions = primitive.extensions;\n\n\t\t\tif (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {\n\t\t\t\tconst decoderModule = window.DracoDecoderModule;\n\n\t\t\t\tif (decoderModule) {\n\t\t\t\t\tconst extDraco = extensions.KHR_draco_mesh_compression;\n\n\t\t\t\t\tif (extDraco.hasOwnProperty('attributes')) {\n\t\t\t\t\t\tconst uint8Buffer = bufferViews[extDraco.bufferView];\n\t\t\t\t\t\tconst buffer = new decoderModule.DecoderBuffer();\n\t\t\t\t\t\tbuffer.Init(uint8Buffer, uint8Buffer.length);\n\t\t\t\t\t\tconst decoder = new decoderModule.Decoder();\n\t\t\t\t\t\tconst geometryType = decoder.GetEncodedGeometryType(buffer);\n\t\t\t\t\t\tlet outputGeometry, status;\n\n\t\t\t\t\t\tswitch (geometryType) {\n\t\t\t\t\t\t\tcase decoderModule.POINT_CLOUD:\n\t\t\t\t\t\t\t\tprimitiveType = PRIMITIVE_POINTS;\n\t\t\t\t\t\t\t\toutputGeometry = new decoderModule.PointCloud();\n\t\t\t\t\t\t\t\tstatus = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase decoderModule.TRIANGULAR_MESH:\n\t\t\t\t\t\t\t\tprimitiveType = PRIMITIVE_TRIANGLES;\n\t\t\t\t\t\t\t\toutputGeometry = new decoderModule.Mesh();\n\t\t\t\t\t\t\t\tstatus = decoder.DecodeBufferToMesh(buffer, outputGeometry);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase decoderModule.INVALID_GEOMETRY_TYPE:\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!status || !status.ok() || outputGeometry.ptr == 0) {\n\t\t\t\t\t\t\tcallback(\"Failed to decode draco compressed asset: \" + (status ? status.error_msg() : 'Mesh asset - invalid draco compressed geometry type: ' + geometryType));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst numFaces = outputGeometry.num_faces();\n\n\t\t\t\t\t\tif (geometryType === decoderModule.TRIANGULAR_MESH) {\n\t\t\t\t\t\t\tconst bit32 = outputGeometry.num_points() > 65535;\n\t\t\t\t\t\t\tnumIndices = numFaces * 3;\n\t\t\t\t\t\t\tconst dataSize = numIndices * (bit32 ? 4 : 2);\n\n\t\t\t\t\t\t\tconst ptr = decoderModule._malloc(dataSize);\n\n\t\t\t\t\t\t\tif (bit32) {\n\t\t\t\t\t\t\t\tdecoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);\n\t\t\t\t\t\t\t\tindices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdecoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);\n\t\t\t\t\t\t\t\tindices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdecoderModule._free(ptr);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV);\n\t\t\t\t\t\tdecoderModule.destroy(outputGeometry);\n\t\t\t\t\t\tdecoderModule.destroy(decoder);\n\t\t\t\t\t\tdecoderModule.destroy(buffer);\n\t\t\t\t\t\tcanUseMorph = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!vertexBuffer) {\n\t\t\tindices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;\n\t\t\tvertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);\n\t\t\tprimitiveType = getPrimitiveType(primitive);\n\t\t}\n\n\t\tlet mesh = null;\n\n\t\tif (vertexBuffer) {\n\t\t\tmesh = new Mesh(device);\n\t\t\tmesh.vertexBuffer = vertexBuffer;\n\t\t\tmesh.primitive[0].type = primitiveType;\n\t\t\tmesh.primitive[0].base = 0;\n\t\t\tmesh.primitive[0].indexed = indices !== null;\n\n\t\t\tif (indices !== null) {\n\t\t\t\tlet indexFormat;\n\n\t\t\t\tif (indices instanceof Uint8Array) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT8;\n\t\t\t\t} else if (indices instanceof Uint16Array) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT16;\n\t\t\t\t} else {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT32;\n\t\t\t\t}\n\n\t\t\t\tif (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT16;\n\t\t\t\t\tindices = new Uint16Array(indices);\n\t\t\t\t}\n\n\t\t\t\tconst indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);\n\t\t\t\tmesh.indexBuffer[0] = indexBuffer;\n\t\t\t\tmesh.primitive[0].count = indices.length;\n\t\t\t} else {\n\t\t\t\tmesh.primitive[0].count = vertexBuffer.numVertices;\n\t\t\t}\n\n\t\t\tmesh.materialIndex = primitive.material;\n\t\t\tlet accessor = accessors[primitive.attributes.POSITION];\n\t\t\tmesh.aabb = getAccessorBoundingBox(accessor);\n\n\t\t\tif (canUseMorph && primitive.hasOwnProperty('targets')) {\n\t\t\t\tconst targets = [];\n\t\t\t\tprimitive.targets.forEach(function (target, index) {\n\t\t\t\t\tconst options = {};\n\n\t\t\t\t\tif (target.hasOwnProperty('POSITION')) {\n\t\t\t\t\t\taccessor = accessors[target.POSITION];\n\t\t\t\t\t\toptions.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);\n\t\t\t\t\t\toptions.deltaPositionsType = TYPE_FLOAT32;\n\t\t\t\t\t\toptions.aabb = getAccessorBoundingBox(accessor);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target.hasOwnProperty('NORMAL')) {\n\t\t\t\t\t\taccessor = accessors[target.NORMAL];\n\t\t\t\t\t\toptions.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);\n\t\t\t\t\t\toptions.deltaNormalsType = TYPE_FLOAT32;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {\n\t\t\t\t\t\toptions.name = gltfMesh.extras.targetNames[index];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.name = index.toString(10);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gltfMesh.hasOwnProperty('weights')) {\n\t\t\t\t\t\toptions.defaultWeight = gltfMesh.weights[index];\n\t\t\t\t\t}\n\n\t\t\t\t\ttargets.push(new MorphTarget(options));\n\t\t\t\t});\n\t\t\t\tmesh.morph = new Morph(targets, device);\n\t\t\t}\n\t\t}\n\n\t\tmeshes.push(mesh);\n\t});\n\treturn meshes;\n};\n\nconst createMaterial = function createMaterial(gltfMaterial, textures, flipV) {\n\tconst glossChunk = [\"#ifdef MAPFLOAT\", \"uniform float material_shininess;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"uniform sampler2D texture_glossMap;\", \"#endif\", \"\", \"void getGlossiness() {\", \"\t\tdGlossiness = 1.0;\", \"\", \"#ifdef MAPFLOAT\", \"\t\tdGlossiness *= material_shininess;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"\t\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\", \"#endif\", \"\", \"#ifdef MAPVERTEX\", \"\t\tdGlossiness *= saturate(vVertexColor.$VC);\", \"#endif\", \"\", \"\t\tdGlossiness = 1.0 - dGlossiness;\", \"\", \"\t\tdGlossiness += 0.0000001;\", \"}\"].join('\\n');\n\tconst specularChunk = [\"#ifdef MAPCOLOR\", \"uniform vec3 material_specular;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"uniform sampler2D texture_specularMap;\", \"#endif\", \"\", \"void getSpecularity() {\", \"\t\tdSpecularity = vec3(1.0);\", \"\", \"\t\t#ifdef MAPCOLOR\", \"\t\t\t\tdSpecularity *= material_specular;\", \"\t\t#endif\", \"\", \"\t\t#ifdef MAPTEXTURE\", \"\t\t\t\tvec3 srgb = texture2D(texture_specularMap, $UV).$CH;\", \"\t\t\t\tdSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));\", \"\t\t#endif\", \"\", \"\t\t#ifdef MAPVERTEX\", \"\t\t\t\tdSpecularity *= saturate(vVertexColor.$VC);\", \"\t\t#endif\", \"}\"].join('\\n');\n\tconst clearCoatGlossChunk = [\"#ifdef MAPFLOAT\", \"uniform float material_clearCoatGlossiness;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"uniform sampler2D texture_clearCoatGlossMap;\", \"#endif\", \"\", \"void getClearCoatGlossiness() {\", \"\t\tccGlossiness = 1.0;\", \"\", \"#ifdef MAPFLOAT\", \"\t\tccGlossiness *= material_clearCoatGlossiness;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"\t\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\", \"#endif\", \"\", \"#ifdef MAPVERTEX\", \"\t\tccGlossiness *= saturate(vVertexColor.$VC);\", \"#endif\", \"\", \"\t\tccGlossiness = 1.0 - ccGlossiness;\", \"\", \"\t\tccGlossiness += 0.0000001;\", \"}\"].join('\\n');\n\tconst zeros = [0, 0];\n\tconst ones = [1, 1];\n\n\tconst extractTextureTransform = function extractTextureTransform(source, material, maps) {\n\t\tvar _source$extensions;\n\n\t\tlet map;\n\t\tconst texCoord = source.texCoord;\n\n\t\tif (texCoord) {\n\t\t\tfor (map = 0; map < maps.length; ++map) {\n\t\t\t\tmaterial[maps[map] + 'MapUv'] = texCoord;\n\t\t\t}\n\t\t}\n\n\t\tconst textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;\n\n\t\tif (textureTransform) {\n\t\t\tconst offset = textureTransform.offset || zeros;\n\t\t\tconst scale = textureTransform.scale || ones;\n\t\t\tconst rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;\n\t\t\tconst tilingVec = new Vec2(scale[0], scale[1]);\n\t\t\tconst offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);\n\n\t\t\tfor (map = 0; map < maps.length; ++map) {\n\t\t\t\tmaterial[`${maps[map]}MapTiling`] = tilingVec;\n\t\t\t\tmaterial[`${maps[map]}MapOffset`] = offsetVec;\n\t\t\t\tmaterial[`${maps[map]}MapRotation`] = rotation;\n\t\t\t}\n\t\t}\n\t};\n\n\tconst material = new StandardMaterial();\n\tmaterial.occludeSpecular = true;\n\tmaterial.diffuseTint = true;\n\tmaterial.diffuseVertexColor = true;\n\tmaterial.specularTint = true;\n\tmaterial.specularVertexColor = true;\n\n\tif (gltfMaterial.hasOwnProperty('name')) {\n\t\tmaterial.name = gltfMaterial.name;\n\t}\n\n\tlet color, texture;\n\n\tif (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_pbrSpecularGlossiness')) {\n\t\tconst specData = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;\n\n\t\tif (specData.hasOwnProperty('diffuseFactor')) {\n\t\t\tcolor = specData.diffuseFactor;\n\t\t\tmaterial.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\t\tmaterial.opacity = color[3];\n\t\t} else {\n\t\t\tmaterial.diffuse.set(1, 1, 1);\n\t\t\tmaterial.opacity = 1;\n\t\t}\n\n\t\tif (specData.hasOwnProperty('diffuseTexture')) {\n\t\t\tconst diffuseTexture = specData.diffuseTexture;\n\t\t\ttexture = textures[diffuseTexture.index];\n\t\t\tmaterial.diffuseMap = texture;\n\t\t\tmaterial.diffuseMapChannel = 'rgb';\n\t\t\tmaterial.opacityMap = texture;\n\t\t\tmaterial.opacityMapChannel = 'a';\n\t\t\textractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);\n\t\t}\n\n\t\tmaterial.useMetalness = false;\n\n\t\tif (specData.hasOwnProperty('specularFactor')) {\n\t\t\tcolor = specData.specularFactor;\n\t\t\tmaterial.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\t} else {\n\t\t\tmaterial.specular.set(1, 1, 1);\n\t\t}\n\n\t\tif (specData.hasOwnProperty('glossinessFactor')) {\n\t\t\tmaterial.shininess = 100 * specData.glossinessFactor;\n\t\t} else {\n\t\t\tmaterial.shininess = 100;\n\t\t}\n\n\t\tif (specData.hasOwnProperty('specularGlossinessTexture')) {\n\t\t\tconst specularGlossinessTexture = specData.specularGlossinessTexture;\n\t\t\tmaterial.specularMap = material.glossMap = textures[specularGlossinessTexture.index];\n\t\t\tmaterial.specularMapChannel = 'rgb';\n\t\t\tmaterial.glossMapChannel = 'a';\n\t\t\textractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);\n\t\t}\n\n\t\tmaterial.chunks.specularPS = specularChunk;\n\t} else if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {\n\t\tconst pbrData = gltfMaterial.pbrMetallicRoughness;\n\n\t\tif (pbrData.hasOwnProperty('baseColorFactor')) {\n\t\t\tcolor = pbrData.baseColorFactor;\n\t\t\tmaterial.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\t\tmaterial.opacity = color[3];\n\t\t} else {\n\t\t\tmaterial.diffuse.set(1, 1, 1);\n\t\t\tmaterial.opacity = 1;\n\t\t}\n\n\t\tif (pbrData.hasOwnProperty('baseColorTexture')) {\n\t\t\tconst baseColorTexture = pbrData.baseColorTexture;\n\t\t\ttexture = textures[baseColorTexture.index];\n\t\t\tmaterial.diffuseMap = texture;\n\t\t\tmaterial.diffuseMapChannel = 'rgb';\n\t\t\tmaterial.opacityMap = texture;\n\t\t\tmaterial.opacityMapChannel = 'a';\n\t\t\textractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);\n\t\t}\n\n\t\tmaterial.useMetalness = true;\n\n\t\tif (pbrData.hasOwnProperty('metallicFactor')) {\n\t\t\tmaterial.metalness = pbrData.metallicFactor;\n\t\t} else {\n\t\t\tmaterial.metalness = 1;\n\t\t}\n\n\t\tif (pbrData.hasOwnProperty('roughnessFactor')) {\n\t\t\tmaterial.shininess = 100 * pbrData.roughnessFactor;\n\t\t} else {\n\t\t\tmaterial.shininess = 100;\n\t\t}\n\n\t\tif (pbrData.hasOwnProperty('metallicRoughnessTexture')) {\n\t\t\tconst metallicRoughnessTexture = pbrData.metallicRoughnessTexture;\n\t\t\tmaterial.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];\n\t\t\tmaterial.metalnessMapChannel = 'b';\n\t\t\tmaterial.glossMapChannel = 'g';\n\t\t\textractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);\n\t\t}\n\n\t\tmaterial.chunks.glossPS = glossChunk;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('normalTexture')) {\n\t\tconst normalTexture = gltfMaterial.normalTexture;\n\t\tmaterial.normalMap = textures[normalTexture.index];\n\t\textractTextureTransform(normalTexture, material, ['normal']);\n\n\t\tif (normalTexture.hasOwnProperty('scale')) {\n\t\t\tmaterial.bumpiness = normalTexture.scale;\n\t\t}\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('occlusionTexture')) {\n\t\tconst occlusionTexture = gltfMaterial.occlusionTexture;\n\t\tmaterial.aoMap = textures[occlusionTexture.index];\n\t\tmaterial.aoMapChannel = 'r';\n\t\textractTextureTransform(occlusionTexture, material, ['ao']);\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('emissiveFactor')) {\n\t\tcolor = gltfMaterial.emissiveFactor;\n\t\tmaterial.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\tmaterial.emissiveTint = true;\n\t} else {\n\t\tmaterial.emissive.set(0, 0, 0);\n\t\tmaterial.emissiveTint = false;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('emissiveTexture')) {\n\t\tconst emissiveTexture = gltfMaterial.emissiveTexture;\n\t\tmaterial.emissiveMap = textures[emissiveTexture.index];\n\t\textractTextureTransform(emissiveTexture, material, ['emissive']);\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('alphaMode')) {\n\t\tswitch (gltfMaterial.alphaMode) {\n\t\t\tcase 'MASK':\n\t\t\t\tmaterial.blendType = BLEND_NONE;\n\n\t\t\t\tif (gltfMaterial.hasOwnProperty('alphaCutoff')) {\n\t\t\t\t\tmaterial.alphaTest = gltfMaterial.alphaCutoff;\n\t\t\t\t} else {\n\t\t\t\t\tmaterial.alphaTest = 0.5;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'BLEND':\n\t\t\t\tmaterial.blendType = BLEND_NORMAL;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tcase 'OPAQUE':\n\t\t\t\tmaterial.blendType = BLEND_NONE;\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmaterial.blendType = BLEND_NONE;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('doubleSided')) {\n\t\tmaterial.twoSidedLighting = gltfMaterial.doubleSided;\n\t\tmaterial.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;\n\t} else {\n\t\tmaterial.twoSidedLighting = false;\n\t\tmaterial.cull = CULLFACE_BACK;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_clearcoat')) {\n\t\tconst ccData = gltfMaterial.extensions.KHR_materials_clearcoat;\n\n\t\tif (ccData.hasOwnProperty('clearcoatFactor')) {\n\t\t\tmaterial.clearCoat = ccData.clearcoatFactor * 0.25;\n\t\t} else {\n\t\t\tmaterial.clearCoat = 0;\n\t\t}\n\n\t\tif (ccData.hasOwnProperty('clearcoatTexture')) {\n\t\t\tconst clearcoatTexture = ccData.clearcoatTexture;\n\t\t\tmaterial.clearCoatMap = textures[clearcoatTexture.index];\n\t\t\tmaterial.clearCoatMapChannel = 'r';\n\t\t\textractTextureTransform(clearcoatTexture, material, ['clearCoat']);\n\t\t}\n\n\t\tif (ccData.hasOwnProperty('clearcoatRoughnessFactor')) {\n\t\t\tmaterial.clearCoatGlossiness = ccData.clearcoatRoughnessFactor;\n\t\t} else {\n\t\t\tmaterial.clearCoatGlossiness = 0;\n\t\t}\n\n\t\tif (ccData.hasOwnProperty('clearcoatRoughnessTexture')) {\n\t\t\tconst clearcoatRoughnessTexture = ccData.clearcoatRoughnessTexture;\n\t\t\tmaterial.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];\n\t\t\tmaterial.clearCoatGlossMapChannel = 'g';\n\t\t\textractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);\n\t\t}\n\n\t\tif (ccData.hasOwnProperty('clearcoatNormalTexture')) {\n\t\t\tconst clearcoatNormalTexture = ccData.clearcoatNormalTexture;\n\t\t\tmaterial.clearCoatNormalMap = textures[clearcoatNormalTexture.index];\n\t\t\textractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);\n\n\t\t\tif (clearcoatNormalTexture.hasOwnProperty('scale')) {\n\t\t\t\tmaterial.clearCoatBumpiness = clearcoatNormalTexture.scale;\n\t\t\t}\n\t\t}\n\n\t\tmaterial.chunks.clearCoatGlossPS = clearCoatGlossChunk;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_unlit')) {\n\t\tmaterial.useLighting = false;\n\t\tmaterial.emissive.copy(material.diffuse);\n\t\tmaterial.emissiveTint = material.diffuseTint;\n\t\tmaterial.emissiveMap = material.diffuseMap;\n\t\tmaterial.emissiveMapUv = material.diffuseMapUv;\n\t\tmaterial.emissiveMapTiling.copy(material.diffuseMapTiling);\n\t\tmaterial.emissiveMapOffset.copy(material.diffuseMapOffset);\n\t\tmaterial.emissiveMapChannel = material.diffuseMapChannel;\n\t\tmaterial.emissiveVertexColor = material.diffuseVertexColor;\n\t\tmaterial.emissiveVertexColorChannel = material.diffuseVertexColorChannel;\n\t\tmaterial.diffuse.set(0, 0, 0);\n\t\tmaterial.diffuseTint = false;\n\t\tmaterial.diffuseMap = null;\n\t\tmaterial.diffuseVertexColor = false;\n\t}\n\n\tmaterial.update();\n\treturn material;\n};\n\nconst createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes) {\n\tconst createAnimData = function createAnimData(gltfAccessor) {\n\t\treturn new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));\n\t};\n\n\tconst interpMap = {\n\t\t\"STEP\": INTERPOLATION_STEP,\n\t\t\"LINEAR\": INTERPOLATION_LINEAR,\n\t\t\"CUBICSPLINE\": INTERPOLATION_CUBIC\n\t};\n\tconst inputMap = {};\n\tconst inputs = [];\n\tconst outputMap = {};\n\tconst outputs = [];\n\tconst curves = [];\n\tlet i;\n\n\tfor (i = 0; i < gltfAnimation.samplers.length; ++i) {\n\t\tconst sampler = gltfAnimation.samplers[i];\n\n\t\tif (!inputMap.hasOwnProperty(sampler.input)) {\n\t\t\tinputMap[sampler.input] = inputs.length;\n\t\t\tinputs.push(createAnimData(gltfAccessors[sampler.input]));\n\t\t}\n\n\t\tif (!outputMap.hasOwnProperty(sampler.output)) {\n\t\t\toutputMap[sampler.output] = outputs.length;\n\t\t\toutputs.push(createAnimData(gltfAccessors[sampler.output]));\n\t\t}\n\n\t\tconst interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;\n\t\tcurves.push(new AnimCurve([], inputMap[sampler.input], outputMap[sampler.output], interpolation));\n\t}\n\n\tconst quatArrays = [];\n\tconst transformSchema = {\n\t\t'translation': 'localPosition',\n\t\t'rotation': 'localRotation',\n\t\t'scale': 'localScale',\n\t\t'weights': 'weights'\n\t};\n\n\tconst constructNodePath = node => {\n\t\tconst path = [];\n\n\t\twhile (node) {\n\t\t\tpath.unshift(node.name);\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn path;\n\t};\n\n\tfor (i = 0; i < gltfAnimation.channels.length; ++i) {\n\t\tconst channel = gltfAnimation.channels[i];\n\t\tconst target = channel.target;\n\t\tconst curve = curves[channel.sampler];\n\t\tconst node = nodes[target.node];\n\t\tconst entityPath = constructNodePath(node);\n\n\t\tcurve._paths.push({\n\t\t\tentityPath: entityPath,\n\t\t\tcomponent: 'graph',\n\t\t\tpropertyPath: [transformSchema[target.path]]\n\t\t});\n\n\t\tif (target.path.startsWith('rotation') && curve.interpolation !== INTERPOLATION_CUBIC) {\n\t\t\tquatArrays.push(curve.output);\n\t\t} else if (target.path.startsWith('weights')) {\n\t\t\toutputs[curve.output]._components = outputs[curve.output].data.length / inputs[curve.input].data.length;\n\t\t}\n\t}\n\n\tquatArrays.sort();\n\tlet prevIndex = null;\n\tlet data;\n\n\tfor (i = 0; i < quatArrays.length; ++i) {\n\t\tconst index = quatArrays[i];\n\n\t\tif (i === 0 || index !== prevIndex) {\n\t\t\tdata = outputs[index];\n\n\t\t\tif (data.components === 4) {\n\t\t\t\tconst d = data.data;\n\t\t\t\tconst len = d.length - 4;\n\n\t\t\t\tfor (let j = 0; j < len; j += 4) {\n\t\t\t\t\tconst dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];\n\n\t\t\t\t\tif (dp < 0) {\n\t\t\t\t\t\td[j + 4] *= -1;\n\t\t\t\t\t\td[j + 5] *= -1;\n\t\t\t\t\t\td[j + 6] *= -1;\n\t\t\t\t\t\td[j + 7] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprevIndex = index;\n\t\t}\n\t}\n\n\tlet duration = 0;\n\n\tfor (i = 0; i < inputs.length; i++) {\n\t\tdata = inputs[i]._data;\n\t\tduration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);\n\t}\n\n\treturn new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : \"animation_\" + animationIndex, duration, inputs, outputs, curves);\n};\n\nconst createNode = function createNode(gltfNode, nodeIndex) {\n\tconst entity = new GraphNode();\n\n\tif (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {\n\t\tentity.name = gltfNode.name;\n\t} else {\n\t\tentity.name = \"node_\" + nodeIndex;\n\t}\n\n\tif (gltfNode.hasOwnProperty('matrix')) {\n\t\ttempMat.data.set(gltfNode.matrix);\n\t\ttempMat.getTranslation(tempVec$1);\n\t\tentity.setLocalPosition(tempVec$1);\n\t\ttempMat.getEulerAngles(tempVec$1);\n\t\tentity.setLocalEulerAngles(tempVec$1);\n\t\ttempMat.getScale(tempVec$1);\n\t\tentity.setLocalScale(tempVec$1);\n\t}\n\n\tif (gltfNode.hasOwnProperty('rotation')) {\n\t\tconst r = gltfNode.rotation;\n\t\tentity.setLocalRotation(r[0], r[1], r[2], r[3]);\n\t}\n\n\tif (gltfNode.hasOwnProperty('translation')) {\n\t\tconst t = gltfNode.translation;\n\t\tentity.setLocalPosition(t[0], t[1], t[2]);\n\t}\n\n\tif (gltfNode.hasOwnProperty('scale')) {\n\t\tconst s = gltfNode.scale;\n\t\tentity.setLocalScale(s[0], s[1], s[2]);\n\t}\n\n\treturn entity;\n};\n\nconst createCamera = function createCamera(gltfCamera, node) {\n\tconst projection = gltfCamera.type === \"orthographic\" ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;\n\tconst gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;\n\tconst componentData = {\n\t\tenabled: false,\n\t\tprojection: projection,\n\t\tnearClip: gltfProperties.znear,\n\t\taspectRatioMode: ASPECT_AUTO\n\t};\n\n\tif (gltfProperties.zfar) {\n\t\tcomponentData.farClip = gltfProperties.zfar;\n\t}\n\n\tif (projection === PROJECTION_ORTHOGRAPHIC) {\n\t\tcomponentData.orthoHeight = 0.5 * gltfProperties.ymag;\n\n\t\tif (gltfProperties.ymag) {\n\t\t\tcomponentData.aspectRatioMode = ASPECT_MANUAL;\n\t\t\tcomponentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;\n\t\t}\n\t} else {\n\t\tcomponentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;\n\n\t\tif (gltfProperties.aspectRatio) {\n\t\t\tcomponentData.aspectRatioMode = ASPECT_MANUAL;\n\t\t\tcomponentData.aspectRatio = gltfProperties.aspectRatio;\n\t\t}\n\t}\n\n\tconst cameraEntity = new Entity(gltfCamera.name);\n\tcameraEntity.addComponent(\"camera\", componentData);\n\treturn cameraEntity;\n};\n\nconst createLight = function createLight(gltfLight, node) {\n\tconst lightProps = {\n\t\tenabled: false,\n\t\ttype: gltfLight.type === \"point\" ? \"omni\" : gltfLight.type,\n\t\tcolor: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,\n\t\trange: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,\n\t\tfalloffMode: LIGHTFALLOFF_INVERSESQUARED,\n\t\tintensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1\n\t};\n\n\tif (gltfLight.hasOwnProperty('spot')) {\n\t\tlightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;\n\t\tlightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;\n\t}\n\n\tconst lightEntity = new Entity(node.name);\n\tlightEntity.rotateLocal(90, 0, 0);\n\tlightEntity.addComponent(\"light\", lightProps);\n\treturn lightEntity;\n};\n\nconst createSkins = function createSkins(device, gltf, nodes, bufferViews) {\n\tif (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst glbSkins = new Map();\n\treturn gltf.skins.map(function (gltfSkin) {\n\t\treturn createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);\n\t});\n};\n\nconst createMeshes = function createMeshes(device, gltf, bufferViews, callback, flipV) {\n\tif (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 || !gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 || !gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst vertexBufferDict = {};\n\treturn gltf.meshes.map(function (gltfMesh) {\n\t\treturn createMesh(device, gltfMesh, gltf.accessors, bufferViews, callback, flipV, vertexBufferDict);\n\t});\n};\n\nconst createMaterials = function createMaterials(gltf, textures, options, flipV) {\n\tif (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst preprocess = options && options.material && options.material.preprocess;\n\tconst process = options && options.material && options.material.process || createMaterial;\n\tconst postprocess = options && options.material && options.material.postprocess;\n\treturn gltf.materials.map(function (gltfMaterial) {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfMaterial);\n\t\t}\n\n\t\tconst material = process(gltfMaterial, textures, flipV);\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfMaterial, material);\n\t\t}\n\n\t\treturn material;\n\t});\n};\n\nconst createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {\n\tif (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst preprocess = options && options.animation && options.animation.preprocess;\n\tconst postprocess = options && options.animation && options.animation.postprocess;\n\treturn gltf.animations.map(function (gltfAnimation, index) {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfAnimation);\n\t\t}\n\n\t\tconst animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes);\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfAnimation, animation);\n\t\t}\n\n\t\treturn animation;\n\t});\n};\n\nconst createNodes = function createNodes(gltf, options) {\n\tif (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst preprocess = options && options.node && options.node.preprocess;\n\tconst process = options && options.node && options.node.process || createNode;\n\tconst postprocess = options && options.node && options.node.postprocess;\n\tconst nodes = gltf.nodes.map(function (gltfNode, index) {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfNode);\n\t\t}\n\n\t\tconst node = process(gltfNode, index);\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfNode, node);\n\t\t}\n\n\t\treturn node;\n\t});\n\n\tfor (let i = 0; i < gltf.nodes.length; ++i) {\n\t\tconst gltfNode = gltf.nodes[i];\n\n\t\tif (gltfNode.hasOwnProperty('children')) {\n\t\t\tconst parent = nodes[i];\n\t\t\tconst uniqueNames = {};\n\n\t\t\tfor (let j = 0; j < gltfNode.children.length; ++j) {\n\t\t\t\tconst child = nodes[gltfNode.children[j]];\n\n\t\t\t\tif (!child.parent) {\n\t\t\t\t\tif (uniqueNames.hasOwnProperty(child.name)) {\n\t\t\t\t\t\tchild.name += uniqueNames[child.name]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuniqueNames[child.name] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tparent.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\nconst createScenes = function createScenes(gltf, nodes) {\n\tvar _gltf$scenes$0$nodes;\n\n\tconst scenes = [];\n\tconst count = gltf.scenes.length;\n\n\tif (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {\n\t\tconst nodeIndex = gltf.scenes[0].nodes[0];\n\t\tscenes.push(nodes[nodeIndex]);\n\t} else {\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst scene = gltf.scenes[i];\n\n\t\t\tif (scene.nodes) {\n\t\t\t\tconst sceneRoot = new GraphNode(scene.name);\n\n\t\t\t\tfor (let n = 0; n < scene.nodes.length; n++) {\n\t\t\t\t\tconst childNode = nodes[scene.nodes[n]];\n\t\t\t\t\tsceneRoot.addChild(childNode);\n\t\t\t\t}\n\n\t\t\t\tscenes.push(sceneRoot);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn scenes;\n};\n\nconst createCameras = function createCameras(gltf, nodes, options) {\n\tlet cameras = null;\n\n\tif (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {\n\t\tconst preprocess = options && options.camera && options.camera.preprocess;\n\t\tconst process = options && options.camera && options.camera.process || createCamera;\n\t\tconst postprocess = options && options.camera && options.camera.postprocess;\n\t\tgltf.nodes.forEach(function (gltfNode, nodeIndex) {\n\t\t\tif (gltfNode.hasOwnProperty('camera')) {\n\t\t\t\tconst gltfCamera = gltf.cameras[gltfNode.camera];\n\n\t\t\t\tif (gltfCamera) {\n\t\t\t\t\tif (preprocess) {\n\t\t\t\t\t\tpreprocess(gltfCamera);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst camera = process(gltfCamera, nodes[nodeIndex]);\n\n\t\t\t\t\tif (postprocess) {\n\t\t\t\t\t\tpostprocess(gltfCamera, camera);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (camera) {\n\t\t\t\t\t\tif (!cameras) cameras = new Map();\n\t\t\t\t\t\tcameras.set(gltfNode, camera);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn cameras;\n};\n\nconst createLights = function createLights(gltf, nodes, options) {\n\tlet lights = null;\n\n\tif (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {\n\t\tconst gltfLights = gltf.extensions.KHR_lights_punctual.lights;\n\n\t\tif (gltfLights.length) {\n\t\t\tconst preprocess = options && options.light && options.light.preprocess;\n\t\t\tconst process = options && options.light && options.light.process || createLight;\n\t\t\tconst postprocess = options && options.light && options.light.postprocess;\n\t\t\tgltf.nodes.forEach(function (gltfNode, nodeIndex) {\n\t\t\t\tif (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {\n\t\t\t\t\tconst lightIndex = gltfNode.extensions.KHR_lights_punctual.light;\n\t\t\t\t\tconst gltfLight = gltfLights[lightIndex];\n\n\t\t\t\t\tif (gltfLight) {\n\t\t\t\t\t\tif (preprocess) {\n\t\t\t\t\t\t\tpreprocess(gltfLight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst light = process(gltfLight, nodes[nodeIndex]);\n\n\t\t\t\t\t\tif (postprocess) {\n\t\t\t\t\t\t\tpostprocess(gltfLight, light);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (light) {\n\t\t\t\t\t\t\tif (!lights) lights = new Map();\n\t\t\t\t\t\t\tlights.set(gltfNode, light);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\treturn lights;\n};\n\nconst linkSkins = function linkSkins(gltf, renders, skins) {\n\tgltf.nodes.forEach(gltfNode => {\n\t\tif (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {\n\t\t\tconst meshGroup = renders[gltfNode.mesh].meshes;\n\t\t\tmeshGroup.forEach(mesh => {\n\t\t\t\tmesh.skin = skins[gltfNode.skin];\n\t\t\t});\n\t\t}\n\t});\n};\n\nconst createResources = function createResources(device, gltf, bufferViews, textureAssets, options, callback) {\n\tconst preprocess = options && options.global && options.global.preprocess;\n\tconst postprocess = options && options.global && options.global.postprocess;\n\n\tif (preprocess) {\n\t\tpreprocess(gltf);\n\t}\n\n\tconst flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';\n\tconst nodes = createNodes(gltf, options);\n\tconst scenes = createScenes(gltf, nodes);\n\tconst lights = createLights(gltf, nodes, options);\n\tconst cameras = createCameras(gltf, nodes, options);\n\tconst animations = createAnimations(gltf, nodes, bufferViews, options);\n\tconst materials = createMaterials(gltf, textureAssets.map(function (textureAsset) {\n\t\treturn textureAsset.resource;\n\t}), options, flipV);\n\tconst meshes = createMeshes(device, gltf, bufferViews, callback, flipV);\n\tconst skins = createSkins(device, gltf, nodes, bufferViews);\n\tconst renders = [];\n\n\tfor (let i = 0; i < meshes.length; i++) {\n\t\trenders[i] = new Render();\n\t\trenders[i].meshes = meshes[i];\n\t}\n\n\tlinkSkins(gltf, renders, skins);\n\tconst result = new GlbResources(gltf);\n\tresult.nodes = nodes;\n\tresult.scenes = scenes;\n\tresult.animations = animations;\n\tresult.textures = textureAssets;\n\tresult.materials = materials;\n\tresult.renders = renders;\n\tresult.skins = skins;\n\tresult.lights = lights;\n\tresult.cameras = cameras;\n\n\tif (postprocess) {\n\t\tpostprocess(gltf, result);\n\t}\n\n\tcallback(null, result);\n};\n\nconst applySampler = function applySampler(texture, gltfSampler) {\n\tconst getFilter = function getFilter(filter, defaultValue) {\n\t\tswitch (filter) {\n\t\t\tcase 9728:\n\t\t\t\treturn FILTER_NEAREST;\n\n\t\t\tcase 9729:\n\t\t\t\treturn FILTER_LINEAR;\n\n\t\t\tcase 9984:\n\t\t\t\treturn FILTER_NEAREST_MIPMAP_NEAREST;\n\n\t\t\tcase 9985:\n\t\t\t\treturn FILTER_LINEAR_MIPMAP_NEAREST;\n\n\t\t\tcase 9986:\n\t\t\t\treturn FILTER_NEAREST_MIPMAP_LINEAR;\n\n\t\t\tcase 9987:\n\t\t\t\treturn FILTER_LINEAR_MIPMAP_LINEAR;\n\n\t\t\tdefault:\n\t\t\t\treturn defaultValue;\n\t\t}\n\t};\n\n\tconst getWrap = function getWrap(wrap, defaultValue) {\n\t\tswitch (wrap) {\n\t\t\tcase 33071:\n\t\t\t\treturn ADDRESS_CLAMP_TO_EDGE;\n\n\t\t\tcase 33648:\n\t\t\t\treturn ADDRESS_MIRRORED_REPEAT;\n\n\t\t\tcase 10497:\n\t\t\t\treturn ADDRESS_REPEAT;\n\n\t\t\tdefault:\n\t\t\t\treturn defaultValue;\n\t\t}\n\t};\n\n\tif (texture) {\n\t\tgltfSampler = gltfSampler || {};\n\t\ttexture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);\n\t\ttexture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);\n\t\ttexture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);\n\t\ttexture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);\n\t}\n};\n\nlet gltfTextureUniqueId = 0;\n\nconst loadImageAsync = function loadImageAsync(gltfImage, index, bufferViews, urlBase, registry, options, callback) {\n\tconst preprocess = options && options.image && options.image.preprocess;\n\n\tconst processAsync = options && options.image && options.image.processAsync || function (gltfImage, callback) {\n\t\tcallback(null, null);\n\t};\n\n\tconst postprocess = options && options.image && options.image.postprocess;\n\n\tconst onLoad = function onLoad(textureAsset) {\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfImage, textureAsset);\n\t\t}\n\n\t\tcallback(null, textureAsset);\n\t};\n\n\tconst mimeTypeFileExtensions = {\n\t\t'image/png': 'png',\n\t\t'image/jpeg': 'jpg',\n\t\t'image/basis': 'basis',\n\t\t'image/ktx': 'ktx',\n\t\t'image/ktx2': 'ktx2',\n\t\t'image/vnd-ms.dds': 'dds'\n\t};\n\n\tconst loadTexture = function loadTexture(url, bufferView, mimeType, options) {\n\t\tconst name = (gltfImage.name || 'gltf-texture') + '-' + gltfTextureUniqueId++;\n\t\tconst file = {\n\t\t\turl: url || name\n\t\t};\n\n\t\tif (bufferView) {\n\t\t\tfile.contents = bufferView.slice(0).buffer;\n\t\t}\n\n\t\tif (mimeType) {\n\t\t\tconst extension = mimeTypeFileExtensions[mimeType];\n\n\t\t\tif (extension) {\n\t\t\t\tfile.filename = file.url + '.' + extension;\n\t\t\t}\n\t\t}\n\n\t\tconst asset = new Asset(name, 'texture', file, null, options);\n\t\tasset.on('load', onLoad);\n\t\tasset.on('error', callback);\n\t\tregistry.add(asset);\n\t\tregistry.load(asset);\n\t};\n\n\tif (preprocess) {\n\t\tpreprocess(gltfImage);\n\t}\n\n\tprocessAsync(gltfImage, function (err, textureAsset) {\n\t\tif (err) {\n\t\t\tcallback(err);\n\t\t} else if (textureAsset) {\n\t\t\tonLoad(textureAsset);\n\t\t} else {\n\t\t\tif (gltfImage.hasOwnProperty('uri')) {\n\t\t\t\tif (isDataURI(gltfImage.uri)) {\n\t\t\t\t\tloadTexture(gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);\n\t\t\t\t} else {\n\t\t\t\t\tloadTexture(path.join(urlBase, gltfImage.uri), null, null, {\n\t\t\t\t\t\tcrossOrigin: \"anonymous\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {\n\t\t\t\tloadTexture(null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);\n\t\t\t} else {\n\t\t\t\tcallback(\"Invalid image found in gltf (neither uri or bufferView found). index=\" + index);\n\t\t\t}\n\t\t}\n\t});\n};\n\nconst loadTexturesAsync = function loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, callback) {\n\tif (!gltf.hasOwnProperty('images') || gltf.images.length === 0 || !gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {\n\t\tcallback(null, []);\n\t\treturn;\n\t}\n\n\tconst preprocess = options && options.texture && options.texture.preprocess;\n\n\tconst processAsync = options && options.texture && options.texture.processAsync || function (gltfTexture, gltfImages, callback) {\n\t\tcallback(null, null);\n\t};\n\n\tconst postprocess = options && options.texture && options.texture.postprocess;\n\tconst assets = [];\n\tconst textures = [];\n\tlet remaining = gltf.textures.length;\n\n\tconst onLoad = function onLoad(textureIndex, imageIndex) {\n\t\tif (!textures[imageIndex]) {\n\t\t\ttextures[imageIndex] = [];\n\t\t}\n\n\t\ttextures[imageIndex].push(textureIndex);\n\n\t\tif (--remaining === 0) {\n\t\t\tconst result = [];\n\t\t\ttextures.forEach(function (textureList, imageIndex) {\n\t\t\t\ttextureList.forEach(function (textureIndex, index) {\n\t\t\t\t\tconst textureAsset = index === 0 ? assets[imageIndex] : cloneTextureAsset(assets[imageIndex]);\n\t\t\t\t\tapplySampler(textureAsset.resource, (gltf.samplers || [])[gltf.textures[textureIndex].sampler]);\n\t\t\t\t\tresult[textureIndex] = textureAsset;\n\n\t\t\t\t\tif (postprocess) {\n\t\t\t\t\t\tpostprocess(gltf.textures[textureIndex], textureAsset);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tcallback(null, result);\n\t\t}\n\t};\n\n\tfor (let i = 0; i < gltf.textures.length; ++i) {\n\t\tconst gltfTexture = gltf.textures[i];\n\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfTexture);\n\t\t}\n\n\t\tprocessAsync(gltfTexture, gltf.images, function (i, gltfTexture, err, gltfImageIndex) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tif (gltfImageIndex === undefined || gltfImageIndex === null) {\n\t\t\t\t\tvar _gltfTexture$extensio, _gltfTexture$extensio2;\n\n\t\t\t\t\tgltfImageIndex = gltfTexture == null ? void 0 : (_gltfTexture$extensio = gltfTexture.extensions) == null ? void 0 : (_gltfTexture$extensio2 = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio2.source;\n\n\t\t\t\t\tif (gltfImageIndex === undefined) {\n\t\t\t\t\t\tgltfImageIndex = gltfTexture.source;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (assets[gltfImageIndex]) {\n\t\t\t\t\tonLoad(i, gltfImageIndex);\n\t\t\t\t} else {\n\t\t\t\t\tconst gltfImage = gltf.images[gltfImageIndex];\n\t\t\t\t\tloadImageAsync(gltfImage, i, bufferViews, urlBase, registry, options, function (err, textureAsset) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassets[gltfImageIndex] = textureAsset;\n\t\t\t\t\t\t\tonLoad(i, gltfImageIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(null, i, gltfTexture));\n\t}\n};\n\nconst loadBuffersAsync = function loadBuffersAsync(gltf, binaryChunk, urlBase, options, callback) {\n\tconst result = [];\n\n\tif (!gltf.buffers || gltf.buffers.length === 0) {\n\t\tcallback(null, result);\n\t\treturn;\n\t}\n\n\tconst preprocess = options && options.buffer && options.buffer.preprocess;\n\n\tconst processAsync = options && options.buffer && options.buffer.processAsync || function (gltfBuffer, callback) {\n\t\tcallback(null, null);\n\t};\n\n\tconst postprocess = options && options.buffer && options.buffer.postprocess;\n\tlet remaining = gltf.buffers.length;\n\n\tconst onLoad = function onLoad(index, buffer) {\n\t\tresult[index] = buffer;\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltf.buffers[index], buffer);\n\t\t}\n\n\t\tif (--remaining === 0) {\n\t\t\tcallback(null, result);\n\t\t}\n\t};\n\n\tfor (let i = 0; i < gltf.buffers.length; ++i) {\n\t\tconst gltfBuffer = gltf.buffers[i];\n\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfBuffer);\n\t\t}\n\n\t\tprocessAsync(gltfBuffer, function (i, gltfBuffer, err, arrayBuffer) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else if (arrayBuffer) {\n\t\t\t\tonLoad(i, new Uint8Array(arrayBuffer));\n\t\t\t} else {\n\t\t\t\tif (gltfBuffer.hasOwnProperty('uri')) {\n\t\t\t\t\tif (isDataURI(gltfBuffer.uri)) {\n\t\t\t\t\t\tconst byteString = atob(gltfBuffer.uri.split(',')[1]);\n\t\t\t\t\t\tconst binaryArray = new Uint8Array(byteString.length);\n\n\t\t\t\t\t\tfor (let j = 0; j < byteString.length; j++) {\n\t\t\t\t\t\t\tbinaryArray[j] = byteString.charCodeAt(j);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tonLoad(i, binaryArray);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thttp.get(path.join(urlBase, gltfBuffer.uri), {\n\t\t\t\t\t\t\tcache: true,\n\t\t\t\t\t\t\tresponseType: 'arraybuffer',\n\t\t\t\t\t\t\tretry: false\n\t\t\t\t\t\t}, function (i, err, result) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tonLoad(i, new Uint8Array(result));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.bind(null, i));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tonLoad(i, binaryChunk);\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(null, i, gltfBuffer));\n\t}\n};\n\nconst parseGltf = function parseGltf(gltfChunk, callback) {\n\tconst decodeBinaryUtf8 = function decodeBinaryUtf8(array) {\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\treturn new TextDecoder().decode(array);\n\t\t}\n\n\t\tlet str = \"\";\n\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tstr += String.fromCharCode(array[i]);\n\t\t}\n\n\t\treturn decodeURIComponent(escape(str));\n\t};\n\n\tconst gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));\n\n\tif (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {\n\t\tcallback(`Invalid gltf version. Expected version 2.0 or above but found version '${gltf.asset.version}'.`);\n\t\treturn;\n\t}\n\n\tcallback(null, gltf);\n};\n\nconst parseGlb = function parseGlb(glbData, callback) {\n\tconst data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);\n\tconst magic = data.getUint32(0, true);\n\tconst version = data.getUint32(4, true);\n\tconst length = data.getUint32(8, true);\n\n\tif (magic !== 0x46546C67) {\n\t\tcallback(\"Invalid magic number found in glb header. Expected 0x46546C67, found 0x\" + magic.toString(16));\n\t\treturn;\n\t}\n\n\tif (version !== 2) {\n\t\tcallback(\"Invalid version number found in glb header. Expected 2, found \" + version);\n\t\treturn;\n\t}\n\n\tif (length <= 0 || length > data.byteLength) {\n\t\tcallback(\"Invalid length found in glb header. Found \" + length);\n\t\treturn;\n\t}\n\n\tconst chunks = [];\n\tlet offset = 12;\n\n\twhile (offset < length) {\n\t\tconst chunkLength = data.getUint32(offset, true);\n\n\t\tif (offset + chunkLength + 8 > data.byteLength) {\n\t\t\tthrow new Error(\"Invalid chunk length found in glb. Found \" + chunkLength);\n\t\t}\n\n\t\tconst chunkType = data.getUint32(offset + 4, true);\n\t\tconst chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);\n\t\tchunks.push({\n\t\t\tlength: chunkLength,\n\t\t\ttype: chunkType,\n\t\t\tdata: chunkData\n\t\t});\n\t\toffset += chunkLength + 8;\n\t}\n\n\tif (chunks.length !== 1 && chunks.length !== 2) {\n\t\tcallback(\"Invalid number of chunks found in glb file.\");\n\t\treturn;\n\t}\n\n\tif (chunks[0].type !== 0x4E4F534A) {\n\t\tcallback(\"Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x\" + chunks[0].type.toString(16));\n\t\treturn;\n\t}\n\n\tif (chunks.length > 1 && chunks[1].type !== 0x004E4942) {\n\t\tcallback(\"Invalid chunk type found in glb file. Expected 0x004E4942, found 0x\" + chunks[1].type.toString(16));\n\t\treturn;\n\t}\n\n\tcallback(null, {\n\t\tgltfChunk: chunks[0].data,\n\t\tbinaryChunk: chunks.length === 2 ? chunks[1].data : null\n\t});\n};\n\nconst parseChunk = function parseChunk(filename, data, callback) {\n\tif (filename && filename.toLowerCase().endsWith('.glb')) {\n\t\tparseGlb(data, callback);\n\t} else {\n\t\tcallback(null, {\n\t\t\tgltfChunk: data,\n\t\t\tbinaryChunk: null\n\t\t});\n\t}\n};\n\nconst parseBufferViewsAsync = function parseBufferViewsAsync(gltf, buffers, options, callback) {\n\tconst result = [];\n\tconst preprocess = options && options.bufferView && options.bufferView.preprocess;\n\n\tconst processAsync = options && options.bufferView && options.bufferView.processAsync || function (gltfBufferView, buffers, callback) {\n\t\tcallback(null, null);\n\t};\n\n\tconst postprocess = options && options.bufferView && options.bufferView.postprocess;\n\tlet remaining = gltf.bufferViews ? gltf.bufferViews.length : 0;\n\n\tif (!remaining) {\n\t\tcallback(null, null);\n\t\treturn;\n\t}\n\n\tconst onLoad = function onLoad(index, bufferView) {\n\t\tconst gltfBufferView = gltf.bufferViews[index];\n\n\t\tif (gltfBufferView.hasOwnProperty('byteStride')) {\n\t\t\tbufferView.byteStride = gltfBufferView.byteStride;\n\t\t}\n\n\t\tresult[index] = bufferView;\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfBufferView, bufferView);\n\t\t}\n\n\t\tif (--remaining === 0) {\n\t\t\tcallback(null, result);\n\t\t}\n\t};\n\n\tfor (let i = 0; i < gltf.bufferViews.length; ++i) {\n\t\tconst gltfBufferView = gltf.bufferViews[i];\n\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfBufferView);\n\t\t}\n\n\t\tprocessAsync(gltfBufferView, buffers, function (i, gltfBufferView, err, result) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else if (result) {\n\t\t\t\tonLoad(i, result);\n\t\t\t} else {\n\t\t\t\tconst buffer = buffers[gltfBufferView.buffer];\n\t\t\t\tconst typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);\n\t\t\t\tonLoad(i, typedArray);\n\t\t\t}\n\t\t}.bind(null, i, gltfBufferView));\n\t}\n};\n\nclass GlbParser {\n\tstatic parseAsync(filename, urlBase, data, device, registry, options, callback) {\n\t\tparseChunk(filename, data, function (err, chunks) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tparseGltf(chunks.gltfChunk, function (err, gltf) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tloadBuffersAsync(gltf, chunks.binaryChunk, urlBase, options, function (err, buffers) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tparseBufferViewsAsync(gltf, buffers, options, function (err, bufferViews) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadTexturesAsync(gltf, bufferViews, urlBase, registry, options, function (err, textureAssets) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcreateResources(device, gltf, bufferViews, textureAssets, options, callback);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tstatic parse(filename, data, device, options) {\n\t\tlet result = null;\n\t\toptions = options || {};\n\t\tparseChunk(filename, data, function (err, chunks) {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t} else {\n\t\t\t\tparseGltf(chunks.gltfChunk, function (err, gltf) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparseBufferViewsAsync(gltf, [chunks.binaryChunk], options, function (err, bufferViews) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcreateResources(device, gltf, bufferViews, [], options, function (err, result_) {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tresult = result_;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n\n\tconstructor(device, assets, maxRetries) {\n\t\tthis._device = device;\n\t\tthis._assets = assets;\n\t\tthis._defaultMaterial = DefaultMaterial.get(device);\n\t\tthis._maxRetries = maxRetries;\n\t}\n\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tGlbParser.parseAsync(this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(null, new GlbContainerResource(result, asset, this._assets, this._defaultMaterial));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, asset, this._maxRetries);\n\t}\n\n\topen(url, data, asset) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass AnimationHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:') || url.load.startsWith('data:')) {\n\t\t\tif (path.getExtension(url.original).toLowerCase() === '.glb') {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t} else {\n\t\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t\t}\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tcallback(null, response);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\tif (path.getExtension(url).toLowerCase() === '.glb') {\n\t\t\tconst glbResources = GlbParser.parse(\"filename.glb\", data, null);\n\n\t\t\tif (glbResources) {\n\t\t\t\tconst animations = glbResources.animations;\n\t\t\t\tglbResources.destroy();\n\t\t\t\treturn animations;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[\"_parseAnimationV\" + data.animation.version](data);\n\t}\n\n\tpatch(asset, assets) {}\n\n\t_parseAnimationV3(data) {\n\t\tconst animData = data.animation;\n\t\tconst anim = new Animation();\n\t\tanim.name = animData.name;\n\t\tanim.duration = animData.duration;\n\n\t\tfor (let i = 0; i < animData.nodes.length; i++) {\n\t\t\tconst node = new Node();\n\t\t\tconst n = animData.nodes[i];\n\t\t\tnode._name = n.name;\n\n\t\t\tfor (let j = 0; j < n.keys.length; j++) {\n\t\t\t\tconst k = n.keys[j];\n\t\t\t\tconst t = k.time;\n\t\t\t\tconst p = k.pos;\n\t\t\t\tconst r = k.rot;\n\t\t\t\tconst s = k.scale;\n\t\t\t\tconst pos = new Vec3(p[0], p[1], p[2]);\n\t\t\t\tconst rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);\n\t\t\t\tconst scl = new Vec3(s[0], s[1], s[2]);\n\t\t\t\tconst key = new Key(t, pos, rot, scl);\n\n\t\t\t\tnode._keys.push(key);\n\t\t\t}\n\n\t\t\tanim.addNode(node);\n\t\t}\n\n\t\treturn anim;\n\t}\n\n\t_parseAnimationV4(data) {\n\t\tconst animData = data.animation;\n\t\tconst anim = new Animation();\n\t\tanim.name = animData.name;\n\t\tanim.duration = animData.duration;\n\n\t\tfor (let i = 0; i < animData.nodes.length; i++) {\n\t\t\tconst node = new Node();\n\t\t\tconst n = animData.nodes[i];\n\t\t\tnode._name = n.name;\n\t\t\tconst defPos = n.defaults.p;\n\t\t\tconst defRot = n.defaults.r;\n\t\t\tconst defScl = n.defaults.s;\n\n\t\t\tfor (let j = 0; j < n.keys.length; j++) {\n\t\t\t\tconst k = n.keys[j];\n\t\t\t\tconst t = k.t;\n\t\t\t\tconst p = defPos ? defPos : k.p;\n\t\t\t\tconst r = defRot ? defRot : k.r;\n\t\t\t\tconst s = defScl ? defScl : k.s;\n\t\t\t\tconst pos = new Vec3(p[0], p[1], p[2]);\n\t\t\t\tconst rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);\n\t\t\t\tconst scl = new Vec3(s[0], s[1], s[2]);\n\t\t\t\tconst key = new Key(t, pos, rot, scl);\n\n\t\t\t\tnode._keys.push(key);\n\t\t\t}\n\n\t\t\tanim.addNode(node);\n\t\t}\n\n\t\treturn anim;\n\t}\n\n}\n\nclass AnimClipHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation clip resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tcallback(null, response);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\tconst name = data.name;\n\t\tconst duration = data.duration;\n\t\tconst inputs = data.inputs.map(function (input) {\n\t\t\treturn new AnimData(1, input);\n\t\t});\n\t\tconst outputs = data.outputs.map(function (output) {\n\t\t\treturn new AnimData(output.components, output.data);\n\t\t});\n\t\tconst curves = data.curves.map(function (curve) {\n\t\t\treturn new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);\n\t\t});\n\t\treturn new AnimTrack(name, duration, inputs, outputs, curves);\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass AnimStateGraph {\n\tconstructor(data) {\n\t\tthis._layers = [];\n\t\tthis._parameters = {};\n\n\t\tif (!Array.isArray(data.layers)) {\n\t\t\tfor (const layerId in data.layers) {\n\t\t\t\tconst dataLayer = data.layers[layerId];\n\t\t\t\tconst layer = {\n\t\t\t\t\tname: dataLayer.name,\n\t\t\t\t\tblendType: dataLayer.blendType,\n\t\t\t\t\tweight: dataLayer.weight,\n\t\t\t\t\tstates: [],\n\t\t\t\t\ttransitions: []\n\t\t\t\t};\n\n\t\t\t\tfor (let i = 0; i < dataLayer.states.length; i++) {\n\t\t\t\t\tlayer.states.push(data.states[dataLayer.states[i]]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < dataLayer.transitions.length; i++) {\n\t\t\t\t\tconst dataLayerTransition = data.transitions[dataLayer.transitions[i]];\n\n\t\t\t\t\tif (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {\n\t\t\t\t\t\tconst conditionKeys = Object.keys(dataLayerTransition.conditions);\n\t\t\t\t\t\tconst conditions = [];\n\n\t\t\t\t\t\tfor (let j = 0; j < conditionKeys.length; j++) {\n\t\t\t\t\t\t\tconst condition = dataLayerTransition.conditions[conditionKeys[j]];\n\n\t\t\t\t\t\t\tif (condition.parameterName) {\n\t\t\t\t\t\t\t\tconditions.push(condition);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataLayerTransition.conditions = conditions;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Number.isInteger(dataLayerTransition.from)) {\n\t\t\t\t\t\tdataLayerTransition.from = data.states[dataLayerTransition.from].name;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Number.isInteger(dataLayerTransition.to)) {\n\t\t\t\t\t\tdataLayerTransition.to = data.states[dataLayerTransition.to].name;\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer.transitions.push(dataLayerTransition);\n\t\t\t\t}\n\n\t\t\t\tthis._layers.push(layer);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._layers = data.layers;\n\t\t}\n\n\t\tfor (const paramId in data.parameters) {\n\t\t\tconst param = data.parameters[paramId];\n\t\t\tthis._parameters[param.name] = {\n\t\t\t\ttype: param.type,\n\t\t\t\tvalue: param.value\n\t\t\t};\n\t\t}\n\t}\n\n\tget parameters() {\n\t\treturn Object.assign({}, this._parameters);\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n}\n\nclass AnimStateGraphHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation state graph resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tcallback(null, response);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn new AnimStateGraph(data);\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass Sound {\n\tconstructor(resource) {\n\t\tif (resource instanceof Audio) {\n\t\t\tthis.audio = resource;\n\t\t} else {\n\t\t\tthis.buffer = resource;\n\t\t}\n\t}\n\n\tget duration() {\n\t\tlet duration = 0;\n\n\t\tif (this.buffer) {\n\t\t\tduration = this.buffer.duration;\n\t\t} else if (this.audio) {\n\t\t\tduration = this.audio.duration;\n\t\t}\n\n\t\treturn duration || 0;\n\t}\n\n}\n\nconst ie = function () {\n\tif (typeof window === 'undefined') {\n\t\treturn false;\n\t}\n\n\tconst ua = window.navigator.userAgent;\n\tconst msie = ua.indexOf('MSIE ');\n\n\tif (msie > 0) {\n\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t}\n\n\tconst trident = ua.indexOf('Trident/');\n\n\tif (trident > 0) {\n\t\tconst rv = ua.indexOf('rv:');\n\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t}\n\n\treturn false;\n}();\n\nconst toMIME = {\n\t'.ogg': 'audio/ogg',\n\t'.mp3': 'audio/mpeg',\n\t'.wav': 'audio/x-wav',\n\t'.mp4a': 'audio/mp4',\n\t'.m4a': 'audio/mp4',\n\t'.mp4': 'audio/mp4',\n\t'.aac': 'audio/aac'\n};\n\nclass AudioHandler {\n\tconstructor(manager) {\n\t\tthis.manager = manager;\n\t\tthis.maxRetries = 0;\n\t}\n\n\t_isSupported(url) {\n\t\tconst ext = path.getExtension(url);\n\n\t\tif (toMIME[ext]) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst success = function success(resource) {\n\t\t\tcallback(null, new Sound(resource));\n\t\t};\n\n\t\tconst error = function error(err) {\n\t\t\tlet msg = 'Error loading audio url: ' + url.original;\n\n\t\t\tif (err) {\n\t\t\t\tmsg += ': ' + (err.message || err);\n\t\t\t}\n\n\t\t\tconsole.warn(msg);\n\t\t\tcallback(msg);\n\t\t};\n\n\t\tif (this._createSound) {\n\t\t\tif (!this._isSupported(url.original)) {\n\t\t\t\terror(`Audio format for ${url.original} not supported`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._createSound(url.load, success, error);\n\t\t} else {\n\t\t\terror(null);\n\t\t}\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n\t_createSound(url, success, error) {\n\t\tif (hasAudioContext()) {\n\t\t\tconst manager = this.manager;\n\n\t\t\tif (!manager.context) {\n\t\t\t\terror('Audio manager has no audio context');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst options = {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t};\n\n\t\t\tif (url.startsWith('blob:') || url.startsWith('data:')) {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t}\n\n\t\t\thttp.get(url, options, function (err, response) {\n\t\t\t\tif (err) {\n\t\t\t\t\terror(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmanager.context.decodeAudioData(response, success, error);\n\t\t\t});\n\t\t} else {\n\t\t\tlet audio = null;\n\n\t\t\ttry {\n\t\t\t\taudio = new Audio();\n\t\t\t} catch (e) {\n\t\t\t\terror(\"No support for Audio element\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ie) {\n\t\t\t\tdocument.body.appendChild(audio);\n\t\t\t}\n\n\t\t\tconst onReady = function onReady() {\n\t\t\t\taudio.removeEventListener('canplaythrough', onReady);\n\n\t\t\t\tif (ie) {\n\t\t\t\t\tdocument.body.removeChild(audio);\n\t\t\t\t}\n\n\t\t\t\tsuccess(audio);\n\t\t\t};\n\n\t\t\taudio.onerror = function () {\n\t\t\t\taudio.onerror = null;\n\n\t\t\t\tif (ie) {\n\t\t\t\t\tdocument.body.removeChild(audio);\n\t\t\t\t}\n\n\t\t\t\terror();\n\t\t\t};\n\n\t\t\taudio.addEventListener('canplaythrough', onReady);\n\t\t\taudio.src = url;\n\t\t}\n\t}\n\n}\n\nclass BinaryHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tresponseType: Http.ResponseType.ARRAY_BUFFER,\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading binary resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass Bundle {\n\tconstructor(files) {\n\t\tthis._blobUrls = {};\n\n\t\tfor (let i = 0, len = files.length; i < len; i++) {\n\t\t\tif (files[i].url) {\n\t\t\t\tthis._blobUrls[files[i].name] = files[i].url;\n\t\t\t}\n\t\t}\n\t}\n\n\thasBlobUrl(url) {\n\t\treturn !!this._blobUrls[url];\n\t}\n\n\tgetBlobUrl(url) {\n\t\treturn this._blobUrls[url];\n\t}\n\n\tdestroy() {\n\t\tfor (const key in this._blobUrls) {\n\t\t\tURL.revokeObjectURL(this._blobUrls[key]);\n\t\t}\n\n\t\tthis._blobUrls = null;\n\t}\n\n}\n\nlet Untar;\n\nfunction UntarScope(isWorker) {\n\tlet utfDecoder;\n\tlet asciiDecoder;\n\n\tif (typeof TextDecoder !== 'undefined') {\n\t\ttry {\n\t\t\tutfDecoder = new TextDecoder('utf-8');\n\t\t\tasciiDecoder = new TextDecoder('windows-1252');\n\t\t} catch (e) {\n\t\t\tconsole.warn('TextDecoder not supported - pc.Untar module will not work');\n\t\t}\n\t} else {\n\t\tconsole.warn('TextDecoder not supported - pc.Untar module will not work');\n\t}\n\n\tfunction PaxHeader(fields) {\n\t\tthis._fields = fields;\n\t}\n\n\tPaxHeader.parse = function (buffer, start, length) {\n\t\tconst paxArray = new Uint8Array(buffer, start, length);\n\t\tlet bytesRead = 0;\n\t\tconst fields = [];\n\n\t\twhile (bytesRead < length) {\n\t\t\tlet spaceIndex;\n\n\t\t\tfor (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {\n\t\t\t\tif (paxArray[spaceIndex] === 0x20) break;\n\t\t\t}\n\n\t\t\tif (spaceIndex >= length) {\n\t\t\t\tthrow new Error('Invalid PAX header data format.');\n\t\t\t}\n\n\t\t\tconst fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);\n\t\t\tconst fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));\n\t\t\tconst field = fieldText.split('=');\n\n\t\t\tif (field.length !== 2) {\n\t\t\t\tthrow new Error('Invalid PAX header data format.');\n\t\t\t}\n\n\t\t\tif (field[1].length === 0) {\n\t\t\t\tfield[1] = null;\n\t\t\t}\n\n\t\t\tfields.push({\n\t\t\t\tname: field[0],\n\t\t\t\tvalue: field[1]\n\t\t\t});\n\t\t\tbytesRead += fieldLength;\n\t\t}\n\n\t\treturn new PaxHeader(fields);\n\t};\n\n\tPaxHeader.prototype.applyHeader = function (file) {\n\t\tfor (let i = 0; i < this._fields.length; i++) {\n\t\t\tlet fieldName = this._fields[i].name;\n\t\t\tconst fieldValue = this._fields[i].value;\n\n\t\t\tif (fieldName === 'path') {\n\t\t\t\tfieldName = 'name';\n\t\t\t}\n\n\t\t\tif (fieldValue === null) {\n\t\t\t\tdelete file[fieldName];\n\t\t\t} else {\n\t\t\t\tfile[fieldName] = fieldValue;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction UntarInternal(arrayBuffer) {\n\t\tthis._arrayBuffer = arrayBuffer || new ArrayBuffer(0);\n\t\tthis._bufferView = new DataView(this._arrayBuffer);\n\t\tthis._globalPaxHeader = null;\n\t\tthis._paxHeader = null;\n\t\tthis._bytesRead = 0;\n\t}\n\n\tif (!isWorker) {\n\t\tUntar = UntarInternal;\n\t}\n\n\tUntarInternal.prototype._hasNext = function () {\n\t\treturn this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;\n\t};\n\n\tUntarInternal.prototype._readNextFile = function () {\n\t\tconst headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);\n\t\tconst headers = asciiDecoder.decode(headersDataView);\n\t\tthis._bytesRead += 512;\n\t\tlet name = headers.substr(0, 100).replace(/\\0/g, '');\n\t\tconst ustarFormat = headers.substr(257, 6);\n\t\tconst size = parseInt(headers.substr(124, 12), 8);\n\t\tconst type = headers.substr(156, 1);\n\t\tconst start = this._bytesRead;\n\t\tlet url = null;\n\t\tlet normalFile = false;\n\n\t\tswitch (type) {\n\t\t\tcase \"0\":\n\t\t\tcase \"\":\n\t\t\t\tnormalFile = true;\n\n\t\t\t\tif (!isWorker) {\n\t\t\t\t\tconst blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);\n\t\t\t\t\turl = URL.createObjectURL(blob);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"g\":\n\t\t\t\tthis._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);\n\t\t\t\tbreak;\n\n\t\t\tcase \"x\":\n\t\t\t\tthis._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tthis._bytesRead += size;\n\t\tconst remainder = size % 512;\n\n\t\tif (remainder !== 0) {\n\t\t\tthis._bytesRead += 512 - remainder;\n\t\t}\n\n\t\tif (!normalFile) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (ustarFormat.indexOf(\"ustar\") !== -1) {\n\t\t\tconst namePrefix = headers.substr(345, 155).replace(/\\0/g, '');\n\n\t\t\tif (namePrefix.length > 0) {\n\t\t\t\tname = namePrefix.trim() + name.trim();\n\t\t\t}\n\t\t}\n\n\t\tconst file = {\n\t\t\tname: name,\n\t\t\tstart: start,\n\t\t\tsize: size,\n\t\t\turl: url\n\t\t};\n\n\t\tif (this._globalPaxHeader) {\n\t\t\tthis._globalPaxHeader.applyHeader(file);\n\t\t}\n\n\t\tif (this._paxHeader) {\n\t\t\tthis._paxHeader.applyHeader(file);\n\n\t\t\tthis._paxHeader = null;\n\t\t}\n\n\t\treturn file;\n\t};\n\n\tUntarInternal.prototype.untar = function (filenamePrefix) {\n\t\tif (!utfDecoder) {\n\t\t\tconsole.error('Cannot untar because TextDecoder interface is not available for this platform.');\n\t\t\treturn [];\n\t\t}\n\n\t\tconst files = [];\n\n\t\twhile (this._hasNext()) {\n\t\t\tconst file = this._readNextFile();\n\n\t\t\tif (!file) continue;\n\n\t\t\tif (filenamePrefix && file.name) {\n\t\t\t\tfile.name = filenamePrefix + file.name;\n\t\t\t}\n\n\t\t\tfiles.push(file);\n\t\t}\n\n\t\treturn files;\n\t};\n\n\tif (isWorker) {\n\t\tself.onmessage = function (e) {\n\t\t\tconst id = e.data.id;\n\n\t\t\ttry {\n\t\t\t\tconst archive = new UntarInternal(e.data.arrayBuffer);\n\t\t\t\tconst files = archive.untar(e.data.prefix);\n\t\t\t\tpostMessage({\n\t\t\t\t\tid: id,\n\t\t\t\t\tfiles: files,\n\t\t\t\t\tarrayBuffer: e.data.arrayBuffer\n\t\t\t\t}, [e.data.arrayBuffer]);\n\t\t\t} catch (err) {\n\t\t\t\tpostMessage({\n\t\t\t\t\tid: id,\n\t\t\t\t\terror: err.toString()\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n}\n\nlet workerUrl = null;\n\nfunction getWorkerUrl() {\n\tif (!workerUrl) {\n\t\tconst code = '(' + UntarScope.toString() + ')(true)\\n\\n';\n\t\tconst blob = new Blob([code], {\n\t\t\ttype: 'application/javascript'\n\t\t});\n\t\tworkerUrl = URL.createObjectURL(blob);\n\t}\n\n\treturn workerUrl;\n}\n\nclass UntarWorker {\n\tconstructor(filenamePrefix) {\n\t\tthis._requestId = 0;\n\t\tthis._pendingRequests = {};\n\t\tthis._filenamePrefix = filenamePrefix;\n\t\tthis._worker = new Worker(getWorkerUrl());\n\n\t\tthis._worker.addEventListener('message', this._onMessage.bind(this));\n\t}\n\n\t_onMessage(e) {\n\t\tconst id = e.data.id;\n\t\tif (!this._pendingRequests[id]) return;\n\t\tconst callback = this._pendingRequests[id];\n\t\tdelete this._pendingRequests[id];\n\n\t\tif (e.data.error) {\n\t\t\tcallback(e.data.error);\n\t\t} else {\n\t\t\tconst arrayBuffer = e.data.arrayBuffer;\n\n\t\t\tfor (let i = 0, len = e.data.files.length; i < len; i++) {\n\t\t\t\tconst file = e.data.files[i];\n\t\t\t\tconst blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);\n\t\t\t\tfile.url = URL.createObjectURL(blob);\n\t\t\t}\n\n\t\t\tcallback(null, e.data.files);\n\t\t}\n\t}\n\n\tuntar(arrayBuffer, callback) {\n\t\tconst id = this._requestId++;\n\t\tthis._pendingRequests[id] = callback;\n\n\t\tthis._worker.postMessage({\n\t\t\tid: id,\n\t\t\tprefix: this._filenamePrefix,\n\t\t\tarrayBuffer: arrayBuffer\n\t\t}, [arrayBuffer]);\n\t}\n\n\thasPendingRequests() {\n\t\treturn Object.keys(this._pendingRequests).length > 0;\n\t}\n\n\tdestroy() {\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\n\t\t\tthis._worker = null;\n\t\t\tthis._pendingRequests = null;\n\t\t}\n\t}\n\n}\n\nUntarScope();\n\nclass BundleHandler {\n\tconstructor(assets) {\n\t\tthis._assets = assets;\n\t\tthis._worker = null;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\t\thttp.get(url.load, {\n\t\t\tresponseType: Http.ResponseType.ARRAY_BUFFER,\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\ttry {\n\t\t\t\t\tself._untar(response, callback);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tcallback(\"Error loading bundle resource \" + url.original + \": \" + ex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcallback(\"Error loading bundle resource \" + url.original + \": \" + err);\n\t\t\t}\n\t\t});\n\t}\n\n\t_untar(response, callback) {\n\t\tconst self = this;\n\n\t\tif (platform.workers) {\n\t\t\tif (!self._worker) {\n\t\t\t\tself._worker = new UntarWorker(self._assets.prefix);\n\t\t\t}\n\n\t\t\tself._worker.untar(response, function (err, files) {\n\t\t\t\tcallback(err, files);\n\n\t\t\t\tif (!self._worker.hasPendingRequests()) {\n\t\t\t\t\tself._worker.destroy();\n\n\t\t\t\t\tself._worker = null;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst archive = new Untar(response);\n\t\t\tconst files = archive.untar(self._assets.prefix);\n\t\t\tcallback(null, files);\n\t\t}\n\t}\n\n\topen(url, data) {\n\t\treturn new Bundle(data);\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass ContainerResource {\n\tinstantiateModelEntity(options) {\n\t\treturn null;\n\t}\n\n\tinstantiateRenderEntity(options) {\n\t\treturn null;\n\t}\n\n}\n\nclass ContainerHandler {\n\tconstructor(device, assets) {\n\t\tthis.glbParser = new GlbParser(device, assets, 0);\n\t\tthis.parsers = {};\n\t}\n\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\n\t_getParser(url) {\n\t\tconst ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;\n\t\treturn this.parsers[ext] || this.glbParser;\n\t}\n\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tthis._getParser(url.original).load(url, callback, asset);\n\t}\n\n\topen(url, data, asset) {\n\t\treturn this._getParser(url).open(url, data, asset);\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass CssHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading css resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nfunction createStyle(cssString) {\n\tconst result = document.createElement('style');\n\tresult.type = 'text/css';\n\n\tif (result.styleSheet) {\n\t\tresult.styleSheet.cssText = cssString;\n\t} else {\n\t\tresult.appendChild(document.createTextNode(cssString));\n\t}\n\n\treturn result;\n}\n\nclass CubemapHandler {\n\tconstructor(device, assets, loader) {\n\t\tthis._device = device;\n\t\tthis._registry = assets;\n\t\tthis._loader = loader;\n\t}\n\n\tload(url, callback, asset) {\n\t\tthis.loadAssets(asset, callback);\n\t}\n\n\topen(url, data, asset) {\n\t\treturn asset ? asset.resource : null;\n\t}\n\n\tpatch(asset, registry) {\n\t\tthis.loadAssets(asset, function (err, result) {\n\t\t\tif (err) {\n\t\t\t\tregistry.fire('error', asset);\n\t\t\t\tregistry.fire('error:' + asset.id, err, asset);\n\t\t\t\tasset.fire('error', asset);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetAssetIds(cubemapAsset) {\n\t\tconst result = [];\n\t\tresult[0] = cubemapAsset.file;\n\n\t\tif ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {\n\t\t\tfor (let i = 0; i < 6; ++i) {\n\t\t\t\tresult[i + 1] = cubemapAsset.data.textures[i];\n\t\t\t}\n\t\t} else {\n\t\t\tresult[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tcompareAssetIds(assetIdA, assetIdB) {\n\t\tif (assetIdA && assetIdB) {\n\t\t\tif (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === \"string\") {\n\t\t\t\treturn assetIdA === assetIdB;\n\t\t\t}\n\n\t\t\treturn assetIdA.url === assetIdB.url;\n\t\t}\n\n\t\treturn assetIdA !== null === (assetIdB !== null);\n\t}\n\n\tupdate(cubemapAsset, assetIds, assets) {\n\t\tconst assetData = cubemapAsset.data || {};\n\t\tconst oldAssets = cubemapAsset._handlerState.assets;\n\t\tconst oldResources = cubemapAsset._resources;\n\t\tlet tex, mip, i;\n\t\tconst resources = [null, null, null, null, null, null, null];\n\n\t\tconst getType = function getType() {\n\t\t\tif (assetData.hasOwnProperty('type')) {\n\t\t\t\treturn assetData.type;\n\t\t\t}\n\n\t\t\tif (assetData.hasOwnProperty('rgbm')) {\n\t\t\t\treturn assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tif (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {\n\t\t\tif (assets[0]) {\n\t\t\t\ttex = assets[0].resource;\n\n\t\t\t\tfor (i = 0; i < 6; ++i) {\n\t\t\t\t\tresources[i + 1] = new Texture(this._device, {\n\t\t\t\t\t\tname: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),\n\t\t\t\t\t\tcubemap: true,\n\t\t\t\t\t\ttype: getType() || tex.type,\n\t\t\t\t\t\twidth: tex.width >> i,\n\t\t\t\t\t\theight: tex.height >> i,\n\t\t\t\t\t\tformat: tex.format,\n\t\t\t\t\t\tlevels: [tex._levels[i]],\n\t\t\t\t\t\tfixCubemapSeams: true,\n\t\t\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\t\tmipmaps: i === 0\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresources[1] = oldResources[1] || null;\n\t\t\tresources[2] = oldResources[2] || null;\n\t\t\tresources[3] = oldResources[3] || null;\n\t\t\tresources[4] = oldResources[4] || null;\n\t\t\tresources[5] = oldResources[5] || null;\n\t\t\tresources[6] = oldResources[6] || null;\n\t\t}\n\n\t\tconst faceAssets = assets.slice(1);\n\n\t\tif (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {\n\t\t\tif (faceAssets.indexOf(null) === -1) {\n\t\t\t\tconst faceTextures = faceAssets.map(function (asset) {\n\t\t\t\t\treturn asset.resource;\n\t\t\t\t});\n\t\t\t\tconst faceLevels = [];\n\n\t\t\t\tfor (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {\n\t\t\t\t\tfaceLevels.push(faceTextures.map(function (faceTexture) {\n\t\t\t\t\t\treturn faceTexture._levels[mip];\n\t\t\t\t\t}));\n\t\t\t\t}\n\n\t\t\t\tconst faces = new Texture(this._device, {\n\t\t\t\t\tname: cubemapAsset.name + '_faces',\n\t\t\t\t\tcubemap: true,\n\t\t\t\t\ttype: getType() || faceTextures[0].type,\n\t\t\t\t\twidth: faceTextures[0].width,\n\t\t\t\t\theight: faceTextures[0].height,\n\t\t\t\t\tformat: faceTextures[0].format,\n\t\t\t\t\tlevels: faceLevels,\n\t\t\t\t\tminFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,\n\t\t\t\t\tmagFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,\n\t\t\t\t\tanisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,\n\t\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\tfixCubemapSeams: !!assets[0]\n\t\t\t\t});\n\t\t\t\tresources[0] = faces;\n\t\t\t}\n\t\t} else {\n\t\t\tresources[0] = oldResources[0] || null;\n\t\t}\n\n\t\tif (!this.cmpArrays(resources, oldResources)) {\n\t\t\tcubemapAsset.resources = resources;\n\t\t\tcubemapAsset._handlerState.assetIds = assetIds;\n\t\t\tcubemapAsset._handlerState.assets = assets;\n\n\t\t\tfor (i = 0; i < oldResources.length; ++i) {\n\t\t\t\tif (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {\n\t\t\t\t\toldResources[i].destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < oldAssets.length; ++i) {\n\t\t\tif (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {\n\t\t\t\toldAssets[i].unload();\n\t\t\t}\n\t\t}\n\t}\n\n\tcmpArrays(arr1, arr2) {\n\t\tif (arr1.length !== arr2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < arr1.length; ++i) {\n\t\t\tif (arr1[i] !== arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tresolveId(value) {\n\t\tconst valueInt = parseInt(value, 10);\n\t\treturn valueInt === value || valueInt.toString() === value ? valueInt : value;\n\t}\n\n\tloadAssets(cubemapAsset, callback) {\n\t\tif (!cubemapAsset.hasOwnProperty('_handlerState')) {\n\t\t\tcubemapAsset._handlerState = {\n\t\t\t\tassetIds: [null, null, null, null, null, null, null],\n\t\t\t\tassets: [null, null, null, null, null, null, null]\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\t\tconst assetIds = self.getAssetIds(cubemapAsset);\n\t\tconst assets = [null, null, null, null, null, null, null];\n\t\tconst loadedAssetIds = cubemapAsset._handlerState.assetIds;\n\t\tconst loadedAssets = cubemapAsset._handlerState.assets;\n\t\tconst registry = self._registry;\n\t\tlet awaiting = 7;\n\n\t\tconst onLoad = function onLoad(index, asset) {\n\t\t\tassets[index] = asset;\n\t\t\tawaiting--;\n\n\t\t\tif (awaiting === 0) {\n\t\t\t\tself.update(cubemapAsset, assetIds, assets);\n\t\t\t\tcallback(null, cubemapAsset.resources);\n\t\t\t}\n\t\t};\n\n\t\tconst onError = function onError(index, err, asset) {\n\t\t\tcallback(err);\n\t\t};\n\n\t\tconst processTexAsset = function processTexAsset(index, texAsset) {\n\t\t\tif (texAsset.loaded) {\n\t\t\t\tonLoad(index, texAsset);\n\t\t\t} else {\n\t\t\t\tregistry.once('load:' + texAsset.id, onLoad.bind(self, index));\n\t\t\t\tregistry.once('error:' + texAsset.id, onError.bind(self, index));\n\n\t\t\t\tif (!texAsset.loading) {\n\t\t\t\t\tregistry.load(texAsset);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet texAsset;\n\n\t\tfor (let i = 0; i < 7; ++i) {\n\t\t\tconst assetId = this.resolveId(assetIds[i]);\n\n\t\t\tif (!assetId) {\n\t\t\t\tonLoad(i, null);\n\t\t\t} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {\n\t\t\t\tonLoad(i, loadedAssets[i]);\n\t\t\t} else if (parseInt(assetId, 10) === assetId) {\n\t\t\t\ttexAsset = registry.get(assetId);\n\n\t\t\t\tif (texAsset) {\n\t\t\t\t\tprocessTexAsset(i, texAsset);\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(function (index, assetId_) {\n\t\t\t\t\t\tconst texAsset = registry.get(assetId_);\n\n\t\t\t\t\t\tif (texAsset) {\n\t\t\t\t\t\t\tprocessTexAsset(index, texAsset);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonError(index, \"failed to find dependent cubemap asset=\" + assetId_);\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(null, i, assetId));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst file = typeof assetId === \"string\" ? {\n\t\t\t\t\turl: assetId,\n\t\t\t\t\tfilename: assetId\n\t\t\t\t} : assetId;\n\t\t\t\ttexAsset = new Asset(cubemapAsset.name + \"_part_\" + i, \"texture\", file);\n\t\t\t\tregistry.add(texAsset);\n\t\t\t\tregistry.once('load:' + texAsset.id, onLoad.bind(self, i));\n\t\t\t\tregistry.once('error:' + texAsset.id, onError.bind(self, i));\n\t\t\t\tregistry.load(texAsset);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass FolderHandler {\n\tload(url, callback) {\n\t\tcallback(null, null);\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n}\n\nconst FONT_MSDF = 'msdf';\nconst FONT_BITMAP = 'bitmap';\n\nclass Font {\n\tconstructor(textures, data) {\n\t\tthis.type = data ? data.type || FONT_MSDF : FONT_MSDF;\n\t\tthis.em = 1;\n\t\tthis.textures = textures;\n\t\tthis.intensity = 0.0;\n\t\tthis._data = null;\n\t\tthis.data = data;\n\t}\n\n\tset data(value) {\n\t\tthis._data = value;\n\t\tif (!value) return;\n\n\t\tif (this._data.intensity !== undefined) {\n\t\t\tthis.intensity = this._data.intensity;\n\t\t}\n\n\t\tif (!this._data.info) this._data.info = {};\n\n\t\tif (!this._data.version || this._data.version < 2) {\n\t\t\tthis._data.info.maps = [{\n\t\t\t\twidth: this._data.info.width,\n\t\t\t\theight: this._data.info.height\n\t\t\t}];\n\n\t\t\tif (this._data.chars) {\n\t\t\t\tfor (const key in this._data.chars) {\n\t\t\t\t\tthis._data.chars[key].map = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget data() {\n\t\treturn this._data;\n\t}\n\n}\n\nfunction upgradeDataSchema(data) {\n\tif (data.version < 3) {\n\t\tif (data.version < 2) {\n\t\t\tdata.info.maps = data.info.maps || [{\n\t\t\t\twidth: data.info.width,\n\t\t\t\theight: data.info.height\n\t\t\t}];\n\t\t}\n\n\t\tdata.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {\n\t\t\tconst existing = data.chars[key];\n\t\t\tconst newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);\n\n\t\t\tif (data.version < 2) {\n\t\t\t\texisting.map = existing.map || 0;\n\t\t\t}\n\n\t\t\tnewChars[newKey] = existing;\n\t\t\treturn newChars;\n\t\t}, {});\n\t\tdata.version = 3;\n\t}\n\n\treturn data;\n}\n\nclass FontHandler {\n\tconstructor(loader) {\n\t\tthis._loader = loader;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, function (err, response) {\n\t\t\t\tif (!err) {\n\t\t\t\t\tconst data = upgradeDataSchema(response);\n\n\t\t\t\t\tself._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\t\ttextures: textures\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(`Error loading font resource: ${url.original} [${err}]`);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tif (asset && asset.data) {\n\t\t\t\tasset.data = upgradeDataSchema(asset.data);\n\t\t\t}\n\n\t\t\tthis._loadTextures(url.load, asset && asset.data, callback);\n\t\t}\n\t}\n\n\t_loadTextures(url, data, callback) {\n\t\tconst numTextures = data.info.maps.length;\n\t\tlet numLoaded = 0;\n\t\tlet error = null;\n\t\tconst textures = new Array(numTextures);\n\t\tconst loader = this._loader;\n\n\t\tconst loadTexture = function loadTexture(index) {\n\t\t\tconst onLoaded = function onLoaded(err, texture) {\n\t\t\t\tif (error) return;\n\n\t\t\t\tif (err) {\n\t\t\t\t\terror = err;\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\ttexture.upload();\n\t\t\t\ttextures[index] = texture;\n\t\t\t\tnumLoaded++;\n\n\t\t\t\tif (numLoaded === numTextures) {\n\t\t\t\t\tcallback(null, textures);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (index === 0) {\n\t\t\t\tloader.load(url, \"texture\", onLoaded);\n\t\t\t} else {\n\t\t\t\tloader.load(url.replace('.png', index + '.png'), \"texture\", onLoaded);\n\t\t\t}\n\t\t};\n\n\t\tfor (let i = 0; i < numTextures; i++) loadTexture(i);\n\t}\n\n\topen(url, data, asset) {\n\t\tlet font;\n\n\t\tif (data.textures) {\n\t\t\tfont = new Font(data.textures, data.data);\n\t\t} else {\n\t\t\tfont = new Font(data, null);\n\t\t}\n\n\t\treturn font;\n\t}\n\n\tpatch(asset, assets) {\n\t\tconst font = asset.resource;\n\n\t\tif (!font.data && asset.data) {\n\t\t\tfont.data = asset.data;\n\t\t} else if (!asset.data && font.data) {\n\t\t\tasset.data = font.data;\n\t\t}\n\n\t\tif (asset.data) {\n\t\t\tasset.data = upgradeDataSchema(asset.data);\n\t\t}\n\t}\n\n}\n\nconst CompressUtils = {\n\tsetCompressedPRS: function (entity, data, compressed) {\n\t\tconst a = compressed.singleVecs;\n\t\tlet b, i;\n\t\tconst v = data.___1;\n\n\t\tif (!v) {\n\t\t\tb = compressed.tripleVecs;\n\t\t\ti = data.___2;\n\t\t}\n\n\t\tlet n = v ? v[0] : b[i];\n\t\tentity.setLocalPosition(a[n], a[n + 1], a[n + 2]);\n\t\tn = v ? v[1] : b[i + 1];\n\t\tentity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);\n\t\tn = v ? v[2] : b[i + 2];\n\t\tentity.setLocalScale(a[n], a[n + 1], a[n + 2]);\n\t},\n\toneCharToKey: function (s, data) {\n\t\tconst i = s.charCodeAt(0) - data.fieldFirstCode;\n\t\treturn data.fieldArray[i];\n\t},\n\tmultCharToKey: function (s, data) {\n\t\tlet ind = 0;\n\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\tind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;\n\t\t}\n\n\t\treturn data.fieldArray[ind];\n\t}\n};\n\nclass Decompress {\n\tconstructor(node, data) {\n\t\tthis._node = node;\n\t\tthis._data = data;\n\t}\n\n\trun() {\n\t\tconst type = Object.prototype.toString.call(this._node);\n\n\t\tif (type === '[object Object]') {\n\t\t\tthis._handleMap();\n\t\t} else if (type === '[object Array]') {\n\t\t\tthis._handleArray();\n\t\t} else {\n\t\t\tthis._result = this._node;\n\t\t}\n\n\t\treturn this._result;\n\t}\n\n\t_handleMap() {\n\t\tthis._result = {};\n\t\tconst a = Object.keys(this._node);\n\t\ta.forEach(this._handleKey, this);\n\t}\n\n\t_handleKey(origKey) {\n\t\tlet newKey = origKey;\n\t\tconst len = origKey.length;\n\n\t\tif (len === 1) {\n\t\t\tnewKey = CompressUtils.oneCharToKey(origKey, this._data);\n\t\t} else if (len === 2) {\n\t\t\tnewKey = CompressUtils.multCharToKey(origKey, this._data);\n\t\t}\n\n\t\tthis._result[newKey] = new Decompress(this._node[origKey], this._data).run();\n\t}\n\n\t_handleArray() {\n\t\tthis._result = [];\n\n\t\tthis._node.forEach(this._handleArElt, this);\n\t}\n\n\t_handleArElt(elt) {\n\t\tconst v = new Decompress(elt, this._data).run();\n\n\t\tthis._result.push(v);\n\t}\n\n}\n\nclass SceneParser {\n\tconstructor(app, isTemplate) {\n\t\tthis._app = app;\n\t\tthis._isTemplate = isTemplate;\n\t}\n\n\tparse(data) {\n\t\tconst entities = {};\n\t\tlet parent = null;\n\t\tconst compressed = data.compressedFormat;\n\n\t\tif (compressed && !data.entDecompressed) {\n\t\t\tdata.entDecompressed = true;\n\t\t\tdata.entities = new Decompress(data.entities, compressed).run();\n\t\t}\n\n\t\tfor (const id in data.entities) {\n\t\t\tconst curData = data.entities[id];\n\n\t\t\tconst curEnt = this._createEntity(curData, compressed);\n\n\t\t\tentities[id] = curEnt;\n\n\t\t\tif (curData.parent === null) {\n\t\t\t\tparent = curEnt;\n\t\t\t}\n\t\t}\n\n\t\tfor (const id in data.entities) {\n\t\t\tconst curEnt = entities[id];\n\t\t\tconst children = data.entities[id].children;\n\t\t\tconst len = children.length;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst childEnt = entities[children[i]];\n\n\t\t\t\tif (childEnt) {\n\t\t\t\t\tcurEnt.addChild(childEnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._openComponentData(parent, data.entities);\n\n\t\treturn parent;\n\t}\n\n\t_createEntity(data, compressed) {\n\t\tconst entity = new Entity();\n\t\tentity.name = data.name;\n\t\tentity.setGuid(data.resource_id);\n\n\t\tthis._setPosRotScale(entity, data, compressed);\n\n\t\tentity._enabled = data.enabled !== undefined ? data.enabled : true;\n\n\t\tif (this._isTemplate) {\n\t\t\tentity._template = true;\n\t\t} else {\n\t\t\tentity._enabledInHierarchy = entity._enabled;\n\t\t}\n\n\t\tentity.template = data.template;\n\n\t\tif (data.tags) {\n\t\t\tfor (let i = 0; i < data.tags.length; i++) {\n\t\t\t\tentity.tags.add(data.tags[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (data.labels) {\n\t\t\tdata.labels.forEach(function (label) {\n\t\t\t\tentity.addLabel(label);\n\t\t\t});\n\t\t}\n\n\t\treturn entity;\n\t}\n\n\t_setPosRotScale(entity, data, compressed) {\n\t\tif (compressed) {\n\t\t\tCompressUtils.setCompressedPRS(entity, data, compressed);\n\t\t} else {\n\t\t\tconst p = data.position;\n\t\t\tconst r = data.rotation;\n\t\t\tconst s = data.scale;\n\t\t\tentity.setLocalPosition(p[0], p[1], p[2]);\n\t\t\tentity.setLocalEulerAngles(r[0], r[1], r[2]);\n\t\t\tentity.setLocalScale(s[0], s[1], s[2]);\n\t\t}\n\t}\n\n\t_openComponentData(entity, entities) {\n\t\tconst systemsList = this._app.systems.list;\n\t\tlet len = systemsList.length;\n\t\tconst entityData = entities[entity.getGuid()];\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst system = systemsList[i];\n\t\t\tconst componentData = entityData.components[system.id];\n\n\t\t\tif (componentData) {\n\t\t\t\tsystem.addComponent(entity, componentData);\n\t\t\t}\n\t\t}\n\n\t\tlen = entityData.children.length;\n\t\tconst children = entity._children;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tchildren[i] = this._openComponentData(children[i], entities);\n\t\t}\n\n\t\treturn entity;\n\t}\n\n}\n\nconst SceneUtils = {\n\tload: function (url, maxRetries, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: maxRetries > 0,\n\t\t\tmaxRetries: maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(err, response);\n\t\t\t} else {\n\t\t\t\tlet errMsg = 'Error while loading scene JSON ' + url.original;\n\n\t\t\t\tif (err.message) {\n\t\t\t\t\terrMsg += ': ' + err.message;\n\n\t\t\t\t\tif (err.stack) {\n\t\t\t\t\t\terrMsg += '\\n' + err.stack;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrMsg += ': ' + err;\n\t\t\t\t}\n\n\t\t\t\tcallback(errMsg);\n\t\t\t}\n\t\t});\n\t}\n};\n\nclass HierarchyHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tSceneUtils.load(url, this.maxRetries, callback);\n\t}\n\n\topen(url, data) {\n\t\tthis._app.systems.script.preloading = true;\n\t\tconst parser = new SceneParser(this._app, false);\n\t\tconst parent = parser.parse(data);\n\t\tthis._app.systems.script.preloading = false;\n\t\treturn parent;\n\t}\n\n}\n\nclass HtmlHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading html resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass JsonHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading JSON resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass AssetReference {\n\tconstructor(propertyName, parent, registry, callbacks, scope) {\n\t\tthis.propertyName = propertyName;\n\t\tthis.parent = parent;\n\t\tthis._scope = scope;\n\t\tthis._registry = registry;\n\t\tthis.id = null;\n\t\tthis.url = null;\n\t\tthis.asset = null;\n\t\tthis._onAssetLoad = callbacks.load;\n\t\tthis._onAssetAdd = callbacks.add;\n\t\tthis._onAssetRemove = callbacks.remove;\n\t\tthis._onAssetUnload = callbacks.unload;\n\t}\n\n\tset id(value) {\n\t\tif (this.url) throw Error(\"Can't set id and url\");\n\n\t\tthis._unbind();\n\n\t\tthis._id = value;\n\t\tthis.asset = this._registry.get(this._id);\n\n\t\tthis._bind();\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tset url(value) {\n\t\tif (this.id) throw Error(\"Can't set id and url\");\n\n\t\tthis._unbind();\n\n\t\tthis._url = value;\n\t\tthis.asset = this._registry.getByUrl(this._url);\n\n\t\tthis._bind();\n\t}\n\n\tget url() {\n\t\treturn this._url;\n\t}\n\n\t_bind() {\n\t\tif (this.id) {\n\t\t\tif (this._onAssetLoad) this._registry.on(\"load:\" + this.id, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._registry.once(\"add:\" + this.id, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._registry.on(\"remove:\" + this.id, this._onRemove, this);\n\t\t\tif (this._onAssetUnload) this._registry.on(\"unload:\" + this.id, this._onUnload, this);\n\t\t}\n\n\t\tif (this.url) {\n\t\t\tif (this._onAssetLoad) this._registry.on(\"load:url:\" + this.url, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._registry.once(\"add:url:\" + this.url, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._registry.on(\"remove:url:\" + this.url, this._onRemove, this);\n\t\t}\n\t}\n\n\t_unbind() {\n\t\tif (this.id) {\n\t\t\tif (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);\n\t\t\tif (this._onAssetUnload) this._registry.off(\"unload:\" + this.id, this._onUnload, this);\n\t\t}\n\n\t\tif (this.url) {\n\t\t\tif (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);\n\t\t}\n\t}\n\n\t_onLoad(asset) {\n\t\tthis._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n\n\t_onAdd(asset) {\n\t\tthis.asset = asset;\n\n\t\tthis._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n\n\t_onRemove(asset) {\n\t\tthis._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);\n\n\t\tthis.asset = null;\n\t}\n\n\t_onUnload(asset) {\n\t\tthis._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nclass StandardMaterialValidator {\n\tconstructor() {\n\t\tthis.removeInvalid = true;\n\t\tthis.valid = true;\n\t\tthis.enumValidators = {\n\t\t\toccludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),\n\t\t\tcull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),\n\t\t\tblendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),\n\t\t\tshadingModel: this._createEnumValidator([SPECULAR_PHONG, SPECULAR_BLINN])\n\t\t};\n\t}\n\n\tsetInvalid(key, data) {\n\t\tthis.valid = false;\n\n\t\tif (this.removeInvalid) {\n\t\t\tdelete data[key];\n\t\t}\n\t}\n\n\tvalidate(data) {\n\t\tconst TYPES = standardMaterialParameterTypes;\n\t\tconst pathMapping = data.mappingFormat === \"path\";\n\n\t\tfor (const key in data) {\n\t\t\tconst type = TYPES[key];\n\n\t\t\tif (!type) {\n\t\t\t\tthis.valid = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type.startsWith(\"enum\")) {\n\t\t\t\tconst enumType = type.split(\":\")[1];\n\n\t\t\t\tif (this.enumValidators[enumType]) {\n\t\t\t\t\tif (!this.enumValidators[enumType](data[key])) {\n\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (typeof data[key] !== 'number') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\tif (typeof data[key] !== 'boolean') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'string') {\n\t\t\t\tif (typeof data[key] !== 'string') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'vec2') {\n\t\t\t\tif (!(data[key] instanceof Array && data[key].length === 2)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'rgb') {\n\t\t\t\tif (!(data[key] instanceof Array && data[key].length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'texture') {\n\t\t\t\tif (!pathMapping) {\n\t\t\t\t\tif (!(typeof data[key] === 'number' || data[key] === null)) {\n\t\t\t\t\t\tif (!(data[key] instanceof Texture)) {\n\t\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!(typeof data[key] === 'string' || data[key] === null)) {\n\t\t\t\t\t\tif (!(data[key] instanceof Texture)) {\n\t\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boundingbox') {\n\t\t\t\tif (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\n\t\t\t\tif (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'cubemap') {\n\t\t\t\tif (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {\n\t\t\t\t\tif (!(data[key] instanceof Texture && data[key].cubemap)) {\n\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'chunks') {\n\t\t\t\tconst chunkNames = Object.keys(data[key]);\n\n\t\t\t\tfor (let i = 0; i < chunkNames.length; i++) {\n\t\t\t\t\tif (typeof data[key][chunkNames[i]] !== 'string') {\n\t\t\t\t\t\tthis.setInvalid(chunkNames[i], data[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(\"Unknown material type: \" + type);\n\t\t\t}\n\t\t}\n\n\t\tdata.validated = true;\n\t\treturn this.valid;\n\t}\n\n\t_createEnumValidator(values) {\n\t\treturn function (value) {\n\t\t\treturn values.indexOf(value) >= 0;\n\t\t};\n\t}\n\n}\n\nclass JsonStandardMaterialParser {\n\tconstructor() {\n\t\tthis._validator = null;\n\t}\n\n\tparse(input) {\n\t\tconst migrated = this.migrate(input);\n\n\t\tconst validated = this._validate(migrated);\n\n\t\tconst material = new StandardMaterial();\n\t\tthis.initialize(material, validated);\n\t\treturn material;\n\t}\n\n\tinitialize(material, data) {\n\t\tif (!data.validated) {\n\t\t\tdata = this._validate(data);\n\t\t}\n\n\t\tif (data.chunks) {\n\t\t\tmaterial.chunks = _extends({}, data.chunks);\n\t\t}\n\n\t\tfor (const key in data) {\n\t\t\tconst type = standardMaterialParameterTypes[key];\n\t\t\tconst value = data[key];\n\n\t\t\tif (type === 'vec2') {\n\t\t\t\tmaterial[key] = new Vec2(value[0], value[1]);\n\t\t\t} else if (type === 'rgb') {\n\t\t\t\tmaterial[key] = new Color(value[0], value[1], value[2]);\n\t\t\t} else if (type === 'texture') {\n\t\t\t\tif (value instanceof Texture) {\n\t\t\t\t\tmaterial[key] = value;\n\t\t\t\t} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {\n\t\t\t\t\tmaterial[key] = null;\n\t\t\t\t}\n\t\t\t} else if (type === 'cubemap') {\n\t\t\t\tif (value instanceof Texture) {\n\t\t\t\t\tmaterial[key] = value;\n\t\t\t\t} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {\n\t\t\t\t\tmaterial[key] = null;\n\t\t\t\t}\n\n\t\t\t\tif (key === 'cubeMap' && !value) {\n\t\t\t\t\tmaterial.prefilteredCubemaps = null;\n\t\t\t\t}\n\t\t\t} else if (type === 'boundingbox') {\n\t\t\t\tconst center = new Vec3(value.center[0], value.center[1], value.center[2]);\n\t\t\t\tconst halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);\n\t\t\t\tmaterial[key] = new BoundingBox(center, halfExtents);\n\t\t\t} else {\n\t\t\t\tmaterial[key] = data[key];\n\t\t\t}\n\t\t}\n\n\t\tmaterial.update();\n\t}\n\n\tmigrate(data) {\n\t\tif (data.shadingModel === undefined) {\n\t\t\tif (data.shader === 'blinn') {\n\t\t\t\tdata.shadingModel = SPECULAR_BLINN;\n\t\t\t} else {\n\t\t\t\tdata.shadingModel = SPECULAR_PHONG;\n\t\t\t}\n\t\t}\n\n\t\tif (data.shader) delete data.shader;\n\n\t\tif (data.mapping_format) {\n\t\t\tdata.mappingFormat = data.mapping_format;\n\t\t\tdelete data.mapping_format;\n\t\t}\n\n\t\tlet i;\n\t\tconst RENAMED_PROPERTIES = [[\"bumpMapFactor\", \"bumpiness\"], [\"aoUvSet\", \"aoMapUv\"], [\"aoMapVertexColor\", \"aoVertexColor\"], [\"diffuseMapVertexColor\", \"diffuseVertexColor\"], [\"emissiveMapVertexColor\", \"emissiveVertexColor\"], [\"specularMapVertexColor\", \"specularVertexColor\"], [\"metalnessMapVertexColor\", \"metalnessVertexColor\"], [\"opacityMapVertexColor\", \"opacityVertexColor\"], [\"glossMapVertexColor\", \"glossVertexColor\"], [\"lightMapVertexColor\", \"lightVertexColor\"], [\"diffuseMapTint\", \"diffuseTint\"], [\"specularMapTint\", \"specularTint\"], [\"emissiveMapTint\", \"emissiveTint\"], [\"metalnessMapTint\", \"metalnessTint\"]];\n\n\t\tfor (i = 0; i < RENAMED_PROPERTIES.length; i++) {\n\t\t\tconst _old = RENAMED_PROPERTIES[i][0];\n\t\t\tconst _new = RENAMED_PROPERTIES[i][1];\n\n\t\t\tif (data[_old] !== undefined && !(data[_new] !== undefined)) {\n\t\t\t\tdata[_new] = data[_old];\n\t\t\t\tdelete data[_old];\n\t\t\t}\n\t\t}\n\n\t\tconst DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];\n\n\t\tfor (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {\n\t\t\tconst name = DEPRECATED_PROPERTIES[i];\n\n\t\t\tif (data.hasOwnProperty(name)) {\n\t\t\t\tdelete data[name];\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t_validate(data) {\n\t\tif (!data.validated) {\n\t\t\tif (!this._validator) {\n\t\t\t\tthis._validator = new StandardMaterialValidator();\n\t\t\t}\n\n\t\t\tthis._validator.validate(data);\n\t\t}\n\n\t\treturn data;\n\t}\n\n}\n\nconst PLACEHOLDER_MAP = {\n\taoMap: 'white',\n\tdiffuseMap: 'gray',\n\tspecularMap: 'gray',\n\tmetalnessMap: 'black',\n\tglossMap: 'gray',\n\temissiveMap: 'gray',\n\tnormalMap: 'normal',\n\theightMap: 'gray',\n\topacityMap: 'gray',\n\tsphereMap: 'gray',\n\tlightMap: 'white'\n};\n\nclass MaterialHandler {\n\tconstructor(app) {\n\t\tthis._assets = app.assets;\n\t\tthis._device = app.graphicsDevice;\n\t\tthis._placeholderTextures = null;\n\t\tthis._parser = new JsonStandardMaterialParser();\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tresponse._engine = true;\n\t\t\t\t\tcallback(null, response);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(`Error loading material: ${url.original} [${err}]`);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\tconst material = this._parser.parse(data);\n\n\t\tif (data._engine) {\n\t\t\tmaterial._data = data;\n\t\t\tdelete data._engine;\n\t\t}\n\n\t\treturn material;\n\t}\n\n\t_createPlaceholders() {\n\t\tthis._placeholderTextures = {};\n\t\tconst textures = {\n\t\t\twhite: [255, 255, 255, 255],\n\t\t\tgray: [128, 128, 128, 255],\n\t\t\tblack: [0, 0, 0, 255],\n\t\t\tnormal: [128, 128, 255, 255]\n\t\t};\n\n\t\tfor (const key in textures) {\n\t\t\tif (!textures.hasOwnProperty(key)) continue;\n\t\t\tthis._placeholderTextures[key] = new Texture(this._device, {\n\t\t\t\twidth: 2,\n\t\t\t\theight: 2,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8\n\t\t\t});\n\t\t\tthis._placeholderTextures[key].name = 'placeholder';\n\n\t\t\tconst pixels = this._placeholderTextures[key].lock();\n\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tfor (let c = 0; c < 4; c++) {\n\t\t\t\t\tpixels[i * 4 + c] = textures[key][c];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._placeholderTextures[key].unlock();\n\t\t}\n\t}\n\n\tpatch(asset, assets) {\n\t\tif (asset.resource._data) {\n\t\t\tasset._data = asset.resource._data;\n\t\t\tdelete asset.resource._data;\n\t\t}\n\n\t\tasset.data.name = asset.name;\n\t\tasset.resource.name = asset.name;\n\n\t\tthis._bindAndAssignAssets(asset, assets);\n\n\t\tasset.off('unload', this._onAssetUnload, this);\n\t\tasset.on('unload', this._onAssetUnload, this);\n\t}\n\n\t_onAssetUnload(asset) {\n\t\tdelete asset.data.parameters;\n\t\tdelete asset.data.chunks;\n\t\tdelete asset.data.name;\n\t}\n\n\t_assignTexture(parameterName, materialAsset, texture) {\n\t\tmaterialAsset.resource[parameterName] = texture;\n\t}\n\n\t_getPlaceholderTexture(parameterName) {\n\t\tif (!this._placeholderTextures) {\n\t\t\tthis._createPlaceholders();\n\t\t}\n\n\t\tconst placeholder = PLACEHOLDER_MAP[parameterName];\n\t\tconst texture = this._placeholderTextures[placeholder];\n\t\treturn texture;\n\t}\n\n\t_assignPlaceholderTexture(parameterName, materialAsset) {\n\t\tmaterialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName, materialAsset);\n\t}\n\n\t_onTextureLoad(parameterName, materialAsset, textureAsset) {\n\t\tthis._assignTexture(parameterName, materialAsset, textureAsset.resource);\n\n\t\tmaterialAsset.resource.update();\n\t}\n\n\t_onTextureAdd(parameterName, materialAsset, textureAsset) {\n\t\tthis._assets.load(textureAsset);\n\t}\n\n\t_onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {\n\t\tconst material = materialAsset.resource;\n\n\t\tif (material) {\n\t\t\tif (materialAsset.resource[parameterName] === textureAsset.resource) {\n\t\t\t\tthis._assignPlaceholderTexture(parameterName, materialAsset);\n\n\t\t\t\tmaterial.update();\n\t\t\t}\n\t\t}\n\t}\n\n\t_assignCubemap(parameterName, materialAsset, textures) {\n\t\tmaterialAsset.resource[parameterName] = textures[0];\n\n\t\tif (parameterName === 'cubeMap') {\n\t\t\tmaterialAsset.resource.prefilteredCubemaps = textures.slice(1);\n\t\t}\n\t}\n\n\t_onCubemapLoad(parameterName, materialAsset, cubemapAsset) {\n\t\tthis._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);\n\n\t\tthis._parser.initialize(materialAsset.resource, materialAsset.data);\n\t}\n\n\t_onCubemapAdd(parameterName, materialAsset, cubemapAsset) {\n\t\tif (materialAsset.data.shadingModel === SPECULAR_PHONG) {\n\t\t\tmaterialAsset.loadFaces = true;\n\t\t}\n\n\t\tthis._assets.load(cubemapAsset);\n\t}\n\n\t_onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {\n\t\tconst material = materialAsset.resource;\n\n\t\tif (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {\n\t\t\tthis._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);\n\n\t\t\tmaterial.update();\n\t\t}\n\t}\n\n\t_bindAndAssignAssets(materialAsset, assets) {\n\t\tconst data = this._parser.migrate(materialAsset.data);\n\n\t\tconst material = materialAsset.resource;\n\t\tconst pathMapping = data.mappingFormat === \"path\";\n\t\tconst TEXTURES = standardMaterialTextureParameters;\n\t\tlet i, name, assetReference;\n\n\t\tfor (i = 0; i < TEXTURES.length; i++) {\n\t\t\tname = TEXTURES[i];\n\t\t\tassetReference = material._assetReferences[name];\n\t\t\tconst dataAssetId = data[name];\n\t\t\tconst materialTexture = material[name];\n\n\t\t\tconst isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name, materialAsset);\n\n\t\t\tconst dataValidated = data.validated;\n\n\t\t\tif (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {\n\t\t\t\tif (!assetReference) {\n\t\t\t\t\tassetReference = new AssetReference(name, materialAsset, assets, {\n\t\t\t\t\t\tload: this._onTextureLoad,\n\t\t\t\t\t\tadd: this._onTextureAdd,\n\t\t\t\t\t\tremove: this._onTextureRemoveOrUnload,\n\t\t\t\t\t\tunload: this._onTextureRemoveOrUnload\n\t\t\t\t\t}, this);\n\t\t\t\t\tmaterial._assetReferences[name] = assetReference;\n\t\t\t\t}\n\n\t\t\t\tif (pathMapping) {\n\t\t\t\t\tassetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);\n\t\t\t\t} else {\n\t\t\t\t\tassetReference.id = dataAssetId;\n\t\t\t\t}\n\n\t\t\t\tif (assetReference.asset) {\n\t\t\t\t\tif (assetReference.asset.resource) {\n\t\t\t\t\t\tthis._assignTexture(name, materialAsset, assetReference.asset.resource);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._assignPlaceholderTexture(name, materialAsset);\n\t\t\t\t\t}\n\n\t\t\t\t\tassets.load(assetReference.asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (assetReference) {\n\t\t\t\t\tif (pathMapping) {\n\t\t\t\t\t\tassetReference.url = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassetReference.id = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst CUBEMAPS = standardMaterialCubemapParameters;\n\n\t\tfor (i = 0; i < CUBEMAPS.length; i++) {\n\t\t\tname = CUBEMAPS[i];\n\t\t\tassetReference = material._assetReferences[name];\n\n\t\t\tif (data[name] && !materialAsset.data.prefilteredCubeMap128) {\n\t\t\t\tif (!assetReference) {\n\t\t\t\t\tassetReference = new AssetReference(name, materialAsset, assets, {\n\t\t\t\t\t\tload: this._onCubemapLoad,\n\t\t\t\t\t\tadd: this._onCubemapAdd,\n\t\t\t\t\t\tremove: this._onCubemapRemoveOrUnload,\n\t\t\t\t\t\tunload: this._onCubemapRemoveOrUnload\n\t\t\t\t\t}, this);\n\t\t\t\t\tmaterial._assetReferences[name] = assetReference;\n\t\t\t\t}\n\n\t\t\t\tif (pathMapping) {\n\t\t\t\t\tassetReference.url = data[name];\n\t\t\t\t} else {\n\t\t\t\t\tassetReference.id = data[name];\n\t\t\t\t}\n\n\t\t\t\tif (assetReference.asset) {\n\t\t\t\t\tif (assetReference.asset.loaded) {\n\t\t\t\t\t\tthis._assignCubemap(name, materialAsset, assetReference.asset.resources);\n\t\t\t\t\t}\n\n\t\t\t\t\tassets.load(assetReference.asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._parser.initialize(material, data);\n\t}\n\n}\n\nclass GlbModelParser {\n\tconstructor(device, defaultMaterial) {\n\t\tthis._device = device;\n\t\tthis._defaultMaterial = defaultMaterial;\n\t}\n\n\tparse(data) {\n\t\tconst glbResources = GlbParser.parse(\"filename.glb\", data, this._device);\n\n\t\tif (glbResources) {\n\t\t\tconst model = GlbContainerResource.createModel(glbResources, this._defaultMaterial);\n\t\t\tglbResources.destroy();\n\t\t\treturn model;\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n\nclass PartitionedVertex {\n\tconstructor() {\n\t\tthis.index = 0;\n\t\tthis.boneIndices = [0, 0, 0, 0];\n\t}\n\n}\n\nclass SkinPartition {\n\tconstructor() {\n\t\tthis.partition = 0;\n\t\tthis.vertexStart = 0;\n\t\tthis.vertexCount = 0;\n\t\tthis.indexStart = 0;\n\t\tthis.indexCount = 0;\n\t\tthis.boneIndices = [];\n\t\tthis.vertices = [];\n\t\tthis.indices = [];\n\t\tthis.indexMap = {};\n\t\tthis.originalMesh = null;\n\t}\n\n\taddVertex(vertex, idx, vertexArray) {\n\t\tlet remappedIndex = -1;\n\n\t\tif (this.indexMap[idx] !== undefined) {\n\t\t\tremappedIndex = this.indexMap[idx];\n\t\t\tthis.indices.push(remappedIndex);\n\t\t} else {\n\t\t\tfor (let influence = 0; influence < 4; influence++) {\n\t\t\t\tif (vertexArray.blendWeight.data[idx * 4 + influence] === 0) continue;\n\t\t\t\tconst originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];\n\t\t\t\tvertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);\n\t\t\t}\n\n\t\t\tremappedIndex = this.vertices.length;\n\t\t\tthis.indices.push(remappedIndex);\n\t\t\tthis.vertices.push(vertex);\n\t\t\tthis.indexMap[idx] = remappedIndex;\n\t\t}\n\t}\n\n\taddPrimitive(vertices, vertexIndices, vertexArray, boneLimit) {\n\t\tconst bonesToAdd = [];\n\t\tlet bonesToAddCount = 0;\n\t\tconst vertexCount = vertices.length;\n\n\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\tconst vertex = vertices[i];\n\t\t\tconst idx = vertex.index;\n\n\t\t\tfor (let influence = 0; influence < 4; influence++) {\n\t\t\t\tif (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {\n\t\t\t\t\tconst boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];\n\t\t\t\t\tlet needToAdd = true;\n\n\t\t\t\t\tfor (let j = 0; j < bonesToAddCount; j++) {\n\t\t\t\t\t\tif (bonesToAdd[j] === boneIndex) {\n\t\t\t\t\t\t\tneedToAdd = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (needToAdd) {\n\t\t\t\t\t\tbonesToAdd[bonesToAddCount] = boneIndex;\n\t\t\t\t\t\tconst boneRemap = this.getBoneRemap(boneIndex);\n\t\t\t\t\t\tbonesToAddCount += boneRemap === -1 ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.boneIndices.length + bonesToAddCount > boneLimit) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < bonesToAddCount; i++) {\n\t\t\tthis.boneIndices.push(bonesToAdd[i]);\n\t\t}\n\n\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\tthis.addVertex(vertices[i], vertexIndices[i], vertexArray);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tgetBoneRemap(boneIndex) {\n\t\tfor (let i = 0; i < this.boneIndices.length; i++) {\n\t\t\tif (this.boneIndices[i] === boneIndex) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n}\n\nfunction indicesToReferences(model) {\n\tconst vertices = model.vertices;\n\tconst skins = model.skins;\n\tconst meshes = model.meshes;\n\tconst meshInstances = model.meshInstances;\n\n\tfor (let i = 0; i < meshes.length; i++) {\n\t\tmeshes[i].vertices = vertices[meshes[i].vertices];\n\n\t\tif (meshes[i].skin !== undefined) {\n\t\t\tmeshes[i].skin = skins[meshes[i].skin];\n\t\t}\n\t}\n\n\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\tmeshInstances[i].mesh = meshes[meshInstances[i].mesh];\n\t}\n}\n\nfunction referencesToIndices(model) {\n\tconst vertices = model.vertices;\n\tconst skins = model.skins;\n\tconst meshes = model.meshes;\n\tconst meshInstances = model.meshInstances;\n\n\tfor (let i = 0; i < meshes.length; i++) {\n\t\tmeshes[i].vertices = vertices.indexOf(meshes[i].vertices);\n\n\t\tif (meshes[i].skin !== undefined) {\n\t\t\tmeshes[i].skin = skins.indexOf(meshes[i].skin);\n\t\t}\n\t}\n\n\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\tmeshInstances[i].mesh = meshes.indexOf(meshInstances[i].mesh);\n\t}\n}\n\nfunction partitionSkin(model, materialMappings, boneLimit) {\n\tlet i, j, k, index;\n\tindicesToReferences(model);\n\tconst vertexArrays = model.vertices;\n\tconst skins = model.skins;\n\tlet mesh;\n\tconst meshes = model.meshes;\n\tconst meshInstances = model.meshInstances;\n\n\tconst getVertex = function getVertex(idx) {\n\t\tconst vert = new PartitionedVertex();\n\t\tvert.index = idx;\n\t\treturn vert;\n\t};\n\n\tfor (i = skins.length - 1; i >= 0; i--) {\n\t\tif (skins[i].boneNames.length > boneLimit) {\n\t\t\tconst skin = skins.splice(i, 1)[0];\n\t\t\tconst meshesToSplit = [];\n\n\t\t\tfor (j = 0; j < meshes.length; j++) {\n\t\t\t\tif (meshes[j].skin === skin) {\n\t\t\t\t\tmeshesToSplit.push(meshes[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (j = 0; j < meshesToSplit.length; j++) {\n\t\t\t\tindex = meshes.indexOf(meshesToSplit[j]);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tmeshes.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (meshesToSplit.length === 0) {\n\t\t\t\tthrow new Error('partitionSkin: There should be at least one mesh that references a skin');\n\t\t\t}\n\n\t\t\tconst vertexArray = meshesToSplit[0].vertices;\n\n\t\t\tfor (j = 1; j < meshesToSplit.length; j++) {\n\t\t\t\tif (meshesToSplit[j].vertices !== vertexArray) {\n\t\t\t\t\tthrow new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet partition;\n\t\t\tconst partitions = [];\n\t\t\tconst primitiveVertices = [];\n\t\t\tconst primitiveIndices = [];\n\t\t\tlet basePartition = 0;\n\n\t\t\tfor (j = 0; j < meshesToSplit.length; j++) {\n\t\t\t\tmesh = meshesToSplit[j];\n\t\t\t\tconst indices = mesh.indices;\n\n\t\t\t\tfor (let iIndex = mesh.base; iIndex < mesh.base + mesh.count;) {\n\t\t\t\t\tindex = indices[iIndex++];\n\t\t\t\t\tprimitiveVertices[0] = getVertex(index);\n\t\t\t\t\tprimitiveIndices[0] = index;\n\t\t\t\t\tindex = indices[iIndex++];\n\t\t\t\t\tprimitiveVertices[1] = getVertex(index);\n\t\t\t\t\tprimitiveIndices[1] = index;\n\t\t\t\t\tindex = indices[iIndex++];\n\t\t\t\t\tprimitiveVertices[2] = getVertex(index);\n\t\t\t\t\tprimitiveIndices[2] = index;\n\t\t\t\t\tlet added = false;\n\n\t\t\t\t\tfor (let iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {\n\t\t\t\t\t\tpartition = partitions[iBonePartition];\n\n\t\t\t\t\t\tif (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {\n\t\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!added) {\n\t\t\t\t\t\tpartition = new SkinPartition();\n\t\t\t\t\t\tpartition.originalMesh = mesh;\n\t\t\t\t\t\tpartition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);\n\t\t\t\t\t\tpartitions.push(partition);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbasePartition = partitions.length;\n\t\t\t}\n\n\t\t\tconst partitionedVertices = [];\n\t\t\tconst partitionedIndices = [];\n\n\t\t\tfor (j = 0; j < partitions.length; j++) {\n\t\t\t\tpartition = partitions[j];\n\n\t\t\t\tif (partition.vertices.length && partition.indices.length) {\n\t\t\t\t\tconst vertexStart = partitionedVertices.length;\n\t\t\t\t\tconst vertexCount = partition.vertices.length;\n\t\t\t\t\tconst indexStart = partitionedIndices.length;\n\t\t\t\t\tconst indexCount = partition.indices.length;\n\t\t\t\t\tpartition.partition = j;\n\t\t\t\t\tpartition.vertexStart = vertexStart;\n\t\t\t\t\tpartition.vertexCount = vertexCount;\n\t\t\t\t\tpartition.indexStart = indexStart;\n\t\t\t\t\tpartition.indexCount = indexCount;\n\t\t\t\t\tlet iSour;\n\t\t\t\t\tlet iDest;\n\t\t\t\t\tiSour = 0;\n\t\t\t\t\tiDest = vertexStart;\n\n\t\t\t\t\twhile (iSour < vertexCount) {\n\t\t\t\t\t\tpartitionedVertices[iDest++] = partition.vertices[iSour++];\n\t\t\t\t\t}\n\n\t\t\t\t\tiSour = 0;\n\t\t\t\t\tiDest = indexStart;\n\n\t\t\t\t\twhile (iSour < indexCount) {\n\t\t\t\t\t\tpartitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst splitSkins = [];\n\n\t\t\tfor (j = 0; j < partitions.length; j++) {\n\t\t\t\tpartition = partitions[j];\n\t\t\t\tconst ibp = [];\n\t\t\t\tconst boneNames = [];\n\n\t\t\t\tfor (k = 0; k < partition.boneIndices.length; k++) {\n\t\t\t\t\tibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);\n\t\t\t\t\tboneNames.push(skin.boneNames[partition.boneIndices[k]]);\n\t\t\t\t}\n\n\t\t\t\tconst splitSkin = {\n\t\t\t\t\tinverseBindMatrices: ibp,\n\t\t\t\t\tboneNames: boneNames\n\t\t\t\t};\n\t\t\t\tsplitSkins.push(splitSkin);\n\t\t\t\tskins.push(splitSkin);\n\t\t\t}\n\n\t\t\tlet attrib, attribName, data, components;\n\t\t\tconst splitVertexArray = {};\n\n\t\t\tfor (attribName in vertexArray) {\n\t\t\t\tsplitVertexArray[attribName] = {\n\t\t\t\t\tcomponents: vertexArray[attribName].components,\n\t\t\t\t\tdata: [],\n\t\t\t\t\ttype: vertexArray[attribName].type\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfor (attribName in vertexArray) {\n\t\t\t\tif (attribName === 'blendIndices') {\n\t\t\t\t\tconst dstBoneIndices = splitVertexArray[attribName].data;\n\n\t\t\t\t\tfor (j = 0; j < partitionedVertices.length; j++) {\n\t\t\t\t\t\tconst srcBoneIndices = partitionedVertices[j].boneIndices;\n\t\t\t\t\t\tdstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tattrib = vertexArray[attribName];\n\t\t\t\t\tdata = attrib.data;\n\t\t\t\t\tcomponents = attrib.components;\n\n\t\t\t\t\tfor (j = 0; j < partitionedVertices.length; j++) {\n\t\t\t\t\t\tindex = partitionedVertices[j].index;\n\n\t\t\t\t\t\tfor (k = 0; k < components; k++) {\n\t\t\t\t\t\t\tsplitVertexArray[attribName].data.push(data[index * components + k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;\n\n\t\t\tfor (j = 0; j < partitions.length; j++) {\n\t\t\t\tpartition = partitions[j];\n\t\t\t\tmesh = {\n\t\t\t\t\taabb: {\n\t\t\t\t\t\tmin: [0, 0, 0],\n\t\t\t\t\t\tmax: [0, 0, 0]\n\t\t\t\t\t},\n\t\t\t\t\tvertices: splitVertexArray,\n\t\t\t\t\tskin: splitSkins[j],\n\t\t\t\t\tindices: partitionedIndices.splice(0, partition.indexCount),\n\t\t\t\t\ttype: 'triangles',\n\t\t\t\t\tbase: 0,\n\t\t\t\t\tcount: partition.indexCount\n\t\t\t\t};\n\t\t\t\tmeshes.push(mesh);\n\n\t\t\t\tfor (k = meshInstances.length - 1; k >= 0; k--) {\n\t\t\t\t\tif (meshInstances[k].mesh === partition.originalMesh) {\n\t\t\t\t\t\tmeshInstances.push({\n\t\t\t\t\t\t\tmesh: mesh,\n\t\t\t\t\t\t\tnode: meshInstances[k].node\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (materialMappings) {\n\t\t\t\t\t\t\tmaterialMappings.push({\n\t\t\t\t\t\t\t\tmaterial: materialMappings[k].material,\n\t\t\t\t\t\t\t\tpath: materialMappings[k].path\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (j = 0; j < partitions.length; j++) {\n\t\t\t\tpartition = partitions[j];\n\n\t\t\t\tfor (k = meshInstances.length - 1; k >= 0; k--) {\n\t\t\t\t\tif (meshInstances[k].mesh === partition.originalMesh) {\n\t\t\t\t\t\tmeshInstances.splice(k, 1);\n\n\t\t\t\t\t\tif (materialMappings) {\n\t\t\t\t\t\t\tmaterialMappings.splice(k, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treferencesToIndices(model);\n}\n\nconst JSON_PRIMITIVE_TYPE = {\n\t\"points\": PRIMITIVE_POINTS,\n\t\"lines\": PRIMITIVE_LINES,\n\t\"lineloop\": PRIMITIVE_LINELOOP,\n\t\"linestrip\": PRIMITIVE_LINESTRIP,\n\t\"triangles\": PRIMITIVE_TRIANGLES,\n\t\"trianglestrip\": PRIMITIVE_TRISTRIP,\n\t\"trianglefan\": PRIMITIVE_TRIFAN\n};\nconst JSON_VERTEX_ELEMENT_TYPE = {\n\t\"int8\": TYPE_INT8,\n\t\"uint8\": TYPE_UINT8,\n\t\"int16\": TYPE_INT16,\n\t\"uint16\": TYPE_UINT16,\n\t\"int32\": TYPE_INT32,\n\t\"uint32\": TYPE_UINT32,\n\t\"float32\": TYPE_FLOAT32\n};\n\nclass JsonModelParser {\n\tconstructor(device, defaultMaterial) {\n\t\tthis._device = device;\n\t\tthis._defaultMaterial = defaultMaterial;\n\t}\n\n\tparse(data) {\n\t\tconst modelData = data.model;\n\n\t\tif (!modelData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (modelData.version <= 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst nodes = this._parseNodes(data);\n\n\t\tconst skins = this._parseSkins(data, nodes);\n\n\t\tconst vertexBuffers = this._parseVertexBuffers(data);\n\n\t\tconst indices = this._parseIndexBuffers(data, vertexBuffers);\n\n\t\tconst morphs = this._parseMorphs(data, nodes, vertexBuffers);\n\n\t\tconst meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);\n\n\t\tconst meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);\n\n\t\tconst model = new Model();\n\t\tmodel.graph = nodes[0];\n\t\tmodel.meshInstances = meshInstances;\n\t\tmodel.skinInstances = skins.instances;\n\t\tmodel.morphInstances = morphs.instances;\n\t\tmodel.getGraph().syncHierarchy();\n\t\treturn model;\n\t}\n\n\t_parseNodes(data) {\n\t\tconst modelData = data.model;\n\t\tconst nodes = [];\n\t\tlet i;\n\n\t\tfor (i = 0; i < modelData.nodes.length; i++) {\n\t\t\tconst nodeData = modelData.nodes[i];\n\t\t\tconst node = new GraphNode(nodeData.name);\n\t\t\tnode.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);\n\t\t\tnode.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);\n\t\t\tnode.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);\n\t\t\tnode.scaleCompensation = !!nodeData.scaleCompensation;\n\t\t\tnodes.push(node);\n\t\t}\n\n\t\tfor (i = 1; i < modelData.parents.length; i++) {\n\t\t\tnodes[modelData.parents[i]].addChild(nodes[i]);\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t_parseSkins(data, nodes) {\n\t\tconst modelData = data.model;\n\t\tconst skins = [];\n\t\tconst skinInstances = [];\n\t\tlet i, j;\n\n\t\tif (!this._device.supportsBoneTextures && modelData.skins.length > 0) {\n\t\t\tconst boneLimit = this._device.getBoneLimit();\n\n\t\t\tpartitionSkin(modelData, null, boneLimit);\n\t\t}\n\n\t\tfor (i = 0; i < modelData.skins.length; i++) {\n\t\t\tconst skinData = modelData.skins[i];\n\t\t\tconst inverseBindMatrices = [];\n\n\t\t\tfor (j = 0; j < skinData.inverseBindMatrices.length; j++) {\n\t\t\t\tconst ibm = skinData.inverseBindMatrices[j];\n\t\t\t\tinverseBindMatrices[j] = new Mat4().set(ibm);\n\t\t\t}\n\n\t\t\tconst skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);\n\t\t\tskins.push(skin);\n\t\t\tconst skinInstance = new SkinInstance(skin);\n\t\t\tconst bones = [];\n\n\t\t\tfor (j = 0; j < skin.boneNames.length; j++) {\n\t\t\t\tconst boneName = skin.boneNames[j];\n\t\t\t\tconst bone = nodes[0].findByName(boneName);\n\t\t\t\tbones.push(bone);\n\t\t\t}\n\n\t\t\tskinInstance.bones = bones;\n\t\t\tskinInstances.push(skinInstance);\n\t\t}\n\n\t\treturn {\n\t\t\tskins: skins,\n\t\t\tinstances: skinInstances\n\t\t};\n\t}\n\n\t_getMorphVertexCount(modelData, morphIndex, vertexBuffers) {\n\t\tfor (let i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\n\t\t\tif (meshData.morph === morphIndex) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[meshData.vertices];\n\t\t\t\treturn vertexBuffer.numVertices;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t_parseMorphs(data, nodes, vertexBuffers) {\n\t\tconst modelData = data.model;\n\t\tconst morphs = [];\n\t\tconst morphInstances = [];\n\t\tlet i, j, vertexCount;\n\t\tlet targets, morphTarget, morphTargetArray;\n\n\t\tif (modelData.morphs) {\n\t\t\tconst sparseToFull = function sparseToFull(data, indices, totalCount) {\n\t\t\t\tconst full = new Float32Array(totalCount * 3);\n\n\t\t\t\tfor (let s = 0; s < indices.length; s++) {\n\t\t\t\t\tconst dstIndex = indices[s] * 3;\n\t\t\t\t\tfull[dstIndex] = data[s * 3];\n\t\t\t\t\tfull[dstIndex + 1] = data[s * 3 + 1];\n\t\t\t\t\tfull[dstIndex + 2] = data[s * 3 + 2];\n\t\t\t\t}\n\n\t\t\t\treturn full;\n\t\t\t};\n\n\t\t\tfor (i = 0; i < modelData.morphs.length; i++) {\n\t\t\t\ttargets = modelData.morphs[i].targets;\n\t\t\t\tmorphTargetArray = [];\n\t\t\t\tvertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);\n\n\t\t\t\tfor (j = 0; j < targets.length; j++) {\n\t\t\t\t\tconst targetAabb = targets[j].aabb;\n\t\t\t\t\tconst min = targetAabb.min;\n\t\t\t\t\tconst max = targetAabb.max;\n\t\t\t\t\tconst aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n\t\t\t\t\tconst indices = targets[j].indices;\n\t\t\t\t\tlet deltaPositions = targets[j].deltaPositions;\n\t\t\t\t\tlet deltaNormals = targets[j].deltaNormals;\n\n\t\t\t\t\tif (indices) {\n\t\t\t\t\t\tdeltaPositions = sparseToFull(deltaPositions, indices, vertexCount);\n\t\t\t\t\t\tdeltaNormals = sparseToFull(deltaNormals, indices, vertexCount);\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphTarget = new MorphTarget({\n\t\t\t\t\t\tdeltaPositions: deltaPositions,\n\t\t\t\t\t\tdeltaNormals: deltaNormals,\n\t\t\t\t\t\tname: targets[j].name,\n\t\t\t\t\t\taabb: aabb\n\t\t\t\t\t});\n\t\t\t\t\tmorphTargetArray.push(morphTarget);\n\t\t\t\t}\n\n\t\t\t\tconst morph = new Morph(morphTargetArray, this._device);\n\t\t\t\tmorphs.push(morph);\n\t\t\t\tconst morphInstance = new MorphInstance(morph);\n\t\t\t\tmorphInstances.push(morphInstance);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmorphs: morphs,\n\t\t\tinstances: morphInstances\n\t\t};\n\t}\n\n\t_parseVertexBuffers(data) {\n\t\tconst modelData = data.model;\n\t\tconst vertexBuffers = [];\n\t\tconst attributeMap = {\n\t\t\tposition: SEMANTIC_POSITION,\n\t\t\tnormal: SEMANTIC_NORMAL,\n\t\t\ttangent: SEMANTIC_TANGENT,\n\t\t\tblendWeight: SEMANTIC_BLENDWEIGHT,\n\t\t\tblendIndices: SEMANTIC_BLENDINDICES,\n\t\t\tcolor: SEMANTIC_COLOR,\n\t\t\ttexCoord0: SEMANTIC_TEXCOORD0,\n\t\t\ttexCoord1: SEMANTIC_TEXCOORD1,\n\t\t\ttexCoord2: SEMANTIC_TEXCOORD2,\n\t\t\ttexCoord3: SEMANTIC_TEXCOORD3,\n\t\t\ttexCoord4: SEMANTIC_TEXCOORD4,\n\t\t\ttexCoord5: SEMANTIC_TEXCOORD5,\n\t\t\ttexCoord6: SEMANTIC_TEXCOORD6,\n\t\t\ttexCoord7: SEMANTIC_TEXCOORD7\n\t\t};\n\n\t\tfor (let i = 0; i < modelData.vertices.length; i++) {\n\t\t\tconst vertexData = modelData.vertices[i];\n\t\t\tconst formatDesc = [];\n\n\t\t\tfor (const attributeName in vertexData) {\n\t\t\t\tconst attribute = vertexData[attributeName];\n\t\t\t\tformatDesc.push({\n\t\t\t\t\tsemantic: attributeMap[attributeName],\n\t\t\t\t\tcomponents: attribute.components,\n\t\t\t\t\ttype: JSON_VERTEX_ELEMENT_TYPE[attribute.type],\n\t\t\t\t\tnormalize: attributeMap[attributeName] === SEMANTIC_COLOR\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst vertexFormat = new VertexFormat(this._device, formatDesc);\n\t\t\tconst numVertices = vertexData.position.data.length / vertexData.position.components;\n\t\t\tconst vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);\n\t\t\tconst iterator = new VertexIterator(vertexBuffer);\n\n\t\t\tfor (let j = 0; j < numVertices; j++) {\n\t\t\t\tfor (const attributeName in vertexData) {\n\t\t\t\t\tconst attribute = vertexData[attributeName];\n\n\t\t\t\t\tswitch (attribute.components) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j]);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 2], 1.0 - attribute.data[j * 2 + 1]);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titerator.next();\n\t\t\t}\n\n\t\t\titerator.end();\n\t\t\tvertexBuffers.push(vertexBuffer);\n\t\t}\n\n\t\treturn vertexBuffers;\n\t}\n\n\t_parseIndexBuffers(data, vertexBuffers) {\n\t\tconst modelData = data.model;\n\t\tlet indexBuffer = null;\n\t\tlet indexData = null;\n\t\tlet i;\n\t\tlet numIndices = 0;\n\n\t\tfor (i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\n\t\t\tif (meshData.indices !== undefined) {\n\t\t\t\tnumIndices += meshData.indices.length;\n\t\t\t}\n\t\t}\n\n\t\tlet maxVerts = 0;\n\n\t\tfor (i = 0; i < vertexBuffers.length; i++) {\n\t\t\tmaxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);\n\t\t}\n\n\t\tif (numIndices > 0) {\n\t\t\tif (maxVerts > 0xFFFF && this._device.extUintElement) {\n\t\t\t\tindexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);\n\t\t\t\tindexData = new Uint32Array(indexBuffer.lock());\n\t\t\t} else {\n\t\t\t\tindexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);\n\t\t\t\tindexData = new Uint16Array(indexBuffer.lock());\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: indexBuffer,\n\t\t\tdata: indexData\n\t\t};\n\t}\n\n\t_parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {\n\t\tconst modelData = data.model;\n\t\tconst meshes = [];\n\t\tlet indexBase = 0;\n\n\t\tfor (let i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\t\t\tconst meshAabb = meshData.aabb;\n\t\t\tconst min = meshAabb.min;\n\t\t\tconst max = meshAabb.max;\n\t\t\tconst aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n\t\t\tconst indexed = meshData.indices !== undefined;\n\t\t\tconst mesh = new Mesh(this._device);\n\t\t\tmesh.vertexBuffer = vertexBuffers[meshData.vertices];\n\t\t\tmesh.indexBuffer[0] = indexed ? indexBuffer : null;\n\t\t\tmesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];\n\t\t\tmesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;\n\t\t\tmesh.primitive[0].count = meshData.count;\n\t\t\tmesh.primitive[0].indexed = indexed;\n\t\t\tmesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;\n\t\t\tmesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;\n\t\t\tmesh.aabb = aabb;\n\n\t\t\tif (indexed) {\n\t\t\t\tindexData.set(meshData.indices, indexBase);\n\t\t\t\tindexBase += meshData.indices.length;\n\t\t\t}\n\n\t\t\tmeshes.push(mesh);\n\t\t}\n\n\t\tif (indexBuffer !== null) {\n\t\t\tindexBuffer.unlock();\n\t\t}\n\n\t\treturn meshes;\n\t}\n\n\t_parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {\n\t\tconst modelData = data.model;\n\t\tconst meshInstances = [];\n\t\tlet i;\n\n\t\tfor (i = 0; i < modelData.meshInstances.length; i++) {\n\t\t\tconst meshInstanceData = modelData.meshInstances[i];\n\t\t\tconst node = nodes[meshInstanceData.node];\n\t\t\tconst mesh = meshes[meshInstanceData.mesh];\n\t\t\tconst meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);\n\n\t\t\tif (mesh.skin) {\n\t\t\t\tconst skinIndex = skins.indexOf(mesh.skin);\n\t\t\t\tmeshInstance.skinInstance = skinInstances[skinIndex];\n\t\t\t}\n\n\t\t\tif (mesh.morph) {\n\t\t\t\tconst morphIndex = morphs.indexOf(mesh.morph);\n\t\t\t\tmeshInstance.morphInstance = morphInstances[morphIndex];\n\t\t\t}\n\n\t\t\tmeshInstances.push(meshInstance);\n\t\t}\n\n\t\treturn meshInstances;\n\t}\n\n}\n\nclass ModelHandler {\n\tconstructor(device) {\n\t\tthis._device = device;\n\t\tthis._parsers = [];\n\t\tthis._defaultMaterial = DefaultMaterial.get(device);\n\t\tthis.maxRetries = 0;\n\t\tthis.addParser(new JsonModelParser(this._device, this._defaultMaterial), function (url, data) {\n\t\t\treturn path.getExtension(url) === '.json';\n\t\t});\n\t\tthis.addParser(new GlbModelParser(this._device, this._defaultMaterial), function (url, data) {\n\t\t\treturn path.getExtension(url) === '.glb';\n\t\t});\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:') || url.load.startsWith('data:')) {\n\t\t\tif (path.getExtension(url.original).toLowerCase() === '.glb') {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t} else {\n\t\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t\t}\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (!callback) return;\n\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading model: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\tfor (let i = 0; i < this._parsers.length; i++) {\n\t\t\tconst p = this._parsers[i];\n\n\t\t\tif (p.decider(url, data)) {\n\t\t\t\treturn p.parser.parse(data);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpatch(asset, assets) {\n\t\tif (!asset.resource) return;\n\t\tconst data = asset.data;\n\t\tconst self = this;\n\t\tasset.resource.meshInstances.forEach(function (meshInstance, i) {\n\t\t\tif (data.mapping) {\n\t\t\t\tconst handleMaterial = function handleMaterial(asset) {\n\t\t\t\t\tif (asset.resource) {\n\t\t\t\t\t\tmeshInstance.material = asset.resource;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasset.once('load', handleMaterial);\n\t\t\t\t\t\tassets.load(asset);\n\t\t\t\t\t}\n\n\t\t\t\t\tasset.once('remove', function (asset) {\n\t\t\t\t\t\tif (meshInstance.material === asset.resource) {\n\t\t\t\t\t\t\tmeshInstance.material = self._defaultMaterial;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tif (!data.mapping[i]) {\n\t\t\t\t\tmeshInstance.material = self._defaultMaterial;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst id = data.mapping[i].material;\n\t\t\t\tconst url = data.mapping[i].path;\n\t\t\t\tlet material;\n\n\t\t\t\tif (id !== undefined) {\n\t\t\t\t\tif (!id) {\n\t\t\t\t\t\tmeshInstance.material = self._defaultMaterial;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmaterial = assets.get(id);\n\n\t\t\t\t\t\tif (material) {\n\t\t\t\t\t\t\thandleMaterial(material);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassets.once('add:' + id, handleMaterial);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (url) {\n\t\t\t\t\tconst path = asset.getAbsoluteUrl(data.mapping[i].path);\n\t\t\t\t\tmaterial = assets.getByUrl(path);\n\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\thandleMaterial(material);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassets.once('add:url:' + path, handleMaterial);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\taddParser(parser, decider) {\n\t\tthis._parsers.push({\n\t\t\tparser: parser,\n\t\t\tdecider: decider\n\t\t});\n\t}\n\n}\n\nfunction onContainerAssetLoaded(containerAsset) {\n\tconst renderAsset = this;\n\tif (!renderAsset.resource) return;\n\tconst containerResource = containerAsset.resource;\n\tconst render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];\n\n\tif (render) {\n\t\trenderAsset.resource.meshes = render.resource.meshes;\n\t}\n}\n\nfunction onContainerAssetAdded(containerAsset) {\n\tconst renderAsset = this;\n\trenderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n\trenderAsset.registry.on('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n\trenderAsset.registry.off('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);\n\trenderAsset.registry.once('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);\n\n\tif (!containerAsset.resource) {\n\t\trenderAsset.registry.load(containerAsset);\n\t} else {\n\t\tonContainerAssetLoaded.call(renderAsset, containerAsset);\n\t}\n}\n\nfunction onContainerAssetRemoved(containerAsset) {\n\tconst renderAsset = this;\n\trenderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n\n\tif (renderAsset.resource) {\n\t\trenderAsset.resource.destroy();\n\t}\n}\n\nclass RenderHandler {\n\tconstructor(assets) {\n\t\tthis._registry = assets;\n\t}\n\n\tload(url, callback, asset) {}\n\n\topen(url, data) {\n\t\treturn new Render();\n\t}\n\n\tpatch(asset, registry) {\n\t\tif (!asset.data.containerAsset) return;\n\t\tconst containerAsset = registry.get(asset.data.containerAsset);\n\n\t\tif (!containerAsset) {\n\t\t\tregistry.once('add:' + asset.data.containerAsset, onContainerAssetAdded, asset);\n\t\t\treturn;\n\t\t}\n\n\t\tonContainerAssetAdded.call(asset, containerAsset);\n\t}\n\n}\n\nclass ResourceLoader {\n\tconstructor(app) {\n\t\tthis._handlers = {};\n\t\tthis._requests = {};\n\t\tthis._cache = {};\n\t\tthis._app = app;\n\t}\n\n\taddHandler(type, handler) {\n\t\tthis._handlers[type] = handler;\n\t\thandler._loader = this;\n\t}\n\n\tremoveHandler(type) {\n\t\tdelete this._handlers[type];\n\t}\n\n\tgetHandler(type) {\n\t\treturn this._handlers[type];\n\t}\n\n\tload(url, type, callback, asset) {\n\t\tconst handler = this._handlers[type];\n\n\t\tif (!handler) {\n\t\t\tconst err = \"No handler for asset type: \" + type;\n\t\t\tcallback(err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!url) {\n\t\t\tthis._loadNull(handler, callback, asset);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst key = url + type;\n\n\t\tif (this._cache[key] !== undefined) {\n\t\t\tcallback(null, this._cache[key]);\n\t\t} else if (this._requests[key]) {\n\t\t\tthis._requests[key].push(callback);\n\t\t} else {\n\t\t\tthis._requests[key] = [callback];\n\t\t\tconst self = this;\n\n\t\t\tconst handleLoad = function handleLoad(err, urlObj) {\n\t\t\t\tif (err) {\n\t\t\t\t\tself._onFailure(key, err);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\thandler.load(urlObj, function (err, data, extra) {\n\t\t\t\t\tif (!self._requests[key]) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tself._onFailure(key, err);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tself._onSuccess(key, handler.open(urlObj.original, data, asset), extra);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tself._onFailure(key, e);\n\t\t\t\t\t}\n\t\t\t\t}, asset);\n\t\t\t};\n\n\t\t\tconst normalizedUrl = url.split('?')[0];\n\n\t\t\tif (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {\n\t\t\t\tif (!this._app.bundles.canLoadUrl(normalizedUrl)) {\n\t\t\t\t\thandleLoad(`Bundle for ${url} not loaded yet`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {\n\t\t\t\t\thandleLoad(err, {\n\t\t\t\t\t\tload: fileUrlFromBundle,\n\t\t\t\t\t\toriginal: normalizedUrl\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\thandleLoad(null, {\n\t\t\t\t\tload: url,\n\t\t\t\t\toriginal: asset && asset.file.filename || url\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t_loadNull(handler, callback, asset) {\n\t\tconst onLoad = function onLoad(err, data, extra) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(null, handler.open(null, data, asset), extra);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\thandler.load(null, onLoad, asset);\n\t}\n\n\t_onSuccess(key, result, extra) {\n\t\tthis._cache[key] = result;\n\n\t\tfor (let i = 0; i < this._requests[key].length; i++) {\n\t\t\tthis._requests[key][i](null, result, extra);\n\t\t}\n\n\t\tdelete this._requests[key];\n\t}\n\n\t_onFailure(key, err) {\n\t\tconsole.error(err);\n\n\t\tif (this._requests[key]) {\n\t\t\tfor (let i = 0; i < this._requests[key].length; i++) {\n\t\t\t\tthis._requests[key][i](err);\n\t\t\t}\n\n\t\t\tdelete this._requests[key];\n\t\t}\n\t}\n\n\topen(type, data) {\n\t\tconst handler = this._handlers[type];\n\n\t\tif (!handler) {\n\t\t\tconsole.warn(\"No resource handler found for: \" + type);\n\t\t\treturn data;\n\t\t}\n\n\t\treturn handler.open(null, data);\n\t}\n\n\tpatch(asset, assets) {\n\t\tconst handler = this._handlers[asset.type];\n\n\t\tif (!handler) {\n\t\t\tconsole.warn(\"No resource handler found for: \" + asset.type);\n\t\t\treturn;\n\t\t}\n\n\t\tif (handler.patch) {\n\t\t\thandler.patch(asset, assets);\n\t\t}\n\t}\n\n\tclearCache(url, type) {\n\t\tdelete this._cache[url + type];\n\t}\n\n\tgetFromCache(url, type) {\n\t\tif (this._cache[url + type]) {\n\t\t\treturn this._cache[url + type];\n\t\t}\n\t}\n\n\tenableRetry(maxRetries = 5) {\n\t\tmaxRetries = Math.max(0, maxRetries) || 0;\n\n\t\tfor (const key in this._handlers) {\n\t\t\tthis._handlers[key].maxRetries = maxRetries;\n\t\t}\n\t}\n\n\tdisableRetry() {\n\t\tfor (const key in this._handlers) {\n\t\t\tthis._handlers[key].maxRetries = 0;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._handlers = {};\n\t\tthis._requests = {};\n\t\tthis._cache = {};\n\t}\n\n}\n\nclass SceneHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tSceneUtils.load(url, this.maxRetries, callback);\n\t}\n\n\topen(url, data) {\n\t\tthis._app.systems.script.preloading = true;\n\t\tconst parser = new SceneParser(this._app, false);\n\t\tconst parent = parser.parse(data);\n\t\tconst scene = this._app.scene;\n\t\tscene.root = parent;\n\n\t\tthis._app.applySceneSettings(data.settings);\n\n\t\tthis._app.systems.script.preloading = false;\n\t\treturn scene;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nlet _legacy = false;\nlet _createdLoadingScreen = false;\nconst script = {\n\tapp: null,\n\tcreate: function (name, callback) {\n\t\tif (!_legacy) return;\n\t\tconst ScriptType = callback(script.app);\n\t\tScriptType._pcScriptName = name;\n\n\t\tScriptHandler._push(ScriptType);\n\n\t\tthis.fire(\"created\", name, callback);\n\t},\n\tattribute: function (name, type, defaultValue, options) {},\n\tcreateLoadingScreen: function (callback) {\n\t\tif (_createdLoadingScreen) return;\n\t\t_createdLoadingScreen = true;\n\t\tconst app = getApplication();\n\t\tcallback(app);\n\t}\n};\nObject.defineProperty(script, 'legacy', {\n\tget: function () {\n\t\treturn _legacy;\n\t},\n\tset: function (value) {\n\t\t_legacy = value;\n\t}\n});\nevents.attach(script);\n\nclass ScriptHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis._scripts = {};\n\t\tthis._cache = {};\n\t}\n\n\tstatic _push(Type) {\n\t\tif (script.legacy && ScriptHandler._types.length > 0) {\n\t\t\tconsole.assert(\"Script Ordering Error. Contact support@playcanvas.com\");\n\t\t} else {\n\t\t\tScriptHandler._types.push(Type);\n\t\t}\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\t\tscript.app = this._app;\n\n\t\tthis._loadScript(url.load, (err, url, extra) => {\n\t\t\tif (!err) {\n\t\t\t\tif (script.legacy) {\n\t\t\t\t\tlet Type = null;\n\n\t\t\t\t\tif (ScriptHandler._types.length) {\n\t\t\t\t\t\tType = ScriptHandler._types.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Type) {\n\t\t\t\t\t\tthis._scripts[url] = Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tType = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback(null, Type, extra);\n\t\t\t\t} else {\n\t\t\t\t\tconst obj = {};\n\n\t\t\t\t\tfor (let i = 0; i < ScriptHandler._types.length; i++) obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];\n\n\t\t\t\t\tScriptHandler._types.length = 0;\n\t\t\t\t\tcallback(null, obj, extra);\n\t\t\t\t\tdelete self._loader._cache[url + 'script'];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcallback(err);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n\t_loadScript(url, callback) {\n\t\tconst head = document.head;\n\t\tconst element = document.createElement('script');\n\t\tthis._cache[url] = element;\n\t\telement.async = false;\n\t\telement.addEventListener('error', function (e) {\n\t\t\tcallback(`Script: ${e.target.src} failed to load`);\n\t\t}, false);\n\t\tlet done = false;\n\n\t\telement.onload = element.onreadystatechange = function () {\n\t\t\tif (!done && (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\")) {\n\t\t\t\tdone = true;\n\t\t\t\tcallback(null, url, element);\n\t\t\t}\n\t\t};\n\n\t\telement.src = url;\n\t\thead.appendChild(element);\n\t}\n\n}\n\nScriptHandler._types = [];\n\nclass ShaderHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading shader resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nconst spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\nconst spriteIndices = [0, 1, 3, 2, 3, 1];\n\nclass Sprite extends EventHandler {\n\tconstructor(device, options) {\n\t\tsuper();\n\t\tthis._device = device;\n\t\tthis._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;\n\t\tthis._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;\n\t\tthis._atlas = options && options.atlas !== undefined ? options.atlas : null;\n\t\tthis._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;\n\t\tthis._meshes = [];\n\t\tthis._updatingProperties = false;\n\t\tthis._meshesDirty = false;\n\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tthis._createMeshes();\n\t\t}\n\t}\n\n\tset frameKeys(value) {\n\t\tthis._frameKeys = value;\n\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('set:frameKeys', value);\n\t}\n\n\tget frameKeys() {\n\t\treturn this._frameKeys;\n\t}\n\n\tset atlas(value) {\n\t\tif (value === this._atlas) return;\n\n\t\tif (this._atlas) {\n\t\t\tthis._atlas.off('set:frames', this._onSetFrames, this);\n\n\t\t\tthis._atlas.off('set:frame', this._onFrameChanged, this);\n\n\t\t\tthis._atlas.off('remove:frame', this._onFrameRemoved, this);\n\t\t}\n\n\t\tthis._atlas = value;\n\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tthis._atlas.on('set:frames', this._onSetFrames, this);\n\n\t\t\tthis._atlas.on('set:frame', this._onFrameChanged, this);\n\n\t\t\tthis._atlas.on('remove:frame', this._onFrameRemoved, this);\n\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('set:atlas', value);\n\t}\n\n\tget atlas() {\n\t\treturn this._atlas;\n\t}\n\n\tset pixelsPerUnit(value) {\n\t\tif (this._pixelsPerUnit === value) return;\n\t\tthis._pixelsPerUnit = value;\n\t\tthis.fire('set:pixelsPerUnit', value);\n\n\t\tif (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\t}\n\n\tget pixelsPerUnit() {\n\t\treturn this._pixelsPerUnit;\n\t}\n\n\tset renderMode(value) {\n\t\tif (this._renderMode === value) return;\n\t\tconst prev = this._renderMode;\n\t\tthis._renderMode = value;\n\t\tthis.fire('set:renderMode', value);\n\n\t\tif (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\tif (this._atlas && this._frameKeys) {\n\t\t\t\tif (this._updatingProperties) {\n\t\t\t\t\tthis._meshesDirty = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._createMeshes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget renderMode() {\n\t\treturn this._renderMode;\n\t}\n\n\tget meshes() {\n\t\treturn this._meshes;\n\t}\n\n\t_createMeshes() {\n\t\tconst len = this._meshes.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst mesh = this._meshes[i];\n\n\t\t\tif (mesh) {\n\t\t\t\tmesh.destroy();\n\t\t\t}\n\t\t}\n\n\t\tconst count = this._frameKeys.length;\n\t\tthis._meshes = new Array(count);\n\t\tconst createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst frame = this._atlas.frames[this._frameKeys[i]];\n\t\t\tthis._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;\n\t\t}\n\n\t\tthis.fire('set:meshes');\n\t}\n\n\t_createSimpleMesh(frame) {\n\t\tconst rect = frame.rect;\n\t\tconst texWidth = this._atlas.texture.width;\n\t\tconst texHeight = this._atlas.texture.height;\n\t\tconst w = rect.z / this._pixelsPerUnit;\n\t\tconst h = rect.w / this._pixelsPerUnit;\n\t\tconst hp = frame.pivot.x;\n\t\tconst vp = frame.pivot.y;\n\t\tconst positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];\n\t\tconst lu = rect.x / texWidth;\n\t\tconst bv = 1.0 - rect.y / texHeight;\n\t\tconst ru = (rect.x + rect.z) / texWidth;\n\t\tconst tv = 1.0 - (rect.y + rect.w) / texHeight;\n\t\tconst uvs = [lu, bv, ru, bv, ru, tv, lu, tv];\n\t\tconst mesh = createMesh$1(this._device, positions, {\n\t\t\tuvs: uvs,\n\t\t\tnormals: spriteNormals,\n\t\t\tindices: spriteIndices\n\t\t});\n\t\treturn mesh;\n\t}\n\n\t_create9SliceMesh() {\n\t\tconst he = Vec2.ONE;\n\t\tconst ws = 3;\n\t\tconst ls = 3;\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\t\tlet vcounter = 0;\n\n\t\tfor (let i = 0; i <= ws; i++) {\n\t\t\tconst u = i === 0 || i === ws ? 0 : 1;\n\n\t\t\tfor (let j = 0; j <= ls; j++) {\n\t\t\t\tconst x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;\n\t\t\t\tconst y = 0.0;\n\t\t\t\tconst z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);\n\t\t\t\tconst v = j === 0 || j === ls ? 0 : 1;\n\t\t\t\tpositions.push(-x, y, z);\n\t\t\t\tnormals.push(0.0, 1.0, 0.0);\n\t\t\t\tuvs.push(u, v);\n\n\t\t\t\tif (i < ws && j < ls) {\n\t\t\t\t\tindices.push(vcounter + ls + 1, vcounter + 1, vcounter);\n\t\t\t\t\tindices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);\n\t\t\t\t}\n\n\t\t\t\tvcounter++;\n\t\t\t}\n\t\t}\n\n\t\tconst options = {\n\t\t\tnormals: normals,\n\t\t\tuvs: uvs,\n\t\t\tindices: indices\n\t\t};\n\t\treturn createMesh$1(this._device, positions, options);\n\t}\n\n\t_onSetFrames(frames) {\n\t\tif (this._updatingProperties) {\n\t\t\tthis._meshesDirty = true;\n\t\t} else {\n\t\t\tthis._createMeshes();\n\t\t}\n\t}\n\n\t_onFrameChanged(frameKey, frame) {\n\t\tconst idx = this._frameKeys.indexOf(frameKey);\n\n\t\tif (idx < 0) return;\n\n\t\tif (frame) {\n\t\t\tif (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\t\tthis._meshes[idx] = this._createSimpleMesh(frame);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._meshes[idx] = null;\n\t\t}\n\n\t\tthis.fire('set:meshes');\n\t}\n\n\t_onFrameRemoved(frameKey) {\n\t\tconst idx = this._frameKeys.indexOf(frameKey);\n\n\t\tif (idx < 0) return;\n\t\tthis._meshes[idx] = null;\n\t\tthis.fire('set:meshes');\n\t}\n\n\tstartUpdate() {\n\t\tthis._updatingProperties = true;\n\t\tthis._meshesDirty = false;\n\t}\n\n\tendUpdate() {\n\t\tthis._updatingProperties = false;\n\n\t\tif (this._meshesDirty && this._atlas && this._frameKeys) {\n\t\t\tthis._createMeshes();\n\t\t}\n\n\t\tthis._meshesDirty = false;\n\t}\n\n\tdestroy() {\n\t\tfor (const mesh of this._meshes) {\n\t\t\tif (mesh) mesh.destroy();\n\t\t}\n\n\t\tthis._meshes.length = 0;\n\t}\n\n}\n\nfunction onTextureAtlasLoaded(atlasAsset) {\n\tconst spriteAsset = this;\n\n\tif (spriteAsset.resource) {\n\t\tspriteAsset.resource.atlas = atlasAsset.resource;\n\t}\n}\n\nfunction onTextureAtlasAdded(atlasAsset) {\n\tconst spriteAsset = this;\n\tspriteAsset.registry.load(atlasAsset);\n}\n\nclass SpriteHandler {\n\tconstructor(assets, device) {\n\t\tthis._assets = assets;\n\t\tthis._device = device;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, function (err, response) {\n\t\t\t\tif (!err) {\n\t\t\t\t\tcallback(null, response);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\topen(url, data) {\n\t\tconst sprite = new Sprite(this._device);\n\n\t\tif (url) {\n\t\t\tsprite.__data = data;\n\t\t}\n\n\t\treturn sprite;\n\t}\n\n\tpatch(asset, assets) {\n\t\tconst sprite = asset.resource;\n\n\t\tif (sprite.__data) {\n\t\t\tasset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;\n\t\t\tasset.data.renderMode = sprite.__data.renderMode;\n\t\t\tasset.data.frameKeys = sprite.__data.frameKeys;\n\n\t\t\tif (sprite.__data.textureAtlasAsset) {\n\t\t\t\tconst atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);\n\n\t\t\t\tif (atlas) {\n\t\t\t\t\tasset.data.textureAtlasAsset = atlas.id;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"Could not find textureatlas with url: \" + sprite.__data.textureAtlasAsset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsprite.startUpdate();\n\t\tsprite.renderMode = asset.data.renderMode;\n\t\tsprite.pixelsPerUnit = asset.data.pixelsPerUnit;\n\t\tsprite.frameKeys = asset.data.frameKeys;\n\n\t\tthis._updateAtlas(asset);\n\n\t\tsprite.endUpdate();\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t}\n\n\t_updateAtlas(asset) {\n\t\tconst sprite = asset.resource;\n\n\t\tif (!asset.data.textureAtlasAsset) {\n\t\t\tsprite.atlas = null;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);\n\n\t\tthis._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);\n\n\t\tconst atlasAsset = this._assets.get(asset.data.textureAtlasAsset);\n\n\t\tif (atlasAsset && atlasAsset.resource) {\n\t\t\tsprite.atlas = atlasAsset.resource;\n\t\t} else {\n\t\t\tif (!atlasAsset) {\n\t\t\t\tthis._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);\n\n\t\t\t\tthis._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);\n\t\t\t} else {\n\t\t\t\tthis._assets.load(atlasAsset);\n\t\t\t}\n\t\t}\n\t}\n\n\t_onAssetChange(asset, attribute, value, oldValue) {\n\t\tif (attribute === 'data') {\n\t\t\tif (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {\n\t\t\t\tthis._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);\n\n\t\t\t\tthis._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass Template {\n\tconstructor(app, data) {\n\t\tthis._app = app;\n\t\tthis._data = data;\n\t\tthis._templateRoot = null;\n\t}\n\n\tinstantiate() {\n\t\tif (!this._templateRoot) {\n\t\t\tthis._parseTemplate();\n\t\t}\n\n\t\treturn this._templateRoot.clone();\n\t}\n\n\t_parseTemplate() {\n\t\tconst parser = new SceneParser(this._app, true);\n\t\tthis._templateRoot = parser.parse(this._data);\n\t}\n\n}\n\nclass TemplateHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tcallback(\"Error requesting template: \" + url.original);\n\t\t\t} else {\n\t\t\t\tcallback(err, response);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn new Template(this._app, data);\n\t}\n\n}\n\nclass TextHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading text resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass TextureAtlas extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._texture = null;\n\t\tthis._frames = null;\n\t}\n\n\tset texture(value) {\n\t\tthis._texture = value;\n\t\tthis.fire('set:texture', value);\n\t}\n\n\tget texture() {\n\t\treturn this._texture;\n\t}\n\n\tset frames(value) {\n\t\tthis._frames = value;\n\t\tthis.fire('set:frames', value);\n\t}\n\n\tget frames() {\n\t\treturn this._frames;\n\t}\n\n\tsetFrame(key, data) {\n\t\tlet frame = this._frames[key];\n\n\t\tif (!frame) {\n\t\t\tframe = {\n\t\t\t\trect: data.rect.clone(),\n\t\t\t\tpivot: data.pivot.clone(),\n\t\t\t\tborder: data.border.clone()\n\t\t\t};\n\t\t\tthis._frames[key] = frame;\n\t\t} else {\n\t\t\tframe.rect.copy(data.rect);\n\t\t\tframe.pivot.copy(data.pivot);\n\t\t\tframe.border.copy(data.border);\n\t\t}\n\n\t\tthis.fire('set:frame', key.toString(), frame);\n\t}\n\n\tremoveFrame(key) {\n\t\tconst frame = this._frames[key];\n\n\t\tif (frame) {\n\t\t\tdelete this._frames[key];\n\t\t\tthis.fire('remove:frame', key.toString(), frame);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this._texture) {\n\t\t\tthis._texture.destroy();\n\t\t}\n\t}\n\n}\n\nconst JSON_ADDRESS_MODE$1 = {\n\t\"repeat\": ADDRESS_REPEAT,\n\t\"clamp\": ADDRESS_CLAMP_TO_EDGE,\n\t\"mirror\": ADDRESS_MIRRORED_REPEAT\n};\nconst JSON_FILTER_MODE$1 = {\n\t\"nearest\": FILTER_NEAREST,\n\t\"linear\": FILTER_LINEAR,\n\t\"nearest_mip_nearest\": FILTER_NEAREST_MIPMAP_NEAREST,\n\t\"linear_mip_nearest\": FILTER_LINEAR_MIPMAP_NEAREST,\n\t\"nearest_mip_linear\": FILTER_NEAREST_MIPMAP_LINEAR,\n\t\"linear_mip_linear\": FILTER_LINEAR_MIPMAP_LINEAR\n};\nconst regexFrame = /^data\\.frames\\.(\\d+)$/;\n\nclass TextureAtlasHandler {\n\tconstructor(loader) {\n\t\tthis._loader = loader;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\n\t\tconst handler = this._loader.getHandler(\"texture\");\n\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, function (err, response) {\n\t\t\t\tif (!err) {\n\t\t\t\t\tconst textureUrl = url.original.replace('.json', '.png');\n\n\t\t\t\t\tself._loader.load(textureUrl, \"texture\", function (err, texture) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\tdata: response,\n\t\t\t\t\t\t\t\ttexture: texture\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn handler.load(url, callback);\n\t\t}\n\t}\n\n\topen(url, data) {\n\t\tconst resource = new TextureAtlas();\n\n\t\tif (data.texture && data.data) {\n\t\t\tresource.texture = data.texture;\n\t\t\tresource.__data = data.data;\n\t\t} else {\n\t\t\tconst handler = this._loader.getHandler(\"texture\");\n\n\t\t\tconst texture = handler.open(url, data);\n\t\t\tif (!texture) return null;\n\t\t\tresource.texture = texture;\n\t\t}\n\n\t\treturn resource;\n\t}\n\n\tpatch(asset, assets) {\n\t\tif (asset.resource.__data) {\n\t\t\tif (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;\n\t\t\tif (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;\n\t\t\tif (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;\n\t\t\tif (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;\n\t\t\tif (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;\n\t\t\tif (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;\n\t\t\tif (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;\n\t\t\tasset.data.frames = asset.resource.__data.frames;\n\t\t\tdelete asset.resource.__data;\n\t\t}\n\n\t\tconst texture = asset.resource.texture;\n\n\t\tif (texture) {\n\t\t\ttexture.name = asset.name;\n\t\t\tif (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];\n\t\t\tif (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];\n\t\t\tif (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];\n\t\t\tif (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];\n\t\t\tif (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) texture.mipmaps = asset.data.mipmaps;\n\t\t\tif (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) texture.anisotropy = asset.data.anisotropy;\n\n\t\t\tif (asset.data.hasOwnProperty('rgbm')) {\n\t\t\t\tconst type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\n\t\t\t\tif (texture.type !== type) {\n\t\t\t\t\ttexture.type = type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasset.resource.texture = texture;\n\t\tconst frames = {};\n\n\t\tfor (const key in asset.data.frames) {\n\t\t\tconst frame = asset.data.frames[key];\n\t\t\tframes[key] = {\n\t\t\t\trect: new Vec4(frame.rect),\n\t\t\t\tpivot: new Vec2(frame.pivot),\n\t\t\t\tborder: new Vec4(frame.border)\n\t\t\t};\n\t\t}\n\n\t\tasset.resource.frames = frames;\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t}\n\n\t_onAssetChange(asset, attribute, value) {\n\t\tlet frame;\n\n\t\tif (attribute === 'data' || attribute === 'data.frames') {\n\t\t\tconst frames = {};\n\n\t\t\tfor (const key in value.frames) {\n\t\t\t\tframe = value.frames[key];\n\t\t\t\tframes[key] = {\n\t\t\t\t\trect: new Vec4(frame.rect),\n\t\t\t\t\tpivot: new Vec2(frame.pivot),\n\t\t\t\t\tborder: new Vec4(frame.border)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tasset.resource.frames = frames;\n\t\t} else {\n\t\t\tconst match = attribute.match(regexFrame);\n\n\t\t\tif (match) {\n\t\t\t\tconst frameKey = match[1];\n\n\t\t\t\tif (value) {\n\t\t\t\t\tif (!asset.resource.frames[frameKey]) {\n\t\t\t\t\t\tasset.resource.frames[frameKey] = {\n\t\t\t\t\t\t\trect: new Vec4(value.rect),\n\t\t\t\t\t\t\tpivot: new Vec2(value.pivot),\n\t\t\t\t\t\t\tborder: new Vec4(value.border)\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tframe = asset.resource.frames[frameKey];\n\t\t\t\t\t\tframe.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);\n\t\t\t\t\t\tframe.pivot.set(value.pivot[0], value.pivot[1]);\n\t\t\t\t\t\tframe.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);\n\t\t\t\t\t}\n\n\t\t\t\t\tasset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);\n\t\t\t\t} else {\n\t\t\t\t\tif (asset.resource.frames[frameKey]) {\n\t\t\t\t\t\tdelete asset.resource.frames[frameKey];\n\t\t\t\t\t\tasset.resource.fire('remove:frame', frameKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunction BasisWorker() {\n\tconst BASIS_FORMAT = {\n\t\tcTFETC1: 0,\n\t\tcTFETC2: 1,\n\t\tcTFBC1: 2,\n\t\tcTFBC3: 3,\n\t\tcTFPVRTC1_4_RGB: 8,\n\t\tcTFPVRTC1_4_RGBA: 9,\n\t\tcTFASTC_4x4: 10,\n\t\tcTFATC_RGB: 11,\n\t\tcTFATC_RGBA_INTERPOLATED_ALPHA: 12,\n\t\tcTFRGBA32: 13,\n\t\tcTFRGB565: 14,\n\t\tcTFRGBA4444: 16\n\t};\n\tconst opaqueMapping = {\n\t\tastc: BASIS_FORMAT.cTFASTC_4x4,\n\t\tdxt: BASIS_FORMAT.cTFBC1,\n\t\tetc1: BASIS_FORMAT.cTFETC1,\n\t\tetc2: BASIS_FORMAT.cTFETC1,\n\t\tpvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,\n\t\tatc: BASIS_FORMAT.cTFATC_RGB,\n\t\tnone: BASIS_FORMAT.cTFRGB565\n\t};\n\tconst alphaMapping = {\n\t\tastc: BASIS_FORMAT.cTFASTC_4x4,\n\t\tdxt: BASIS_FORMAT.cTFBC3,\n\t\tetc1: BASIS_FORMAT.cTFRGBA4444,\n\t\tetc2: BASIS_FORMAT.cTFETC2,\n\t\tpvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,\n\t\tatc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,\n\t\tnone: BASIS_FORMAT.cTFRGBA4444\n\t};\n\tconst PIXEL_FORMAT = {\n\t\tETC1: 21,\n\t\tETC2_RGB: 22,\n\t\tETC2_RGBA: 23,\n\t\tDXT1: 8,\n\t\tDXT5: 10,\n\t\tPVRTC_4BPP_RGB_1: 26,\n\t\tPVRTC_4BPP_RGBA_1: 27,\n\t\tASTC_4x4: 28,\n\t\tATC_RGB: 29,\n\t\tATC_RGBA: 30,\n\t\tR8_G8_B8_A8: 7,\n\t\tR5_G6_B5: 3,\n\t\tR4_G4_B4_A4: 5\n\t};\n\n\tconst basisToEngineMapping = (basisFormat, deviceDetails) => {\n\t\tswitch (basisFormat) {\n\t\t\tcase BASIS_FORMAT.cTFETC1:\n\t\t\t\treturn deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;\n\n\t\t\tcase BASIS_FORMAT.cTFETC2:\n\t\t\t\treturn PIXEL_FORMAT.ETC2_RGBA;\n\n\t\t\tcase BASIS_FORMAT.cTFBC1:\n\t\t\t\treturn PIXEL_FORMAT.DXT1;\n\n\t\t\tcase BASIS_FORMAT.cTFBC3:\n\t\t\t\treturn PIXEL_FORMAT.DXT5;\n\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGB:\n\t\t\t\treturn PIXEL_FORMAT.PVRTC_4BPP_RGB_1;\n\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGBA:\n\t\t\t\treturn PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;\n\n\t\t\tcase BASIS_FORMAT.cTFASTC_4x4:\n\t\t\t\treturn PIXEL_FORMAT.ASTC_4x4;\n\n\t\t\tcase BASIS_FORMAT.cTFATC_RGB:\n\t\t\t\treturn PIXEL_FORMAT.ATC_RGB;\n\n\t\t\tcase BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:\n\t\t\t\treturn PIXEL_FORMAT.ATC_RGBA;\n\n\t\t\tcase BASIS_FORMAT.cTFRGBA32:\n\t\t\t\treturn PIXEL_FORMAT.R8_G8_B8_A8;\n\n\t\t\tcase BASIS_FORMAT.cTFRGB565:\n\t\t\t\treturn PIXEL_FORMAT.R5_G6_B5;\n\n\t\t\tcase BASIS_FORMAT.cTFRGBA4444:\n\t\t\t\treturn PIXEL_FORMAT.R4_G4_B4_A4;\n\t\t}\n\t};\n\n\tconst unswizzleGGGR = data => {\n\t\tconst genB = function genB(R, G) {\n\t\t\tconst r = R * (2.0 / 255.0) - 1.0;\n\t\t\tconst g = G * (2.0 / 255.0) - 1.0;\n\t\t\tconst b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));\n\t\t\treturn Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));\n\t\t};\n\n\t\tfor (let offset = 0; offset < data.length; offset += 4) {\n\t\t\tconst R = data[offset + 3];\n\t\t\tconst G = data[offset + 1];\n\t\t\tdata[offset + 0] = R;\n\t\t\tdata[offset + 2] = genB(R, G);\n\t\t\tdata[offset + 3] = 255;\n\t\t}\n\n\t\treturn data;\n\t};\n\n\tconst pack565 = data => {\n\t\tconst result = new Uint16Array(data.length / 4);\n\n\t\tfor (let offset = 0; offset < data.length; offset += 4) {\n\t\t\tconst R = data[offset + 0];\n\t\t\tconst G = data[offset + 1];\n\t\t\tconst B = data[offset + 2];\n\t\t\tresult[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tconst isPOT = (width, height) => {\n\t\treturn (width & width - 1) === 0 && (height & height - 1) === 0;\n\t};\n\n\tconst performanceNow = () => {\n\t\treturn typeof performance !== 'undefined' ? performance.now() : 0;\n\t};\n\n\tlet basis;\n\tlet rgbPriority;\n\tlet rgbaPriority;\n\n\tconst chooseTargetFormat = (deviceDetails, hasAlpha, isUASTC) => {\n\t\tif (isUASTC) {\n\t\t\tif (deviceDetails.formats.astc) {\n\t\t\t\treturn 'astc';\n\t\t\t}\n\t\t} else {\n\t\t\tif (hasAlpha) {\n\t\t\t\tif (deviceDetails.formats.etc2) {\n\t\t\t\t\treturn 'etc2';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {\n\t\t\t\t\treturn 'etc1';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst testInOrder = priority => {\n\t\t\tfor (let i = 0; i < priority.length; ++i) {\n\t\t\t\tconst format = priority[i];\n\n\t\t\t\tif (deviceDetails.formats[format]) {\n\t\t\t\t\treturn format;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'none';\n\t\t};\n\n\t\treturn testInOrder(hasAlpha ? rgbaPriority : rgbPriority);\n\t};\n\n\tconst dimensionsValid = (width, height, format, webgl2) => {\n\t\tswitch (format) {\n\t\t\tcase BASIS_FORMAT.cTFETC1:\n\t\t\tcase BASIS_FORMAT.cTFETC2:\n\t\t\t\treturn true;\n\n\t\t\tcase BASIS_FORMAT.cTFBC1:\n\t\t\tcase BASIS_FORMAT.cTFBC3:\n\t\t\t\treturn (width & 0x3) === 0 && (height & 0x3) === 0;\n\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGB:\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGBA:\n\t\t\t\treturn isPOT(width, height) && (width === height || webgl2);\n\n\t\t\tcase BASIS_FORMAT.cTFASTC_4x4:\n\t\t\t\treturn true;\n\n\t\t\tcase BASIS_FORMAT.cTFATC_RGB:\n\t\t\tcase BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:\n\t\t\t\treturn true;\n\t\t}\n\t};\n\n\tconst transcodeKTX2 = (url, data, options) => {\n\t\tif (!basis.KTX2File) {\n\t\t\tthrow new Error('Basis transcoder module does not include support for KTX2.');\n\t\t}\n\n\t\tconst funcStart = performanceNow();\n\t\tconst basisFile = new basis.KTX2File(new Uint8Array(data));\n\t\tconst width = basisFile.getWidth();\n\t\tconst height = basisFile.getHeight();\n\t\tconst levels = basisFile.getLevels();\n\t\tconst hasAlpha = !!basisFile.getHasAlpha();\n\t\tconst isUASTC = basisFile.isUASTC && basisFile.isUASTC();\n\n\t\tif (!width || !height || !levels) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error(`Invalid image dimensions url=${url} width=${width} height=${height} levels=${levels}`);\n\t\t}\n\n\t\tconst format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);\n\t\tconst unswizzle = !!options.isGGGR && format === 'pvr';\n\t\tlet basisFormat;\n\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGBA32;\n\t\t} else {\n\t\t\tbasisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];\n\n\t\t\tif (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {\n\t\t\t\tbasisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;\n\t\t\t}\n\t\t}\n\n\t\tif (!basisFile.startTranscoding()) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error('Failed to start transcoding url=' + url);\n\t\t}\n\n\t\tlet i;\n\t\tconst levelData = [];\n\n\t\tfor (let mip = 0; mip < levels; ++mip) {\n\t\t\tconst dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);\n\t\t\tconst dst = new Uint8Array(dstSize);\n\n\t\t\tif (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {\n\t\t\t\tbasisFile.close();\n\t\t\t\tbasisFile.delete();\n\t\t\t\tthrow new Error('Failed to transcode image url=' + url);\n\t\t\t}\n\n\t\t\tconst is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;\n\t\t\tlevelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);\n\t\t}\n\n\t\tbasisFile.close();\n\t\tbasisFile.delete();\n\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGB565;\n\n\t\t\tfor (i = 0; i < levelData.length; ++i) {\n\t\t\t\tlevelData[i] = pack565(unswizzleGGGR(levelData[i]));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tformat: basisToEngineMapping(basisFormat, options.deviceDetails),\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: levelData,\n\t\t\tcubemap: false,\n\t\t\ttranscodeTime: performanceNow() - funcStart,\n\t\t\turl: url,\n\t\t\tunswizzledGGGR: unswizzle\n\t\t};\n\t};\n\n\tconst transcodeBasis = (url, data, options) => {\n\t\tconst funcStart = performanceNow();\n\t\tconst basisFile = new basis.BasisFile(new Uint8Array(data));\n\t\tconst width = basisFile.getImageWidth(0, 0);\n\t\tconst height = basisFile.getImageHeight(0, 0);\n\t\tconst images = basisFile.getNumImages();\n\t\tconst levels = basisFile.getNumLevels(0);\n\t\tconst hasAlpha = !!basisFile.getHasAlpha();\n\t\tconst isUASTC = basisFile.isUASTC && basisFile.isUASTC();\n\n\t\tif (!width || !height || !images || !levels) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error(`Invalid image dimensions url=${url} width=${width} height=${height} images=${images} levels=${levels}`);\n\t\t}\n\n\t\tconst format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);\n\t\tconst unswizzle = !!options.isGGGR && format === 'pvr';\n\t\tlet basisFormat;\n\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGBA32;\n\t\t} else {\n\t\t\tbasisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];\n\n\t\t\tif (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {\n\t\t\t\tbasisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;\n\t\t\t}\n\t\t}\n\n\t\tif (!basisFile.startTranscoding()) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error('Failed to start transcoding url=' + url);\n\t\t}\n\n\t\tlet i;\n\t\tconst levelData = [];\n\n\t\tfor (let mip = 0; mip < levels; ++mip) {\n\t\t\tconst dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);\n\t\t\tconst dst = new Uint8Array(dstSize);\n\n\t\t\tif (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {\n\t\t\t\tbasisFile.close();\n\t\t\t\tbasisFile.delete();\n\t\t\t\tthrow new Error('Failed to transcode image url=' + url);\n\t\t\t}\n\n\t\t\tconst is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;\n\t\t\tlevelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);\n\t\t}\n\n\t\tbasisFile.close();\n\t\tbasisFile.delete();\n\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGB565;\n\n\t\t\tfor (i = 0; i < levelData.length; ++i) {\n\t\t\t\tlevelData[i] = pack565(unswizzleGGGR(levelData[i]));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tformat: basisToEngineMapping(basisFormat, options.deviceDetails),\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: levelData,\n\t\t\tcubemap: false,\n\t\t\ttranscodeTime: performanceNow() - funcStart,\n\t\t\turl: url,\n\t\t\tunswizzledGGGR: unswizzle\n\t\t};\n\t};\n\n\tconst transcode = (url, data, options) => {\n\t\treturn options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);\n\t};\n\n\tconst workerTranscode = (url, data, options) => {\n\t\ttry {\n\t\t\tconst result = transcode(url, data, options);\n\t\t\tresult.levels = result.levels.map(v => v.buffer);\n\t\t\tself.postMessage({\n\t\t\t\turl: url,\n\t\t\t\tdata: result\n\t\t\t}, result.levels);\n\t\t} catch (err) {\n\t\t\tself.postMessage({\n\t\t\t\turl: url,\n\t\t\t\terr: err\n\t\t\t}, null);\n\t\t}\n\t};\n\n\tconst workerInit = (config, callback) => {\n\t\tself.importScripts(config.basisUrl);\n\n\t\tconst instantiateWasmFunc = (imports, successCallback) => {\n\t\t\tWebAssembly.instantiate(config.module, imports).then(result => {\n\t\t\t\tsuccessCallback(result);\n\t\t\t}).catch(reason => {\n\t\t\t\tconsole.error('instantiate failed + ' + reason);\n\t\t\t});\n\t\t\treturn {};\n\t\t};\n\n\t\tself.BASIS(config.module ? {\n\t\t\tinstantiateWasm: instantiateWasmFunc\n\t\t} : null).then(instance => {\n\t\t\tinstance.initializeBasis();\n\t\t\tbasis = instance;\n\t\t\trgbPriority = config.rgbPriority;\n\t\t\trgbaPriority = config.rgbaPriority;\n\t\t\tcallback(null);\n\t\t});\n\t};\n\n\tconst queue = [];\n\n\tself.onmessage = message => {\n\t\tconst data = message.data;\n\n\t\tswitch (data.type) {\n\t\t\tcase 'init':\n\t\t\t\tworkerInit(data.config, () => {\n\t\t\t\t\tfor (let i = 0; i < queue.length; ++i) {\n\t\t\t\t\t\tworkerTranscode(queue[i].url, queue[i].data, queue[i].options);\n\t\t\t\t\t}\n\n\t\t\t\t\tqueue.length = 0;\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'transcode':\n\t\t\t\tif (basis) {\n\t\t\t\t\tworkerTranscode(data.url, data.data, data.options);\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(data);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\nconst getCompressionFormats = device => {\n\treturn {\n\t\tastc: !!device.extCompressedTextureASTC,\n\t\tatc: !!device.extCompressedTextureATC,\n\t\tdxt: !!device.extCompressedTextureS3TC,\n\t\tetc1: !!device.extCompressedTextureETC1,\n\t\tetc2: !!device.extCompressedTextureETC,\n\t\tpvr: !!device.extCompressedTexturePVRTC\n\t};\n};\n\nconst prepareWorkerModules = (config, callback) => {\n\tconst getWorkerBlob = () => {\n\t\tconst code = '(' + BasisWorker.toString() + ')()\\n\\n';\n\t\treturn new Blob([code], {\n\t\t\ttype: 'application/javascript'\n\t\t});\n\t};\n\n\tconst wasmSupported = () => {\n\t\ttry {\n\t\t\tif (typeof WebAssembly === \"object\" && typeof WebAssembly.instantiate === \"function\") {\n\t\t\t\tconst module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));\n\t\t\t\tif (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\n\t\t\t}\n\t\t} catch (e) {}\n\n\t\treturn false;\n\t};\n\n\tconst sendResponse = (basisCode, module) => {\n\t\tcallback(null, {\n\t\t\tworkerUrl: URL.createObjectURL(getWorkerBlob()),\n\t\t\tbasisUrl: URL.createObjectURL(basisCode),\n\t\t\tmodule: module,\n\t\t\trgbPriority: config.rgbPriority,\n\t\t\trgbaPriority: config.rgbaPriority\n\t\t});\n\t};\n\n\tif (config.glueUrl && config.wasmUrl && wasmSupported()) {\n\t\tlet basisCode = null;\n\t\tlet module = null;\n\t\thttp.get(config.glueUrl, {\n\t\t\tresponseType: 'blob'\n\t\t}, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tif (module) {\n\t\t\t\t\tsendResponse(response, module);\n\t\t\t\t} else {\n\t\t\t\t\tbasisCode = response;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tconst fetchPromise = fetch(config.wasmUrl);\n\n\t\tconst compileManual = () => {\n\t\t\tfetchPromise.then(result => result.arrayBuffer()).then(buffer => WebAssembly.compile(buffer)).then(module_ => {\n\t\t\t\tif (basisCode) {\n\t\t\t\t\tsendResponse(basisCode, module_);\n\t\t\t\t} else {\n\t\t\t\t\tmodule = module_;\n\t\t\t\t}\n\t\t\t}).catch(err => {\n\t\t\t\tcallback(err, null);\n\t\t\t});\n\t\t};\n\n\t\tif (WebAssembly.compileStreaming) {\n\t\t\tWebAssembly.compileStreaming(fetchPromise).then(module_ => {\n\t\t\t\tif (basisCode) {\n\t\t\t\t\tsendResponse(basisCode, module_);\n\t\t\t\t} else {\n\t\t\t\t\tmodule = module_;\n\t\t\t\t}\n\t\t\t}).catch(err => {\n\t\t\t\tcompileManual();\n\t\t\t});\n\t\t} else {\n\t\t\tcompileManual();\n\t\t}\n\t} else {\n\t\thttp.get(config.fallbackUrl, {\n\t\t\tresponseType: 'blob'\n\t\t}, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err, null);\n\t\t\t} else {\n\t\t\t\tsendResponse(response, null);\n\t\t\t}\n\t\t});\n\t}\n};\n\nclass BasisQueue {\n\tconstructor() {\n\t\tthis.callbacks = {};\n\t\tthis.queue = [];\n\t\tthis.clients = [];\n\t}\n\n\tenqueueJob(url, data, callback, options) {\n\t\tif (this.callbacks.hasOwnProperty(url)) {\n\t\t\tthis.callbacks[url].push(callback);\n\t\t} else {\n\t\t\tthis.callbacks[url] = [callback];\n\t\t\tconst job = {\n\t\t\t\turl: url,\n\t\t\t\tdata: data,\n\t\t\t\toptions: options\n\t\t\t};\n\n\t\t\tif (this.clients.length > 0) {\n\t\t\t\tthis.clients.shift().run(job);\n\t\t\t} else {\n\t\t\t\tthis.queue.push(job);\n\t\t\t}\n\t\t}\n\t}\n\n\tenqueueClient(client) {\n\t\tif (this.queue.length > 0) {\n\t\t\tclient.run(this.queue.shift());\n\t\t} else {\n\t\t\tthis.clients.push(client);\n\t\t}\n\t}\n\n\thandleResponse(url, err, data) {\n\t\tconst callback = this.callbacks[url];\n\n\t\tif (err) {\n\t\t\tfor (let i = 0; i < callback.length; ++i) {\n\t\t\t\tcallback[i](err);\n\t\t\t}\n\t\t} else {\n\t\t\tif (data.format === PIXELFORMAT_R5_G6_B5 || data.format === PIXELFORMAT_R4_G4_B4_A4) {\n\t\t\t\tdata.levels = data.levels.map(function (v) {\n\t\t\t\t\treturn new Uint16Array(v);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdata.levels = data.levels.map(function (v) {\n\t\t\t\t\treturn new Uint8Array(v);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < callback.length; ++i) {\n\t\t\t\tcallback[i](null, data);\n\t\t\t}\n\t\t}\n\n\t\tdelete this.callbacks[url];\n\t}\n\n}\n\nclass BasisClient {\n\tconstructor(queue, config, eager) {\n\t\tthis.queue = queue;\n\t\tthis.worker = new Worker(config.workerUrl);\n\t\tthis.worker.addEventListener('message', message => {\n\t\t\tconst data = message.data;\n\t\t\tthis.queue.handleResponse(data.url, data.err, data.data);\n\n\t\t\tif (!this.eager) {\n\t\t\t\tthis.queue.enqueueClient(this);\n\t\t\t}\n\t\t});\n\t\tthis.worker.postMessage({\n\t\t\ttype: 'init',\n\t\t\tconfig: config\n\t\t});\n\t\tthis.eager = eager;\n\t}\n\n\trun(job) {\n\t\tconst transfer = [];\n\n\t\tif (job.data instanceof ArrayBuffer) {\n\t\t\ttransfer.push(job.data);\n\t\t}\n\n\t\tthis.worker.postMessage({\n\t\t\ttype: 'transcode',\n\t\t\turl: job.url,\n\t\t\tformat: job.format,\n\t\t\tdata: job.data,\n\t\t\toptions: job.options\n\t\t}, transfer);\n\n\t\tif (this.eager) {\n\t\t\tthis.queue.enqueueClient(this);\n\t\t}\n\t}\n\n}\n\nconst defaultNumWorkers = 1;\nconst defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];\nconst defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];\nconst queue = new BasisQueue();\nlet lazyConfig = null;\nlet initializing = false;\n\nfunction basisInitialize(config) {\n\tif (initializing) {\n\t\treturn;\n\t}\n\n\tif (!config) {\n\t\tconfig = lazyConfig || {};\n\t} else if (config.lazyInit) {\n\t\tlazyConfig = config;\n\t\treturn;\n\t}\n\n\tif (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {\n\t\tconst modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];\n\t\tconst wasmModule = modules.find(function (m) {\n\t\t\treturn m.moduleName === 'BASIS';\n\t\t});\n\n\t\tif (wasmModule) {\n\t\t\tconst urlBase = window.ASSET_PREFIX || \"\";\n\n\t\t\tif (!config.glueUrl) {\n\t\t\t\tconfig.glueUrl = urlBase + wasmModule.glueUrl;\n\t\t\t}\n\n\t\t\tif (!config.wasmUrl) {\n\t\t\t\tconfig.wasmUrl = urlBase + wasmModule.wasmUrl;\n\t\t\t}\n\n\t\t\tif (!config.fallbackUrl) {\n\t\t\t\tconfig.fallbackUrl = urlBase + wasmModule.fallbackUrl;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (config.glueUrl || config.wasmUrl || config.fallbackUrl) {\n\t\tinitializing = true;\n\t\tconst numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));\n\t\tconst eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);\n\t\tconfig.rgbPriority = config.rgbPriority || defaultRgbPriority;\n\t\tconfig.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;\n\t\tprepareWorkerModules(config, (err, clientConfig) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(`failed to initialize basis worker: ${err}`);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < numWorkers; ++i) {\n\t\t\t\t\tqueue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nlet deviceDetails = null;\n\nfunction basisTranscode(device, url, data, callback, options) {\n\tbasisInitialize();\n\n\tif (!deviceDetails) {\n\t\tdeviceDetails = {\n\t\t\twebgl2: device.webgl2,\n\t\t\tformats: getCompressionFormats(device)\n\t\t};\n\t}\n\n\tqueue.enqueueJob(url, data, callback, {\n\t\tdeviceDetails: deviceDetails,\n\t\tisGGGR: !!(options != null && options.isGGGR),\n\t\tisKTX2: !!(options != null && options.isKTX2)\n\t});\n\treturn initializing;\n}\n\nclass BasisParser {\n\tconstructor(registry, device) {\n\t\tthis.device = device;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tconst device = this.device;\n\n\t\tconst transcode = data => {\n\t\t\tvar _asset$file, _asset$file$variants, _asset$file$variants$;\n\n\t\t\tconst basisModuleFound = basisTranscode(device, url.load, data, callback, {\n\t\t\t\tisGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0\n\t\t\t});\n\n\t\t\tif (!basisModuleFound) {\n\t\t\t\tcallback(`Basis module not found. Asset '${asset.name}' basis texture variant will not be loaded.`);\n\t\t\t}\n\t\t};\n\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\ttranscode(result);\n\t\t\t}\n\t\t}, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: data.format,\n\t\t\tcubemap: data.cubemap,\n\t\t\tlevels: data.levels\n\t\t});\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n}\n\nclass ImgParser {\n\tconstructor(registry) {\n\t\tthis.crossOrigin = registry.prefix ? 'anonymous' : null;\n\t\tthis.maxRetries = 0;\n\t\tthis.useImageBitmap = false  ;\n\t}\n\n\tload(url, callback, asset) {\n\t\tvar _asset$file;\n\n\t\tconst hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);\n\n\t\tif (hasContents) {\n\t\t\turl = {\n\t\t\t\tload: URL.createObjectURL(new Blob([asset.file.contents])),\n\t\t\t\toriginal: url.original\n\t\t\t};\n\t\t}\n\n\t\tconst handler = (err, result) => {\n\t\t\tif (hasContents) {\n\t\t\t\tURL.revokeObjectURL(url.load);\n\t\t\t}\n\n\t\t\tcallback(err, result);\n\t\t};\n\n\t\tlet crossOrigin;\n\n\t\tif (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {\n\t\t\tcrossOrigin = asset.options.crossOrigin;\n\t\t} else if (ABSOLUTE_URL.test(url.load)) {\n\t\t\tcrossOrigin = this.crossOrigin;\n\t\t}\n\n\t\tif (this.useImageBitmap) {\n\t\t\tthis._loadImageBitmap(url.load, url.original, crossOrigin, handler);\n\t\t} else {\n\t\t\tthis._loadImage(url.load, url.original, crossOrigin, handler);\n\t\t}\n\t}\n\n\topen(url, data, device) {\n\t\tconst ext = path.getExtension(url).toLowerCase();\n\t\tconst format = ext === \".jpg\" || ext === \".jpeg\" ? PIXELFORMAT_R8_G8_B8 : PIXELFORMAT_R8_G8_B8_A8;\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: format\n\t\t});\n\t\ttexture.setSource(data);\n\t\treturn texture;\n\t}\n\n\t_loadImage(url, originalUrl, crossOrigin, callback) {\n\t\tconst image = new Image();\n\n\t\tif (crossOrigin) {\n\t\t\timage.crossOrigin = crossOrigin;\n\t\t}\n\n\t\tlet retries = 0;\n\t\tconst maxRetries = this.maxRetries;\n\t\tlet retryTimeout;\n\n\t\timage.onload = function () {\n\t\t\tcallback(null, image);\n\t\t};\n\n\t\timage.onerror = function () {\n\t\t\tif (retryTimeout) return;\n\n\t\t\tif (maxRetries > 0 && ++retries <= maxRetries) {\n\t\t\t\tconst retryDelay = Math.pow(2, retries) * 100;\n\t\t\t\tconsole.log(`Error loading Texture from: '${originalUrl}' - Retrying in ${retryDelay}ms...`);\n\t\t\t\tconst idx = url.indexOf('?');\n\t\t\t\tconst separator = idx >= 0 ? '&' : '?';\n\t\t\t\tretryTimeout = setTimeout(function () {\n\t\t\t\t\timage.src = url + separator + 'retry=' + Date.now();\n\t\t\t\t\tretryTimeout = null;\n\t\t\t\t}, retryDelay);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading Texture from: '${originalUrl}'`);\n\t\t\t}\n\t\t};\n\n\t\timage.src = url;\n\t}\n\n\t_loadImageBitmap(url, originalUrl, crossOrigin, callback) {\n\t\tconst options = {\n\t\t\tcache: true,\n\t\t\tresponseType: \"blob\",\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\thttp.get(url, options, function (err, blob) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tcreateImageBitmap(blob, {\n\t\t\t\t\tpremultiplyAlpha: 'none'\n\t\t\t\t}).then(function (imageBitmap) {\n\t\t\t\t\tcallback(null, imageBitmap);\n\t\t\t\t}).catch(function (e) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n}\n\nconst IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];\nconst KNOWN_FORMATS = {\n\t0x83F0: PIXELFORMAT_DXT1,\n\t0x83F2: PIXELFORMAT_DXT3,\n\t0x83F3: PIXELFORMAT_DXT5,\n\t0x8D64: PIXELFORMAT_ETC1,\n\t0x9274: PIXELFORMAT_ETC2_RGB,\n\t0x9278: PIXELFORMAT_ETC2_RGBA,\n\t0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,\n\t0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,\n\t0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,\n\t0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,\n\t0x8051: PIXELFORMAT_R8_G8_B8,\n\t0x8058: PIXELFORMAT_R8_G8_B8_A8,\n\t0x8C41: PIXELFORMAT_SRGB,\n\t0x8C43: PIXELFORMAT_SRGBA,\n\t0x8C3A: PIXELFORMAT_111110F,\n\t0x881B: PIXELFORMAT_RGB16F,\n\t0x881A: PIXELFORMAT_RGBA16F\n};\n\nfunction createContainer(pixelFormat, buffer, byteOffset, byteSize) {\n\treturn pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);\n}\n\nclass KtxParser {\n\tconstructor(registry) {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst textureData = this.parse(data);\n\n\t\tif (!textureData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: textureData.width,\n\t\t\theight: textureData.height,\n\t\t\tformat: textureData.format,\n\t\t\tcubemap: textureData.cubemap,\n\t\t\tlevels: textureData.levels\n\t\t});\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n\tparse(data) {\n\t\tconst dataU32 = new Uint32Array(data);\n\n\t\tif (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst header = {\n\t\t\tendianness: dataU32[3],\n\t\t\tglType: dataU32[4],\n\t\t\tglTypeSize: dataU32[5],\n\t\t\tglFormat: dataU32[6],\n\t\t\tglInternalFormat: dataU32[7],\n\t\t\tglBaseInternalFormat: dataU32[8],\n\t\t\tpixelWidth: dataU32[9],\n\t\t\tpixelHeight: dataU32[10],\n\t\t\tpixelDepth: dataU32[11],\n\t\t\tnumberOfArrayElements: dataU32[12],\n\t\t\tnumberOfFaces: dataU32[13],\n\t\t\tnumberOfMipmapLevels: dataU32[14],\n\t\t\tbytesOfKeyValueData: dataU32[15]\n\t\t};\n\n\t\tif (header.pixelDepth > 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (header.numberOfArrayElements !== 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst format = KNOWN_FORMATS[header.glInternalFormat];\n\n\t\tif (format === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet offset = 16 + header.bytesOfKeyValueData / 4;\n\t\tconst isCubemap = header.numberOfFaces > 1;\n\t\tconst levels = [];\n\n\t\tfor (let mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {\n\t\t\tconst imageSizeInBytes = dataU32[offset++];\n\n\t\t\tif (isCubemap) {\n\t\t\t\tlevels.push([]);\n\t\t\t}\n\n\t\t\tconst target = isCubemap ? levels[mipmapLevel] : levels;\n\n\t\t\tfor (let face = 0; face < (isCubemap ? 6 : 1); ++face) {\n\t\t\t\ttarget.push(createContainer(format, data, offset * 4, imageSizeInBytes));\n\t\t\t\toffset += imageSizeInBytes + 3 >> 2;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tformat: format,\n\t\t\twidth: header.pixelWidth,\n\t\t\theight: header.pixelHeight,\n\t\t\tlevels: levels,\n\t\t\tcubemap: isCubemap\n\t\t};\n\t}\n\n}\n\nconst KHRConstants = {\n\tKHR_DF_MODEL_ETC1S: 163,\n\tKHR_DF_MODEL_UASTC: 166\n};\n\nclass Ktx2Parser {\n\tconstructor(registry, device) {\n\t\tthis.maxRetries = 0;\n\t\tthis.device = device;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err, result);\n\t\t\t} else {\n\t\t\t\tthis.parse(result, url, callback, asset);\n\t\t\t}\n\t\t}, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: data.format,\n\t\t\tcubemap: data.cubemap,\n\t\t\tlevels: data.levels\n\t\t});\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n\tparse(arraybuffer, url, callback, asset) {\n\t\tconst rs = new ReadStream(arraybuffer);\n\t\tconst magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];\n\n\t\tif (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst header = {\n\t\t\tvkFormat: rs.readU32(),\n\t\t\ttypeSize: rs.readU32(),\n\t\t\tpixelWidth: rs.readU32(),\n\t\t\tpixelHeight: rs.readU32(),\n\t\t\tpixelDepth: rs.readU32(),\n\t\t\tlayerCount: rs.readU32(),\n\t\t\tfaceCount: rs.readU32(),\n\t\t\tlevelCount: rs.readU32(),\n\t\t\tsupercompressionScheme: rs.readU32()\n\t\t};\n\t\tconst index = {\n\t\t\tdfdByteOffset: rs.readU32(),\n\t\t\tdfdByteLength: rs.readU32(),\n\t\t\tkvdByteOffset: rs.readU32(),\n\t\t\tkvdByteLength: rs.readU32(),\n\t\t\tsgdByteOffset: rs.readU64(),\n\t\t\tsgdByteLength: rs.readU64()\n\t\t};\n\t\tconst levels = [];\n\n\t\tfor (let i = 0; i < Math.max(1, header.levelCount); ++i) {\n\t\t\tlevels.push({\n\t\t\t\tbyteOffset: rs.readU64(),\n\t\t\t\tbyteLength: rs.readU64(),\n\t\t\t\tuncompressedByteLength: rs.readU64()\n\t\t\t});\n\t\t}\n\n\t\tconst dfdTotalSize = rs.readU32();\n\n\t\tif (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {\n\t\t\treturn null;\n\t\t}\n\n\t\trs.skip(8);\n\t\tconst colorModel = rs.readU8();\n\t\trs.skip(index.dfdByteLength - 9);\n\t\trs.skip(index.kvdByteLength);\n\n\t\tif (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {\n\t\t\tvar _asset$file, _asset$file$variants, _asset$file$variants$;\n\n\t\t\tconst basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {\n\t\t\t\tisGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0,\n\t\t\t\tisKTX2: true\n\t\t\t});\n\n\t\t\tif (!basisModuleFound) {\n\t\t\t\tcallback('Basis module not found. Asset \"' + asset.name + '\" basis texture variant will not be loaded.');\n\t\t\t}\n\t\t} else {\n\t\t\tcallback('unsupported KTX2 pixel format');\n\t\t}\n\t}\n\n}\n\nclass DdsParser {\n\tconstructor(registry) {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst header = new Uint32Array(data, 0, 128 / 4);\n\t\tconst width = header[4];\n\t\tconst height = header[3];\n\t\tconst mips = Math.max(header[7], 1);\n\t\tconst isFourCc = header[20] === 4;\n\t\tconst fcc = header[21];\n\t\tconst bpp = header[22];\n\t\tconst isCubemap = header[28] === 65024;\n\t\tconst FCC_DXT1 = 827611204;\n\t\tconst FCC_DXT5 = 894720068;\n\t\tconst FCC_FP16 = 113;\n\t\tconst FCC_FP32 = 116;\n\t\tconst FCC_ETC1 = 826496069;\n\t\tconst FCC_PVRTC_2BPP_RGB_1 = 825438800;\n\t\tconst FCC_PVRTC_2BPP_RGBA_1 = 825504336;\n\t\tconst FCC_PVRTC_4BPP_RGB_1 = 825439312;\n\t\tconst FCC_PVRTC_4BPP_RGBA_1 = 825504848;\n\t\tlet compressed = false;\n\t\tlet etc1 = false;\n\t\tlet pvrtc2 = false;\n\t\tlet pvrtc4 = false;\n\t\tlet format = null;\n\t\tlet componentSize = 1;\n\t\tlet texture;\n\n\t\tif (isFourCc) {\n\t\t\tif (fcc === FCC_DXT1) {\n\t\t\t\tformat = PIXELFORMAT_DXT1;\n\t\t\t\tcompressed = true;\n\t\t\t} else if (fcc === FCC_DXT5) {\n\t\t\t\tformat = PIXELFORMAT_DXT5;\n\t\t\t\tcompressed = true;\n\t\t\t} else if (fcc === FCC_FP16) {\n\t\t\t\tformat = PIXELFORMAT_RGBA16F;\n\t\t\t\tcomponentSize = 2;\n\t\t\t} else if (fcc === FCC_FP32) {\n\t\t\t\tformat = PIXELFORMAT_RGBA32F;\n\t\t\t\tcomponentSize = 4;\n\t\t\t} else if (fcc === FCC_ETC1) {\n\t\t\t\tformat = PIXELFORMAT_ETC1;\n\t\t\t\tcompressed = true;\n\t\t\t\tetc1 = true;\n\t\t\t} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {\n\t\t\t\tformat = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;\n\t\t\t\tcompressed = true;\n\t\t\t\tpvrtc2 = true;\n\t\t\t} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {\n\t\t\t\tformat = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;\n\t\t\t\tcompressed = true;\n\t\t\t\tpvrtc4 = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bpp === 32) {\n\t\t\t\tformat = PIXELFORMAT_R8_G8_B8_A8;\n\t\t\t}\n\t\t}\n\n\t\tif (!format) {\n\t\t\ttexture = new Texture(device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8\n\t\t\t});\n\t\t\ttexture.name = 'dds-legacy-empty';\n\t\t\treturn texture;\n\t\t}\n\n\t\ttexture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tformat: format,\n\t\t\tcubemap: isCubemap,\n\t\t\tmipmaps: mips > 1\n\t\t});\n\t\tlet offset = 128;\n\t\tconst faces = isCubemap ? 6 : 1;\n\t\tlet mipSize;\n\t\tconst DXT_BLOCK_WIDTH = 4;\n\t\tconst DXT_BLOCK_HEIGHT = 4;\n\t\tconst blockSize = fcc === FCC_DXT1 ? 8 : 16;\n\t\tlet numBlocksAcross, numBlocksDown, numBlocks;\n\n\t\tfor (let face = 0; face < faces; face++) {\n\t\t\tlet mipWidth = width;\n\t\t\tlet mipHeight = height;\n\n\t\t\tfor (let i = 0; i < mips; i++) {\n\t\t\t\tif (compressed) {\n\t\t\t\t\tif (etc1) {\n\t\t\t\t\t\tmipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;\n\t\t\t\t\t} else if (pvrtc2) {\n\t\t\t\t\t\tmipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;\n\t\t\t\t\t} else if (pvrtc4) {\n\t\t\t\t\t\tmipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);\n\t\t\t\t\t\tnumBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);\n\t\t\t\t\t\tnumBlocks = numBlocksAcross * numBlocksDown;\n\t\t\t\t\t\tmipSize = numBlocks * blockSize;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmipSize = mipWidth * mipHeight * 4;\n\t\t\t\t}\n\n\t\t\t\tconst mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);\n\n\t\t\t\tif (!isCubemap) {\n\t\t\t\t\ttexture._levels[i] = mipBuff;\n\t\t\t\t} else {\n\t\t\t\t\tif (!texture._levels[i]) texture._levels[i] = [];\n\t\t\t\t\ttexture._levels[i][face] = mipBuff;\n\t\t\t\t}\n\n\t\t\t\toffset += mipSize * componentSize;\n\t\t\t\tmipWidth = Math.max(mipWidth * 0.5, 1);\n\t\t\t\tmipHeight = Math.max(mipHeight * 0.5, 1);\n\t\t\t}\n\t\t}\n\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n}\n\nclass HdrParser {\n\tconstructor(registry) {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst textureData = this.parse(data);\n\n\t\tif (!textureData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: ADDRESS_REPEAT,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tminFilter: FILTER_NEAREST_MIPMAP_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\twidth: textureData.width,\n\t\t\theight: textureData.height,\n\t\t\tlevels: textureData.levels,\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\ttype: TEXTURETYPE_RGBE,\n\t\t\tmipmaps: false\n\t\t});\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n\tparse(data) {\n\t\tconst readStream = new ReadStream(data);\n\t\tconst magic = readStream.readLine();\n\n\t\tif (!magic.startsWith('#?RADIANCE')) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst variables = {};\n\n\t\twhile (true) {\n\t\t\tconst line = readStream.readLine();\n\n\t\t\tif (line.length === 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tconst parts = line.split('=');\n\n\t\t\t\tif (parts.length === 2) {\n\t\t\t\t\tvariables[parts[0]] = parts[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!variables.hasOwnProperty('FORMAT')) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst resolution = readStream.readLine().split(' ');\n\n\t\tif (resolution.length !== 4) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst height = parseInt(resolution[1], 10);\n\t\tconst width = parseInt(resolution[3], 10);\n\n\t\tconst pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');\n\n\t\tif (!pixels) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: [pixels]\n\t\t};\n\t}\n\n\t_readPixels(readStream, width, height, flipY) {\n\t\tif (width < 8 || width > 0x7fff) {\n\t\t\treturn this._readPixelsFlat(readStream, width, height);\n\t\t}\n\n\t\tconst rgbe = [0, 0, 0, 0];\n\t\treadStream.readArray(rgbe);\n\n\t\tif (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {\n\t\t\treadStream.skip(-4);\n\t\t\treturn this._readPixelsFlat(readStream, width, height);\n\t\t}\n\n\t\tconst buffer = new ArrayBuffer(width * height * 4);\n\t\tconst view = new Uint8Array(buffer);\n\t\tlet scanstart = flipY ? 0 : width * 4 * (height - 1);\n\t\tlet x, y, i, channel, count, value;\n\n\t\tfor (y = 0; y < height; ++y) {\n\t\t\tif (y) {\n\t\t\t\treadStream.readArray(rgbe);\n\t\t\t}\n\n\t\t\tif ((rgbe[2] << 8) + rgbe[3] !== width) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfor (channel = 0; channel < 4; ++channel) {\n\t\t\t\tx = 0;\n\n\t\t\t\twhile (x < width) {\n\t\t\t\t\tcount = readStream.readU8();\n\n\t\t\t\t\tif (count > 128) {\n\t\t\t\t\t\tcount -= 128;\n\n\t\t\t\t\t\tif (x + count > width) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue = readStream.readU8();\n\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\t\t\tview[scanstart + channel + 4 * x++] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (count === 0 || x + count > width) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\t\t\tview[scanstart + channel + 4 * x++] = readStream.readU8();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanstart += width * 4 * (flipY ? 1 : -1);\n\t\t}\n\n\t\treturn view;\n\t}\n\n\t_readPixelsFlat(readStream, width, height) {\n\t\treturn readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;\n\t}\n\n}\n\nconst JSON_ADDRESS_MODE = {\n\t\"repeat\": ADDRESS_REPEAT,\n\t\"clamp\": ADDRESS_CLAMP_TO_EDGE,\n\t\"mirror\": ADDRESS_MIRRORED_REPEAT\n};\nconst JSON_FILTER_MODE = {\n\t\"nearest\": FILTER_NEAREST,\n\t\"linear\": FILTER_LINEAR,\n\t\"nearest_mip_nearest\": FILTER_NEAREST_MIPMAP_NEAREST,\n\t\"linear_mip_nearest\": FILTER_LINEAR_MIPMAP_NEAREST,\n\t\"nearest_mip_linear\": FILTER_NEAREST_MIPMAP_LINEAR,\n\t\"linear_mip_linear\": FILTER_LINEAR_MIPMAP_LINEAR\n};\nconst JSON_TEXTURE_TYPE = {\n\t\"default\": TEXTURETYPE_DEFAULT,\n\t\"rgbm\": TEXTURETYPE_RGBM,\n\t\"rgbe\": TEXTURETYPE_RGBE,\n\t\"swizzleGGGR\": TEXTURETYPE_SWIZZLEGGGR\n};\n\nclass TextureParser {\n\tload(url, callback, asset) {\n\t\tthrow new Error('not implemented');\n\t}\n\n\topen(url, data, device) {\n\t\tthrow new Error('not implemented');\n\t}\n\n}\n\nconst _completePartialMipmapChain = function _completePartialMipmapChain(texture) {\n\tconst requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;\n\n\tconst isHtmlElement = function isHtmlElement(object) {\n\t\treturn object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;\n\t};\n\n\tif (!(texture._format === PIXELFORMAT_R8_G8_B8_A8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {\n\t\treturn;\n\t}\n\n\tconst downsample = function downsample(width, height, data) {\n\t\tconst sampledWidth = Math.max(1, width >> 1);\n\t\tconst sampledHeight = Math.max(1, height >> 1);\n\t\tconst sampledData = new data.constructor(sampledWidth * sampledHeight * 4);\n\t\tconst xs = Math.floor(width / sampledWidth);\n\t\tconst ys = Math.floor(height / sampledHeight);\n\t\tconst xsys = xs * ys;\n\n\t\tfor (let y = 0; y < sampledHeight; ++y) {\n\t\t\tfor (let x = 0; x < sampledWidth; ++x) {\n\t\t\t\tfor (let e = 0; e < 4; ++e) {\n\t\t\t\t\tlet sum = 0;\n\n\t\t\t\t\tfor (let sy = 0; sy < ys; ++sy) {\n\t\t\t\t\t\tfor (let sx = 0; sx < xs; ++sx) {\n\t\t\t\t\t\t\tsum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sampledData;\n\t};\n\n\tfor (let level = texture._levels.length; level < requiredMipLevels; ++level) {\n\t\tconst width = Math.max(1, texture._width >> level - 1);\n\t\tconst height = Math.max(1, texture._height >> level - 1);\n\n\t\tif (texture._cubemap) {\n\t\t\tconst mips = [];\n\n\t\t\tfor (let face = 0; face < 6; ++face) {\n\t\t\t\tmips.push(downsample(width, height, texture._levels[level - 1][face]));\n\t\t\t}\n\n\t\t\ttexture._levels.push(mips);\n\t\t} else {\n\t\t\ttexture._levels.push(downsample(width, height, texture._levels[level - 1]));\n\t\t}\n\t}\n\n\ttexture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];\n};\n\nclass TextureHandler {\n\tconstructor(device, assets, loader) {\n\t\tthis._device = device;\n\t\tthis._assets = assets;\n\t\tthis._loader = loader;\n\t\tthis.imgParser = new ImgParser(assets);\n\t\tthis.parsers = {\n\t\t\tdds: new DdsParser(assets),\n\t\t\tktx: new KtxParser(assets),\n\t\t\tktx2: new Ktx2Parser(assets, device),\n\t\t\tbasis: new BasisParser(assets, device),\n\t\t\thdr: new HdrParser(assets)\n\t\t};\n\t}\n\n\tset crossOrigin(value) {\n\t\tthis.imgParser.crossOrigin = value;\n\t}\n\n\tget crossOrigin() {\n\t\treturn this.imgParser.crossOrigin;\n\t}\n\n\tset maxRetries(value) {\n\t\tthis.imgParser.maxRetries = value;\n\n\t\tfor (const parser in this.parsers) {\n\t\t\tif (this.parsers.hasOwnProperty(parser)) {\n\t\t\t\tthis.parsers[parser].maxRetries = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tget maxRetries() {\n\t\treturn this.imgParser.maxRetries;\n\t}\n\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\n\t_getParser(url) {\n\t\tconst ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');\n\t\treturn this.parsers[ext] || this.imgParser;\n\t}\n\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tthis._getParser(url.original).load(url, callback, asset);\n\t}\n\n\topen(url, data, asset) {\n\t\tif (!url) return;\n\n\t\tlet texture = this._getParser(url).open(url, data, this._device);\n\n\t\tif (texture === null) {\n\t\t\ttexture = new Texture(this._device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8\n\t\t\t});\n\t\t} else {\n\t\t\t_completePartialMipmapChain(texture);\n\n\t\t\tif (data.unswizzledGGGR) {\n\t\t\t\tasset.file.variants.basis.opt &= ~8;\n\t\t\t}\n\t\t}\n\n\t\treturn texture;\n\t}\n\n\tpatch(asset, assets) {\n\t\tconst texture = asset.resource;\n\n\t\tif (!texture) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (asset.name && asset.name.length > 0) {\n\t\t\ttexture.name = asset.name;\n\t\t}\n\n\t\tconst assetData = asset.data;\n\n\t\tif (assetData.hasOwnProperty('minfilter')) {\n\t\t\ttexture.minFilter = JSON_FILTER_MODE[assetData.minfilter];\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('magfilter')) {\n\t\t\ttexture.magFilter = JSON_FILTER_MODE[assetData.magfilter];\n\t\t}\n\n\t\tif (!texture.cubemap) {\n\t\t\tif (assetData.hasOwnProperty('addressu')) {\n\t\t\t\ttexture.addressU = JSON_ADDRESS_MODE[assetData.addressu];\n\t\t\t}\n\n\t\t\tif (assetData.hasOwnProperty('addressv')) {\n\t\t\t\ttexture.addressV = JSON_ADDRESS_MODE[assetData.addressv];\n\t\t\t}\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('mipmaps')) {\n\t\t\ttexture.mipmaps = assetData.mipmaps;\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('anisotropy')) {\n\t\t\ttexture.anisotropy = assetData.anisotropy;\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('flipY')) {\n\t\t\ttexture.flipY = !!assetData.flipY;\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('type')) {\n\t\t\ttexture.type = JSON_TEXTURE_TYPE[assetData.type];\n\t\t} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {\n\t\t\ttexture.type = TEXTURETYPE_RGBM;\n\t\t} else if (asset.file && (asset.file.opt & 8) !== 0) {\n\t\t\ttexture.type = TEXTURETYPE_SWIZZLEGGGR;\n\t\t}\n\t}\n\n}\n\nclass TagsCache {\n\tconstructor(key = null) {\n\t\tthis._index = {};\n\t\tthis._key = key;\n\t}\n\n\taddItem(item) {\n\t\tconst tags = item.tags._list;\n\n\t\tfor (const tag of tags) this.add(tag, item);\n\t}\n\n\tremoveItem(item) {\n\t\tconst tags = item.tags._list;\n\n\t\tfor (const tag of tags) this.remove(tag, item);\n\t}\n\n\tadd(tag, item) {\n\t\tif (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) return;\n\n\t\tif (!this._index[tag]) {\n\t\t\tthis._index[tag] = {\n\t\t\t\tlist: []\n\t\t\t};\n\t\t\tif (this._key) this._index[tag].keys = {};\n\t\t}\n\n\t\tthis._index[tag].list.push(item);\n\n\t\tif (this._key) this._index[tag].keys[item[this._key]] = item;\n\t}\n\n\tremove(tag, item) {\n\t\tif (!this._index[tag]) return;\n\n\t\tif (this._key) {\n\t\t\tif (!this._index[tag].keys[item[this._key]]) return;\n\t\t}\n\n\t\tconst ind = this._index[tag].list.indexOf(item);\n\n\t\tif (ind === -1) return;\n\n\t\tthis._index[tag].list.splice(ind, 1);\n\n\t\tif (this._key) delete this._index[tag].keys[item[this._key]];\n\t\tif (this._index[tag].list.length === 0) delete this._index[tag];\n\t}\n\n\tfind(args) {\n\t\tconst index = {};\n\t\tconst items = [];\n\t\tlet item, tag, tags, tagsRest, missingIndex;\n\n\t\tconst sort = (a, b) => {\n\t\t\treturn this._index[a].list.length - this._index[b].list.length;\n\t\t};\n\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\ttag = args[i];\n\n\t\t\tif (tag instanceof Array) {\n\t\t\t\tif (tag.length === 0) continue;\n\n\t\t\t\tif (tag.length === 1) {\n\t\t\t\t\ttag = tag[0];\n\t\t\t\t} else {\n\t\t\t\t\tmissingIndex = false;\n\n\t\t\t\t\tfor (let t = 0; t < tag.length; t++) {\n\t\t\t\t\t\tif (!this._index[tag[t]]) {\n\t\t\t\t\t\t\tmissingIndex = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (missingIndex) continue;\n\t\t\t\t\ttags = tag.slice(0).sort(sort);\n\t\t\t\t\ttagsRest = tags.slice(1);\n\t\t\t\t\tif (tagsRest.length === 1) tagsRest = tagsRest[0];\n\n\t\t\t\t\tfor (let n = 0; n < this._index[tags[0]].list.length; n++) {\n\t\t\t\t\t\titem = this._index[tags[0]].list[n];\n\n\t\t\t\t\t\tif ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {\n\t\t\t\t\t\t\tif (this._key) index[item[this._key]] = true;\n\t\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tag && typeof tag === 'string' && this._index[tag]) {\n\t\t\t\tfor (let n = 0; n < this._index[tag].list.length; n++) {\n\t\t\t\t\titem = this._index[tag].list[n];\n\n\t\t\t\t\tif (this._key) {\n\t\t\t\t\t\tif (!index[item[this._key]]) {\n\t\t\t\t\t\t\tindex[item[this._key]] = true;\n\t\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (items.indexOf(item) === -1) {\n\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn items;\n\t}\n\n}\n\nclass AssetRegistry extends EventHandler {\n\tconstructor(loader) {\n\t\tsuper();\n\t\tthis._loader = loader;\n\t\tthis._assets = [];\n\t\tthis._cache = {};\n\t\tthis._names = {};\n\t\tthis._tags = new TagsCache('_id');\n\t\tthis._urls = {};\n\t\tthis.prefix = null;\n\t}\n\n\tlist(filters) {\n\t\tfilters = filters || {};\n\t\treturn this._assets.filter(asset => {\n\t\t\tlet include = true;\n\n\t\t\tif (filters.preload !== undefined) {\n\t\t\t\tinclude = asset.preload === filters.preload;\n\t\t\t}\n\n\t\t\treturn include;\n\t\t});\n\t}\n\n\tadd(asset) {\n\t\tconst index = this._assets.push(asset) - 1;\n\t\tlet url;\n\t\tthis._cache[asset.id] = index;\n\t\tif (!this._names[asset.name]) this._names[asset.name] = [];\n\n\t\tthis._names[asset.name].push(index);\n\n\t\tif (asset.file) {\n\t\t\turl = asset.file.url;\n\t\t\tthis._urls[url] = index;\n\t\t}\n\n\t\tasset.registry = this;\n\n\t\tthis._tags.addItem(asset);\n\n\t\tasset.tags.on('add', this._onTagAdd, this);\n\t\tasset.tags.on('remove', this._onTagRemove, this);\n\t\tthis.fire(\"add\", asset);\n\t\tthis.fire(\"add:\" + asset.id, asset);\n\t\tif (url) this.fire(\"add:url:\" + url, asset);\n\t\tif (asset.preload) this.load(asset);\n\t}\n\n\tremove(asset) {\n\t\tconst idx = this._cache[asset.id];\n\t\tconst url = asset.file ? asset.file.url : null;\n\n\t\tif (idx !== undefined) {\n\t\t\tthis._assets.splice(idx, 1);\n\n\t\t\tdelete this._cache[asset.id];\n\t\t\tthis._names = {};\n\t\t\tthis._urls = [];\n\n\t\t\tfor (let i = 0, l = this._assets.length; i < l; i++) {\n\t\t\t\tconst a = this._assets[i];\n\t\t\t\tthis._cache[a.id] = i;\n\n\t\t\t\tif (!this._names[a.name]) {\n\t\t\t\t\tthis._names[a.name] = [];\n\t\t\t\t}\n\n\t\t\t\tthis._names[a.name].push(i);\n\n\t\t\t\tif (a.file) {\n\t\t\t\t\tthis._urls[a.file.url] = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._tags.removeItem(asset);\n\n\t\t\tasset.tags.off('add', this._onTagAdd, this);\n\t\t\tasset.tags.off('remove', this._onTagRemove, this);\n\t\t\tasset.fire(\"remove\", asset);\n\t\t\tthis.fire(\"remove\", asset);\n\t\t\tthis.fire(\"remove:\" + asset.id, asset);\n\t\t\tif (url) this.fire(\"remove:url:\" + url, asset);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget(id) {\n\t\tconst idx = this._cache[id];\n\t\treturn this._assets[idx];\n\t}\n\n\tgetByUrl(url) {\n\t\tconst idx = this._urls[url];\n\t\treturn this._assets[idx];\n\t}\n\n\tload(asset) {\n\t\tif (asset.loading || asset.loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst file = asset.file;\n\n\t\tconst _opened = resource => {\n\t\t\tif (resource instanceof Array) {\n\t\t\t\tasset.resources = resource;\n\t\t\t} else {\n\t\t\t\tasset.resource = resource;\n\t\t\t}\n\n\t\t\tthis._loader.patch(asset, this);\n\n\t\t\tthis.fire(\"load\", asset);\n\t\t\tthis.fire(\"load:\" + asset.id, asset);\n\t\t\tif (file && file.url) this.fire(\"load:url:\" + file.url, asset);\n\t\t\tasset.fire(\"load\", asset);\n\t\t};\n\n\t\tconst _loaded = (err, resource, extra) => {\n\t\t\tasset.loaded = true;\n\t\t\tasset.loading = false;\n\n\t\t\tif (err) {\n\t\t\t\tthis.fire(\"error\", err, asset);\n\t\t\t\tthis.fire(\"error:\" + asset.id, err, asset);\n\t\t\t\tasset.fire(\"error\", err, asset);\n\t\t\t} else {\n\t\t\t\tif (!script.legacy && asset.type === 'script') {\n\t\t\t\t\tconst handler = this._loader.getHandler('script');\n\n\t\t\t\t\tif (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {\n\t\t\t\t\t\tdocument.head.removeChild(handler._cache[asset.id]);\n\t\t\t\t\t}\n\n\t\t\t\t\thandler._cache[asset.id] = extra;\n\t\t\t\t}\n\n\t\t\t\t_opened(resource);\n\t\t\t}\n\t\t};\n\n\t\tif (file || asset.type === 'cubemap') {\n\t\t\tthis.fire(\"load:start\", asset);\n\t\t\tthis.fire(\"load:\" + asset.id + \":start\", asset);\n\t\t\tasset.loading = true;\n\n\t\t\tthis._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);\n\t\t} else {\n\t\t\tconst resource = this._loader.open(asset.type, asset.data);\n\n\t\t\tasset.loaded = true;\n\n\t\t\t_opened(resource);\n\t\t}\n\t}\n\n\tloadFromUrl(url, type, callback) {\n\t\tthis.loadFromUrlAndFilename(url, null, type, callback);\n\t}\n\n\tloadFromUrlAndFilename(url, filename, type, callback) {\n\t\tconst name = path.getBasename(filename || url);\n\t\tconst file = {\n\t\t\tfilename: filename || name,\n\t\t\turl: url\n\t\t};\n\t\tlet asset = this.getByUrl(url);\n\n\t\tif (!asset) {\n\t\t\tasset = new Asset(name, type, file);\n\t\t\tthis.add(asset);\n\t\t} else if (asset.loaded) {\n\t\t\tcallback(asset.loadFromUrlError || null, asset);\n\t\t\treturn;\n\t\t}\n\n\t\tconst startLoad = asset => {\n\t\t\tasset.once(\"load\", loadedAsset => {\n\t\t\t\tif (type === 'material') {\n\t\t\t\t\tthis._loadTextures(loadedAsset, (err, textures) => {\n\t\t\t\t\t\tcallback(err, loadedAsset);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(null, loadedAsset);\n\t\t\t\t}\n\t\t\t});\n\t\t\tasset.once(\"error\", err => {\n\t\t\t\tif (err) {\n\t\t\t\t\tthis.loadFromUrlError = err;\n\t\t\t\t}\n\n\t\t\t\tcallback(err, asset);\n\t\t\t});\n\t\t\tthis.load(asset);\n\t\t};\n\n\t\tif (asset.resource) {\n\t\t\tcallback(null, asset);\n\t\t} else if (type === 'model') {\n\t\t\tthis._loadModel(asset, startLoad);\n\t\t} else {\n\t\t\tstartLoad(asset);\n\t\t}\n\t}\n\n\t_loadModel(modelAsset, continuation) {\n\t\tconst url = modelAsset.getFileUrl();\n\t\tconst ext = path.getExtension(url);\n\n\t\tif (ext === '.json' || ext === '.glb') {\n\t\t\tconst dir = path.getDirectory(url);\n\t\t\tconst basename = path.getBasename(url);\n\t\t\tconst mappingUrl = path.join(dir, basename.replace(ext, \".mapping.json\"));\n\n\t\t\tthis._loader.load(mappingUrl, 'json', (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tmodelAsset.data = {\n\t\t\t\t\t\tmapping: []\n\t\t\t\t\t};\n\t\t\t\t\tcontinuation(modelAsset);\n\t\t\t\t} else {\n\t\t\t\t\tthis._loadMaterials(modelAsset, data, (e, materials) => {\n\t\t\t\t\t\tmodelAsset.data = data;\n\t\t\t\t\t\tcontinuation(modelAsset);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tcontinuation(modelAsset);\n\t\t}\n\t}\n\n\t_loadMaterials(modelAsset, mapping, callback) {\n\t\tconst materials = [];\n\t\tlet count = 0;\n\n\t\tconst onMaterialLoaded = (err, materialAsset) => {\n\t\t\tthis._loadTextures(materialAsset, (err, textures) => {\n\t\t\t\tmaterials.push(materialAsset);\n\n\t\t\t\tif (materials.length === count) {\n\t\t\t\t\tcallback(null, materials);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tfor (let i = 0; i < mapping.mapping.length; i++) {\n\t\t\tconst path = mapping.mapping[i].path;\n\n\t\t\tif (path) {\n\t\t\t\tcount++;\n\t\t\t\tconst url = modelAsset.getAbsoluteUrl(path);\n\t\t\t\tthis.loadFromUrl(url, \"material\", onMaterialLoaded);\n\t\t\t}\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\tcallback(null, materials);\n\t\t}\n\t}\n\n\t_loadTextures(materialAsset, callback) {\n\t\tconst textures = [];\n\t\tlet count = 0;\n\t\tconst data = materialAsset.data;\n\n\t\tif (data.mappingFormat !== 'path') {\n\t\t\tcallback(null, textures);\n\t\t\treturn;\n\t\t}\n\n\t\tconst onTextureLoaded = (err, texture) => {\n\t\t\tif (err) console.error(err);\n\t\t\ttextures.push(texture);\n\n\t\t\tif (textures.length === count) {\n\t\t\t\tcallback(null, textures);\n\t\t\t}\n\t\t};\n\n\t\tconst texParams = standardMaterialTextureParameters;\n\n\t\tfor (let i = 0; i < texParams.length; i++) {\n\t\t\tconst path = data[texParams[i]];\n\n\t\t\tif (path && typeof path === 'string') {\n\t\t\t\tcount++;\n\t\t\t\tconst url = materialAsset.getAbsoluteUrl(path);\n\t\t\t\tthis.loadFromUrl(url, \"texture\", onTextureLoaded);\n\t\t\t}\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\tcallback(null, textures);\n\t\t}\n\t}\n\n\tfindAll(name, type) {\n\t\tconst idxs = this._names[name];\n\n\t\tif (idxs) {\n\t\t\tconst assets = idxs.map(idx => {\n\t\t\t\treturn this._assets[idx];\n\t\t\t});\n\n\t\t\tif (type) {\n\t\t\t\treturn assets.filter(asset => {\n\t\t\t\t\treturn asset.type === type;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn assets;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\t_onTagAdd(tag, asset) {\n\t\tthis._tags.add(tag, asset);\n\t}\n\n\t_onTagRemove(tag, asset) {\n\t\tthis._tags.remove(tag, asset);\n\t}\n\n\tfindByTag() {\n\t\treturn this._tags.find(arguments);\n\t}\n\n\tfilter(callback) {\n\t\treturn this._assets.filter(asset => callback(asset));\n\t}\n\n\tfind(name, type) {\n\t\tconst asset = this.findAll(name, type);\n\t\treturn asset.length > 0 ? asset[0] : null;\n\t}\n\n}\n\nclass BundleRegistry {\n\tconstructor(assets) {\n\t\tthis._assets = assets;\n\t\tthis._bundleAssets = {};\n\t\tthis._assetsInBundles = {};\n\t\tthis._urlsInBundles = {};\n\t\tthis._fileRequests = {};\n\n\t\tthis._assets.on('add', this._onAssetAdded, this);\n\n\t\tthis._assets.on('remove', this._onAssetRemoved, this);\n\t}\n\n\t_onAssetAdded(asset) {\n\t\tif (asset.type === 'bundle') {\n\t\t\tthis._bundleAssets[asset.id] = asset;\n\n\t\t\tthis._registerBundleEventListeners(asset.id);\n\n\t\t\tfor (let i = 0, len = asset.data.assets.length; i < len; i++) {\n\t\t\t\tthis._indexAssetInBundle(asset.data.assets[i], asset);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._assetsInBundles[asset.id]) {\n\t\t\t\tthis._indexAssetFileUrls(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\t_registerBundleEventListeners(bundleAssetId) {\n\t\tthis._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);\n\n\t\tthis._assets.on('error:' + bundleAssetId, this._onBundleError, this);\n\t}\n\n\t_unregisterBundleEventListeners(bundleAssetId) {\n\t\tthis._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);\n\n\t\tthis._assets.off('error:' + bundleAssetId, this._onBundleError, this);\n\t}\n\n\t_indexAssetInBundle(assetId, bundleAsset) {\n\t\tif (!this._assetsInBundles[assetId]) {\n\t\t\tthis._assetsInBundles[assetId] = [bundleAsset];\n\t\t} else {\n\t\t\tconst bundles = this._assetsInBundles[assetId];\n\t\t\tconst idx = bundles.indexOf(bundleAsset);\n\n\t\t\tif (idx === -1) {\n\t\t\t\tbundles.push(bundleAsset);\n\t\t\t}\n\t\t}\n\n\t\tconst asset = this._assets.get(assetId);\n\n\t\tif (asset) {\n\t\t\tthis._indexAssetFileUrls(asset);\n\t\t}\n\t}\n\n\t_indexAssetFileUrls(asset) {\n\t\tconst urls = this._getAssetFileUrls(asset);\n\n\t\tif (!urls) return;\n\n\t\tfor (let i = 0, len = urls.length; i < len; i++) {\n\t\t\tconst url = urls[i];\n\t\t\tthis._urlsInBundles[url] = this._assetsInBundles[asset.id];\n\t\t}\n\t}\n\n\t_getAssetFileUrls(asset) {\n\t\tlet url = asset.getFileUrl();\n\t\tif (!url) return null;\n\t\turl = this._normalizeUrl(url);\n\t\tconst urls = [url];\n\n\t\tif (asset.type === 'font') {\n\t\t\tconst numFiles = asset.data.info.maps.length;\n\n\t\t\tfor (let i = 1; i < numFiles; i++) {\n\t\t\t\turls.push(url.replace('.png', i + '.png'));\n\t\t\t}\n\t\t}\n\n\t\treturn urls;\n\t}\n\n\t_normalizeUrl(url) {\n\t\treturn url && url.split('?')[0];\n\t}\n\n\t_onAssetRemoved(asset) {\n\t\tif (asset.type === 'bundle') {\n\t\t\tdelete this._bundleAssets[asset.id];\n\n\t\t\tthis._unregisterBundleEventListeners(asset.id);\n\n\t\t\tfor (const id in this._assetsInBundles) {\n\t\t\t\tconst array = this._assetsInBundles[id];\n\t\t\t\tconst idx = array.indexOf(asset);\n\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tarray.splice(idx, 1);\n\n\t\t\t\t\tif (!array.length) {\n\t\t\t\t\t\tdelete this._assetsInBundles[id];\n\n\t\t\t\t\t\tfor (const url in this._urlsInBundles) {\n\t\t\t\t\t\t\tif (this._urlsInBundles[url] === array) {\n\t\t\t\t\t\t\t\tdelete this._urlsInBundles[url];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._onBundleError(`Bundle ${asset.id} was removed`, asset);\n\t\t} else if (this._assetsInBundles[asset.id]) {\n\t\t\tdelete this._assetsInBundles[asset.id];\n\n\t\t\tconst urls = this._getAssetFileUrls(asset);\n\n\t\t\tfor (let i = 0, len = urls.length; i < len; i++) {\n\t\t\t\tdelete this._urlsInBundles[urls[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\t_onBundleLoaded(bundleAsset) {\n\t\tif (!bundleAsset.resource) {\n\t\t\tthis._onBundleError(`Bundle ${bundleAsset.id} failed to load`, bundleAsset);\n\n\t\t\treturn;\n\t\t}\n\n\t\trequestAnimationFrame(() => {\n\t\t\tif (!this._fileRequests) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (const url in this._fileRequests) {\n\t\t\t\tconst bundles = this._urlsInBundles[url];\n\t\t\t\tif (!bundles || bundles.indexOf(bundleAsset) === -1) continue;\n\t\t\t\tconst decodedUrl = decodeURIComponent(url);\n\t\t\t\tlet err = null;\n\n\t\t\t\tif (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {\n\t\t\t\t\terr = `Bundle ${bundleAsset.id} does not contain URL ${url}`;\n\t\t\t\t}\n\n\t\t\t\tconst requests = this._fileRequests[url];\n\n\t\t\t\tfor (let i = 0, len = requests.length; i < len; i++) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\trequests[i](err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdelete this._fileRequests[url];\n\t\t\t}\n\t\t});\n\t}\n\n\t_onBundleError(err, bundleAsset) {\n\t\tfor (const url in this._fileRequests) {\n\t\t\tconst bundle = this._findLoadedOrLoadingBundleForUrl(url);\n\n\t\t\tif (!bundle) {\n\t\t\t\tconst requests = this._fileRequests[url];\n\n\t\t\t\tfor (let i = 0, len = requests.length; i < len; i++) {\n\t\t\t\t\trequests[i](err);\n\t\t\t\t}\n\n\t\t\t\tdelete this._fileRequests[url];\n\t\t\t}\n\t\t}\n\t}\n\n\t_findLoadedOrLoadingBundleForUrl(url) {\n\t\tconst bundles = this._urlsInBundles[url];\n\t\tif (!bundles) return null;\n\t\tconst len = bundles.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (bundles[i].loaded && bundles[i].resource) {\n\t\t\t\treturn bundles[i];\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (bundles[i].loading) {\n\t\t\t\treturn bundles[i];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tlistBundlesForAsset(asset) {\n\t\treturn this._assetsInBundles[asset.id] || null;\n\t}\n\n\tlist() {\n\t\tconst result = [];\n\n\t\tfor (const id in this._bundleAssets) {\n\t\t\tresult.push(this._bundleAssets[id]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\thasUrl(url) {\n\t\treturn !!this._urlsInBundles[url];\n\t}\n\n\tcanLoadUrl(url) {\n\t\treturn !!this._findLoadedOrLoadingBundleForUrl(url);\n\t}\n\n\tloadUrl(url, callback) {\n\t\tconst bundle = this._findLoadedOrLoadingBundleForUrl(url);\n\n\t\tif (!bundle) {\n\t\t\tcallback(`URL ${url} not found in any bundles`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (bundle.loaded) {\n\t\t\tconst decodedUrl = decodeURIComponent(url);\n\n\t\t\tif (!bundle.resource.hasBlobUrl(decodedUrl)) {\n\t\t\t\tcallback(`Bundle ${bundle.id} does not contain URL ${url}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallback(null, bundle.resource.getBlobUrl(decodedUrl));\n\t\t} else if (this._fileRequests.hasOwnProperty(url)) {\n\t\t\tthis._fileRequests[url].push(callback);\n\t\t} else {\n\t\t\tthis._fileRequests[url] = [callback];\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._assets.off('add', this._onAssetAdded, this);\n\n\t\tthis._assets.off('remove', this._onAssetRemoved, this);\n\n\t\tfor (const id in this._bundleAssets) {\n\t\t\tthis._unregisterBundleEventListeners(id);\n\t\t}\n\n\t\tthis._assets = null;\n\t\tthis._bundleAssets = null;\n\t\tthis._assetsInBundles = null;\n\t\tthis._urlsInBundles = null;\n\t\tthis._fileRequests = null;\n\t}\n\n}\n\nconst components = ['x', 'y', 'z', 'w'];\nconst vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];\n\nfunction rawToValue(app, args, value, old) {\n\tswitch (args.type) {\n\t\tcase 'boolean':\n\t\t\treturn !!value;\n\n\t\tcase 'number':\n\t\t\tif (typeof value === 'number') {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tconst v = parseInt(value, 10);\n\t\t\t\tif (isNaN(v)) return null;\n\t\t\t\treturn v;\n\t\t\t} else if (typeof value === 'boolean') {\n\t\t\t\treturn 0 + value;\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\tcase 'json':\n\t\t\t{\n\t\t\t\tconst result = {};\n\n\t\t\t\tif (Array.isArray(args.schema)) {\n\t\t\t\t\tif (!value || typeof value !== 'object') {\n\t\t\t\t\t\tvalue = {};\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < args.schema.length; i++) {\n\t\t\t\t\t\tconst field = args.schema[i];\n\t\t\t\t\t\tif (!field.name) continue;\n\n\t\t\t\t\t\tif (field.array) {\n\t\t\t\t\t\t\tresult[field.name] = [];\n\t\t\t\t\t\t\tconst arr = Array.isArray(value[field.name]) ? value[field.name] : [];\n\n\t\t\t\t\t\t\tfor (let j = 0; j < arr.length; j++) {\n\t\t\t\t\t\t\t\tresult[field.name].push(rawToValue(app, field, arr[j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;\n\t\t\t\t\t\t\tresult[field.name] = rawToValue(app, field, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\tcase 'asset':\n\t\t\tif (value instanceof Asset) {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'number') {\n\t\t\t\treturn app.assets.get(value) || null;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\treturn app.assets.get(parseInt(value, 10)) || null;\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\tcase 'entity':\n\t\t\tif (value instanceof GraphNode) {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\treturn app.getEntityFromIndex(value);\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\tcase 'rgb':\n\t\tcase 'rgba':\n\t\t\tif (value instanceof Color) {\n\t\t\t\tif (old instanceof Color) {\n\t\t\t\t\told.copy(value);\n\t\t\t\t\treturn old;\n\t\t\t\t}\n\n\t\t\t\treturn value.clone();\n\t\t\t} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {\n\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\tif (typeof value[i] !== 'number') return null;\n\t\t\t\t}\n\n\t\t\t\tif (!old) old = new Color();\n\t\t\t\told.r = value[0];\n\t\t\t\told.g = value[1];\n\t\t\t\told.b = value[2];\n\t\t\t\told.a = value.length === 3 ? 1 : value[3];\n\t\t\t\treturn old;\n\t\t\t} else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {\n\t\t\t\tif (!old) old = new Color();\n\t\t\t\told.fromString(value);\n\t\t\t\treturn old;\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\tcase 'vec2':\n\t\tcase 'vec3':\n\t\tcase 'vec4':\n\t\t\t{\n\t\t\t\tconst len = parseInt(args.type.slice(3), 10);\n\t\t\t\tconst vecType = vecLookup[len];\n\n\t\t\t\tif (value instanceof vecType) {\n\t\t\t\t\tif (old instanceof vecType) {\n\t\t\t\t\t\told.copy(value);\n\t\t\t\t\t\treturn old;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value.clone();\n\t\t\t\t} else if (value instanceof Array && value.length === len) {\n\t\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\t\tif (typeof value[i] !== 'number') return null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!old) old = new vecType();\n\n\t\t\t\t\tfor (let i = 0; i < len; i++) old[components[i]] = value[i];\n\n\t\t\t\t\treturn old;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\tcase 'curve':\n\t\t\tif (value) {\n\t\t\t\tlet curve;\n\n\t\t\t\tif (value instanceof Curve || value instanceof CurveSet) {\n\t\t\t\t\tcurve = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tconst CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;\n\t\t\t\t\tcurve = new CurveType(value.keys);\n\t\t\t\t\tcurve.type = value.type;\n\t\t\t\t}\n\n\t\t\t\treturn curve;\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nclass ScriptAttributes {\n\tconstructor(scriptType) {\n\t\tthis.scriptType = scriptType;\n\t\tthis.index = {};\n\t}\n\n\tadd(name, args) {\n\t\tif (this.index[name]) {\n\t\t\treturn;\n\t\t} else if (ScriptAttributes.reservedNames.has(name)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index[name] = args;\n\t\tObject.defineProperty(this.scriptType.prototype, name, {\n\t\t\tget: function () {\n\t\t\t\treturn this.__attributes[name];\n\t\t\t},\n\t\t\tset: function (raw) {\n\t\t\t\tconst evt = 'attr';\n\t\t\t\tconst evtName = 'attr:' + name;\n\t\t\t\tconst old = this.__attributes[name];\n\t\t\t\tlet oldCopy = old;\n\n\t\t\t\tif (old && args.type !== 'json' && old.clone) {\n\t\t\t\t\tif (this._callbacks[evt] || this._callbacks[evtName]) {\n\t\t\t\t\t\toldCopy = old.clone();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (args.array) {\n\t\t\t\t\tthis.__attributes[name] = [];\n\n\t\t\t\t\tif (raw) {\n\t\t\t\t\t\tfor (let i = 0, len = raw.length; i < len; i++) {\n\t\t\t\t\t\t\tthis.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.__attributes[name] = rawToValue(this.app, args, raw, old);\n\t\t\t\t}\n\n\t\t\t\tthis.fire(evt, name, this.__attributes[name], oldCopy);\n\t\t\t\tthis.fire(evtName, this.__attributes[name], oldCopy);\n\t\t\t}\n\t\t});\n\t}\n\n\tremove(name) {\n\t\tif (!this.index[name]) return false;\n\t\tdelete this.index[name];\n\t\tdelete this.scriptType.prototype[name];\n\t\treturn true;\n\t}\n\n\thas(name) {\n\t\treturn !!this.index[name];\n\t}\n\n\tget(name) {\n\t\treturn this.index[name] || null;\n\t}\n\n}\n\nScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);\n\nclass Component extends EventHandler {\n\tconstructor(system, entity) {\n\t\tsuper();\n\t\tthis.system = system;\n\t\tthis.entity = entity;\n\n\t\tif (this.system.schema && !this._accessorsBuilt) {\n\t\t\tthis.buildAccessors(this.system.schema);\n\t\t}\n\n\t\tthis.on(\"set\", function (name, oldValue, newValue) {\n\t\t\tthis.fire(\"set_\" + name, name, oldValue, newValue);\n\t\t});\n\t\tthis.on('set_enabled', this.onSetEnabled, this);\n\t}\n\n\tstatic _buildAccessors(obj, schema) {\n\t\tschema.forEach(function (descriptor) {\n\t\t\tconst name = typeof descriptor === 'object' ? descriptor.name : descriptor;\n\t\t\tObject.defineProperty(obj, name, {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.data[name];\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\tconst data = this.data;\n\t\t\t\t\tconst oldValue = data[name];\n\t\t\t\t\tdata[name] = value;\n\t\t\t\t\tthis.fire('set', name, oldValue, value);\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t});\n\t\tobj._accessorsBuilt = true;\n\t}\n\n\tbuildAccessors(schema) {\n\t\tComponent._buildAccessors(this, schema);\n\t}\n\n\tonSetEnabled(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.entity.enabled) {\n\t\t\t\tif (newValue) {\n\t\t\t\t\tthis.onEnable();\n\t\t\t\t} else {\n\t\t\t\t\tthis.onDisable();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {}\n\n\tonDisable() {}\n\n\tonPostStateChange() {}\n\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\n}\n\nclass ScriptComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._scripts = [];\n\t\tthis._updateList = new SortedLoopArray({\n\t\t\tsortBy: '__executionOrder'\n\t\t});\n\t\tthis._postUpdateList = new SortedLoopArray({\n\t\t\tsortBy: '__executionOrder'\n\t\t});\n\t\tthis._scriptsIndex = {};\n\t\tthis._destroyedScripts = [];\n\t\tthis._destroyed = false;\n\t\tthis._scriptsData = null;\n\t\tthis._oldState = true;\n\t\tthis._enabled = true;\n\t\tthis._beingEnabled = false;\n\t\tthis._isLoopingThroughScripts = false;\n\t\tthis._executionOrder = -1;\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\n\tset enabled(value) {\n\t\tconst oldValue = this._enabled;\n\t\tthis._enabled = value;\n\t\tthis.fire('set', 'enabled', oldValue, value);\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tset scripts(value) {\n\t\tthis._scriptsData = value;\n\n\t\tfor (const key in value) {\n\t\t\tif (!value.hasOwnProperty(key)) continue;\n\t\t\tconst script = this._scriptsIndex[key];\n\n\t\t\tif (script) {\n\t\t\t\tif (typeof value[key].enabled === 'boolean') script.enabled = !!value[key].enabled;\n\n\t\t\t\tif (typeof value[key].attributes === 'object') {\n\t\t\t\t\tfor (const attr in value[key].attributes) {\n\t\t\t\t\t\tif (ScriptAttributes.reservedNames.has(attr)) continue;\n\n\t\t\t\t\t\tif (!script.__attributes.hasOwnProperty(attr)) {\n\t\t\t\t\t\t\tconst scriptType = this.system.app.scripts.get(key);\n\t\t\t\t\t\t\tif (scriptType) scriptType.attributes.add(attr, {});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscript[attr] = value[key].attributes[attr];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(this.order);\n\t\t\t}\n\t\t}\n\t}\n\n\tget scripts() {\n\t\treturn this._scripts;\n\t}\n\n\tonEnable() {\n\t\tthis._beingEnabled = true;\n\n\t\tthis._checkState();\n\n\t\tif (!this.entity._beingEnabled) {\n\t\t\tthis.onPostStateChange();\n\t\t}\n\n\t\tthis._beingEnabled = false;\n\t}\n\n\tonDisable() {\n\t\tthis._checkState();\n\t}\n\n\tonPostStateChange() {\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) {\n\t\t\tconst script = this.scripts[i];\n\n\t\t\tif (script._initialized && !script._postInitialized && script.enabled) {\n\t\t\t\tscript._postInitialized = true;\n\t\t\t\tif (script.postInitialize) this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);\n\t\t\t}\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_beginLooping() {\n\t\tconst looping = this._isLoopingThroughScripts;\n\t\tthis._isLoopingThroughScripts = true;\n\t\treturn looping;\n\t}\n\n\t_endLooping(wasLoopingBefore) {\n\t\tthis._isLoopingThroughScripts = wasLoopingBefore;\n\n\t\tif (!this._isLoopingThroughScripts) {\n\t\t\tthis._removeDestroyedScripts();\n\t\t}\n\t}\n\n\t_onSetEnabled(prop, old, value) {\n\t\tthis._beingEnabled = true;\n\n\t\tthis._checkState();\n\n\t\tthis._beingEnabled = false;\n\t}\n\n\t_checkState() {\n\t\tconst state = this.enabled && this.entity.enabled;\n\t\tif (state === this._oldState) return;\n\t\tthis._oldState = state;\n\t\tthis.fire(state ? 'enable' : 'disable');\n\t\tthis.fire('state', state);\n\n\t\tif (state) {\n\t\t\tthis.system._addComponentToEnabled(this);\n\t\t} else {\n\t\t\tthis.system._removeComponentFromEnabled(this);\n\t\t}\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) {\n\t\t\tconst script = this.scripts[i];\n\t\t\tscript.enabled = script._enabled;\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (let i = 0; i < this.scripts.length; i++) {\n\t\t\tconst script = this.scripts[i];\n\t\t\tif (!script) continue;\n\t\t\tthis.destroy(script.__scriptType.__name);\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_removeDestroyedScripts() {\n\t\tconst len = this._destroyedScripts.length;\n\t\tif (!len) return;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst script = this._destroyedScripts[i];\n\n\t\t\tthis._removeScriptInstance(script);\n\t\t}\n\n\t\tthis._destroyedScripts.length = 0;\n\n\t\tthis._resetExecutionOrder(0, this._scripts.length);\n\t}\n\n\t_onInitializeAttributes() {\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) this.scripts[i].__initializeAttributes();\n\t}\n\n\t_scriptMethod(script, method, arg) {\n\t\tscript[method](arg);\n\t}\n\n\t_onInitialize() {\n\t\tconst scripts = this._scripts;\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (let i = 0, len = scripts.length; i < len; i++) {\n\t\t\tconst script = scripts[i];\n\n\t\t\tif (!script._initialized && script.enabled) {\n\t\t\t\tscript._initialized = true;\n\t\t\t\tif (script.initialize) this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);\n\t\t\t}\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_onPostInitialize() {\n\t\tthis.onPostStateChange();\n\t}\n\n\t_onUpdate(dt) {\n\t\tconst list = this._updateList;\n\t\tif (!list.length) return;\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {\n\t\t\tconst script = list.items[list.loopIndex];\n\n\t\t\tif (script.enabled) {\n\t\t\t\tthis._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);\n\t\t\t}\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_onPostUpdate(dt) {\n\t\tconst list = this._postUpdateList;\n\t\tif (!list.length) return;\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {\n\t\t\tconst script = list.items[list.loopIndex];\n\n\t\t\tif (script.enabled) {\n\t\t\t\tthis._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);\n\t\t\t}\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_insertScriptInstance(scriptInstance, index, scriptsLength) {\n\t\tif (index === -1) {\n\t\t\tthis._scripts.push(scriptInstance);\n\n\t\t\tscriptInstance.__executionOrder = scriptsLength;\n\n\t\t\tif (scriptInstance.update) {\n\t\t\t\tthis._updateList.append(scriptInstance);\n\t\t\t}\n\n\t\t\tif (scriptInstance.postUpdate) {\n\t\t\t\tthis._postUpdateList.append(scriptInstance);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._scripts.splice(index, 0, scriptInstance);\n\n\t\t\tscriptInstance.__executionOrder = index;\n\n\t\t\tthis._resetExecutionOrder(index + 1, scriptsLength + 1);\n\n\t\t\tif (scriptInstance.update) {\n\t\t\t\tthis._updateList.insert(scriptInstance);\n\t\t\t}\n\n\t\t\tif (scriptInstance.postUpdate) {\n\t\t\t\tthis._postUpdateList.insert(scriptInstance);\n\t\t\t}\n\t\t}\n\t}\n\n\t_removeScriptInstance(scriptInstance) {\n\t\tconst idx = this._scripts.indexOf(scriptInstance);\n\n\t\tif (idx === -1) return idx;\n\n\t\tthis._scripts.splice(idx, 1);\n\n\t\tif (scriptInstance.update) {\n\t\t\tthis._updateList.remove(scriptInstance);\n\t\t}\n\n\t\tif (scriptInstance.postUpdate) {\n\t\t\tthis._postUpdateList.remove(scriptInstance);\n\t\t}\n\n\t\treturn idx;\n\t}\n\n\t_resetExecutionOrder(startIndex, scriptsLength) {\n\t\tfor (let i = startIndex; i < scriptsLength; i++) {\n\t\t\tthis._scripts[i].__executionOrder = i;\n\t\t}\n\t}\n\n\t_resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {\n\t\tif (attribute.array) {\n\t\t\tconst len = oldValue.length;\n\n\t\t\tif (!len) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newGuidArray = oldValue.slice();\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];\n\n\t\t\t\tif (duplicatedIdsMap[guid]) {\n\t\t\t\t\tnewGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnewAttributes[attributeName] = newGuidArray;\n\t\t} else {\n\t\t\tif (oldValue instanceof Entity) {\n\t\t\t\toldValue = oldValue.getGuid();\n\t\t\t} else if (typeof oldValue !== 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (duplicatedIdsMap[oldValue]) {\n\t\t\t\tnewAttributes[attributeName] = duplicatedIdsMap[oldValue];\n\t\t\t}\n\t\t}\n\t}\n\n\thas(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\treturn !!this._scriptsIndex[nameOrType];\n\t\t}\n\n\t\tif (!nameOrType) return false;\n\t\tconst scriptType = nameOrType;\n\t\tconst scriptName = scriptType.__name;\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tconst scriptInstance = scriptData && scriptData.instance;\n\t\treturn scriptInstance instanceof scriptType;\n\t}\n\n\tget(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\tconst data = this._scriptsIndex[nameOrType];\n\t\t\treturn data ? data.instance : null;\n\t\t}\n\n\t\tif (!nameOrType) return null;\n\t\tconst scriptType = nameOrType;\n\t\tconst scriptName = scriptType.__name;\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tconst scriptInstance = scriptData && scriptData.instance;\n\t\treturn scriptInstance instanceof scriptType ? scriptInstance : null;\n\t}\n\n\tcreate(nameOrType, args = {}) {\n\t\tconst self = this;\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tscriptName = scriptType.__name;\n\t\t}\n\n\t\tif (scriptType) {\n\t\t\tif (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {\n\t\t\t\tconst scriptInstance = new scriptType({\n\t\t\t\t\tapp: this.system.app,\n\t\t\t\t\tentity: this.entity,\n\t\t\t\t\tenabled: args.hasOwnProperty('enabled') ? args.enabled : true,\n\t\t\t\t\tattributes: args.attributes\n\t\t\t\t});\n\t\t\t\tconst len = this._scripts.length;\n\t\t\t\tlet ind = -1;\n\t\t\t\tif (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) ind = args.ind;\n\n\t\t\t\tthis._insertScriptInstance(scriptInstance, ind, len);\n\n\t\t\t\tthis._scriptsIndex[scriptName] = {\n\t\t\t\t\tinstance: scriptInstance,\n\t\t\t\t\tonSwap: function () {\n\t\t\t\t\t\tself.swap(scriptName);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis[scriptName] = scriptInstance;\n\t\t\t\tif (!args.preloading) scriptInstance.__initializeAttributes();\n\t\t\t\tthis.fire('create', scriptName, scriptInstance);\n\t\t\t\tthis.fire('create:' + scriptName, scriptInstance);\n\t\t\t\tthis.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);\n\n\t\t\t\tif (!args.preloading) {\n\t\t\t\t\tif (scriptInstance.enabled && !scriptInstance._initialized) {\n\t\t\t\t\t\tscriptInstance._initialized = true;\n\t\t\t\t\t\tif (scriptInstance.initialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scriptInstance.enabled && !scriptInstance._postInitialized) {\n\t\t\t\t\t\tscriptInstance._postInitialized = true;\n\t\t\t\t\t\tif (scriptInstance.postInitialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn scriptInstance;\n\t\t\t}\n\n\t\t\tconsole.warn(`script '${scriptName}' is already added to entity '${this.entity.name}'`);\n\t\t} else {\n\t\t\tthis._scriptsIndex[scriptName] = {\n\t\t\t\tawaiting: true,\n\t\t\t\tind: this._scripts.length\n\t\t\t};\n\t\t\tconsole.warn(`script '${scriptName}' is not found, awaiting it to be added to registry`);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdestroy(nameOrType) {\n\t\tlet scriptName = nameOrType;\n\t\tlet scriptType = nameOrType;\n\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tscriptName = scriptType.__name;\n\t\t}\n\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tdelete this._scriptsIndex[scriptName];\n\t\tif (!scriptData) return false;\n\t\tconst scriptInstance = scriptData.instance;\n\n\t\tif (scriptInstance && !scriptInstance._destroyed) {\n\t\t\tscriptInstance.enabled = false;\n\t\t\tscriptInstance._destroyed = true;\n\n\t\t\tif (!this._isLoopingThroughScripts) {\n\t\t\t\tconst ind = this._removeScriptInstance(scriptInstance);\n\n\t\t\t\tif (ind >= 0) {\n\t\t\t\t\tthis._resetExecutionOrder(ind, this._scripts.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._destroyedScripts.push(scriptInstance);\n\t\t\t}\n\t\t}\n\n\t\tthis.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);\n\t\tdelete this[scriptName];\n\t\tthis.fire('destroy', scriptName, scriptInstance || null);\n\t\tthis.fire('destroy:' + scriptName, scriptInstance || null);\n\t\tif (scriptInstance) scriptInstance.fire('destroy');\n\t\treturn true;\n\t}\n\n\tswap(nameOrType) {\n\t\tlet scriptName = nameOrType;\n\t\tlet scriptType = nameOrType;\n\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tscriptName = scriptType.__name;\n\t\t}\n\n\t\tconst old = this._scriptsIndex[scriptName];\n\t\tif (!old || !old.instance) return false;\n\t\tconst scriptInstanceOld = old.instance;\n\n\t\tconst ind = this._scripts.indexOf(scriptInstanceOld);\n\n\t\tconst scriptInstance = new scriptType({\n\t\t\tapp: this.system.app,\n\t\t\tentity: this.entity,\n\t\t\tenabled: scriptInstanceOld.enabled,\n\t\t\tattributes: scriptInstanceOld.__attributes\n\t\t});\n\t\tif (!scriptInstance.swap) return false;\n\n\t\tscriptInstance.__initializeAttributes();\n\n\t\tthis._scripts[ind] = scriptInstance;\n\t\tthis._scriptsIndex[scriptName].instance = scriptInstance;\n\t\tthis[scriptName] = scriptInstance;\n\t\tscriptInstance.__executionOrder = ind;\n\n\t\tif (scriptInstanceOld.update) {\n\t\t\tthis._updateList.remove(scriptInstanceOld);\n\t\t}\n\n\t\tif (scriptInstanceOld.postUpdate) {\n\t\t\tthis._postUpdateList.remove(scriptInstanceOld);\n\t\t}\n\n\t\tif (scriptInstance.update) {\n\t\t\tthis._updateList.insert(scriptInstance);\n\t\t}\n\n\t\tif (scriptInstance.postUpdate) {\n\t\t\tthis._postUpdateList.insert(scriptInstance);\n\t\t}\n\n\t\tthis._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);\n\n\t\tthis.fire('swap', scriptName, scriptInstance);\n\t\tthis.fire('swap:' + scriptName, scriptInstance);\n\t\treturn true;\n\t}\n\n\tresolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {\n\t\tconst newScriptComponent = this.entity.script;\n\n\t\tfor (const scriptName in oldScriptComponent._scriptsIndex) {\n\t\t\tconst scriptType = this.system.app.scripts.get(scriptName);\n\n\t\t\tif (!scriptType) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst script = oldScriptComponent._scriptsIndex[scriptName];\n\n\t\t\tif (!script || !script.instance) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;\n\t\t\tconst newAttributes = newScriptComponent[scriptName].__attributes;\n\n\t\t\tif (!newAttributesRaw && !newAttributes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst useGuid = !!newAttributesRaw;\n\t\t\tconst oldAttributes = script.instance.__attributes;\n\n\t\t\tfor (const attributeName in oldAttributes) {\n\t\t\t\tif (!oldAttributes[attributeName]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst attribute = scriptType.attributes.get(attributeName);\n\n\t\t\t\tif (!attribute) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (attribute.type === 'entity') {\n\t\t\t\t\tthis._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);\n\t\t\t\t} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {\n\t\t\t\t\tconst oldValue = oldAttributes[attributeName];\n\t\t\t\t\tconst newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];\n\n\t\t\t\t\tfor (let i = 0; i < attribute.schema.length; i++) {\n\t\t\t\t\t\tconst field = attribute.schema[i];\n\n\t\t\t\t\t\tif (field.type !== 'entity') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (attribute.array) {\n\t\t\t\t\t\t\tfor (let j = 0; j < oldValue.length; j++) {\n\t\t\t\t\t\t\t\tthis._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmove(nameOrType, ind) {\n\t\tconst len = this._scripts.length;\n\t\tif (ind >= len || ind < 0) return false;\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\n\t\tif (typeof scriptName !== 'string') {\n\t\t\tscriptName = nameOrType.__name;\n\t\t} else {\n\t\t\tscriptType = null;\n\t\t}\n\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tif (!scriptData || !scriptData.instance) return false;\n\t\tconst scriptInstance = scriptData.instance;\n\t\tif (scriptType && !(scriptInstance instanceof scriptType)) return false;\n\n\t\tconst indOld = this._scripts.indexOf(scriptInstance);\n\n\t\tif (indOld === -1 || indOld === ind) return false;\n\n\t\tthis._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);\n\n\t\tthis._resetExecutionOrder(0, len);\n\n\t\tthis._updateList.sort();\n\n\t\tthis._postUpdateList.sort();\n\n\t\tthis.fire('move', scriptName, scriptInstance, ind, indOld);\n\t\tthis.fire('move:' + scriptName, scriptInstance, ind, indOld);\n\t\treturn true;\n\t}\n\n}\n\nScriptComponent.scriptMethods = {\n\tinitialize: 'initialize',\n\tpostInitialize: 'postInitialize',\n\tupdate: 'update',\n\tpostUpdate: 'postUpdate',\n\tswap: 'swap'\n};\n\nconst funcNameRegex = new RegExp('^\\\\s*function(?:\\\\s|\\\\s*\\\\/\\\\*.*\\\\*\\\\/\\\\s*)+([^\\\\(\\\\s\\\\/]*)\\\\s*');\n\nclass ScriptType extends EventHandler {\n\tconstructor(args) {\n\t\tsuper();\n\t\tthis.initialize = void 0;\n\t\tthis.postInitialize = void 0;\n\t\tthis.update = void 0;\n\t\tthis.postUpdate = void 0;\n\t\tthis.swap = void 0;\n\t\tthis.initScriptType(args);\n\t}\n\n\tset enabled(value) {\n\t\tthis._enabled = !!value;\n\t\tif (this.enabled === this._enabledOld) return;\n\t\tthis._enabledOld = this.enabled;\n\t\tthis.fire(this.enabled ? 'enable' : 'disable');\n\t\tthis.fire('state', this.enabled);\n\n\t\tif (!this._initialized && this.enabled) {\n\t\t\tthis._initialized = true;\n\n\t\t\tthis.__initializeAttributes(true);\n\n\t\t\tif (this.initialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.initialize);\n\t\t}\n\n\t\tif (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {\n\t\t\tthis._postInitialized = true;\n\t\t\tif (this.postInitialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.postInitialize);\n\t\t}\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;\n\t}\n\n\tinitScriptType(args) {\n\t\tconst script = this.constructor;\n\t\tthis.app = args.app;\n\t\tthis.entity = args.entity;\n\t\tthis._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;\n\t\tthis._enabledOld = this.enabled;\n\t\tthis.__destroyed = false;\n\t\tthis.__attributes = {};\n\t\tthis.__attributesRaw = args.attributes || {};\n\t\tthis.__scriptType = script;\n\t\tthis.__executionOrder = -1;\n\t}\n\n\tstatic __getScriptName(constructorFn) {\n\t\tif (typeof constructorFn !== 'function') return undefined;\n\t\tif ('name' in Function.prototype) return constructorFn.name;\n\t\tif (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';\n\t\tconst match = (\"\" + constructorFn).match(funcNameRegex);\n\t\treturn match ? match[1] : undefined;\n\t}\n\n\tstatic get scriptName() {\n\t\treturn this.__name;\n\t}\n\n\tstatic get attributes() {\n\t\tif (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);\n\t\treturn this.__attributes;\n\t}\n\n\t__initializeAttributes(force) {\n\t\tif (!force && !this.__attributesRaw) return;\n\n\t\tfor (const key in this.__scriptType.attributes.index) {\n\t\t\tif (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {\n\t\t\t\tthis[key] = this.__attributesRaw[key];\n\t\t\t} else if (!this.__attributes.hasOwnProperty(key)) {\n\t\t\t\tif (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {\n\t\t\t\t\tthis[key] = this.__scriptType.attributes.index[key].default;\n\t\t\t\t} else {\n\t\t\t\t\tthis[key] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.__attributesRaw = null;\n\t}\n\n\tstatic extend(methods) {\n\t\tfor (const key in methods) {\n\t\t\tif (!methods.hasOwnProperty(key)) continue;\n\t\t\tthis.prototype[key] = methods[key];\n\t\t}\n\t}\n\n}\n\nScriptType.__name = null;\n\nclass ScriptRegistry extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.app = app;\n\t\tthis._scripts = {};\n\t\tthis._list = [];\n\t}\n\n\tdestroy() {\n\t\tthis.app = null;\n\t\tthis.off();\n\t}\n\n\tadd(script) {\n\t\tconst scriptName = script.__name;\n\n\t\tif (this._scripts.hasOwnProperty(scriptName)) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (script.prototype.swap) {\n\t\t\t\t\tconst old = this._scripts[scriptName];\n\n\t\t\t\t\tconst ind = this._list.indexOf(old);\n\n\t\t\t\t\tthis._list[ind] = script;\n\t\t\t\t\tthis._scripts[scriptName] = script;\n\t\t\t\t\tthis.fire('swap', scriptName, script);\n\t\t\t\t\tthis.fire('swap:' + scriptName, script);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`script registry already has '${scriptName}' script, define 'swap' method for new script type to enable code hot swapping`);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._scripts[scriptName] = script;\n\n\t\tthis._list.push(script);\n\n\t\tthis.fire('add', scriptName, script);\n\t\tthis.fire('add:' + scriptName, script);\n\t\tsetTimeout(() => {\n\t\t\tif (!this._scripts.hasOwnProperty(scriptName)) return;\n\n\t\t\tif (!this.app || !this.app.systems || !this.app.systems.script) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst components = this.app.systems.script._components;\n\t\t\tlet attributes;\n\t\t\tconst scriptInstances = [];\n\t\t\tconst scriptInstancesInitialized = [];\n\n\t\t\tfor (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {\n\t\t\t\tconst component = components.items[components.loopIndex];\n\n\t\t\t\tif (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {\n\t\t\t\t\tif (component._scriptsData && component._scriptsData[scriptName]) attributes = component._scriptsData[scriptName].attributes;\n\t\t\t\t\tconst scriptInstance = component.create(scriptName, {\n\t\t\t\t\t\tpreloading: true,\n\t\t\t\t\t\tind: component._scriptsIndex[scriptName].ind,\n\t\t\t\t\t\tattributes: attributes\n\t\t\t\t\t});\n\t\t\t\t\tif (scriptInstance) scriptInstances.push(scriptInstance);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < scriptInstances.length; i++) scriptInstances[i].__initializeAttributes();\n\n\t\t\tfor (let i = 0; i < scriptInstances.length; i++) {\n\t\t\t\tif (scriptInstances[i].enabled) {\n\t\t\t\t\tscriptInstances[i]._initialized = true;\n\t\t\t\t\tscriptInstancesInitialized.push(scriptInstances[i]);\n\t\t\t\t\tif (scriptInstances[i].initialize) scriptInstances[i].initialize();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < scriptInstancesInitialized.length; i++) {\n\t\t\t\tif (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tscriptInstancesInitialized[i]._postInitialized = true;\n\t\t\t\tif (scriptInstancesInitialized[i].postInitialize) scriptInstancesInitialized[i].postInitialize();\n\t\t\t}\n\t\t});\n\t\treturn true;\n\t}\n\n\tremove(nameOrType) {\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\n\t\tif (typeof scriptName !== 'string') {\n\t\t\tscriptName = scriptType.__name;\n\t\t} else {\n\t\t\tscriptType = this.get(scriptName);\n\t\t}\n\n\t\tif (this.get(scriptName) !== scriptType) return false;\n\t\tdelete this._scripts[scriptName];\n\n\t\tconst ind = this._list.indexOf(scriptType);\n\n\t\tthis._list.splice(ind, 1);\n\n\t\tthis.fire('remove', scriptName, scriptType);\n\t\tthis.fire('remove:' + scriptName, scriptType);\n\t\treturn true;\n\t}\n\n\tget(name) {\n\t\treturn this._scripts[name] || null;\n\t}\n\n\thas(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\treturn this._scripts.hasOwnProperty(nameOrType);\n\t\t}\n\n\t\tif (!nameOrType) return false;\n\t\tconst scriptName = nameOrType.__name;\n\t\treturn this._scripts[scriptName] === nameOrType;\n\t}\n\n\tlist() {\n\t\treturn this._list;\n\t}\n\n}\n\nclass I18nParser {\n\t_validate(data) {\n\t\tif (!data.header) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"header\" field');\n\t\t}\n\n\t\tif (!data.header.version) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"header.version\" field');\n\t\t}\n\n\t\tif (data.header.version !== 1) {\n\t\t\tthrow new Error('pc.I18n#addData: Invalid \"header.version\" field');\n\t\t}\n\n\t\tif (!data.data) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"data\" field');\n\t\t} else if (!Array.isArray(data.data)) {\n\t\t\tthrow new Error('pc.I18n#addData: \"data\" field must be an array');\n\t\t}\n\n\t\tfor (let i = 0, len = data.data.length; i < len; i++) {\n\t\t\tconst entry = data.data[i];\n\n\t\t\tif (!entry.info) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].info\" field`);\n\t\t\t}\n\n\t\t\tif (!entry.info.locale) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].info.locale\" field`);\n\t\t\t}\n\n\t\t\tif (typeof entry.info.locale !== 'string') {\n\t\t\t\tthrow new Error(`pc.I18n#addData: \"data[${i}].info.locale\" must be a string`);\n\t\t\t}\n\n\t\t\tif (!entry.messages) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].messages\" field`);\n\t\t\t}\n\t\t}\n\t}\n\n\tparse(data) {\n\t\treturn data.data;\n\t}\n\n}\n\nclass I18n extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.locale = DEFAULT_LOCALE;\n\t\tthis._translations = {};\n\t\tthis._availableLangs = {};\n\t\tthis._app = app;\n\t\tthis._assets = [];\n\t\tthis._parser = new I18nParser();\n\t}\n\n\tset assets(value) {\n\t\tconst index = {};\n\n\t\tfor (let _i = 0, len = value.length; _i < len; _i++) {\n\t\t\tconst id = value[_i] instanceof Asset ? value[_i].id : value[_i];\n\t\t\tindex[id] = true;\n\t\t}\n\n\t\tlet i = this._assets.length;\n\n\t\twhile (i--) {\n\t\t\tconst id = this._assets[i];\n\n\t\t\tif (!index[id]) {\n\t\t\t\tthis._app.assets.off('add:' + id, this._onAssetAdd, this);\n\n\t\t\t\tconst asset = this._app.assets.get(id);\n\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis._onAssetRemove(asset);\n\t\t\t\t}\n\n\t\t\t\tthis._assets.splice(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tfor (const id in index) {\n\t\t\tconst idNum = parseInt(id, 10);\n\t\t\tif (this._assets.indexOf(idNum) !== -1) continue;\n\n\t\t\tthis._assets.push(idNum);\n\n\t\t\tconst asset = this._app.assets.get(idNum);\n\n\t\t\tif (!asset) {\n\t\t\t\tthis._app.assets.once('add:' + idNum, this._onAssetAdd, this);\n\t\t\t} else {\n\t\t\t\tthis._onAssetAdd(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\tget assets() {\n\t\treturn this._assets;\n\t}\n\n\tset locale(value) {\n\t\tif (this._locale === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet lang = getLang(value);\n\n\t\tif (lang === 'in') {\n\t\t\tlang = 'id';\n\t\t\tvalue = replaceLang(value, lang);\n\n\t\t\tif (this._locale === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst old = this._locale;\n\t\tthis._locale = value;\n\t\tthis._lang = lang;\n\t\tthis._pluralFn = getPluralFn(this._lang);\n\t\tthis.fire('set:locale', value, old);\n\t}\n\n\tget locale() {\n\t\treturn this._locale;\n\t}\n\n\tstatic findAvailableLocale(desiredLocale, availableLocales) {\n\t\treturn findAvailableLocale(desiredLocale, availableLocales);\n\t}\n\n\tfindAvailableLocale(desiredLocale) {\n\t\tif (this._translations[desiredLocale]) {\n\t\t\treturn desiredLocale;\n\t\t}\n\n\t\tconst lang = getLang(desiredLocale);\n\t\treturn this._findFallbackLocale(desiredLocale, lang);\n\t}\n\n\tgetText(key, locale) {\n\t\tlet result = key;\n\t\tlet lang;\n\n\t\tif (!locale) {\n\t\t\tlocale = this._locale;\n\t\t\tlang = this._lang;\n\t\t}\n\n\t\tlet translations = this._translations[locale];\n\n\t\tif (!translations) {\n\t\t\tif (!lang) {\n\t\t\t\tlang = getLang(locale);\n\t\t\t}\n\n\t\t\tlocale = this._findFallbackLocale(locale, lang);\n\t\t\ttranslations = this._translations[locale];\n\t\t}\n\n\t\tif (translations && translations.hasOwnProperty(key)) {\n\t\t\tresult = translations[key];\n\n\t\t\tif (Array.isArray(result)) {\n\t\t\t\tresult = result[0];\n\t\t\t}\n\n\t\t\tif (result === null || result === undefined) {\n\t\t\t\tresult = key;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tgetPluralText(key, n, locale) {\n\t\tlet result = key;\n\t\tlet lang;\n\t\tlet pluralFn;\n\n\t\tif (!locale) {\n\t\t\tlocale = this._locale;\n\t\t\tlang = this._lang;\n\t\t\tpluralFn = this._pluralFn;\n\t\t} else {\n\t\t\tlang = getLang(locale);\n\t\t\tpluralFn = getPluralFn(lang);\n\t\t}\n\n\t\tlet translations = this._translations[locale];\n\n\t\tif (!translations) {\n\t\t\tlocale = this._findFallbackLocale(locale, lang);\n\t\t\tlang = getLang(locale);\n\t\t\tpluralFn = getPluralFn(lang);\n\t\t\ttranslations = this._translations[locale];\n\t\t}\n\n\t\tif (translations && translations[key] && pluralFn) {\n\t\t\tconst index = pluralFn(n);\n\t\t\tresult = translations[key][index];\n\n\t\t\tif (result === null || result === undefined) {\n\t\t\t\tresult = key;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\taddData(data) {\n\t\tlet parsed;\n\n\t\ttry {\n\t\t\tparsed = this._parser.parse(data);\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0, len = parsed.length; i < len; i++) {\n\t\t\tconst entry = parsed[i];\n\t\t\tconst locale = entry.info.locale;\n\t\t\tconst messages = entry.messages;\n\n\t\t\tif (!this._translations[locale]) {\n\t\t\t\tthis._translations[locale] = {};\n\t\t\t\tconst lang = getLang(locale);\n\n\t\t\t\tif (!this._availableLangs[lang]) {\n\t\t\t\t\tthis._availableLangs[lang] = locale;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject.assign(this._translations[locale], messages);\n\t\t\tthis.fire('data:add', locale, messages);\n\t\t}\n\t}\n\n\tremoveData(data) {\n\t\tlet parsed;\n\n\t\ttry {\n\t\t\tparsed = this._parser.parse(data);\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0, len = parsed.length; i < len; i++) {\n\t\t\tconst entry = parsed[i];\n\t\t\tconst locale = entry.info.locale;\n\t\t\tconst translations = this._translations[locale];\n\t\t\tif (!translations) continue;\n\t\t\tconst messages = entry.messages;\n\n\t\t\tfor (const key in messages) {\n\t\t\t\tdelete translations[key];\n\t\t\t}\n\n\t\t\tif (Object.keys(translations).length === 0) {\n\t\t\t\tdelete this._translations[locale];\n\t\t\t\tdelete this._availableLangs[getLang(locale)];\n\t\t\t}\n\n\t\t\tthis.fire('data:remove', locale, messages);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._translations = null;\n\t\tthis._availableLangs = null;\n\t\tthis._assets = null;\n\t\tthis._parser = null;\n\t\tthis.off();\n\t}\n\n\t_findFallbackLocale(locale, lang) {\n\t\tlet result = DEFAULT_LOCALE_FALLBACKS[locale];\n\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = DEFAULT_LOCALE_FALLBACKS[lang];\n\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this._availableLangs[lang];\n\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn DEFAULT_LOCALE;\n\t}\n\n\t_onAssetAdd(asset) {\n\t\tasset.on('load', this._onAssetLoad, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t\tasset.on('remove', this._onAssetRemove, this);\n\t\tasset.on('unload', this._onAssetUnload, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onAssetLoad(asset);\n\t\t}\n\t}\n\n\t_onAssetLoad(asset) {\n\t\tthis.addData(asset.resource);\n\t}\n\n\t_onAssetChange(asset) {\n\t\tif (asset.resource) {\n\t\t\tthis.addData(asset.resource);\n\t\t}\n\t}\n\n\t_onAssetRemove(asset) {\n\t\tasset.off('load', this._onAssetLoad, this);\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.off('remove', this._onAssetRemove, this);\n\t\tasset.off('unload', this._onAssetUnload, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis.removeData(asset.resource);\n\t\t}\n\n\t\tthis._app.assets.once('add:' + asset.id, this._onAssetAdd, this);\n\t}\n\n\t_onAssetUnload(asset) {\n\t\tif (asset.resource) {\n\t\t\tthis.removeData(asset.resource);\n\t\t}\n\t}\n\n}\n\nconst FILLMODE_NONE = 'NONE';\nconst FILLMODE_FILL_WINDOW = 'FILL_WINDOW';\nconst FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';\nconst RESOLUTION_AUTO = 'AUTO';\nconst RESOLUTION_FIXED = 'FIXED';\n\nclass VrDisplay extends EventHandler {\n\tconstructor(app, display) {\n\t\tsuper();\n\t\tthis._app = app;\n\t\tthis._device = app.graphicsDevice;\n\t\tthis.id = display.displayId;\n\t\tthis._frameData = null;\n\n\t\tif (window.VRFrameData) {\n\t\t\tthis._frameData = new window.VRFrameData();\n\t\t}\n\n\t\tthis.display = display;\n\t\tthis._camera = null;\n\t\tthis.sitToStandInv = new Mat4();\n\t\tthis.leftView = new Mat4();\n\t\tthis.leftProj = new Mat4();\n\t\tthis.leftViewInv = new Mat4();\n\t\tthis.leftPos = new Vec3();\n\t\tthis.rightView = new Mat4();\n\t\tthis.rightProj = new Mat4();\n\t\tthis.rightViewInv = new Mat4();\n\t\tthis.rightPos = new Vec3();\n\t\tthis.combinedPos = new Vec3();\n\t\tthis.combinedView = new Mat4();\n\t\tthis.combinedProj = new Mat4();\n\t\tthis.combinedViewInv = new Mat4();\n\t\tthis.combinedFov = 0;\n\t\tthis.combinedAspect = 0;\n\t\tthis.presenting = false;\n\n\t\tthis._presentChange = event => {\n\t\t\tlet display;\n\n\t\t\tif (event.display) {\n\t\t\t\tdisplay = event.display;\n\t\t\t} else if (event.detail && event.detail.display) {\n\t\t\t\tdisplay = event.detail.display;\n\t\t\t} else if (event.detail && event.detail.vrdisplay) {\n\t\t\t\tdisplay = event.detail.vrdisplay;\n\t\t\t} else {\n\t\t\t\tdisplay = this.display;\n\t\t\t}\n\n\t\t\tif (display === this.display) {\n\t\t\t\tthis.presenting = this.display && this.display.isPresenting;\n\n\t\t\t\tif (this.presenting) {\n\t\t\t\t\tconst leftEye = this.display.getEyeParameters(\"left\");\n\t\t\t\t\tconst rightEye = this.display.getEyeParameters(\"right\");\n\t\t\t\t\tconst w = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;\n\t\t\t\t\tconst h = Math.max(leftEye.renderHeight, rightEye.renderHeight);\n\n\t\t\t\t\tthis._app.graphicsDevice.setResolution(w, h);\n\n\t\t\t\t\tthis._app._allowResize = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis._app.setCanvasResolution(RESOLUTION_AUTO);\n\n\t\t\t\t\tthis._app._allowResize = true;\n\t\t\t\t}\n\n\t\t\t\tthis.fire('beforepresentchange', this);\n\t\t\t\tthis.fire('presentchange', this);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener('vrdisplaypresentchange', this._presentChange, false);\n\t}\n\n\tdestroy() {\n\t\twindow.removeEventListener('vrdisplaypresentchange', this._presentChange);\n\t\tif (this._camera) this._camera.vrDisplay = null;\n\t\tthis._camera = null;\n\t}\n\n\tpoll() {\n\t\tif (this.display) {\n\t\t\tthis.display.getFrameData(this._frameData);\n\t\t\tthis.leftProj.data = this._frameData.leftProjectionMatrix;\n\t\t\tthis.rightProj.data = this._frameData.rightProjectionMatrix;\n\t\t\tconst stage = this.display.stageParameters;\n\n\t\t\tif (stage) {\n\t\t\t\tthis.sitToStandInv.set(stage.sittingToStandingTransform).invert();\n\t\t\t\tthis.combinedView.set(this._frameData.leftViewMatrix);\n\t\t\t\tthis.leftView.mul2(this.combinedView, this.sitToStandInv);\n\t\t\t\tthis.combinedView.set(this._frameData.rightViewMatrix);\n\t\t\t\tthis.rightView.mul2(this.combinedView, this.sitToStandInv);\n\t\t\t} else {\n\t\t\t\tthis.leftView.set(this._frameData.leftViewMatrix);\n\t\t\t\tthis.rightView.set(this._frameData.rightViewMatrix);\n\t\t\t}\n\n\t\t\tlet nx = this.leftProj.data[3] + this.leftProj.data[0];\n\t\t\tlet nz = this.leftProj.data[11] + this.leftProj.data[8];\n\t\t\tlet l = 1.0 / Math.sqrt(nx * nx + nz * nz);\n\t\t\tnx *= l;\n\t\t\tnz *= l;\n\t\t\tlet maxFov = -Math.atan2(nz, nx);\n\t\t\tnx = this.rightProj.data[3] + this.rightProj.data[0];\n\t\t\tnz = this.rightProj.data[11] + this.rightProj.data[8];\n\t\t\tl = 1.0 / Math.sqrt(nx * nx + nz * nz);\n\t\t\tnx *= l;\n\t\t\tnz *= l;\n\t\t\tmaxFov = Math.max(maxFov, -Math.atan2(nz, nx));\n\t\t\tmaxFov *= 2.0;\n\t\t\tthis.combinedFov = maxFov;\n\t\t\tconst aspect = this.rightProj.data[5] / this.rightProj.data[0];\n\t\t\tthis.combinedAspect = aspect;\n\t\t\tconst view = this.combinedView;\n\t\t\tview.copy(this.leftView);\n\t\t\tview.invert();\n\t\t\tthis.leftViewInv.copy(view);\n\t\t\tconst pos = this.combinedPos;\n\t\t\tpos.x = this.leftPos.x = view.data[12];\n\t\t\tpos.y = this.leftPos.y = view.data[13];\n\t\t\tpos.z = this.leftPos.z = view.data[14];\n\t\t\tview.copy(this.rightView);\n\t\t\tview.invert();\n\t\t\tthis.rightViewInv.copy(view);\n\t\t\tconst deltaX = pos.x - view.data[12];\n\t\t\tconst deltaY = pos.y - view.data[13];\n\t\t\tconst deltaZ = pos.z - view.data[14];\n\t\t\tconst dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);\n\t\t\tthis.rightPos.x = view.data[12];\n\t\t\tthis.rightPos.y = view.data[13];\n\t\t\tthis.rightPos.z = view.data[14];\n\t\t\tpos.x += view.data[12];\n\t\t\tpos.y += view.data[13];\n\t\t\tpos.z += view.data[14];\n\t\t\tpos.x *= 0.5;\n\t\t\tpos.y *= 0.5;\n\t\t\tpos.z *= 0.5;\n\t\t\tconst b = Math.PI * 0.5;\n\t\t\tconst c = maxFov * 0.5;\n\t\t\tconst a = Math.PI - (b + c);\n\t\t\tconst offset = dist * 0.5 * Math.sin(a);\n\t\t\tconst fwdX = view.data[8];\n\t\t\tconst fwdY = view.data[9];\n\t\t\tconst fwdZ = view.data[10];\n\t\t\tview.data[12] = pos.x + fwdX * offset;\n\t\t\tview.data[13] = pos.y + fwdY * offset;\n\t\t\tview.data[14] = pos.z + fwdZ * offset;\n\t\t\tthis.combinedViewInv.copy(view);\n\t\t\tview.invert();\n\t\t\tthis.combinedProj.setPerspective(maxFov * math.RAD_TO_DEG, aspect, this.display.depthNear + offset, this.display.depthFar + offset, true);\n\t\t}\n\t}\n\n\trequestPresent(callback) {\n\t\tif (!this.display) {\n\t\t\tif (callback) callback(new Error(\"No VrDisplay to requestPresent\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.presenting) {\n\t\t\tif (callback) callback(new Error(\"VrDisplay already presenting\"));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.display.requestPresent([{\n\t\t\tsource: this._device.canvas\n\t\t}]).then(function () {\n\t\t\tif (callback) callback();\n\t\t}, function (err) {\n\t\t\tif (callback) callback(err);\n\t\t});\n\t}\n\n\texitPresent(callback) {\n\t\tif (!this.display) {\n\t\t\tif (callback) callback(new Error(\"No VrDisplay to exitPresent\"));\n\t\t}\n\n\t\tif (!this.presenting) {\n\t\t\tif (callback) callback(new Error(\"VrDisplay not presenting\"));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.display.exitPresent().then(function () {\n\t\t\tif (callback) callback();\n\t\t}, function () {\n\t\t\tif (callback) callback(new Error(\"exitPresent failed\"));\n\t\t});\n\t}\n\n\trequestAnimationFrame(fn) {\n\t\tif (this.display) this.display.requestAnimationFrame(fn);\n\t}\n\n\tsubmitFrame() {\n\t\tif (this.display) this.display.submitFrame();\n\t}\n\n\treset() {\n\t\tif (this.display) this.display.resetPose();\n\t}\n\n\tsetClipPlanes(n, f) {\n\t\tif (this.display) {\n\t\t\tthis.display.depthNear = n;\n\t\t\tthis.display.depthFar = f;\n\t\t}\n\t}\n\n\tgetFrameData() {\n\t\tif (this.display) return this._frameData;\n\t}\n\n\tget capabilities() {\n\t\tif (this.display) return this.display.capabilities;\n\t\treturn {};\n\t}\n\n}\n\nclass VrManager extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.isSupported = VrManager.isSupported;\n\t\tthis._index = {};\n\t\tthis.displays = [];\n\t\tthis.display = null;\n\t\tthis._app = app;\n\t\tthis._onDisplayConnect = this._onDisplayConnect.bind(this);\n\t\tthis._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);\n\n\t\tthis._attach();\n\n\t\tthis._getDisplays((err, displays) => {\n\t\t\tif (err) {\n\t\t\t\tthis.fire('error', err);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < displays.length; i++) {\n\t\t\t\t\tthis._addDisplay(displays[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.fire('ready', this.displays);\n\t\t\t}\n\t\t});\n\t}\n\n\t_attach() {\n\t\twindow.addEventListener('vrdisplayconnect', this._onDisplayConnect);\n\t\twindow.addEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);\n\t}\n\n\t_detach() {\n\t\twindow.removeEventListener('vrdisplayconnect', this._onDisplayConnect);\n\t\twindow.removeEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);\n\t}\n\n\tdestroy() {\n\t\tthis._detach();\n\t}\n\n\tpoll() {\n\t\tconst l = this.displays.length;\n\t\tif (!l) return;\n\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tif (this.displays[i]._camera) this.displays[i].poll();\n\t\t}\n\t}\n\n\t_getDisplays(callback) {\n\t\tif (navigator.getVRDisplays) {\n\t\t\tnavigator.getVRDisplays().then(function (displays) {\n\t\t\t\tif (callback) callback(null, displays);\n\t\t\t});\n\t\t} else {\n\t\t\tif (callback) callback(new Error('WebVR not supported'));\n\t\t}\n\t}\n\n\t_addDisplay(vrDisplay) {\n\t\tif (this._index[vrDisplay.displayId]) return;\n\t\tconst display = new VrDisplay(this._app, vrDisplay);\n\t\tthis._index[display.id] = display;\n\t\tthis.displays.push(display);\n\t\tif (!this.display) this.display = display;\n\t\tthis.fire('displayconnect', display);\n\t}\n\n\t_onDisplayConnect(e) {\n\t\tif (e.detail && e.detail.display) {\n\t\t\tthis._addDisplay(e.detail.display);\n\t\t} else {\n\t\t\tthis._addDisplay(e.display);\n\t\t}\n\t}\n\n\t_onDisplayDisconnect(e) {\n\t\tlet id;\n\n\t\tif (e.detail && e.detail.display) {\n\t\t\tid = e.detail.display.displayId;\n\t\t} else {\n\t\t\tid = e.display.displayId;\n\t\t}\n\n\t\tconst display = this._index[id];\n\t\tif (!display) return;\n\t\tdisplay.destroy();\n\t\tdelete this._index[display.id];\n\t\tconst ind = this.displays.indexOf(display);\n\t\tthis.displays.splice(ind, 1);\n\n\t\tif (this.display === display) {\n\t\t\tif (this.displays.length) {\n\t\t\t\tthis.display = this.displays[0];\n\t\t\t} else {\n\t\t\t\tthis.display = null;\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('displaydisconnect', display);\n\t}\n\n}\n\nVrManager.isSupported = typeof navigator !== 'undefined' ? !!navigator.getVRDisplays : false;\n\nconst XRTYPE_INLINE = 'inline';\nconst XRTYPE_VR = 'immersive-vr';\nconst XRTYPE_AR = 'immersive-ar';\nconst XRSPACE_VIEWER = 'viewer';\nconst XRSPACE_LOCAL = 'local';\nconst XRSPACE_LOCALFLOOR = 'local-floor';\nconst XRSPACE_BOUNDEDFLOOR = 'bounded-floor';\nconst XRSPACE_UNBOUNDED = 'unbounded';\nconst XRTARGETRAY_GAZE = 'gaze';\nconst XRTARGETRAY_SCREEN = 'screen';\nconst XRTARGETRAY_POINTER = 'tracked-pointer';\nconst XRHAND_NONE = 'none';\nconst XRHAND_LEFT = 'left';\nconst XRHAND_RIGHT = 'right';\nconst XRTRACKABLE_POINT = 'point';\nconst XRTRACKABLE_PLANE = 'plane';\nconst XRTRACKABLE_MESH = 'mesh';\nconst XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';\nconst XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';\nconst XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';\nconst XRDEPTHSENSINGFORMAT_F32 = 'float32';\n\nconst poolVec3 = [];\nconst poolQuat = [];\n\nclass XrHitTestSource extends EventHandler {\n\tconstructor(manager, xrHitTestSource, transient) {\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis._xrHitTestSource = xrHitTestSource;\n\t\tthis._transient = transient;\n\t}\n\n\tremove() {\n\t\tif (!this._xrHitTestSource) return;\n\t\tconst sources = this.manager.hitTest.sources;\n\t\tconst ind = sources.indexOf(this);\n\t\tif (ind !== -1) sources.splice(ind, 1);\n\t\tthis.onStop();\n\t}\n\n\tonStop() {\n\t\tthis._xrHitTestSource.cancel();\n\n\t\tthis._xrHitTestSource = null;\n\t\tthis.fire('remove');\n\t\tthis.manager.hitTest.fire('remove', this);\n\t}\n\n\tupdate(frame) {\n\t\tif (this._transient) {\n\t\t\tconst transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);\n\n\t\t\tfor (let i = 0; i < transientResults.length; i++) {\n\t\t\t\tconst transientResult = transientResults[i];\n\t\t\t\tlet inputSource;\n\t\t\t\tif (transientResult.inputSource) inputSource = this.manager.input._getByInputSource(transientResult.inputSource);\n\t\t\t\tthis.updateHitResults(transientResult.results, inputSource);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));\n\t\t}\n\t}\n\n\tupdateHitResults(results, inputSource) {\n\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\tconst pose = results[i].getPose(this.manager._referenceSpace);\n\t\t\tlet position = poolVec3.pop();\n\t\t\tif (!position) position = new Vec3();\n\t\t\tposition.copy(pose.transform.position);\n\t\t\tlet rotation = poolQuat.pop();\n\t\t\tif (!rotation) rotation = new Quat();\n\t\t\trotation.copy(pose.transform.orientation);\n\t\t\tthis.fire('result', position, rotation, inputSource);\n\t\t\tthis.manager.hitTest.fire('result', this, position, rotation, inputSource);\n\t\t\tpoolVec3.push(position);\n\t\t\tpoolQuat.push(rotation);\n\t\t}\n\t}\n\n}\n\nclass XrHitTest extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);\n\t\tthis._session = null;\n\t\tthis.sources = [];\n\n\t\tif (this._supported) {\n\t\t\tthis.manager.on('start', this._onSessionStart, this);\n\t\t\tthis.manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\n\t_onSessionStart() {\n\t\tif (this.manager.type !== XRTYPE_AR) return;\n\t\tthis._session = this.manager.session;\n\t}\n\n\t_onSessionEnd() {\n\t\tif (!this._session) return;\n\t\tthis._session = null;\n\n\t\tfor (let i = 0; i < this.sources.length; i++) {\n\t\t\tthis.sources[i].onStop();\n\t\t}\n\n\t\tthis.sources = [];\n\t}\n\n\tisAvailable(callback, fireError) {\n\t\tlet err;\n\t\tif (!this._supported) err = new Error('XR HitTest is not supported');\n\t\tif (!this._session) err = new Error('XR Session is not started (1)');\n\t\tif (this.manager.type !== XRTYPE_AR) err = new Error('XR HitTest is available only for AR');\n\n\t\tif (err) {\n\t\t\tif (callback) callback(err);\n\t\t\tif (fireError) fireError.fire('error', err);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstart(options) {\n\t\toptions = options || {};\n\t\tif (!this.isAvailable(options.callback, this)) return;\n\t\tif (!options.profile && !options.spaceType) options.spaceType = XRSPACE_VIEWER;\n\t\tlet xrRay;\n\t\tconst offsetRay = options.offsetRay;\n\t\tif (offsetRay) xrRay = new XRRay(new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z), new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z));\n\t\tconst callback = options.callback;\n\n\t\tif (options.spaceType) {\n\t\t\tthis._session.requestReferenceSpace(options.spaceType).then(referenceSpace => {\n\t\t\t\tif (!this._session) {\n\t\t\t\t\tconst err = new Error('XR Session is not started (2)');\n\t\t\t\t\tif (callback) callback(err);\n\t\t\t\t\tthis.fire('error', err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._session.requestHitTestSource({\n\t\t\t\t\tspace: referenceSpace,\n\t\t\t\t\tentityTypes: options.entityTypes || undefined,\n\t\t\t\t\toffsetRay: xrRay\n\t\t\t\t}).then(xrHitTestSource => {\n\t\t\t\t\tthis._onHitTestSource(xrHitTestSource, false, callback);\n\t\t\t\t}).catch(ex => {\n\t\t\t\t\tif (callback) callback(ex);\n\t\t\t\t\tthis.fire('error', ex);\n\t\t\t\t});\n\t\t\t}).catch(ex => {\n\t\t\t\tif (callback) callback(ex);\n\t\t\t\tthis.fire('error', ex);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._session.requestHitTestSourceForTransientInput({\n\t\t\t\tprofile: options.profile,\n\t\t\t\tentityTypes: options.entityTypes || undefined,\n\t\t\t\toffsetRay: xrRay\n\t\t\t}).then(xrHitTestSource => {\n\t\t\t\tthis._onHitTestSource(xrHitTestSource, true, callback);\n\t\t\t}).catch(ex => {\n\t\t\t\tif (callback) callback(ex);\n\t\t\t\tthis.fire('error', ex);\n\t\t\t});\n\t\t}\n\t}\n\n\t_onHitTestSource(xrHitTestSource, transient, callback) {\n\t\tif (!this._session) {\n\t\t\txrHitTestSource.cancel();\n\t\t\tconst err = new Error('XR Session is not started (3)');\n\t\t\tif (callback) callback(err);\n\t\t\tthis.fire('error', err);\n\t\t\treturn;\n\t\t}\n\n\t\tconst hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);\n\t\tthis.sources.push(hitTestSource);\n\t\tif (callback) callback(null, hitTestSource);\n\t\tthis.fire('add', hitTestSource);\n\t}\n\n\tupdate(frame) {\n\t\tfor (let i = 0; i < this.sources.length; i++) {\n\t\t\tthis.sources[i].update(frame);\n\t\t}\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n}\n\nclass XrFinger {\n\tconstructor(index, hand) {\n\t\tthis._index = index;\n\t\tthis._hand = hand;\n\n\t\tthis._hand._fingers.push(this);\n\n\t\tthis._joints = [];\n\t\tthis._tip = null;\n\t}\n\n\tget index() {\n\t\treturn this._index;\n\t}\n\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\n\tget joints() {\n\t\treturn this._joints;\n\t}\n\n\tget tip() {\n\t\treturn this._tip;\n\t}\n\n}\n\nconst tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];\nconst tipJointIdsIndex = {};\n\nfor (let i = 0; i < tipJointIds.length; i++) {\n\ttipJointIdsIndex[tipJointIds[i]] = true;\n}\n\nclass XrJoint {\n\tconstructor(index, id, hand, finger = null) {\n\t\tthis._index = index;\n\t\tthis._id = id;\n\t\tthis._hand = hand;\n\t\tthis._finger = finger;\n\t\tthis._wrist = id === 'wrist';\n\t\tthis._tip = this._finger && !!tipJointIdsIndex[id];\n\t\tthis._radius = null;\n\t\tthis._localTransform = new Mat4();\n\t\tthis._worldTransform = new Mat4();\n\t\tthis._localPosition = new Vec3();\n\t\tthis._localRotation = new Quat();\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._dirtyLocal = true;\n\t}\n\n\tupdate(pose) {\n\t\tthis._dirtyLocal = true;\n\t\tthis._radius = pose.radius;\n\n\t\tthis._localPosition.copy(pose.transform.position);\n\n\t\tthis._localRotation.copy(pose.transform.orientation);\n\t}\n\n\t_updateTransforms() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = false;\n\n\t\t\tthis._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);\n\t\t}\n\n\t\tconst manager = this._hand._manager;\n\t\tconst parent = manager.camera.parent;\n\n\t\tif (parent) {\n\t\t\tthis._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);\n\t\t} else {\n\t\t\tthis._worldTransform.copy(this._localTransform);\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\tthis._updateTransforms();\n\n\t\tthis._worldTransform.getTranslation(this._position);\n\n\t\treturn this._position;\n\t}\n\n\tgetRotation() {\n\t\tthis._updateTransforms();\n\n\t\tthis._rotation.setFromMat4(this._worldTransform);\n\n\t\treturn this._rotation;\n\t}\n\n\tget index() {\n\t\treturn this._index;\n\t}\n\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\n\tget finger() {\n\t\treturn this._finger;\n\t}\n\n\tget wrist() {\n\t\treturn this._wrist;\n\t}\n\n\tget tip() {\n\t\treturn this._tip;\n\t}\n\n\tget radius() {\n\t\treturn this._radius || 0.005;\n\t}\n\n}\n\nlet fingerJointIds = [];\nconst vecA$2 = new Vec3();\nconst vecB$2 = new Vec3();\nconst vecC = new Vec3();\n\nif (platform.browser && window.XRHand) {\n\tfingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];\n}\n\nclass XrHand extends EventHandler {\n\tconstructor(inputSource) {\n\t\tsuper();\n\t\tconst xrHand = inputSource._xrInputSource.hand;\n\t\tthis._manager = inputSource._manager;\n\t\tthis._inputSource = inputSource;\n\t\tthis._tracking = false;\n\t\tthis._fingers = [];\n\t\tthis._joints = [];\n\t\tthis._jointsById = {};\n\t\tthis._tips = [];\n\t\tthis._wrist = null;\n\n\t\tif (xrHand.get('wrist')) {\n\t\t\tconst joint = new XrJoint(0, 'wrist', this, null);\n\t\t\tthis._wrist = joint;\n\n\t\t\tthis._joints.push(joint);\n\n\t\t\tthis._jointsById.wrist = joint;\n\t\t}\n\n\t\tfor (let f = 0; f < fingerJointIds.length; f++) {\n\t\t\tconst finger = new XrFinger(f, this);\n\n\t\t\tfor (let j = 0; j < fingerJointIds[f].length; j++) {\n\t\t\t\tconst jointId = fingerJointIds[f][j];\n\t\t\t\tif (!xrHand.get(jointId)) continue;\n\t\t\t\tconst joint = new XrJoint(j, jointId, this, finger);\n\n\t\t\t\tthis._joints.push(joint);\n\n\t\t\t\tthis._jointsById[jointId] = joint;\n\n\t\t\t\tif (joint.tip) {\n\t\t\t\t\tthis._tips.push(joint);\n\n\t\t\t\t\tfinger._tip = joint;\n\t\t\t\t}\n\n\t\t\t\tfinger._joints.push(joint);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate(frame) {\n\t\tconst xrInputSource = this._inputSource._xrInputSource;\n\n\t\tfor (let j = 0; j < this._joints.length; j++) {\n\t\t\tconst joint = this._joints[j];\n\t\t\tconst jointSpace = xrInputSource.hand.get(joint._id);\n\n\t\t\tif (jointSpace) {\n\t\t\t\tlet pose;\n\t\t\t\tif (frame.session.visibilityState !== 'hidden') pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);\n\n\t\t\t\tif (pose) {\n\t\t\t\t\tjoint.update(pose);\n\n\t\t\t\t\tif (joint.wrist && !this._tracking) {\n\t\t\t\t\t\tthis._tracking = true;\n\t\t\t\t\t\tthis.fire('tracking');\n\t\t\t\t\t}\n\t\t\t\t} else if (joint.wrist) {\n\t\t\t\t\tif (this._tracking) {\n\t\t\t\t\t\tthis._tracking = false;\n\t\t\t\t\t\tthis.fire('trackinglost');\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst j1 = this._jointsById['thumb-metacarpal'];\n\t\tconst j4 = this._jointsById['thumb-tip'];\n\t\tconst j6 = this._jointsById['index-finger-phalanx-proximal'];\n\t\tconst j9 = this._jointsById['index-finger-tip'];\n\t\tconst j16 = this._jointsById['ring-finger-phalanx-proximal'];\n\t\tconst j21 = this._jointsById['pinky-finger-phalanx-proximal'];\n\n\t\tif (j1 && j4 && j6 && j9 && j16 && j21) {\n\t\t\tthis._inputSource._dirtyRay = true;\n\n\t\t\tthis._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);\n\n\t\t\tlet jointL = j1;\n\t\t\tlet jointR = j21;\n\n\t\t\tif (this._inputSource.handedness === XRHAND_LEFT) {\n\t\t\t\tconst t = jointL;\n\t\t\t\tjointL = jointR;\n\t\t\t\tjointR = t;\n\t\t\t}\n\n\t\t\tvecA$2.sub2(jointL._localPosition, this._wrist._localPosition);\n\t\t\tvecB$2.sub2(jointR._localPosition, this._wrist._localPosition);\n\t\t\tvecC.cross(vecA$2, vecB$2).normalize();\n\t\t\tvecA$2.lerp(j6._localPosition, j16._localPosition, 0.5);\n\t\t\tvecA$2.sub(this._wrist._localPosition).normalize();\n\n\t\t\tthis._inputSource._rayLocal.direction.lerp(vecC, vecA$2, 0.5).normalize();\n\t\t}\n\n\t\tconst squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);\n\n\t\tif (squeezing) {\n\t\t\tif (!this._inputSource._squeezing) {\n\t\t\t\tthis._inputSource._squeezing = true;\n\n\t\t\t\tthis._inputSource.fire('squeezestart');\n\n\t\t\t\tthis._manager.input.fire('squeezestart', this._inputSource);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._inputSource._squeezing) {\n\t\t\t\tthis._inputSource._squeezing = false;\n\n\t\t\t\tthis._inputSource.fire('squeeze');\n\n\t\t\t\tthis._manager.input.fire('squeeze', this._inputSource);\n\n\t\t\t\tthis._inputSource.fire('squeezeend');\n\n\t\t\t\tthis._manager.input.fire('squeezeend', this._inputSource);\n\t\t\t}\n\t\t}\n\t}\n\n\t_fingerIsClosed(index) {\n\t\tconst finger = this._fingers[index];\n\t\tvecA$2.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();\n\t\tvecB$2.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();\n\t\treturn vecA$2.dot(vecB$2) < -0.8;\n\t}\n\n\tgetJointById(id) {\n\t\treturn this._jointsById[id] || null;\n\t}\n\n\tget fingers() {\n\t\treturn this._fingers;\n\t}\n\n\tget joints() {\n\t\treturn this._joints;\n\t}\n\n\tget tips() {\n\t\treturn this._tips;\n\t}\n\n\tget wrist() {\n\t\treturn this._wrist;\n\t}\n\n\tget tracking() {\n\t\treturn this._tracking;\n\t}\n\n}\n\nconst quat$1 = new Quat();\nlet ids$1 = 0;\n\nclass XrInputSource extends EventHandler {\n\tconstructor(manager, xrInputSource) {\n\t\tsuper();\n\t\tthis._id = ++ids$1;\n\t\tthis._manager = manager;\n\t\tthis._xrInputSource = xrInputSource;\n\t\tthis._ray = new Ray();\n\t\tthis._rayLocal = new Ray();\n\t\tthis._grip = false;\n\t\tthis._hand = null;\n\t\tif (xrInputSource.hand) this._hand = new XrHand(this);\n\t\tthis._localTransform = null;\n\t\tthis._worldTransform = null;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._localPosition = null;\n\t\tthis._localRotation = null;\n\t\tthis._dirtyLocal = true;\n\t\tthis._selecting = false;\n\t\tthis._squeezing = false;\n\t\tthis._elementInput = true;\n\t\tthis._elementEntity = null;\n\t\tthis._hitTestSources = [];\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tget inputSource() {\n\t\treturn this._xrInputSource;\n\t}\n\n\tget targetRayMode() {\n\t\treturn this._xrInputSource.targetRayMode;\n\t}\n\n\tget handedness() {\n\t\treturn this._xrInputSource.handedness;\n\t}\n\n\tget profiles() {\n\t\treturn this._xrInputSource.profiles;\n\t}\n\n\tget grip() {\n\t\treturn this._grip;\n\t}\n\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\n\tget gamepad() {\n\t\treturn this._xrInputSource.gamepad || null;\n\t}\n\n\tget selecting() {\n\t\treturn this._selecting;\n\t}\n\n\tget squeezing() {\n\t\treturn this._squeezing;\n\t}\n\n\tset elementInput(value) {\n\t\tif (this._elementInput === value) return;\n\t\tthis._elementInput = value;\n\t\tif (!this._elementInput) this._elementEntity = null;\n\t}\n\n\tget elementInput() {\n\t\treturn this._elementInput;\n\t}\n\n\tget elementEntity() {\n\t\treturn this._elementEntity;\n\t}\n\n\tget hitTestSources() {\n\t\treturn this._hitTestSources;\n\t}\n\n\tupdate(frame) {\n\t\tif (this._hand) {\n\t\t\tthis._hand.update(frame);\n\t\t} else {\n\t\t\tif (this._xrInputSource.gripSpace) {\n\t\t\t\tconst gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);\n\n\t\t\t\tif (gripPose) {\n\t\t\t\t\tif (!this._grip) {\n\t\t\t\t\t\tthis._grip = true;\n\t\t\t\t\t\tthis._localTransform = new Mat4();\n\t\t\t\t\t\tthis._worldTransform = new Mat4();\n\t\t\t\t\t\tthis._localPosition = new Vec3();\n\t\t\t\t\t\tthis._localRotation = new Quat();\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._dirtyLocal = true;\n\n\t\t\t\t\tthis._localPosition.copy(gripPose.transform.position);\n\n\t\t\t\t\tthis._localRotation.copy(gripPose.transform.orientation);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);\n\n\t\t\tif (targetRayPose) {\n\t\t\t\tthis._dirtyRay = true;\n\n\t\t\t\tthis._rayLocal.origin.copy(targetRayPose.transform.position);\n\n\t\t\t\tthis._rayLocal.direction.set(0, 0, -1);\n\n\t\t\t\tquat$1.copy(targetRayPose.transform.orientation);\n\t\t\t\tquat$1.transformVector(this._rayLocal.direction, this._rayLocal.direction);\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateTransforms() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = false;\n\n\t\t\tthis._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);\n\t\t}\n\n\t\tconst parent = this._manager.camera.parent;\n\n\t\tif (parent) {\n\t\t\tthis._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);\n\t\t} else {\n\t\t\tthis._worldTransform.copy(this._localTransform);\n\t\t}\n\t}\n\n\t_updateRayTransforms() {\n\t\tconst dirty = this._dirtyRay;\n\t\tthis._dirtyRay = false;\n\t\tconst parent = this._manager.camera.parent;\n\n\t\tif (parent) {\n\t\t\tconst parentTransform = this._manager.camera.parent.getWorldTransform();\n\n\t\t\tparentTransform.getTranslation(this._position);\n\n\t\t\tthis._rotation.setFromMat4(parentTransform);\n\n\t\t\tthis._rotation.transformVector(this._rayLocal.origin, this._ray.origin);\n\n\t\t\tthis._ray.origin.add(this._position);\n\n\t\t\tthis._rotation.transformVector(this._rayLocal.direction, this._ray.direction);\n\t\t} else if (dirty) {\n\t\t\tthis._ray.origin.copy(this._rayLocal.origin);\n\n\t\t\tthis._ray.direction.copy(this._rayLocal.direction);\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\tif (!this._position) return null;\n\n\t\tthis._updateTransforms();\n\n\t\tthis._worldTransform.getTranslation(this._position);\n\n\t\treturn this._position;\n\t}\n\n\tgetLocalPosition() {\n\t\treturn this._localPosition;\n\t}\n\n\tgetRotation() {\n\t\tif (!this._rotation) return null;\n\n\t\tthis._updateTransforms();\n\n\t\tthis._rotation.setFromMat4(this._worldTransform);\n\n\t\treturn this._rotation;\n\t}\n\n\tgetLocalRotation() {\n\t\treturn this._localRotation;\n\t}\n\n\tgetOrigin() {\n\t\tthis._updateRayTransforms();\n\n\t\treturn this._ray.origin;\n\t}\n\n\tgetDirection() {\n\t\tthis._updateRayTransforms();\n\n\t\treturn this._ray.direction;\n\t}\n\n\thitTestStart(options = {}) {\n\t\toptions.profile = this._xrInputSource.profiles[0];\n\t\tconst callback = options.callback;\n\n\t\toptions.callback = (err, hitTestSource) => {\n\t\t\tif (hitTestSource) this.onHitTestSourceAdd(hitTestSource);\n\t\t\tif (callback) callback(err, hitTestSource);\n\t\t};\n\n\t\tthis._manager.hitTest.start(options);\n\t}\n\n\tonHitTestSourceAdd(hitTestSource) {\n\t\tthis._hitTestSources.push(hitTestSource);\n\n\t\tthis.fire('hittest:add', hitTestSource);\n\t\thitTestSource.on('result', function (position, rotation, inputSource) {\n\t\t\tif (inputSource !== this) return;\n\t\t\tthis.fire('hittest:result', hitTestSource, position, rotation);\n\t\t}, this);\n\t\thitTestSource.once('remove', function () {\n\t\t\tthis.onHitTestSourceRemove(hitTestSource);\n\t\t\tthis.fire('hittest:remove', hitTestSource);\n\t\t}, this);\n\t}\n\n\tonHitTestSourceRemove(hitTestSource) {\n\t\tconst ind = this._hitTestSources.indexOf(hitTestSource);\n\n\t\tif (ind !== -1) this._hitTestSources.splice(ind, 1);\n\t}\n\n}\n\nclass XrInput extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis._session = null;\n\t\tthis._inputSources = [];\n\n\t\tthis._onInputSourcesChangeEvt = evt => {\n\t\t\tthis._onInputSourcesChange(evt);\n\t\t};\n\n\t\tthis.manager.on('start', this._onSessionStart, this);\n\t\tthis.manager.on('end', this._onSessionEnd, this);\n\t}\n\n\t_onSessionStart() {\n\t\tthis._session = this.manager.session;\n\n\t\tthis._session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);\n\n\t\tthis._session.addEventListener('select', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource.fire('select', evt);\n\t\t\tthis.fire('select', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('selectstart', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._selecting = true;\n\t\t\tinputSource.fire('selectstart', evt);\n\t\t\tthis.fire('selectstart', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('selectend', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._selecting = false;\n\t\t\tinputSource.fire('selectend', evt);\n\t\t\tthis.fire('selectend', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('squeeze', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource.fire('squeeze', evt);\n\t\t\tthis.fire('squeeze', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('squeezestart', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._squeezing = true;\n\t\t\tinputSource.fire('squeezestart', evt);\n\t\t\tthis.fire('squeezestart', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('squeezeend', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._squeezing = false;\n\t\t\tinputSource.fire('squeezeend', evt);\n\t\t\tthis.fire('squeezeend', inputSource, evt);\n\t\t});\n\n\t\tconst inputSources = this._session.inputSources;\n\n\t\tfor (let i = 0; i < inputSources.length; i++) {\n\t\t\tthis._addInputSource(inputSources[i]);\n\t\t}\n\t}\n\n\t_onSessionEnd() {\n\t\tlet i = this._inputSources.length;\n\n\t\twhile (i--) {\n\t\t\tconst inputSource = this._inputSources[i];\n\n\t\t\tthis._inputSources.splice(i, 1);\n\n\t\t\tinputSource.fire('remove');\n\t\t\tthis.fire('remove', inputSource);\n\t\t}\n\n\t\tthis._session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);\n\n\t\tthis._session = null;\n\t}\n\n\t_onInputSourcesChange(evt) {\n\t\tfor (let i = 0; i < evt.removed.length; i++) {\n\t\t\tthis._removeInputSource(evt.removed[i]);\n\t\t}\n\n\t\tfor (let i = 0; i < evt.added.length; i++) {\n\t\t\tthis._addInputSource(evt.added[i]);\n\t\t}\n\t}\n\n\t_getByInputSource(xrInputSource) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tif (this._inputSources[i].inputSource === xrInputSource) {\n\t\t\t\treturn this._inputSources[i];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_addInputSource(xrInputSource) {\n\t\tif (this._getByInputSource(xrInputSource)) return;\n\t\tconst inputSource = new XrInputSource(this.manager, xrInputSource);\n\n\t\tthis._inputSources.push(inputSource);\n\n\t\tthis.fire('add', inputSource);\n\t}\n\n\t_removeInputSource(xrInputSource) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tif (this._inputSources[i].inputSource !== xrInputSource) continue;\n\t\t\tconst inputSource = this._inputSources[i];\n\n\t\t\tthis._inputSources.splice(i, 1);\n\n\t\t\tlet h = inputSource.hitTestSources.length;\n\n\t\t\twhile (h--) {\n\t\t\t\tinputSource.hitTestSources[h].remove();\n\t\t\t}\n\n\t\t\tinputSource.fire('remove');\n\t\t\tthis.fire('remove', inputSource);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tupdate(frame) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tthis._inputSources[i].update(frame);\n\t\t}\n\t}\n\n\tget inputSources() {\n\t\treturn this._inputSources;\n\t}\n\n}\n\nconst vec3A = new Vec3();\nconst vec3B = new Vec3();\nconst mat4A = new Mat4();\nconst mat4B = new Mat4();\n\nclass XrLightEstimation extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._supported = false;\n\t\tthis._available = false;\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t\tthis._intensity = 0;\n\t\tthis._rotation = new Quat();\n\t\tthis._color = new Color();\n\t\tthis._sphericalHarmonics = new Float32Array(27);\n\n\t\tthis._manager.on('start', this._onSessionStart, this);\n\n\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t}\n\n\t_onSessionStart() {\n\t\tconst supported = !!this._manager.session.requestLightProbe;\n\t\tif (!supported) return;\n\t\tthis._supported = true;\n\t}\n\n\t_onSessionEnd() {\n\t\tthis._supported = false;\n\t\tthis._available = false;\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t}\n\n\tstart() {\n\t\tlet err;\n\t\tif (!this._manager.session) err = new Error('XR session is not running');\n\t\tif (!err && this._manager.type !== XRTYPE_AR) err = new Error('XR session type is not AR');\n\t\tif (!err && !this._supported) err = new Error('light-estimation is not supported');\n\t\tif (!err && this._lightProbe || this._lightProbeRequested) err = new Error('light estimation is already requested');\n\n\t\tif (err) {\n\t\t\tthis.fire('error', err);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lightProbeRequested = true;\n\n\t\tthis._manager.session.requestLightProbe().then(lightProbe => {\n\t\t\tconst wasRequested = this._lightProbeRequested;\n\t\t\tthis._lightProbeRequested = false;\n\n\t\t\tif (this._manager.active) {\n\t\t\t\tif (wasRequested) {\n\t\t\t\t\tthis._lightProbe = lightProbe;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.fire('error', new Error('XR session is not active'));\n\t\t\t}\n\t\t}).catch(ex => {\n\t\t\tthis._lightProbeRequested = false;\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\n\tend() {\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t\tthis._available = false;\n\t}\n\n\tupdate(frame) {\n\t\tif (!this._lightProbe) return;\n\t\tconst lightEstimate = frame.getLightEstimate(this._lightProbe);\n\t\tif (!lightEstimate) return;\n\n\t\tif (!this._available) {\n\t\t\tthis._available = true;\n\t\t\tthis.fire('available');\n\t\t}\n\n\t\tconst pli = lightEstimate.primaryLightIntensity;\n\t\tthis._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));\n\t\tvec3A.copy(pli).mulScalar(1 / this._intensity);\n\n\t\tthis._color.set(vec3A.x, vec3A.y, vec3A.z);\n\n\t\tvec3A.set(0, 0, 0);\n\t\tvec3B.copy(lightEstimate.primaryLightDirection);\n\t\tmat4A.setLookAt(vec3B, vec3A, Vec3.UP);\n\t\tmat4B.setFromAxisAngle(Vec3.RIGHT, 90);\n\t\tmat4A.mul(mat4B);\n\n\t\tthis._rotation.setFromMat4(mat4A);\n\n\t\tthis._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget available() {\n\t\treturn this._available;\n\t}\n\n\tget intensity() {\n\t\treturn this._available ? this._intensity : null;\n\t}\n\n\tget color() {\n\t\treturn this._available ? this._color : null;\n\t}\n\n\tget rotation() {\n\t\treturn this._available ? this._rotation : null;\n\t}\n\n\tget sphericalHarmonics() {\n\t\treturn this._available ? this._sphericalHarmonics : null;\n\t}\n\n}\n\nclass XrTrackedImage extends EventHandler {\n\tconstructor(image, width) {\n\t\tsuper();\n\t\tthis._image = image;\n\t\tthis._bitmap = null;\n\t\tthis._width = width;\n\t\tthis._measuredWidth = 0;\n\t\tthis._trackable = false;\n\t\tthis._tracking = false;\n\t\tthis._emulated = false;\n\t\tthis._pose = null;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t}\n\n\tget image() {\n\t\treturn this._image;\n\t}\n\n\tset width(value) {\n\t\tthis._width = value;\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\n\tget trackable() {\n\t\treturn this._trackable;\n\t}\n\n\tget tracking() {\n\t\treturn this._tracking;\n\t}\n\n\tget emulated() {\n\t\treturn this._emulated;\n\t}\n\n\tprepare() {\n\t\tif (this._bitmap) {\n\t\t\treturn {\n\t\t\t\timage: this._bitmap,\n\t\t\t\twidthInMeters: this._width\n\t\t\t};\n\t\t}\n\n\t\treturn createImageBitmap(this._image).then(bitmap => {\n\t\t\tthis._bitmap = bitmap;\n\t\t\treturn {\n\t\t\t\timage: this._bitmap,\n\t\t\t\twidthInMeters: this._width\n\t\t\t};\n\t\t});\n\t}\n\n\tdestroy() {\n\t\tthis._image = null;\n\t\tthis._pose = null;\n\n\t\tif (this._bitmap) {\n\t\t\tthis._bitmap.close();\n\n\t\t\tthis._bitmap = null;\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\tif (this._pose) this._position.copy(this._pose.transform.position);\n\t\treturn this._position;\n\t}\n\n\tgetRotation() {\n\t\tif (this._pose) this._rotation.copy(this._pose.transform.orientation);\n\t\treturn this._rotation;\n\t}\n\n}\n\nclass XrImageTracking extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._supported = platform.browser && !!window.XRImageTrackingResult;\n\t\tthis._available = false;\n\t\tthis._images = [];\n\n\t\tif (this._supported) {\n\t\t\tthis._manager.on('start', this._onSessionStart, this);\n\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\n\tadd(image, width) {\n\t\tif (!this._supported || this._manager.active) return null;\n\t\tconst trackedImage = new XrTrackedImage(image, width);\n\n\t\tthis._images.push(trackedImage);\n\n\t\treturn trackedImage;\n\t}\n\n\tremove(trackedImage) {\n\t\tif (this._manager.active) return;\n\n\t\tconst ind = this._images.indexOf(trackedImage);\n\n\t\tif (ind !== -1) {\n\t\t\ttrackedImage.destroy();\n\n\t\t\tthis._images.splice(ind, 1);\n\t\t}\n\t}\n\n\t_onSessionStart() {\n\t\tthis._manager.session.getTrackedImageScores().then(images => {\n\t\t\tthis._available = true;\n\n\t\t\tfor (let i = 0; i < images.length; i++) {\n\t\t\t\tthis._images[i]._trackable = images[i] === 'trackable';\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('error', err);\n\t\t});\n\t}\n\n\t_onSessionEnd() {\n\t\tthis._available = false;\n\n\t\tfor (let i = 0; i < this._images.length; i++) {\n\t\t\tthis._images[i]._pose = null;\n\t\t\tthis._images[i]._measuredWidth = 0;\n\n\t\t\tif (this._images[i]._tracking) {\n\t\t\t\tthis._images[i]._tracking = false;\n\n\t\t\t\tthis._images[i].fire('untracked');\n\t\t\t}\n\t\t}\n\t}\n\n\tprepareImages(callback) {\n\t\tif (this._images.length) {\n\t\t\tPromise.all(this._images.map(function (trackedImage) {\n\t\t\t\treturn trackedImage.prepare();\n\t\t\t})).then(function (bitmaps) {\n\t\t\t\tcallback(null, bitmaps);\n\t\t\t}).catch(function (err) {\n\t\t\t\tcallback(err, null);\n\t\t\t});\n\t\t} else {\n\t\t\tcallback(null, null);\n\t\t}\n\t}\n\n\tupdate(frame) {\n\t\tif (!this._available) return;\n\t\tconst results = frame.getImageTrackingResults();\n\t\tconst index = {};\n\n\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\tindex[results[i].index] = results[i];\n\t\t\tconst trackedImage = this._images[results[i].index];\n\t\t\ttrackedImage._emulated = results[i].trackingState === 'emulated';\n\t\t\ttrackedImage._measuredWidth = results[i].measuredWidthInMeters;\n\t\t\ttrackedImage._dirtyTransform = true;\n\t\t\ttrackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);\n\t\t}\n\n\t\tfor (let i = 0; i < this._images.length; i++) {\n\t\t\tif (this._images[i]._tracking && !index[i]) {\n\t\t\t\tthis._images[i]._tracking = false;\n\n\t\t\t\tthis._images[i].fire('untracked');\n\t\t\t} else if (!this._images[i]._tracking && index[i]) {\n\t\t\t\tthis._images[i]._tracking = true;\n\n\t\t\t\tthis._images[i].fire('tracked');\n\t\t\t}\n\t\t}\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget available() {\n\t\treturn this._available;\n\t}\n\n\tget images() {\n\t\treturn this._images;\n\t}\n\n}\n\nclass XrDomOverlay {\n\tconstructor(manager) {\n\t\tthis._manager = manager;\n\t\tthis._supported = platform.browser && !!window.XRDOMOverlayState;\n\t\tthis._root = null;\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget available() {\n\t\treturn this._supported && this._manager.active && this._manager._session.domOverlayState !== null;\n\t}\n\n\tget state() {\n\t\tif (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) return null;\n\t\treturn this._manager._session.domOverlayState.type;\n\t}\n\n\tset root(value) {\n\t\tif (!this._supported || this._manager.active) return;\n\t\tthis._root = value;\n\t}\n\n\tget root() {\n\t\treturn this._root;\n\t}\n\n}\n\nclass XrDepthSensing extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._available = false;\n\t\tthis._depthInfoCpu = null;\n\t\tthis._depthInfoGpu = null;\n\t\tthis._usage = null;\n\t\tthis._dataFormat = null;\n\t\tthis._matrixDirty = false;\n\t\tthis._matrix = new Mat4();\n\t\tthis._emptyBuffer = new Uint8Array(32);\n\t\tthis._depthBuffer = null;\n\t\tthis._texture = new Texture(this._manager.app.graphicsDevice, {\n\t\t\tformat: PIXELFORMAT_L8_A8,\n\t\t\tmipmaps: false,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tminFilter: FILTER_LINEAR,\n\t\t\tmagFilter: FILTER_LINEAR\n\t\t});\n\n\t\tif (this.supported) {\n\t\t\tthis._manager.on('start', this._onSessionStart, this);\n\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\n\t_onSessionStart() {\n\t\tconst session = this._manager.session;\n\n\t\ttry {\n\t\t\tthis._usage = session.depthUsage;\n\t\t\tthis._dataFormat = session.depthDataFormat;\n\t\t} catch (ex) {\n\t\t\tthis._usage = null;\n\t\t\tthis._dataFormat = null;\n\t\t\tthis._available = false;\n\t\t\tthis.fire('error', ex);\n\t\t}\n\t}\n\n\t_onSessionEnd() {\n\t\tthis._depthInfoCpu = null;\n\t\tthis._depthInfoGpu = null;\n\t\tthis._usage = null;\n\t\tthis._dataFormat = null;\n\n\t\tif (this._available) {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('unavailable');\n\t\t}\n\n\t\tthis._depthBuffer = null;\n\t\tthis._texture._width = 4;\n\t\tthis._texture._height = 4;\n\t\tthis._texture._levels[0] = this._emptyBuffer;\n\n\t\tthis._texture.upload();\n\t}\n\n\t_updateTexture() {\n\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\n\t\tif (depthInfo) {\n\t\t\tlet resized = false;\n\n\t\t\tif (depthInfo.width !== this._texture.width || depthInfo.height !== this._texture.height) {\n\t\t\t\tthis._texture._width = depthInfo.width;\n\t\t\t\tthis._texture._height = depthInfo.height;\n\t\t\t\tthis._matrixDirty = true;\n\t\t\t\tresized = true;\n\t\t\t}\n\n\t\t\tif (this._depthInfoCpu) {\n\t\t\t\tconst dataBuffer = this._depthInfoCpu.data;\n\t\t\t\tthis._depthBuffer = new Uint8Array(dataBuffer);\n\t\t\t\tthis._texture._levels[0] = this._depthBuffer;\n\n\t\t\t\tthis._texture.upload();\n\t\t\t} else if (this._depthInfoGpu) {\n\t\t\t\tthis._texture._levels[0] = this._depthInfoGpu.texture;\n\n\t\t\t\tthis._texture.upload();\n\t\t\t}\n\n\t\t\tif (resized) this.fire('resize', depthInfo.width, depthInfo.height);\n\t\t} else if (this._depthBuffer) {\n\t\t\tthis._depthBuffer = null;\n\t\t\tthis._texture._width = 4;\n\t\t\tthis._texture._height = 4;\n\t\t\tthis._texture._levels[0] = this._emptyBuffer;\n\n\t\t\tthis._texture.upload();\n\t\t}\n\t}\n\n\tupdate(frame, view) {\n\t\tif (!this._usage) return;\n\t\tlet depthInfoCpu = null;\n\t\tlet depthInfoGpu = null;\n\n\t\tif (this._usage === XRDEPTHSENSINGUSAGE_CPU && view) {\n\t\t\tdepthInfoCpu = frame.getDepthInformation(view);\n\t\t} else if (this._usage === XRDEPTHSENSINGUSAGE_GPU && view) {\n\t\t\tdepthInfoGpu = frame.getDepthInformation(view);\n\t\t}\n\n\t\tif (this._depthInfoCpu && !depthInfoCpu || !this._depthInfoCpu && depthInfoCpu || this.depthInfoGpu && !depthInfoGpu || !this._depthInfoGpu && depthInfoGpu) {\n\t\t\tthis._matrixDirty = true;\n\t\t}\n\n\t\tthis._depthInfoCpu = depthInfoCpu;\n\t\tthis._depthInfoGpu = depthInfoGpu;\n\n\t\tthis._updateTexture();\n\n\t\tif (this._matrixDirty) {\n\t\t\tthis._matrixDirty = false;\n\t\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\n\t\t\tif (depthInfo) {\n\t\t\t\tthis._matrix.data.set(depthInfo.normDepthBufferFromNormView.matrix);\n\t\t\t} else {\n\t\t\t\tthis._matrix.setIdentity();\n\t\t\t}\n\t\t}\n\n\t\tif ((this._depthInfoCpu || this._depthInfoGpu) && !this._available) {\n\t\t\tthis._available = true;\n\t\t\tthis.fire('available');\n\t\t} else if (!this._depthInfoCpu && !this._depthInfoGpu && this._available) {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('unavailable');\n\t\t}\n\t}\n\n\tgetDepth(u, v) {\n\t\tif (!this._depthInfoCpu) return null;\n\t\treturn this._depthInfoCpu.getDepthInMeters(u, v);\n\t}\n\n\tget supported() {\n\t\treturn platform.browser && !!window.XRDepthInformation;\n\t}\n\n\tget available() {\n\t\treturn this._available;\n\t}\n\n\tget usage() {\n\t\treturn this._usage;\n\t}\n\n\tget dataFormat() {\n\t\treturn this._dataFormat;\n\t}\n\n\tget width() {\n\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\t\treturn depthInfo && depthInfo.width || 0;\n\t}\n\n\tget height() {\n\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\t\treturn depthInfo && depthInfo.height || 0;\n\t}\n\n\tget texture() {\n\t\treturn this._texture;\n\t}\n\n\tget uvMatrix() {\n\t\treturn this._matrix;\n\t}\n\n\tget rawValueToMeters() {\n\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\t\treturn depthInfo && depthInfo.rawValueToMeters || 0;\n\t}\n\n}\n\nlet ids = 0;\n\nclass XrPlane extends EventHandler {\n\tconstructor(planeDetection, xrPlane) {\n\t\tsuper();\n\t\tthis._id = ++ids;\n\t\tthis._planeDetection = planeDetection;\n\t\tthis._manager = this._planeDetection._manager;\n\t\tthis._xrPlane = xrPlane;\n\t\tthis._lastChangedTime = this._xrPlane.lastChangedTime;\n\t\tthis._orientation = this._xrPlane.orientation;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t}\n\n\tdestroy() {\n\t\tthis.fire('remove');\n\t}\n\n\tupdate(frame) {\n\t\tconst pose = frame.getPose(this._xrPlane.planeSpace, this._manager._referenceSpace);\n\n\t\tif (pose) {\n\t\t\tthis._position.copy(pose.transform.position);\n\n\t\t\tthis._rotation.copy(pose.transform.orientation);\n\t\t}\n\n\t\tif (this._lastChangedTime !== this._xrPlane.lastChangedTime) {\n\t\t\tthis._lastChangedTime = this._xrPlane.lastChangedTime;\n\t\t\tthis.fire('change');\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\treturn this._position;\n\t}\n\n\tgetRotation() {\n\t\treturn this._rotation;\n\t}\n\n\tget id() {\n\t\treturn this.id;\n\t}\n\n\tget orientation() {\n\t\treturn this._orientation;\n\t}\n\n\tget points() {\n\t\treturn this._xrPlane.polygon;\n\t}\n\n}\n\nclass XrPlaneDetection extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._supported = platform.browser && !!window.XRPlane;\n\t\tthis._available = false;\n\t\tthis._planesIndex = new Map();\n\t\tthis._planes = null;\n\n\t\tif (this._supported) {\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\n\t_onSessionEnd() {\n\t\tif (this._planes) {\n\t\t\tfor (let i = 0; i < this._planes.length; i++) {\n\t\t\t\tthis._planes[i].destroy();\n\t\t\t}\n\t\t}\n\n\t\tthis._planesIndex.clear();\n\n\t\tthis._planes = null;\n\n\t\tif (this._available) {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('unavailable');\n\t\t}\n\t}\n\n\tupdate(frame) {\n\t\tlet detectedPlanes;\n\n\t\tif (!this._available) {\n\t\t\ttry {\n\t\t\t\tdetectedPlanes = frame.detectedPlanes;\n\t\t\t\tthis._planes = [];\n\t\t\t\tthis._available = true;\n\t\t\t\tthis.fire('available');\n\t\t\t} catch (ex) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tdetectedPlanes = frame.detectedPlanes;\n\t\t}\n\n\t\tfor (const [xrPlane, plane] of this._planesIndex) {\n\t\t\tif (detectedPlanes.has(xrPlane)) continue;\n\n\t\t\tthis._planesIndex.delete(xrPlane);\n\n\t\t\tthis._planes.splice(this._planes.indexOf(plane), 1);\n\n\t\t\tplane.destroy();\n\t\t\tthis.fire('remove', plane);\n\t\t}\n\n\t\tfor (const xrPlane of detectedPlanes) {\n\t\t\tlet plane = this._planesIndex.get(xrPlane);\n\n\t\t\tif (!plane) {\n\t\t\t\tplane = new XrPlane(this, xrPlane);\n\n\t\t\t\tthis._planesIndex.set(xrPlane, plane);\n\n\t\t\t\tthis._planes.push(plane);\n\n\t\t\t\tplane.update(frame);\n\t\t\t\tthis.fire('add', plane);\n\t\t\t} else {\n\t\t\t\tplane.update(frame);\n\t\t\t}\n\t\t}\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget available() {\n\t\treturn this._available;\n\t}\n\n\tget planes() {\n\t\treturn this._planes;\n\t}\n\n}\n\nclass XrManager extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.app = app;\n\t\tthis._supported = platform.browser && !!navigator.xr;\n\t\tthis._available = {};\n\t\tthis._available[XRTYPE_INLINE] = false;\n\t\tthis._available[XRTYPE_VR] = false;\n\t\tthis._available[XRTYPE_AR] = false;\n\t\tthis._type = null;\n\t\tthis._spaceType = null;\n\t\tthis._session = null;\n\t\tthis._baseLayer = null;\n\t\tthis._referenceSpace = null;\n\t\tthis.depthSensing = new XrDepthSensing(this);\n\t\tthis.domOverlay = new XrDomOverlay(this);\n\t\tthis.hitTest = new XrHitTest(this);\n\t\tthis.imageTracking = new XrImageTracking(this);\n\t\tthis.planeDetection = new XrPlaneDetection(this);\n\t\tthis.input = new XrInput(this);\n\t\tthis.lightEstimation = new XrLightEstimation(this);\n\t\tthis._camera = null;\n\t\tthis.views = [];\n\t\tthis.viewsPool = [];\n\t\tthis._localPosition = new Vec3();\n\t\tthis._localRotation = new Quat();\n\t\tthis._depthNear = 0.1;\n\t\tthis._depthFar = 1000;\n\t\tthis._width = 0;\n\t\tthis._height = 0;\n\n\t\tif (this._supported) {\n\t\t\tnavigator.xr.addEventListener('devicechange', () => {\n\t\t\t\tthis._deviceAvailabilityCheck();\n\t\t\t});\n\n\t\t\tthis._deviceAvailabilityCheck();\n\t\t}\n\t}\n\n\tstart(camera, type, spaceType, options) {\n\t\tlet callback = options;\n\t\tif (typeof options === 'object') callback = options.callback;\n\n\t\tif (!this._available[type]) {\n\t\t\tif (callback) callback(new Error('XR is not available'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._session) {\n\t\t\tif (callback) callback(new Error('XR session is already started'));\n\t\t\treturn;\n\t\t}\n\n\t\tthis._camera = camera;\n\t\tthis._camera.camera.xr = this;\n\t\tthis._type = type;\n\t\tthis._spaceType = spaceType;\n\n\t\tthis._setClipPlanes(camera.nearClip, camera.farClip);\n\n\t\tconst opts = {\n\t\t\trequiredFeatures: [spaceType],\n\t\t\toptionalFeatures: []\n\t\t};\n\n\t\tif (type === XRTYPE_AR) {\n\t\t\topts.optionalFeatures.push('light-estimation');\n\t\t\topts.optionalFeatures.push('hit-test');\n\n\t\t\tif (options) {\n\t\t\t\tif (options.imageTracking && this.imageTracking.supported) opts.optionalFeatures.push('image-tracking');\n\t\t\t\tif (options.planeDetection) opts.optionalFeatures.push('plane-detection');\n\t\t\t}\n\n\t\t\tif (this.domOverlay.supported && this.domOverlay.root) {\n\t\t\t\topts.optionalFeatures.push('dom-overlay');\n\t\t\t\topts.domOverlay = {\n\t\t\t\t\troot: this.domOverlay.root\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (options && options.depthSensing && this.depthSensing.supported) {\n\t\t\t\topts.optionalFeatures.push('depth-sensing');\n\t\t\t\tconst usagePreference = [XRDEPTHSENSINGUSAGE_CPU];\n\t\t\t\tconst dataFormatPreference = [XRDEPTHSENSINGFORMAT_L8A8];\n\n\t\t\t\tif (options.depthSensing.usagePreference) {\n\t\t\t\t\tconst ind = usagePreference.indexOf(options.depthSensing.usagePreference);\n\t\t\t\t\tif (ind !== -1) usagePreference.splice(ind, 1);\n\t\t\t\t\tusagePreference.unshift(options.depthSensing.usagePreference);\n\t\t\t\t}\n\n\t\t\t\tif (options.depthSensing.dataFormatPreference) {\n\t\t\t\t\tconst ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);\n\t\t\t\t\tif (ind !== -1) dataFormatPreference.splice(ind, 1);\n\t\t\t\t\tdataFormatPreference.unshift(options.depthSensing.dataFormatPreference);\n\t\t\t\t}\n\n\t\t\t\topts.depthSensing = {\n\t\t\t\t\tusagePreference: usagePreference,\n\t\t\t\t\tdataFormatPreference: dataFormatPreference\n\t\t\t\t};\n\t\t\t}\n\t\t} else if (type === XRTYPE_VR) {\n\t\t\topts.optionalFeatures.push('hand-tracking');\n\t\t}\n\n\t\tif (options && options.optionalFeatures) opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);\n\n\t\tif (this.imageTracking.supported && this.imageTracking.images.length) {\n\t\t\tthis.imageTracking.prepareImages((err, trackedImages) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (callback) callback(err);\n\t\t\t\t\tthis.fire('error', err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (trackedImages !== null) opts.trackedImages = trackedImages;\n\n\t\t\t\tthis._onStartOptionsReady(type, spaceType, opts, callback);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._onStartOptionsReady(type, spaceType, opts, callback);\n\t\t}\n\t}\n\n\t_onStartOptionsReady(type, spaceType, options, callback) {\n\t\tnavigator.xr.requestSession(type, options).then(session => {\n\t\t\tthis._onSessionStart(session, spaceType, callback);\n\t\t}).catch(ex => {\n\t\t\tthis._camera.camera.xr = null;\n\t\t\tthis._camera = null;\n\t\t\tthis._type = null;\n\t\t\tthis._spaceType = null;\n\t\t\tif (callback) callback(ex);\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\n\tend(callback) {\n\t\tif (!this._session) {\n\t\t\tif (callback) callback(new Error('XR Session is not initialized'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (callback) this.once('end', callback);\n\n\t\tthis._session.end();\n\t}\n\n\tisAvailable(type) {\n\t\treturn this._available[type];\n\t}\n\n\t_deviceAvailabilityCheck() {\n\t\tfor (const key in this._available) {\n\t\t\tthis._sessionSupportCheck(key);\n\t\t}\n\t}\n\n\t_sessionSupportCheck(type) {\n\t\tnavigator.xr.isSessionSupported(type).then(available => {\n\t\t\tif (this._available[type] === available) return;\n\t\t\tthis._available[type] = available;\n\t\t\tthis.fire('available', type, available);\n\t\t\tthis.fire('available:' + type, available);\n\t\t}).catch(ex => {\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\n\t_onSessionStart(session, spaceType, callback) {\n\t\tlet failed = false;\n\t\tthis._session = session;\n\n\t\tconst onVisibilityChange = () => {\n\t\t\tthis.fire('visibility:change', session.visibilityState);\n\t\t};\n\n\t\tconst onClipPlanesChange = () => {\n\t\t\tthis._setClipPlanes(this._camera.nearClip, this._camera.farClip);\n\t\t};\n\n\t\tconst onEnd = () => {\n\t\t\tthis._session = null;\n\t\t\tthis._referenceSpace = null;\n\t\t\tthis.views = [];\n\t\t\tthis._width = 0;\n\t\t\tthis._height = 0;\n\t\t\tthis._type = null;\n\t\t\tthis._spaceType = null;\n\n\t\t\tif (this._camera) {\n\t\t\t\tthis._camera.off('set_nearClip', onClipPlanesChange);\n\n\t\t\t\tthis._camera.off('set_farClip', onClipPlanesChange);\n\n\t\t\t\tthis._camera.camera.xr = null;\n\t\t\t\tthis._camera = null;\n\t\t\t}\n\n\t\t\tsession.removeEventListener('end', onEnd);\n\t\t\tsession.removeEventListener('visibilitychange', onVisibilityChange);\n\t\t\tif (!failed) this.fire('end');\n\t\t\tthis.app.tick();\n\t\t};\n\n\t\tsession.addEventListener('end', onEnd);\n\t\tsession.addEventListener('visibilitychange', onVisibilityChange);\n\n\t\tthis._camera.on('set_nearClip', onClipPlanesChange);\n\n\t\tthis._camera.on('set_farClip', onClipPlanesChange);\n\n\t\tthis._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl);\n\t\tsession.updateRenderState({\n\t\t\tbaseLayer: this._baseLayer,\n\t\t\tdepthNear: this._depthNear,\n\t\t\tdepthFar: this._depthFar\n\t\t});\n\t\tsession.requestReferenceSpace(spaceType).then(referenceSpace => {\n\t\t\tthis._referenceSpace = referenceSpace;\n\t\t\tthis.app.tick();\n\t\t\tif (callback) callback(null);\n\t\t\tthis.fire('start');\n\t\t}).catch(ex => {\n\t\t\tfailed = true;\n\t\t\tsession.end();\n\t\t\tif (callback) callback(ex);\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\n\t_setClipPlanes(near, far) {\n\t\tif (this._depthNear === near && this._depthFar === far) return;\n\t\tthis._depthNear = near;\n\t\tthis._depthFar = far;\n\t\tif (!this._session) return;\n\n\t\tthis._session.updateRenderState({\n\t\t\tdepthNear: this._depthNear,\n\t\t\tdepthFar: this._depthFar\n\t\t});\n\t}\n\n\tupdate(frame) {\n\t\tif (!this._session) return;\n\t\tconst width = frame.session.renderState.baseLayer.framebufferWidth;\n\t\tconst height = frame.session.renderState.baseLayer.framebufferHeight;\n\n\t\tif (this._width !== width || this._height !== height) {\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\t\t\tthis.app.graphicsDevice.setResolution(width, height);\n\t\t}\n\n\t\tconst pose = frame.getViewerPose(this._referenceSpace);\n\t\tconst lengthNew = pose ? pose.views.length : 0;\n\n\t\tif (lengthNew > this.views.length) {\n\t\t\tfor (let i = 0; i <= lengthNew - this.views.length; i++) {\n\t\t\t\tlet view = this.viewsPool.pop();\n\n\t\t\t\tif (!view) {\n\t\t\t\t\tview = {\n\t\t\t\t\t\tviewport: new Vec4(),\n\t\t\t\t\t\tprojMat: new Mat4(),\n\t\t\t\t\t\tviewMat: new Mat4(),\n\t\t\t\t\t\tviewOffMat: new Mat4(),\n\t\t\t\t\t\tviewInvMat: new Mat4(),\n\t\t\t\t\t\tviewInvOffMat: new Mat4(),\n\t\t\t\t\t\tprojViewOffMat: new Mat4(),\n\t\t\t\t\t\tviewMat3: new Mat3(),\n\t\t\t\t\t\tposition: new Float32Array(3),\n\t\t\t\t\t\trotation: new Quat()\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tthis.views.push(view);\n\t\t\t}\n\t\t} else if (lengthNew <= this.views.length) {\n\t\t\tfor (let i = 0; i < this.views.length - lengthNew; i++) {\n\t\t\t\tthis.viewsPool.push(this.views.pop());\n\t\t\t}\n\t\t}\n\n\t\tif (pose) {\n\t\t\tconst posePosition = pose.transform.position;\n\t\t\tconst poseOrientation = pose.transform.orientation;\n\n\t\t\tthis._localPosition.set(posePosition.x, posePosition.y, posePosition.z);\n\n\t\t\tthis._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);\n\n\t\t\tconst layer = frame.session.renderState.baseLayer;\n\n\t\t\tfor (let i = 0; i < pose.views.length; i++) {\n\t\t\t\tconst viewRaw = pose.views[i];\n\t\t\t\tconst view = this.views[i];\n\t\t\t\tconst viewport = layer.getViewport(viewRaw);\n\t\t\t\tview.viewport.x = viewport.x;\n\t\t\t\tview.viewport.y = viewport.y;\n\t\t\t\tview.viewport.z = viewport.width;\n\t\t\t\tview.viewport.w = viewport.height;\n\t\t\t\tview.projMat.set(viewRaw.projectionMatrix);\n\t\t\t\tview.viewMat.set(viewRaw.transform.inverse.matrix);\n\t\t\t\tview.viewInvMat.set(viewRaw.transform.matrix);\n\t\t\t}\n\t\t}\n\n\t\tthis._camera.camera._node.setLocalPosition(this._localPosition);\n\n\t\tthis._camera.camera._node.setLocalRotation(this._localRotation);\n\n\t\tthis.input.update(frame);\n\n\t\tif (this._type === XRTYPE_AR) {\n\t\t\tif (this.hitTest.supported) this.hitTest.update(frame);\n\t\t\tif (this.lightEstimation.supported) this.lightEstimation.update(frame);\n\t\t\tif (this.depthSensing.supported) this.depthSensing.update(frame, pose && pose.views[0]);\n\t\t\tif (this.imageTracking.supported) this.imageTracking.update(frame);\n\t\t\tif (this.planeDetection.supported) this.planeDetection.update(frame);\n\t\t}\n\n\t\tthis.fire('update', frame);\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget active() {\n\t\treturn !!this._session;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget spaceType() {\n\t\treturn this._spaceType;\n\t}\n\n\tget session() {\n\t\treturn this._session;\n\t}\n\n\tget camera() {\n\t\treturn this._camera ? this._camera.entity : null;\n\t}\n\n\tget visibilityState() {\n\t\tif (!this._session) return null;\n\t\treturn this._session.visibilityState;\n\t}\n\n}\n\nclass ComponentSystem extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.app = app;\n\t\tthis.store = {};\n\t\tthis.schema = [];\n\t}\n\n\taddComponent(entity, data = {}) {\n\t\tconst component = new this.ComponentType(this, entity);\n\t\tconst componentData = new this.DataType();\n\t\tthis.store[entity.getGuid()] = {\n\t\t\tentity: entity,\n\t\t\tdata: componentData\n\t\t};\n\t\tentity[this.id] = component;\n\t\tentity.c[this.id] = component;\n\t\tthis.initializeComponentData(component, data, []);\n\t\tthis.fire('add', entity, component);\n\t\treturn component;\n\t}\n\n\tremoveComponent(entity) {\n\t\tconst record = this.store[entity.getGuid()];\n\t\tconst component = entity.c[this.id];\n\t\tthis.fire('beforeremove', entity, component);\n\t\tdelete this.store[entity.getGuid()];\n\t\tentity[this.id] = undefined;\n\t\tdelete entity.c[this.id];\n\t\tthis.fire('remove', entity, record.data);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst src = this.store[entity.getGuid()];\n\t\treturn this.addComponent(clone, src.data);\n\t}\n\n\tinitializeComponentData(component, data = {}, properties) {\n\t\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\t\tconst descriptor = properties[i];\n\t\t\tlet name, type;\n\n\t\t\tif (typeof descriptor === 'object') {\n\t\t\t\tname = descriptor.name;\n\t\t\t\ttype = descriptor.type;\n\t\t\t} else {\n\t\t\t\tname = descriptor;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\n\t\t\tlet value = data[name];\n\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (type !== undefined) {\n\t\t\t\t\tvalue = convertValue(value, type);\n\t\t\t\t}\n\n\t\t\t\tcomponent[name] = value;\n\t\t\t} else {\n\t\t\t\tcomponent[name] = component.data[name];\n\t\t\t}\n\t\t}\n\n\t\tif (component.enabled && component.entity.enabled) {\n\t\t\tcomponent.onEnable();\n\t\t}\n\t}\n\n\tgetPropertiesOfType(type) {\n\t\tconst matchingProperties = [];\n\t\tconst schema = this.schema || [];\n\t\tschema.forEach(function (descriptor) {\n\t\t\tif (descriptor && typeof descriptor === 'object' && descriptor.type === type) {\n\t\t\t\tmatchingProperties.push(descriptor);\n\t\t\t}\n\t\t});\n\t\treturn matchingProperties;\n\t}\n\n\tdestroy() {\n\t\tthis.off();\n\t}\n\n}\n\nfunction convertValue(value, type) {\n\tif (!value) {\n\t\treturn value;\n\t}\n\n\tswitch (type) {\n\t\tcase 'rgb':\n\t\t\tif (value instanceof Color) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Color(value[0], value[1], value[2]);\n\n\t\tcase 'rgba':\n\t\t\tif (value instanceof Color) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Color(value[0], value[1], value[2], value[3]);\n\n\t\tcase 'vec2':\n\t\t\tif (value instanceof Vec2) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Vec2(value[0], value[1]);\n\n\t\tcase 'vec3':\n\t\t\tif (value instanceof Vec3) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Vec3(value[0], value[1], value[2]);\n\n\t\tcase 'vec4':\n\t\t\tif (value instanceof Vec4) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Vec4(value[0], value[1], value[2], value[3]);\n\n\t\tcase 'boolean':\n\t\tcase 'number':\n\t\tcase 'string':\n\t\t\treturn value;\n\n\t\tcase 'entity':\n\t\t\treturn value;\n\n\t\tdefault:\n\t\t\tthrow new Error('Could not convert unhandled type: ' + type);\n\t}\n}\n\nclass AnimCache {\n\tconstructor() {\n\t\tthis._left = Infinity;\n\t\tthis._right = -Infinity;\n\t\tthis._len = 0;\n\t\tthis._recip = 0;\n\t\tthis._p0 = 0;\n\t\tthis._p1 = 0;\n\t\tthis._t = 0;\n\t\tthis._hermite = {\n\t\t\tvalid: false,\n\t\t\tp0: 0,\n\t\t\tm0: 0,\n\t\t\tp1: 0,\n\t\t\tm1: 0\n\t\t};\n\t}\n\n\tupdate(time, input) {\n\t\tif (time < this._left || time >= this._right) {\n\t\t\tconst len = input.length;\n\n\t\t\tif (!len) {\n\t\t\t\tthis._left = -Infinity;\n\t\t\t\tthis._right = Infinity;\n\t\t\t\tthis._len = 0;\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = 0;\n\t\t\t} else {\n\t\t\t\tif (time < input[0]) {\n\t\t\t\t\tthis._left = -Infinity;\n\t\t\t\t\tthis._right = input[0];\n\t\t\t\t\tthis._len = 0;\n\t\t\t\t\tthis._recip = 0;\n\t\t\t\t\tthis._p0 = this._p1 = 0;\n\t\t\t\t} else if (time >= input[len - 1]) {\n\t\t\t\t\tthis._left = input[len - 1];\n\t\t\t\t\tthis._right = Infinity;\n\t\t\t\t\tthis._len = 0;\n\t\t\t\t\tthis._recip = 0;\n\t\t\t\t\tthis._p0 = this._p1 = len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tconst index = this._findKey(time, input);\n\n\t\t\t\t\tthis._left = input[index];\n\t\t\t\t\tthis._right = input[index + 1];\n\t\t\t\t\tthis._len = this._right - this._left;\n\t\t\t\t\tconst diff = 1.0 / this._len;\n\t\t\t\t\tthis._recip = isFinite(diff) ? diff : 0;\n\t\t\t\t\tthis._p0 = index;\n\t\t\t\t\tthis._p1 = index + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;\n\t\tthis._hermite.valid = false;\n\t}\n\n\t_findKey(time, input) {\n\t\tlet index = 0;\n\n\t\twhile (time >= input[index + 1]) {\n\t\t\tindex++;\n\t\t}\n\n\t\treturn index;\n\t}\n\n\teval(result, interpolation, output) {\n\t\tconst data = output._data;\n\t\tconst comp = output._components;\n\t\tconst idx0 = this._p0 * comp;\n\n\t\tif (interpolation === INTERPOLATION_STEP) {\n\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\tresult[i] = data[idx0 + i];\n\t\t\t}\n\t\t} else {\n\t\t\tconst t = this._t;\n\t\t\tconst idx1 = this._p1 * comp;\n\n\t\t\tswitch (interpolation) {\n\t\t\t\tcase INTERPOLATION_LINEAR:\n\t\t\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\t\t\tresult[i] = math.lerp(data[idx0 + i], data[idx1 + i], t);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INTERPOLATION_CUBIC:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst hermite = this._hermite;\n\n\t\t\t\t\t\tif (!hermite.valid) {\n\t\t\t\t\t\t\tconst t2 = t * t;\n\t\t\t\t\t\t\tconst twot = t + t;\n\t\t\t\t\t\t\tconst omt = 1 - t;\n\t\t\t\t\t\t\tconst omt2 = omt * omt;\n\t\t\t\t\t\t\thermite.valid = true;\n\t\t\t\t\t\t\thermite.p0 = (1 + twot) * omt2;\n\t\t\t\t\t\t\thermite.m0 = t * omt2;\n\t\t\t\t\t\t\thermite.p1 = t2 * (3 - twot);\n\t\t\t\t\t\t\thermite.m1 = t2 * (t - 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst p0 = (this._p0 * 3 + 1) * comp;\n\t\t\t\t\t\tconst m0 = (this._p0 * 3 + 2) * comp;\n\t\t\t\t\t\tconst p1 = (this._p1 * 3 + 1) * comp;\n\t\t\t\t\t\tconst m1 = (this._p1 * 3 + 0) * comp;\n\n\t\t\t\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\t\t\t\tresult[i] = hermite.p0 * data[p0 + i] + hermite.m0 * data[m0 + i] * this._len + hermite.p1 * data[p1 + i] + hermite.m1 * data[m1 + i] * this._len;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimSnapshot {\n\tconstructor(animTrack) {\n\t\tthis._name = animTrack.name + 'Snapshot';\n\t\tthis._time = -1;\n\t\tthis._cache = [];\n\t\tthis._results = [];\n\n\t\tfor (let i = 0; i < animTrack._inputs.length; ++i) {\n\t\t\tthis._cache[i] = new AnimCache();\n\t\t}\n\n\t\tconst curves = animTrack._curves;\n\t\tconst outputs = animTrack._outputs;\n\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst output = outputs[curve._output];\n\t\t\tconst storage = [];\n\n\t\t\tfor (let j = 0; j < output._components; ++j) {\n\t\t\t\tstorage[j] = 0;\n\t\t\t}\n\n\t\t\tthis._results[i] = storage;\n\t\t}\n\t}\n\n}\n\nclass AnimClip {\n\tconstructor(track, time, speed, playing, loop, eventHandler) {\n\t\tthis._name = track.name;\n\t\tthis._track = track;\n\t\tthis._snapshot = new AnimSnapshot(track);\n\t\tthis._playing = playing;\n\t\tthis._time = time;\n\t\tthis._speed = speed;\n\t\tthis._loop = loop;\n\t\tthis._blendWeight = 1.0;\n\t\tthis._blendOrder = 0.0;\n\t\tthis._eventHandler = eventHandler;\n\t\tthis._eventCursor = 0;\n\n\t\twhile (this._track.events[this._eventCursor] && this._track.events[this._eventCursor].time < this.time) {\n\t\t\tthis._eventCursor++;\n\t\t}\n\t}\n\n\tset name(name) {\n\t\tthis._name = name;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tget track() {\n\t\treturn this._track;\n\t}\n\n\tget snapshot() {\n\t\treturn this._snapshot;\n\t}\n\n\tset time(time) {\n\t\tthis._time = time;\n\t}\n\n\tget time() {\n\t\treturn this._time;\n\t}\n\n\tset speed(speed) {\n\t\tthis._speed = speed;\n\t}\n\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t}\n\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\n\tset blendWeight(blendWeight) {\n\t\tthis._blendWeight = blendWeight;\n\t}\n\n\tget blendWeight() {\n\t\treturn this._blendWeight;\n\t}\n\n\tset blendOrder(blendOrder) {\n\t\tthis._blendOrder = blendOrder;\n\t}\n\n\tget blendOrder() {\n\t\treturn this._blendOrder;\n\t}\n\n\tset eventCursor(value) {\n\t\tthis._eventCursor = value;\n\t}\n\n\tget eventCursor() {\n\t\treturn this._eventCursor;\n\t}\n\n\tactiveEventsForFrame(frameStartTime, frameEndTime) {\n\t\tif (frameStartTime === 0) {\n\t\t\tthis.eventCursor = 0;\n\t\t}\n\n\t\tlet clippedFrameDuration;\n\n\t\tif (frameEndTime > this.track.duration) {\n\t\t\tclippedFrameDuration = frameEndTime - this.track.duration;\n\t\t\tframeEndTime = this.track.duration;\n\t\t}\n\n\t\twhile (this.track.events[this.eventCursor] && this.track.events[this.eventCursor].time >= frameStartTime && (frameEndTime === this.track.duration ? this.track.events[this.eventCursor].time <= frameEndTime : this.track.events[this.eventCursor].time < frameEndTime)) {\n\t\t\tconst event = this.track.events[this.eventCursor];\n\n\t\t\tthis._eventHandler.fire(event.name, _extends({\n\t\t\t\ttrack: this.track\n\t\t\t}, event));\n\n\t\t\tthis.eventCursor++;\n\t\t}\n\n\t\tif (Number.isFinite(clippedFrameDuration)) {\n\t\t\tthis.activeEventsForFrame(0, clippedFrameDuration);\n\t\t}\n\t}\n\n\t_update(deltaTime) {\n\t\tif (this._playing) {\n\t\t\tlet time = this._time;\n\t\t\tconst duration = this._track.duration;\n\t\t\tconst speed = this._speed;\n\t\t\tconst loop = this._loop;\n\n\t\t\tif (this._track.events.length > 0 && duration > 0) {\n\t\t\t\tthis.activeEventsForFrame(time, time + speed * deltaTime);\n\t\t\t}\n\n\t\t\ttime += speed * deltaTime;\n\n\t\t\tif (speed >= 0) {\n\t\t\t\tif (time > duration) {\n\t\t\t\t\tif (loop) {\n\t\t\t\t\t\ttime = time % duration || 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime = this._track.duration;\n\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (time < 0) {\n\t\t\t\t\tif (loop) {\n\t\t\t\t\t\ttime = duration + (time % duration || 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime = 0;\n\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._time = time;\n\t\t}\n\n\t\tif (this._time !== this._snapshot._time) {\n\t\t\tthis._track.eval(this._time, this._snapshot);\n\t\t}\n\t}\n\n\tplay() {\n\t\tthis._playing = true;\n\t\tthis._time = 0;\n\t}\n\n\tstop() {\n\t\tthis._playing = false;\n\t\tthis._time = 0;\n\t}\n\n\tpause() {\n\t\tthis._playing = false;\n\t}\n\n\tresume() {\n\t\tthis._playing = true;\n\t}\n\n\treset() {\n\t\tthis._time = 0;\n\t}\n\n}\n\nconst ANIM_INTERRUPTION_NONE = 'NONE';\nconst ANIM_INTERRUPTION_PREV = 'PREV_STATE';\nconst ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';\nconst ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';\nconst ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';\nconst ANIM_GREATER_THAN = 'GREATER_THAN';\nconst ANIM_LESS_THAN = 'LESS_THAN';\nconst ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';\nconst ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';\nconst ANIM_EQUAL_TO = 'EQUAL_TO';\nconst ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';\nconst ANIM_PARAMETER_INTEGER = 'INTEGER';\nconst ANIM_PARAMETER_FLOAT = 'FLOAT';\nconst ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';\nconst ANIM_PARAMETER_TRIGGER = 'TRIGGER';\nconst ANIM_BLEND_1D = '1D';\nconst ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';\nconst ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';\nconst ANIM_BLEND_DIRECT = 'DIRECT';\nconst ANIM_STATE_START = 'START';\nconst ANIM_STATE_END = 'END';\nconst ANIM_STATE_ANY = 'ANY';\nconst ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];\nconst ANIM_LAYER_OVERWRITE = 'OVERWRITE';\nconst ANIM_LAYER_ADDITIVE = 'ADDITIVE';\n\nclass AnimTargetValue {\n\tconstructor(component, type) {\n\t\tthis._component = component;\n\t\tthis.mask = new Int8Array(component.layers.length);\n\t\tthis.weights = new Float32Array(component.layers.length);\n\t\tthis.totalWeight = 0;\n\t\tthis.counter = 0;\n\t\tthis.layerCounter = 0;\n\t\tthis.valueType = type;\n\t\tthis.dirty = true;\n\t\tthis.value = [0, 0, 0, 1];\n\t}\n\n\tgetWeight(index) {\n\t\tif (this.dirty) this.updateWeights();\n\n\t\tif (this.totalWeight === 0 || !this.mask[index]) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.weights[index] / this.totalWeight;\n\t}\n\n\tsetMask(index, value) {\n\t\tthis.mask[index] = value;\n\n\t\tif (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {\n\t\t\tthis.mask = this.mask.fill(0, 0, index);\n\t\t}\n\n\t\tthis.dirty = true;\n\t}\n\n\tupdateWeights() {\n\t\tthis.totalWeight = 0;\n\n\t\tfor (let i = 0; i < this.weights.length; i++) {\n\t\t\tthis.weights[i] = this._component.layers[i].weight;\n\t\t\tthis.totalWeight += this.mask[i] * this.weights[i];\n\t\t}\n\n\t\tthis.dirty = false;\n\t}\n\n\tupdateValue(index, value) {\n\t\tif (this.counter === 0) {\n\t\t\tthis.value[0] = 0;\n\t\t\tthis.value[1] = 0;\n\t\t\tthis.value[2] = 0;\n\t\t\tthis.value[3] = 1;\n\t\t}\n\n\t\tif (!this.mask[index]) return;\n\n\t\tif (this.counter === 0) {\n\t\t\tAnimEvaluator._set(this.value, value, this.valueType);\n\t\t} else {\n\t\t\tAnimEvaluator._blend(this.value, value, this.getWeight(index), this.valueType);\n\t\t}\n\t}\n\n}\n\nAnimTargetValue.TYPE_QUAT = 'quaternion';\nAnimTargetValue.TYPE_VEC3 = 'vector3';\n\nclass AnimEvaluator {\n\tconstructor(binder) {\n\t\tthis._binder = binder;\n\t\tthis._clips = [];\n\t\tthis._inputs = [];\n\t\tthis._outputs = [];\n\t\tthis._targets = {};\n\t}\n\n\tget clips() {\n\t\treturn this._clips;\n\t}\n\n\tstatic _dot(a, b) {\n\t\tconst len = a.length;\n\t\tlet result = 0;\n\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\tresult += a[i] * b[i];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstatic _normalize(a) {\n\t\tlet l = AnimEvaluator._dot(a, a);\n\n\t\tif (l > 0) {\n\t\t\tl = 1.0 / Math.sqrt(l);\n\t\t\tconst len = a.length;\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] *= l;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic _set(a, b, type) {\n\t\tconst len = a.length;\n\n\t\tif (type === 'quaternion') {\n\t\t\tlet l = AnimEvaluator._dot(b, b);\n\n\t\t\tif (l > 0) {\n\t\t\t\tl = 1.0 / Math.sqrt(l);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] = b[i] * l;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] = b[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic _blendVec(a, b, t) {\n\t\tconst it = 1.0 - t;\n\t\tconst len = a.length;\n\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\ta[i] = a[i] * it + b[i] * t;\n\t\t}\n\t}\n\n\tstatic _blendQuat(a, b, t) {\n\t\tconst len = a.length;\n\t\tconst it = 1.0 - t;\n\n\t\tif (AnimEvaluator._dot(a, b) < 0) {\n\t\t\tt = -t;\n\t\t}\n\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\ta[i] = a[i] * it + b[i] * t;\n\t\t}\n\n\t\tAnimEvaluator._normalize(a);\n\t}\n\n\tstatic _blend(a, b, t, type) {\n\t\tif (type === 'quaternion') {\n\t\t\tAnimEvaluator._blendQuat(a, b, t);\n\t\t} else {\n\t\t\tAnimEvaluator._blendVec(a, b, t);\n\t\t}\n\t}\n\n\tstatic _stableSort(a, lessFunc) {\n\t\tconst len = a.length;\n\n\t\tfor (let i = 0; i < len - 1; ++i) {\n\t\t\tfor (let j = i + 1; j < len; ++j) {\n\t\t\t\tif (lessFunc(a[j], a[i])) {\n\t\t\t\t\tconst tmp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taddClip(clip) {\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\t\tconst curves = clip.track.curves;\n\t\tconst snapshot = clip.snapshot;\n\t\tconst inputs = [];\n\t\tconst outputs = [];\n\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst paths = curve.paths;\n\n\t\t\tfor (let j = 0; j < paths.length; ++j) {\n\t\t\t\tconst path = paths[j];\n\t\t\t\tconst resolved = binder.resolve(path);\n\t\t\t\tlet target = targets[resolved && resolved.targetPath || null];\n\n\t\t\t\tif (!target && resolved) {\n\t\t\t\t\ttarget = {\n\t\t\t\t\t\ttarget: resolved,\n\t\t\t\t\t\tvalue: [],\n\t\t\t\t\t\tcurves: 0,\n\t\t\t\t\t\tblendCounter: 0\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (let k = 0; k < target.target.components; ++k) {\n\t\t\t\t\t\ttarget.value.push(0);\n\t\t\t\t\t}\n\n\t\t\t\t\ttargets[resolved.targetPath] = target;\n\n\t\t\t\t\tif (binder.animComponent) {\n\t\t\t\t\t\tif (!binder.animComponent.targets[resolved.targetPath]) {\n\t\t\t\t\t\t\tlet type;\n\n\t\t\t\t\t\t\tif (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {\n\t\t\t\t\t\t\t\ttype = AnimTargetValue.TYPE_QUAT;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttype = AnimTargetValue.TYPE_VEC3;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath].layerCounter++;\n\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target) {\n\t\t\t\t\ttarget.curves++;\n\t\t\t\t\tinputs.push(snapshot._results[i]);\n\t\t\t\t\toutputs.push(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._clips.push(clip);\n\n\t\tthis._inputs.push(inputs);\n\n\t\tthis._outputs.push(outputs);\n\t}\n\n\tremoveClip(index) {\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\t\tconst clips = this._clips;\n\t\tconst clip = clips[index];\n\t\tconst curves = clip.track.curves;\n\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst paths = curve.paths;\n\n\t\t\tfor (let j = 0; j < paths.length; ++j) {\n\t\t\t\tconst path = paths[j];\n\n\t\t\t\tconst target = this._binder.resolve(path);\n\n\t\t\t\tif (target) {\n\t\t\t\t\ttarget.curves--;\n\n\t\t\t\t\tif (target.curves === 0) {\n\t\t\t\t\t\tbinder.unresolve(path);\n\t\t\t\t\t\tdelete targets[target.targetPath];\n\n\t\t\t\t\t\tif (binder.animComponent) {\n\t\t\t\t\t\t\tbinder.animComponent.targets[target.targetPath].layerCounter--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclips.splice(index, 1);\n\n\t\tthis._inputs.splice(index, 1);\n\n\t\tthis._outputs.splice(index, 1);\n\t}\n\n\tremoveClips() {\n\t\twhile (this._clips.length > 0) {\n\t\t\tthis.removeClip(0);\n\t\t}\n\t}\n\n\tfindClip(name) {\n\t\tconst clips = this._clips;\n\n\t\tfor (let i = 0; i < clips.length; ++i) {\n\t\t\tconst clip = clips[i];\n\n\t\t\tif (clip.name === name) {\n\t\t\t\treturn clip;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\trebind() {\n\t\tthis._binder.rebind();\n\n\t\tthis._targets = {};\n\t\tconst clips = [...this.clips];\n\t\tthis.removeClips();\n\t\tclips.forEach(clip => {\n\t\t\tthis.addClip(clip);\n\t\t});\n\t}\n\n\tassignMask(mask) {\n\t\treturn this._binder.assignMask(mask);\n\t}\n\n\tupdate(deltaTime) {\n\t\tconst clips = this._clips;\n\t\tconst order = clips.map(function (c, i) {\n\t\t\treturn i;\n\t\t});\n\n\t\tAnimEvaluator._stableSort(order, function (a, b) {\n\t\t\treturn clips[a].blendOrder < clips[b].blendOrder;\n\t\t});\n\n\t\tfor (let i = 0; i < order.length; ++i) {\n\t\t\tconst index = order[i];\n\t\t\tconst clip = clips[index];\n\t\t\tconst inputs = this._inputs[index];\n\t\t\tconst outputs = this._outputs[index];\n\t\t\tconst blendWeight = clip.blendWeight;\n\n\t\t\tif (blendWeight > 0.0) {\n\t\t\t\tclip._update(deltaTime);\n\t\t\t}\n\n\t\t\tlet input;\n\t\t\tlet output;\n\t\t\tlet value;\n\n\t\t\tif (blendWeight >= 1.0) {\n\t\t\t\tfor (let j = 0; j < inputs.length; ++j) {\n\t\t\t\t\tinput = inputs[j];\n\t\t\t\t\toutput = outputs[j];\n\t\t\t\t\tvalue = output.value;\n\n\t\t\t\t\tAnimEvaluator._set(value, input, output.target.type);\n\n\t\t\t\t\toutput.blendCounter++;\n\t\t\t\t}\n\t\t\t} else if (blendWeight > 0.0) {\n\t\t\t\tfor (let j = 0; j < inputs.length; ++j) {\n\t\t\t\t\tinput = inputs[j];\n\t\t\t\t\toutput = outputs[j];\n\t\t\t\t\tvalue = output.value;\n\n\t\t\t\t\tif (output.blendCounter === 0) {\n\t\t\t\t\t\tAnimEvaluator._set(value, input, output.target.type);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAnimEvaluator._blend(value, input, blendWeight, output.target.type);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.blendCounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\n\t\tfor (const path in targets) {\n\t\t\tif (targets.hasOwnProperty(path)) {\n\t\t\t\tconst target = targets[path];\n\n\t\t\t\tif (binder.animComponent && target.target.isTransform) {\n\t\t\t\t\tconst animTarget = binder.animComponent.targets[path];\n\n\t\t\t\t\tif (animTarget.counter === animTarget.layerCounter) {\n\t\t\t\t\t\tanimTarget.counter = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tanimTarget.updateValue(binder.layerIndex, target.value);\n\t\t\t\t\ttarget.target.func(animTarget.value);\n\t\t\t\t\tanimTarget.counter++;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.target.func(target.value);\n\t\t\t\t}\n\n\t\t\t\ttarget.blendCounter = 0;\n\t\t\t}\n\t\t}\n\n\t\tbinder.update(deltaTime);\n\t}\n\n}\n\nclass AnimBinder {\n\tstatic joinPath(pathSegments, character) {\n\t\tcharacter = character || '.';\n\n\t\tconst escape = function escape(string) {\n\t\t\treturn string.replace(/\\\\/g, '\\\\\\\\').replace(new RegExp('\\\\' + character, 'g'), '\\\\' + character);\n\t\t};\n\n\t\treturn pathSegments.map(escape).join(character);\n\t}\n\n\tstatic splitPath(path, character) {\n\t\tcharacter = character || '.';\n\t\tconst result = [];\n\t\tlet curr = \"\";\n\t\tlet i = 0;\n\n\t\twhile (i < path.length) {\n\t\t\tlet c = path[i++];\n\n\t\t\tif (c === '\\\\' && i < path.length) {\n\t\t\t\tc = path[i++];\n\n\t\t\t\tif (c === '\\\\' || c === character) {\n\t\t\t\t\tcurr += c;\n\t\t\t\t} else {\n\t\t\t\t\tcurr += '\\\\' + c;\n\t\t\t\t}\n\t\t\t} else if (c === character) {\n\t\t\t\tresult.push(curr);\n\t\t\t\tcurr = '';\n\t\t\t} else {\n\t\t\t\tcurr += c;\n\t\t\t}\n\t\t}\n\n\t\tif (curr.length > 0) {\n\t\t\tresult.push(curr);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstatic encode(entityPath, component, propertyPath) {\n\t\treturn `${Array.isArray(entityPath) ? entityPath.join('/') : entityPath}/${component}/${Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath}`;\n\t}\n\n\tresolve(path) {\n\t\treturn null;\n\t}\n\n\tunresolve(path) {}\n\n\tupdate(deltaTime) {}\n\n}\n\nclass AnimTarget {\n\tconstructor(func, type, components, targetPath) {\n\t\tthis._func = func;\n\t\tthis._type = type;\n\t\tthis._components = components;\n\t\tthis._targetPath = targetPath;\n\t\tthis._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';\n\t}\n\n\tget func() {\n\t\treturn this._func;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget components() {\n\t\treturn this._components;\n\t}\n\n\tget targetPath() {\n\t\treturn this._targetPath;\n\t}\n\n\tget isTransform() {\n\t\treturn this._isTransform;\n\t}\n\n}\n\nclass DefaultAnimBinder {\n\tconstructor(graph) {\n\t\tthis._isPathInMask = (path, checkMaskValue) => {\n\t\t\tconst maskItem = this._mask[path];\n\t\t\tif (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;\n\t\t\treturn false;\n\t\t};\n\n\t\tthis.graph = graph;\n\t\tif (!graph) return;\n\t\tthis._mask = null;\n\t\tconst nodes = {};\n\n\t\tconst flatten = function flatten(node) {\n\t\t\tnodes[node.name] = node;\n\n\t\t\tfor (let i = 0; i < node.children.length; ++i) {\n\t\t\t\tflatten(node.children[i]);\n\t\t\t}\n\t\t};\n\n\t\tflatten(graph);\n\t\tthis.nodes = nodes;\n\t\tthis.targetCache = {};\n\n\t\tconst findMeshInstances = function findMeshInstances(node) {\n\t\t\tlet object = node;\n\n\t\t\twhile (object && !(object instanceof Entity)) {\n\t\t\t\tobject = object.parent;\n\t\t\t}\n\n\t\t\tlet meshInstances;\n\n\t\t\tif (object) {\n\t\t\t\tif (object.render) {\n\t\t\t\t\tmeshInstances = object.render.meshInstances;\n\t\t\t\t} else if (object.model) {\n\t\t\t\t\tmeshInstances = object.model.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn meshInstances;\n\t\t};\n\n\t\tthis.nodeCounts = {};\n\t\tthis.activeNodes = [];\n\t\tthis.handlers = {\n\t\t\t'localPosition': function (node) {\n\t\t\t\tconst object = node.localPosition;\n\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');\n\t\t\t},\n\t\t\t'localRotation': function (node) {\n\t\t\t\tconst object = node.localRotation;\n\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');\n\t\t\t},\n\t\t\t'localScale': function (node) {\n\t\t\t\tconst object = node.localScale;\n\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');\n\t\t\t},\n\t\t\t'weights': function (node) {\n\t\t\t\tconst meshInstances = findMeshInstances(node);\n\n\t\t\t\tif (meshInstances) {\n\t\t\t\t\tconst morphInstances = [];\n\n\t\t\t\t\tfor (let i = 0; i < meshInstances.length; ++i) {\n\t\t\t\t\t\tif (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {\n\t\t\t\t\t\t\tmorphInstances.push(meshInstances[i].morphInstance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (morphInstances.length > 0) {\n\t\t\t\t\t\tconst func = function func(value) {\n\t\t\t\t\t\t\tfor (let i = 0; i < value.length; ++i) {\n\t\t\t\t\t\t\t\tfor (let j = 0; j < morphInstances.length; j++) {\n\t\t\t\t\t\t\t\t\tmorphInstances[j].setWeight(i, value[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', morphInstances[0].morph._targets.length, node, 'weights');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\t'materialTexture': (node, textureName) => {\n\t\t\t\tconst meshInstances = findMeshInstances(node);\n\n\t\t\t\tif (meshInstances) {\n\t\t\t\t\tlet meshInstance;\n\n\t\t\t\t\tfor (let i = 0; i < meshInstances.length; ++i) {\n\t\t\t\t\t\tif (meshInstances[i].node.name === node.name) {\n\t\t\t\t\t\t\tmeshInstance = meshInstances[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meshInstance) {\n\t\t\t\t\t\tconst func = value => {\n\t\t\t\t\t\t\tconst textureAsset = this.animComponent.system.app.assets.get(value[0]);\n\n\t\t\t\t\t\t\tif (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {\n\t\t\t\t\t\t\t\tmeshInstance.material[textureName] = textureAsset.resource;\n\t\t\t\t\t\t\t\tmeshInstance.material.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\n\t_isPathActive(path) {\n\t\tif (!this._mask) return true;\n\t\tconst rootNodeNames = [path.entityPath[0], this.graph.name];\n\n\t\tfor (let j = 0; j < rootNodeNames.length; ++j) {\n\t\t\tlet currEntityPath = rootNodeNames[j];\n\t\t\tif (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;\n\n\t\t\tfor (let i = 1; i < path.entityPath.length; i++) {\n\t\t\t\tcurrEntityPath += '/' + path.entityPath[i];\n\t\t\t\tif (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfindNode(path) {\n\t\tif (!this._isPathActive(path)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet node;\n\n\t\tif (this.graph) {\n\t\t\tnode = this.graph.findByPath(path.entityPath);\n\t\t}\n\n\t\tif (!node) {\n\t\t\tnode = this.nodes[path.entityPath[path.entityPath.length - 1] || \"\"];\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tstatic createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {\n\t\tconst targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);\n\t\treturn new AnimTarget(func, type, valueCount, targetPath);\n\t}\n\n\tresolve(path) {\n\t\tconst encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);\n\t\tlet target = this.targetCache[encodedPath];\n\t\tif (target) return target;\n\t\tconst node = this.findNode(path);\n\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst handler = this.handlers[path.propertyPath];\n\n\t\tif (!handler) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttarget = handler(node);\n\n\t\tif (!target) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.targetCache[encodedPath] = target;\n\n\t\tif (!this.nodeCounts[node.path]) {\n\t\t\tthis.activeNodes.push(node);\n\t\t\tthis.nodeCounts[node.path] = 1;\n\t\t} else {\n\t\t\tthis.nodeCounts[node.path]++;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tunresolve(path) {\n\t\tif (path.component !== 'graph') return;\n\t\tconst node = this.nodes[path.entityPath[path.entityPath.length - 1] || \"\"];\n\t\tthis.nodeCounts[node.path]--;\n\n\t\tif (this.nodeCounts[node.path] === 0) {\n\t\t\tconst activeNodes = this.activeNodes;\n\t\t\tconst i = activeNodes.indexOf(node.node);\n\t\t\tconst len = activeNodes.length;\n\n\t\t\tif (i < len - 1) {\n\t\t\t\tactiveNodes[i] = activeNodes[len - 1];\n\t\t\t}\n\n\t\t\tactiveNodes.pop();\n\t\t}\n\t}\n\n\tupdate(deltaTime) {\n\t\tconst activeNodes = this.activeNodes;\n\n\t\tfor (let i = 0; i < activeNodes.length; ++i) {\n\t\t\tactiveNodes[i]._dirtifyLocal();\n\t\t}\n\t}\n\n\tassignMask(mask) {\n\t\tif (mask !== this._mask) {\n\t\t\tthis._mask = mask;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nclass InterpolatedKey {\n\tconstructor() {\n\t\tthis._written = false;\n\t\tthis._name = \"\";\n\t\tthis._keyFrames = [];\n\t\tthis._quat = new Quat();\n\t\tthis._pos = new Vec3();\n\t\tthis._scale = new Vec3();\n\t\tthis._targetNode = null;\n\t}\n\n\tgetTarget() {\n\t\treturn this._targetNode;\n\t}\n\n\tsetTarget(node) {\n\t\tthis._targetNode = node;\n\t}\n\n}\n\nclass Skeleton {\n\tconstructor(graph) {\n\t\tthis.looping = true;\n\t\tthis._animation = null;\n\t\tthis._time = 0;\n\t\tthis._interpolatedKeys = [];\n\t\tthis._interpolatedKeyDict = {};\n\t\tthis._currKeyIndices = {};\n\t\tthis.graph = null;\n\n\t\tconst addInterpolatedKeys = node => {\n\t\t\tconst interpKey = new InterpolatedKey();\n\t\t\tinterpKey._name = node.name;\n\n\t\t\tthis._interpolatedKeys.push(interpKey);\n\n\t\t\tthis._interpolatedKeyDict[node.name] = interpKey;\n\t\t\tthis._currKeyIndices[node.name] = 0;\n\n\t\t\tfor (let i = 0; i < node._children.length; i++) addInterpolatedKeys(node._children[i]);\n\t\t};\n\n\t\taddInterpolatedKeys(graph);\n\t}\n\n\tset animation(value) {\n\t\tthis._animation = value;\n\t\tthis.currentTime = 0;\n\t}\n\n\tget animation() {\n\t\treturn this._animation;\n\t}\n\n\tset currentTime(value) {\n\t\tthis._time = value;\n\t\tconst numNodes = this._interpolatedKeys.length;\n\n\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\tconst node = this._interpolatedKeys[i];\n\t\t\tconst nodeName = node._name;\n\t\t\tthis._currKeyIndices[nodeName] = 0;\n\t\t}\n\n\t\tthis.addTime(0);\n\t\tthis.updateGraph();\n\t}\n\n\tget currentTime() {\n\t\treturn this._time;\n\t}\n\n\tget numNodes() {\n\t\treturn this._interpolatedKeys.length;\n\t}\n\n\taddTime(delta) {\n\t\tif (this._animation !== null) {\n\t\t\tconst nodes = this._animation._nodes;\n\t\t\tconst duration = this._animation.duration;\n\n\t\t\tif (this._time === duration && !this.looping) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._time += delta;\n\n\t\t\tif (this._time > duration) {\n\t\t\t\tthis._time = this.looping ? 0.0 : duration;\n\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tconst node = nodes[i];\n\t\t\t\t\tconst nodeName = node._name;\n\t\t\t\t\tthis._currKeyIndices[nodeName] = 0;\n\t\t\t\t}\n\t\t\t} else if (this._time < 0) {\n\t\t\t\tthis._time = this.looping ? duration : 0.0;\n\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tconst node = nodes[i];\n\t\t\t\t\tconst nodeName = node._name;\n\t\t\t\t\tthis._currKeyIndices[nodeName] = node._keys.length - 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst offset = delta >= 0 ? 1 : -1;\n\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tconst node = nodes[i];\n\t\t\t\tconst nodeName = node._name;\n\t\t\t\tconst keys = node._keys;\n\t\t\t\tconst interpKey = this._interpolatedKeyDict[nodeName];\n\n\t\t\t\tif (interpKey === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet foundKey = false;\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tfor (let currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {\n\t\t\t\t\t\tconst k1 = keys[currKeyIndex];\n\t\t\t\t\t\tconst k2 = keys[currKeyIndex + 1];\n\n\t\t\t\t\t\tif (k1.time <= this._time && k2.time >= this._time) {\n\t\t\t\t\t\t\tconst alpha = (this._time - k1.time) / (k2.time - k1.time);\n\n\t\t\t\t\t\t\tinterpKey._pos.lerp(k1.position, k2.position, alpha);\n\n\t\t\t\t\t\t\tinterpKey._quat.slerp(k1.rotation, k2.rotation, alpha);\n\n\t\t\t\t\t\t\tinterpKey._scale.lerp(k1.scale, k2.scale, alpha);\n\n\t\t\t\t\t\t\tinterpKey._written = true;\n\t\t\t\t\t\t\tthis._currKeyIndices[nodeName] = currKeyIndex;\n\t\t\t\t\t\t\tfoundKey = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {\n\t\t\t\t\tinterpKey._pos.copy(keys[0].position);\n\n\t\t\t\t\tinterpKey._quat.copy(keys[0].rotation);\n\n\t\t\t\t\tinterpKey._scale.copy(keys[0].scale);\n\n\t\t\t\t\tinterpKey._written = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblend(skel1, skel2, alpha) {\n\t\tconst numNodes = this._interpolatedKeys.length;\n\n\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\tconst key1 = skel1._interpolatedKeys[i];\n\t\t\tconst key2 = skel2._interpolatedKeys[i];\n\t\t\tconst dstKey = this._interpolatedKeys[i];\n\n\t\t\tif (key1._written && key2._written) {\n\t\t\t\tdstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);\n\n\t\t\t\tdstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);\n\n\t\t\t\tdstKey._scale.lerp(key1._scale, key2._scale, alpha);\n\n\t\t\t\tdstKey._written = true;\n\t\t\t} else if (key1._written) {\n\t\t\t\tdstKey._quat.copy(key1._quat);\n\n\t\t\t\tdstKey._pos.copy(key1._pos);\n\n\t\t\t\tdstKey._scale.copy(key1._scale);\n\n\t\t\t\tdstKey._written = true;\n\t\t\t} else if (key2._written) {\n\t\t\t\tdstKey._quat.copy(key2._quat);\n\n\t\t\t\tdstKey._pos.copy(key2._pos);\n\n\t\t\t\tdstKey._scale.copy(key2._scale);\n\n\t\t\t\tdstKey._written = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetGraph(graph) {\n\t\tthis.graph = graph;\n\n\t\tif (graph) {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tconst interpKey = this._interpolatedKeys[i];\n\t\t\t\tconst graphNode = graph.findByName(interpKey._name);\n\n\t\t\t\tthis._interpolatedKeys[i].setTarget(graphNode);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tthis._interpolatedKeys[i].setTarget(null);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateGraph() {\n\t\tif (this.graph) {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tconst interpKey = this._interpolatedKeys[i];\n\n\t\t\t\tif (interpKey._written) {\n\t\t\t\t\tconst transform = interpKey.getTarget();\n\t\t\t\t\ttransform.localPosition.copy(interpKey._pos);\n\t\t\t\t\ttransform.localRotation.copy(interpKey._quat);\n\t\t\t\t\ttransform.localScale.copy(interpKey._scale);\n\t\t\t\t\tif (!transform._dirtyLocal) transform._dirtifyLocal();\n\t\t\t\t\tinterpKey._written = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimationComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.animationsIndex = {};\n\t\tthis.on('set_animations', this.onSetAnimations, this);\n\t\tthis.on('set_assets', this.onSetAssets, this);\n\t\tthis.on('set_loop', this.onSetLoop, this);\n\t}\n\n\tset currentTime(currentTime) {\n\t\tconst data = this.data;\n\n\t\tif (data.skeleton) {\n\t\t\tconst skeleton = data.skeleton;\n\t\t\tskeleton.currentTime = currentTime;\n\t\t\tskeleton.addTime(0);\n\t\t\tskeleton.updateGraph();\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tconst animEvaluator = data.animEvaluator;\n\n\t\t\tfor (let i = 0; i < animEvaluator.clips.length; ++i) {\n\t\t\t\tanimEvaluator.clips[i].time = currentTime;\n\t\t\t}\n\t\t}\n\t}\n\n\tget currentTime() {\n\t\tconst data = this.data;\n\n\t\tif (data.skeleton) {\n\t\t\treturn this.data.skeleton._time;\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tconst clips = data.animEvaluator.clips;\n\n\t\t\tif (clips.length > 0) {\n\t\t\t\treturn clips[clips.length - 1].time;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tget duration() {\n\t\treturn this.data.animations[this.data.currAnim].duration;\n\t}\n\n\tplay(name, blendTime = 0) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst data = this.data;\n\n\t\tif (!data.animations[name]) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata.prevAnim = data.currAnim;\n\t\tdata.currAnim = name;\n\n\t\tif (data.model) {\n\t\t\tif (!data.skeleton && !data.animEvaluator) {\n\t\t\t\tthis._createAnimationController();\n\t\t\t}\n\n\t\t\tconst prevAnim = data.animations[data.prevAnim];\n\t\t\tconst currAnim = data.animations[data.currAnim];\n\t\t\tdata.blending = blendTime > 0 && data.prevAnim;\n\n\t\t\tif (data.blending) {\n\t\t\t\tdata.blend = 0;\n\t\t\t\tdata.blendSpeed = 1.0 / blendTime;\n\t\t\t}\n\n\t\t\tif (data.skeleton) {\n\t\t\t\tif (data.blending) {\n\t\t\t\t\tdata.fromSkel.animation = prevAnim;\n\t\t\t\t\tdata.fromSkel.addTime(data.skeleton._time);\n\t\t\t\t\tdata.toSkel.animation = currAnim;\n\t\t\t\t} else {\n\t\t\t\t\tdata.skeleton.animation = currAnim;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.animEvaluator) {\n\t\t\t\tconst animEvaluator = data.animEvaluator;\n\n\t\t\t\tif (data.blending) {\n\t\t\t\t\twhile (animEvaluator.clips.length > 1) {\n\t\t\t\t\t\tanimEvaluator.removeClip(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata.animEvaluator.removeClips();\n\t\t\t\t}\n\n\t\t\t\tconst clip = new AnimClip(data.animations[data.currAnim], 0, 1.0, true, data.loop);\n\t\t\t\tclip.name = data.currAnim;\n\t\t\t\tclip.blendWeight = data.blending ? 0 : 1;\n\t\t\t\tclip.reset();\n\t\t\t\tdata.animEvaluator.addClip(clip);\n\t\t\t}\n\t\t}\n\n\t\tdata.playing = true;\n\t}\n\n\tgetAnimation(name) {\n\t\treturn this.data.animations[name];\n\t}\n\n\tsetModel(model) {\n\t\tconst data = this.data;\n\n\t\tif (model !== data.model) {\n\t\t\tthis._resetAnimationController();\n\n\t\t\tdata.model = model;\n\n\t\t\tif (data.animations && data.currAnim && data.animations[data.currAnim]) {\n\t\t\t\tthis.play(data.currAnim);\n\t\t\t}\n\t\t}\n\t}\n\n\t_resetAnimationController() {\n\t\tconst data = this.data;\n\t\tdata.skeleton = null;\n\t\tdata.fromSkel = null;\n\t\tdata.toSkel = null;\n\t\tdata.animEvaluator = null;\n\t}\n\n\t_createAnimationController() {\n\t\tconst data = this.data;\n\t\tconst model = data.model;\n\t\tconst animations = data.animations;\n\t\tlet hasJson = false;\n\t\tlet hasGlb = false;\n\n\t\tfor (const animation in animations) {\n\t\t\tif (animations.hasOwnProperty(animation)) {\n\t\t\t\tconst anim = animations[animation];\n\n\t\t\t\tif (anim.constructor === AnimTrack) {\n\t\t\t\t\thasGlb = true;\n\t\t\t\t} else {\n\t\t\t\t\thasJson = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst graph = model.getGraph();\n\n\t\tif (hasJson) {\n\t\t\tdata.fromSkel = new Skeleton(graph);\n\t\t\tdata.toSkel = new Skeleton(graph);\n\t\t\tdata.skeleton = new Skeleton(graph);\n\t\t\tdata.skeleton.looping = data.loop;\n\t\t\tdata.skeleton.setGraph(graph);\n\t\t} else if (hasGlb) {\n\t\t\tdata.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));\n\t\t}\n\t}\n\n\tloadAnimationAssets(ids) {\n\t\tif (!ids || !ids.length) return;\n\t\tconst assets = this.system.app.assets;\n\n\t\tconst onAssetReady = asset => {\n\t\t\tif (asset.resources.length > 1) {\n\t\t\t\tfor (let i = 0; i < asset.resources.length; i++) {\n\t\t\t\t\tthis.animations[asset.resources[i].name] = asset.resources[i];\n\t\t\t\t\tthis.animationsIndex[asset.id] = asset.resources[i].name;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.animations[asset.name] = asset.resource;\n\t\t\t\tthis.animationsIndex[asset.id] = asset.name;\n\t\t\t}\n\n\t\t\tthis.animations = this.animations;\n\t\t};\n\n\t\tconst onAssetAdd = asset => {\n\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\tasset.on('change', this.onAssetChanged, this);\n\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\n\t\t\tif (asset.resource) {\n\t\t\t\tonAssetReady(asset);\n\t\t\t} else {\n\t\t\t\tasset.once('load', onAssetReady, this);\n\t\t\t\tif (this.enabled && this.entity.enabled) assets.load(asset);\n\t\t\t}\n\t\t};\n\n\t\tfor (let i = 0, l = ids.length; i < l; i++) {\n\t\t\tconst asset = assets.get(ids[i]);\n\n\t\t\tif (asset) {\n\t\t\t\tonAssetAdd(asset);\n\t\t\t} else {\n\t\t\t\tassets.on('add:' + ids[i], onAssetAdd);\n\t\t\t}\n\t\t}\n\t}\n\n\tonAssetChanged(asset, attribute, newValue, oldValue) {\n\t\tif (attribute === 'resource' || attribute === 'resources') {\n\t\t\tif (attribute === 'resources' && newValue && newValue.length === 0) {\n\t\t\t\tnewValue = null;\n\t\t\t}\n\n\t\t\tif (newValue) {\n\t\t\t\tlet restarted = false;\n\n\t\t\t\tif (newValue.length > 1) {\n\t\t\t\t\tif (oldValue && oldValue.length > 1) {\n\t\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this.animations[asset.name];\n\t\t\t\t\t}\n\n\t\t\t\t\trestarted = false;\n\n\t\t\t\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\t\t\t\tthis.animations[newValue[i].name] = newValue[i];\n\n\t\t\t\t\t\tif (!restarted && this.data.currAnim === newValue[i].name) {\n\t\t\t\t\t\t\tif (this.data.playing && this.data.enabled && this.entity.enabled) {\n\t\t\t\t\t\t\t\trestarted = true;\n\t\t\t\t\t\t\t\tthis.play(newValue[i].name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!restarted) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\n\t\t\t\t\t\tthis.onSetAnimations();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (oldValue && oldValue.length > 1) {\n\t\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.animations[asset.name] = newValue[0] || newValue;\n\t\t\t\t\trestarted = false;\n\n\t\t\t\t\tif (this.data.currAnim === asset.name) {\n\t\t\t\t\t\tif (this.data.playing && this.data.enabled && this.entity.enabled) {\n\t\t\t\t\t\t\trestarted = true;\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!restarted) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\n\t\t\t\t\t\tthis.onSetAnimations();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.animationsIndex[asset.id] = asset.name;\n\t\t\t} else {\n\t\t\t\tif (oldValue.length > 1) {\n\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\n\t\t\t\t\t\tif (this.data.currAnim === oldValue[i].name) {\n\t\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.animations[asset.name];\n\n\t\t\t\t\tif (this.data.currAnim === asset.name) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdelete this.animationsIndex[asset.id];\n\t\t\t}\n\t\t}\n\t}\n\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\n\t\tif (this.animations) {\n\t\t\tif (asset.resources.length > 1) {\n\t\t\t\tfor (let i = 0; i < asset.resources.length; i++) {\n\t\t\t\t\tdelete this.animations[asset.resources[i].name];\n\t\t\t\t\tif (this.data.currAnim === asset.resources[i].name) this._stopCurrentAnimation();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete this.animations[asset.name];\n\t\t\t\tif (this.data.currAnim === asset.name) this._stopCurrentAnimation();\n\t\t\t}\n\n\t\t\tdelete this.animationsIndex[asset.id];\n\t\t}\n\t}\n\n\t_stopCurrentAnimation() {\n\t\tconst data = this.data;\n\t\tdata.currAnim = null;\n\t\tdata.playing = false;\n\n\t\tif (data.skeleton) {\n\t\t\tdata.skeleton.currentTime = 0;\n\t\t\tdata.skeleton.animation = null;\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tfor (let i = 0; i < data.animEvaluator.clips.length; ++i) {\n\t\t\t\tdata.animEvaluator.clips[i].stop();\n\t\t\t}\n\n\t\t\tdata.animEvaluator.update(0);\n\t\t\tdata.animEvaluator.removeClips();\n\t\t}\n\t}\n\n\tonSetAnimations(name, oldValue, newValue) {\n\t\tconst data = this.data;\n\t\tconst modelComponent = this.entity.model;\n\n\t\tif (modelComponent) {\n\t\t\tconst m = modelComponent.model;\n\n\t\t\tif (m && m !== data.model) {\n\t\t\t\tthis.setModel(m);\n\t\t\t}\n\t\t}\n\n\t\tif (!data.currAnim && data.activate && data.enabled && this.entity.enabled) {\n\t\t\tconst animationNames = Object.keys(data.animations);\n\n\t\t\tif (animationNames.length > 0) {\n\t\t\t\tthis.play(animationNames[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetAssets(name, oldValue, newValue) {\n\t\tif (oldValue && oldValue.length) {\n\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\tif (oldValue[i]) {\n\t\t\t\t\tconst asset = this.system.app.assets.get(oldValue[i]);\n\n\t\t\t\t\tif (asset) {\n\t\t\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\t\t\tconst animName = this.animationsIndex[asset.id];\n\t\t\t\t\t\tif (this.data.currAnim === animName) this._stopCurrentAnimation();\n\t\t\t\t\t\tdelete this.animations[animName];\n\t\t\t\t\t\tdelete this.animationsIndex[asset.id];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst ids = newValue.map(value => {\n\t\t\treturn value instanceof Asset ? value.id : value;\n\t\t});\n\t\tthis.loadAnimationAssets(ids);\n\t}\n\n\tonSetLoop(name, oldValue, newValue) {\n\t\tconst data = this.data;\n\n\t\tif (data.skeleton) {\n\t\t\tdata.skeleton.looping = data.loop;\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tfor (let i = 0; i < data.animEvaluator.clips.length; ++i) {\n\t\t\t\tdata.animEvaluator.clips[i].loop = data.loop;\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetCurrentTime(name, oldValue, newValue) {\n\t\tconst data = this.data;\n\n\t\tif (data.skeleton) {\n\t\t\tconst skeleton = data.skeleton;\n\t\t\tskeleton.currentTime = newValue;\n\t\t\tskeleton.addTime(0);\n\t\t\tskeleton.updateGraph();\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tconst animEvaluator = data.animEvaluator;\n\n\t\t\tfor (let i = 0; i < animEvaluator.clips.length; ++i) {\n\t\t\t\tanimEvaluator.clips[i].time = newValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tsuper.onEnable();\n\t\tconst data = this.data;\n\t\tconst assets = data.assets;\n\t\tconst registry = this.system.app.assets;\n\n\t\tif (assets) {\n\t\t\tfor (let i = 0, len = assets.length; i < len; i++) {\n\t\t\t\tlet asset = assets[i];\n\t\t\t\tif (!(asset instanceof Asset)) asset = registry.get(asset);\n\t\t\t\tif (asset && !asset.resource) registry.load(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (data.activate && !data.currAnim) {\n\t\t\tconst animationNames = Object.keys(data.animations);\n\n\t\t\tif (animationNames.length > 0) {\n\t\t\t\tthis.play(animationNames[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeRemove() {\n\t\tfor (let i = 0; i < this.assets.length; i++) {\n\t\t\tlet asset = this.assets[i];\n\n\t\t\tif (typeof asset === 'number') {\n\t\t\t\tasset = this.system.app.assets.get(asset);\n\t\t\t}\n\n\t\t\tif (!asset) continue;\n\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t}\n\n\t\tconst data = this.data;\n\t\tdelete data.animation;\n\t\tdelete data.skeleton;\n\t\tdelete data.fromSkel;\n\t\tdelete data.toSkel;\n\t\tdelete data.animEvaluator;\n\t}\n\n}\n\nclass AnimationComponentData {\n\tconstructor() {\n\t\tthis.assets = [];\n\t\tthis.speed = 1.0;\n\t\tthis.loop = true;\n\t\tthis.activate = true;\n\t\tthis.enabled = true;\n\t\tthis.animations = {};\n\t\tthis.model = null;\n\t\tthis.prevAnim = null;\n\t\tthis.currAnim = null;\n\t\tthis.blending = false;\n\t\tthis.blend = 0;\n\t\tthis.blendSpeed = 0;\n\t\tthis.playing = false;\n\t\tthis.skeleton = null;\n\t\tthis.fromSkel = null;\n\t\tthis.toSkel = null;\n\t\tthis.animEvaluator = null;\n\t}\n\n}\n\nconst _schema$l = ['enabled', 'assets', 'speed', 'loop', 'activate', 'animations', 'skeleton', 'model', 'prevAnim', 'currAnim', 'fromSkel', 'toSkel', 'blending', 'blendTimeRemaining', 'playing'];\n\nclass AnimationComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'animation';\n\t\tthis.ComponentType = AnimationComponent;\n\t\tthis.DataType = AnimationComponentData;\n\t\tthis.schema = _schema$l;\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['activate', 'enabled', 'loop', 'speed', 'assets'];\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tthis.addComponent(clone, {});\n\t\tclone.animation.assets = entity.animation.assets.slice();\n\t\tclone.animation.data.speed = entity.animation.speed;\n\t\tclone.animation.data.loop = entity.animation.loop;\n\t\tclone.animation.data.activate = entity.animation.activate;\n\t\tclone.animation.data.enabled = entity.animation.enabled;\n\t\tconst clonedAnimations = {};\n\t\tconst animations = entity.animation.animations;\n\n\t\tfor (const key in animations) {\n\t\t\tif (animations.hasOwnProperty(key)) {\n\t\t\t\tclonedAnimations[key] = animations[key];\n\t\t\t}\n\t\t}\n\n\t\tclone.animation.animations = clonedAnimations;\n\t\tconst clonedAnimationsIndex = {};\n\t\tconst animationsIndex = entity.animation.animationsIndex;\n\n\t\tfor (const key in animationsIndex) {\n\t\t\tif (animationsIndex.hasOwnProperty(key)) {\n\t\t\t\tclonedAnimationsIndex[key] = animationsIndex[key];\n\t\t\t}\n\t\t}\n\n\t\tclone.animation.animationsIndex = clonedAnimationsIndex;\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tconst componentData = component.data;\n\n\t\t\t\tif (componentData.enabled && component.entity.enabled) {\n\t\t\t\t\tif (componentData.blending) {\n\t\t\t\t\t\tcomponentData.blend += dt * componentData.blendSpeed;\n\n\t\t\t\t\t\tif (componentData.blend >= 1.0) {\n\t\t\t\t\t\t\tcomponentData.blend = 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (componentData.playing) {\n\t\t\t\t\t\tconst skeleton = componentData.skeleton;\n\n\t\t\t\t\t\tif (skeleton !== null && componentData.model !== null) {\n\t\t\t\t\t\t\tif (componentData.blending) {\n\t\t\t\t\t\t\t\tskeleton.blend(componentData.fromSkel, componentData.toSkel, componentData.blend);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst delta = dt * componentData.speed;\n\t\t\t\t\t\t\t\tskeleton.addTime(delta);\n\n\t\t\t\t\t\t\t\tif (componentData.speed > 0 && skeleton._time === skeleton._animation.duration && !componentData.loop) {\n\t\t\t\t\t\t\t\t\tcomponentData.playing = false;\n\t\t\t\t\t\t\t\t} else if (componentData.speed < 0 && skeleton._time === 0 && !componentData.loop) {\n\t\t\t\t\t\t\t\t\tcomponentData.playing = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (componentData.blending && componentData.blend === 1.0) {\n\t\t\t\t\t\t\t\tskeleton.animation = componentData.toSkel._animation;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tskeleton.updateGraph();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst animEvaluator = componentData.animEvaluator;\n\n\t\t\t\t\tif (animEvaluator) {\n\t\t\t\t\t\tfor (let i = 0; i < animEvaluator.clips.length; ++i) {\n\t\t\t\t\t\t\tconst clip = animEvaluator.clips[i];\n\t\t\t\t\t\t\tclip.speed = componentData.speed;\n\n\t\t\t\t\t\t\tif (!componentData.playing) {\n\t\t\t\t\t\t\t\tclip.pause();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclip.resume();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (componentData.blending && animEvaluator.clips.length > 1) {\n\t\t\t\t\t\t\tanimEvaluator.clips[1].blendWeight = componentData.blend;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tanimEvaluator.update(dt);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (componentData.blending && componentData.blend === 1.0) {\n\t\t\t\t\t\tcomponentData.blending = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(AnimationComponent.prototype, _schema$l);\n\nclass AnimNode {\n\tconstructor(state, parent, name, point, speed = 1) {\n\t\tthis._state = state;\n\t\tthis._parent = parent;\n\t\tthis._name = name;\n\n\t\tif (Array.isArray(point)) {\n\t\t\tthis._point = new Vec2(point[0], point[1]);\n\t\t\tthis._pointLength = this._point.length();\n\t\t} else {\n\t\t\tthis._point = point;\n\t\t\tthis._pointLength = point;\n\t\t}\n\n\t\tthis._speed = speed;\n\t\tthis._weightedSpeed = 1.0;\n\t\tthis._weight = 1.0;\n\t\tthis._animTrack = null;\n\t}\n\n\tget parent() {\n\t\treturn this._parent;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tget path() {\n\t\treturn this._parent ? this._parent.path + '.' + this._name : this._name;\n\t}\n\n\tget point() {\n\t\treturn this._point;\n\t}\n\n\tget pointLength() {\n\t\treturn this._pointLength;\n\t}\n\n\tset weight(value) {\n\t\tthis._weight = value;\n\t}\n\n\tget weight() {\n\t\treturn this._parent ? this._parent.weight * this._weight : this._weight;\n\t}\n\n\tget normalizedWeight() {\n\t\tconst totalWeight = this._state.totalWeight;\n\t\tif (totalWeight === 0.0) return 0.0;\n\t\treturn this.weight / totalWeight;\n\t}\n\n\tget speed() {\n\t\treturn this._weightedSpeed * this._speed;\n\t}\n\n\tget absoluteSpeed() {\n\t\treturn Math.abs(this._speed);\n\t}\n\n\tset weightedSpeed(weightedSpeed) {\n\t\tthis._weightedSpeed = weightedSpeed;\n\t}\n\n\tget weightedSpeed() {\n\t\treturn this._weightedSpeed;\n\t}\n\n\tset animTrack(value) {\n\t\tthis._animTrack = value;\n\t}\n\n\tget animTrack() {\n\t\treturn this._animTrack;\n\t}\n\n}\n\nclass AnimBlendTree extends AnimNode {\n\tconstructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tsuper(state, parent, name, point);\n\t\tthis._parameters = parameters;\n\t\tthis._parameterValues = new Array(parameters.length);\n\t\tthis._children = [];\n\t\tthis._findParameter = findParameter;\n\t\tthis._syncAnimations = syncAnimations !== false;\n\t\tthis._pointCache = {};\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst child = children[i];\n\n\t\t\tif (child.children) {\n\t\t\t\tthis._children.push(createTree(child.type, this, null, name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, createTree, findParameter));\n\t\t\t} else {\n\t\t\t\tthis._children.push(new AnimNode(state, this, child.name, child.point, child.speed));\n\t\t\t}\n\t\t}\n\t}\n\n\tget weight() {\n\t\tthis.calculateWeights();\n\t\treturn this._parent ? this._parent.weight * this._weight : this._weight;\n\t}\n\n\tget syncAnimations() {\n\t\treturn this._syncAnimations;\n\t}\n\n\tgetChild(name) {\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tif (this._children[i].name === name) return this._children[i];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tupdateParameterValues() {\n\t\tlet paramsEqual = true;\n\n\t\tfor (let i = 0; i < this._parameterValues.length; i++) {\n\t\t\tconst updatedParameter = this._findParameter(this._parameters[i]).value;\n\n\t\t\tif (this._parameterValues[i] !== updatedParameter) {\n\t\t\t\tthis._parameterValues[i] = updatedParameter;\n\t\t\t\tparamsEqual = false;\n\t\t\t}\n\t\t}\n\n\t\treturn paramsEqual;\n\t}\n\n\tgetNodeWeightedDuration(i) {\n\t\treturn this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;\n\t}\n\n\tgetNodeCount() {\n\t\tlet count = 0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\n\t\t\tif (child.constructor === AnimBlendTree) {\n\t\t\t\tcount += this._children[i].getNodeCount();\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n}\n\nclass AnimBlendTree1D extends AnimBlendTree {\n\tconstructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tchildren.sort((a, b) => a.point - b.point);\n\t\tsuper(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t}\n\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightedDurationSum = 0.0;\n\t\tthis._children[0].weight = 0.0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst c1 = this._children[i];\n\n\t\t\tif (i !== this._children.length - 1) {\n\t\t\t\tconst c2 = this._children[i + 1];\n\n\t\t\t\tif (c1.point === c2.point) {\n\t\t\t\t\tc1.weight = 0.5;\n\t\t\t\t\tc2.weight = 0.5;\n\t\t\t\t} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {\n\t\t\t\t\tconst child2Distance = Math.abs(c1.point - c2.point);\n\t\t\t\t\tconst parameterDistance = Math.abs(c1.point - this._parameterValues[0]);\n\t\t\t\t\tconst weight = (child2Distance - parameterDistance) / child2Distance;\n\t\t\t\t\tc1.weight = weight;\n\t\t\t\t\tc2.weight = 1.0 - weight;\n\t\t\t\t} else {\n\t\t\t\t\tc2.weight = 0.0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;\n\t\t\t}\n\t\t}\n\n\t\tif (this._syncAnimations) {\n\t\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\t\tconst child = this._children[i];\n\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimBlendTreeCartesian2D extends AnimBlendTree {\n\tpointDistanceCache(i, j) {\n\t\tconst pointKey = `${i}${j}`;\n\n\t\tif (!this._pointCache[pointKey]) {\n\t\t\tthis._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);\n\t\t}\n\n\t\treturn this._pointCache[pointKey];\n\t}\n\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum, weightedDurationSum;\n\n\t\tAnimBlendTreeCartesian2D._p.set(...this._parameterValues);\n\n\t\tweightSum = 0.0;\n\t\tweightedDurationSum = 0.0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tconst pi = child.point;\n\n\t\t\tAnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);\n\n\t\t\tlet minj = Number.MAX_VALUE;\n\n\t\t\tfor (let j = 0; j < this._children.length; j++) {\n\t\t\t\tif (i === j) continue;\n\t\t\t\tconst pipj = this.pointDistanceCache(i, j);\n\t\t\t\tconst result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);\n\t\t\t\tif (result < minj) minj = result;\n\t\t\t}\n\n\t\t\tchild.weight = minj;\n\t\t\tweightSum += minj;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tchild.weight = child._weight / weightSum;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nAnimBlendTreeCartesian2D._p = new Vec2();\nAnimBlendTreeCartesian2D._pip = new Vec2();\n\nclass AnimBlendTreeDirectional2D extends AnimBlendTree {\n\tpointCache(i, j) {\n\t\tconst pointKey = `${i}${j}`;\n\n\t\tif (!this._pointCache[pointKey]) {\n\t\t\tthis._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);\n\t\t}\n\n\t\treturn this._pointCache[pointKey];\n\t}\n\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum, weightedDurationSum;\n\n\t\tAnimBlendTreeDirectional2D._p.set(...this._parameterValues);\n\n\t\tconst pLength = AnimBlendTreeDirectional2D._p.length();\n\n\t\tweightSum = 0.0;\n\t\tweightedDurationSum = 0.0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tconst pi = child.point;\n\t\t\tconst piLength = child.pointLength;\n\t\t\tlet minj = Number.MAX_VALUE;\n\n\t\t\tfor (let j = 0; j < this._children.length; j++) {\n\t\t\t\tif (i === j) continue;\n\t\t\t\tconst pipj = this.pointCache(i, j);\n\t\t\t\tconst pjLength = this._children[j].pointLength;\n\n\t\t\t\tAnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);\n\n\t\t\t\tconst result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);\n\t\t\t\tif (result < minj) minj = result;\n\t\t\t}\n\n\t\t\tchild.weight = minj;\n\t\t\tweightSum += minj;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tchild.weight = child._weight / weightSum;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tconst weightedChildDuration = child.animTrack.duration / weightedDurationSum * weightSum;\n\t\t\t\tchild.weightedSpeed = child.absoluteSpeed * weightedChildDuration;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nAnimBlendTreeDirectional2D._p = new Vec2();\nAnimBlendTreeDirectional2D._pip = new Vec2();\n\nclass AnimBlendTreeDirect extends AnimBlendTree {\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum = 0.0;\n\t\tlet weightedDurationSum = 0.0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tweightSum += Math.max(this._parameterValues[i], 0.0);\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tconst child = this._children[i];\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tchild.weight = Math.max(this._parameterValues[i], 0.0) / weightSum;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimState {\n\tconstructor(controller, name, speed, loop, blendTree) {\n\t\tthis._controller = controller;\n\t\tthis._name = name;\n\t\tthis._animations = {};\n\t\tthis._animationList = [];\n\t\tthis._speed = speed || 1.0;\n\t\tthis._loop = loop === undefined ? true : loop;\n\n\t\tconst findParameter = this._controller.findParameter.bind(this._controller);\n\n\t\tif (blendTree) {\n\t\t\tthis._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, findParameter);\n\t\t} else {\n\t\t\tthis._blendTree = new AnimNode(this, null, name, 1.0, speed);\n\t\t}\n\t}\n\n\t_createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tswitch (type) {\n\t\t\tcase ANIM_BLEND_1D:\n\t\t\t\treturn new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\n\t\t\tcase ANIM_BLEND_2D_CARTESIAN:\n\t\t\t\treturn new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\n\t\t\tcase ANIM_BLEND_2D_DIRECTIONAL:\n\t\t\t\treturn new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\n\t\t\tcase ANIM_BLEND_DIRECT:\n\t\t\t\treturn new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t\t}\n\t}\n\n\t_getNodeFromPath(path) {\n\t\tlet currNode = this._blendTree;\n\n\t\tfor (let i = 1; i < path.length; i++) {\n\t\t\tcurrNode = currNode.getChild(path[i]);\n\t\t}\n\n\t\treturn currNode;\n\t}\n\n\taddAnimation(path, animTrack) {\n\t\tconst pathString = path.join('.');\n\n\t\tconst indexOfAnimation = this._animationList.findIndex(function (animation) {\n\t\t\treturn animation.path === pathString;\n\t\t});\n\n\t\tif (indexOfAnimation >= 0) {\n\t\t\tthis._animationList[indexOfAnimation].animTrack = animTrack;\n\t\t} else {\n\t\t\tconst node = this._getNodeFromPath(path);\n\n\t\t\tnode.animTrack = animTrack;\n\n\t\t\tthis._animationList.push(node);\n\t\t}\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tset animations(value) {\n\t\tthis._animationList = value;\n\t}\n\n\tget animations() {\n\t\treturn this._animationList;\n\t}\n\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\n\tset loop(value) {\n\t\tthis._loop = value;\n\t}\n\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\n\tget nodeCount() {\n\t\tif (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;\n\t\treturn this._blendTree.getNodeCount();\n\t}\n\n\tget playable() {\n\t\treturn ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;\n\t}\n\n\tget looping() {\n\t\tif (this.animations.length > 0) {\n\t\t\tconst trackClipName = this.name + '.' + this.animations[0].animTrack.name;\n\n\t\t\tconst trackClip = this._controller.animEvaluator.findClip(trackClipName);\n\n\t\t\tif (trackClip) {\n\t\t\t\treturn trackClip.loop;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget totalWeight() {\n\t\tlet sum = 0;\n\n\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\tsum += this.animations[i].weight;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\tget timelineDuration() {\n\t\tlet duration = 0;\n\n\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\tconst animation = this.animations[i];\n\n\t\t\tif (animation.animTrack.duration > duration) {\n\t\t\t\tduration = animation.animTrack.duration;\n\t\t\t}\n\t\t}\n\n\t\treturn duration;\n\t}\n\n}\n\nclass AnimTransition {\n\tconstructor({\n\t\tfrom,\n\t\tto,\n\t\ttime = 0,\n\t\tpriority = 0,\n\t\tconditions = [],\n\t\texitTime = null,\n\t\ttransitionOffset = null,\n\t\tinterruptionSource = ANIM_INTERRUPTION_NONE\n\t}) {\n\t\tthis._from = from;\n\t\tthis._to = to;\n\t\tthis._time = time;\n\t\tthis._priority = priority;\n\t\tthis._conditions = conditions;\n\t\tthis._exitTime = exitTime;\n\t\tthis._transitionOffset = transitionOffset;\n\t\tthis._interruptionSource = interruptionSource;\n\t}\n\n\tget from() {\n\t\treturn this._from;\n\t}\n\n\tset to(value) {\n\t\tthis._to = value;\n\t}\n\n\tget to() {\n\t\treturn this._to;\n\t}\n\n\tget time() {\n\t\treturn this._time;\n\t}\n\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\n\tget conditions() {\n\t\treturn this._conditions;\n\t}\n\n\tget exitTime() {\n\t\treturn this._exitTime;\n\t}\n\n\tget transitionOffset() {\n\t\treturn this._transitionOffset;\n\t}\n\n\tget interruptionSource() {\n\t\treturn this._interruptionSource;\n\t}\n\n\tget hasExitTime() {\n\t\treturn !!this.exitTime;\n\t}\n\n}\n\nclass AnimController {\n\tconstructor(animEvaluator, states, transitions, parameters, activate, eventHandler, consumedTriggers) {\n\t\tthis._animEvaluator = animEvaluator;\n\t\tthis._states = {};\n\t\tthis._stateNames = [];\n\t\tthis._eventHandler = eventHandler;\n\t\tthis._consumedTriggers = consumedTriggers;\n\n\t\tfor (let i = 0; i < states.length; i++) {\n\t\t\tthis._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);\n\n\t\t\tthis._stateNames.push(states[i].name);\n\t\t}\n\n\t\tthis._transitions = transitions.map(transition => {\n\t\t\treturn new AnimTransition(_extends({}, transition));\n\t\t});\n\t\tthis._findTransitionsFromStateCache = {};\n\t\tthis._findTransitionsBetweenStatesCache = {};\n\t\tthis._parameters = parameters;\n\t\tthis._previousStateName = null;\n\t\tthis._activeStateName = ANIM_STATE_START;\n\t\tthis._playing = false;\n\t\tthis._activate = activate;\n\t\tthis._currTransitionTime = 1.0;\n\t\tthis._totalTransitionTime = 1.0;\n\t\tthis._isTransitioning = false;\n\t\tthis._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;\n\t\tthis._transitionPreviousStates = [];\n\t\tthis._timeInState = 0;\n\t\tthis._timeInStateBefore = 0;\n\t}\n\n\tget animEvaluator() {\n\t\treturn this._animEvaluator;\n\t}\n\n\tset activeState(stateName) {\n\t\tthis._activeStateName = stateName;\n\t}\n\n\tget activeState() {\n\t\treturn this._findState(this._activeStateName);\n\t}\n\n\tget activeStateName() {\n\t\treturn this._activeStateName;\n\t}\n\n\tget activeStateAnimations() {\n\t\treturn this.activeState.animations;\n\t}\n\n\tset previousState(stateName) {\n\t\tthis._previousStateName = stateName;\n\t}\n\n\tget previousState() {\n\t\treturn this._findState(this._previousStateName);\n\t}\n\n\tget previousStateName() {\n\t\treturn this._previousStateName;\n\t}\n\n\tget playable() {\n\t\tlet playable = true;\n\n\t\tfor (let i = 0; i < this._stateNames.length; i++) {\n\t\t\tif (!this._states[this._stateNames[i]].playable) {\n\t\t\t\tplayable = false;\n\t\t\t}\n\t\t}\n\n\t\treturn playable;\n\t}\n\n\tset playing(value) {\n\t\tthis._playing = value;\n\t}\n\n\tget playing() {\n\t\treturn this._playing;\n\t}\n\n\tget activeStateProgress() {\n\t\treturn this._getActiveStateProgressForTime(this._timeInState);\n\t}\n\n\tget activeStateDuration() {\n\t\tif (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END) return 0.0;\n\t\tlet maxDuration = 0.0;\n\n\t\tfor (let i = 0; i < this.activeStateAnimations.length; i++) {\n\t\t\tconst activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);\n\n\t\t\tif (activeClip) {\n\t\t\t\tmaxDuration = Math.max(maxDuration, activeClip.track.duration);\n\t\t\t}\n\t\t}\n\n\t\treturn maxDuration;\n\t}\n\n\tset activeStateCurrentTime(time) {\n\t\tthis._timeInStateBefore = time;\n\t\tthis._timeInState = time;\n\n\t\tfor (let i = 0; i < this.activeStateAnimations.length; i++) {\n\t\t\tconst clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);\n\n\t\t\tif (clip) {\n\t\t\t\tclip.time = time;\n\t\t\t}\n\t\t}\n\t}\n\n\tget activeStateCurrentTime() {\n\t\treturn this._timeInState;\n\t}\n\n\tget transitioning() {\n\t\treturn this._isTransitioning;\n\t}\n\n\tget transitionProgress() {\n\t\treturn this._currTransitionTime / this._totalTransitionTime;\n\t}\n\n\tget states() {\n\t\treturn this._stateNames;\n\t}\n\n\tassignMask(mask) {\n\t\treturn this._animEvaluator.assignMask(mask);\n\t}\n\n\t_findState(stateName) {\n\t\treturn this._states[stateName];\n\t}\n\n\t_getActiveStateProgressForTime(time) {\n\t\tif (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) return 1.0;\n\n\t\tconst activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);\n\n\t\tif (activeClip) {\n\t\t\treturn time / activeClip.track.duration;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_findTransitionsFromState(stateName) {\n\t\tlet transitions = this._findTransitionsFromStateCache[stateName];\n\n\t\tif (!transitions) {\n\t\t\ttransitions = this._transitions.filter(function (transition) {\n\t\t\t\treturn transition.from === stateName;\n\t\t\t});\n\t\t\ttransitions.sort(function (a, b) {\n\t\t\t\treturn a.priority < b.priority;\n\t\t\t});\n\t\t\tthis._findTransitionsFromStateCache[stateName] = transitions;\n\t\t}\n\n\t\treturn transitions;\n\t}\n\n\t_findTransitionsBetweenStates(sourceStateName, destinationStateName) {\n\t\tlet transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];\n\n\t\tif (!transitions) {\n\t\t\ttransitions = this._transitions.filter(function (transition) {\n\t\t\t\treturn transition.from === sourceStateName && transition.to === destinationStateName;\n\t\t\t});\n\t\t\ttransitions.sort(function (a, b) {\n\t\t\t\treturn a.priority < b.priority;\n\t\t\t});\n\t\t\tthis._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;\n\t\t}\n\n\t\treturn transitions;\n\t}\n\n\t_transitionHasConditionsMet(transition) {\n\t\tconst conditions = transition.conditions;\n\n\t\tfor (let i = 0; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\t\t\tconst parameter = this.findParameter(condition.parameterName);\n\n\t\t\tswitch (condition.predicate) {\n\t\t\t\tcase ANIM_GREATER_THAN:\n\t\t\t\t\tif (!(parameter.value > condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_LESS_THAN:\n\t\t\t\t\tif (!(parameter.value < condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_GREATER_THAN_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value >= condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_LESS_THAN_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value <= condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value === condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_NOT_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value !== condition.value)) return false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t_findTransition(from, to) {\n\t\tlet transitions = [];\n\n\t\tif (from && to) {\n\t\t\ttransitions = transitions.concat(this._findTransitionsBetweenStates(from, to));\n\t\t} else {\n\t\t\tif (!this._isTransitioning) {\n\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t} else {\n\t\t\t\tswitch (this._transitionInterruptionSource) {\n\t\t\t\t\tcase ANIM_INTERRUPTION_PREV:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ANIM_INTERRUPTION_NEXT:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ANIM_INTERRUPTION_PREV_NEXT:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ANIM_INTERRUPTION_NEXT_PREV:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttransitions = transitions.filter(transition => {\n\t\t\tif (transition.to === this.activeStateName) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (transition.hasExitTime) {\n\t\t\t\tlet progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);\n\n\t\t\t\tlet progress = this._getActiveStateProgressForTime(this._timeInState);\n\n\t\t\t\tif (transition.exitTime < 1.0 && this.activeState.loop) {\n\t\t\t\t\tprogressBefore -= Math.floor(progressBefore);\n\t\t\t\t\tprogress -= Math.floor(progress);\n\t\t\t\t}\n\n\t\t\t\tif (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this._transitionHasConditionsMet(transition);\n\t\t});\n\n\t\tif (transitions.length > 0) {\n\t\t\tconst transition = transitions[0];\n\n\t\t\tif (transition.to === ANIM_STATE_END) {\n\t\t\t\tconst startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];\n\n\t\t\t\ttransition.to = startTransition.to;\n\t\t\t}\n\n\t\t\treturn transition;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tupdateStateFromTransition(transition) {\n\t\tlet state;\n\t\tlet animation;\n\t\tlet clip;\n\t\tthis.previousState = transition.from ? this.activeStateName : null;\n\t\tthis.activeState = transition.to;\n\n\t\tfor (let i = 0; i < transition.conditions.length; i++) {\n\t\t\tconst condition = transition.conditions[i];\n\t\t\tconst parameter = this.findParameter(condition.parameterName);\n\n\t\t\tif (parameter.type === ANIM_PARAMETER_TRIGGER) {\n\t\t\t\tthis._consumedTriggers.add(condition.parameterName);\n\t\t\t}\n\t\t}\n\n\t\tif (this.previousState) {\n\t\t\tif (!this._isTransitioning) {\n\t\t\t\tthis._transitionPreviousStates = [];\n\t\t\t}\n\n\t\t\tthis._transitionPreviousStates.push({\n\t\t\t\tname: this._previousStateName,\n\t\t\t\tweight: 1\n\t\t\t});\n\n\t\t\tconst interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);\n\n\t\t\tfor (let i = 0; i < this._transitionPreviousStates.length; i++) {\n\t\t\t\tif (!this._isTransitioning) {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight = 1.0;\n\t\t\t\t} else if (i !== this._transitionPreviousStates.length - 1) {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight *= 1.0 - interpolatedTime;\n\t\t\t\t} else {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight = interpolatedTime;\n\t\t\t\t}\n\n\t\t\t\tstate = this._findState(this._transitionPreviousStates[i].name);\n\n\t\t\t\tfor (let j = 0; j < state.animations.length; j++) {\n\t\t\t\t\tanimation = state.animations[j];\n\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name + '.previous.' + i);\n\n\t\t\t\t\tif (!clip) {\n\t\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\t\t\t\t\t\tclip.name = animation.name + '.previous.' + i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i !== this._transitionPreviousStates.length - 1) {\n\t\t\t\t\t\tclip.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._isTransitioning = true;\n\t\tthis._totalTransitionTime = transition.time;\n\t\tthis._currTransitionTime = 0;\n\t\tthis._transitionInterruptionSource = transition.interruptionSource;\n\t\tconst activeState = this.activeState;\n\t\tconst hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;\n\t\tlet timeInState = 0;\n\t\tlet timeInStateBefore = 0;\n\n\t\tif (hasTransitionOffset) {\n\t\t\tconst offsetTime = activeState.timelineDuration * transition.transitionOffset;\n\t\t\ttimeInState = offsetTime;\n\t\t\ttimeInStateBefore = offsetTime;\n\t\t}\n\n\t\tthis._timeInState = timeInState;\n\t\tthis._timeInStateBefore = timeInStateBefore;\n\n\t\tfor (let i = 0; i < activeState.animations.length; i++) {\n\t\t\tclip = this._animEvaluator.findClip(activeState.animations[i].name);\n\n\t\t\tif (!clip) {\n\t\t\t\tconst speed = Number.isFinite(activeState.animations[i].speed) ? activeState.animations[i].speed : activeState.speed;\n\t\t\t\tclip = new AnimClip(activeState.animations[i].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);\n\t\t\t\tclip.name = activeState.animations[i].name;\n\n\t\t\t\tthis._animEvaluator.addClip(clip);\n\t\t\t} else {\n\t\t\t\tclip.reset();\n\t\t\t}\n\n\t\t\tif (transition.time > 0) {\n\t\t\t\tclip.blendWeight = 0.0;\n\t\t\t} else {\n\t\t\t\tclip.blendWeight = activeState.animations[i].normalizedWeight;\n\t\t\t}\n\n\t\t\tclip.play();\n\n\t\t\tif (hasTransitionOffset) {\n\t\t\t\tclip.time = activeState.timelineDuration * transition.transitionOffset;\n\t\t\t} else {\n\t\t\t\tconst startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;\n\t\t\t\tclip.time = startTime;\n\t\t\t}\n\t\t}\n\t}\n\n\t_transitionToState(newStateName) {\n\t\tif (!this._findState(newStateName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet transition = this._findTransition(this._activeStateName, newStateName);\n\n\t\tif (!transition) {\n\t\t\tthis._animEvaluator.removeClips();\n\n\t\t\ttransition = new AnimTransition({\n\t\t\t\tfrom: null,\n\t\t\t\tto: newStateName\n\t\t\t});\n\t\t}\n\n\t\tthis.updateStateFromTransition(transition);\n\t}\n\n\tassignAnimation(pathString, animTrack, speed, loop) {\n\t\tconst path = pathString.split('.');\n\n\t\tlet state = this._findState(path[0]);\n\n\t\tif (!state) {\n\t\t\tstate = new AnimState(this, path[0], 1.0);\n\t\t\tthis._states[path[0]] = state;\n\n\t\t\tthis._stateNames.push(path[0]);\n\t\t}\n\n\t\tstate.addAnimation(path, animTrack);\n\n\t\tif (speed !== undefined) {\n\t\t\tstate.speed = speed;\n\t\t}\n\n\t\tif (loop !== undefined) {\n\t\t\tstate.loop = loop;\n\t\t}\n\n\t\tif (!this._playing && this._activate && this.playable) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\n\tremoveNodeAnimations(nodeName) {\n\t\tif (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst state = this._findState(nodeName);\n\n\t\tif (!state) {\n\t\t\treturn;\n\t\t}\n\n\t\tstate.animations = [];\n\t\treturn true;\n\t}\n\n\tplay(stateName) {\n\t\tif (stateName) {\n\t\t\tthis._transitionToState(stateName);\n\t\t}\n\n\t\tthis._playing = true;\n\t}\n\n\tpause() {\n\t\tthis._playing = false;\n\t}\n\n\treset() {\n\t\tthis._previousStateName = null;\n\t\tthis._activeStateName = ANIM_STATE_START;\n\t\tthis._playing = false;\n\t\tthis._currTransitionTime = 1.0;\n\t\tthis._totalTransitionTime = 1.0;\n\t\tthis._isTransitioning = false;\n\t\tthis._timeInState = 0;\n\t\tthis._timeInStateBefore = 0;\n\n\t\tthis._animEvaluator.removeClips();\n\t}\n\n\trebind() {\n\t\tthis._animEvaluator.rebind();\n\t}\n\n\tupdate(dt) {\n\t\tif (!this._playing) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet state;\n\t\tlet animation;\n\t\tlet clip;\n\t\tthis._timeInStateBefore = this._timeInState;\n\t\tthis._timeInState += dt;\n\n\t\tconst transition = this._findTransition(this._activeStateName);\n\n\t\tif (transition) this.updateStateFromTransition(transition);\n\n\t\tif (this._isTransitioning) {\n\t\t\tthis._currTransitionTime += dt;\n\n\t\t\tif (this._currTransitionTime <= this._totalTransitionTime) {\n\t\t\t\tconst interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;\n\n\t\t\t\tfor (let i = 0; i < this._transitionPreviousStates.length; i++) {\n\t\t\t\t\tstate = this._findState(this._transitionPreviousStates[i].name);\n\t\t\t\t\tconst stateWeight = this._transitionPreviousStates[i].weight;\n\n\t\t\t\t\tfor (let j = 0; j < state.animations.length; j++) {\n\t\t\t\t\t\tanimation = state.animations[j];\n\t\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name + '.previous.' + i);\n\n\t\t\t\t\t\tif (clip) {\n\t\t\t\t\t\t\tclip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate = this.activeState;\n\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tthis._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._isTransitioning = false;\n\t\t\t\tconst activeClips = this.activeStateAnimations.length;\n\t\t\t\tconst totalClips = this._animEvaluator.clips.length;\n\n\t\t\t\tfor (let i = 0; i < totalClips - activeClips; i++) {\n\t\t\t\t\tthis._animEvaluator.removeClip(0);\n\t\t\t\t}\n\n\t\t\t\tthis._transitionPreviousStates = [];\n\t\t\t\tstate = this.activeState;\n\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\n\t\t\t\t\tif (clip) {\n\t\t\t\t\t\tclip.blendWeight = animation.normalizedWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.activeState._blendTree.constructor !== AnimNode) {\n\t\t\t\tstate = this.activeState;\n\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\n\t\t\t\t\tif (clip) {\n\t\t\t\t\t\tclip.blendWeight = animation.normalizedWeight;\n\n\t\t\t\t\t\tif (animation.parent.syncAnimations) {\n\t\t\t\t\t\t\tclip.speed = animation.speed;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._animEvaluator.update(dt);\n\t}\n\n\tfindParameter(name) {\n\t\treturn this._parameters[name];\n\t}\n\n}\n\nconst v2 = new Vec2();\nconst v3 = new Vec3();\nconst v4 = new Vec4();\nconst c = new Color();\nconst q = new Quat();\n\nclass AnimComponentBinder extends DefaultAnimBinder {\n\tconstructor(animComponent, graph, layerName, mask, layerIndex) {\n\t\tsuper(graph);\n\t\tthis.animComponent = animComponent;\n\t\tthis._mask = mask;\n\t\tthis.layerName = layerName;\n\t\tthis.layerIndex = layerIndex;\n\t}\n\n\tstatic _packFloat(values) {\n\t\treturn values[0];\n\t}\n\n\tstatic _packBoolean(values) {\n\t\treturn !!values[0];\n\t}\n\n\tstatic _packVec2(values) {\n\t\tv2.x = values[0];\n\t\tv2.y = values[1];\n\t\treturn v2;\n\t}\n\n\tstatic _packVec3(values) {\n\t\tv3.x = values[0];\n\t\tv3.y = values[1];\n\t\tv3.z = values[2];\n\t\treturn v3;\n\t}\n\n\tstatic _packVec4(values) {\n\t\tv4.x = values[0];\n\t\tv4.y = values[1];\n\t\tv4.z = values[2];\n\t\tv4.w = values[3];\n\t\treturn v4;\n\t}\n\n\tstatic _packColor(values) {\n\t\tc.r = values[0];\n\t\tc.g = values[1];\n\t\tc.b = values[2];\n\t\tc.a = values[3];\n\t\treturn c;\n\t}\n\n\tstatic _packQuat(values) {\n\t\tq.x = values[0];\n\t\tq.y = values[1];\n\t\tq.z = values[2];\n\t\tq.w = values[3];\n\t\treturn q;\n\t}\n\n\tresolve(path) {\n\t\tconst encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);\n\t\tlet target = this.targetCache[encodedPath];\n\t\tif (target) return target;\n\t\tlet entity;\n\t\tlet propertyComponent;\n\t\tlet targetPath;\n\n\t\tswitch (path.component) {\n\t\t\tcase 'entity':\n\t\t\t\tentity = this._getEntityFromHierarchy(path.entityPath);\n\t\t\t\ttargetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);\n\t\t\t\tpropertyComponent = entity;\n\t\t\t\tbreak;\n\n\t\t\tcase 'graph':\n\t\t\t\tpropertyComponent = this.findNode(path);\n\t\t\t\tif (!propertyComponent) return null;\n\t\t\t\ttargetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tentity = this._getEntityFromHierarchy(path.entityPath);\n\t\t\t\tpropertyComponent = entity.findComponent(path.component);\n\t\t\t\tif (!propertyComponent) return null;\n\t\t\t\ttargetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttarget = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);\n\t\tthis.targetCache[encodedPath] = target;\n\t\treturn target;\n\t}\n\n\tupdate(deltaTime) {\n\t\tconst activeNodes = this.activeNodes;\n\n\t\tif (activeNodes) {\n\t\t\tfor (let i = 0; i < activeNodes.length; i++) {\n\t\t\t\tactiveNodes[i]._dirtifyLocal();\n\t\t\t}\n\t\t}\n\t}\n\n\t_getEntityFromHierarchy(entityHierarchy) {\n\t\tif (!this.animComponent.entity.name === entityHierarchy[0]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currEntity = this.animComponent.entity;\n\n\t\tif (entityHierarchy.length === 1) {\n\t\t\treturn currEntity;\n\t\t}\n\n\t\treturn currEntity._parent.findByPath(entityHierarchy);\n\t}\n\n\t_resolvePath(object, path, resolveLeaf) {\n\t\tconst steps = path.length - (resolveLeaf ? 0 : 1);\n\n\t\tfor (let i = 0; i < steps; i++) {\n\t\t\tobject = object[path[i]];\n\t\t}\n\n\t\treturn object;\n\t}\n\n\t_setter(object, path, packFunc) {\n\t\tconst obj = this._resolvePath(object, path);\n\n\t\tconst key = path[path.length - 1];\n\t\tconst setterFunc = \"set\" + key.substring(0, 1).toUpperCase() + key.substring(1);\n\n\t\tif (obj[setterFunc]) {\n\t\t\tconst func = obj[setterFunc].bind(obj);\n\t\t\treturn function (values) {\n\t\t\t\tfunc(packFunc(values));\n\t\t\t};\n\t\t}\n\n\t\tconst prop = obj[key];\n\n\t\tif (typeof prop === 'object' && prop.hasOwnProperty('copy')) {\n\t\t\treturn function (values) {\n\t\t\t\tprop.copy(packFunc(values));\n\t\t\t};\n\t\t}\n\n\t\tif ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {\n\t\t\tconst parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;\n\t\t\tconst objKey = path[path.length - 2];\n\t\t\treturn function (values) {\n\t\t\t\tobj[key] = packFunc(values);\n\t\t\t\tparent[objKey] = obj;\n\t\t\t};\n\t\t}\n\n\t\treturn function (values) {\n\t\t\tobj[key] = packFunc(values);\n\t\t};\n\t}\n\n\t_createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {\n\t\tif (this.handlers && propertyHierarchy[0] === 'weights') {\n\t\t\treturn this.handlers.weights(propertyComponent);\n\t\t} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {\n\t\t\tconst materialPropertyName = propertyHierarchy[1];\n\n\t\t\tif (materialPropertyName.endsWith('Map')) {\n\t\t\t\treturn this.handlers.materialTexture(propertyComponent, materialPropertyName);\n\t\t\t}\n\t\t}\n\n\t\tconst property = this._resolvePath(propertyComponent, propertyHierarchy, true);\n\n\t\tif (typeof property === 'undefined') return null;\n\t\tlet setter;\n\t\tlet animDataType;\n\t\tlet animDataComponents;\n\n\t\tif (typeof property === 'number') {\n\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);\n\t\t\tanimDataType = 'vector';\n\t\t\tanimDataComponents = 1;\n\t\t} else if (typeof property === 'boolean') {\n\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);\n\t\t\tanimDataType = 'vector';\n\t\t\tanimDataComponents = 1;\n\t\t} else if (typeof property === 'object') {\n\t\t\tswitch (property.constructor) {\n\t\t\t\tcase Vec2:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Vec3:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Vec4:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Color:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Quat:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);\n\t\t\t\t\tanimDataType = 'quaternion';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (propertyHierarchy.indexOf('material') !== -1) {\n\t\t\treturn new AnimTarget(function (values) {\n\t\t\t\tsetter(values);\n\t\t\t\tpropertyComponent.material.update();\n\t\t\t}, animDataType, animDataComponents, targetPath);\n\t\t}\n\n\t\treturn new AnimTarget(setter, animDataType, animDataComponents, targetPath);\n\t}\n\n\trebind() {\n\t\tthis.targetCache = {};\n\n\t\tif (this.animComponent.rootBone) {\n\t\t\tthis.graph = this.animComponent.rootBone;\n\t\t} else {\n\t\t\tthis.graph = this.animComponent.entity;\n\t\t}\n\n\t\tconst nodes = {};\n\n\t\tconst flatten = function flatten(node) {\n\t\t\tnodes[node.name] = node;\n\n\t\t\tfor (let i = 0; i < node.children.length; ++i) {\n\t\t\t\tflatten(node.children[i]);\n\t\t\t}\n\t\t};\n\n\t\tflatten(this.graph);\n\t\tthis.nodes = nodes;\n\t}\n\n}\n\nclass AnimComponentLayer {\n\tconstructor(name, controller, component, weight = 1, blendType = ANIM_LAYER_OVERWRITE) {\n\t\tthis._name = name;\n\t\tthis._controller = controller;\n\t\tthis._component = component;\n\t\tthis._weight = weight;\n\t\tthis._blendType = blendType;\n\t\tthis._mask = null;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tset playing(value) {\n\t\tthis._controller.playing = value;\n\t}\n\n\tget playing() {\n\t\treturn this._controller.playing;\n\t}\n\n\tget playable() {\n\t\treturn this._controller.playable;\n\t}\n\n\tget activeState() {\n\t\treturn this._controller.activeStateName;\n\t}\n\n\tget previousState() {\n\t\treturn this._controller.previousStateName;\n\t}\n\n\tget activeStateProgress() {\n\t\treturn this._controller.activeStateProgress;\n\t}\n\n\tget activeStateDuration() {\n\t\treturn this._controller.activeStateDuration;\n\t}\n\n\tset activeStateCurrentTime(time) {\n\t\tconst controller = this._controller;\n\t\tconst layerPlaying = controller.playing;\n\t\tcontroller.playing = true;\n\t\tcontroller.activeStateCurrentTime = time;\n\n\t\tif (!layerPlaying) {\n\t\t\tcontroller.update(0);\n\t\t}\n\n\t\tcontroller.playing = layerPlaying;\n\t}\n\n\tget activeStateCurrentTime() {\n\t\treturn this._controller.activeStateCurrentTime;\n\t}\n\n\tget transitioning() {\n\t\treturn this._controller.transitioning;\n\t}\n\n\tget transitionProgress() {\n\t\tif (this.transitioning) {\n\t\t\treturn this._controller.transitionProgress;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tget states() {\n\t\treturn this._controller.states;\n\t}\n\n\tset weight(value) {\n\t\tthis._weight = value;\n\n\t\tthis._component.dirtifyTargets();\n\t}\n\n\tget weight() {\n\t\treturn this._weight;\n\t}\n\n\tset blendType(value) {\n\t\tif (value !== this._blendType) {\n\t\t\tthis._blendType = value;\n\n\t\t\tthis._component.rebind();\n\t\t}\n\t}\n\n\tget blendType() {\n\t\treturn this._blendType;\n\t}\n\n\tset mask(value) {\n\t\tif (this._controller.assignMask(value)) {\n\t\t\tthis._component.rebind();\n\t\t}\n\n\t\tthis._mask = value;\n\t}\n\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\n\tplay(name) {\n\t\tthis._controller.play(name);\n\t}\n\n\tpause() {\n\t\tthis._controller.pause();\n\t}\n\n\treset() {\n\t\tthis._controller.reset();\n\t}\n\n\trebind() {\n\t\tthis._controller.rebind();\n\t}\n\n\tupdate(dt) {\n\t\tthis._controller.update(dt);\n\t}\n\n\tassignMask(mask) {\n\t\tif (this._controller.assignMask(mask)) {\n\t\t\tthis._component.rebind();\n\t\t}\n\n\t\tthis._mask = mask;\n\t}\n\n\tassignAnimation(nodePath, animTrack, speed, loop) {\n\t\tif (animTrack.constructor !== AnimTrack) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._controller.assignAnimation(nodePath, animTrack, speed, loop);\n\n\t\tif (this._controller._transitions.length === 0) {\n\t\t\tthis._controller._transitions.push(new AnimTransition({\n\t\t\t\tfrom: 'START',\n\t\t\t\tto: nodePath\n\t\t\t}));\n\t\t}\n\n\t\tif (this._component.activate && this._component.playable) {\n\t\t\tthis._component.playing = true;\n\t\t}\n\t}\n\n\tremoveNodeAnimations(nodeName) {\n\t\tif (this._controller.removeNodeAnimations(nodeName)) {\n\t\t\tthis._component.playing = false;\n\t\t}\n\t}\n\n\tgetAnimationAsset(stateName) {\n\t\treturn this._component.animationAssets[`${this.name}:${stateName}`];\n\t}\n\n\ttransition(to, time = 0, transitionOffset = null) {\n\t\tthis._controller.updateStateFromTransition(new AnimTransition({\n\t\t\tfrom: this._controller.activeStateName,\n\t\t\tto,\n\t\t\ttime,\n\t\t\ttransitionOffset\n\t\t}));\n\t}\n\n}\n\nclass AnimComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._stateGraphAsset = null;\n\t\tthis._animationAssets = {};\n\t\tthis._speed = 1.0;\n\t\tthis._activate = true;\n\t\tthis._playing = false;\n\t\tthis._rootBone = null;\n\t\tthis._stateGraph = null;\n\t\tthis._layers = [];\n\t\tthis._layerIndices = {};\n\t\tthis._parameters = {};\n\t\tthis._targets = {};\n\t\tthis._consumedTriggers = new Set();\n\t}\n\n\tset stateGraphAsset(value) {\n\t\tif (value === null) {\n\t\t\tthis.removeStateGraph();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._stateGraphAsset) {\n\t\t\tconst stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);\n\t\t\tstateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);\n\t\t}\n\n\t\tlet _id;\n\n\t\tlet _asset;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t\t_asset = this.system.app.assets.get(_id);\n\n\t\t\tif (!_asset) {\n\t\t\t\tthis.system.app.assets.add(value);\n\t\t\t\t_asset = this.system.app.assets.get(_id);\n\t\t\t}\n\t\t} else {\n\t\t\t_id = value;\n\t\t\t_asset = this.system.app.assets.get(_id);\n\t\t}\n\n\t\tif (!_asset || this._stateGraphAsset === _id) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_asset.resource) {\n\t\t\tthis._stateGraph = _asset.resource;\n\t\t\tthis.loadStateGraph(this._stateGraph);\n\n\t\t\t_asset.on('change', this._onStateGraphAssetChangeEvent, this);\n\t\t} else {\n\t\t\t_asset.once('load', asset => {\n\t\t\t\tthis._stateGraph = asset.resource;\n\t\t\t\tthis.loadStateGraph(this._stateGraph);\n\t\t\t});\n\n\t\t\t_asset.on('change', this._onStateGraphAssetChangeEvent, this);\n\n\t\t\tthis.system.app.assets.load(_asset);\n\t\t}\n\n\t\tthis._stateGraphAsset = _id;\n\t}\n\n\tget stateGraphAsset() {\n\t\treturn this._stateGraphAsset;\n\t}\n\n\tset animationAssets(value) {\n\t\tthis._animationAssets = value;\n\t\tthis.loadAnimationAssets();\n\t}\n\n\tget animationAssets() {\n\t\treturn this._animationAssets;\n\t}\n\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\n\tset activate(value) {\n\t\tthis._activate = value;\n\t}\n\n\tget activate() {\n\t\treturn this._activate;\n\t}\n\n\tset playing(value) {\n\t\tthis._playing = value;\n\t}\n\n\tget playing() {\n\t\treturn this._playing;\n\t}\n\n\tset rootBone(value) {\n\t\tif (typeof value === 'string') {\n\t\t\tconst entity = this.entity.root.findByGuid(value);\n\t\t\tthis._rootBone = entity;\n\t\t} else if (value instanceof Entity) {\n\t\t\tthis._rootBone = value;\n\t\t} else {\n\t\t\tthis._rootBone = null;\n\t\t}\n\n\t\tthis.rebind();\n\t}\n\n\tget rootBone() {\n\t\treturn this._rootBone;\n\t}\n\n\tset stateGraph(value) {\n\t\tthis._stateGraph = value;\n\t}\n\n\tget stateGraph() {\n\t\treturn this._stateGraph;\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset layerIndices(value) {\n\t\tthis._layerIndices = value;\n\t}\n\n\tget layerIndices() {\n\t\treturn this._layerIndices;\n\t}\n\n\tset parameters(value) {\n\t\tthis._parameters = value;\n\t}\n\n\tget parameters() {\n\t\treturn this._parameters;\n\t}\n\n\tset targets(value) {\n\t\tthis._targets = value;\n\t}\n\n\tget targets() {\n\t\treturn this._targets;\n\t}\n\n\tget playable() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tif (!this._layers[i].playable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget baseLayer() {\n\t\tif (this._layers.length > 0) {\n\t\t\treturn this._layers[0];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_onStateGraphAssetChangeEvent(asset) {\n\t\tconst prevAnimationAssets = this.animationAssets;\n\t\tconst prevMasks = this.layers.map(layer => layer.mask);\n\t\tthis.removeStateGraph();\n\t\tthis._stateGraph = new AnimStateGraph(asset._data);\n\t\tthis.loadStateGraph(this._stateGraph);\n\t\tthis.animationAssets = prevAnimationAssets;\n\t\tthis.loadAnimationAssets();\n\t\tthis.layers.forEach((layer, i) => {\n\t\t\tlayer.mask = prevMasks[i];\n\t\t});\n\t\tthis.rebind();\n\t}\n\n\tdirtifyTargets() {\n\t\tconst targets = Object.values(this._targets);\n\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\ttargets[i].dirty = true;\n\t\t}\n\t}\n\n\t_addLayer({\n\t\tname,\n\t\tstates,\n\t\ttransitions,\n\t\tweight,\n\t\tmask,\n\t\tblendType\n\t}) {\n\t\tlet graph;\n\n\t\tif (this.rootBone) {\n\t\t\tgraph = this.rootBone;\n\t\t} else {\n\t\t\tgraph = this.entity;\n\t\t}\n\n\t\tconst layerIndex = this._layers.length;\n\t\tconst animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);\n\t\tconst animEvaluator = new AnimEvaluator(animBinder);\n\t\tconst controller = new AnimController(animEvaluator, states, transitions, this._parameters, this._activate, this, this._consumedTriggers);\n\n\t\tthis._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));\n\n\t\tthis._layerIndices[name] = layerIndex;\n\t\treturn this._layers[layerIndex];\n\t}\n\n\taddLayer(name, weight, mask, blendType) {\n\t\tconst layer = this.findAnimationLayer(name);\n\t\tif (layer) return layer;\n\t\tconst states = [{\n\t\t\t\"name\": \"START\",\n\t\t\t\"speed\": 1\n\t\t}];\n\t\tconst transitions = [];\n\t\treturn this._addLayer({\n\t\t\tname,\n\t\t\tstates,\n\t\t\ttransitions,\n\t\t\tweight,\n\t\t\tmask,\n\t\t\tblendType\n\t\t});\n\t}\n\n\tloadStateGraph(stateGraph) {\n\t\tthis._stateGraph = stateGraph;\n\t\tthis._parameters = {};\n\t\tconst paramKeys = Object.keys(stateGraph.parameters);\n\n\t\tfor (let i = 0; i < paramKeys.length; i++) {\n\t\t\tconst paramKey = paramKeys[i];\n\t\t\tthis._parameters[paramKey] = {\n\t\t\t\ttype: stateGraph.parameters[paramKey].type,\n\t\t\t\tvalue: stateGraph.parameters[paramKey].value\n\t\t\t};\n\t\t}\n\n\t\tthis._layers = [];\n\n\t\tfor (let i = 0; i < stateGraph.layers.length; i++) {\n\t\t\tconst layer = stateGraph.layers[i];\n\n\t\t\tthis._addLayer.bind(this)(_extends({}, layer));\n\t\t}\n\n\t\tthis.setupAnimationAssets();\n\t}\n\n\tsetupAnimationAssets() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this._layers[i];\n\t\t\tconst layerName = layer.name;\n\n\t\t\tfor (let j = 0; j < layer.states.length; j++) {\n\t\t\t\tconst stateName = layer.states[j];\n\n\t\t\t\tif (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {\n\t\t\t\t\tconst stateKey = layerName + ':' + stateName;\n\n\t\t\t\t\tif (!this._animationAssets[stateKey]) {\n\t\t\t\t\t\tthis._animationAssets[stateKey] = {\n\t\t\t\t\t\t\tasset: null\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.loadAnimationAssets();\n\t}\n\n\tloadAnimationAssets() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this._layers[i];\n\n\t\t\tfor (let j = 0; j < layer.states.length; j++) {\n\t\t\t\tconst stateName = layer.states[j];\n\t\t\t\tif (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;\n\t\t\t\tconst animationAsset = this._animationAssets[layer.name + ':' + stateName];\n\n\t\t\t\tif (!animationAsset || !animationAsset.asset) {\n\t\t\t\t\tthis.removeNodeAnimations(stateName, layer.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst assetId = animationAsset.asset;\n\t\t\t\tconst asset = this.system.app.assets.get(assetId);\n\n\t\t\t\tif (asset) {\n\t\t\t\t\tif (asset.resource) {\n\t\t\t\t\t\tthis.onAnimationAssetLoaded(layer.name, stateName, asset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasset.once('load', function (layerName, stateName) {\n\t\t\t\t\t\t\treturn function (asset) {\n\t\t\t\t\t\t\t\tthis.onAnimationAssetLoaded(layerName, stateName, asset);\n\t\t\t\t\t\t\t}.bind(this);\n\t\t\t\t\t\t}.bind(this)(layer.name, stateName));\n\t\t\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonAnimationAssetLoaded(layerName, stateName, asset) {\n\t\tconst animTrack = asset.resource;\n\n\t\tif (asset.data.events) {\n\t\t\tanimTrack.events = new AnimEvents(Object.values(asset.data.events));\n\t\t}\n\n\t\tthis.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);\n\t}\n\n\tremoveStateGraph() {\n\t\tthis._stateGraph = null;\n\t\tthis._stateGraphAsset = null;\n\t\tthis._animationAssets = {};\n\t\tthis._layers = [];\n\t\tthis._layerIndices = {};\n\t\tthis._parameters = {};\n\t\tthis._playing = false;\n\t}\n\n\tresetStateGraph() {\n\t\tif (this.stateGraphAsset) {\n\t\t\tconst stateGraph = this.system.app.assets.get(this.stateGraphAsset).resource;\n\t\t\tthis.loadStateGraph(stateGraph);\n\t\t} else {\n\t\t\tthis.removeStateGraph();\n\t\t}\n\t}\n\n\treset() {\n\t\tthis._parameters = Object.assign({}, this._stateGraph.parameters);\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layerPlaying = this._layers[i].playing;\n\n\t\t\tthis._layers[i].reset();\n\n\t\t\tthis._layers[i].playing = layerPlaying;\n\t\t}\n\t}\n\n\trebind() {\n\t\tthis._targets = {};\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tthis._layers[i].rebind();\n\t\t}\n\t}\n\n\tfindAnimationLayer(name) {\n\t\tconst layerIndex = this._layerIndices[name];\n\t\treturn this._layers[layerIndex] || null;\n\t}\n\n\taddAnimationState(nodeName, animTrack, speed = 1, loop = true, layerName = 'Base') {\n\t\tif (!this._stateGraph) {\n\t\t\tthis.loadStateGraph(new AnimStateGraph({\n\t\t\t\t\"layers\": [{\n\t\t\t\t\t\"name\": layerName,\n\t\t\t\t\t\"states\": [{\n\t\t\t\t\t\t\"name\": \"START\",\n\t\t\t\t\t\t\"speed\": 1\n\t\t\t\t\t}, {\n\t\t\t\t\t\t\"name\": nodeName,\n\t\t\t\t\t\t\"speed\": speed,\n\t\t\t\t\t\t\"loop\": loop,\n\t\t\t\t\t\t\"defaultState\": true\n\t\t\t\t\t}],\n\t\t\t\t\t\"transitions\": [{\n\t\t\t\t\t\t\"from\": 'START',\n\t\t\t\t\t\t\"to\": nodeName\n\t\t\t\t\t}]\n\t\t\t\t}],\n\t\t\t\t\"parameters\": {}\n\t\t\t}));\n\t\t}\n\n\t\tconst layer = this.findAnimationLayer(layerName);\n\n\t\tif (layer) {\n\t\t\tlayer.assignAnimation(nodeName, animTrack, speed, loop);\n\t\t} else {\n\t\t\tvar _this$addLayer;\n\n\t\t\t(_this$addLayer = this.addLayer(layerName)) == null ? void 0 : _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);\n\t\t}\n\t}\n\n\tassignAnimation(nodePath, animTrack, layerName, speed = 1, loop = true) {\n\t\tif (!this._stateGraph && nodePath.indexOf('.') === -1) {\n\t\t\tthis.loadStateGraph(new AnimStateGraph({\n\t\t\t\t\"layers\": [{\n\t\t\t\t\t\"name\": \"Base\",\n\t\t\t\t\t\"states\": [{\n\t\t\t\t\t\t\"name\": \"START\",\n\t\t\t\t\t\t\"speed\": 1\n\t\t\t\t\t}, {\n\t\t\t\t\t\t\"name\": nodePath,\n\t\t\t\t\t\t\"speed\": speed,\n\t\t\t\t\t\t\"loop\": loop,\n\t\t\t\t\t\t\"defaultState\": true\n\t\t\t\t\t}],\n\t\t\t\t\t\"transitions\": [{\n\t\t\t\t\t\t\"from\": 'START',\n\t\t\t\t\t\t\"to\": nodePath\n\t\t\t\t\t}]\n\t\t\t\t}],\n\t\t\t\t\"parameters\": {}\n\t\t\t}));\n\t\t\tthis.baseLayer.assignAnimation(nodePath, animTrack);\n\t\t\treturn;\n\t\t}\n\n\t\tconst layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;\n\n\t\tif (!layer) {\n\t\t\treturn;\n\t\t}\n\n\t\tlayer.assignAnimation(nodePath, animTrack, speed, loop);\n\t}\n\n\tremoveNodeAnimations(nodeName, layerName) {\n\t\tconst layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;\n\n\t\tif (!layer) {\n\t\t\treturn;\n\t\t}\n\n\t\tlayer.removeNodeAnimations(nodeName);\n\t}\n\n\tgetParameterValue(name, type) {\n\t\tconst param = this._parameters[name];\n\n\t\tif (param && param.type === type) {\n\t\t\treturn param.value;\n\t\t}\n\t}\n\n\tsetParameterValue(name, type, value) {\n\t\tconst param = this._parameters[name];\n\n\t\tif (param && param.type === type) {\n\t\t\tparam.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgetFloat(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_FLOAT);\n\t}\n\n\tsetFloat(name, value) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);\n\t}\n\n\tgetInteger(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_INTEGER);\n\t}\n\n\tsetInteger(name, value) {\n\t\tif (typeof value === 'number' && value % 1 === 0) {\n\t\t\tthis.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);\n\t\t}\n\t}\n\n\tgetBoolean(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);\n\t}\n\n\tsetBoolean(name, value) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);\n\t}\n\n\tgetTrigger(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);\n\t}\n\n\tsetTrigger(name, singleFrame = false) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);\n\n\t\tif (singleFrame) {\n\t\t\tthis._consumedTriggers.add(name);\n\t\t}\n\t}\n\n\tresetTrigger(name) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);\n\t}\n\n\tonBeforeRemove() {\n\t\tif (Number.isFinite(this._stateGraphAsset)) {\n\t\t\tconst stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);\n\t\t\tstateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);\n\t\t}\n\t}\n\n\tupdate(dt) {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tthis.layers[i].update(dt * this.speed);\n\t\t}\n\n\t\tthis._consumedTriggers.forEach(trigger => {\n\t\t\tthis.parameters[trigger].value = false;\n\t\t});\n\n\t\tthis._consumedTriggers.clear();\n\t}\n\n\tresolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {\n\t\tif (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {\n\t\t\tthis.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];\n\t\t} else {\n\t\t\tthis.rebind();\n\t\t}\n\t}\n\n}\n\nclass AnimComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$k = ['enabled'];\n\nclass AnimComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'anim';\n\t\tthis.ComponentType = AnimComponent;\n\t\tthis.DataType = AnimComponentData;\n\t\tthis.schema = _schema$k;\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('animationUpdate', this.onAnimationUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tsuper.initializeComponentData(component, data, _schema$k);\n\t\tconst complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];\n\t\tObject.keys(data).forEach(key => {\n\t\t\tif (complexProperties.includes(key)) return;\n\t\t\tcomponent[key] = data[key];\n\t\t});\n\n\t\tif (data.stateGraph) {\n\t\t\tcomponent.stateGraph = data.stateGraph;\n\t\t\tcomponent.loadStateGraph(component.stateGraph);\n\t\t}\n\n\t\tif (data.layers) {\n\t\t\tdata.layers.forEach((layer, i) => {\n\t\t\t\tlayer._controller.states.forEach(stateKey => {\n\t\t\t\t\tlayer._controller._states[stateKey]._animationList.forEach(node => {\n\t\t\t\t\t\tcomponent.layers[i].assignAnimation(node.name, node.animTrack);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} else if (data.animationAssets) {\n\t\t\tcomponent.animationAssets = Object.assign(component.animationAssets, data.animationAssets);\n\t\t}\n\n\t\tif (data.masks) {\n\t\t\tObject.keys(data.masks).forEach(key => {\n\t\t\t\tif (component.layers[key]) {\n\t\t\t\t\tconst maskData = data.masks[key].mask;\n\t\t\t\t\tconst mask = {};\n\t\t\t\t\tObject.keys(maskData).forEach(maskKey => {\n\t\t\t\t\t\tmask[decodeURI(maskKey)] = maskData[maskKey];\n\t\t\t\t\t});\n\t\t\t\t\tcomponent.layers[key].mask = mask;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tonAnimationUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id].entity.anim;\n\t\t\t\tconst componentData = component.data;\n\n\t\t\t\tif (componentData.enabled && component.entity.enabled && component.playing) {\n\t\t\t\t\tcomponent.update(dt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst data = {\n\t\t\tstateGraphAsset: entity.anim.stateGraphAsset,\n\t\t\tanimationAssets: entity.anim.animationAssets,\n\t\t\tspeed: entity.anim.speed,\n\t\t\tactivate: entity.anim.activate,\n\t\t\tplaying: entity.anim.playing,\n\t\t\trootBone: entity.anim.rootBone,\n\t\t\tstateGraph: entity.anim.stateGraph,\n\t\t\tlayers: entity.anim.layers,\n\t\t\tlayerIndices: entity.anim.layerIndices,\n\t\t\tparameters: entity.anim.parameters\n\t\t};\n\t\tthis.addComponent(clone, data);\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('animationUpdate', this.onAnimationUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(AnimComponent.prototype, _schema$k);\n\nclass AudioListenerComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t}\n\n\tsetCurrentListener() {\n\t\tif (this.enabled && this.entity.audiolistener && this.entity.enabled) {\n\t\t\tthis.system.current = this.entity;\n\t\t\tconst position = this.system.current.getPosition();\n\t\t\tthis.system.manager.listener.setPosition(position);\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tthis.setCurrentListener();\n\t}\n\n\tonDisable() {\n\t\tif (this.system.current === this.entity) {\n\t\t\tthis.system.current = null;\n\t\t}\n\t}\n\n}\n\nclass AudioListenerComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$j = ['enabled'];\n\nclass AudioListenerComponentSystem extends ComponentSystem {\n\tconstructor(app, manager) {\n\t\tsuper(app);\n\t\tthis.id = \"audiolistener\";\n\t\tthis.ComponentType = AudioListenerComponent;\n\t\tthis.DataType = AudioListenerComponentData;\n\t\tthis.schema = _schema$j;\n\t\tthis.manager = manager;\n\t\tthis.current = null;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['enabled'];\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tonUpdate(dt) {\n\t\tif (this.current) {\n\t\t\tconst position = this.current.getPosition();\n\t\t\tthis.manager.listener.setPosition(position);\n\t\t\tconst wtm = this.current.getWorldTransform();\n\t\t\tthis.manager.listener.setOrientation(wtm);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(AudioListenerComponent.prototype, _schema$j);\n\nclass AudioSourceComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.on(\"set_assets\", this.onSetAssets, this);\n\t\tthis.on(\"set_loop\", this.onSetLoop, this);\n\t\tthis.on(\"set_volume\", this.onSetVolume, this);\n\t\tthis.on(\"set_pitch\", this.onSetPitch, this);\n\t\tthis.on(\"set_minDistance\", this.onSetMinDistance, this);\n\t\tthis.on(\"set_maxDistance\", this.onSetMaxDistance, this);\n\t\tthis.on(\"set_rollOffFactor\", this.onSetRollOffFactor, this);\n\t\tthis.on(\"set_distanceModel\", this.onSetDistanceModel, this);\n\t\tthis.on(\"set_3d\", this.onSet3d, this);\n\t}\n\n\tplay(name) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.channel) {\n\t\t\tthis.stop();\n\t\t}\n\n\t\tlet channel;\n\t\tconst componentData = this.data;\n\n\t\tif (componentData.sources[name]) {\n\t\t\tif (!componentData['3d']) {\n\t\t\t\tchannel = this.system.manager.playSound(componentData.sources[name], componentData);\n\t\t\t\tcomponentData.currentSource = name;\n\t\t\t\tcomponentData.channel = channel;\n\t\t\t} else {\n\t\t\t\tconst pos = this.entity.getPosition();\n\t\t\t\tchannel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);\n\t\t\t\tcomponentData.currentSource = name;\n\t\t\t\tcomponentData.channel = channel;\n\t\t\t}\n\t\t}\n\t}\n\n\tpause() {\n\t\tif (this.channel) {\n\t\t\tthis.channel.pause();\n\t\t}\n\t}\n\n\tunpause() {\n\t\tif (this.channel && this.channel.paused) {\n\t\t\tthis.channel.unpause();\n\t\t}\n\t}\n\n\tstop() {\n\t\tif (this.channel) {\n\t\t\tthis.channel.stop();\n\t\t\tthis.channel = null;\n\t\t}\n\t}\n\n\tonSetAssets(name, oldValue, newValue) {\n\t\tconst newAssets = [];\n\t\tconst len = newValue.length;\n\n\t\tif (oldValue && oldValue.length) {\n\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\tif (oldValue[i]) {\n\t\t\t\t\tconst asset = this.system.app.assets.get(oldValue[i]);\n\n\t\t\t\t\tif (asset) {\n\t\t\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\n\t\t\t\t\t\tif (this.currentSource === asset.name) {\n\t\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (len) {\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tif (oldValue.indexOf(newValue[i]) < 0) {\n\t\t\t\t\tif (newValue[i] instanceof Asset) {\n\t\t\t\t\t\tnewAssets.push(newValue[i].id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewAssets.push(newValue[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.system._inTools && newAssets.length) {\n\t\t\tthis.loadAudioSourceAssets(newAssets);\n\t\t}\n\t}\n\n\tonAssetChanged(asset, attribute, newValue, oldValue) {\n\t\tif (attribute === 'resource') {\n\t\t\tconst sources = this.data.sources;\n\n\t\t\tif (sources) {\n\t\t\t\tthis.data.sources[asset.name] = newValue;\n\n\t\t\t\tif (this.data.currentSource === asset.name) {\n\t\t\t\t\tif (this.channel) {\n\t\t\t\t\t\tif (this.channel.paused) {\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\n\t\tif (this.data.sources[asset.name]) {\n\t\t\tdelete this.data.sources[asset.name];\n\n\t\t\tif (this.data.currentSource === asset.name) {\n\t\t\t\tthis.stop();\n\t\t\t\tthis.data.currentSource = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetLoop(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setLoop(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetVolume(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setVolume(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetPitch(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setPitch(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetMaxDistance(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setMaxDistance(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetMinDistance(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setMinDistance(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetRollOffFactor(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setRollOffFactor(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetDistanceModel(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setDistanceModel(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSet3d(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.system.initialized && this.currentSource) {\n\t\t\t\tlet paused = false;\n\t\t\t\tlet suspended = false;\n\n\t\t\t\tif (this.channel) {\n\t\t\t\t\tpaused = this.channel.paused;\n\t\t\t\t\tsuspended = this.channel.suspended;\n\t\t\t\t}\n\n\t\t\t\tthis.play(this.currentSource);\n\n\t\t\t\tif (this.channel) {\n\t\t\t\t\tthis.channel.paused = paused;\n\t\t\t\t\tthis.channel.suspended = suspended;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tconst assets = this.data.assets;\n\n\t\tif (assets) {\n\t\t\tconst registry = this.system.app.assets;\n\n\t\t\tfor (let i = 0, len = assets.length; i < len; i++) {\n\t\t\t\tlet asset = assets[i];\n\t\t\t\tif (!(asset instanceof Asset)) asset = registry.get(asset);\n\n\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\tregistry.load(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.system.initialized) {\n\t\t\tif (this.data.activate && !this.channel) {\n\t\t\t\tthis.play(this.currentSource);\n\t\t\t} else {\n\t\t\t\tthis.unpause();\n\t\t\t}\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tthis.pause();\n\t}\n\n\tloadAudioSourceAssets(ids) {\n\t\tconst assets = ids.map(id => {\n\t\t\treturn this.system.app.assets.get(id);\n\t\t});\n\t\tconst sources = {};\n\t\tlet currentSource = null;\n\t\tlet count = assets.length;\n\n\t\tconst _error = e => {\n\t\t\tcount--;\n\t\t};\n\n\t\tconst _done = () => {\n\t\t\tthis.data.sources = sources;\n\t\t\tthis.data.currentSource = currentSource;\n\n\t\t\tif (this.enabled && this.activate && currentSource) {\n\t\t\t\tthis.onEnable();\n\t\t\t}\n\t\t};\n\n\t\tassets.forEach((asset, index) => {\n\t\t\tif (asset) {\n\t\t\t\tcurrentSource = currentSource || asset.name;\n\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\tasset.on('change', this.onAssetChanged, this);\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.off('error', _error, this);\n\t\t\t\tasset.on('error', _error, this);\n\t\t\t\tasset.ready(asset => {\n\t\t\t\t\tsources[asset.name] = asset.resource;\n\t\t\t\t\tcount--;\n\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\t_done();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (!asset.resource && this.enabled && this.entity.enabled) this.system.app.assets.load(asset);\n\t\t\t} else {\n\t\t\t\tcount--;\n\n\t\t\t\tif (count === 0) {\n\t\t\t\t\t_done();\n\t\t\t\t}\n\n\t\t\t\tthis.system.app.assets.on(\"add:\" + ids[index], asset => {\n\t\t\t\t\tasset.ready(asset => {\n\t\t\t\t\t\tthis.data.sources[asset.name] = asset.resource;\n\t\t\t\t\t});\n\t\t\t\t\tif (!asset.resource) this.system.app.assets.load(asset);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n}\n\nclass AudioSourceComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.assets = [];\n\t\tthis.activate = true;\n\t\tthis.volume = 1;\n\t\tthis.pitch = 1;\n\t\tthis.loop = false;\n\t\tthis['3d'] = true;\n\t\tthis.minDistance = 1;\n\t\tthis.maxDistance = 10000;\n\t\tthis.rollOffFactor = 1;\n\t\tthis.distanceModel = DISTANCE_INVERSE;\n\t\tthis.paused = true;\n\t\tthis.sources = {};\n\t\tthis.currentSource = null;\n\t\tthis.channel = null;\n\t}\n\n}\n\nconst _schema$i = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];\n\nclass AudioSourceComponentSystem extends ComponentSystem {\n\tconstructor(app, manager) {\n\t\tsuper(app);\n\t\tthis.id = \"audiosource\";\n\t\tthis.ComponentType = AudioSourceComponent;\n\t\tthis.DataType = AudioSourceComponentData;\n\t\tthis.schema = _schema$i;\n\t\tthis.manager = manager;\n\t\tthis.initialized = false;\n\t\tthis.app.systems.on('initialize', this.onInitialize, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('remove', this.onRemove, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\tcomponent.paused = !(component.enabled && component.activate);\n\t}\n\n\tonInitialize(root) {\n\t\tif (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {\n\t\t\troot.audiosource.play(root.audiosource.currentSource);\n\t\t}\n\n\t\tconst children = root._children;\n\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\tthis.onInitialize(children[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.initialized = true;\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tconst entity = component.entity;\n\t\t\t\tconst componentData = component.data;\n\n\t\t\t\tif (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {\n\t\t\t\t\tconst pos = entity.getPosition();\n\t\t\t\t\tcomponentData.channel.setPosition(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonRemove(entity, data) {\n\t\tif (data.channel) {\n\t\t\tdata.channel.stop();\n\t\t\tdata.channel = null;\n\t\t}\n\t}\n\n\tsetVolume(volume) {\n\t\tthis.manager.setVolume(volume);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('initialize', this.onInitialize, this);\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(AudioSourceComponent.prototype, _schema$i);\n\nclass EntityReference extends EventHandler {\n\tconstructor(parentComponent, entityPropertyName, eventConfig) {\n\t\tsuper();\n\n\t\tif (!parentComponent || !(parentComponent instanceof Component)) {\n\t\t\tthrow new Error('The parentComponent argument is required and must be a Component');\n\t\t} else if (!entityPropertyName || typeof entityPropertyName !== 'string') {\n\t\t\tthrow new Error('The propertyName argument is required and must be a string');\n\t\t} else if (eventConfig && typeof eventConfig !== 'object') {\n\t\t\tthrow new Error('If provided, the eventConfig argument must be an object');\n\t\t}\n\n\t\tthis._parentComponent = parentComponent;\n\t\tthis._entityPropertyName = entityPropertyName;\n\t\tthis._entity = null;\n\t\tthis._app = parentComponent.system.app;\n\n\t\tthis._configureEventListeners(eventConfig || {}, {\n\t\t\t'entity#destroy': this._onEntityDestroy\n\t\t});\n\n\t\tthis._toggleLifecycleListeners('on');\n\t}\n\n\t_configureEventListeners(externalEventConfig, internalEventConfig) {\n\t\tconst externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);\n\n\t\tconst internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);\n\n\t\tthis._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);\n\t\tthis._listenerStatusFlags = {};\n\t\tthis._gainListeners = {};\n\t\tthis._loseListeners = {};\n\t}\n\n\t_parseEventListenerConfig(eventConfig, prefix, scope) {\n\t\treturn Object.keys(eventConfig).map(function (listenerDescription, index) {\n\t\t\tconst listenerDescriptionParts = listenerDescription.split('#');\n\t\t\tconst sourceName = listenerDescriptionParts[0];\n\t\t\tconst eventName = listenerDescriptionParts[1];\n\t\t\tconst callback = eventConfig[listenerDescription];\n\n\t\t\tif (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {\n\t\t\t\tthrow new Error('Invalid event listener description: `' + listenerDescription + '`');\n\t\t\t}\n\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tid: prefix + '_' + index + '_' + listenerDescription,\n\t\t\t\tsourceName: sourceName,\n\t\t\t\teventName: eventName,\n\t\t\t\tcallback: callback,\n\t\t\t\tscope: scope\n\t\t\t};\n\t\t}, this);\n\t}\n\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);\n\n\t\tthis._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);\n\n\t\tthis._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);\n\n\t\tthis._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);\n\n\t\tconst allComponentSystems = [];\n\n\t\tfor (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n\t\t\tconst config = this._eventListenerConfigs[i];\n\t\t\tconst componentSystem = this._app.systems[config.sourceName];\n\n\t\t\tif (componentSystem) {\n\t\t\t\tif (allComponentSystems.indexOf(componentSystem) === -1) {\n\t\t\t\t\tallComponentSystems.push(componentSystem);\n\t\t\t\t}\n\n\t\t\t\tif (componentSystem && config.eventName === 'gain') {\n\t\t\t\t\tthis._gainListeners[config.sourceName] = config;\n\t\t\t\t}\n\n\t\t\t\tif (componentSystem && config.eventName === 'lose') {\n\t\t\t\t\tthis._loseListeners[config.sourceName] = config;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < allComponentSystems.length; ++i) {\n\t\t\tallComponentSystems[i][onOrOff]('add', this._onComponentAdd, this);\n\t\t\tallComponentSystems[i][onOrOff]('beforeremove', this._onComponentRemove, this);\n\t\t}\n\t}\n\n\t_onSetEntity(name, oldValue, newValue) {\n\t\tif (newValue instanceof Entity) {\n\t\t\tthis._updateEntityReference();\n\t\t} else {\n\t\t\tif (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {\n\t\t\t\tconsole.warn(\"Entity field `\" + this._entityPropertyName + \"` was set to unexpected type '\" + typeof newValue + \"'\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (oldValue !== newValue) {\n\t\t\t\tthis._updateEntityReference();\n\t\t\t}\n\t\t}\n\t}\n\n\tonParentComponentEnable() {\n\t\tif (!this._entity) {\n\t\t\tthis._updateEntityReference();\n\t\t}\n\t}\n\n\t_onSceneLoaded() {\n\t\tthis._updateEntityReference();\n\t}\n\n\t_updateEntityReference() {\n\t\tlet nextEntityGuid = this._parentComponent.data[this._entityPropertyName];\n\t\tlet nextEntity;\n\n\t\tif (nextEntityGuid instanceof Entity) {\n\t\t\tnextEntity = nextEntityGuid;\n\t\t\tnextEntityGuid = nextEntity.getGuid();\n\t\t\tthis._parentComponent.data[this._entityPropertyName] = nextEntityGuid;\n\t\t} else {\n\t\t\tconst root = this._parentComponent.system.app.root;\n\n\t\t\tconst isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);\n\n\t\t\tnextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;\n\t\t}\n\n\t\tconst hasChanged = this._entity !== nextEntity;\n\n\t\tif (hasChanged) {\n\t\t\tif (this._entity) {\n\t\t\t\tthis._onBeforeEntityChange();\n\t\t\t}\n\n\t\t\tthis._entity = nextEntity;\n\n\t\t\tif (this._entity) {\n\t\t\t\tthis._onAfterEntityChange();\n\t\t\t}\n\n\t\t\tthis.fire('set:entity', this._entity);\n\t\t}\n\t}\n\n\t_onBeforeEntityChange() {\n\t\tthis._toggleEntityListeners('off');\n\n\t\tthis._callAllGainOrLoseListeners(this._loseListeners);\n\t}\n\n\t_onAfterEntityChange() {\n\t\tthis._toggleEntityListeners('on');\n\n\t\tthis._callAllGainOrLoseListeners(this._gainListeners);\n\t}\n\n\t_onComponentAdd(entity, component) {\n\t\tconst componentName = component.system.id;\n\n\t\tif (entity === this._entity) {\n\t\t\tthis._callGainOrLoseListener(componentName, this._gainListeners);\n\n\t\t\tthis._toggleComponentListeners('on', componentName);\n\t\t}\n\t}\n\n\t_onComponentRemove(entity, component) {\n\t\tconst componentName = component.system.id;\n\n\t\tif (entity === this._entity) {\n\t\t\tthis._callGainOrLoseListener(componentName, this._loseListeners);\n\n\t\t\tthis._toggleComponentListeners('off', componentName, true);\n\t\t}\n\t}\n\n\t_callAllGainOrLoseListeners(listenerMap) {\n\t\tfor (const componentName in this._entity.c) {\n\t\t\tthis._callGainOrLoseListener(componentName, listenerMap);\n\t\t}\n\t}\n\n\t_callGainOrLoseListener(componentName, listenerMap) {\n\t\tif (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {\n\t\t\tconst config = listenerMap[componentName];\n\t\t\tconfig.callback.call(config.scope);\n\t\t}\n\t}\n\n\t_toggleEntityListeners(onOrOff, isDestroying) {\n\t\tif (this._entity) {\n\t\t\tfor (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n\t\t\t\tthis._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);\n\t\t\t}\n\t\t}\n\t}\n\n\t_toggleComponentListeners(onOrOff, componentName, isDestroying) {\n\t\tfor (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n\t\t\tconst config = this._eventListenerConfigs[i];\n\n\t\t\tif (config.sourceName === componentName) {\n\t\t\t\tthis._safeToggleListener(onOrOff, config, isDestroying);\n\t\t\t}\n\t\t}\n\t}\n\n\t_safeToggleListener(onOrOff, config, isDestroying) {\n\t\tconst isAdding = onOrOff === 'on';\n\n\t\tif (isAdding && this._listenerStatusFlags[config.id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst source = this._getEventSource(config.sourceName, isDestroying);\n\n\t\tif (source) {\n\t\t\tsource[onOrOff](config.eventName, config.callback, config.scope);\n\t\t\tthis._listenerStatusFlags[config.id] = isAdding;\n\t\t}\n\t}\n\n\t_getEventSource(sourceName, isDestroying) {\n\t\tif (sourceName === 'entity') {\n\t\t\treturn this._entity;\n\t\t}\n\n\t\tconst component = this._entity[sourceName];\n\n\t\tif (component) {\n\t\t\treturn component;\n\t\t}\n\n\t\tif (!isDestroying) {\n\t\t\tconsole.warn('Entity has no component with name ' + sourceName);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_onEntityDestroy(entity) {\n\t\tif (this._entity === entity) {\n\t\t\tthis._toggleEntityListeners('off', true);\n\n\t\t\tthis._entity = null;\n\t\t}\n\t}\n\n\t_onParentComponentRemove(entity, component) {\n\t\tif (component === this._parentComponent) {\n\t\t\tthis._toggleLifecycleListeners('off');\n\n\t\t\tthis._toggleEntityListeners('off', true);\n\t\t}\n\t}\n\n\thasComponent(componentName) {\n\t\treturn this._entity && this._entity.c ? !!this._entity.c[componentName] : false;\n\t}\n\n\tget entity() {\n\t\treturn this._entity;\n\t}\n\n}\n\nconst BUTTON_TRANSITION_MODE_TINT = 0;\nconst BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;\n\nconst ELEMENTTYPE_GROUP = 'group';\nconst ELEMENTTYPE_IMAGE = 'image';\nconst ELEMENTTYPE_TEXT = 'text';\n\nconst VisualState = {\n\tDEFAULT: 'DEFAULT',\n\tHOVER: 'HOVER',\n\tPRESSED: 'PRESSED',\n\tINACTIVE: 'INACTIVE'\n};\nconst STATES_TO_TINT_NAMES = {};\nSTATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';\nSTATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';\nSTATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';\nSTATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';\nconst STATES_TO_SPRITE_ASSET_NAMES = {};\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';\nconst STATES_TO_SPRITE_FRAME_NAMES = {};\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';\n\nclass ButtonComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._visualState = VisualState.DEFAULT;\n\t\tthis._isHovering = false;\n\t\tthis._hoveringCounter = 0;\n\t\tthis._isPressed = false;\n\t\tthis._defaultTint = new Color(1, 1, 1, 1);\n\t\tthis._defaultSpriteAsset = null;\n\t\tthis._defaultSpriteFrame = 0;\n\t\tthis._imageReference = new EntityReference(this, 'imageEntity', {\n\t\t\t'element#gain': this._onImageElementGain,\n\t\t\t'element#lose': this._onImageElementLose,\n\t\t\t'element#set:color': this._onSetColor,\n\t\t\t'element#set:opacity': this._onSetOpacity,\n\t\t\t'element#set:spriteAsset': this._onSetSpriteAsset,\n\t\t\t'element#set:spriteFrame': this._onSetSpriteFrame\n\t\t});\n\n\t\tthis._toggleLifecycleListeners('on', system);\n\t}\n\n\t_toggleLifecycleListeners(onOrOff, system) {\n\t\tthis[onOrOff]('set_active', this._onSetActive, this);\n\t\tthis[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);\n\t\tthis[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);\n\t\tsystem.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);\n\t\tsystem.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);\n\t}\n\n\t_onSetActive(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._updateVisualState();\n\t\t}\n\t}\n\n\t_onSetTransitionMode(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._cancelTween();\n\n\t\t\tthis._resetToDefaultVisualState(oldValue);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onSetTransitionValue(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onElementComponentRemove(entity) {\n\t\tif (this.entity === entity) {\n\t\t\tthis._toggleHitElementListeners('off');\n\t\t}\n\t}\n\n\t_onElementComponentAdd(entity) {\n\t\tif (this.entity === entity) {\n\t\t\tthis._toggleHitElementListeners('on');\n\t\t}\n\t}\n\n\t_onImageElementLose() {\n\t\tthis._cancelTween();\n\n\t\tthis._resetToDefaultVisualState(this.transitionMode);\n\t}\n\n\t_onImageElementGain() {\n\t\tthis._storeDefaultVisualState();\n\n\t\tthis._forceReapplyVisualState();\n\t}\n\n\t_toggleHitElementListeners(onOrOff) {\n\t\tif (this.entity.element) {\n\t\t\tconst isAdding = onOrOff === 'on';\n\n\t\t\tif (isAdding && this._hasHitElementListeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);\n\t\t\tthis.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);\n\t\t\tthis.entity.element[onOrOff]('mousedown', this._onMouseDown, this);\n\t\t\tthis.entity.element[onOrOff]('mouseup', this._onMouseUp, this);\n\t\t\tthis.entity.element[onOrOff]('touchstart', this._onTouchStart, this);\n\t\t\tthis.entity.element[onOrOff]('touchend', this._onTouchEnd, this);\n\t\t\tthis.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);\n\t\t\tthis.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);\n\t\t\tthis.entity.element[onOrOff]('selectstart', this._onSelectStart, this);\n\t\t\tthis.entity.element[onOrOff]('selectend', this._onSelectEnd, this);\n\t\t\tthis.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);\n\t\t\tthis.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);\n\t\t\tthis.entity.element[onOrOff]('click', this._onClick, this);\n\t\t\tthis._hasHitElementListeners = isAdding;\n\t\t}\n\t}\n\n\t_storeDefaultVisualState() {\n\t\tif (this._imageReference.hasComponent('element')) {\n\t\t\tconst element = this._imageReference.entity.element;\n\n\t\t\tif (element.type !== ELEMENTTYPE_GROUP) {\n\t\t\t\tthis._storeDefaultColor(element.color);\n\n\t\t\t\tthis._storeDefaultOpacity(element.opacity);\n\n\t\t\t\tthis._storeDefaultSpriteAsset(element.spriteAsset);\n\n\t\t\t\tthis._storeDefaultSpriteFrame(element.spriteFrame);\n\t\t\t}\n\t\t}\n\t}\n\n\t_storeDefaultColor(color) {\n\t\tthis._defaultTint.r = color.r;\n\t\tthis._defaultTint.g = color.g;\n\t\tthis._defaultTint.b = color.b;\n\t}\n\n\t_storeDefaultOpacity(opacity) {\n\t\tthis._defaultTint.a = opacity;\n\t}\n\n\t_storeDefaultSpriteAsset(spriteAsset) {\n\t\tthis._defaultSpriteAsset = spriteAsset;\n\t}\n\n\t_storeDefaultSpriteFrame(spriteFrame) {\n\t\tthis._defaultSpriteFrame = spriteFrame;\n\t}\n\n\t_onSetColor(color) {\n\t\tif (!this._isApplyingTint) {\n\t\t\tthis._storeDefaultColor(color);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onSetOpacity(opacity) {\n\t\tif (!this._isApplyingTint) {\n\t\t\tthis._storeDefaultOpacity(opacity);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onSetSpriteAsset(spriteAsset) {\n\t\tif (!this._isApplyingSprite) {\n\t\t\tthis._storeDefaultSpriteAsset(spriteAsset);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onSetSpriteFrame(spriteFrame) {\n\t\tif (!this._isApplyingSprite) {\n\t\t\tthis._storeDefaultSpriteFrame(spriteFrame);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onMouseEnter(event) {\n\t\tthis._isHovering = true;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('mouseenter', event);\n\t}\n\n\t_onMouseLeave(event) {\n\t\tthis._isHovering = false;\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('mouseleave', event);\n\t}\n\n\t_onMouseDown(event) {\n\t\tthis._isPressed = true;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('mousedown', event);\n\t}\n\n\t_onMouseUp(event) {\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('mouseup', event);\n\t}\n\n\t_onTouchStart(event) {\n\t\tthis._isPressed = true;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('touchstart', event);\n\t}\n\n\t_onTouchEnd(event) {\n\t\tevent.event.preventDefault();\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('touchend', event);\n\t}\n\n\t_onTouchLeave(event) {\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('touchleave', event);\n\t}\n\n\t_onTouchCancel(event) {\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('touchcancel', event);\n\t}\n\n\t_onSelectStart(event) {\n\t\tthis._isPressed = true;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('selectstart', event);\n\t}\n\n\t_onSelectEnd(event) {\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('selectend', event);\n\t}\n\n\t_onSelectEnter(event) {\n\t\tthis._hoveringCounter++;\n\n\t\tif (this._hoveringCounter === 1) {\n\t\t\tthis._isHovering = true;\n\n\t\t\tthis._updateVisualState();\n\t\t}\n\n\t\tthis._fireIfActive('selectenter', event);\n\t}\n\n\t_onSelectLeave(event) {\n\t\tthis._hoveringCounter--;\n\n\t\tif (this._hoveringCounter === 0) {\n\t\t\tthis._isHovering = false;\n\t\t\tthis._isPressed = false;\n\n\t\t\tthis._updateVisualState();\n\t\t}\n\n\t\tthis._fireIfActive('selectleave', event);\n\t}\n\n\t_onClick(event) {\n\t\tthis._fireIfActive('click', event);\n\t}\n\n\t_fireIfActive(name, event) {\n\t\tif (this.data.active) {\n\t\t\tthis.fire(name, event);\n\t\t}\n\t}\n\n\t_updateVisualState(force) {\n\t\tconst oldVisualState = this._visualState;\n\n\t\tconst newVisualState = this._determineVisualState();\n\n\t\tif ((oldVisualState !== newVisualState || force) && this.enabled) {\n\t\t\tthis._visualState = newVisualState;\n\n\t\t\tif (oldVisualState === VisualState.HOVER) {\n\t\t\t\tthis._fireIfActive('hoverend');\n\t\t\t}\n\n\t\t\tif (oldVisualState === VisualState.PRESSED) {\n\t\t\t\tthis._fireIfActive('pressedend');\n\t\t\t}\n\n\t\t\tif (newVisualState === VisualState.HOVER) {\n\t\t\t\tthis._fireIfActive('hoverstart');\n\t\t\t}\n\n\t\t\tif (newVisualState === VisualState.PRESSED) {\n\t\t\t\tthis._fireIfActive('pressedstart');\n\t\t\t}\n\n\t\t\tswitch (this.transitionMode) {\n\t\t\t\tcase BUTTON_TRANSITION_MODE_TINT:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst tintName = STATES_TO_TINT_NAMES[this._visualState];\n\t\t\t\t\t\tconst tintColor = this[tintName];\n\n\t\t\t\t\t\tthis._applyTint(tintColor);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase BUTTON_TRANSITION_MODE_SPRITE_CHANGE:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];\n\t\t\t\t\t\tconst spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];\n\t\t\t\t\t\tconst spriteAsset = this[spriteAssetName];\n\t\t\t\t\t\tconst spriteFrame = this[spriteFrameName];\n\n\t\t\t\t\t\tthis._applySprite(spriteAsset, spriteFrame);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_forceReapplyVisualState() {\n\t\tthis._updateVisualState(true);\n\t}\n\n\t_resetToDefaultVisualState(transitionMode) {\n\t\tif (this._imageReference.hasComponent('element')) {\n\t\t\tswitch (transitionMode) {\n\t\t\t\tcase BUTTON_TRANSITION_MODE_TINT:\n\t\t\t\t\tthis._cancelTween();\n\n\t\t\t\t\tthis._applyTintImmediately(this._defaultTint);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BUTTON_TRANSITION_MODE_SPRITE_CHANGE:\n\t\t\t\t\tthis._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_determineVisualState() {\n\t\tif (!this.active) {\n\t\t\treturn VisualState.INACTIVE;\n\t\t} else if (this._isPressed) {\n\t\t\treturn VisualState.PRESSED;\n\t\t} else if (this._isHovering) {\n\t\t\treturn VisualState.HOVER;\n\t\t}\n\n\t\treturn VisualState.DEFAULT;\n\t}\n\n\t_applySprite(spriteAsset, spriteFrame) {\n\t\tspriteFrame = spriteFrame || 0;\n\n\t\tif (this._imageReference.hasComponent('element')) {\n\t\t\tthis._isApplyingSprite = true;\n\n\t\t\tif (this._imageReference.entity.element.spriteAsset !== spriteAsset) {\n\t\t\t\tthis._imageReference.entity.element.spriteAsset = spriteAsset;\n\t\t\t}\n\n\t\t\tif (this._imageReference.entity.element.spriteFrame !== spriteFrame) {\n\t\t\t\tthis._imageReference.entity.element.spriteFrame = spriteFrame;\n\t\t\t}\n\n\t\t\tthis._isApplyingSprite = false;\n\t\t}\n\t}\n\n\t_applyTint(tintColor) {\n\t\tthis._cancelTween();\n\n\t\tif (this.fadeDuration === 0) {\n\t\t\tthis._applyTintImmediately(tintColor);\n\t\t} else {\n\t\t\tthis._applyTintWithTween(tintColor);\n\t\t}\n\t}\n\n\t_applyTintImmediately(tintColor) {\n\t\tif (!tintColor || !this._imageReference.hasComponent('element')) return;\n\t\tconst color3 = toColor3(tintColor);\n\t\tthis._isApplyingTint = true;\n\t\tif (!color3.equals(this._imageReference.entity.element.color)) this._imageReference.entity.element.color = color3;\n\t\tif (this._imageReference.entity.element.opacity != tintColor.a) this._imageReference.entity.element.opacity = tintColor.a;\n\t\tthis._isApplyingTint = false;\n\t}\n\n\t_applyTintWithTween(tintColor) {\n\t\tif (!tintColor || !this._imageReference.hasComponent('element')) return;\n\t\tconst color3 = toColor3(tintColor);\n\t\tconst color = this._imageReference.entity.element.color;\n\t\tconst opacity = this._imageReference.entity.element.opacity;\n\t\tif (color3.equals(color) && tintColor.a == opacity) return;\n\t\tthis._tweenInfo = {\n\t\t\tstartTime: now(),\n\t\t\tfrom: new Color(color.r, color.g, color.b, opacity),\n\t\t\tto: tintColor.clone(),\n\t\t\tlerpColor: new Color()\n\t\t};\n\t}\n\n\t_updateTintTween() {\n\t\tconst elapsedTime = now() - this._tweenInfo.startTime;\n\n\t\tlet elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;\n\t\telapsedProportion = math.clamp(elapsedProportion, 0, 1);\n\n\t\tif (Math.abs(elapsedProportion - 1) > 1e-5) {\n\t\t\tconst lerpColor = this._tweenInfo.lerpColor;\n\t\t\tlerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);\n\n\t\t\tthis._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));\n\t\t} else {\n\t\t\tthis._applyTintImmediately(this._tweenInfo.to);\n\n\t\t\tthis._cancelTween();\n\t\t}\n\t}\n\n\t_cancelTween() {\n\t\tdelete this._tweenInfo;\n\t}\n\n\tonUpdate() {\n\t\tif (this._tweenInfo) {\n\t\t\tthis._updateTintTween();\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tthis._isHovering = false;\n\t\tthis._hoveringCounter = 0;\n\t\tthis._isPressed = false;\n\n\t\tthis._imageReference.onParentComponentEnable();\n\n\t\tthis._toggleHitElementListeners('on');\n\n\t\tthis._forceReapplyVisualState();\n\t}\n\n\tonDisable() {\n\t\tthis._toggleHitElementListeners('off');\n\n\t\tthis._resetToDefaultVisualState(this.transitionMode);\n\t}\n\n\tonRemove() {\n\t\tthis._toggleLifecycleListeners('off', this.system);\n\n\t\tthis.onDisable();\n\t}\n\n}\n\nfunction toColor3(color4) {\n\treturn new Color(color4.r, color4.g, color4.b);\n}\n\nclass ButtonComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.active = true;\n\t\tthis.imageEntity = null;\n\t\tthis.hitPadding = new Vec4();\n\t\tthis.transitionMode = BUTTON_TRANSITION_MODE_TINT;\n\t\tthis.hoverTint = new Color(0.75, 0.75, 0.75);\n\t\tthis.pressedTint = new Color(0.5, 0.5, 0.5);\n\t\tthis.inactiveTint = new Color(0.25, 0.25, 0.25);\n\t\tthis.fadeDuration = 0;\n\t\tthis.hoverSpriteAsset = null;\n\t\tthis.hoverSpriteFrame = 0;\n\t\tthis.pressedSpriteAsset = null;\n\t\tthis.pressedSpriteFrame = 0;\n\t\tthis.inactiveSpriteAsset = null;\n\t\tthis.inactiveSpriteFrame = 0;\n\t}\n\n}\n\nconst _schema$h = ['enabled', 'active', {\n\tname: 'imageEntity',\n\ttype: 'entity'\n}, {\n\tname: 'hitPadding',\n\ttype: 'vec4'\n}, 'transitionMode', {\n\tname: 'hoverTint',\n\ttype: 'rgba'\n}, {\n\tname: 'pressedTint',\n\ttype: 'rgba'\n}, {\n\tname: 'inactiveTint',\n\ttype: 'rgba'\n}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];\n\nclass ButtonComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'button';\n\t\tthis.ComponentType = ButtonComponent;\n\t\tthis.DataType = ButtonComponentData;\n\t\tthis.schema = _schema$h;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tsuper.initializeComponentData(component, data, _schema$h);\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tconst entity = components[id].entity;\n\t\t\tconst component = entity.button;\n\n\t\t\tif (component.enabled && entity.enabled) {\n\t\t\t\tcomponent.onUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(ButtonComponent.prototype, _schema$h);\n\nlet depthLayer$1;\n\nclass PostEffect {\n\tconstructor(effect, inputTarget) {\n\t\tthis.effect = effect;\n\t\tthis.inputTarget = inputTarget;\n\t\tthis.outputTarget = null;\n\t\tthis.name = effect.constructor.name;\n\t}\n\n}\n\nclass PostEffectQueue {\n\tconstructor(app, camera) {\n\t\tthis.app = app;\n\t\tthis.camera = camera;\n\t\tthis.destinationRenderTarget = null;\n\t\tthis.effects = [];\n\t\tthis.enabled = false;\n\t\tthis.depthTarget = null;\n\t\tthis.renderTargetScale = 1;\n\t\tthis.resizeTimeout = null;\n\t\tthis.resizeLast = 0;\n\n\t\tthis._resizeTimeoutCallback = () => {\n\t\t\tthis.resizeRenderTargets();\n\t\t};\n\n\t\tcamera.on('set:rect', this.onCameraRectChanged, this);\n\t}\n\n\t_allocateColorBuffer(format, name) {\n\t\tconst rect = this.camera.rect;\n\t\tconst width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);\n\t\tconst height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);\n\t\tconst colorBuffer = new Texture(this.app.graphicsDevice, {\n\t\t\tformat: format,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tcolorBuffer.name = name;\n\t\treturn colorBuffer;\n\t}\n\n\t_createOffscreenTarget(useDepth, hdr) {\n\t\tconst device = this.app.graphicsDevice;\n\t\tconst format = hdr ? device.getHdrFormat() : PIXELFORMAT_R8_G8_B8_A8;\n\t\tconst name = this.camera.entity.name + '-posteffect-' + this.effects.length;\n\n\t\tconst colorBuffer = this._allocateColorBuffer(format, name);\n\n\t\tconst useStencil = this.app.graphicsDevice.supportsStencil;\n\t\tconst samples = useDepth ? device.samples : 1;\n\t\treturn new RenderTarget({\n\t\t\tcolorBuffer: colorBuffer,\n\t\t\tdepth: useDepth,\n\t\t\tstencil: useStencil,\n\t\t\tsamples: samples\n\t\t});\n\t}\n\n\t_resizeOffscreenTarget(rt) {\n\t\tconst format = rt.colorBuffer.format;\n\t\tconst name = rt.colorBuffer.name;\n\t\trt.destroyFrameBuffers();\n\t\trt.destroyTextureBuffers();\n\t\trt._colorBuffer = this._allocateColorBuffer(format, name);\n\t}\n\n\t_destroyOffscreenTarget(rt) {\n\t\trt.destroyTextureBuffers();\n\t\trt.destroy();\n\t}\n\n\tsetRenderTargetScale(scale) {\n\t\tthis.renderTargetScale = scale;\n\t\tthis.resizeRenderTargets();\n\t}\n\n\taddEffect(effect) {\n\t\tconst effects = this.effects;\n\t\tconst isFirstEffect = effects.length === 0;\n\n\t\tconst inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);\n\n\t\tconst newEntry = new PostEffect(effect, inputTarget);\n\t\teffects.push(newEntry);\n\t\tthis._sourceTarget = newEntry.inputTarget;\n\n\t\tif (effects.length > 1) {\n\t\t\teffects[effects.length - 2].outputTarget = newEntry.inputTarget;\n\t\t}\n\n\t\tthis._newPostEffect = effect;\n\n\t\tif (effect.needsDepthBuffer) {\n\t\t\tthis._requestDepthMap();\n\t\t}\n\n\t\tthis.enable();\n\t\tthis._newPostEffect = undefined;\n\t}\n\n\tremoveEffect(effect) {\n\t\tlet index = -1;\n\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tif (this.effects[i].effect === effect) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (index >= 0) {\n\t\t\tif (index > 0) {\n\t\t\t\tthis.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;\n\t\t\t} else {\n\t\t\t\tif (this.effects.length > 1) {\n\t\t\t\t\tif (!this.effects[1].inputTarget._depth) {\n\t\t\t\t\t\tthis._destroyOffscreenTarget(this.effects[1].inputTarget);\n\n\t\t\t\t\t\tthis.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);\n\t\t\t\t\t\tthis._sourceTarget = this.effects[1].inputTarget;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.camera.renderTarget = this.effects[1].inputTarget;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._destroyOffscreenTarget(this.effects[index].inputTarget);\n\n\t\t\tthis.effects.splice(index, 1);\n\t\t}\n\n\t\tif (this.enabled) {\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._releaseDepthMap();\n\t\t\t}\n\t\t}\n\n\t\tif (this.effects.length === 0) {\n\t\t\tthis.disable();\n\t\t}\n\t}\n\n\t_requestDepthMaps() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tconst effect = this.effects[i].effect;\n\t\t\tif (this._newPostEffect === effect) continue;\n\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._requestDepthMap();\n\t\t\t}\n\t\t}\n\t}\n\n\t_releaseDepthMaps() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tconst effect = this.effects[i].effect;\n\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._releaseDepthMap();\n\t\t\t}\n\t\t}\n\t}\n\n\t_requestDepthMap() {\n\t\tif (!depthLayer$1) depthLayer$1 = this.app.scene.layers.getLayerById(LAYERID_DEPTH);\n\t\tif (depthLayer$1) depthLayer$1.incrementCounter();\n\t}\n\n\t_releaseDepthMap() {\n\t\tif (depthLayer$1) depthLayer$1.decrementCounter();\n\t}\n\n\tdestroy() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tthis.effects[i].inputTarget.destroy();\n\t\t}\n\n\t\tthis.effects.length = 0;\n\t\tthis.disable();\n\t}\n\n\tenable() {\n\t\tif (!this.enabled && this.effects.length) {\n\t\t\tthis.enabled = true;\n\n\t\t\tthis._requestDepthMaps();\n\n\t\t\tthis.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);\n\t\t\tthis.destinationRenderTarget = this.camera.renderTarget;\n\t\t\tthis.camera.renderTarget = this.effects[0].inputTarget;\n\n\t\t\tthis.camera.onPostprocessing = () => {\n\t\t\t\tif (this.enabled) {\n\t\t\t\t\tlet rect = null;\n\t\t\t\t\tconst len = this.effects.length;\n\n\t\t\t\t\tif (len) {\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tconst fx = this.effects[i];\n\t\t\t\t\t\t\tlet destTarget = fx.outputTarget;\n\n\t\t\t\t\t\t\tif (i === len - 1) {\n\t\t\t\t\t\t\t\trect = this.camera.rect;\n\n\t\t\t\t\t\t\t\tif (this.destinationRenderTarget) {\n\t\t\t\t\t\t\t\t\tdestTarget = this.destinationRenderTarget;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfx.effect.render(fx.inputTarget, destTarget, rect);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tdisable() {\n\t\tif (this.enabled) {\n\t\t\tthis.enabled = false;\n\t\t\tthis.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);\n\n\t\t\tthis._releaseDepthMaps();\n\n\t\t\tthis._destroyOffscreenTarget(this._sourceTarget);\n\n\t\t\tthis.camera.renderTarget = null;\n\t\t\tthis.camera.onPostprocessing = null;\n\t\t}\n\t}\n\n\t_onCanvasResized(width, height) {\n\t\tconst rect = this.camera.rect;\n\t\tconst device = this.app.graphicsDevice;\n\t\tthis.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);\n\t\tif (this.resizeTimeout) return;\n\n\t\tif (now() - this.resizeLast > 100) {\n\t\t\tthis.resizeRenderTargets();\n\t\t} else {\n\t\t\tthis.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);\n\t\t}\n\t}\n\n\tresizeRenderTargets() {\n\t\tif (this.resizeTimeout) {\n\t\t\tclearTimeout(this.resizeTimeout);\n\t\t\tthis.resizeTimeout = null;\n\t\t}\n\n\t\tthis.resizeLast = now();\n\t\tconst rect = this.camera.rect;\n\t\tconst desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);\n\t\tconst desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);\n\t\tconst effects = this.effects;\n\n\t\tfor (let i = 0, len = effects.length; i < len; i++) {\n\t\t\tconst fx = effects[i];\n\n\t\t\tif (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {\n\t\t\t\tthis._resizeOffscreenTarget(fx.inputTarget);\n\t\t\t}\n\t\t}\n\t}\n\n\tonCameraRectChanged(name, oldValue, newValue) {\n\t\tif (this.enabled) {\n\t\t\tthis.resizeRenderTargets();\n\t\t}\n\t}\n\n}\n\nconst properties$1 = [{\n\tname: 'aspectRatio',\n\treadonly: false\n}, {\n\tname: 'aspectRatioMode',\n\treadonly: false\n}, {\n\tname: 'calculateProjection',\n\treadonly: false\n}, {\n\tname: 'calculateTransform',\n\treadonly: false\n}, {\n\tname: 'clearColor',\n\treadonly: false\n}, {\n\tname: 'cullFaces',\n\treadonly: false\n}, {\n\tname: 'farClip',\n\treadonly: false\n}, {\n\tname: 'flipFaces',\n\treadonly: false\n}, {\n\tname: 'fov',\n\treadonly: false\n}, {\n\tname: 'frustumCulling',\n\treadonly: false\n}, {\n\tname: 'horizontalFov',\n\treadonly: false\n}, {\n\tname: 'nearClip',\n\treadonly: false\n}, {\n\tname: 'orthoHeight',\n\treadonly: false\n}, {\n\tname: 'projection',\n\treadonly: false\n}, {\n\tname: 'scissorRect',\n\treadonly: false\n}, {\n\tname: 'vrDisplay',\n\treadonly: false\n}];\n\nclass CameraComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.onPostprocessing = null;\n\t\tthis.onPreRender = null;\n\t\tthis.onPostRender = null;\n\t\tthis._camera = new Camera();\n\t\tthis._camera.node = entity;\n\t\tthis._priority = 0;\n\t\tthis._disablePostEffectsLayer = LAYERID_UI;\n\t\tthis._postEffects = new PostEffectQueue(system.app, this);\n\t}\n\n\tget camera() {\n\t\treturn this._camera;\n\t}\n\n\tset clearColorBuffer(value) {\n\t\tthis._camera.clearColorBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget clearColorBuffer() {\n\t\treturn this._camera.clearColorBuffer;\n\t}\n\n\tset clearDepthBuffer(value) {\n\t\tthis._camera.clearDepthBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget clearDepthBuffer() {\n\t\treturn this._camera.clearDepthBuffer;\n\t}\n\n\tset clearStencilBuffer(value) {\n\t\tthis._camera.clearStencilBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget clearStencilBuffer() {\n\t\treturn this._camera.clearStencilBuffer;\n\t}\n\n\tset disablePostEffectsLayer(layer) {\n\t\tthis._disablePostEffectsLayer = layer;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget disablePostEffectsLayer() {\n\t\treturn this._disablePostEffectsLayer;\n\t}\n\n\tget frustum() {\n\t\treturn this._camera.frustum;\n\t}\n\n\tset layers(newValue) {\n\t\tconst layers = this._camera.layers;\n\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeCamera(this);\n\t\t}\n\n\t\tthis._camera.layers = newValue;\n\t\tif (!this.enabled || !this.entity.enabled) return;\n\n\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addCamera(this);\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._camera.layers;\n\t}\n\n\tget postEffectsEnabled() {\n\t\treturn this._postEffects.enabled;\n\t}\n\n\tget postEffects() {\n\t\treturn this._postEffects;\n\t}\n\n\tset priority(newValue) {\n\t\tthis._priority = newValue;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\n\tget projectionMatrix() {\n\t\treturn this._camera.projectionMatrix;\n\t}\n\n\tset rect(value) {\n\t\tthis._camera.rect = value;\n\t\tthis.fire('set:rect', this._camera.rect);\n\t}\n\n\tget rect() {\n\t\treturn this._camera.rect;\n\t}\n\n\tset renderTarget(value) {\n\t\tthis._camera.renderTarget = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget renderTarget() {\n\t\treturn this._camera.renderTarget;\n\t}\n\n\tget viewMatrix() {\n\t\treturn this._camera.viewMatrix;\n\t}\n\n\tdirtyLayerCompositionCameras() {\n\t\tconst layerComp = this.system.app.scene.layers;\n\t\tlayerComp._dirtyCameras = true;\n\t}\n\n\tscreenToWorld(screenx, screeny, cameraz, worldCoord) {\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst w = device.clientRect.width;\n\t\tconst h = device.clientRect.height;\n\t\treturn this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);\n\t}\n\n\tworldToScreen(worldCoord, screenCoord) {\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst w = device.clientRect.width;\n\t\tconst h = device.clientRect.height;\n\t\treturn this._camera.worldToScreen(worldCoord, w, h, screenCoord);\n\t}\n\n\tonAppPrerender() {\n\t\tthis._camera._viewMatDirty = true;\n\t\tthis._camera._viewProjMatDirty = true;\n\t}\n\n\taddCameraToLayers() {\n\t\tconst layers = this.layers;\n\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addCamera(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveCameraFromLayers() {\n\t\tconst layers = this.layers;\n\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeCamera(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addCameraToLayers();\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addCamera(this);\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeCamera(this);\n\t}\n\n\tonEnable() {\n\t\tconst system = this.system;\n\t\tconst scene = system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tsystem.addCamera(this);\n\t\tscene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (layers) {\n\t\t\tlayers.on(\"add\", this.onLayerAdded, this);\n\t\t\tlayers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addCameraToLayers();\n\t\t}\n\n\t\tthis.postEffects.enable();\n\t}\n\n\tonDisable() {\n\t\tconst system = this.system;\n\t\tconst scene = system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tthis.postEffects.disable();\n\t\tthis.removeCameraFromLayers();\n\t\tscene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (layers) {\n\t\t\tlayers.off(\"add\", this.onLayerAdded, this);\n\t\t\tlayers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tsystem.removeCamera(this);\n\t}\n\n\tonRemove() {\n\t\tthis.onDisable();\n\t\tthis.off();\n\t}\n\n\tcalculateAspectRatio(rt) {\n\t\tconst src = rt ? rt : this.system.app.graphicsDevice;\n\t\tconst rect = this.rect;\n\t\treturn src.width * rect.z / (src.height * rect.w);\n\t}\n\n\tframeBegin(rt) {\n\t\tif (this.aspectRatioMode === ASPECT_AUTO) {\n\t\t\tthis.aspectRatio = this.calculateAspectRatio(rt);\n\t\t}\n\t}\n\n\tframeEnd() {}\n\n\tenterVr(display, callback) {\n\t\tif (display instanceof Function && !callback) {\n\t\t\tcallback = display;\n\t\t\tdisplay = null;\n\t\t}\n\n\t\tif (!this.system.app.vr) {\n\t\t\tcallback(\"VrManager not created. Enable VR in project settings.\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!display) {\n\t\t\tdisplay = this.system.app.vr.display;\n\t\t}\n\n\t\tif (display) {\n\t\t\tconst self = this;\n\n\t\t\tif (display.capabilities.canPresent) {\n\t\t\t\tdisplay.requestPresent(function (err) {\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tself.vrDisplay = display;\n\t\t\t\t\t\tself.vrDisplay.once('beforepresentchange', function (display) {\n\t\t\t\t\t\t\tif (!display.presenting) {\n\t\t\t\t\t\t\t\tself.vrDisplay = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback(err);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tself.vrDisplay = display;\n\t\t\t\tcallback();\n\t\t\t}\n\t\t} else {\n\t\t\tcallback(\"No pc.VrDisplay to present\");\n\t\t}\n\t}\n\n\texitVr(callback) {\n\t\tif (this.vrDisplay) {\n\t\t\tif (this.vrDisplay.capabilities.canPresent) {\n\t\t\t\tconst display = this.vrDisplay;\n\t\t\t\tthis.vrDisplay = null;\n\t\t\t\tdisplay.exitPresent(callback);\n\t\t\t} else {\n\t\t\t\tthis.vrDisplay = null;\n\t\t\t\tcallback();\n\t\t\t}\n\t\t} else {\n\t\t\tcallback(\"Not presenting VR\");\n\t\t}\n\t}\n\n\tstartXr(type, spaceType, options) {\n\t\tthis.system.app.xr.start(this, type, spaceType, options);\n\t}\n\n\tendXr(callback) {\n\t\tif (!this._camera.xr) {\n\t\t\tif (callback) callback(new Error(\"Camera is not in XR\"));\n\t\t\treturn;\n\t\t}\n\n\t\tthis._camera.xr.end(callback);\n\t}\n\n\tcopy(source) {\n\t\tproperties$1.forEach(property => {\n\t\t\tif (!property.readonly) {\n\t\t\t\tconst name = property.name;\n\t\t\t\tthis[name] = source[name];\n\t\t\t}\n\t\t});\n\t\tthis.clearColorBuffer = source.clearColorBuffer;\n\t\tthis.clearDepthBuffer = source.clearDepthBuffer;\n\t\tthis.clearStencilBuffer = source.clearStencilBuffer;\n\t\tthis.disablePostEffectsLayer = source.disablePostEffectsLayer;\n\t\tthis.layers = source.layers;\n\t\tthis.priority = source.priority;\n\t\tthis.renderTarget = source.renderTarget;\n\t\tthis.rect = source.rect;\n\t}\n\n}\n\nproperties$1.forEach(function (property) {\n\tconst name = property.name;\n\tconst options = {};\n\n\toptions.get = function () {\n\t\treturn this._camera[name];\n\t};\n\n\tif (!property.readonly) {\n\t\toptions.set = function (newValue) {\n\t\t\tthis._camera[name] = newValue;\n\t\t};\n\t}\n\n\tObject.defineProperty(CameraComponent.prototype, name, options);\n});\n\nclass CameraComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$g = ['enabled'];\n\nclass CameraComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'camera';\n\t\tthis.ComponentType = CameraComponent;\n\t\tthis.DataType = CameraComponentData;\n\t\tthis.schema = _schema$g;\n\t\tthis.cameras = [];\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.on('prerender', this.onAppPrerender, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect'];\n\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tconst property = properties[i];\n\n\t\t\tif (data.hasOwnProperty(property)) {\n\t\t\t\tconst value = data[property];\n\n\t\t\t\tswitch (property) {\n\t\t\t\t\tcase 'rect':\n\t\t\t\t\tcase 'scissorRect':\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tcomponent[property] = new Vec4(value[0], value[1], value[2], value[3]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'clearColor':\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tcomponent[property] = new Color(value[0], value[1], value[2], value[3]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst c = entity.camera;\n\t\tthis.addComponent(clone, {\n\t\t\taspectRatio: c.aspectRatio,\n\t\t\taspectRatioMode: c.aspectRatioMode,\n\t\t\tcalculateProjection: c.calculateProjection,\n\t\t\tcalculateTransform: c.calculateTransform,\n\t\t\tclearColor: c.clearColor,\n\t\t\tclearColorBuffer: c.clearColorBuffer,\n\t\t\tclearDepthBuffer: c.clearDepthBuffer,\n\t\t\tclearStencilBuffer: c.clearStencilBuffer,\n\t\t\tcullFaces: c.cullFaces,\n\t\t\tenabled: c.enabled,\n\t\t\tfarClip: c.farClip,\n\t\t\tflipFaces: c.flipFaces,\n\t\t\tfov: c.fov,\n\t\t\tfrustumCulling: c.frustumCulling,\n\t\t\thorizontalFov: c.horizontalFov,\n\t\t\tlayers: c.layers,\n\t\t\trenderTarget: c.renderTarget,\n\t\t\tnearClip: c.nearClip,\n\t\t\torthoHeight: c.orthoHeight,\n\t\t\tprojection: c.projection,\n\t\t\tpriority: c.priority,\n\t\t\trect: c.rect,\n\t\t\tscissorRect: c.scissorRect\n\t\t});\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tthis.removeCamera(component);\n\t}\n\n\tonUpdate(dt) {\n\t\tif (this.app.vr) {\n\t\t\tconst components = this.store;\n\n\t\t\tfor (const id in components) {\n\t\t\t\tconst component = components[id];\n\n\t\t\t\tif (component.data.enabled && component.entity.enabled) {\n\t\t\t\t\tconst cameraComponent = component.entity.camera;\n\t\t\t\t\tconst vrDisplay = cameraComponent.vrDisplay;\n\n\t\t\t\t\tif (vrDisplay) {\n\t\t\t\t\t\tvrDisplay.setClipPlanes(cameraComponent.nearClip, cameraComponent.farClip);\n\n\t\t\t\t\t\tif (component.entity) {\n\t\t\t\t\t\t\tcomponent.entity.localTransform.copy(vrDisplay.combinedViewInv);\n\t\t\t\t\t\t\tcomponent.entity._dirtyLocal = false;\n\n\t\t\t\t\t\t\tcomponent.entity._dirtifyWorld();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonAppPrerender() {\n\t\tfor (let i = 0, len = this.cameras.length; i < len; i++) {\n\t\t\tthis.cameras[i].onAppPrerender();\n\t\t}\n\t}\n\n\taddCamera(camera) {\n\t\tthis.cameras.push(camera);\n\t\tthis.sortCamerasByPriority();\n\t}\n\n\tremoveCamera(camera) {\n\t\tconst index = this.cameras.indexOf(camera);\n\n\t\tif (index >= 0) {\n\t\t\tthis.cameras.splice(index, 1);\n\t\t\tthis.sortCamerasByPriority();\n\t\t}\n\t}\n\n\tsortCamerasByPriority() {\n\t\tthis.cameras.sort(function (a, b) {\n\t\t\treturn a.priority - b.priority;\n\t\t});\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(CameraComponent.prototype, _schema$g);\n\nclass CollisionComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._compoundParent = null;\n\t\tthis.entity.on('insert', this._onInsert, this);\n\t\tthis.on('set_type', this.onSetType, this);\n\t\tthis.on('set_halfExtents', this.onSetHalfExtents, this);\n\t\tthis.on('set_radius', this.onSetRadius, this);\n\t\tthis.on('set_height', this.onSetHeight, this);\n\t\tthis.on('set_axis', this.onSetAxis, this);\n\t\tthis.on(\"set_asset\", this.onSetAsset, this);\n\t\tthis.on(\"set_renderAsset\", this.onSetRenderAsset, this);\n\t\tthis.on(\"set_model\", this.onSetModel, this);\n\t\tthis.on(\"set_render\", this.onSetRender, this);\n\t}\n\n\tonSetType(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis.system.changeType(this, oldValue, newValue);\n\t\t}\n\t}\n\n\tonSetHalfExtents(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\n\t\tif (this.data.initialized && t === 'box') {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetRadius(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\n\t\tif (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetHeight(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\n\t\tif (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetAxis(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\n\t\tif (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.asset = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(this.data.asset);\n\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tif (!newValue) {\n\t\t\t\tthis.data.model = null;\n\t\t\t}\n\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetRenderAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.renderAsset = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(this.data.renderAsset);\n\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onRenderAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tif (!newValue) {\n\t\t\t\tthis.data.render = null;\n\t\t\t}\n\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetModel(name, oldValue, newValue) {\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tthis.system.implementations.mesh.doRecreatePhysicalShape(this);\n\t\t}\n\t}\n\n\tonSetRender(name, oldValue, newValue) {\n\t\tthis.onSetModel(name, oldValue, newValue);\n\t}\n\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\n\t\tif (this.data.asset === asset.id) {\n\t\t\tthis.asset = null;\n\t\t}\n\t}\n\n\tonRenderAssetRemoved(asset) {\n\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\n\t\tif (this.data.renderAsset === asset.id) {\n\t\t\tthis.renderAsset = null;\n\t\t}\n\t}\n\n\t_getCompoundChildShapeIndex(shape) {\n\t\tconst compound = this.data.shape;\n\t\tconst shapes = compound.getNumChildShapes();\n\n\t\tfor (let i = 0; i < shapes; i++) {\n\t\t\tconst childShape = compound.getChildShape(i);\n\n\t\t\tif (childShape.ptr === shape.ptr) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_onInsert(parent) {\n\t\tif (typeof Ammo === 'undefined') return;\n\n\t\tif (this._compoundParent) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t} else if (!this.entity.rigidbody) {\n\t\t\tlet ancestor = this.entity.parent;\n\n\t\t\twhile (ancestor) {\n\t\t\t\tif (ancestor.collision && ancestor.collision.type === 'compound') {\n\t\t\t\t\tif (ancestor.collision.shape.getNumChildShapes() === 0) {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(ancestor.collision);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tancestor = ancestor.parent;\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateCompound() {\n\t\tconst entity = this.entity;\n\n\t\tif (entity._dirtyWorld) {\n\t\t\tlet dirty = entity._dirtyLocal;\n\t\t\tlet parent = entity;\n\n\t\t\twhile (parent && !dirty) {\n\t\t\t\tif (parent.collision && parent.collision === this._compoundParent) break;\n\t\t\t\tif (parent._dirtyLocal) dirty = true;\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\n\t\t\tif (dirty) {\n\t\t\t\tentity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);\n\t\t\t\tconst bodyComponent = this._compoundParent.entity.rigidbody;\n\t\t\t\tif (bodyComponent) bodyComponent.activate();\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tif (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {\n\t\t\tconst asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);\n\n\t\t\tif (asset && (!asset.resource || !this.data.shape)) {\n\t\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.entity.rigidbody) {\n\t\t\tif (this.entity.rigidbody.enabled) {\n\t\t\t\tthis.entity.rigidbody.enableSimulation();\n\t\t\t}\n\t\t} else if (this._compoundParent && this !== this._compoundParent) {\n\t\t\tif (this._compoundParent.shape.getNumChildShapes() === 0) {\n\t\t\t\tthis.system.recreatePhysicalShapes(this._compoundParent);\n\t\t\t} else {\n\t\t\t\tconst transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);\n\n\t\t\t\tthis._compoundParent.shape.addChildShape(transform, this.data.shape);\n\n\t\t\t\tAmmo.destroy(transform);\n\t\t\t\tif (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();\n\t\t\t}\n\t\t} else if (this.entity.trigger) {\n\t\t\tthis.entity.trigger.enable();\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tif (this.entity.rigidbody) {\n\t\t\tthis.entity.rigidbody.disableSimulation();\n\t\t} else if (this._compoundParent && this !== this._compoundParent) {\n\t\t\tif (!this._compoundParent.entity._destroying) {\n\t\t\t\tthis.system._removeCompoundChild(this._compoundParent, this.data.shape);\n\n\t\t\t\tif (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();\n\t\t\t}\n\t\t} else if (this.entity.trigger) {\n\t\t\tthis.entity.trigger.disable();\n\t\t}\n\t}\n\n\tonBeforeRemove() {\n\t\tif (this.asset) {\n\t\t\tthis.asset = null;\n\t\t}\n\n\t\tif (this.renderAsset) {\n\t\t\tthis.renderAsset = null;\n\t\t}\n\n\t\tthis.entity.off('insert', this._onInsert, this);\n\t\tthis.off();\n\t}\n\n}\n\nclass CollisionComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.type = 'box';\n\t\tthis.halfExtents = new Vec3(0.5, 0.5, 0.5);\n\t\tthis.radius = 0.5;\n\t\tthis.axis = 1;\n\t\tthis.height = 2;\n\t\tthis.asset = null;\n\t\tthis.renderAsset = null;\n\t\tthis.shape = null;\n\t\tthis.model = null;\n\t\tthis.render = null;\n\t\tthis.initialized = false;\n\t}\n\n}\n\nconst BODYTYPE_STATIC = 'static';\nconst BODYTYPE_DYNAMIC = 'dynamic';\nconst BODYTYPE_KINEMATIC = 'kinematic';\nconst BODYFLAG_STATIC_OBJECT = 1;\nconst BODYFLAG_KINEMATIC_OBJECT = 2;\nconst BODYFLAG_NORESPONSE_OBJECT = 4;\nconst BODYSTATE_ACTIVE_TAG = 1;\nconst BODYSTATE_ISLAND_SLEEPING = 2;\nconst BODYSTATE_WANTS_DEACTIVATION = 3;\nconst BODYSTATE_DISABLE_DEACTIVATION = 4;\nconst BODYSTATE_DISABLE_SIMULATION = 5;\nconst BODYGROUP_NONE = 0;\nconst BODYGROUP_DEFAULT = 1;\nconst BODYGROUP_DYNAMIC = 1;\nconst BODYGROUP_STATIC = 2;\nconst BODYGROUP_KINEMATIC = 4;\nconst BODYGROUP_ENGINE_1 = 8;\nconst BODYGROUP_TRIGGER = 16;\nconst BODYGROUP_ENGINE_2 = 32;\nconst BODYGROUP_ENGINE_3 = 64;\nconst BODYGROUP_USER_1 = 128;\nconst BODYGROUP_USER_2 = 256;\nconst BODYGROUP_USER_3 = 512;\nconst BODYGROUP_USER_4 = 1024;\nconst BODYGROUP_USER_5 = 2048;\nconst BODYGROUP_USER_6 = 4096;\nconst BODYGROUP_USER_7 = 8192;\nconst BODYGROUP_USER_8 = 16384;\nconst BODYMASK_NONE = 0;\nconst BODYMASK_ALL = 65535;\nconst BODYMASK_STATIC = 2;\nconst BODYMASK_NOT_STATIC = 65535 ^ 2;\nconst BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);\n\nlet ammoVec1$1, ammoQuat$1, ammoTransform$1;\n\nclass Trigger {\n\tconstructor(app, component, data) {\n\t\tthis.entity = component.entity;\n\t\tthis.component = component;\n\t\tthis.app = app;\n\n\t\tif (typeof Ammo !== 'undefined' && !ammoVec1$1) {\n\t\t\tammoVec1$1 = new Ammo.btVector3();\n\t\t\tammoQuat$1 = new Ammo.btQuaternion();\n\t\t\tammoTransform$1 = new Ammo.btTransform();\n\t\t}\n\n\t\tthis.initialize(data);\n\t}\n\n\tinitialize(data) {\n\t\tconst entity = this.entity;\n\t\tconst shape = data.shape;\n\n\t\tif (shape && typeof Ammo !== 'undefined') {\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t}\n\n\t\t\tconst mass = 1;\n\t\t\tconst pos = entity.getPosition();\n\t\t\tconst rot = entity.getRotation();\n\t\t\tammoVec1$1.setValue(pos.x, pos.y, pos.z);\n\t\t\tammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\t\tammoTransform$1.setOrigin(ammoVec1$1);\n\t\t\tammoTransform$1.setRotation(ammoQuat$1);\n\t\t\tconst body = this.app.systems.rigidbody.createBody(mass, shape, ammoTransform$1);\n\t\t\tbody.setRestitution(0);\n\t\t\tbody.setFriction(0);\n\t\t\tbody.setDamping(0, 0);\n\t\t\tammoVec1$1.setValue(0, 0, 0);\n\t\t\tbody.setLinearFactor(ammoVec1$1);\n\t\t\tbody.setAngularFactor(ammoVec1$1);\n\t\t\tbody.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);\n\t\t\tbody.entity = entity;\n\t\t\tthis.body = body;\n\n\t\t\tif (this.component.enabled && entity.enabled) {\n\t\t\t\tthis.enable();\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tthis.disable();\n\t\tthis.app.systems.rigidbody.destroyBody(body);\n\t}\n\n\t_getEntityTransform(transform) {\n\t\tconst pos = this.entity.getPosition();\n\t\tconst rot = this.entity.getRotation();\n\t\tammoVec1$1.setValue(pos.x, pos.y, pos.z);\n\t\tammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\ttransform.setOrigin(ammoVec1$1);\n\t\ttransform.setRotation(ammoQuat$1);\n\t}\n\n\tupdateTransform() {\n\t\tthis._getEntityTransform(ammoTransform$1);\n\n\t\tconst body = this.body;\n\t\tbody.setWorldTransform(ammoTransform$1);\n\t\tbody.activate();\n\t}\n\n\tenable() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tconst systems = this.app.systems;\n\t\tsystems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);\n\n\t\tsystems.rigidbody._triggers.push(this);\n\n\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\tthis.updateTransform();\n\t}\n\n\tdisable() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tconst systems = this.app.systems;\n\n\t\tconst idx = systems.rigidbody._triggers.indexOf(this);\n\n\t\tif (idx > -1) {\n\t\t\tsystems.rigidbody._triggers.splice(idx, 1);\n\t\t}\n\n\t\tsystems.rigidbody.removeBody(body);\n\t\tbody.forceActivationState(BODYSTATE_DISABLE_SIMULATION);\n\t}\n\n}\n\nconst mat4 = new Mat4();\nconst vec3 = new Vec3();\nconst quat = new Quat();\nconst tempGraphNode = new GraphNode();\nconst _schema$f = ['enabled', 'type', 'halfExtents', 'radius', 'axis', 'height', 'asset', 'renderAsset', 'shape', 'model', 'render'];\n\nclass CollisionSystemImpl {\n\tconstructor(system) {\n\t\tthis.system = system;\n\t}\n\n\tbeforeInitialize(component, data) {\n\t\tdata.shape = null;\n\t\tdata.model = new Model();\n\t\tdata.model.graph = new GraphNode();\n\t}\n\n\tafterInitialize(component, data) {\n\t\tthis.recreatePhysicalShapes(component);\n\t\tcomponent.data.initialized = true;\n\t}\n\n\treset(component, data) {\n\t\tthis.beforeInitialize(component, data);\n\t\tthis.afterInitialize(component, data);\n\t}\n\n\trecreatePhysicalShapes(component) {\n\t\tconst entity = component.entity;\n\t\tconst data = component.data;\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t\tdelete entity.trigger;\n\t\t\t}\n\n\t\t\tif (data.shape) {\n\t\t\t\tif (component._compoundParent) {\n\t\t\t\t\tthis.system._removeCompoundChild(component._compoundParent, data.shape);\n\n\t\t\t\t\tif (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n\t\t\t\t}\n\n\t\t\t\tAmmo.destroy(data.shape);\n\t\t\t\tdata.shape = null;\n\t\t\t}\n\n\t\t\tdata.shape = this.createPhysicalShape(component.entity, data);\n\t\t\tconst firstCompoundChild = !component._compoundParent;\n\n\t\t\tif (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {\n\t\t\t\tcomponent._compoundParent = component;\n\t\t\t\tentity.forEach(this._addEachDescendant, component);\n\t\t\t} else if (data.type !== 'compound') {\n\t\t\t\tif (component._compoundParent && component === component._compoundParent) {\n\t\t\t\t\tentity.forEach(this.system.implementations.compound._updateEachDescendant, component);\n\t\t\t\t}\n\n\t\t\t\tif (!component.rigidbody) {\n\t\t\t\t\tcomponent._compoundParent = null;\n\t\t\t\t\tlet parent = entity.parent;\n\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.collision && parent.collision.type === 'compound') {\n\t\t\t\t\t\t\tcomponent._compoundParent = parent.collision;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (component._compoundParent) {\n\t\t\t\tif (component !== component._compoundParent) {\n\t\t\t\t\tif (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(component._compoundParent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.system.updateCompoundChildTransform(entity);\n\t\t\t\t\t\tif (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (entity.rigidbody) {\n\t\t\t\tentity.rigidbody.disableSimulation();\n\t\t\t\tentity.rigidbody.createBody();\n\n\t\t\t\tif (entity.enabled && entity.rigidbody.enabled) {\n\t\t\t\t\tentity.rigidbody.enableSimulation();\n\t\t\t\t}\n\t\t\t} else if (!component._compoundParent) {\n\t\t\t\tif (!entity.trigger) {\n\t\t\t\t\tentity.trigger = new Trigger(this.system.app, component, data);\n\t\t\t\t} else {\n\t\t\t\t\tentity.trigger.initialize(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcreatePhysicalShape(entity, data) {\n\t\treturn undefined;\n\t}\n\n\tupdateTransform(component, position, rotation, scale) {\n\t\tif (component.entity.trigger) {\n\t\t\tcomponent.entity.trigger.updateTransform();\n\t\t}\n\t}\n\n\tbeforeRemove(entity, component) {\n\t\tif (component.data.shape) {\n\t\t\tif (component._compoundParent && !component._compoundParent.entity._destroying) {\n\t\t\t\tthis.system._removeCompoundChild(component._compoundParent, component.data.shape);\n\n\t\t\t\tif (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n\t\t\t}\n\n\t\t\tcomponent._compoundParent = null;\n\t\t\tAmmo.destroy(component.data.shape);\n\t\t\tcomponent.data.shape = null;\n\t\t}\n\t}\n\n\tremove(entity, data) {\n\t\tconst app = this.system.app;\n\n\t\tif (entity.rigidbody && entity.rigidbody.body) {\n\t\t\tentity.rigidbody.disableSimulation();\n\t\t}\n\n\t\tif (entity.trigger) {\n\t\t\tentity.trigger.destroy();\n\t\t\tdelete entity.trigger;\n\t\t}\n\n\t\tif (app.scene.containsModel(data.model)) {\n\t\t\tapp.root.removeChild(data.model.graph);\n\t\t\tapp.scene.removeModel(data.model);\n\t\t}\n\t}\n\n\tclone(entity, clone) {\n\t\tconst src = this.system.store[entity.getGuid()];\n\t\tconst data = {\n\t\t\tenabled: src.data.enabled,\n\t\t\ttype: src.data.type,\n\t\t\thalfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],\n\t\t\tradius: src.data.radius,\n\t\t\taxis: src.data.axis,\n\t\t\theight: src.data.height,\n\t\t\tasset: src.data.asset,\n\t\t\trenderAsset: src.data.renderAsset,\n\t\t\tmodel: src.data.model,\n\t\t\trender: src.data.render\n\t\t};\n\t\treturn this.system.addComponent(clone, data);\n\t}\n\n}\n\nclass CollisionBoxSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tconst he = data.halfExtents;\n\t\t\tconst ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);\n\t\t\tconst shape = new Ammo.btBoxShape(ammoHe);\n\t\t\tAmmo.destroy(ammoHe);\n\t\t\treturn shape;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n}\n\nclass CollisionSphereSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\treturn new Ammo.btSphereShape(data.radius);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n}\n\nclass CollisionCapsuleSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tconst axis = data.axis !== undefined ? data.axis : 1;\n\t\tconst radius = data.radius || 0.5;\n\t\tconst height = Math.max((data.height || 2) - 2 * radius, 0);\n\t\tlet shape = null;\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\tshape = new Ammo.btCapsuleShapeX(radius, height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tshape = new Ammo.btCapsuleShape(radius, height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tshape = new Ammo.btCapsuleShapeZ(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn shape;\n\t}\n\n}\n\nclass CollisionCylinderSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tconst axis = data.axis !== undefined ? data.axis : 1;\n\t\tconst radius = data.radius !== undefined ? data.radius : 0.5;\n\t\tconst height = data.height !== undefined ? data.height : 1;\n\t\tlet halfExtents = null;\n\t\tlet shape = null;\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(height * 0.5, radius, radius);\n\t\t\t\t\tshape = new Ammo.btCylinderShapeX(halfExtents);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(radius, height * 0.5, radius);\n\t\t\t\t\tshape = new Ammo.btCylinderShape(halfExtents);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(radius, radius, height * 0.5);\n\t\t\t\t\tshape = new Ammo.btCylinderShapeZ(halfExtents);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (halfExtents) Ammo.destroy(halfExtents);\n\t\treturn shape;\n\t}\n\n}\n\nclass CollisionConeSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tconst axis = data.axis !== undefined ? data.axis : 1;\n\t\tconst radius = data.radius !== undefined ? data.radius : 0.5;\n\t\tconst height = data.height !== undefined ? data.height : 1;\n\t\tlet shape = null;\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\tshape = new Ammo.btConeShapeX(radius, height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tshape = new Ammo.btConeShape(radius, height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tshape = new Ammo.btConeShapeZ(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn shape;\n\t}\n\n}\n\nclass CollisionMeshSystemImpl extends CollisionSystemImpl {\n\tbeforeInitialize(component, data) {}\n\n\tcreateAmmoMesh(mesh, node, shape) {\n\t\tlet triMesh;\n\n\t\tif (this.system._triMeshCache[mesh.id]) {\n\t\t\ttriMesh = this.system._triMeshCache[mesh.id];\n\t\t} else {\n\t\t\tconst vb = mesh.vertexBuffer;\n\t\t\tconst format = vb.getFormat();\n\t\t\tlet stride;\n\t\t\tlet positions;\n\n\t\t\tfor (let i = 0; i < format.elements.length; i++) {\n\t\t\t\tconst element = format.elements[i];\n\n\t\t\t\tif (element.name === SEMANTIC_POSITION) {\n\t\t\t\t\tpositions = new Float32Array(vb.lock(), element.offset);\n\t\t\t\t\tstride = element.stride / 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst indices = [];\n\t\t\tmesh.getIndices(indices);\n\t\t\tconst numTriangles = mesh.primitive[0].count / 3;\n\t\t\tconst v1 = new Ammo.btVector3();\n\t\t\tconst v2 = new Ammo.btVector3();\n\t\t\tconst v3 = new Ammo.btVector3();\n\t\t\tlet i1, i2, i3;\n\t\t\tconst base = mesh.primitive[0].base;\n\t\t\ttriMesh = new Ammo.btTriangleMesh();\n\t\t\tthis.system._triMeshCache[mesh.id] = triMesh;\n\n\t\t\tfor (let i = 0; i < numTriangles; i++) {\n\t\t\t\ti1 = indices[base + i * 3] * stride;\n\t\t\t\ti2 = indices[base + i * 3 + 1] * stride;\n\t\t\t\ti3 = indices[base + i * 3 + 2] * stride;\n\t\t\t\tv1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);\n\t\t\t\tv2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);\n\t\t\t\tv3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n\t\t\t\ttriMesh.addTriangle(v1, v2, v3, true);\n\t\t\t}\n\n\t\t\tAmmo.destroy(v1);\n\t\t\tAmmo.destroy(v2);\n\t\t\tAmmo.destroy(v3);\n\t\t}\n\n\t\tconst useQuantizedAabbCompression = true;\n\t\tconst triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);\n\n\t\tconst scaling = this.system._getNodeScaling(node);\n\n\t\ttriMeshShape.setLocalScaling(scaling);\n\t\tAmmo.destroy(scaling);\n\n\t\tconst transform = this.system._getNodeTransform(node);\n\n\t\tshape.addChildShape(transform, triMeshShape);\n\t\tAmmo.destroy(transform);\n\t}\n\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo === 'undefined') return;\n\n\t\tif (data.model || data.render) {\n\t\t\tconst shape = new Ammo.btCompoundShape();\n\n\t\t\tif (data.model) {\n\t\t\t\tconst meshInstances = data.model.meshInstances;\n\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tthis.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape);\n\t\t\t\t}\n\t\t\t} else if (data.render) {\n\t\t\t\tconst meshes = data.render.meshes;\n\n\t\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\t\tthis.createAmmoMesh(meshes[i], tempGraphNode, shape);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst entityTransform = entity.getWorldTransform();\n\t\t\tconst scale = entityTransform.getScale();\n\t\t\tconst vec = new Ammo.btVector3(scale.x, scale.y, scale.z);\n\t\t\tshape.setLocalScaling(vec);\n\t\t\tAmmo.destroy(vec);\n\t\t\treturn shape;\n\t\t}\n\t}\n\n\trecreatePhysicalShapes(component) {\n\t\tconst data = component.data;\n\n\t\tif (data.renderAsset || data.asset) {\n\t\t\tif (component.enabled && component.entity.enabled) {\n\t\t\t\tthis.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.doRecreatePhysicalShape(component);\n\t}\n\n\tloadAsset(component, id, property) {\n\t\tconst data = component.data;\n\t\tconst assets = this.system.app.assets;\n\t\tconst asset = assets.get(id);\n\n\t\tif (asset) {\n\t\t\tasset.ready(asset => {\n\t\t\t\tdata[property] = asset.resource;\n\t\t\t\tthis.doRecreatePhysicalShape(component);\n\t\t\t});\n\t\t\tassets.load(asset);\n\t\t} else {\n\t\t\tassets.once(\"add:\" + id, asset => {\n\t\t\t\tasset.ready(asset => {\n\t\t\t\t\tdata[property] = asset.resource;\n\t\t\t\t\tthis.doRecreatePhysicalShape(component);\n\t\t\t\t});\n\t\t\t\tassets.load(asset);\n\t\t\t});\n\t\t}\n\t}\n\n\tdoRecreatePhysicalShape(component) {\n\t\tconst entity = component.entity;\n\t\tconst data = component.data;\n\n\t\tif (data.model || data.render) {\n\t\t\tthis.destroyShape(data);\n\t\t\tdata.shape = this.createPhysicalShape(entity, data);\n\n\t\t\tif (entity.rigidbody) {\n\t\t\t\tentity.rigidbody.disableSimulation();\n\t\t\t\tentity.rigidbody.createBody();\n\n\t\t\t\tif (entity.enabled && entity.rigidbody.enabled) {\n\t\t\t\t\tentity.rigidbody.enableSimulation();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!entity.trigger) {\n\t\t\t\t\tentity.trigger = new Trigger(this.system.app, component, data);\n\t\t\t\t} else {\n\t\t\t\t\tentity.trigger.initialize(data);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.beforeRemove(entity, component);\n\t\t\tthis.remove(entity, data);\n\t\t}\n\t}\n\n\tupdateTransform(component, position, rotation, scale) {\n\t\tif (component.shape) {\n\t\t\tconst entityTransform = component.entity.getWorldTransform();\n\t\t\tconst worldScale = entityTransform.getScale();\n\t\t\tconst previousScale = component.shape.getLocalScaling();\n\n\t\t\tif (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {\n\t\t\t\tthis.doRecreatePhysicalShape(component);\n\t\t\t}\n\t\t}\n\n\t\tsuper.updateTransform(component, position, rotation, scale);\n\t}\n\n\tdestroyShape(data) {\n\t\tif (!data.shape) return;\n\t\tconst numShapes = data.shape.getNumChildShapes();\n\n\t\tfor (let i = 0; i < numShapes; i++) {\n\t\t\tconst shape = data.shape.getChildShape(i);\n\t\t\tAmmo.destroy(shape);\n\t\t}\n\n\t\tAmmo.destroy(data.shape);\n\t\tdata.shape = null;\n\t}\n\n\tremove(entity, data) {\n\t\tthis.destroyShape(data);\n\t\tsuper.remove(entity, data);\n\t}\n\n}\n\nclass CollisionCompoundSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\treturn new Ammo.btCompoundShape();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t_addEachDescendant(entity) {\n\t\tif (!entity.collision || entity.rigidbody) return;\n\t\tentity.collision._compoundParent = this;\n\n\t\tif (entity !== this.entity) {\n\t\t\tentity.collision.system.recreatePhysicalShapes(entity.collision);\n\t\t}\n\t}\n\n\t_updateEachDescendant(entity) {\n\t\tif (!entity.collision) return;\n\t\tif (entity.collision._compoundParent !== this) return;\n\t\tentity.collision._compoundParent = null;\n\n\t\tif (entity !== this.entity && !entity.rigidbody) {\n\t\t\tentity.collision.system.recreatePhysicalShapes(entity.collision);\n\t\t}\n\t}\n\n\t_updateEachDescendantTransform(entity) {\n\t\tif (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) return;\n\t\tthis.collision.system.updateCompoundChildTransform(entity);\n\t}\n\n}\n\nclass CollisionComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = \"collision\";\n\t\tthis.ComponentType = CollisionComponent;\n\t\tthis.DataType = CollisionComponentData;\n\t\tthis.schema = _schema$f;\n\t\tthis.implementations = {};\n\t\tthis._triMeshCache = {};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.on('remove', this.onRemove, this);\n\t}\n\n\tinitializeComponentData(component, _data, properties) {\n\t\tproperties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled'];\n\t\tconst data = {};\n\n\t\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\t\tconst property = properties[i];\n\t\t\tdata[property] = _data[property];\n\t\t}\n\n\t\tlet idx;\n\n\t\tif (_data.hasOwnProperty('asset')) {\n\t\t\tidx = properties.indexOf('model');\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\n\t\t\tidx = properties.indexOf('render');\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\t\t} else if (_data.hasOwnProperty('model')) {\n\t\t\tidx = properties.indexOf('asset');\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!data.type) {\n\t\t\tdata.type = component.data.type;\n\t\t}\n\n\t\tcomponent.data.type = data.type;\n\n\t\tif (data.halfExtents && Array.isArray(data.halfExtents)) {\n\t\t\tdata.halfExtents = new Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);\n\t\t}\n\n\t\tconst impl = this._createImplementation(data.type);\n\n\t\timpl.beforeInitialize(component, data);\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\timpl.afterInitialize(component, data);\n\t}\n\n\t_createImplementation(type) {\n\t\tif (this.implementations[type] === undefined) {\n\t\t\tlet impl;\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'box':\n\t\t\t\t\timpl = new CollisionBoxSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'sphere':\n\t\t\t\t\timpl = new CollisionSphereSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'capsule':\n\t\t\t\t\timpl = new CollisionCapsuleSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'cylinder':\n\t\t\t\t\timpl = new CollisionCylinderSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'cone':\n\t\t\t\t\timpl = new CollisionConeSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\timpl = new CollisionMeshSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'compound':\n\t\t\t\t\timpl = new CollisionCompoundSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.implementations[type] = impl;\n\t\t}\n\n\t\treturn this.implementations[type];\n\t}\n\n\t_getImplementation(entity) {\n\t\treturn this.implementations[entity.collision.data.type];\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\treturn this._getImplementation(entity).clone(entity, clone);\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tthis.implementations[component.data.type].beforeRemove(entity, component);\n\t\tcomponent.onBeforeRemove();\n\t}\n\n\tonRemove(entity, data) {\n\t\tthis.implementations[data.type].remove(entity, data);\n\t}\n\n\tupdateCompoundChildTransform(entity) {\n\t\tthis._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);\n\n\t\tif (entity.enabled && entity.collision.enabled) {\n\t\t\tconst transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);\n\n\t\t\tentity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);\n\n\t\t\tAmmo.destroy(transform);\n\t\t}\n\t}\n\n\t_removeCompoundChild(collision, shape) {\n\t\tif (collision.shape.removeChildShape) {\n\t\t\tcollision.shape.removeChildShape(shape);\n\t\t} else {\n\t\t\tconst ind = collision._getCompoundChildShapeIndex(shape);\n\n\t\t\tif (ind !== null) {\n\t\t\t\tcollision.shape.removeChildShapeByIndex(ind);\n\t\t\t}\n\t\t}\n\t}\n\n\tonTransformChanged(component, position, rotation, scale) {\n\t\tthis.implementations[component.data.type].updateTransform(component, position, rotation, scale);\n\t}\n\n\tchangeType(component, previousType, newType) {\n\t\tthis.implementations[previousType].beforeRemove(component.entity, component);\n\t\tthis.implementations[previousType].remove(component.entity, component.data);\n\n\t\tthis._createImplementation(newType).reset(component, component.data);\n\t}\n\n\trecreatePhysicalShapes(component) {\n\t\tthis.implementations[component.data.type].recreatePhysicalShapes(component);\n\t}\n\n\t_calculateNodeRelativeTransform(node, relative) {\n\t\tif (node === relative) {\n\t\t\tconst scale = node.getWorldTransform().getScale();\n\t\t\tmat4.setScale(scale.x, scale.y, scale.z);\n\t\t} else {\n\t\t\tthis._calculateNodeRelativeTransform(node.parent, relative);\n\n\t\t\tmat4.mul(node.getLocalTransform());\n\t\t}\n\t}\n\n\t_getNodeScaling(node) {\n\t\tconst wtm = node.getWorldTransform();\n\t\tconst scl = wtm.getScale();\n\t\treturn new Ammo.btVector3(scl.x, scl.y, scl.z);\n\t}\n\n\t_getNodeTransform(node, relative) {\n\t\tlet pos, rot;\n\n\t\tif (relative) {\n\t\t\tthis._calculateNodeRelativeTransform(node, relative);\n\n\t\t\tpos = vec3;\n\t\t\trot = quat;\n\t\t\tmat4.getTranslation(pos);\n\t\t\trot.setFromMat4(mat4);\n\t\t} else {\n\t\t\tpos = node.getPosition();\n\t\t\trot = node.getRotation();\n\t\t}\n\n\t\tconst transform = new Ammo.btTransform();\n\t\ttransform.setIdentity();\n\t\tconst origin = transform.getOrigin();\n\t\torigin.setValue(pos.x, pos.y, pos.z);\n\t\tconst ammoQuat = new Ammo.btQuaternion();\n\t\tammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\ttransform.setRotation(ammoQuat);\n\t\tAmmo.destroy(ammoQuat);\n\t\tAmmo.destroy(origin);\n\t\treturn transform;\n\t}\n\n\tdestroy() {\n\t\tfor (const key in this._triMeshCache) {\n\t\t\tAmmo.destroy(this._triMeshCache[key]);\n\t\t}\n\n\t\tthis._triMeshCache = null;\n\t\tsuper.destroy();\n\t}\n\n}\n\nComponent._buildAccessors(CollisionComponent.prototype, _schema$f);\n\nclass ComponentSystemRegistry extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.anim = void 0;\n\t\tthis.animation = void 0;\n\t\tthis.audiolistener = void 0;\n\t\tthis.audiosource = void 0;\n\t\tthis.button = void 0;\n\t\tthis.camera = void 0;\n\t\tthis.collision = void 0;\n\t\tthis.element = void 0;\n\t\tthis.joint = void 0;\n\t\tthis.layoutchild = void 0;\n\t\tthis.layoutgroup = void 0;\n\t\tthis.light = void 0;\n\t\tthis.model = void 0;\n\t\tthis.particlesystem = void 0;\n\t\tthis.render = void 0;\n\t\tthis.rigidbody = void 0;\n\t\tthis.screen = void 0;\n\t\tthis.script = void 0;\n\t\tthis.scrollbar = void 0;\n\t\tthis.scrollview = void 0;\n\t\tthis.sound = void 0;\n\t\tthis.sprite = void 0;\n\t\tthis.zone = void 0;\n\t\tthis.list = [];\n\t}\n\n\tadd(system) {\n\t\tconst id = system.id;\n\n\t\tif (this[id]) {\n\t\t\tthrow new Error(`ComponentSystem name '${id}' already registered or not allowed`);\n\t\t}\n\n\t\tthis[id] = system;\n\t\tthis.list.push(system);\n\t}\n\n\tremove(system) {\n\t\tconst id = system.id;\n\n\t\tif (!this[id]) {\n\t\t\tthrow new Error(`No ComponentSystem named '${id}' registered`);\n\t\t}\n\n\t\tdelete this[id];\n\t\tconst index = this.list.indexOf(this[id]);\n\n\t\tif (index !== -1) {\n\t\t\tthis.list.splice(index, 1);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis.off();\n\n\t\tfor (let i = 0; i < this.list.length; i++) {\n\t\t\tthis.list[i].destroy();\n\t\t}\n\t}\n\n}\n\nclass StencilParameters {\n\tconstructor(options) {\n\t\tthis.func = options.func === undefined ? FUNC_ALWAYS : options.func;\n\t\tthis.ref = options.ref || 0;\n\t\tthis.readMask = options.readMask === undefined ? 0xFF : options.readMask;\n\t\tthis.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;\n\t\tthis.fail = options.fail || STENCILOP_KEEP;\n\t\tthis.zfail = options.zfail || STENCILOP_KEEP;\n\t\tthis.zpass = options.zpass || STENCILOP_KEEP;\n\t}\n\n\tclone() {\n\t\treturn new StencilParameters({\n\t\t\tfunc: this.func,\n\t\t\tref: this.ref,\n\t\t\treadMask: this.readMask,\n\t\t\twriteMask: this.writeMask,\n\t\t\tfail: this.fail,\n\t\t\tzfail: this.zfail,\n\t\t\tzpass: this.zpass\n\t\t});\n\t}\n\n}\n\nclass ImageRenderable {\n\tconstructor(entity, mesh, material) {\n\t\tthis._entity = entity;\n\t\tthis._element = entity.element;\n\t\tthis.model = new Model();\n\t\tthis.node = new GraphNode();\n\t\tthis.model.graph = this.node;\n\t\tthis.mesh = mesh;\n\t\tthis.meshInstance = new MeshInstance(this.mesh, material, this.node);\n\t\tthis.meshInstance.name = 'ImageElement: ' + entity.name;\n\t\tthis.meshInstance.castShadow = false;\n\t\tthis.meshInstance.receiveShadow = false;\n\t\tthis._meshDirty = false;\n\t\tthis.model.meshInstances.push(this.meshInstance);\n\n\t\tthis._entity.addChild(this.model.graph);\n\n\t\tthis.model._entity = this._entity;\n\t\tthis.unmaskMeshInstance = null;\n\t}\n\n\tdestroy() {\n\t\tthis.setMaterial(null);\n\n\t\tthis._element.removeModelFromLayers(this.model);\n\n\t\tthis.model.destroy();\n\t\tthis.model = null;\n\t\tthis.node = null;\n\t\tthis.mesh = null;\n\t\tthis.meshInstance = null;\n\t\tthis._entity = null;\n\t\tthis._element = null;\n\t}\n\n\tsetMesh(mesh) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.mesh = mesh;\n\t\tthis.meshInstance.mesh = mesh;\n\t\tthis.meshInstance.visible = !!mesh;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.mesh = mesh;\n\t\t}\n\n\t\tthis.forceUpdateAabb();\n\t}\n\n\tsetMask(mask) {\n\t\tif (!this.meshInstance) return;\n\n\t\tif (mask) {\n\t\t\tthis.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);\n\t\t\tthis.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;\n\t\t\tthis.unmaskMeshInstance.castShadow = false;\n\t\t\tthis.unmaskMeshInstance.receiveShadow = false;\n\t\t\tthis.unmaskMeshInstance.pick = false;\n\t\t\tthis.model.meshInstances.push(this.unmaskMeshInstance);\n\n\t\t\tfor (const name in this.meshInstance.parameters) {\n\t\t\t\tthis.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);\n\t\t\t}\n\t\t} else {\n\t\t\tconst idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);\n\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis.model.meshInstances.splice(idx, 1);\n\t\t\t}\n\n\t\t\tthis.unmaskMeshInstance = null;\n\t\t}\n\n\t\tif (this._entity.enabled && this._element.enabled) {\n\t\t\tthis._element.removeModelFromLayers(this.model);\n\n\t\t\tthis._element.addModelToLayers(this.model);\n\t\t}\n\t}\n\n\tsetMaterial(material) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.material = material;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.material = material;\n\t\t}\n\t}\n\n\tsetParameter(name, value) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.setParameter(name, value);\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.setParameter(name, value);\n\t\t}\n\t}\n\n\tdeleteParameter(name) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.deleteParameter(name);\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.deleteParameter(name);\n\t\t}\n\t}\n\n\tsetUnmaskDrawOrder() {\n\t\tif (!this.meshInstance) return;\n\n\t\tconst getLastChild = function getLastChild(e) {\n\t\t\tlet last;\n\t\t\tconst c = e.children;\n\t\t\tconst l = c.length;\n\n\t\t\tif (l) {\n\t\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\t\tif (c[i].element) {\n\t\t\t\t\t\tlast = c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!last) return null;\n\t\t\t\tconst child = getLastChild(last);\n\n\t\t\t\tif (child) {\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\n\t\t\t\treturn last;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tconst lastChild = getLastChild(this._entity);\n\n\t\t\tif (lastChild && lastChild.element) {\n\t\t\t\tthis.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();\n\t\t\t} else {\n\t\t\t\tthis.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();\n\t\t\t}\n\t\t}\n\t}\n\n\tsetDrawOrder(drawOrder) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.drawOrder = drawOrder;\n\t}\n\n\tsetCull(cull) {\n\t\tif (!this.meshInstance) return;\n\t\tconst element = this._element;\n\t\tlet visibleFn = null;\n\n\t\tif (cull && element._isScreenCulled()) {\n\t\t\tvisibleFn = function (camera) {\n\t\t\t\treturn element.isVisibleForCamera(camera);\n\t\t\t};\n\t\t}\n\n\t\tthis.meshInstance.cull = cull;\n\t\tthis.meshInstance.isVisibleFunc = visibleFn;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.cull = cull;\n\t\t\tthis.unmaskMeshInstance.isVisibleFunc = visibleFn;\n\t\t}\n\t}\n\n\tsetScreenSpace(screenSpace) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.screenSpace = screenSpace;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.screenSpace = screenSpace;\n\t\t}\n\t}\n\n\tsetLayer(layer) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.layer = layer;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.layer = layer;\n\t\t}\n\t}\n\n\tforceUpdateAabb(mask) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance._aabbVer = -1;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance._aabbVer = -1;\n\t\t}\n\t}\n\n\tsetAabbFunc(fn) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance._updateAabbFunc = fn;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance._updateAabbFunc = fn;\n\t\t}\n\t}\n\n}\n\nclass ImageElement {\n\tconstructor(element) {\n\t\tthis._element = element;\n\t\tthis._entity = element.entity;\n\t\tthis._system = element.system;\n\t\tthis._textureAsset = null;\n\t\tthis._texture = null;\n\t\tthis._materialAsset = null;\n\t\tthis._material = null;\n\t\tthis._spriteAsset = null;\n\t\tthis._sprite = null;\n\t\tthis._spriteFrame = 0;\n\t\tthis._pixelsPerUnit = null;\n\t\tthis._rect = new Vec4(0, 0, 1, 1);\n\t\tthis._mask = false;\n\t\tthis._maskRef = 0;\n\t\tthis._outerScale = new Vec2();\n\t\tthis._outerScaleUniform = new Float32Array(2);\n\t\tthis._innerOffset = new Vec4();\n\t\tthis._innerOffsetUniform = new Float32Array(4);\n\t\tthis._atlasRect = new Vec4();\n\t\tthis._atlasRectUniform = new Float32Array(4);\n\t\tthis._defaultMesh = this._createMesh();\n\t\tthis._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array([1, 1, 1]);\n\n\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\n\t\tthis._renderable.setParameter('material_opacity', 1);\n\n\t\tthis._updateAabbFunc = this._updateAabb.bind(this);\n\n\t\tthis._onScreenChange(this._element.screen);\n\n\t\tthis._element.on('resize', this._onParentResizeOrPivotChange, this);\n\n\t\tthis._element.on('set:pivot', this._onParentResizeOrPivotChange, this);\n\n\t\tthis._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);\n\n\t\tthis._element.on('set:screen', this._onScreenChange, this);\n\n\t\tthis._element.on('set:draworder', this._onDrawOrderChange, this);\n\n\t\tthis._element.on('screen:set:resolution', this._onResolutionChange, this);\n\t}\n\n\tdestroy() {\n\t\tthis.textureAsset = null;\n\t\tthis.spriteAsset = null;\n\t\tthis.materialAsset = null;\n\n\t\tthis._renderable.setMesh(this._defaultMesh);\n\n\t\tthis._renderable.destroy();\n\n\t\tthis._defaultMesh = null;\n\n\t\tthis._element.off('resize', this._onParentResizeOrPivotChange, this);\n\n\t\tthis._element.off('set:pivot', this._onParentResizeOrPivotChange, this);\n\n\t\tthis._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);\n\n\t\tthis._element.off('set:screen', this._onScreenChange, this);\n\n\t\tthis._element.off('set:draworder', this._onDrawOrderChange, this);\n\n\t\tthis._element.off('screen:set:resolution', this._onResolutionChange, this);\n\t}\n\n\t_onResolutionChange(res) {}\n\n\t_onParentResizeOrPivotChange() {\n\t\tif (this._renderable.mesh) {\n\t\t\tthis._updateMesh(this._renderable.mesh);\n\t\t}\n\t}\n\n\t_onScreenSpaceChange(value) {\n\t\tthis._updateMaterial(value);\n\t}\n\n\t_onScreenChange(screen, previous) {\n\t\tif (screen) {\n\t\t\tthis._updateMaterial(screen.screen.screenSpace);\n\t\t} else {\n\t\t\tthis._updateMaterial(false);\n\t\t}\n\t}\n\n\t_onDrawOrderChange(order) {\n\t\tthis._renderable.setDrawOrder(order);\n\n\t\tif (this.mask && this._element.screen) {\n\t\t\tthis._element.screen.screen.once('syncdraworder', function () {\n\t\t\t\tthis._renderable.setUnmaskDrawOrder();\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t_hasUserMaterial() {\n\t\treturn !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;\n\t}\n\n\t_use9Slicing() {\n\t\treturn this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);\n\t}\n\n\t_updateMaterial(screenSpace) {\n\t\tconst mask = !!this._mask;\n\t\tconst nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);\n\t\tconst nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);\n\n\t\tif (!this._hasUserMaterial()) {\n\t\t\tthis._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);\n\t\t}\n\n\t\tif (this._renderable) {\n\t\t\tthis._renderable.setCull(true);\n\n\t\t\tthis._renderable.setMaterial(this._material);\n\n\t\t\tthis._renderable.setScreenSpace(screenSpace);\n\n\t\t\tthis._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);\n\t\t}\n\t}\n\n\t_createMesh() {\n\t\tconst element = this._element;\n\t\tconst w = element.calculatedWidth;\n\t\tconst h = element.calculatedHeight;\n\t\tconst r = this._rect;\n\t\tconst vertexData = new ArrayBuffer(4 * 8 * 4);\n\t\tconst vertexDataF32 = new Float32Array(vertexData);\n\t\tvertexDataF32[5] = 1;\n\t\tvertexDataF32[6] = r.x;\n\t\tvertexDataF32[7] = 1.0 - r.y;\n\t\tvertexDataF32[8] = w;\n\t\tvertexDataF32[13] = 1;\n\t\tvertexDataF32[14] = r.x + r.z;\n\t\tvertexDataF32[15] = 1.0 - r.y;\n\t\tvertexDataF32[16] = w;\n\t\tvertexDataF32[17] = h;\n\t\tvertexDataF32[21] = 1;\n\t\tvertexDataF32[22] = r.x + r.z;\n\t\tvertexDataF32[23] = 1.0 - (r.y + r.w);\n\t\tvertexDataF32[25] = h;\n\t\tvertexDataF32[29] = 1;\n\t\tvertexDataF32[30] = r.x;\n\t\tvertexDataF32[31] = 1.0 - (r.y + r.w);\n\t\tconst vertexDesc = [{\n\t\t\tsemantic: SEMANTIC_POSITION,\n\t\t\tcomponents: 3,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_NORMAL,\n\t\t\tcomponents: 3,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_TEXCOORD0,\n\t\t\tcomponents: 2,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}];\n\t\tconst device = this._system.app.graphicsDevice;\n\t\tconst vertexFormat = new VertexFormat(device, vertexDesc);\n\t\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData);\n\t\tconst mesh = new Mesh(device);\n\t\tmesh.vertexBuffer = vertexBuffer;\n\t\tmesh.primitive[0].type = PRIMITIVE_TRIFAN;\n\t\tmesh.primitive[0].base = 0;\n\t\tmesh.primitive[0].count = 4;\n\t\tmesh.primitive[0].indexed = false;\n\t\tmesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));\n\n\t\tthis._updateMesh(mesh);\n\n\t\treturn mesh;\n\t}\n\n\t_updateMesh(mesh) {\n\t\tconst element = this._element;\n\t\tconst w = element.calculatedWidth;\n\t\tconst h = element.calculatedHeight;\n\n\t\tconst screenSpace = element._isScreenSpace();\n\n\t\tthis._updateMaterial(screenSpace);\n\n\t\tif (this._renderable) this._renderable.forceUpdateAabb();\n\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tconst frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n\t\t\tconst borderWidthScale = 2 / frameData.rect.z;\n\t\t\tconst borderHeightScale = 2 / frameData.rect.w;\n\n\t\t\tthis._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);\n\n\t\t\tconst tex = this.sprite.atlas.texture;\n\n\t\t\tthis._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);\n\n\t\t\tconst ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;\n\t\t\tconst scaleMulX = frameData.rect.z / ppu;\n\t\t\tconst scaleMulY = frameData.rect.w / ppu;\n\n\t\t\tthis._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));\n\n\t\t\tlet scaleX = scaleMulX;\n\t\t\tlet scaleY = scaleMulY;\n\t\t\tthis._outerScale.x /= scaleMulX;\n\t\t\tthis._outerScale.y /= scaleMulY;\n\t\t\tscaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);\n\t\t\tscaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);\n\n\t\t\tif (this._renderable) {\n\t\t\t\tthis._innerOffsetUniform[0] = this._innerOffset.x;\n\t\t\t\tthis._innerOffsetUniform[1] = this._innerOffset.y;\n\t\t\t\tthis._innerOffsetUniform[2] = this._innerOffset.z;\n\t\t\t\tthis._innerOffsetUniform[3] = this._innerOffset.w;\n\n\t\t\t\tthis._renderable.setParameter('innerOffset', this._innerOffsetUniform);\n\n\t\t\t\tthis._atlasRectUniform[0] = this._atlasRect.x;\n\t\t\t\tthis._atlasRectUniform[1] = this._atlasRect.y;\n\t\t\t\tthis._atlasRectUniform[2] = this._atlasRect.z;\n\t\t\t\tthis._atlasRectUniform[3] = this._atlasRect.w;\n\n\t\t\t\tthis._renderable.setParameter('atlasRect', this._atlasRectUniform);\n\n\t\t\t\tthis._outerScaleUniform[0] = this._outerScale.x;\n\t\t\t\tthis._outerScaleUniform[1] = this._outerScale.y;\n\n\t\t\t\tthis._renderable.setParameter('outerScale', this._outerScaleUniform);\n\n\t\t\t\tthis._renderable.setAabbFunc(this._updateAabbFunc);\n\n\t\t\t\tthis._renderable.node.setLocalScale(scaleX, scaleY, 1);\n\n\t\t\t\tthis._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tconst vb = mesh.vertexBuffer;\n\t\t\tconst vertexDataF32 = new Float32Array(vb.lock());\n\t\t\tconst hp = element.pivot.x;\n\t\t\tconst vp = element.pivot.y;\n\t\t\tvertexDataF32[0] = 0 - hp * w;\n\t\t\tvertexDataF32[1] = 0 - vp * h;\n\t\t\tvertexDataF32[8] = w - hp * w;\n\t\t\tvertexDataF32[9] = 0 - vp * h;\n\t\t\tvertexDataF32[16] = w - hp * w;\n\t\t\tvertexDataF32[17] = h - vp * h;\n\t\t\tvertexDataF32[24] = 0 - hp * w;\n\t\t\tvertexDataF32[25] = h - vp * h;\n\t\t\tlet atlasTextureWidth = 1;\n\t\t\tlet atlasTextureHeight = 1;\n\t\t\tlet rect = this._rect;\n\n\t\t\tif (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {\n\t\t\t\tconst frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n\n\t\t\t\tif (frame) {\n\t\t\t\t\trect = frame.rect;\n\t\t\t\t\tatlasTextureWidth = this._sprite.atlas.texture.width;\n\t\t\t\t\tatlasTextureHeight = this._sprite.atlas.texture.height;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvertexDataF32[6] = rect.x / atlasTextureWidth;\n\t\t\tvertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;\n\t\t\tvertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;\n\t\t\tvertexDataF32[15] = 1.0 - rect.y / atlasTextureHeight;\n\t\t\tvertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;\n\t\t\tvertexDataF32[23] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;\n\t\t\tvertexDataF32[30] = rect.x / atlasTextureWidth;\n\t\t\tvertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;\n\t\t\tvb.unlock();\n\t\t\tconst min = new Vec3(0 - hp * w, 0 - vp * h, 0);\n\t\t\tconst max = new Vec3(w - hp * w, h - vp * h, 0);\n\t\t\tmesh.aabb.setMinMax(min, max);\n\n\t\t\tif (this._renderable) {\n\t\t\t\tthis._renderable.node.setLocalScale(1, 1, 1);\n\n\t\t\t\tthis._renderable.node.setLocalPosition(0, 0, 0);\n\n\t\t\t\tthis._renderable.setAabbFunc(null);\n\t\t\t}\n\t\t}\n\n\t\tthis._meshDirty = false;\n\t}\n\n\t_updateSprite() {\n\t\tlet nineSlice = false;\n\t\tlet mesh = null;\n\n\t\tif (this._sprite && this._sprite.atlas) {\n\t\t\tmesh = this._sprite.meshes[this.spriteFrame];\n\t\t\tnineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;\n\t\t}\n\n\t\tthis.mesh = nineSlice ? mesh : this._defaultMesh;\n\n\t\tif (this.mesh) {\n\t\t\tif (!this._element._beingInitialized) {\n\t\t\t\tthis._updateMesh(this.mesh);\n\t\t\t} else {\n\t\t\t\tthis._meshDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateAabb(aabb) {\n\t\taabb.center.set(0, 0, 0);\n\t\taabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);\n\t\taabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());\n\t\treturn aabb;\n\t}\n\n\t_toggleMask() {\n\t\tthis._element._dirtifyMask();\n\n\t\tconst screenSpace = this._element._isScreenSpace();\n\n\t\tthis._updateMaterial(screenSpace);\n\n\t\tthis._renderable.setMask(!!this._mask);\n\t}\n\n\t_onMaterialLoad(asset) {\n\t\tthis.material = asset.resource;\n\t}\n\n\t_onMaterialAdded(asset) {\n\t\tthis._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);\n\n\t\tif (this._materialAsset === asset.id) {\n\t\t\tthis._bindMaterialAsset(asset);\n\t\t}\n\t}\n\n\t_bindMaterialAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on(\"load\", this._onMaterialLoad, this);\n\t\tasset.on(\"change\", this._onMaterialChange, this);\n\t\tasset.on(\"remove\", this._onMaterialRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindMaterialAsset(asset) {\n\t\tasset.off(\"load\", this._onMaterialLoad, this);\n\t\tasset.off(\"change\", this._onMaterialChange, this);\n\t\tasset.off(\"remove\", this._onMaterialRemove, this);\n\t}\n\n\t_onMaterialChange() {}\n\n\t_onMaterialRemove() {}\n\n\t_onTextureAdded(asset) {\n\t\tthis._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);\n\n\t\tif (this._textureAsset === asset.id) {\n\t\t\tthis._bindTextureAsset(asset);\n\t\t}\n\t}\n\n\t_bindTextureAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on(\"load\", this._onTextureLoad, this);\n\t\tasset.on(\"change\", this._onTextureChange, this);\n\t\tasset.on(\"remove\", this._onTextureRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onTextureLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindTextureAsset(asset) {\n\t\tasset.off(\"load\", this._onTextureLoad, this);\n\t\tasset.off(\"change\", this._onTextureChange, this);\n\t\tasset.off(\"remove\", this._onTextureRemove, this);\n\t}\n\n\t_onTextureLoad(asset) {\n\t\tthis.texture = asset.resource;\n\t}\n\n\t_onTextureChange(asset) {}\n\n\t_onTextureRemove(asset) {}\n\n\t_onSpriteAssetAdded(asset) {\n\t\tthis._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);\n\n\t\tif (this._spriteAsset === asset.id) {\n\t\t\tthis._bindSpriteAsset(asset);\n\t\t}\n\t}\n\n\t_bindSpriteAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on(\"load\", this._onSpriteAssetLoad, this);\n\t\tasset.on(\"change\", this._onSpriteAssetChange, this);\n\t\tasset.on(\"remove\", this._onSpriteAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onSpriteAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindSpriteAsset(asset) {\n\t\tasset.off(\"load\", this._onSpriteAssetLoad, this);\n\t\tasset.off(\"change\", this._onSpriteAssetChange, this);\n\t\tasset.off(\"remove\", this._onSpriteAssetRemove, this);\n\n\t\tif (asset.data.textureAtlasAsset) {\n\t\t\tthis._system.app.assets.off(\"load:\" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);\n\t\t}\n\t}\n\n\t_onSpriteAssetLoad(asset) {\n\t\tif (!asset || !asset.resource) {\n\t\t\tthis.sprite = null;\n\t\t} else {\n\t\t\tif (!asset.resource.atlas) {\n\t\t\t\tconst atlasAssetId = asset.data.textureAtlasAsset;\n\n\t\t\t\tif (atlasAssetId) {\n\t\t\t\t\tconst assets = this._system.app.assets;\n\t\t\t\t\tassets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n\t\t\t\t\tassets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = asset.resource;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSpriteAssetChange(asset) {\n\t\tthis._onSpriteAssetLoad(asset);\n\t}\n\n\t_onSpriteAssetRemove(asset) {}\n\n\t_bindSprite(sprite) {\n\t\tsprite.on('set:meshes', this._onSpriteMeshesChange, this);\n\t\tsprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);\n\t\tsprite.on('set:atlas', this._onAtlasTextureChange, this);\n\n\t\tif (sprite.atlas) {\n\t\t\tsprite.atlas.on('set:texture', this._onAtlasTextureChange, this);\n\t\t}\n\t}\n\n\t_unbindSprite(sprite) {\n\t\tsprite.off('set:meshes', this._onSpriteMeshesChange, this);\n\t\tsprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);\n\t\tsprite.off('set:atlas', this._onAtlasTextureChange, this);\n\n\t\tif (sprite.atlas) {\n\t\t\tsprite.atlas.off('set:texture', this._onAtlasTextureChange, this);\n\t\t}\n\t}\n\n\t_onSpriteMeshesChange() {\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);\n\t\t}\n\n\t\tthis._updateSprite();\n\t}\n\n\t_onSpritePpuChange() {\n\t\tif (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {\n\t\t\tthis._updateSprite();\n\t\t}\n\t}\n\n\t_onAtlasTextureChange() {\n\t\tif (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {\n\t\t\tthis._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);\n\n\t\t\tthis._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter('texture_emissiveMap');\n\n\t\t\tthis._renderable.deleteParameter('texture_opacityMap');\n\t\t}\n\t}\n\n\t_onTextureAtlasLoad(atlasAsset) {\n\t\tconst spriteAsset = this._spriteAsset;\n\n\t\tif (spriteAsset instanceof Asset) {\n\t\t\tthis._onSpriteAssetLoad(spriteAsset);\n\t\t} else {\n\t\t\tthis._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tif (this._materialAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._materialAsset);\n\n\t\t\tif (asset && asset.resource !== this._material) {\n\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (this._textureAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._textureAsset);\n\n\t\t\tif (asset && asset.resource !== this._texture) {\n\t\t\t\tthis._bindTextureAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (this._spriteAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._spriteAsset);\n\n\t\t\tif (asset && asset.resource !== this._sprite) {\n\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tthis._element.addModelToLayers(this._renderable.model);\n\t}\n\n\tonDisable() {\n\t\tthis._element.removeModelFromLayers(this._renderable.model);\n\t}\n\n\t_setStencil(stencilParams) {\n\t\tthis._renderable.meshInstance.stencilFront = stencilParams;\n\t\tthis._renderable.meshInstance.stencilBack = stencilParams;\n\t\tlet ref = 0;\n\n\t\tif (this._element.maskedBy) {\n\t\t\tref = this._element.maskedBy.element._image._maskRef;\n\t\t}\n\n\t\tif (this._renderable.unmaskMeshInstance) {\n\t\t\tconst sp = new StencilParameters({\n\t\t\t\tref: ref + 1,\n\t\t\t\tfunc: FUNC_EQUAL,\n\t\t\t\tzpass: STENCILOP_DECREMENT\n\t\t\t});\n\t\t\tthis._renderable.unmaskMeshInstance.stencilFront = sp;\n\t\t\tthis._renderable.unmaskMeshInstance.stencilBack = sp;\n\t\t}\n\t}\n\n\tset color(value) {\n\t\tconst r = value.r;\n\t\tconst g = value.g;\n\t\tconst b = value.b;\n\n\t\tif (this._color.r !== r || this._color.g !== g || this._color.b !== b) {\n\t\t\tthis._color.r = r;\n\t\t\tthis._color.g = g;\n\t\t\tthis._color.b = b;\n\t\t\tthis._colorUniform[0] = r;\n\t\t\tthis._colorUniform[1] = g;\n\t\t\tthis._colorUniform[2] = b;\n\n\t\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:color', this._color);\n\t\t}\n\t}\n\n\tget color() {\n\t\treturn this._color;\n\t}\n\n\tset opacity(value) {\n\t\tif (value !== this._color.a) {\n\t\t\tthis._color.a = value;\n\n\t\t\tthis._renderable.setParameter('material_opacity', value);\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:opacity', value);\n\t\t}\n\t}\n\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\n\tset rect(value) {\n\t\tlet x, y, z, w;\n\n\t\tif (value instanceof Vec4) {\n\t\t\tx = value.x;\n\t\t\ty = value.y;\n\t\t\tz = value.z;\n\t\t\tw = value.w;\n\t\t} else {\n\t\t\tx = value[0];\n\t\t\ty = value[1];\n\t\t\tz = value[2];\n\t\t\tw = value[3];\n\t\t}\n\n\t\tif (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._rect.set(x, y, z, w);\n\n\t\tif (this._renderable.mesh) {\n\t\t\tif (!this._element._beingInitialized) {\n\t\t\t\tthis._updateMesh(this._renderable.mesh);\n\t\t\t} else {\n\t\t\t\tthis._meshDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tget rect() {\n\t\treturn this._rect;\n\t}\n\n\tset material(value) {\n\t\tif (this._material === value) return;\n\n\t\tif (!value) {\n\t\t\tconst screenSpace = this._element._isScreenSpace();\n\n\t\t\tif (this.mask) {\n\t\t\t\tvalue = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;\n\t\t\t} else {\n\t\t\t\tvalue = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;\n\t\t\t}\n\t\t}\n\n\t\tthis._material = value;\n\n\t\tif (value) {\n\t\t\tthis._renderable.setMaterial(value);\n\n\t\t\tif (this._hasUserMaterial()) {\n\t\t\t\tthis._renderable.deleteParameter('material_opacity');\n\n\t\t\t\tthis._renderable.deleteParameter('material_emissive');\n\t\t\t} else {\n\t\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\n\t\t\t\tthis._renderable.setParameter('material_opacity', this._color.a);\n\t\t\t}\n\t\t}\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset materialAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tif (this._materialAsset !== _id) {\n\t\t\tif (this._materialAsset) {\n\t\t\t\tassets.off('add:' + this._materialAsset, this._onMaterialAdded, this);\n\n\t\t\t\tconst _prev = assets.get(this._materialAsset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\t_prev.off(\"load\", this._onMaterialLoad, this);\n\n\t\t\t\t\t_prev.off(\"change\", this._onMaterialChange, this);\n\n\t\t\t\t\t_prev.off(\"remove\", this._onMaterialRemove, this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._materialAsset = _id;\n\n\t\t\tif (this._materialAsset) {\n\t\t\t\tconst asset = assets.get(this._materialAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.material = null;\n\t\t\t\t\tassets.on('add:' + this._materialAsset, this._onMaterialAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.material = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget materialAsset() {\n\t\treturn this._materialAsset;\n\t}\n\n\tset texture(value) {\n\t\tif (this._texture === value) return;\n\n\t\tif (this._textureAsset) {\n\t\t\tconst textureAsset = this._system.app.assets.get(this._textureAsset);\n\n\t\t\tif (textureAsset && textureAsset.resource !== value) {\n\t\t\t\tthis.textureAsset = null;\n\t\t\t}\n\t\t}\n\n\t\tthis._texture = value;\n\n\t\tif (value) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tthis.spriteAsset = null;\n\t\t\t}\n\n\t\t\tthis._renderable.setParameter(\"texture_emissiveMap\", this._texture);\n\n\t\t\tthis._renderable.setParameter(\"texture_opacityMap\", this._texture);\n\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\tthis._renderable.setParameter(\"material_emissive\", this._colorUniform);\n\n\t\t\tthis._renderable.setParameter(\"material_opacity\", this._color.a);\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter(\"texture_emissiveMap\");\n\n\t\t\tthis._renderable.deleteParameter(\"texture_opacityMap\");\n\t\t}\n\t}\n\n\tget texture() {\n\t\treturn this._texture;\n\t}\n\n\tset textureAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tif (this._textureAsset !== _id) {\n\t\t\tif (this._textureAsset) {\n\t\t\t\tassets.off('add:' + this._textureAsset, this._onTextureAdded, this);\n\n\t\t\t\tconst _prev = assets.get(this._textureAsset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\t_prev.off(\"load\", this._onTextureLoad, this);\n\n\t\t\t\t\t_prev.off(\"change\", this._onTextureChange, this);\n\n\t\t\t\t\t_prev.off(\"remove\", this._onTextureRemove, this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._textureAsset = _id;\n\n\t\t\tif (this._textureAsset) {\n\t\t\t\tconst asset = assets.get(this._textureAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.texture = null;\n\t\t\t\t\tassets.on('add:' + this._textureAsset, this._onTextureAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindTextureAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.texture = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget textureAsset() {\n\t\treturn this._textureAsset;\n\t}\n\n\tset spriteAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tif (this._spriteAsset !== _id) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tassets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n\n\t\t\t\tconst _prev = assets.get(this._spriteAsset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindSpriteAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._spriteAsset = _id;\n\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst asset = assets.get(this._spriteAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.sprite = null;\n\t\t\t\t\tassets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:spriteAsset', _id);\n\t\t}\n\t}\n\n\tget spriteAsset() {\n\t\treturn this._spriteAsset;\n\t}\n\n\tset sprite(value) {\n\t\tif (this._sprite === value) return;\n\n\t\tif (this._sprite) {\n\t\t\tthis._unbindSprite(this._sprite);\n\t\t}\n\n\t\tif (this._spriteAsset) {\n\t\t\tconst spriteAsset = this._system.app.assets.get(this._spriteAsset);\n\n\t\t\tif (spriteAsset && spriteAsset.resource !== value) {\n\t\t\t\tthis.spriteAsset = null;\n\t\t\t}\n\t\t}\n\n\t\tthis._sprite = value;\n\n\t\tif (this._sprite) {\n\t\t\tthis._bindSprite(this._sprite);\n\n\t\t\tif (this._textureAsset) {\n\t\t\t\tthis.textureAsset = null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {\n\t\t\tthis._renderable.setParameter(\"texture_emissiveMap\", this._sprite.atlas.texture);\n\n\t\t\tthis._renderable.setParameter(\"texture_opacityMap\", this._sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter(\"texture_emissiveMap\");\n\n\t\t\tthis._renderable.deleteParameter(\"texture_opacityMap\");\n\t\t}\n\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);\n\t\t}\n\n\t\tthis._updateSprite();\n\t}\n\n\tget sprite() {\n\t\treturn this._sprite;\n\t}\n\n\tset spriteFrame(value) {\n\t\tconst oldValue = this._spriteFrame;\n\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);\n\t\t} else {\n\t\t\tthis._spriteFrame = value;\n\t\t}\n\n\t\tif (this._spriteFrame !== oldValue) {\n\t\t\tthis._updateSprite();\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:spriteFrame', value);\n\t\t}\n\t}\n\n\tget spriteFrame() {\n\t\treturn this._spriteFrame;\n\t}\n\n\tset mesh(value) {\n\t\tthis._renderable.setMesh(value);\n\n\t\tif (this._defaultMesh === value) {\n\t\t\tthis._renderable.setAabbFunc(null);\n\t\t} else {\n\t\t\tthis._renderable.setAabbFunc(this._updateAabbFunc);\n\t\t}\n\t}\n\n\tget mesh() {\n\t\treturn this._renderable.mesh;\n\t}\n\n\tset mask(value) {\n\t\tif (this._mask !== value) {\n\t\t\tthis._mask = value;\n\n\t\t\tthis._toggleMask();\n\t\t}\n\t}\n\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\n\tset pixelsPerUnit(value) {\n\t\tif (this._pixelsPerUnit === value) return;\n\t\tthis._pixelsPerUnit = value;\n\n\t\tif (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tthis._updateSprite();\n\t\t}\n\t}\n\n\tget pixelsPerUnit() {\n\t\treturn this._pixelsPerUnit;\n\t}\n\n\tget aabb() {\n\t\tif (this._renderable.meshInstance) {\n\t\t\treturn this._renderable.meshInstance.aabb;\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n\nclass LocalizedAsset extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis._app = app;\n\t\tapp.i18n.on('set:locale', this._onSetLocale, this);\n\t\tthis._autoLoad = false;\n\t\tthis._disableLocalization = false;\n\t\tthis._defaultAsset = null;\n\t\tthis._localizedAsset = null;\n\t}\n\n\tset defaultAsset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\t\tif (this._defaultAsset === id) return;\n\n\t\tif (this._defaultAsset) {\n\t\t\tthis._unbindDefaultAsset();\n\t\t}\n\n\t\tthis._defaultAsset = id;\n\n\t\tif (this._defaultAsset) {\n\t\t\tthis._bindDefaultAsset();\n\t\t}\n\n\t\tthis._onSetLocale(this._app.i18n.locale);\n\t}\n\n\tget defaultAsset() {\n\t\treturn this._defaultAsset;\n\t}\n\n\tset localizedAsset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\n\t\tif (this._localizedAsset === id) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._localizedAsset) {\n\t\t\tthis._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);\n\n\t\t\tthis._unbindLocalizedAsset();\n\n\t\t\tthis._localizedAsset = null;\n\t\t}\n\n\t\tthis._localizedAsset = id;\n\n\t\tif (this._localizedAsset) {\n\t\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\n\t\t\tif (!asset) {\n\t\t\t\tthis._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);\n\t\t\t} else {\n\t\t\t\tthis._bindLocalizedAsset();\n\t\t\t}\n\t\t}\n\t}\n\n\tget localizedAsset() {\n\t\treturn this._localizedAsset;\n\t}\n\n\tset autoLoad(value) {\n\t\tif (this._autoLoad === value) return;\n\t\tthis._autoLoad = value;\n\n\t\tif (this._autoLoad && this._localizedAsset) {\n\t\t\tthis._unbindLocalizedAsset();\n\n\t\t\tthis._bindLocalizedAsset();\n\t\t}\n\t}\n\n\tget autoLoad() {\n\t\treturn this._autoLoad;\n\t}\n\n\tset disableLocalization(value) {\n\t\tif (this._disableLocalization === value) return;\n\t\tthis._disableLocalization = value;\n\n\t\tthis._onSetLocale(this._app.i18n.locale);\n\t}\n\n\tget disableLocalization() {\n\t\treturn this._disableLocalization;\n\t}\n\n\t_bindDefaultAsset() {\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\n\t\tif (!asset) {\n\t\t\tthis._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n\t\t} else {\n\t\t\tthis._onDefaultAssetAdd(asset);\n\t\t}\n\t}\n\n\t_unbindDefaultAsset() {\n\t\tif (!this._defaultAsset) return;\n\n\t\tthis._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\n\t\tif (!asset) return;\n\t\tasset.off('add:localized', this._onLocaleAdd, this);\n\t\tasset.off('remove:localized', this._onLocaleRemove, this);\n\t\tasset.off('remove', this._onDefaultAssetRemove, this);\n\t}\n\n\t_onDefaultAssetAdd(asset) {\n\t\tif (this._defaultAsset !== asset.id) return;\n\t\tasset.on('add:localized', this._onLocaleAdd, this);\n\t\tasset.on('remove:localized', this._onLocaleRemove, this);\n\t\tasset.once('remove', this._onDefaultAssetRemove, this);\n\t}\n\n\t_onDefaultAssetRemove(asset) {\n\t\tif (this._defaultAsset !== asset.id) return;\n\t\tasset.off('add:localized', this._onLocaleAdd, this);\n\t\tasset.off('remove:localized', this._onLocaleAdd, this);\n\n\t\tthis._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n\t}\n\n\t_bindLocalizedAsset() {\n\t\tif (!this._autoLoad) return;\n\n\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\n\t\tif (!asset) return;\n\t\tasset.on(\"load\", this._onLocalizedAssetLoad, this);\n\t\tasset.on(\"change\", this._onLocalizedAssetChange, this);\n\t\tasset.on(\"remove\", this._onLocalizedAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onLocalizedAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindLocalizedAsset() {\n\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\n\t\tif (!asset) return;\n\t\tasset.off(\"load\", this._onLocalizedAssetLoad, this);\n\t\tasset.off(\"change\", this._onLocalizedAssetChange, this);\n\t\tasset.off(\"remove\", this._onLocalizedAssetRemove, this);\n\t}\n\n\t_onLocalizedAssetAdd(asset) {\n\t\tif (this._localizedAsset !== asset.id) return;\n\n\t\tthis._bindLocalizedAsset();\n\t}\n\n\t_onLocalizedAssetLoad(asset) {\n\t\tthis.fire('load', asset);\n\t}\n\n\t_onLocalizedAssetChange(asset, name, newValue, oldValue) {\n\t\tthis.fire('change', asset, name, newValue, oldValue);\n\t}\n\n\t_onLocalizedAssetRemove(asset) {\n\t\tif (this._localizedAsset === asset.id) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t}\n\n\t\tthis.fire('remove', asset);\n\t}\n\n\t_onLocaleAdd(locale, assetId) {\n\t\tif (this._app.i18n.locale !== locale) return;\n\n\t\tthis._onSetLocale(locale);\n\t}\n\n\t_onLocaleRemove(locale, assetId) {\n\t\tif (this._app.i18n.locale !== locale) return;\n\n\t\tthis._onSetLocale(locale);\n\t}\n\n\t_onSetLocale(locale) {\n\t\tif (!this._defaultAsset) {\n\t\t\tthis.localizedAsset = null;\n\t\t\treturn;\n\t\t}\n\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\n\t\tif (!asset || this._disableLocalization) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t\treturn;\n\t\t}\n\n\t\tconst localizedAssetId = asset.getLocalizedAssetId(locale);\n\n\t\tif (!localizedAssetId) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.localizedAsset = localizedAssetId;\n\t}\n\n\tdestroy() {\n\t\tthis.defaultAsset = null;\n\n\t\tthis._app.i18n.off('set:locale', this._onSetLocale, this);\n\n\t\tthis.off();\n\t}\n\n}\n\nconst EOF_TOKEN = 0;\nconst ERROR_TOKEN = 1;\nconst TEXT_TOKEN = 2;\nconst OPEN_BRACKET_TOKEN = 3;\nconst CLOSE_BRACKET_TOKEN = 4;\nconst EQUALS_TOKEN = 5;\nconst STRING_TOKEN = 6;\nconst IDENTIFIER_TOKEN = 7;\nconst WHITESPACE_TOKEN = 8;\nconst WHITESPACE_CHARS = \" \\t\\n\\r\\v\\f\";\nconst IDENTIFIER_REGEX = /[A-Z|a-z|0-9|_|-|/]/;\n\nclass Scanner {\n\tconstructor(symbols) {\n\t\tthis._symbols = symbols;\n\t\tthis._index = 0;\n\t\tthis._last = 0;\n\t\tthis._cur = this._symbols.length > 0 ? this._symbols[0] : null;\n\t\tthis._buf = [];\n\t\tthis._mode = \"text\";\n\t\tthis._error = null;\n\t}\n\n\tread() {\n\t\tlet token = this._read();\n\n\t\twhile (token === WHITESPACE_TOKEN) {\n\t\t\ttoken = this._read();\n\t\t}\n\n\t\tif (token !== EOF_TOKEN && token !== ERROR_TOKEN) {\n\t\t\tthis._last = this._index;\n\t\t}\n\n\t\treturn token;\n\t}\n\n\tbuf() {\n\t\treturn this._buf;\n\t}\n\n\tlast() {\n\t\treturn this._last;\n\t}\n\n\terror() {\n\t\treturn this._error;\n\t}\n\n\tdebugPrint() {\n\t\tconst tokenStrings = [\"EOF\", \"ERROR\", \"TEXT\", \"OPEN_BRACKET\", \"CLOSE_BRACKET\", \"EQUALS\", \"STRING\", \"IDENTIFIER\", \"WHITESPACE\"];\n\t\tlet token = this.read();\n\t\tlet result = \"\";\n\n\t\twhile (true) {\n\t\t\tresult += (result.length > 0 ? \"\\n\" : \"\") + tokenStrings[token] + \" '\" + this.buf().join(\"\") + \"'\";\n\n\t\t\tif (token === EOF_TOKEN || token === ERROR_TOKEN) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttoken = this.read();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_read() {\n\t\tthis._buf = [];\n\n\t\tif (this._eof()) {\n\t\t\treturn EOF_TOKEN;\n\t\t}\n\n\t\treturn this._mode === \"text\" ? this._text() : this._tag();\n\t}\n\n\t_text() {\n\t\twhile (true) {\n\t\t\tswitch (this._cur) {\n\t\t\t\tcase null:\n\t\t\t\t\treturn this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;\n\n\t\t\t\tcase \"[\":\n\t\t\t\t\tthis._mode = \"tag\";\n\t\t\t\t\treturn this._buf.length > 0 ? TEXT_TOKEN : this._tag();\n\n\t\t\t\tcase \"\\\\\":\n\t\t\t\t\tthis._next();\n\n\t\t\t\t\tswitch (this._cur) {\n\t\t\t\t\t\tcase \"[\":\n\t\t\t\t\t\t\tthis._store();\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis._output(\"\\\\\");\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._store();\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_tag() {\n\t\tswitch (this._cur) {\n\t\t\tcase null:\n\t\t\t\tthis._error = \"unexpected end of input reading tag\";\n\t\t\t\treturn ERROR_TOKEN;\n\n\t\t\tcase \"[\":\n\t\t\t\tthis._store();\n\n\t\t\t\treturn OPEN_BRACKET_TOKEN;\n\n\t\t\tcase \"]\":\n\t\t\t\tthis._store();\n\n\t\t\t\tthis._mode = \"text\";\n\t\t\t\treturn CLOSE_BRACKET_TOKEN;\n\n\t\t\tcase \"=\":\n\t\t\t\tthis._store();\n\n\t\t\t\treturn EQUALS_TOKEN;\n\n\t\t\tcase \" \":\n\t\t\tcase \"\\t\":\n\t\t\tcase \"\\n\":\n\t\t\tcase \"\\r\":\n\t\t\tcase \"\\v\":\n\t\t\tcase \"\\f\":\n\t\t\t\treturn this._whitespace();\n\n\t\t\tcase \"\\\"\":\n\t\t\t\treturn this._string();\n\n\t\t\tdefault:\n\t\t\t\tif (!this._isIdentifierSymbol(this._cur)) {\n\t\t\t\t\tthis._error = \"unrecognized character\";\n\t\t\t\t\treturn ERROR_TOKEN;\n\t\t\t\t}\n\n\t\t\t\treturn this._identifier();\n\t\t}\n\t}\n\n\t_whitespace() {\n\t\tthis._store();\n\n\t\twhile (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {\n\t\t\tthis._store();\n\t\t}\n\n\t\treturn WHITESPACE_TOKEN;\n\t}\n\n\t_string() {\n\t\tthis._next();\n\n\t\twhile (true) {\n\t\t\tswitch (this._cur) {\n\t\t\t\tcase null:\n\t\t\t\t\tthis._error = \"unexpected end of input reading string\";\n\t\t\t\t\treturn ERROR_TOKEN;\n\n\t\t\t\tcase \"\\\"\":\n\t\t\t\t\tthis._next();\n\n\t\t\t\t\treturn STRING_TOKEN;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._store();\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_identifier() {\n\t\tthis._store();\n\n\t\twhile (this._cur !== null && this._isIdentifierSymbol(this._cur)) {\n\t\t\tthis._store();\n\t\t}\n\n\t\treturn IDENTIFIER_TOKEN;\n\t}\n\n\t_isIdentifierSymbol(s) {\n\t\treturn s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;\n\t}\n\n\t_eof() {\n\t\treturn this._cur === null;\n\t}\n\n\t_next() {\n\t\tif (!this._eof()) {\n\t\t\tthis._index++;\n\t\t\tthis._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;\n\t\t}\n\n\t\treturn this._cur;\n\t}\n\n\t_store() {\n\t\tthis._buf.push(this._cur);\n\n\t\treturn this._next();\n\t}\n\n\t_output(c) {\n\t\tthis._buf.push(c);\n\t}\n\n}\n\nclass Parser {\n\tconstructor(symbols) {\n\t\tthis._scanner = new Scanner(symbols);\n\t\tthis._error = null;\n\t}\n\n\tparse(symbols, tags) {\n\t\twhile (true) {\n\t\t\tconst token = this._scanner.read();\n\n\t\t\tswitch (token) {\n\t\t\t\tcase EOF_TOKEN:\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase ERROR_TOKEN:\n\t\t\t\t\treturn false;\n\n\t\t\t\tcase TEXT_TOKEN:\n\t\t\t\t\tArray.prototype.push.apply(symbols, this._scanner.buf());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase OPEN_BRACKET_TOKEN:\n\t\t\t\t\tif (!this._parseTag(symbols, tags)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\terror() {\n\t\treturn \"Error evaluating markup at #\" + this._scanner.last().toString() + \" (\" + (this._scanner.error() || this._error) + \")\";\n\t}\n\n\t_parseTag(symbols, tags) {\n\t\tlet token = this._scanner.read();\n\n\t\tif (token !== IDENTIFIER_TOKEN) {\n\t\t\tthis._error = \"expected identifier\";\n\t\t\treturn false;\n\t\t}\n\n\t\tconst name = this._scanner.buf().join(\"\");\n\n\t\tif (name[0] === \"/\") {\n\t\t\tfor (let index = tags.length - 1; index >= 0; --index) {\n\t\t\t\tif (name === \"/\" + tags[index].name && tags[index].end === null) {\n\t\t\t\t\ttags[index].end = symbols.length;\n\t\t\t\t\ttoken = this._scanner.read();\n\n\t\t\t\t\tif (token !== CLOSE_BRACKET_TOKEN) {\n\t\t\t\t\t\tthis._error = \"expected close bracket\";\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._error = \"failed to find matching tag\";\n\t\t\treturn false;\n\t\t}\n\n\t\tconst tag = {\n\t\t\tname: name,\n\t\t\tvalue: null,\n\t\t\tattributes: {},\n\t\t\tstart: symbols.length,\n\t\t\tend: null\n\t\t};\n\t\ttoken = this._scanner.read();\n\n\t\tif (token === EQUALS_TOKEN) {\n\t\t\ttoken = this._scanner.read();\n\n\t\t\tif (token !== STRING_TOKEN) {\n\t\t\t\tthis._error = \"expected string\";\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttag.value = this._scanner.buf().join(\"\");\n\t\t\ttoken = this._scanner.read();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tswitch (token) {\n\t\t\t\tcase CLOSE_BRACKET_TOKEN:\n\t\t\t\t\ttags.push(tag);\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase IDENTIFIER_TOKEN:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst identifier = this._scanner.buf().join(\"\");\n\n\t\t\t\t\t\ttoken = this._scanner.read();\n\n\t\t\t\t\t\tif (token !== EQUALS_TOKEN) {\n\t\t\t\t\t\t\tthis._error = \"expected equals\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttoken = this._scanner.read();\n\n\t\t\t\t\t\tif (token !== STRING_TOKEN) {\n\t\t\t\t\t\t\tthis._error = \"expected string\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst value = this._scanner.buf().join(\"\");\n\n\t\t\t\t\t\ttag.attributes[identifier] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._error = \"expected close bracket or identifier\";\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttoken = this._scanner.read();\n\t\t}\n\t}\n\n}\n\nfunction merge(target, source) {\n\tfor (const key in source) {\n\t\tif (!source.hasOwnProperty(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = source[key];\n\n\t\tif (value instanceof Object) {\n\t\t\tif (!target.hasOwnProperty(key)) {\n\t\t\t\ttarget[key] = {};\n\t\t\t}\n\n\t\t\tmerge(target[key], source[key]);\n\t\t} else {\n\t\t\ttarget[key] = value;\n\t\t}\n\t}\n}\n\nfunction combineTags(tags) {\n\tif (tags.length === 0) {\n\t\treturn null;\n\t}\n\n\tconst result = {};\n\n\tfor (let index = 0; index < tags.length; ++index) {\n\t\tconst tag = tags[index];\n\t\tconst tmp = {};\n\t\ttmp[tag.name] = {\n\t\t\tvalue: tag.value,\n\t\t\tattributes: tag.attributes\n\t\t};\n\t\tmerge(result, tmp);\n\t}\n\n\treturn result;\n}\n\nfunction resolveMarkupTags(tags, numSymbols) {\n\tif (tags.length === 0) {\n\t\treturn null;\n\t}\n\n\tconst edges = {};\n\n\tfor (let index = 0; index < tags.length; ++index) {\n\t\tconst tag = tags[index];\n\n\t\tif (!edges.hasOwnProperty(tag.start)) {\n\t\t\tedges[tag.start] = {\n\t\t\t\topen: [tag],\n\t\t\t\tclose: null\n\t\t\t};\n\t\t} else {\n\t\t\tif (edges[tag.start].open === null) {\n\t\t\t\tedges[tag.start].open = [tag];\n\t\t\t} else {\n\t\t\t\tedges[tag.start].open.push(tag);\n\t\t\t}\n\t\t}\n\n\t\tif (!edges.hasOwnProperty(tag.end)) {\n\t\t\tedges[tag.end] = {\n\t\t\t\topen: null,\n\t\t\t\tclose: [tag]\n\t\t\t};\n\t\t} else {\n\t\t\tif (edges[tag.end].close === null) {\n\t\t\t\tedges[tag.end].close = [tag];\n\t\t\t} else {\n\t\t\t\tedges[tag.end].close.push(tag);\n\t\t\t}\n\t\t}\n\t}\n\n\tlet tagStack = [];\n\n\tfunction removeTags(tags) {\n\t\ttagStack = tagStack.filter(function (tag) {\n\t\t\treturn tags.find(function (t) {\n\t\t\t\treturn t === tag;\n\t\t\t}) === undefined;\n\t\t});\n\t}\n\n\tfunction addTags(tags) {\n\t\tfor (let index = 0; index < tags.length; ++index) {\n\t\t\ttagStack.push(tags[index]);\n\t\t}\n\t}\n\n\tconst edgeKeys = Object.keys(edges).sort(function (a, b) {\n\t\treturn a - b;\n\t});\n\tconst resolvedTags = [];\n\n\tfor (let index = 0; index < edgeKeys.length; ++index) {\n\t\tconst edge = edges[edgeKeys[index]];\n\n\t\tif (edge.close !== null) {\n\t\t\tremoveTags(edge.close);\n\t\t}\n\n\t\tif (edge.open !== null) {\n\t\t\taddTags(edge.open);\n\t\t}\n\n\t\tresolvedTags.push({\n\t\t\tstart: edgeKeys[index],\n\t\t\ttags: combineTags(tagStack)\n\t\t});\n\t}\n\n\tconst result = [];\n\tlet prevTag = null;\n\n\tfor (let index = 0; index < resolvedTags.length; ++index) {\n\t\tconst resolvedTag = resolvedTags[index];\n\n\t\twhile (result.length < resolvedTag.start) {\n\t\t\tresult.push(prevTag ? prevTag.tags : null);\n\t\t}\n\n\t\tprevTag = resolvedTag;\n\t}\n\n\twhile (result.length < numSymbols) {\n\t\tresult.push(null);\n\t}\n\n\treturn result;\n}\n\nfunction evaluateMarkup(symbols) {\n\tconst parser = new Parser(symbols);\n\tconst stripped_symbols = [];\n\tconst tags = [];\n\n\tif (!parser.parse(stripped_symbols, tags)) {\n\t\tconsole.warn(parser.error());\n\t\treturn {\n\t\t\tsymbols: symbols,\n\t\t\ttags: null\n\t\t};\n\t}\n\n\tconst invalidTag = tags.find(function (t) {\n\t\treturn t.end === null;\n\t});\n\n\tif (invalidTag) {\n\t\tconsole.warn(`Markup error: found unclosed tag='${invalidTag.name}'`);\n\t\treturn {\n\t\t\tsymbols: symbols,\n\t\t\ttags: null\n\t\t};\n\t}\n\n\tconst resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);\n\treturn {\n\t\tsymbols: stripped_symbols,\n\t\ttags: resolved_tags\n\t};\n}\n\nclass Markup {\n\tstatic evaluate(symbols) {\n\t\treturn evaluateMarkup(symbols);\n\t}\n\n}\n\nclass MeshInfo {\n\tconstructor() {\n\t\tthis.count = 0;\n\t\tthis.quad = 0;\n\t\tthis.lines = {};\n\t\tthis.positions = [];\n\t\tthis.normals = [];\n\t\tthis.uvs = [];\n\t\tthis.colors = [];\n\t\tthis.indices = [];\n\t\tthis.meshInstance = null;\n\t}\n\n}\n\nconst LINE_BREAK_CHAR = /^[\\r\\n]$/;\nconst WHITESPACE_CHAR = /^[ \\t]$/;\nconst WORD_BOUNDARY_CHAR = /^[ \\t\\-]|[\\u200b]$/;\nconst ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;\nconst CJK_CHAR = /^[\\u1100-\\u11ff]|[\\u3000-\\u9fff]|[\\ua960-\\ua97f]|[\\uac00-\\ud7ff]$/;\nconst NO_LINE_BREAK_CJK_CHAR = /^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/;\nconst CONTROL_CHARS = ['\\u200B', '\\u061C', '\\u200E', '\\u200F', '\\u202A', '\\u202B', '\\u202C', '\\u202D', '\\u202E', '\\u2066', '\\u2067', '\\u2068', '\\u2069'];\nconst CONTROL_GLYPH_DATA = {\n\twidth: 0,\n\theight: 0,\n\txadvance: 0,\n\txoffset: 0,\n\tyoffset: 0\n};\n\nclass TextElement {\n\tconstructor(element) {\n\t\tthis._element = element;\n\t\tthis._system = element.system;\n\t\tthis._entity = element.entity;\n\t\tthis._text = \"\";\n\t\tthis._symbols = [];\n\t\tthis._colorPalette = [];\n\t\tthis._symbolColors = null;\n\t\tthis._i18nKey = null;\n\t\tthis._fontAsset = new LocalizedAsset(this._system.app);\n\t\tthis._fontAsset.disableLocalization = true;\n\n\t\tthis._fontAsset.on('load', this._onFontLoad, this);\n\n\t\tthis._fontAsset.on('change', this._onFontChange, this);\n\n\t\tthis._fontAsset.on('remove', this._onFontRemove, this);\n\n\t\tthis._font = null;\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array(3);\n\t\tthis._spacing = 1;\n\t\tthis._fontSize = 32;\n\t\tthis._fontMinY = 0;\n\t\tthis._fontMaxY = 0;\n\t\tthis._originalFontSize = 32;\n\t\tthis._maxFontSize = 32;\n\t\tthis._minFontSize = 8;\n\t\tthis._autoFitWidth = false;\n\t\tthis._autoFitHeight = false;\n\t\tthis._maxLines = -1;\n\t\tthis._lineHeight = 32;\n\t\tthis._scaledLineHeight = 32;\n\t\tthis._wrapLines = false;\n\t\tthis._drawOrder = 0;\n\t\tthis._alignment = new Vec2(0.5, 0.5);\n\t\tthis._autoWidth = true;\n\t\tthis._autoHeight = true;\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\tthis._node = new GraphNode();\n\t\tthis._model = new Model();\n\t\tthis._model.graph = this._node;\n\n\t\tthis._entity.addChild(this._node);\n\n\t\tthis._meshInfo = [];\n\t\tthis._material = null;\n\t\tthis._aabbDirty = true;\n\t\tthis._aabb = new BoundingBox();\n\t\tthis._noResize = false;\n\t\tthis._currentMaterialType = null;\n\t\tthis._maskedMaterialSrc = null;\n\t\tthis._rtlReorder = false;\n\t\tthis._unicodeConverter = false;\n\t\tthis._rtl = false;\n\t\tthis._outlineColor = new Color(0, 0, 0, 1);\n\t\tthis._outlineColorUniform = new Float32Array(4);\n\t\tthis._outlineThicknessScale = 0.2;\n\t\tthis._outlineThickness = 0.0;\n\t\tthis._shadowColor = new Color(0, 0, 0, 1);\n\t\tthis._shadowColorUniform = new Float32Array(4);\n\t\tthis._shadowOffsetScale = 0.005;\n\t\tthis._shadowOffset = new Vec2(0, 0);\n\t\tthis._shadowOffsetUniform = new Float32Array(2);\n\t\tthis._enableMarkup = false;\n\n\t\tthis._onScreenChange(this._element.screen);\n\n\t\telement.on('resize', this._onParentResize, this);\n\t\telement.on('set:screen', this._onScreenChange, this);\n\t\telement.on('screen:set:screenspace', this._onScreenSpaceChange, this);\n\t\telement.on('set:draworder', this._onDrawOrderChange, this);\n\t\telement.on('set:pivot', this._onPivotChange, this);\n\n\t\tthis._system.app.i18n.on('set:locale', this._onLocaleSet, this);\n\n\t\tthis._system.app.i18n.on('data:add', this._onLocalizationData, this);\n\n\t\tthis._system.app.i18n.on('data:remove', this._onLocalizationData, this);\n\n\t\tthis._rangeStart = 0;\n\t\tthis._rangeEnd = 0;\n\t}\n\n\tdestroy() {\n\t\tthis._setMaterial(null);\n\n\t\tif (this._model) {\n\t\t\tthis._element.removeModelFromLayers(this._model);\n\n\t\t\tthis._model.destroy();\n\n\t\t\tthis._model = null;\n\t\t}\n\n\t\tthis._fontAsset.destroy();\n\n\t\tthis.font = null;\n\n\t\tthis._element.off('resize', this._onParentResize, this);\n\n\t\tthis._element.off('set:screen', this._onScreenChange, this);\n\n\t\tthis._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);\n\n\t\tthis._element.off('set:draworder', this._onDrawOrderChange, this);\n\n\t\tthis._element.off('set:pivot', this._onPivotChange, this);\n\n\t\tthis._system.app.i18n.off('set:locale', this._onLocaleSet, this);\n\n\t\tthis._system.app.i18n.off('data:add', this._onLocalizationData, this);\n\n\t\tthis._system.app.i18n.off('data:remove', this._onLocalizationData, this);\n\t}\n\n\t_onParentResize(width, height) {\n\t\tif (this._noResize) return;\n\t\tif (this._font) this._updateText();\n\t}\n\n\t_onScreenChange(screen) {\n\t\tif (screen) {\n\t\t\tthis._updateMaterial(screen.screen.screenSpace);\n\t\t} else {\n\t\t\tthis._updateMaterial(false);\n\t\t}\n\t}\n\n\t_onScreenSpaceChange(value) {\n\t\tthis._updateMaterial(value);\n\t}\n\n\t_onDrawOrderChange(order) {\n\t\tthis._drawOrder = order;\n\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tthis._model.meshInstances[i].drawOrder = order;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onPivotChange(pivot) {\n\t\tif (this._font) this._updateText();\n\t}\n\n\t_onLocaleSet(locale) {\n\t\tif (!this._i18nKey) return;\n\n\t\tif (this.fontAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this.fontAsset);\n\n\t\t\tif (!asset || !asset.resource || asset.resource !== this._font) {\n\t\t\t\tthis.font = null;\n\t\t\t}\n\t\t}\n\n\t\tthis._resetLocalizedText();\n\t}\n\n\t_onLocalizationData(locale, messages) {\n\t\tif (this._i18nKey && messages[this._i18nKey]) {\n\t\t\tthis._resetLocalizedText();\n\t\t}\n\t}\n\n\t_resetLocalizedText() {\n\t\tthis._setText(this._system.app.i18n.getText(this._i18nKey));\n\t}\n\n\t_setText(text) {\n\t\tif (this.unicodeConverter) {\n\t\t\tconst unicodeConverterFunc = this._system.getUnicodeConverter();\n\n\t\t\tif (unicodeConverterFunc) {\n\t\t\t\ttext = unicodeConverterFunc(text);\n\t\t\t} else {\n\t\t\t\tconsole.warn('Element created with unicodeConverter option but no unicodeConverter function registered');\n\t\t\t}\n\t\t}\n\n\t\tif (this._text !== text) {\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText(text);\n\t\t\t}\n\n\t\t\tthis._text = text;\n\t\t}\n\t}\n\n\t_updateText(text) {\n\t\tlet tags;\n\t\tif (text === undefined) text = this._text;\n\t\tthis._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);\n\n\t\tif (this._symbols.length === 0) {\n\t\t\tthis._symbols = [\" \"];\n\t\t}\n\n\t\tif (this._enableMarkup) {\n\t\t\tconst results = Markup.evaluate(this._symbols);\n\t\t\tthis._symbols = results.symbols;\n\t\t\ttags = results.tags;\n\t\t}\n\n\t\tif (this._rtlReorder) {\n\t\t\tconst rtlReorderFunc = this._system.app.systems.element.getRtlReorder();\n\n\t\t\tif (rtlReorderFunc) {\n\t\t\t\tconst results = rtlReorderFunc(this._symbols);\n\t\t\t\tthis._rtl = results.rtl;\n\t\t\t\tthis._symbols = results.mapping.map(function (v) {\n\t\t\t\t\treturn this._symbols[v];\n\t\t\t\t}, this);\n\n\t\t\t\tif (tags) {\n\t\t\t\t\ttags = results.mapping.map(function (v) {\n\t\t\t\t\t\treturn tags[v];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn('Element created with rtlReorder option but no rtlReorder function registered');\n\t\t\t}\n\t\t} else {\n\t\t\tthis._rtl = false;\n\t\t}\n\n\t\tif (tags) {\n\t\t\tconst paletteMap = {};\n\t\t\tthis._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];\n\t\t\tthis._symbolColors = [];\n\t\t\tpaletteMap[this._color.toString(false).toLowerCase()] = 0;\n\n\t\t\tfor (let i = 0, len = this._symbols.length; i < len; ++i) {\n\t\t\t\tconst tag = tags[i];\n\t\t\t\tlet color = 0;\n\n\t\t\t\tif (tag && tag.color && tag.color.value) {\n\t\t\t\t\tconst c = tag.color.value;\n\n\t\t\t\t\tif (c.length === 7 && c[0] === \"#\") {\n\t\t\t\t\t\tconst hex = c.substring(1).toLowerCase();\n\n\t\t\t\t\t\tif (paletteMap.hasOwnProperty(hex)) {\n\t\t\t\t\t\t\tcolor = paletteMap[hex];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (/^([0-9a-f]{2}){3}$/.test(hex)) {\n\t\t\t\t\t\t\t\tcolor = this._colorPalette.length / 3;\n\t\t\t\t\t\t\t\tpaletteMap[hex] = color;\n\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(0, 2), 16));\n\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(2, 4), 16));\n\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(4, 6), 16));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._symbolColors.push(color);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._colorPalette = [];\n\t\t\tthis._symbolColors = null;\n\t\t}\n\n\t\tconst charactersPerTexture = this._calculateCharsPerTexture();\n\n\t\tlet removedModel = false;\n\t\tconst element = this._element;\n\n\t\tconst screenSpace = element._isScreenSpace();\n\n\t\tconst screenCulled = element._isScreenCulled();\n\n\t\tconst visibleFn = function visibleFn(camera) {\n\t\t\treturn element.isVisibleForCamera(camera);\n\t\t};\n\n\t\tfor (let i = 0, len = this._meshInfo.length; i < len; i++) {\n\t\t\tconst l = charactersPerTexture[i] || 0;\n\t\t\tconst meshInfo = this._meshInfo[i];\n\n\t\t\tif (meshInfo.count !== l) {\n\t\t\t\tif (!removedModel) {\n\t\t\t\t\telement.removeModelFromLayers(this._model);\n\t\t\t\t\tremovedModel = true;\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.count = l;\n\t\t\t\tmeshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;\n\t\t\t\tmeshInfo.indices.length = l * 3 * 2;\n\t\t\t\tmeshInfo.uvs.length = l * 2 * 4;\n\t\t\t\tmeshInfo.colors.length = l * 4 * 4;\n\n\t\t\t\tif (meshInfo.meshInstance) {\n\t\t\t\t\tthis._removeMeshInstance(meshInfo.meshInstance);\n\t\t\t\t}\n\n\t\t\t\tif (l === 0) {\n\t\t\t\t\tmeshInfo.meshInstance = null;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (let v = 0; v < l; v++) {\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 0] = v * 4;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 0] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 1] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 2] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 3] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 4] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 5] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 6] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 7] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 8] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 9] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 10] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 11] = -1;\n\t\t\t\t}\n\n\t\t\t\tconst mesh = createMesh$1(this._system.app.graphicsDevice, meshInfo.positions, {\n\t\t\t\t\tuvs: meshInfo.uvs,\n\t\t\t\t\tnormals: meshInfo.normals,\n\t\t\t\t\tcolors: meshInfo.colors,\n\t\t\t\t\tindices: meshInfo.indices\n\t\t\t\t});\n\t\t\t\tconst mi = new MeshInstance(mesh, this._material, this._node);\n\t\t\t\tmi.name = \"Text Element: \" + this._entity.name;\n\t\t\t\tmi.castShadow = false;\n\t\t\t\tmi.receiveShadow = false;\n\t\t\t\tmi.cull = !screenSpace;\n\t\t\t\tmi.screenSpace = screenSpace;\n\t\t\t\tmi.drawOrder = this._drawOrder;\n\n\t\t\t\tif (screenCulled) {\n\t\t\t\t\tmi.cull = true;\n\t\t\t\t\tmi.isVisibleFunc = visibleFn;\n\t\t\t\t}\n\n\t\t\t\tthis._setTextureParams(mi, this._font.textures[i]);\n\n\t\t\t\tif (this._symbolColors) {\n\t\t\t\t\tthis._colorUniform[0] = 1;\n\t\t\t\t\tthis._colorUniform[1] = 1;\n\t\t\t\t\tthis._colorUniform[2] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\t\t\tthis._colorUniform[2] = this._color.b;\n\t\t\t\t}\n\n\t\t\t\tmi.setParameter(\"material_emissive\", this._colorUniform);\n\t\t\t\tmi.setParameter(\"material_opacity\", this._color.a);\n\t\t\t\tmi.setParameter(\"font_sdfIntensity\", this._font.intensity);\n\t\t\t\tmi.setParameter(\"font_pxrange\", this._getPxRange(this._font));\n\t\t\t\tmi.setParameter(\"font_textureWidth\", this._font.data.info.maps[i].width);\n\t\t\t\tthis._outlineColorUniform[0] = this._outlineColor.r;\n\t\t\t\tthis._outlineColorUniform[1] = this._outlineColor.g;\n\t\t\t\tthis._outlineColorUniform[2] = this._outlineColor.b;\n\t\t\t\tthis._outlineColorUniform[3] = this._outlineColor.a;\n\t\t\t\tmi.setParameter(\"outline_color\", this._outlineColorUniform);\n\t\t\t\tmi.setParameter(\"outline_thickness\", this._outlineThicknessScale * this._outlineThickness);\n\t\t\t\tthis._shadowColorUniform[0] = this._shadowColor.r;\n\t\t\t\tthis._shadowColorUniform[1] = this._shadowColor.g;\n\t\t\t\tthis._shadowColorUniform[2] = this._shadowColor.b;\n\t\t\t\tthis._shadowColorUniform[3] = this._shadowColor.a;\n\t\t\t\tmi.setParameter(\"shadow_color\", this._shadowColorUniform);\n\t\t\t\tconst ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;\n\t\t\t\tthis._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;\n\t\t\t\tthis._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;\n\t\t\t\tmi.setParameter(\"shadow_offset\", this._shadowOffsetUniform);\n\t\t\t\tmeshInfo.meshInstance = mi;\n\n\t\t\t\tthis._model.meshInstances.push(mi);\n\t\t\t}\n\t\t}\n\n\t\tif (this._element.maskedBy) {\n\t\t\tthis._element._setMaskedBy(this._element.maskedBy);\n\t\t}\n\n\t\tif (removedModel && this._element.enabled && this._entity.enabled) {\n\t\t\tthis._element.addModelToLayers(this._model);\n\t\t}\n\n\t\tthis._updateMeshes();\n\n\t\tthis._rangeStart = 0;\n\t\tthis._rangeEnd = this._symbols.length;\n\n\t\tthis._updateRenderRange();\n\t}\n\n\t_removeMeshInstance(meshInstance) {\n\t\tmeshInstance.destroy();\n\n\t\tconst idx = this._model.meshInstances.indexOf(meshInstance);\n\n\t\tif (idx !== -1) this._model.meshInstances.splice(idx, 1);\n\t}\n\n\t_setMaterial(material) {\n\t\tthis._material = material;\n\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.material = material;\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateMaterial(screenSpace) {\n\t\tconst element = this._element;\n\n\t\tconst screenCulled = element._isScreenCulled();\n\n\t\tconst visibleFn = function visibleFn(camera) {\n\t\t\treturn element.isVisibleForCamera(camera);\n\t\t};\n\n\t\tconst msdf = this._font && this._font.type === FONT_MSDF;\n\t\tthis._material = this._system.getTextElementMaterial(screenSpace, msdf);\n\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.cull = !screenSpace;\n\t\t\t\tmi.material = this._material;\n\t\t\t\tmi.screenSpace = screenSpace;\n\n\t\t\t\tif (screenCulled) {\n\t\t\t\t\tmi.cull = true;\n\t\t\t\t\tmi.isVisibleFunc = visibleFn;\n\t\t\t\t} else {\n\t\t\t\t\tmi.isVisibleFunc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_isWordBoundary(char) {\n\t\treturn WORD_BOUNDARY_CHAR.test(char);\n\t}\n\n\t_isValidNextChar(nextchar) {\n\t\treturn nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);\n\t}\n\n\t_isNextCJKBoundary(char, nextchar) {\n\t\treturn CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));\n\t}\n\n\t_isNextCJKWholeWord(nextchar) {\n\t\treturn CJK_CHAR.test(nextchar);\n\t}\n\n\t_updateMeshes() {\n\t\tconst json = this._font.data;\n\t\tconst self = this;\n\t\tconst minFont = Math.min(this._minFontSize, this._maxFontSize);\n\t\tconst maxFont = this._maxFontSize;\n\n\t\tconst autoFit = this._shouldAutoFit();\n\n\t\tif (autoFit) {\n\t\t\tthis._fontSize = this._maxFontSize;\n\t\t}\n\n\t\tconst MAGIC = 32;\n\t\tconst l = this._symbols.length;\n\t\tlet _x = 0;\n\t\tlet _y = 0;\n\t\tlet _z = 0;\n\t\tlet _xMinusTrailingWhitespace = 0;\n\t\tlet lines = 1;\n\t\tlet wordStartX = 0;\n\t\tlet wordStartIndex = 0;\n\t\tlet lineStartIndex = 0;\n\t\tlet numWordsThisLine = 0;\n\t\tlet numCharsThisLine = 0;\n\t\tlet numBreaksThisLine = 0;\n\t\tconst splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;\n\t\tlet maxLineWidth = this._element.calculatedWidth;\n\n\t\tif (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {\n\t\t\tmaxLineWidth = Number.POSITIVE_INFINITY;\n\t\t}\n\n\t\tlet fontMinY = 0;\n\t\tlet fontMaxY = 0;\n\t\tlet char, data, quad, nextchar;\n\n\t\tfunction breakLine(symbols, lineBreakIndex, lineBreakX) {\n\t\t\tself._lineWidths.push(Math.abs(lineBreakX));\n\n\t\t\tconst sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;\n\t\t\tconst sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;\n\t\t\tconst chars = symbols.slice(sliceStart, sliceEnd);\n\n\t\t\tif (numBreaksThisLine) {\n\t\t\t\tlet i = chars.length;\n\n\t\t\t\twhile (i-- && numBreaksThisLine > 0) {\n\t\t\t\t\tif (LINE_BREAK_CHAR.test(chars[i])) {\n\t\t\t\t\t\tchars.splice(i, 1);\n\t\t\t\t\t\tnumBreaksThisLine--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tself._lineContents.push(chars.join(''));\n\n\t\t\t_x = 0;\n\t\t\t_y -= self._scaledLineHeight;\n\t\t\tlines++;\n\t\t\tnumWordsThisLine = 0;\n\t\t\tnumCharsThisLine = 0;\n\t\t\tnumBreaksThisLine = 0;\n\t\t\twordStartX = 0;\n\t\t\tlineStartIndex = lineBreakIndex;\n\t\t}\n\n\t\tlet retryUpdateMeshes = true;\n\n\t\twhile (retryUpdateMeshes) {\n\t\t\tretryUpdateMeshes = false;\n\n\t\t\tif (autoFit) {\n\t\t\t\tthis._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);\n\t\t\t} else {\n\t\t\t\tthis._scaledLineHeight = this._lineHeight;\n\t\t\t}\n\n\t\t\tthis.width = 0;\n\t\t\tthis.height = 0;\n\t\t\tthis._lineWidths = [];\n\t\t\tthis._lineContents = [];\n\t\t\t_x = 0;\n\t\t\t_y = 0;\n\t\t\t_z = 0;\n\t\t\t_xMinusTrailingWhitespace = 0;\n\t\t\tlines = 1;\n\t\t\twordStartX = 0;\n\t\t\twordStartIndex = 0;\n\t\t\tlineStartIndex = 0;\n\t\t\tnumWordsThisLine = 0;\n\t\t\tnumCharsThisLine = 0;\n\t\t\tnumBreaksThisLine = 0;\n\t\t\tconst scale = this._fontSize / MAGIC;\n\t\t\tfontMinY = this._fontMinY * scale;\n\t\t\tfontMaxY = this._fontMaxY * scale;\n\n\t\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\t\tthis._meshInfo[i].quad = 0;\n\t\t\t\tthis._meshInfo[i].lines = {};\n\t\t\t}\n\n\t\t\tlet color_r = 255;\n\t\t\tlet color_g = 255;\n\t\t\tlet color_b = 255;\n\n\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\tchar = this._symbols[i];\n\t\t\t\tnextchar = i + 1 >= l ? null : this._symbols[i + 1];\n\t\t\t\tconst isLineBreak = LINE_BREAK_CHAR.test(char);\n\n\t\t\t\tif (isLineBreak) {\n\t\t\t\t\tnumBreaksThisLine++;\n\n\t\t\t\t\tif (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {\n\t\t\t\t\t\tbreakLine(this._symbols, i, _xMinusTrailingWhitespace);\n\t\t\t\t\t\twordStartIndex = i + 1;\n\t\t\t\t\t\tlineStartIndex = i + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet x = 0;\n\t\t\t\tlet y = 0;\n\t\t\t\tlet advance = 0;\n\t\t\t\tlet quadsize = 1;\n\t\t\t\tlet dataScale, size;\n\t\t\t\tdata = json.chars[char];\n\n\t\t\t\tif (!data) {\n\t\t\t\t\tif (CONTROL_CHARS.indexOf(char) !== -1) {\n\t\t\t\t\t\tdata = CONTROL_GLYPH_DATA;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (json.chars[' ']) {\n\t\t\t\t\t\t\tdata = json.chars[' '];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (const key in json.chars) {\n\t\t\t\t\t\t\t\tdata = json.chars[key];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (data) {\n\t\t\t\t\tlet kerning = 0;\n\n\t\t\t\t\tif (numCharsThisLine > 0) {\n\t\t\t\t\t\tconst kernTable = this._font.data.kerning;\n\n\t\t\t\t\t\tif (kernTable) {\n\t\t\t\t\t\t\tconst kernLeft = kernTable[string.getCodePoint(this._symbols[i - 1]) || 0];\n\n\t\t\t\t\t\t\tif (kernLeft) {\n\t\t\t\t\t\t\t\tkerning = kernLeft[string.getCodePoint(this._symbols[i]) || 0] || 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdataScale = data.scale || 1;\n\t\t\t\t\tsize = (data.width + data.height) / 2;\n\t\t\t\t\tquadsize = scale * size / dataScale;\n\t\t\t\t\tadvance = (data.xadvance + kerning) * scale;\n\t\t\t\t\tx = (data.xoffset - kerning) * scale;\n\t\t\t\t\ty = data.yoffset * scale;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`Couldn't substitute missing character: '${char}'`);\n\t\t\t\t}\n\n\t\t\t\tconst isWhitespace = WHITESPACE_CHAR.test(char);\n\t\t\t\tconst meshInfo = this._meshInfo[data && data.map || 0];\n\t\t\t\tconst candidateLineWidth = _x + this._spacing * advance;\n\n\t\t\t\tif (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {\n\t\t\t\t\tif (this._maxLines < 0 || lines < this._maxLines) {\n\t\t\t\t\t\tif (numWordsThisLine === 0) {\n\t\t\t\t\t\t\twordStartIndex = i;\n\t\t\t\t\t\t\tbreakLine(this._symbols, i, _xMinusTrailingWhitespace);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst backtrack = Math.max(i - wordStartIndex, 0);\n\n\t\t\t\t\t\t\tif (this._meshInfo.length <= 1) {\n\t\t\t\t\t\t\t\tmeshInfo.lines[lines - 1] -= backtrack;\n\t\t\t\t\t\t\t\tmeshInfo.quad -= backtrack;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst backtrackStart = wordStartIndex;\n\t\t\t\t\t\t\t\tconst backtrackEnd = i;\n\n\t\t\t\t\t\t\t\tfor (let j = backtrackStart; j < backtrackEnd; j++) {\n\t\t\t\t\t\t\t\t\tconst backChar = this._symbols[j];\n\t\t\t\t\t\t\t\t\tconst backCharData = json.chars[backChar];\n\t\t\t\t\t\t\t\t\tconst backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];\n\t\t\t\t\t\t\t\t\tbackMeshInfo.lines[lines - 1] -= 1;\n\t\t\t\t\t\t\t\t\tbackMeshInfo.quad -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ti -= backtrack + 1;\n\t\t\t\t\t\t\tbreakLine(this._symbols, wordStartIndex, wordStartX);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tquad = meshInfo.quad;\n\t\t\t\tmeshInfo.lines[lines - 1] = quad;\n\t\t\t\tlet left = _x - x;\n\t\t\t\tlet right = left + quadsize;\n\t\t\t\tconst bottom = _y - y;\n\t\t\t\tconst top = bottom + quadsize;\n\n\t\t\t\tif (this._rtl) {\n\t\t\t\t\tconst shift = quadsize - x - this._spacing * advance - x;\n\t\t\t\t\tleft -= shift;\n\t\t\t\t\tright -= shift;\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 0] = left;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 1] = bottom;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 2] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 3] = right;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 4] = bottom;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 5] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 6] = right;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 7] = top;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 8] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 9] = left;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 10] = top;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 11] = _z;\n\t\t\t\tthis.width = Math.max(this.width, candidateLineWidth);\n\t\t\t\tlet fontSize;\n\n\t\t\t\tif (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {\n\t\t\t\t\tfontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));\n\t\t\t\t\tfontSize = math.clamp(fontSize, minFont, maxFont);\n\n\t\t\t\t\tif (fontSize !== this._element.fontSize) {\n\t\t\t\t\t\tthis._fontSize = fontSize;\n\t\t\t\t\t\tretryUpdateMeshes = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.height = Math.max(this.height, fontMaxY - (_y + fontMinY));\n\n\t\t\t\tif (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {\n\t\t\t\t\tfontSize = math.clamp(this._fontSize - 1, minFont, maxFont);\n\n\t\t\t\t\tif (fontSize !== this._element.fontSize) {\n\t\t\t\t\t\tthis._fontSize = fontSize;\n\t\t\t\t\t\tretryUpdateMeshes = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_x += this._spacing * advance;\n\n\t\t\t\tif (!isWhitespace) {\n\t\t\t\t\t_xMinusTrailingWhitespace = _x;\n\t\t\t\t}\n\n\t\t\t\tif (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {\n\t\t\t\t\tnumWordsThisLine++;\n\t\t\t\t\twordStartX = _xMinusTrailingWhitespace;\n\t\t\t\t\twordStartIndex = i + 1;\n\t\t\t\t}\n\n\t\t\t\tnumCharsThisLine++;\n\n\t\t\t\tconst uv = this._getUv(char);\n\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 0] = uv[0];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 2] = uv[2];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 4] = uv[2];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 6] = uv[0];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];\n\n\t\t\t\tif (this._symbolColors) {\n\t\t\t\t\tconst colorIdx = this._symbolColors[i] * 3;\n\t\t\t\t\tcolor_r = this._colorPalette[colorIdx];\n\t\t\t\t\tcolor_g = this._colorPalette[colorIdx + 1];\n\t\t\t\t\tcolor_b = this._colorPalette[colorIdx + 2];\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 0] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 1] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 2] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 3] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 4] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 5] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 6] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 7] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 8] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 9] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 10] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 11] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 12] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 13] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 14] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 15] = 255;\n\t\t\t\tmeshInfo.quad++;\n\t\t\t}\n\n\t\t\tif (retryUpdateMeshes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineStartIndex < l) {\n\t\t\t\tbreakLine(this._symbols, l, _x);\n\t\t\t}\n\t\t}\n\n\t\tthis._noResize = true;\n\t\tthis.autoWidth = this._autoWidth;\n\t\tthis.autoHeight = this._autoHeight;\n\t\tthis._noResize = false;\n\t\tconst hp = this._element.pivot.x;\n\t\tconst vp = this._element.pivot.y;\n\t\tconst ha = this._alignment.x;\n\t\tconst va = this._alignment.y;\n\n\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\tif (this._meshInfo[i].count === 0) continue;\n\t\t\tlet prevQuad = 0;\n\n\t\t\tfor (const line in this._meshInfo[i].lines) {\n\t\t\t\tconst index = this._meshInfo[i].lines[line];\n\n\t\t\t\tconst lw = this._lineWidths[parseInt(line, 10)];\n\n\t\t\t\tconst hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);\n\t\t\t\tconst voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);\n\n\t\t\t\tfor (let _quad = prevQuad; _quad <= index; _quad++) {\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 3] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 6] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 9] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 1] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 4] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 7] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 10] += voffset;\n\t\t\t\t}\n\n\t\t\t\tif (this._rtl) {\n\t\t\t\t\tfor (let _quad2 = prevQuad; _quad2 <= index; _quad2++) {\n\t\t\t\t\t\tconst idx = _quad2 * 4 * 3;\n\n\t\t\t\t\t\tfor (let vert = 0; vert < 4; ++vert) {\n\t\t\t\t\t\t\tthis._meshInfo[i].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst tmp0 = this._meshInfo[i].positions[idx + 3];\n\t\t\t\t\t\tconst tmp1 = this._meshInfo[i].positions[idx + 6];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 0] = tmp0;\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 9] = tmp1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevQuad = index + 1;\n\t\t\t}\n\n\t\t\tconst numVertices = this._meshInfo[i].count * 4;\n\t\t\tconst vertMax = this._meshInfo[i].quad * 4;\n\t\t\tconst it = new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);\n\n\t\t\tfor (let v = 0; v < numVertices; v++) {\n\t\t\t\tif (v >= vertMax) {\n\t\t\t\t\tit.element[SEMANTIC_POSITION].set(0, 0, 0);\n\t\t\t\t\tit.element[SEMANTIC_TEXCOORD0].set(0, 0);\n\t\t\t\t\tit.element[SEMANTIC_COLOR].set(0, 0, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tit.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);\n\t\t\t\t\tit.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);\n\t\t\t\t\tit.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0], this._meshInfo[i].colors[v * 4 + 1], this._meshInfo[i].colors[v * 4 + 2], this._meshInfo[i].colors[v * 4 + 3]);\n\t\t\t\t}\n\n\t\t\t\tit.next();\n\t\t\t}\n\n\t\t\tit.end();\n\n\t\t\tthis._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);\n\n\t\t\tthis._meshInfo[i].meshInstance._aabbVer = -1;\n\t\t}\n\n\t\tthis._aabbDirty = true;\n\t}\n\n\t_onFontRender() {\n\t\tthis.font = this._font;\n\t}\n\n\t_onFontLoad(asset) {\n\t\tif (this.font !== asset.resource) {\n\t\t\tthis.font = asset.resource;\n\t\t}\n\t}\n\n\t_onFontChange(asset, name, _new, _old) {\n\t\tif (name === 'data') {\n\t\t\tthis._font.data = _new;\n\t\t\tconst maps = this._font.data.info.maps.length;\n\n\t\t\tfor (let i = 0; i < maps; i++) {\n\t\t\t\tif (!this._meshInfo[i]) continue;\n\t\t\t\tconst mi = this._meshInfo[i].meshInstance;\n\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.setParameter(\"font_sdfIntensity\", this._font.intensity);\n\t\t\t\t\tmi.setParameter(\"font_pxrange\", this._getPxRange(this._font));\n\t\t\t\t\tmi.setParameter(\"font_textureWidth\", this._font.data.info.maps[i].width);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onFontRemove(asset) {}\n\n\t_setTextureParams(mi, texture) {\n\t\tif (this._font) {\n\t\t\tif (this._font.type === FONT_MSDF) {\n\t\t\t\tmi.deleteParameter(\"texture_emissiveMap\");\n\t\t\t\tmi.deleteParameter(\"texture_opacityMap\");\n\t\t\t\tmi.setParameter(\"texture_msdfMap\", texture);\n\t\t\t} else if (this._font.type === FONT_BITMAP) {\n\t\t\t\tmi.deleteParameter(\"texture_msdfMap\");\n\t\t\t\tmi.setParameter(\"texture_emissiveMap\", texture);\n\t\t\t\tmi.setParameter(\"texture_opacityMap\", texture);\n\t\t\t}\n\t\t}\n\t}\n\n\t_getPxRange(font) {\n\t\tconst keys = Object.keys(this._font.data.chars);\n\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst char = this._font.data.chars[keys[i]];\n\n\t\t\tif (char.range) {\n\t\t\t\treturn (char.scale || 1) * char.range;\n\t\t\t}\n\t\t}\n\n\t\treturn 2;\n\t}\n\n\t_getUv(char) {\n\t\tconst data = this._font.data;\n\n\t\tif (!data.chars[char]) {\n\t\t\tconst space = ' ';\n\n\t\t\tif (data.chars[space]) {\n\t\t\t\treturn this._getUv(space);\n\t\t\t}\n\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\n\t\tconst map = data.chars[char].map;\n\t\tconst width = data.info.maps[map].width;\n\t\tconst height = data.info.maps[map].height;\n\t\tconst x = data.chars[char].x;\n\t\tconst y = data.chars[char].y;\n\t\tconst x1 = x;\n\t\tconst y1 = y;\n\t\tconst x2 = x + data.chars[char].width;\n\t\tconst y2 = y - data.chars[char].height;\n\t\tconst edge = 1 - data.chars[char].height / height;\n\t\treturn [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];\n\t}\n\n\tonEnable() {\n\t\tthis._fontAsset.autoLoad = true;\n\n\t\tif (this._model) {\n\t\t\tthis._element.addModelToLayers(this._model);\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tthis._fontAsset.autoLoad = false;\n\n\t\tif (this._model) {\n\t\t\tthis._element.removeModelFromLayers(this._model);\n\t\t}\n\t}\n\n\t_setStencil(stencilParams) {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0; i < instances.length; i++) {\n\t\t\t\tinstances[i].stencilFront = stencilParams;\n\t\t\t\tinstances[i].stencilBack = stencilParams;\n\t\t\t}\n\t\t}\n\t}\n\n\t_shouldAutoFitWidth() {\n\t\treturn this._autoFitWidth && !this._autoWidth;\n\t}\n\n\t_shouldAutoFitHeight() {\n\t\treturn this._autoFitHeight && !this._autoHeight;\n\t}\n\n\t_shouldAutoFit() {\n\t\treturn this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;\n\t}\n\n\t_calculateCharsPerTexture(symbolIndex) {\n\t\tconst charactersPerTexture = {};\n\n\t\tif (symbolIndex === undefined) {\n\t\t\tsymbolIndex = this._symbols.length;\n\t\t}\n\n\t\tfor (let i = 0, len = symbolIndex; i < len; i++) {\n\t\t\tconst char = this._symbols[i];\n\t\t\tlet info = this._font.data.chars[char];\n\n\t\t\tif (!info) {\n\t\t\t\tinfo = this._font.data.chars[' '];\n\n\t\t\t\tif (!info) {\n\t\t\t\t\tinfo = this._font.data.chars[Object.keys(this._font.data.chars)[0]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst map = info.map;\n\n\t\t\tif (!charactersPerTexture[map]) {\n\t\t\t\tcharactersPerTexture[map] = 1;\n\t\t\t} else {\n\t\t\t\tcharactersPerTexture[map]++;\n\t\t\t}\n\t\t}\n\n\t\treturn charactersPerTexture;\n\t}\n\n\t_updateRenderRange() {\n\t\tconst startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);\n\t\tconst endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);\n\n\t\tfor (let i = 0, len = this._meshInfo.length; i < len; i++) {\n\t\t\tconst start = startChars[i] || 0;\n\t\t\tconst end = endChars[i] || 0;\n\t\t\tconst instance = this._meshInfo[i].meshInstance;\n\n\t\t\tif (instance) {\n\t\t\t\tconst mesh = instance.mesh;\n\n\t\t\t\tif (mesh) {\n\t\t\t\t\tmesh.primitive[0].base = start * 3 * 2;\n\t\t\t\t\tmesh.primitive[0].count = (end - start) * 3 * 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset text(value) {\n\t\tthis._i18nKey = null;\n\t\tconst str = value != null && value.toString() || \"\";\n\n\t\tthis._setText(str);\n\t}\n\n\tget text() {\n\t\treturn this._text;\n\t}\n\n\tset key(value) {\n\t\tconst str = value !== null ? value.toString() : null;\n\n\t\tif (this._i18nKey === str) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._i18nKey = str;\n\n\t\tif (str) {\n\t\t\tthis._fontAsset.disableLocalization = false;\n\n\t\t\tthis._resetLocalizedText();\n\t\t} else {\n\t\t\tthis._fontAsset.disableLocalization = true;\n\t\t}\n\t}\n\n\tget key() {\n\t\treturn this._i18nKey;\n\t}\n\n\tset color(value) {\n\t\tconst r = value.r;\n\t\tconst g = value.g;\n\t\tconst b = value.b;\n\n\t\tif (this._color.r !== r || this._color.g !== g || this._color.b !== b) {\n\t\t\tthis._color.r = r;\n\t\t\tthis._color.g = g;\n\t\t\tthis._color.b = b;\n\n\t\t\tif (this._symbolColors) {\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter('material_emissive', this._colorUniform);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:color', this._color);\n\t\t}\n\t}\n\n\tget color() {\n\t\treturn this._color;\n\t}\n\n\tset opacity(value) {\n\t\tif (this._color.a !== value) {\n\t\t\tthis._color.a = value;\n\n\t\t\tif (this._model) {\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter('material_opacity', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:opacity', value);\n\t\t}\n\t}\n\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\n\tset lineHeight(value) {\n\t\tconst _prev = this._lineHeight;\n\t\tthis._lineHeight = value;\n\t\tthis._scaledLineHeight = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget lineHeight() {\n\t\treturn this._lineHeight;\n\t}\n\n\tset wrapLines(value) {\n\t\tconst _prev = this._wrapLines;\n\t\tthis._wrapLines = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget wrapLines() {\n\t\treturn this._wrapLines;\n\t}\n\n\tget lines() {\n\t\treturn this._lineContents;\n\t}\n\n\tset spacing(value) {\n\t\tconst _prev = this._spacing;\n\t\tthis._spacing = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget spacing() {\n\t\treturn this._spacing;\n\t}\n\n\tset fontSize(value) {\n\t\tconst _prev = this._fontSize;\n\t\tthis._fontSize = value;\n\t\tthis._originalFontSize = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget fontSize() {\n\t\treturn this._fontSize;\n\t}\n\n\tset fontAsset(value) {\n\t\tthis._fontAsset.defaultAsset = value;\n\t}\n\n\tget fontAsset() {\n\t\treturn this._fontAsset.localizedAsset;\n\t}\n\n\tset font(value) {\n\t\tlet previousFontType;\n\n\t\tif (this._font) {\n\t\t\tpreviousFontType = this._font.type;\n\t\t\tif (this._font.off) this._font.off('render', this._onFontRender, this);\n\t\t}\n\n\t\tthis._font = value;\n\t\tthis._fontMinY = 0;\n\t\tthis._fontMaxY = 0;\n\t\tif (!value) return;\n\t\tconst json = this._font.data;\n\n\t\tfor (const charId in json.chars) {\n\t\t\tconst data = json.chars[charId];\n\n\t\t\tif (data.bounds) {\n\t\t\t\tthis._fontMinY = Math.min(this._fontMinY, data.bounds[1]);\n\t\t\t\tthis._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);\n\t\t\t}\n\t\t}\n\n\t\tif (this._font.on) this._font.on('render', this._onFontRender, this);\n\n\t\tif (this._fontAsset.localizedAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._fontAsset.localizedAsset);\n\n\t\t\tif (asset.resource !== this._font) {\n\t\t\t\tthis._fontAsset.defaultAsset = null;\n\t\t\t}\n\t\t}\n\n\t\tif (value.type !== previousFontType) {\n\t\t\tconst screenSpace = this._element._isScreenSpace();\n\n\t\t\tthis._updateMaterial(screenSpace);\n\t\t}\n\n\t\tfor (let i = 0, len = this._font.textures.length; i < len; i++) {\n\t\t\tif (!this._meshInfo[i]) {\n\t\t\t\tthis._meshInfo[i] = new MeshInfo();\n\t\t\t} else {\n\t\t\t\tconst mi = this._meshInfo[i].meshInstance;\n\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.setParameter(\"font_sdfIntensity\", this._font.intensity);\n\t\t\t\t\tmi.setParameter(\"font_pxrange\", this._getPxRange(this._font));\n\t\t\t\t\tmi.setParameter(\"font_textureWidth\", this._font.data.info.maps[i].width);\n\n\t\t\t\t\tthis._setTextureParams(mi, this._font.textures[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet removedModel = false;\n\n\t\tfor (let i = this._font.textures.length; i < this._meshInfo.length; i++) {\n\t\t\tif (this._meshInfo[i].meshInstance) {\n\t\t\t\tif (!removedModel) {\n\t\t\t\t\tthis._element.removeModelFromLayers(this._model);\n\n\t\t\t\t\tremovedModel = true;\n\t\t\t\t}\n\n\t\t\t\tthis._removeMeshInstance(this._meshInfo[i].meshInstance);\n\t\t\t}\n\t\t}\n\n\t\tif (this._meshInfo.length > this._font.textures.length) this._meshInfo.length = this._font.textures.length;\n\n\t\tthis._updateText();\n\t}\n\n\tget font() {\n\t\treturn this._font;\n\t}\n\n\tset alignment(value) {\n\t\tif (value instanceof Vec2) {\n\t\t\tthis._alignment.set(value.x, value.y);\n\t\t} else {\n\t\t\tthis._alignment.set(value[0], value[1]);\n\t\t}\n\n\t\tif (this._font) this._updateText();\n\t}\n\n\tget alignment() {\n\t\treturn this._alignment;\n\t}\n\n\tset autoWidth(value) {\n\t\tconst old = this._autoWidth;\n\t\tthis._autoWidth = value;\n\n\t\tif (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {\n\t\t\tthis._element.width = this.width;\n\t\t}\n\n\t\tif (old !== value) {\n\t\t\tconst newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\n\t\t\tif (newFontSize !== this._fontSize) {\n\t\t\t\tthis._fontSize = newFontSize;\n\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget autoWidth() {\n\t\treturn this._autoWidth;\n\t}\n\n\tset autoHeight(value) {\n\t\tconst old = this._autoHeight;\n\t\tthis._autoHeight = value;\n\n\t\tif (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {\n\t\t\tthis._element.height = this.height;\n\t\t}\n\n\t\tif (old !== value) {\n\t\t\tconst newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\n\t\t\tif (newFontSize !== this._fontSize) {\n\t\t\t\tthis._fontSize = newFontSize;\n\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget autoHeight() {\n\t\treturn this._autoHeight;\n\t}\n\n\tset rtlReorder(value) {\n\t\tif (this._rtlReorder !== value) {\n\t\t\tthis._rtlReorder = value;\n\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText();\n\t\t\t}\n\t\t}\n\t}\n\n\tget rtlReorder() {\n\t\treturn this._rtlReorder;\n\t}\n\n\tset unicodeConverter(value) {\n\t\tif (this._unicodeConverter !== value) {\n\t\t\tthis._unicodeConverter = value;\n\n\t\t\tthis._setText(this._text);\n\t\t}\n\t}\n\n\tget unicodeConverter() {\n\t\treturn this._unicodeConverter;\n\t}\n\n\tget aabb() {\n\t\tif (this._aabbDirty) {\n\t\t\tlet initialized = false;\n\n\t\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\t\tif (!this._meshInfo[i].meshInstance) continue;\n\n\t\t\t\tif (!initialized) {\n\t\t\t\t\tthis._aabb.copy(this._meshInfo[i].meshInstance.aabb);\n\n\t\t\t\t\tinitialized = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._aabb.add(this._meshInfo[i].meshInstance.aabb);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._aabbDirty = false;\n\t\t}\n\n\t\treturn this._aabb;\n\t}\n\n\tset outlineColor(value) {\n\t\tconst r = value instanceof Color ? value.r : value[0];\n\t\tconst g = value instanceof Color ? value.g : value[1];\n\t\tconst b = value instanceof Color ? value.b : value[2];\n\t\tconst a = value instanceof Color ? value.a : value[3];\n\n\t\tif (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._outlineColor.r = r;\n\t\tthis._outlineColor.g = g;\n\t\tthis._outlineColor.b = b;\n\t\tthis._outlineColor.a = a;\n\n\t\tif (this._model) {\n\t\t\tthis._outlineColorUniform[0] = this._outlineColor.r;\n\t\t\tthis._outlineColorUniform[1] = this._outlineColor.g;\n\t\t\tthis._outlineColorUniform[2] = this._outlineColor.b;\n\t\t\tthis._outlineColorUniform[3] = this._outlineColor.a;\n\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter(\"outline_color\", this._outlineColorUniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tget outlineColor() {\n\t\treturn this._outlineColor;\n\t}\n\n\tset outlineThickness(value) {\n\t\tconst _prev = this._outlineThickness;\n\t\tthis._outlineThickness = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tif (this._model) {\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter(\"outline_thickness\", this._outlineThicknessScale * this._outlineThickness);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget outlineThickness() {\n\t\treturn this._outlineThickness;\n\t}\n\n\tset shadowColor(value) {\n\t\tconst r = value instanceof Color ? value.r : value[0];\n\t\tconst g = value instanceof Color ? value.g : value[1];\n\t\tconst b = value instanceof Color ? value.b : value[2];\n\t\tconst a = value instanceof Color ? value.a : value[3];\n\n\t\tif (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._shadowColor.r = r;\n\t\tthis._shadowColor.g = g;\n\t\tthis._shadowColor.b = b;\n\t\tthis._shadowColor.a = a;\n\n\t\tif (this._model) {\n\t\t\tthis._shadowColorUniform[0] = this._shadowColor.r;\n\t\t\tthis._shadowColorUniform[1] = this._shadowColor.g;\n\t\t\tthis._shadowColorUniform[2] = this._shadowColor.b;\n\t\t\tthis._shadowColorUniform[3] = this._shadowColor.a;\n\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter(\"shadow_color\", this._shadowColorUniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tget shadowColor() {\n\t\treturn this._shadowColor;\n\t}\n\n\tset shadowOffset(value) {\n\t\tconst x = value instanceof Vec2 ? value.x : value[0],\n\t\t\t\t\ty = value instanceof Vec2 ? value.y : value[1];\n\n\t\tif (this._shadowOffset.x === x && this._shadowOffset.y === y) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._shadowOffset.set(x, y);\n\n\t\tif (this._font && this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;\n\t\t\t\tthis._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;\n\t\t\t\tthis._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter(\"shadow_offset\", this._shadowOffsetUniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tget shadowOffset() {\n\t\treturn this._shadowOffset;\n\t}\n\n\tset minFontSize(value) {\n\t\tif (this._minFontSize === value) return;\n\t\tthis._minFontSize = value;\n\n\t\tif (this.font && this._shouldAutoFit()) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget minFontSize() {\n\t\treturn this._minFontSize;\n\t}\n\n\tset maxFontSize(value) {\n\t\tif (this._maxFontSize === value) return;\n\t\tthis._maxFontSize = value;\n\n\t\tif (this.font && this._shouldAutoFit()) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget maxFontSize() {\n\t\treturn this._maxFontSize;\n\t}\n\n\tset autoFitWidth(value) {\n\t\tif (this._autoFitWidth === value) return;\n\t\tthis._autoFitWidth = value;\n\t\tthis._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget autoFitWidth() {\n\t\treturn this._autoFitWidth;\n\t}\n\n\tset autoFitHeight(value) {\n\t\tif (this._autoFitHeight === value) return;\n\t\tthis._autoFitHeight = value;\n\t\tthis._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget autoFitHeight() {\n\t\treturn this._autoFitHeight;\n\t}\n\n\tset maxLines(value) {\n\t\tif (this._maxLines === value) return;\n\t\tif (value === null && this._maxLines === -1) return;\n\t\tthis._maxLines = value === null ? -1 : value;\n\n\t\tif (this.font && this._wrapLines) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget maxLines() {\n\t\treturn this._maxLines;\n\t}\n\n\tset enableMarkup(value) {\n\t\tvalue = !!value;\n\t\tif (this._enableMarkup === value) return;\n\t\tthis._enableMarkup = value;\n\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget enableMarkup() {\n\t\treturn this._enableMarkup;\n\t}\n\n\tget symbols() {\n\t\treturn this._symbols;\n\t}\n\n\tget symbolColors() {\n\t\tif (this._symbolColors === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._symbolColors.map(function (c) {\n\t\t\treturn this._colorPalette.slice(c * 3, c * 3 + 3);\n\t\t}, this);\n\t}\n\n\tget rtl() {\n\t\treturn this._rtl;\n\t}\n\n\tset rangeStart(rangeStart) {\n\t\trangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));\n\n\t\tif (rangeStart !== this._rangeStart) {\n\t\t\tthis._rangeStart = rangeStart;\n\n\t\t\tthis._updateRenderRange();\n\t\t}\n\t}\n\n\tget rangeStart() {\n\t\treturn this._rangeStart;\n\t}\n\n\tset rangeEnd(rangeEnd) {\n\t\trangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));\n\n\t\tif (rangeEnd !== this._rangeEnd) {\n\t\t\tthis._rangeEnd = rangeEnd;\n\n\t\t\tthis._updateRenderRange();\n\t\t}\n\t}\n\n\tget rangeEnd() {\n\t\treturn this._rangeEnd;\n\t}\n\n}\n\nconst position = new Vec3();\nconst invParentWtm = new Mat4();\nconst vecA$1 = new Vec3();\nconst vecB$1 = new Vec3();\nconst matA = new Mat4();\nconst matB = new Mat4();\nconst matC = new Mat4();\nconst matD = new Mat4();\n\nclass ElementComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._beingInitialized = false;\n\t\tthis._anchor = new Vec4();\n\t\tthis._localAnchor = new Vec4();\n\t\tthis._pivot = new Vec2();\n\t\tthis._width = this._calculatedWidth = 32;\n\t\tthis._height = this._calculatedHeight = 32;\n\t\tthis._margin = new Vec4(0, 0, -32, -32);\n\t\tthis._modelTransform = new Mat4();\n\t\tthis._screenToWorld = new Mat4();\n\t\tthis._anchorTransform = new Mat4();\n\t\tthis._anchorDirty = true;\n\t\tthis._parentWorldTransform = new Mat4();\n\t\tthis._screenTransform = new Mat4();\n\t\tthis._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\t\tthis._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];\n\t\tthis._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\t\tthis._cornersDirty = true;\n\t\tthis._canvasCornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\t\tthis.entity.on('insert', this._onInsert, this);\n\n\t\tthis._patch();\n\n\t\tthis.screen = null;\n\t\tthis._type = ELEMENTTYPE_GROUP;\n\t\tthis._image = null;\n\t\tthis._text = null;\n\t\tthis._group = null;\n\t\tthis._drawOrder = 0;\n\t\tthis._useInput = false;\n\t\tthis._layers = [LAYERID_UI];\n\t\tthis._addedModels = [];\n\t\tthis._batchGroupId = -1;\n\t\tthis._offsetReadAt = 0;\n\t\tthis._maskOffset = 0.5;\n\t\tthis._maskedBy = null;\n\t}\n\n\tget _absLeft() {\n\t\treturn this._localAnchor.x + this._margin.x;\n\t}\n\n\tget _absRight() {\n\t\treturn this._localAnchor.z - this._margin.z;\n\t}\n\n\tget _absTop() {\n\t\treturn this._localAnchor.w - this._margin.w;\n\t}\n\n\tget _absBottom() {\n\t\treturn this._localAnchor.y + this._margin.y;\n\t}\n\n\tget _hasSplitAnchorsX() {\n\t\treturn Math.abs(this._anchor.x - this._anchor.z) > 0.001;\n\t}\n\n\tget _hasSplitAnchorsY() {\n\t\treturn Math.abs(this._anchor.y - this._anchor.w) > 0.001;\n\t}\n\n\tget aabb() {\n\t\tif (this._image) return this._image.aabb;\n\t\tif (this._text) return this._text.aabb;\n\t\treturn null;\n\t}\n\n\tset anchor(value) {\n\t\tif (value instanceof Vec4) {\n\t\t\tthis._anchor.set(value.x, value.y, value.z, value.w);\n\t\t} else {\n\t\t\tthis._anchor.set(value[0], value[1], value[2], value[3]);\n\t\t}\n\n\t\tif (!this.entity._parent && !this.screen) {\n\t\t\tthis._calculateLocalAnchors();\n\t\t} else {\n\t\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\t\t}\n\n\t\tthis._anchorDirty = true;\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire('set:anchor', this._anchor);\n\t}\n\n\tget anchor() {\n\t\treturn this._anchor;\n\t}\n\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) return;\n\n\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\tthis.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tthis.system.app.batcher.insert(BatchGroup.ELEMENT, value, this.entity);\n\t\t}\n\n\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tif (this._image && this._image._renderable.model) {\n\t\t\t\tthis.addModelToLayers(this._image._renderable.model);\n\t\t\t} else if (this._text && this._text._model) {\n\t\t\t\tthis.addModelToLayers(this._text._model);\n\t\t\t}\n\t\t}\n\n\t\tthis._batchGroupId = value;\n\t}\n\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\n\tset bottom(value) {\n\t\tthis._margin.y = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wt = this._absTop;\n\t\tconst wb = this._localAnchor.y + value;\n\n\t\tthis._setHeight(wt - wb);\n\n\t\tp.y = value + this._calculatedHeight * this._pivot.y;\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\n\tget bottom() {\n\t\treturn this._margin.y;\n\t}\n\n\tset calculatedWidth(value) {\n\t\tthis._setCalculatedWidth(value, true);\n\t}\n\n\tget calculatedWidth() {\n\t\treturn this._calculatedWidth;\n\t}\n\n\tset calculatedHeight(value) {\n\t\tthis._setCalculatedHeight(value, true);\n\t}\n\n\tget calculatedHeight() {\n\t\treturn this._calculatedHeight;\n\t}\n\n\tget canvasCorners() {\n\t\tif (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst screenCorners = this.screenCorners;\n\t\tconst sx = device.canvas.clientWidth / device.width;\n\t\tconst sy = device.canvas.clientHeight / device.height;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tthis._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);\n\t\t}\n\n\t\tthis._canvasCornersDirty = false;\n\t\treturn this._canvasCorners;\n\t}\n\n\tset drawOrder(value) {\n\t\tlet priority = 0;\n\n\t\tif (this.screen) {\n\t\t\tpriority = this.screen.screen.priority;\n\t\t}\n\n\t\tif (value > 0xFFFFFF) {\n\t\t\tvalue = 0xFFFFFF;\n\t\t}\n\n\t\tthis._drawOrder = (priority << 24) + value;\n\t\tthis.fire('set:draworder', this._drawOrder);\n\t}\n\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\n\tset height(value) {\n\t\tthis._height = value;\n\n\t\tif (!this._hasSplitAnchorsY) {\n\t\t\tthis._setCalculatedHeight(value, true);\n\t\t}\n\n\t\tthis.fire('set:height', this._height);\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\tset layers(value) {\n\t\tif (this._addedModels.length) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\n\t\t\t\tif (layer) {\n\t\t\t\t\tfor (let j = 0; j < this._addedModels.length; j++) {\n\t\t\t\t\t\tlayer.removeMeshInstances(this._addedModels[j].meshInstances);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._layers = value;\n\t\tif (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tfor (let j = 0; j < this._addedModels.length; j++) {\n\t\t\t\t\tlayer.addMeshInstances(this._addedModels[j].meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset left(value) {\n\t\tthis._margin.x = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wr = this._absRight;\n\t\tconst wl = this._localAnchor.x + value;\n\n\t\tthis._setWidth(wr - wl);\n\n\t\tp.x = value + this._calculatedWidth * this._pivot.x;\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\n\tget left() {\n\t\treturn this._margin.x;\n\t}\n\n\tset margin(value) {\n\t\tthis._margin.copy(value);\n\n\t\tthis._calculateSize(true, true);\n\n\t\tthis.fire('set:margin', this._margin);\n\t}\n\n\tget margin() {\n\t\treturn this._margin;\n\t}\n\n\tget maskedBy() {\n\t\treturn this._maskedBy;\n\t}\n\n\tset pivot(value) {\n\t\tconst prevX = this._pivot.x;\n\t\tconst prevY = this._pivot.y;\n\n\t\tif (value instanceof Vec2) {\n\t\t\tthis._pivot.set(value.x, value.y);\n\t\t} else {\n\t\t\tthis._pivot.set(value[0], value[1]);\n\t\t}\n\n\t\tconst mx = this._margin.x + this._margin.z;\n\t\tconst dx = this._pivot.x - prevX;\n\t\tthis._margin.x += mx * dx;\n\t\tthis._margin.z -= mx * dx;\n\t\tconst my = this._margin.y + this._margin.w;\n\t\tconst dy = this._pivot.y - prevY;\n\t\tthis._margin.y += my * dy;\n\t\tthis._margin.w -= my * dy;\n\t\tthis._anchorDirty = true;\n\t\tthis._cornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\n\t\tthis._calculateSize(false, false);\n\n\t\tthis._flagChildrenAsDirty();\n\n\t\tthis.fire('set:pivot', this._pivot);\n\t}\n\n\tget pivot() {\n\t\treturn this._pivot;\n\t}\n\n\tset right(value) {\n\t\tthis._margin.z = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wl = this._absLeft;\n\t\tconst wr = this._localAnchor.z - value;\n\n\t\tthis._setWidth(wr - wl);\n\n\t\tp.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\n\tget right() {\n\t\treturn this._margin.z;\n\t}\n\n\tget screenCorners() {\n\t\tif (!this._cornersDirty || !this.screen) return this._screenCorners;\n\t\tconst parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];\n\n\t\tthis._screenCorners[0].set(this._absLeft, this._absBottom, 0);\n\n\t\tthis._screenCorners[1].set(this._absRight, this._absBottom, 0);\n\n\t\tthis._screenCorners[2].set(this._absRight, this._absTop, 0);\n\n\t\tthis._screenCorners[3].set(this._absLeft, this._absTop, 0);\n\n\t\tconst screenSpace = this.screen.screen.screenSpace;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tthis._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);\n\n\t\t\tif (screenSpace) this._screenCorners[i].mulScalar(this.screen.screen.scale);\n\n\t\t\tif (parentBottomLeft) {\n\t\t\t\tthis._screenCorners[i].add(parentBottomLeft);\n\t\t\t}\n\t\t}\n\n\t\tthis._cornersDirty = false;\n\t\tthis._canvasCornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\t\treturn this._screenCorners;\n\t}\n\n\tget textWidth() {\n\t\treturn this._text ? this._text.width : 0;\n\t}\n\n\tget textHeight() {\n\t\treturn this._text ? this._text.height : 0;\n\t}\n\n\tset top(value) {\n\t\tthis._margin.w = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wb = this._absBottom;\n\t\tconst wt = this._localAnchor.w - value;\n\n\t\tthis._setHeight(wt - wb);\n\n\t\tp.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\n\tget top() {\n\t\treturn this._margin.w;\n\t}\n\n\tset type(value) {\n\t\tif (value !== this._type) {\n\t\t\tthis._type = value;\n\n\t\t\tif (this._image) {\n\t\t\t\tthis._image.destroy();\n\n\t\t\t\tthis._image = null;\n\t\t\t}\n\n\t\t\tif (this._text) {\n\t\t\t\tthis._text.destroy();\n\n\t\t\t\tthis._text = null;\n\t\t\t}\n\n\t\t\tif (value === ELEMENTTYPE_IMAGE) {\n\t\t\t\tthis._image = new ImageElement(this);\n\t\t\t} else if (value === ELEMENTTYPE_TEXT) {\n\t\t\t\tthis._text = new TextElement(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset useInput(value) {\n\t\tif (this._useInput === value) return;\n\t\tthis._useInput = value;\n\n\t\tif (this.system.app.elementInput) {\n\t\t\tif (value) {\n\t\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\t\tthis.system.app.elementInput.addElement(this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._useInput === true) {\n\t\t\t\tconsole.warn(\"Elements will not get any input events because this.system.app.elementInput is not created\");\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('set:useInput', value);\n\t}\n\n\tget useInput() {\n\t\treturn this._useInput;\n\t}\n\n\tset width(value) {\n\t\tthis._width = value;\n\n\t\tif (!this._hasSplitAnchorsX) {\n\t\t\tthis._setCalculatedWidth(value, true);\n\t\t}\n\n\t\tthis.fire('set:width', this._width);\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\n\tget worldCorners() {\n\t\tif (!this._worldCornersDirty) {\n\t\t\treturn this._worldCorners;\n\t\t}\n\n\t\tif (this.screen) {\n\t\t\tconst screenCorners = this.screenCorners;\n\n\t\t\tif (!this.screen.screen.screenSpace) {\n\t\t\t\tmatA.copy(this.screen.screen._screenMatrix);\n\t\t\t\tmatA.data[13] = -matA.data[13];\n\t\t\t\tmatA.mul2(this.screen.getWorldTransform(), matA);\n\n\t\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\t\tmatA.transformPoint(screenCorners[i], this._worldCorners[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst localPos = this.entity.getLocalPosition();\n\t\t\tmatA.setTranslate(-localPos.x, -localPos.y, -localPos.z);\n\t\t\tmatB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());\n\t\t\tmatC.setTranslate(localPos.x, localPos.y, localPos.z);\n\t\t\tconst entity = this.entity.parent ? this.entity.parent : this.entity;\n\t\t\tmatD.copy(entity.getWorldTransform());\n\t\t\tmatD.mul(matC).mul(matB).mul(matA);\n\t\t\tvecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA$1, this._worldCorners[0]);\n\t\t\tvecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA$1, this._worldCorners[1]);\n\t\t\tvecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA$1, this._worldCorners[2]);\n\t\t\tvecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA$1, this._worldCorners[3]);\n\t\t}\n\n\t\tthis._worldCornersDirty = false;\n\t\treturn this._worldCorners;\n\t}\n\n\t_patch() {\n\t\tthis.entity._sync = this._sync;\n\t\tthis.entity.setPosition = this._setPosition;\n\t\tthis.entity.setLocalPosition = this._setLocalPosition;\n\t}\n\n\t_unpatch() {\n\t\tthis.entity._sync = Entity.prototype._sync;\n\t\tthis.entity.setPosition = Entity.prototype.setPosition;\n\t\tthis.entity.setLocalPosition = Entity.prototype.setLocalPosition;\n\t}\n\n\t_setPosition(x, y, z) {\n\t\tif (!this.element.screen) return Entity.prototype.setPosition.call(this, x, y, z);\n\n\t\tif (x instanceof Vec3) {\n\t\t\tposition.copy(x);\n\t\t} else {\n\t\t\tposition.set(x, y, z);\n\t\t}\n\n\t\tthis.getWorldTransform();\n\t\tinvParentWtm.copy(this.element._screenToWorld).invert();\n\t\tinvParentWtm.transformPoint(position, this.localPosition);\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\t_setLocalPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localPosition.copy(x);\n\t\t} else {\n\t\t\tthis.localPosition.set(x, y, z);\n\t\t}\n\n\t\tconst element = this.element;\n\t\tconst p = this.localPosition;\n\t\tconst pvt = element._pivot;\n\t\telement._margin.x = p.x - element._calculatedWidth * pvt.x;\n\t\telement._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;\n\t\telement._margin.y = p.y - element._calculatedHeight * pvt.y;\n\t\telement._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\t_sync() {\n\t\tconst element = this.element;\n\t\tconst screen = element.screen;\n\n\t\tif (screen) {\n\t\t\tif (element._anchorDirty) {\n\t\t\t\tlet resx = 0;\n\t\t\t\tlet resy = 0;\n\t\t\t\tlet px = 0;\n\t\t\t\tlet py = 1;\n\n\t\t\t\tif (this._parent && this._parent.element) {\n\t\t\t\t\tresx = this._parent.element.calculatedWidth;\n\t\t\t\t\tresy = this._parent.element.calculatedHeight;\n\t\t\t\t\tpx = this._parent.element.pivot.x;\n\t\t\t\t\tpy = this._parent.element.pivot.y;\n\t\t\t\t} else {\n\t\t\t\t\tconst resolution = screen.screen.resolution;\n\t\t\t\t\tresx = resolution.x / screen.screen.scale;\n\t\t\t\t\tresy = resolution.y / screen.screen.scale;\n\t\t\t\t}\n\n\t\t\t\telement._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);\n\n\t\t\t\telement._anchorDirty = false;\n\n\t\t\t\telement._calculateLocalAnchors();\n\t\t\t}\n\n\t\t\tif (element._sizeDirty) {\n\t\t\t\telement._calculateSize(false, false);\n\t\t\t}\n\t\t}\n\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tconst p = this.localPosition;\n\t\t\tconst pvt = element._pivot;\n\t\t\telement._margin.x = p.x - element._calculatedWidth * pvt.x;\n\t\t\telement._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;\n\t\t\telement._margin.y = p.y - element._calculatedHeight * pvt.y;\n\t\t\telement._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\n\t\tif (!screen) {\n\t\t\tif (this._dirtyWorld) {\n\t\t\t\telement._cornersDirty = true;\n\t\t\t\telement._canvasCornersDirty = true;\n\t\t\t\telement._worldCornersDirty = true;\n\t\t\t}\n\n\t\t\treturn Entity.prototype._sync.call(this);\n\t\t}\n\n\t\tif (this._dirtyWorld) {\n\t\t\tif (this._parent === null) {\n\t\t\t\tthis.worldTransform.copy(this.localTransform);\n\t\t\t} else {\n\t\t\t\tif (this._parent.element) {\n\t\t\t\t\telement._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);\n\t\t\t\t} else {\n\t\t\t\t\telement._screenToWorld.copy(element._anchorTransform);\n\t\t\t\t}\n\n\t\t\t\telement._modelTransform.mul2(element._screenToWorld, this.localTransform);\n\n\t\t\t\tif (screen) {\n\t\t\t\t\telement._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);\n\n\t\t\t\t\tif (!screen.screen.screenSpace) {\n\t\t\t\t\t\telement._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.worldTransform.mul2(element._screenToWorld, this.localTransform);\n\t\t\t\t\tconst parentWorldTransform = element._parentWorldTransform;\n\t\t\t\t\tparentWorldTransform.setIdentity();\n\t\t\t\t\tconst parent = this._parent;\n\n\t\t\t\t\tif (parent && parent.element && parent !== screen) {\n\t\t\t\t\t\tmatA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());\n\t\t\t\t\t\tparentWorldTransform.mul2(parent.element._parentWorldTransform, matA);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst depthOffset = vecA$1;\n\t\t\t\t\tdepthOffset.set(0, 0, this.localPosition.z);\n\t\t\t\t\tconst pivotOffset = vecB$1;\n\t\t\t\t\tpivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);\n\t\t\t\t\tmatA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);\n\t\t\t\t\tmatB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());\n\t\t\t\t\tmatC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);\n\n\t\t\t\t\telement._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);\n\n\t\t\t\t\telement._cornersDirty = true;\n\t\t\t\t\telement._canvasCornersDirty = true;\n\t\t\t\t\telement._worldCornersDirty = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.worldTransform.copy(element._modelTransform);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirtyWorld = false;\n\t\t}\n\t}\n\n\t_onInsert(parent) {\n\t\tconst result = this._parseUpToScreen();\n\n\t\tthis.entity._dirtifyWorld();\n\n\t\tthis._updateScreen(result.screen);\n\n\t\tthis._dirtifyMask();\n\t}\n\n\t_dirtifyMask() {\n\t\tlet current = this.entity;\n\n\t\twhile (current) {\n\t\t\tconst next = current.parent;\n\n\t\t\tif ((next === null || next.screen) && current.element) {\n\t\t\t\tif (!this.system._prerender || !this.system._prerender.length) {\n\t\t\t\t\tthis.system._prerender = [];\n\t\t\t\t\tthis.system.app.once('prerender', this._onPrerender, this);\n\t\t\t\t}\n\n\t\t\t\tconst i = this.system._prerender.indexOf(this.entity);\n\n\t\t\t\tif (i >= 0) {\n\t\t\t\t\tthis.system._prerender.splice(i, 1);\n\t\t\t\t}\n\n\t\t\t\tconst j = this.system._prerender.indexOf(current);\n\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tthis.system._prerender.push(current);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrent = next;\n\t\t}\n\t}\n\n\t_onPrerender() {\n\t\tfor (let i = 0; i < this.system._prerender.length; i++) {\n\t\t\tconst mask = this.system._prerender[i];\n\n\t\t\tif (mask.element) {\n\t\t\t\tconst depth = 1;\n\t\t\t\tmask.element.syncMask(depth);\n\t\t\t}\n\t\t}\n\n\t\tthis.system._prerender.length = 0;\n\t}\n\n\t_bindScreen(screen) {\n\t\tscreen._bindElement(this);\n\t}\n\n\t_unbindScreen(screen) {\n\t\tscreen._unbindElement(this);\n\t}\n\n\t_updateScreen(screen) {\n\t\tif (this.screen && this.screen !== screen) {\n\t\t\tthis._unbindScreen(this.screen.screen);\n\t\t}\n\n\t\tconst previousScreen = this.screen;\n\t\tthis.screen = screen;\n\n\t\tif (this.screen) {\n\t\t\tthis._bindScreen(this.screen.screen);\n\t\t}\n\n\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\n\t\tthis.fire('set:screen', this.screen, previousScreen);\n\t\tthis._anchorDirty = true;\n\t\tconst children = this.entity.children;\n\n\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\tif (children[i].element) children[i].element._updateScreen(screen);\n\t\t}\n\n\t\tif (this.screen) this.screen.screen.syncDrawOrder();\n\t}\n\n\tsyncMask(depth) {\n\t\tconst result = this._parseUpToScreen();\n\n\t\tthis._updateMask(result.mask, depth);\n\t}\n\n\t_setMaskedBy(mask) {\n\t\tconst renderableElement = this._image || this._text;\n\n\t\tif (mask) {\n\t\t\tconst ref = mask.element._image._maskRef;\n\t\t\tconst sp = new StencilParameters({\n\t\t\t\tref: ref,\n\t\t\t\tfunc: FUNC_EQUAL\n\t\t\t});\n\n\t\t\tif (renderableElement && renderableElement._setStencil) {\n\t\t\t\trenderableElement._setStencil(sp);\n\t\t\t}\n\n\t\t\tthis._maskedBy = mask;\n\t\t} else {\n\t\t\tif (renderableElement && renderableElement._setStencil) {\n\t\t\t\trenderableElement._setStencil(null);\n\t\t\t}\n\n\t\t\tthis._maskedBy = null;\n\t\t}\n\t}\n\n\t_updateMask(currentMask, depth) {\n\t\tif (currentMask) {\n\t\t\tthis._setMaskedBy(currentMask);\n\n\t\t\tif (this.mask) {\n\t\t\t\tconst ref = currentMask.element._image._maskRef;\n\t\t\t\tconst sp = new StencilParameters({\n\t\t\t\t\tref: ref,\n\t\t\t\t\tfunc: FUNC_EQUAL,\n\t\t\t\t\tzpass: STENCILOP_INCREMENT\n\t\t\t\t});\n\n\t\t\t\tthis._image._setStencil(sp);\n\n\t\t\t\tthis._image._maskRef = depth;\n\t\t\t\tdepth++;\n\t\t\t\tcurrentMask = this.entity;\n\t\t\t}\n\n\t\t\tconst children = this.entity.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i].element) {\n\t\t\t\t\tchildren[i].element._updateMask(currentMask, depth);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mask) depth--;\n\t\t} else {\n\t\t\tthis._setMaskedBy(null);\n\n\t\t\tif (this.mask) {\n\t\t\t\tconst sp = new StencilParameters({\n\t\t\t\t\tref: depth,\n\t\t\t\t\tfunc: FUNC_ALWAYS,\n\t\t\t\t\tzpass: STENCILOP_REPLACE\n\t\t\t\t});\n\n\t\t\t\tthis._image._setStencil(sp);\n\n\t\t\t\tthis._image._maskRef = depth;\n\t\t\t\tdepth++;\n\t\t\t\tcurrentMask = this.entity;\n\t\t\t}\n\n\t\t\tconst children = this.entity.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i].element) {\n\t\t\t\t\tchildren[i].element._updateMask(currentMask, depth);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mask) depth--;\n\t\t}\n\t}\n\n\t_parseUpToScreen() {\n\t\tconst result = {\n\t\t\tscreen: null,\n\t\t\tmask: null\n\t\t};\n\t\tlet parent = this.entity._parent;\n\n\t\twhile (parent && !parent.screen) {\n\t\t\tif (parent.element && parent.element.mask) {\n\t\t\t\tif (!result.mask) result.mask = parent;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\tif (parent && parent.screen) result.screen = parent;\n\t\treturn result;\n\t}\n\n\t_onScreenResize(res) {\n\t\tthis._anchorDirty = true;\n\t\tthis._cornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\n\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\n\t\tthis.fire('screen:set:resolution', res);\n\t}\n\n\t_onScreenSpaceChange() {\n\t\tthis.fire('screen:set:screenspace', this.screen.screen.screenSpace);\n\t}\n\n\t_onScreenRemove() {\n\t\tif (this.screen) {\n\t\t\tif (this.screen._destroying) {\n\t\t\t\tthis.screen = null;\n\t\t\t} else {\n\t\t\t\tthis._updateScreen(null);\n\t\t\t}\n\t\t}\n\t}\n\n\t_calculateLocalAnchors() {\n\t\tlet resx = 1000;\n\t\tlet resy = 1000;\n\t\tconst parent = this.entity._parent;\n\n\t\tif (parent && parent.element) {\n\t\t\tresx = parent.element.calculatedWidth;\n\t\t\tresy = parent.element.calculatedHeight;\n\t\t} else if (this.screen) {\n\t\t\tconst res = this.screen.screen.resolution;\n\t\t\tconst scale = this.screen.screen.scale;\n\t\t\tresx = res.x / scale;\n\t\t\tresy = res.y / scale;\n\t\t}\n\n\t\tthis._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);\n\t}\n\n\tgetOffsetPosition(x, y) {\n\t\tconst p = this.entity.getLocalPosition().clone();\n\t\tp.x += x;\n\t\tp.y += y;\n\n\t\tthis._screenToWorld.transformPoint(p, p);\n\n\t\treturn p;\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\n\t\tif (this._image) {\n\t\t\tlayer.addMeshInstances(this._image._renderable.model.meshInstances);\n\t\t} else if (this._text) {\n\t\t\tlayer.addMeshInstances(this._text._model.meshInstances);\n\t\t}\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\n\t\tif (this._image) {\n\t\t\tlayer.removeMeshInstances(this._image._renderable.model.meshInstances);\n\t\t} else if (this._text) {\n\t\t\tlayer.removeMeshInstances(this._text._model.meshInstances);\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tif (this._image) this._image.onEnable();\n\t\tif (this._text) this._text.onEnable();\n\t\tif (this._group) this._group.onEnable();\n\n\t\tif (this.useInput && this.system.app.elementInput) {\n\t\t\tthis.system.app.elementInput.addElement(this);\n\t\t}\n\n\t\tthis.system.app.scene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tthis.system.app.batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tthis.fire(\"enableelement\");\n\t}\n\n\tonDisable() {\n\t\tthis.system.app.scene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this._image) this._image.onDisable();\n\t\tif (this._text) this._text.onDisable();\n\t\tif (this._group) this._group.onDisable();\n\n\t\tif (this.system.app.elementInput && this.useInput) {\n\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tthis.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tthis.fire(\"disableelement\");\n\t}\n\n\tonRemove() {\n\t\tthis.entity.off('insert', this._onInsert, this);\n\n\t\tthis._unpatch();\n\n\t\tif (this._image) this._image.destroy();\n\t\tif (this._text) this._text.destroy();\n\n\t\tif (this.system.app.elementInput && this.useInput) {\n\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t}\n\n\t\tif (this.screen && this.screen.screen) {\n\t\t\tthis._unbindScreen(this.screen.screen);\n\n\t\t\tthis.screen.screen.syncDrawOrder();\n\t\t}\n\n\t\tthis.off();\n\t}\n\n\t_calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {\n\t\tif (!this.entity._parent && !this.screen) return;\n\n\t\tthis._calculateLocalAnchors();\n\n\t\tconst newWidth = this._absRight - this._absLeft;\n\t\tconst newHeight = this._absTop - this._absBottom;\n\n\t\tif (propagateCalculatedWidth) {\n\t\t\tthis._setWidth(newWidth);\n\t\t} else {\n\t\t\tthis._setCalculatedWidth(newWidth, false);\n\t\t}\n\n\t\tif (propagateCalculatedHeight) {\n\t\t\tthis._setHeight(newHeight);\n\t\t} else {\n\t\t\tthis._setCalculatedHeight(newHeight, false);\n\t\t}\n\n\t\tconst p = this.entity.getLocalPosition();\n\t\tp.x = this._margin.x + this._calculatedWidth * this._pivot.x;\n\t\tp.y = this._margin.y + this._calculatedHeight * this._pivot.y;\n\t\tthis.entity.setLocalPosition(p);\n\t\tthis._sizeDirty = false;\n\t}\n\n\t_setWidth(w) {\n\t\tthis._width = w;\n\n\t\tthis._setCalculatedWidth(w, false);\n\n\t\tthis.fire('set:width', this._width);\n\t}\n\n\t_setHeight(h) {\n\t\tthis._height = h;\n\n\t\tthis._setCalculatedHeight(h, false);\n\n\t\tthis.fire('set:height', this._height);\n\t}\n\n\t_setCalculatedWidth(value, updateMargins) {\n\t\tif (Math.abs(value - this._calculatedWidth) <= 1e-4) return;\n\t\tthis._calculatedWidth = value;\n\n\t\tthis.entity._dirtifyLocal();\n\n\t\tif (updateMargins) {\n\t\t\tconst p = this.entity.getLocalPosition();\n\t\t\tconst pvt = this._pivot;\n\t\t\tthis._margin.x = p.x - this._calculatedWidth * pvt.x;\n\t\t\tthis._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;\n\t\t}\n\n\t\tthis._flagChildrenAsDirty();\n\n\t\tthis.fire('set:calculatedWidth', this._calculatedWidth);\n\t\tthis.fire('resize', this._calculatedWidth, this._calculatedHeight);\n\t}\n\n\t_setCalculatedHeight(value, updateMargins) {\n\t\tif (Math.abs(value - this._calculatedHeight) <= 1e-4) return;\n\t\tthis._calculatedHeight = value;\n\n\t\tthis.entity._dirtifyLocal();\n\n\t\tif (updateMargins) {\n\t\t\tconst p = this.entity.getLocalPosition();\n\t\t\tconst pvt = this._pivot;\n\t\t\tthis._margin.y = p.y - this._calculatedHeight * pvt.y;\n\t\t\tthis._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;\n\t\t}\n\n\t\tthis._flagChildrenAsDirty();\n\n\t\tthis.fire('set:calculatedHeight', this._calculatedHeight);\n\t\tthis.fire('resize', this._calculatedWidth, this._calculatedHeight);\n\t}\n\n\t_flagChildrenAsDirty() {\n\t\tconst c = this.entity._children;\n\n\t\tfor (let i = 0, l = c.length; i < l; i++) {\n\t\t\tif (c[i].element) {\n\t\t\t\tc[i].element._anchorDirty = true;\n\t\t\t\tc[i].element._sizeDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\taddModelToLayers(model) {\n\t\tthis._addedModels.push(model);\n\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances(model.meshInstances);\n\t\t}\n\t}\n\n\tremoveModelFromLayers(model) {\n\t\tconst idx = this._addedModels.indexOf(model);\n\n\t\tif (idx >= 0) {\n\t\t\tthis._addedModels.splice(idx, 1);\n\t\t}\n\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances(model.meshInstances);\n\t\t}\n\t}\n\n\tgetMaskOffset() {\n\t\tconst frame = this.system.app.frame;\n\n\t\tif (this._offsetReadAt !== frame) {\n\t\t\tthis._maskOffset = 0.5;\n\t\t\tthis._offsetReadAt = frame;\n\t\t}\n\n\t\tconst mo = this._maskOffset;\n\t\tthis._maskOffset -= 0.001;\n\t\treturn mo;\n\t}\n\n\tisVisibleForCamera(camera) {\n\t\tlet clipL, clipR, clipT, clipB;\n\n\t\tif (this.maskedBy) {\n\t\t\tconst corners = this.maskedBy.element.screenCorners;\n\t\t\tclipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));\n\t\t\tclipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));\n\t\t\tclipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));\n\t\t\tclipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));\n\t\t} else {\n\t\t\tconst sw = this.system.app.graphicsDevice.width;\n\t\t\tconst sh = this.system.app.graphicsDevice.height;\n\t\t\tconst cameraWidth = camera._rect.z * sw;\n\t\t\tconst cameraHeight = camera._rect.w * sh;\n\t\t\tclipL = camera._rect.x * sw;\n\t\t\tclipR = clipL + cameraWidth;\n\t\t\tclipT = (1 - camera._rect.y) * sh;\n\t\t\tclipB = clipT - cameraHeight;\n\t\t}\n\n\t\tconst hitCorners = this.screenCorners;\n\t\tconst left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));\n\t\tconst right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));\n\t\tconst bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));\n\t\tconst top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));\n\n\t\tif (right < clipL || left > clipR || bottom > clipT || top < clipB) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t_isScreenSpace() {\n\t\tif (this.screen && this.screen.screen) {\n\t\t\treturn this.screen.screen.screenSpace;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_isScreenCulled() {\n\t\tif (this.screen && this.screen.screen) {\n\t\t\treturn this.screen.screen.cull;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nfunction _define(name) {\n\tObject.defineProperty(ElementComponent.prototype, name, {\n\t\tget: function () {\n\t\t\tif (this._text) {\n\t\t\t\treturn this._text[name];\n\t\t\t} else if (this._image) {\n\t\t\t\treturn this._image[name];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t\tset: function (value) {\n\t\t\tif (this._text) {\n\t\t\t\tthis._text[name] = value;\n\t\t\t} else if (this._image) {\n\t\t\t\tthis._image[name] = value;\n\t\t\t}\n\t\t}\n\t});\n}\n\n_define(\"fontSize\");\n\n_define(\"minFontSize\");\n\n_define(\"maxFontSize\");\n\n_define(\"maxLines\");\n\n_define(\"autoFitWidth\");\n\n_define(\"autoFitHeight\");\n\n_define(\"color\");\n\n_define(\"font\");\n\n_define(\"fontAsset\");\n\n_define(\"spacing\");\n\n_define(\"lineHeight\");\n\n_define(\"wrapLines\");\n\n_define(\"lines\");\n\n_define(\"alignment\");\n\n_define(\"autoWidth\");\n\n_define(\"autoHeight\");\n\n_define(\"rtlReorder\");\n\n_define(\"unicodeConverter\");\n\n_define(\"text\");\n\n_define(\"key\");\n\n_define(\"texture\");\n\n_define(\"textureAsset\");\n\n_define(\"material\");\n\n_define(\"materialAsset\");\n\n_define(\"sprite\");\n\n_define(\"spriteAsset\");\n\n_define(\"spriteFrame\");\n\n_define(\"pixelsPerUnit\");\n\n_define(\"opacity\");\n\n_define(\"rect\");\n\n_define(\"mask\");\n\n_define(\"outlineColor\");\n\n_define(\"outlineThickness\");\n\n_define(\"shadowColor\");\n\n_define(\"shadowOffset\");\n\n_define(\"enableMarkup\");\n\n_define(\"rangeStart\");\n\n_define(\"rangeEnd\");\n\nclass ElementComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$e = ['enabled'];\n\nclass ElementComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'element';\n\t\tthis.ComponentType = ElementComponent;\n\t\tthis.DataType = ElementComponentData;\n\t\tthis.schema = _schema$e;\n\t\tthis._unicodeConverter = null;\n\t\tthis._rtlReorder = null;\n\t\tthis._defaultTexture = new Texture(app.graphicsDevice, {\n\t\t\twidth: 1,\n\t\t\theight: 1,\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8\n\t\t});\n\t\tthis._defaultTexture.name = 'element-system';\n\n\t\tconst pixels = this._defaultTexture.lock();\n\n\t\tconst pixelData = new Uint8Array(4);\n\t\tpixelData[0] = 255.0;\n\t\tpixelData[1] = 255.0;\n\t\tpixelData[2] = 255.0;\n\t\tpixelData[3] = 255.0;\n\t\tpixels.set(pixelData);\n\n\t\tthis._defaultTexture.unlock();\n\n\t\tthis.defaultImageMaterial = null;\n\t\tthis.defaultImage9SlicedMaterial = null;\n\t\tthis.defaultImage9TiledMaterial = null;\n\t\tthis.defaultImageMaskMaterial = null;\n\t\tthis.defaultImage9SlicedMaskMaterial = null;\n\t\tthis.defaultImage9TiledMaskMaterial = null;\n\t\tthis.defaultScreenSpaceImageMaterial = null;\n\t\tthis.defaultScreenSpaceImage9SlicedMaterial = null;\n\t\tthis.defaultScreenSpaceImage9TiledMaterial = null;\n\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial = null;\n\t\tthis.defaultScreenSpaceImageMask9TiledMaterial = null;\n\t\tthis.defaultScreenSpaceImageMaskMaterial = null;\n\t\tthis.defaultTextMaterial = null;\n\t\tthis.defaultBitmapTextMaterial = null;\n\t\tthis.defaultScreenSpaceTextMaterial = null;\n\t\tthis.defaultScreenSpaceBitmapTextMaterial = null;\n\t\tthis.defaultImageMaterials = [];\n\t\tthis.on('beforeremove', this.onRemoveComponent, this);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._defaultTexture.destroy();\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent._beingInitialized = true;\n\n\t\tif (data.anchor !== undefined) {\n\t\t\tif (data.anchor instanceof Vec4) {\n\t\t\t\tcomponent.anchor.copy(data.anchor);\n\t\t\t} else {\n\t\t\t\tcomponent.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);\n\t\t\t}\n\t\t}\n\n\t\tif (data.pivot !== undefined) {\n\t\t\tif (data.pivot instanceof Vec2) {\n\t\t\t\tcomponent.pivot.copy(data.pivot);\n\t\t\t} else {\n\t\t\t\tcomponent.pivot.set(data.pivot[0], data.pivot[1]);\n\t\t\t}\n\t\t}\n\n\t\tconst splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;\n\t\tconst splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;\n\t\tlet _marginChange = false;\n\t\tlet color;\n\n\t\tif (data.margin !== undefined) {\n\t\t\tif (data.margin instanceof Vec4) {\n\t\t\t\tcomponent.margin.copy(data.margin);\n\t\t\t} else {\n\t\t\t\tcomponent._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);\n\t\t\t}\n\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (data.left !== undefined) {\n\t\t\tcomponent._margin.x = data.left;\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (data.bottom !== undefined) {\n\t\t\tcomponent._margin.y = data.bottom;\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (data.right !== undefined) {\n\t\t\tcomponent._margin.z = data.right;\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (data.top !== undefined) {\n\t\t\tcomponent._margin.w = data.top;\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (_marginChange) {\n\t\t\tcomponent.margin = component._margin;\n\t\t}\n\n\t\tlet shouldForceSetAnchor = false;\n\n\t\tif (data.width !== undefined && !splitHorAnchors) {\n\t\t\tcomponent.width = data.width;\n\t\t} else if (splitHorAnchors) {\n\t\t\tshouldForceSetAnchor = true;\n\t\t}\n\n\t\tif (data.height !== undefined && !splitVerAnchors) {\n\t\t\tcomponent.height = data.height;\n\t\t} else if (splitVerAnchors) {\n\t\t\tshouldForceSetAnchor = true;\n\t\t}\n\n\t\tif (shouldForceSetAnchor) {\n\t\t\tcomponent.anchor = component.anchor;\n\t\t}\n\n\t\tif (data.enabled !== undefined) {\n\t\t\tcomponent.enabled = data.enabled;\n\t\t}\n\n\t\tif (data.useInput !== undefined) {\n\t\t\tcomponent.useInput = data.useInput;\n\t\t}\n\n\t\tcomponent.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;\n\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tcomponent.layers = data.layers.slice(0);\n\t\t}\n\n\t\tif (data.type !== undefined) {\n\t\t\tcomponent.type = data.type;\n\t\t}\n\n\t\tif (component.type === ELEMENTTYPE_IMAGE) {\n\t\t\tif (data.rect !== undefined) {\n\t\t\t\tcomponent.rect = data.rect;\n\t\t\t}\n\n\t\t\tif (data.color !== undefined) {\n\t\t\t\tcolor = data.color;\n\n\t\t\t\tif (!(color instanceof Color)) {\n\t\t\t\t\tcolor = new Color(data.color[0], data.color[1], data.color[2]);\n\t\t\t\t}\n\n\t\t\t\tcomponent.color = color;\n\t\t\t}\n\n\t\t\tif (data.opacity !== undefined) component.opacity = data.opacity;\n\t\t\tif (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;\n\t\t\tif (data.texture) component.texture = data.texture;\n\t\t\tif (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;\n\t\t\tif (data.sprite) component.sprite = data.sprite;\n\t\t\tif (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;\n\t\t\tif (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;\n\t\t\tif (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;\n\t\t\tif (data.material) component.material = data.material;\n\n\t\t\tif (data.mask !== undefined) {\n\t\t\t\tcomponent.mask = data.mask;\n\t\t\t}\n\t\t} else if (component.type === ELEMENTTYPE_TEXT) {\n\t\t\tif (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;\n\t\t\tif (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;\n\t\t\tif (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;\n\t\t\tif (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;\n\n\t\t\tif (data.text !== null && data.text !== undefined) {\n\t\t\t\tcomponent.text = data.text;\n\t\t\t} else if (data.key !== null && data.key !== undefined) {\n\t\t\t\tcomponent.key = data.key;\n\t\t\t}\n\n\t\t\tif (data.color !== undefined) {\n\t\t\t\tcolor = data.color;\n\n\t\t\t\tif (!(color instanceof Color)) {\n\t\t\t\t\tcolor = new Color(color[0], color[1], color[2]);\n\t\t\t\t}\n\n\t\t\t\tcomponent.color = color;\n\t\t\t}\n\n\t\t\tif (data.opacity !== undefined) {\n\t\t\t\tcomponent.opacity = data.opacity;\n\t\t\t}\n\n\t\t\tif (data.spacing !== undefined) component.spacing = data.spacing;\n\n\t\t\tif (data.fontSize !== undefined) {\n\t\t\t\tcomponent.fontSize = data.fontSize;\n\t\t\t\tif (!data.lineHeight) component.lineHeight = data.fontSize;\n\t\t\t}\n\n\t\t\tif (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;\n\t\t\tif (data.maxLines !== undefined) component.maxLines = data.maxLines;\n\t\t\tif (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;\n\t\t\tif (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;\n\t\t\tif (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;\n\t\t\tif (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;\n\t\t\tif (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;\n\t\t\tif (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;\n\t\t\tif (data.font !== undefined) component.font = data.font;\n\t\t\tif (data.alignment !== undefined) component.alignment = data.alignment;\n\t\t\tif (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;\n\t\t\tif (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;\n\t\t\tif (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;\n\t\t\tif (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;\n\t\t\tif (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;\n\t\t}\n\n\t\tconst result = component._parseUpToScreen();\n\n\t\tif (result.screen) {\n\t\t\tcomponent._updateScreen(result.screen);\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\tcomponent._beingInitialized = false;\n\n\t\tif (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {\n\t\t\tcomponent._image._updateMesh(component._image.mesh);\n\t\t}\n\t}\n\n\tonRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.element;\n\t\tconst data = {\n\t\t\tenabled: source.enabled,\n\t\t\twidth: source.width,\n\t\t\theight: source.height,\n\t\t\tanchor: source.anchor.clone(),\n\t\t\tpivot: source.pivot.clone(),\n\t\t\tmargin: source.margin.clone(),\n\t\t\talignment: source.alignment && source.alignment.clone() || source.alignment,\n\t\t\tautoWidth: source.autoWidth,\n\t\t\tautoHeight: source.autoHeight,\n\t\t\ttype: source.type,\n\t\t\trect: source.rect && source.rect.clone() || source.rect,\n\t\t\trtlReorder: source.rtlReorder,\n\t\t\tunicodeConverter: source.unicodeConverter,\n\t\t\tmaterialAsset: source.materialAsset,\n\t\t\tmaterial: source.material,\n\t\t\tcolor: source.color && source.color.clone() || source.color,\n\t\t\topacity: source.opacity,\n\t\t\ttextureAsset: source.textureAsset,\n\t\t\ttexture: source.texture,\n\t\t\tspriteAsset: source.spriteAsset,\n\t\t\tsprite: source.sprite,\n\t\t\tspriteFrame: source.spriteFrame,\n\t\t\tpixelsPerUnit: source.pixelsPerUnit,\n\t\t\tspacing: source.spacing,\n\t\t\tlineHeight: source.lineHeight,\n\t\t\twrapLines: source.wrapLines,\n\t\t\tlayers: source.layers,\n\t\t\tfontSize: source.fontSize,\n\t\t\tminFontSize: source.minFontSize,\n\t\t\tmaxFontSize: source.maxFontSize,\n\t\t\tautoFitWidth: source.autoFitWidth,\n\t\t\tautoFitHeight: source.autoFitHeight,\n\t\t\tmaxLines: source.maxLines,\n\t\t\tfontAsset: source.fontAsset,\n\t\t\tfont: source.font,\n\t\t\tuseInput: source.useInput,\n\t\t\tbatchGroupId: source.batchGroupId,\n\t\t\tmask: source.mask,\n\t\t\toutlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,\n\t\t\toutlineThickness: source.outlineThickness,\n\t\t\tshadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,\n\t\t\tshadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,\n\t\t\tenableMarkup: source.enableMarkup\n\t\t};\n\n\t\tif (source.key !== undefined && source.key !== null) {\n\t\t\tdata.key = source.key;\n\t\t} else {\n\t\t\tdata.text = source.text;\n\t\t}\n\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\tgetTextElementMaterial(screenSpace, msdf) {\n\t\tif (screenSpace) {\n\t\t\tif (msdf) {\n\t\t\t\tif (!this.defaultScreenSpaceTextMaterial) {\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial = new StandardMaterial();\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.name = \"defaultScreenSpaceTextMaterial\";\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.useLighting = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.useGammaTonemap = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.useFog = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.useSkybox = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0);\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1);\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.opacity = 0.5;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.depthWrite = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.depthTest = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.emissiveVertexColor = true;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.update();\n\t\t\t\t}\n\n\t\t\t\treturn this.defaultScreenSpaceTextMaterial;\n\t\t\t}\n\n\t\t\tif (!this.defaultScreenSpaceBitmapTextMaterial) {\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial = new StandardMaterial();\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.name = \"defaultScreenSpaceBitmapTextMaterial\";\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.emissiveTint = true;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.opacity = 0.5;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.opacityMap = this._defaultTexture;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = 'a';\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.useLighting = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.useFog = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.useSkybox = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0);\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.depthWrite = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.depthTest = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = true;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.update();\n\t\t\t}\n\n\t\t\treturn this.defaultScreenSpaceBitmapTextMaterial;\n\t\t}\n\n\t\tif (msdf) {\n\t\t\tif (!this.defaultTextMaterial) {\n\t\t\t\tthis.defaultTextMaterial = new StandardMaterial();\n\t\t\t\tthis.defaultTextMaterial.name = \"defaultTextMaterial\";\n\t\t\t\tthis.defaultTextMaterial.msdfMap = this._defaultTexture;\n\t\t\t\tthis.defaultTextMaterial.useLighting = false;\n\t\t\t\tthis.defaultTextMaterial.useGammaTonemap = false;\n\t\t\t\tthis.defaultTextMaterial.useFog = false;\n\t\t\t\tthis.defaultTextMaterial.useSkybox = false;\n\t\t\t\tthis.defaultTextMaterial.diffuse.set(0, 0, 0);\n\t\t\t\tthis.defaultTextMaterial.emissive.set(1, 1, 1);\n\t\t\t\tthis.defaultTextMaterial.opacity = 0.5;\n\t\t\t\tthis.defaultTextMaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\t\tthis.defaultTextMaterial.depthWrite = false;\n\t\t\t\tthis.defaultTextMaterial.emissiveVertexColor = true;\n\t\t\t\tthis.defaultTextMaterial.update();\n\t\t\t}\n\n\t\t\treturn this.defaultTextMaterial;\n\t\t}\n\n\t\tif (!this.defaultBitmapTextMaterial) {\n\t\t\tthis.defaultBitmapTextMaterial = new StandardMaterial();\n\t\t\tthis.defaultBitmapTextMaterial.name = \"defaultBitmapTextMaterial\";\n\t\t\tthis.defaultBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);\n\t\t\tthis.defaultBitmapTextMaterial.emissiveTint = true;\n\t\t\tthis.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture;\n\t\t\tthis.defaultBitmapTextMaterial.opacity = 0.5;\n\t\t\tthis.defaultBitmapTextMaterial.opacityMap = this._defaultTexture;\n\t\t\tthis.defaultBitmapTextMaterial.opacityMapChannel = 'a';\n\t\t\tthis.defaultBitmapTextMaterial.useLighting = false;\n\t\t\tthis.defaultBitmapTextMaterial.useGammaTonemap = false;\n\t\t\tthis.defaultBitmapTextMaterial.useFog = false;\n\t\t\tthis.defaultBitmapTextMaterial.useSkybox = false;\n\t\t\tthis.defaultBitmapTextMaterial.diffuse.set(0, 0, 0);\n\t\t\tthis.defaultBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\tthis.defaultBitmapTextMaterial.depthWrite = false;\n\t\t\tthis.defaultBitmapTextMaterial.emissiveVertexColor = true;\n\t\t\tthis.defaultBitmapTextMaterial.update();\n\t\t}\n\n\t\treturn this.defaultBitmapTextMaterial;\n\t}\n\n\t_createBaseImageMaterial() {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.diffuse.set(0, 0, 0);\n\t\tmaterial.emissive.set(0.5, 0.5, 0.5);\n\t\tmaterial.emissiveMap = this._defaultTexture;\n\t\tmaterial.emissiveTint = true;\n\t\tmaterial.opacityMap = this._defaultTexture;\n\t\tmaterial.opacityMapChannel = \"a\";\n\t\tmaterial.opacityTint = true;\n\t\tmaterial.opacity = 0;\n\t\tmaterial.useLighting = false;\n\t\tmaterial.useGammaTonemap = false;\n\t\tmaterial.useFog = false;\n\t\tmaterial.useSkybox = false;\n\t\tmaterial.blendType = BLEND_PREMULTIPLIED;\n\t\tmaterial.depthWrite = false;\n\t\treturn material;\n\t}\n\n\tgetImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {\n\t\tif (screenSpace) {\n\t\t\tif (mask) {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMask9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.name = \"defaultScreenSpaceImageMask9SlicedMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImageMask9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMask9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.name = \"defaultScreenSpaceImageMask9TiledMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImageMask9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMaskMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.name = \"defaultScreenSpaceImageMaskMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImageMaskMaterial;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImage9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.name = \"defaultScreenSpaceImage9SlicedMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImage9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImage9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.name = \"defaultScreenSpaceImage9TiledMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImage9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.name = \"defaultScreenSpaceImageMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImageMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (mask) {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultImage9SlicedMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.name = \"defaultImage9SlicedMaskMaterial\";\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImage9SlicedMaskMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultImage9TiledMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.name = \"defaultImage9TiledMaskMaterial\";\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImage9TiledMaskMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultImageMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImageMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.name = \"defaultImageMaskMaterial\";\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImageMaskMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImageMaskMaterial;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultImage9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.name = \"defaultImage9SlicedMaterial\";\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImage9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultImage9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.name = \"defaultImage9TiledMaterial\";\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9TiledMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImage9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultImageMaterial) {\n\t\t\t\t\t\tthis.defaultImageMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImageMaterial.name = \"defaultImageMaterial\";\n\t\t\t\t\t\tthis.defaultImageMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImageMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImageMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterUnicodeConverter(func) {\n\t\tthis._unicodeConverter = func;\n\t}\n\n\tregisterRtlReorder(func) {\n\t\tthis._rtlReorder = func;\n\t}\n\n\tgetUnicodeConverter() {\n\t\treturn this._unicodeConverter;\n\t}\n\n\tgetRtlReorder() {\n\t\treturn this._rtlReorder;\n\t}\n\n}\n\nComponent._buildAccessors(ElementComponent.prototype, _schema$e);\n\nconst MOTION_FREE = 'free';\nconst MOTION_LIMITED = 'limited';\nconst MOTION_LOCKED = 'locked';\n\nconst properties = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];\n\nclass JointComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._constraint = null;\n\t\tthis._entityA = null;\n\t\tthis._entityB = null;\n\t\tthis._breakForce = 3.4e+38;\n\t\tthis._enableCollision = true;\n\t\tthis._linearMotionX = MOTION_LOCKED;\n\t\tthis._linearLimitsX = new Vec2(0, 0);\n\t\tthis._linearSpringX = false;\n\t\tthis._linearStiffnessX = 0;\n\t\tthis._linearDampingX = 1;\n\t\tthis._linearEquilibriumX = 0;\n\t\tthis._linearMotionY = MOTION_LOCKED;\n\t\tthis._linearLimitsY = new Vec2(0, 0);\n\t\tthis._linearSpringY = false;\n\t\tthis._linearStiffnessY = 0;\n\t\tthis._linearDampingY = 1;\n\t\tthis._linearEquilibriumY = 0;\n\t\tthis._linearMotionZ = MOTION_LOCKED;\n\t\tthis._linearLimitsZ = new Vec2(0, 0);\n\t\tthis._linearSpringZ = false;\n\t\tthis._linearStiffnessZ = 0;\n\t\tthis._linearDampingZ = 1;\n\t\tthis._linearEquilibriumZ = 0;\n\t\tthis._angularMotionX = MOTION_LOCKED;\n\t\tthis._angularLimitsX = new Vec2(0, 0);\n\t\tthis._angularSpringX = false;\n\t\tthis._angularStiffnessX = 0;\n\t\tthis._angularDampingX = 1;\n\t\tthis._angularEquilibriumX = 0;\n\t\tthis._angularMotionY = MOTION_LOCKED;\n\t\tthis._angularLimitsY = new Vec2(0, 0);\n\t\tthis._angularSpringY = false;\n\t\tthis._angularStiffnessY = 0;\n\t\tthis._angularDampingY = 1;\n\t\tthis._angularEquilibriumY = 0;\n\t\tthis._angularMotionZ = MOTION_LOCKED;\n\t\tthis._angularLimitsZ = new Vec2(0, 0);\n\t\tthis._angularSpringZ = false;\n\t\tthis._angularEquilibriumZ = 0;\n\t\tthis._angularDampingZ = 1;\n\t\tthis._angularStiffnessZ = 0;\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\n\tset entityA(body) {\n\t\tthis._destroyConstraint();\n\n\t\tthis._entityA = body;\n\n\t\tthis._createConstraint();\n\t}\n\n\tget entityA() {\n\t\treturn this._entityA;\n\t}\n\n\tset entityB(body) {\n\t\tthis._destroyConstraint();\n\n\t\tthis._entityB = body;\n\n\t\tthis._createConstraint();\n\t}\n\n\tget entityB() {\n\t\treturn this._entityB;\n\t}\n\n\tset breakForce(force) {\n\t\tif (this._constraint && this._breakForce !== force) {\n\t\t\tthis._constraint.setBreakingImpulseThreshold(force);\n\n\t\t\tthis._breakForce = force;\n\t\t}\n\t}\n\n\tget breakForce() {\n\t\treturn this._breakForce;\n\t}\n\n\tset enableCollision(enableCollision) {\n\t\tthis._destroyConstraint();\n\n\t\tthis._enableCollision = enableCollision;\n\n\t\tthis._createConstraint();\n\t}\n\n\tget enableCollision() {\n\t\treturn this._enableCollision;\n\t}\n\n\tset angularLimitsX(limits) {\n\t\tif (!this._angularLimitsX.equals(limits)) {\n\t\t\tthis._angularLimitsX.copy(limits);\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularLimitsX() {\n\t\treturn this._angularLimitsX;\n\t}\n\n\tset angularMotionX(value) {\n\t\tif (this._angularMotionX !== value) {\n\t\t\tthis._angularMotionX = value;\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularMotionX() {\n\t\treturn this._angularMotionX;\n\t}\n\n\tset angularLimitsY(limits) {\n\t\tif (!this._angularLimitsY.equals(limits)) {\n\t\t\tthis._angularLimitsY.copy(limits);\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularLimitsY() {\n\t\treturn this._angularLimitsY;\n\t}\n\n\tset angularMotionY(value) {\n\t\tif (this._angularMotionY !== value) {\n\t\t\tthis._angularMotionY = value;\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularMotionY() {\n\t\treturn this._angularMotionY;\n\t}\n\n\tset angularLimitsZ(limits) {\n\t\tif (!this._angularLimitsZ.equals(limits)) {\n\t\t\tthis._angularLimitsZ.copy(limits);\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularLimitsZ() {\n\t\treturn this._angularLimitsZ;\n\t}\n\n\tset angularMotionZ(value) {\n\t\tif (this._angularMotionZ !== value) {\n\t\t\tthis._angularMotionZ = value;\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularMotionZ() {\n\t\treturn this._angularMotionZ;\n\t}\n\n\tset linearLimitsX(limits) {\n\t\tif (!this._linearLimitsX.equals(limits)) {\n\t\t\tthis._linearLimitsX.copy(limits);\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearLimitsX() {\n\t\treturn this._linearLimitsX;\n\t}\n\n\tset linearMotionX(value) {\n\t\tif (this._linearMotionX !== value) {\n\t\t\tthis._linearMotionX = value;\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearMotionX() {\n\t\treturn this._linearMotionX;\n\t}\n\n\tset linearLimitsY(limits) {\n\t\tif (!this._linearLimitsY.equals(limits)) {\n\t\t\tthis._linearLimitsY.copy(limits);\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearLimitsY() {\n\t\treturn this._linearLimitsY;\n\t}\n\n\tset linearMotionY(value) {\n\t\tif (this._linearMotionY !== value) {\n\t\t\tthis._linearMotionY = value;\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearMotionY() {\n\t\treturn this._linearMotionY;\n\t}\n\n\tset linearLimitsZ(limits) {\n\t\tif (!this._linearLimitsZ.equals(limits)) {\n\t\t\tthis._linearLimitsZ.copy(limits);\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearLimitsZ() {\n\t\treturn this._linearLimitsZ;\n\t}\n\n\tset linearMotionZ(value) {\n\t\tif (this._linearMotionZ !== value) {\n\t\t\tthis._linearMotionZ = value;\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearMotionZ() {\n\t\treturn this._linearMotionZ;\n\t}\n\n\t_convertTransform(pcTransform, ammoTransform) {\n\t\tconst pos = pcTransform.getTranslation();\n\t\tconst rot = new Quat();\n\t\trot.setFromMat4(pcTransform);\n\t\tconst ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);\n\t\tconst ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);\n\t\tammoTransform.setOrigin(ammoVec);\n\t\tammoTransform.setRotation(ammoQuat);\n\t\tAmmo.destroy(ammoVec);\n\t\tAmmo.destroy(ammoQuat);\n\t}\n\n\t_updateAngularLimits() {\n\t\tconst constraint = this._constraint;\n\n\t\tif (constraint) {\n\t\t\tlet lx, ly, lz, ux, uy, uz;\n\n\t\t\tif (this._angularMotionX === MOTION_LIMITED) {\n\t\t\t\tlx = this._angularLimitsX.x * math.DEG_TO_RAD;\n\t\t\t\tux = this._angularLimitsX.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionX === MOTION_FREE) {\n\t\t\t\tlx = 1;\n\t\t\t\tux = 0;\n\t\t\t} else {\n\t\t\t\tlx = ux = 0;\n\t\t\t}\n\n\t\t\tif (this._angularMotionY === MOTION_LIMITED) {\n\t\t\t\tly = this._angularLimitsY.x * math.DEG_TO_RAD;\n\t\t\t\tuy = this._angularLimitsY.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionY === MOTION_FREE) {\n\t\t\t\tly = 1;\n\t\t\t\tuy = 0;\n\t\t\t} else {\n\t\t\t\tly = uy = 0;\n\t\t\t}\n\n\t\t\tif (this._angularMotionZ === MOTION_LIMITED) {\n\t\t\t\tlz = this._angularLimitsZ.x * math.DEG_TO_RAD;\n\t\t\t\tuz = this._angularLimitsZ.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionZ === MOTION_FREE) {\n\t\t\t\tlz = 1;\n\t\t\t\tuz = 0;\n\t\t\t} else {\n\t\t\t\tlz = uz = 0;\n\t\t\t}\n\n\t\t\tconst limits = new Ammo.btVector3(lx, ly, lz);\n\t\t\tconstraint.setAngularLowerLimit(limits);\n\t\t\tlimits.setValue(ux, uy, uz);\n\t\t\tconstraint.setAngularUpperLimit(limits);\n\t\t\tAmmo.destroy(limits);\n\t\t}\n\t}\n\n\t_updateLinearLimits() {\n\t\tconst constraint = this._constraint;\n\n\t\tif (constraint) {\n\t\t\tlet lx, ly, lz, ux, uy, uz;\n\n\t\t\tif (this._linearMotionX === MOTION_LIMITED) {\n\t\t\t\tlx = this._linearLimitsX.x;\n\t\t\t\tux = this._linearLimitsX.y;\n\t\t\t} else if (this._linearMotionX === MOTION_FREE) {\n\t\t\t\tlx = 1;\n\t\t\t\tux = 0;\n\t\t\t} else {\n\t\t\t\tlx = ux = 0;\n\t\t\t}\n\n\t\t\tif (this._linearMotionY === MOTION_LIMITED) {\n\t\t\t\tly = this._linearLimitsY.x;\n\t\t\t\tuy = this._linearLimitsY.y;\n\t\t\t} else if (this._linearMotionY === MOTION_FREE) {\n\t\t\t\tly = 1;\n\t\t\t\tuy = 0;\n\t\t\t} else {\n\t\t\t\tly = uy = 0;\n\t\t\t}\n\n\t\t\tif (this._linearMotionZ === MOTION_LIMITED) {\n\t\t\t\tlz = this._linearLimitsZ.x;\n\t\t\t\tuz = this._linearLimitsZ.y;\n\t\t\t} else if (this._linearMotionZ === MOTION_FREE) {\n\t\t\t\tlz = 1;\n\t\t\t\tuz = 0;\n\t\t\t} else {\n\t\t\t\tlz = uz = 0;\n\t\t\t}\n\n\t\t\tconst limits = new Ammo.btVector3(lx, ly, lz);\n\t\t\tconstraint.setLinearLowerLimit(limits);\n\t\t\tlimits.setValue(ux, uy, uz);\n\t\t\tconstraint.setLinearUpperLimit(limits);\n\t\t\tAmmo.destroy(limits);\n\t\t}\n\t}\n\n\t_createConstraint() {\n\t\tif (this._entityA && this._entityA.rigidbody) {\n\t\t\tthis._destroyConstraint();\n\n\t\t\tconst mat = new Mat4();\n\t\t\tconst bodyA = this._entityA.rigidbody.body;\n\t\t\tbodyA.activate();\n\t\t\tconst jointWtm = this.entity.getWorldTransform();\n\n\t\t\tconst entityAWtm = this._entityA.getWorldTransform();\n\n\t\t\tconst invEntityAWtm = entityAWtm.clone().invert();\n\t\t\tmat.mul2(invEntityAWtm, jointWtm);\n\t\t\tconst frameA = new Ammo.btTransform();\n\n\t\t\tthis._convertTransform(mat, frameA);\n\n\t\t\tif (this._entityB && this._entityB.rigidbody) {\n\t\t\t\tconst bodyB = this._entityB.rigidbody.body;\n\t\t\t\tbodyB.activate();\n\n\t\t\t\tconst entityBWtm = this._entityB.getWorldTransform();\n\n\t\t\t\tconst invEntityBWtm = entityBWtm.clone().invert();\n\t\t\t\tmat.mul2(invEntityBWtm, jointWtm);\n\t\t\t\tconst frameB = new Ammo.btTransform();\n\n\t\t\t\tthis._convertTransform(mat, frameB);\n\n\t\t\t\tthis._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);\n\t\t\t\tAmmo.destroy(frameB);\n\t\t\t} else {\n\t\t\t\tthis._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);\n\t\t\t}\n\n\t\t\tAmmo.destroy(frameA);\n\t\t\tconst axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst type = i < 3 ? '_linear' : '_angular';\n\n\t\t\t\tthis._constraint.enableSpring(i, this[type + 'Spring' + axis[i]]);\n\n\t\t\t\tthis._constraint.setDamping(i, this[type + 'Damping' + axis[i]]);\n\n\t\t\t\tthis._constraint.setEquilibriumPoint(i, this[type + 'Equilibrium' + axis[i]]);\n\n\t\t\t\tthis._constraint.setStiffness(i, this[type + 'Stiffness' + axis[i]]);\n\t\t\t}\n\n\t\t\tthis._constraint.setBreakingImpulseThreshold(this._breakForce);\n\n\t\t\tthis._updateLinearLimits();\n\n\t\t\tthis._updateAngularLimits();\n\n\t\t\tconst app = this.system.app;\n\t\t\tconst dynamicsWorld = app.systems.rigidbody.dynamicsWorld;\n\t\t\tdynamicsWorld.addConstraint(this._constraint, !this._enableCollision);\n\t\t}\n\t}\n\n\t_destroyConstraint() {\n\t\tif (this._constraint) {\n\t\t\tconst app = this.system.app;\n\t\t\tconst dynamicsWorld = app.systems.rigidbody.dynamicsWorld;\n\t\t\tdynamicsWorld.removeConstraint(this._constraint);\n\t\t\tAmmo.destroy(this._constraint);\n\t\t\tthis._constraint = null;\n\t\t}\n\t}\n\n\tinitFromData(data) {\n\t\tfor (const prop of properties) {\n\t\t\tif (data.hasOwnProperty(prop)) {\n\t\t\t\tif (data[prop] instanceof Vec2) {\n\t\t\t\t\tthis['_' + prop].copy(data[prop]);\n\t\t\t\t} else {\n\t\t\t\t\tthis['_' + prop] = data[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._createConstraint();\n\t}\n\n\tonEnable() {\n\t\tthis._createConstraint();\n\t}\n\n\tonDisable() {\n\t\tthis._destroyConstraint();\n\t}\n\n\t_onSetEnabled(prop, old, value) {}\n\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\t}\n\n}\n\nconst functionMap = {\n\tDamping: 'setDamping',\n\tEquilibrium: 'setEquilibriumPoint',\n\tSpring: 'enableSpring',\n\tStiffness: 'setStiffness'\n};\n['linear', 'angular'].forEach(type => {\n\t['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(name => {\n\t\t['X', 'Y', 'Z'].forEach(axis => {\n\t\t\tconst prop = type + name + axis;\n\t\t\tconst propInternal = '_' + prop;\n\t\t\tlet index = type === 'linear' ? 0 : 3;\n\t\t\tif (axis === 'Y') index += 1;\n\t\t\tif (axis === 'Z') index += 2;\n\t\t\tObject.defineProperty(JointComponent.prototype, prop, {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this[propInternal];\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\tif (this[propInternal] !== value) {\n\t\t\t\t\t\tthis[propInternal] = value;\n\n\t\t\t\t\t\tthis._constraint[functionMap[name]](index, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n});\n\nclass JointComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$d = ['enabled'];\n\nclass JointComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'joint';\n\t\tthis.app = app;\n\t\tthis.ComponentType = JointComponent;\n\t\tthis.DataType = JointComponentData;\n\t\tthis.schema = _schema$d;\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent.initFromData(data);\n\t}\n\n}\n\nComponent._buildAccessors(JointComponent.prototype, _schema$d);\n\nclass LayoutChildComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._minWidth = 0;\n\t\tthis._minHeight = 0;\n\t\tthis._maxWidth = null;\n\t\tthis._maxHeight = null;\n\t\tthis._fitWidthProportion = 0;\n\t\tthis._fitHeightProportion = 0;\n\t\tthis._excludeFromLayout = false;\n\t}\n\n\tset minWidth(value) {\n\t\tif (value !== this._minWidth) {\n\t\t\tthis._minWidth = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget minWidth() {\n\t\treturn this._minWidth;\n\t}\n\n\tset minHeight(value) {\n\t\tif (value !== this._minHeight) {\n\t\t\tthis._minHeight = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget minHeight() {\n\t\treturn this._minHeight;\n\t}\n\n\tset maxWidth(value) {\n\t\tif (value !== this._maxWidth) {\n\t\t\tthis._maxWidth = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget maxWidth() {\n\t\treturn this._maxWidth;\n\t}\n\n\tset maxHeight(value) {\n\t\tif (value !== this._maxHeight) {\n\t\t\tthis._maxHeight = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget maxHeight() {\n\t\treturn this._maxHeight;\n\t}\n\n\tset fitWidthProportion(value) {\n\t\tif (value !== this._fitWidthProportion) {\n\t\t\tthis._fitWidthProportion = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget fitWidthProportion() {\n\t\treturn this._fitWidthProportion;\n\t}\n\n\tset fitHeightProportion(value) {\n\t\tif (value !== this._fitHeightProportion) {\n\t\t\tthis._fitHeightProportion = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget fitHeightProportion() {\n\t\treturn this._fitHeightProportion;\n\t}\n\n\tset excludeFromLayout(value) {\n\t\tif (value !== this._excludeFromLayout) {\n\t\t\tthis._excludeFromLayout = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget excludeFromLayout() {\n\t\treturn this._excludeFromLayout;\n\t}\n\n}\n\nclass LayoutChildComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$c = ['enabled'];\n\nclass LayoutChildComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'layoutchild';\n\t\tthis.ComponentType = LayoutChildComponent;\n\t\tthis.DataType = LayoutChildComponentData;\n\t\tthis.schema = _schema$c;\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) component.enabled = data.enabled;\n\t\tif (data.minWidth !== undefined) component.minWidth = data.minWidth;\n\t\tif (data.minHeight !== undefined) component.minHeight = data.minHeight;\n\t\tif (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;\n\t\tif (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;\n\t\tif (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;\n\t\tif (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;\n\t\tif (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst layoutChild = entity.layoutchild;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: layoutChild.enabled,\n\t\t\tminWidth: layoutChild.minWidth,\n\t\t\tminHeight: layoutChild.minHeight,\n\t\t\tmaxWidth: layoutChild.maxWidth,\n\t\t\tmaxHeight: layoutChild.maxHeight,\n\t\t\tfitWidthProportion: layoutChild.fitWidthProportion,\n\t\t\tfitHeightProportion: layoutChild.fitHeightProportion,\n\t\t\texcludeFromLayout: layoutChild.excludeFromLayout\n\t\t});\n\t}\n\n}\n\nComponent._buildAccessors(LayoutChildComponent.prototype, _schema$c);\n\nconst FITTING_NONE = 0;\nconst FITTING_STRETCH = 1;\nconst FITTING_SHRINK = 2;\nconst FITTING_BOTH = 3;\n\nconst AXIS_MAPPINGS = {};\nAXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {\n\taxis: 'x',\n\tsize: 'width',\n\tcalculatedSize: 'calculatedWidth',\n\tminSize: 'minWidth',\n\tmaxSize: 'maxWidth',\n\tfitting: 'widthFitting',\n\tfittingProportion: 'fitWidthProportion'\n};\nAXIS_MAPPINGS[ORIENTATION_VERTICAL] = {\n\taxis: 'y',\n\tsize: 'height',\n\tcalculatedSize: 'calculatedHeight',\n\tminSize: 'minHeight',\n\tmaxSize: 'maxHeight',\n\tfitting: 'heightFitting',\n\tfittingProportion: 'fitHeightProportion'\n};\nconst OPPOSITE_ORIENTATION = {};\nOPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;\nOPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;\nconst PROPERTY_DEFAULTS = {\n\tminWidth: 0,\n\tminHeight: 0,\n\tmaxWidth: Number.POSITIVE_INFINITY,\n\tmaxHeight: Number.POSITIVE_INFINITY,\n\twidth: null,\n\theight: null,\n\tfitWidthProportion: 0,\n\tfitHeightProportion: 0\n};\nconst FITTING_ACTION = {\n\tNONE: 'NONE',\n\tAPPLY_STRETCHING: 'APPLY_STRETCHING',\n\tAPPLY_SHRINKING: 'APPLY_SHRINKING'\n};\nconst availableSpace = new Vec2();\n\nfunction createCalculator(orientation) {\n\tlet options;\n\tconst a = AXIS_MAPPINGS[orientation];\n\tconst b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];\n\n\tfunction minExtentA(element, size) {\n\t\treturn -size[a.size] * element.pivot[a.axis];\n\t}\n\n\tfunction minExtentB(element, size) {\n\t\treturn -size[b.size] * element.pivot[b.axis];\n\t}\n\n\tfunction maxExtentA(element, size) {\n\t\treturn size[a.size] * (1 - element.pivot[a.axis]);\n\t}\n\n\tfunction calculateAll(allElements, layoutOptions) {\n\t\tallElements = allElements.filter(shouldIncludeInLayout);\n\t\toptions = layoutOptions;\n\t\tavailableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;\n\t\tavailableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;\n\t\tresetAnchors(allElements);\n\t\tconst lines = reverseLinesIfRequired(splitLines(allElements));\n\t\tconst sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));\n\t\tconst positions = calculateBasePositions(lines, sizes);\n\t\tapplyAlignmentAndPadding(lines, sizes, positions);\n\t\tapplySizesAndPositions(lines, sizes, positions);\n\t\treturn createLayoutInfo(lines);\n\t}\n\n\tfunction shouldIncludeInLayout(element) {\n\t\tconst layoutChildComponent = element.entity.layoutchild;\n\t\treturn !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;\n\t}\n\n\tfunction resetAnchors(allElements) {\n\t\tfor (let i = 0; i < allElements.length; ++i) {\n\t\t\tconst element = allElements[i];\n\t\t\tconst anchor = element.anchor;\n\n\t\t\tif (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {\n\t\t\t\telement.anchor = Vec4.ZERO;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction splitLines(allElements) {\n\t\tif (!options.wrap) {\n\t\t\treturn [allElements];\n\t\t}\n\n\t\tconst lines = [[]];\n\t\tconst sizes = getElementSizeProperties(allElements);\n\t\tlet runningSize = 0;\n\t\tconst allowOverrun = options[a.fitting] === FITTING_SHRINK;\n\n\t\tfor (let i = 0; i < allElements.length; ++i) {\n\t\t\tif (lines[lines.length - 1].length > 0) {\n\t\t\t\trunningSize += options.spacing[a.axis];\n\t\t\t}\n\n\t\t\tconst idealElementSize = sizes[i][a.size];\n\t\t\trunningSize += idealElementSize;\n\n\t\t\tif (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {\n\t\t\t\trunningSize = idealElementSize;\n\t\t\t\tlines.push([]);\n\t\t\t}\n\n\t\t\tlines[lines.length - 1].push(allElements[i]);\n\n\t\t\tif (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {\n\t\t\t\trunningSize = 0;\n\t\t\t\tlines.push([]);\n\t\t\t}\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\tfunction reverseLinesIfRequired(lines) {\n\t\tconst reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;\n\t\tconst reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;\n\n\t\tif (reverseAxisA) {\n\t\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\t\tif (reverseAxisA) {\n\t\t\t\t\tlines[lineIndex].reverse();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reverseAxisB) {\n\t\t\tlines.reverse();\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\tfunction calculateSizesOnAxisA(lines) {\n\t\tconst sizesAllLines = [];\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = getElementSizeProperties(line);\n\t\t\tconst idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);\n\t\t\tconst fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);\n\n\t\t\tif (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\t\tstretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);\n\t\t\t} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\t\tshrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);\n\t\t\t}\n\n\t\t\tsizesAllLines.push(sizesThisLine);\n\t\t}\n\n\t\treturn sizesAllLines;\n\t}\n\n\tfunction calculateSizesOnAxisB(lines, sizesAllLines) {\n\t\tconst largestElementsForEachLine = [];\n\t\tconst largestSizesForEachLine = [];\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tline.largestElement = null;\n\t\t\tline.largestSize = {\n\t\t\t\twidth: Number.NEGATIVE_INFINITY,\n\t\t\t\theight: Number.NEGATIVE_INFINITY\n\t\t\t};\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst sizesThisElement = sizesAllLines[lineIndex][elementIndex];\n\n\t\t\t\tif (sizesThisElement[b.size] > line.largestSize[b.size]) {\n\t\t\t\t\tline.largestElement = line[elementIndex];\n\t\t\t\t\tline.largestSize = sizesThisElement;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlargestElementsForEachLine.push(line.largestElement);\n\t\t\tlargestSizesForEachLine.push(line.largestSize);\n\t\t}\n\n\t\tconst idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);\n\t\tconst fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);\n\n\t\tif (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\tstretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);\n\t\t} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\tshrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);\n\t\t}\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst sizesForThisElement = sizesAllLines[lineIndex][elementIndex];\n\t\t\t\tconst currentSize = sizesForThisElement[b.size];\n\t\t\t\tconst availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];\n\t\t\t\tconst elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);\n\n\t\t\t\tif (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\t\t\tsizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);\n\t\t\t\t} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\t\t\tsizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sizesAllLines;\n\t}\n\n\tfunction determineFittingAction(fittingMode, currentSize, availableSize) {\n\t\tswitch (fittingMode) {\n\t\t\tcase FITTING_NONE:\n\t\t\t\treturn FITTING_ACTION.NONE;\n\n\t\t\tcase FITTING_STRETCH:\n\t\t\t\tif (currentSize < availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_STRETCHING;\n\t\t\t\t}\n\n\t\t\t\treturn FITTING_ACTION.NONE;\n\n\t\t\tcase FITTING_SHRINK:\n\t\t\t\tif (currentSize >= availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_SHRINKING;\n\t\t\t\t}\n\n\t\t\t\treturn FITTING_ACTION.NONE;\n\n\t\t\tcase FITTING_BOTH:\n\t\t\t\tif (currentSize < availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_STRETCHING;\n\t\t\t\t}\n\n\t\t\t\treturn FITTING_ACTION.APPLY_SHRINKING;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unrecognized fitting mode: ${fittingMode}`);\n\t\t}\n\t}\n\n\tfunction calculateTotalSpace(sizes, axis) {\n\t\tconst totalSizes = sumValues(sizes, axis.size);\n\t\tconst totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];\n\t\treturn totalSizes + totalSpacing;\n\t}\n\n\tfunction stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {\n\t\tconst ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);\n\t\tconst fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);\n\t\tconst fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);\n\t\tlet remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;\n\n\t\tfor (let i = 0; i < sizesThisLine.length; ++i) {\n\t\t\tconst index = ascendingMaxSizeOrder[i];\n\t\t\tconst targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);\n\t\t\tconst targetSize = sizesThisLine[index][axis.size] + targetIncrease;\n\t\t\tconst maxSize = sizesThisLine[index][axis.maxSize];\n\t\t\tconst actualSize = Math.min(targetSize, maxSize);\n\t\t\tsizesThisLine[index][axis.size] = actualSize;\n\t\t\tconst actualIncrease = Math.max(targetSize - actualSize, 0);\n\t\t\tconst appliedIncrease = targetIncrease - actualIncrease;\n\t\t\tremainingUndershoot -= appliedIncrease;\n\t\t}\n\t}\n\n\tfunction shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {\n\t\tconst descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);\n\t\tconst fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);\n\t\tconst inverseFittingProportions = invertNormalizedValues(fittingProportions);\n\t\tconst inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);\n\t\tlet remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];\n\n\t\tfor (let i = 0; i < sizesThisLine.length; ++i) {\n\t\t\tconst index = descendingMinSizeOrder[i];\n\t\t\tconst targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);\n\t\t\tconst targetSize = sizesThisLine[index][axis.size] - targetReduction;\n\t\t\tconst minSize = sizesThisLine[index][axis.minSize];\n\t\t\tconst actualSize = Math.max(targetSize, minSize);\n\t\t\tsizesThisLine[index][axis.size] = actualSize;\n\t\t\tconst actualReduction = Math.max(actualSize - targetSize, 0);\n\t\t\tconst appliedReduction = targetReduction - actualReduction;\n\t\t\tremainingOvershoot -= appliedReduction;\n\t\t}\n\t}\n\n\tfunction calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {\n\t\tconst proportion = fittingProportions[index];\n\t\tconst sumOfRemainingProportions = fittingProportionSums[index];\n\n\t\tif (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {\n\t\t\treturn remainingAdjustment;\n\t\t}\n\n\t\treturn remainingAdjustment * proportion / sumOfRemainingProportions;\n\t}\n\n\tfunction calculateBasePositions(lines, sizes) {\n\t\tconst cursor = {};\n\t\tcursor[a.axis] = 0;\n\t\tcursor[b.axis] = 0;\n\t\tlines[a.size] = Number.NEGATIVE_INFINITY;\n\t\tconst positionsAllLines = [];\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\n\t\t\tif (line.length === 0) {\n\t\t\t\tpositionsAllLines.push([]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst positionsThisLine = [];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst element = line[elementIndex];\n\t\t\t\tconst sizesThisElement = sizesThisLine[elementIndex];\n\t\t\t\tcursor[b.axis] -= minExtentB(element, sizesThisElement);\n\t\t\t\tcursor[a.axis] -= minExtentA(element, sizesThisElement);\n\t\t\t\tpositionsThisLine[elementIndex] = {};\n\t\t\t\tpositionsThisLine[elementIndex][a.axis] = cursor[a.axis];\n\t\t\t\tpositionsThisLine[elementIndex][b.axis] = cursor[b.axis];\n\t\t\t\tcursor[b.axis] += minExtentB(element, sizesThisElement);\n\t\t\t\tcursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];\n\t\t\t}\n\n\t\t\tline[a.size] = cursor[a.axis] - options.spacing[a.axis];\n\t\t\tline[b.size] = line.largestSize[b.size];\n\t\t\tlines[a.size] = Math.max(lines[a.size], line[a.size]);\n\t\t\tcursor[a.axis] = 0;\n\t\t\tcursor[b.axis] += line[b.size] + options.spacing[b.axis];\n\t\t\tpositionsAllLines.push(positionsThisLine);\n\t\t}\n\n\t\tlines[b.size] = cursor[b.axis] - options.spacing[b.axis];\n\t\treturn positionsAllLines;\n\t}\n\n\tfunction applyAlignmentAndPadding(lines, sizes, positions) {\n\t\tconst alignmentA = options.alignment[a.axis];\n\t\tconst alignmentB = options.alignment[b.axis];\n\t\tconst paddingA = options.padding[a.axis];\n\t\tconst paddingB = options.padding[b.axis];\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\t\t\tconst positionsThisLine = positions[lineIndex];\n\t\t\tconst axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;\n\t\t\tconst axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];\n\t\t\t\tpositionsThisLine[elementIndex][a.axis] += axisAOffset;\n\t\t\t\tpositionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction applySizesAndPositions(lines, sizes, positions) {\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\t\t\tconst positionsThisLine = positions[lineIndex];\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst element = line[elementIndex];\n\t\t\t\telement[a.calculatedSize] = sizesThisLine[elementIndex][a.size];\n\t\t\t\telement[b.calculatedSize] = sizesThisLine[elementIndex][b.size];\n\n\t\t\t\tif (options.orientation === ORIENTATION_HORIZONTAL) {\n\t\t\t\t\telement.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);\n\t\t\t\t} else {\n\t\t\t\t\telement.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction createLayoutInfo(lines) {\n\t\tconst layoutWidth = lines.width;\n\t\tconst layoutHeight = lines.height;\n\t\tconst xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;\n\t\tconst yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;\n\t\treturn {\n\t\t\tbounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)\n\t\t};\n\t}\n\n\tfunction getElementSizeProperties(elements) {\n\t\tconst sizeProperties = [];\n\n\t\tfor (let i = 0; i < elements.length; ++i) {\n\t\t\tconst element = elements[i];\n\t\t\tconst minWidth = Math.max(getProperty(element, 'minWidth'), 0);\n\t\t\tconst minHeight = Math.max(getProperty(element, 'minHeight'), 0);\n\t\t\tconst maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);\n\t\t\tconst maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);\n\t\t\tconst width = clamp(getProperty(element, 'width'), minWidth, maxWidth);\n\t\t\tconst height = clamp(getProperty(element, 'height'), minHeight, maxHeight);\n\t\t\tconst fitWidthProportion = getProperty(element, 'fitWidthProportion');\n\t\t\tconst fitHeightProportion = getProperty(element, 'fitHeightProportion');\n\t\t\tsizeProperties.push({\n\t\t\t\tminWidth: minWidth,\n\t\t\t\tminHeight: minHeight,\n\t\t\t\tmaxWidth: maxWidth,\n\t\t\t\tmaxHeight: maxHeight,\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tfitWidthProportion: fitWidthProportion,\n\t\t\t\tfitHeightProportion: fitHeightProportion\n\t\t\t});\n\t\t}\n\n\t\treturn sizeProperties;\n\t}\n\n\tfunction getProperty(element, propertyName) {\n\t\tconst layoutChildComponent = element.entity.layoutchild;\n\n\t\tif (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {\n\t\t\treturn layoutChildComponent[propertyName];\n\t\t} else if (element[propertyName] !== undefined) {\n\t\t\treturn element[propertyName];\n\t\t}\n\n\t\treturn PROPERTY_DEFAULTS[propertyName];\n\t}\n\n\tfunction clamp(value, min, max) {\n\t\treturn Math.min(Math.max(value, min), max);\n\t}\n\n\tfunction sumValues(items, propertyName) {\n\t\treturn items.reduce(function (accumulator, current) {\n\t\t\treturn accumulator + current[propertyName];\n\t\t}, 0);\n\t}\n\n\tfunction getNormalizedValues(items, propertyName) {\n\t\tconst sum = sumValues(items, propertyName);\n\t\tconst normalizedValues = [];\n\t\tconst numItems = items.length;\n\n\t\tif (sum === 0) {\n\t\t\tfor (let i = 0; i < numItems; ++i) {\n\t\t\t\tnormalizedValues.push(1 / numItems);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < numItems; ++i) {\n\t\t\t\tnormalizedValues.push(items[i][propertyName] / sum);\n\t\t\t}\n\t\t}\n\n\t\treturn normalizedValues;\n\t}\n\n\tfunction invertNormalizedValues(values) {\n\t\tif (values.length === 1) {\n\t\t\treturn [1];\n\t\t}\n\n\t\tconst invertedValues = [];\n\t\tconst numValues = values.length;\n\n\t\tfor (let i = 0; i < numValues; ++i) {\n\t\t\tinvertedValues.push((1 - values[i]) / (numValues - 1));\n\t\t}\n\n\t\treturn invertedValues;\n\t}\n\n\tfunction getTraversalOrder(items, orderBy, descending) {\n\t\titems.forEach(assignIndex);\n\t\treturn items.slice().sort(function (itemA, itemB) {\n\t\t\treturn descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];\n\t\t}).map(getIndex);\n\t}\n\n\tfunction assignIndex(item, index) {\n\t\titem.index = index;\n\t}\n\n\tfunction getIndex(item) {\n\t\treturn item.index;\n\t}\n\n\tfunction createSumArray(values, order) {\n\t\tconst sumArray = [];\n\t\tsumArray[order[values.length - 1]] = values[order[values.length - 1]];\n\n\t\tfor (let i = values.length - 2; i >= 0; --i) {\n\t\t\tsumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];\n\t\t}\n\n\t\treturn sumArray;\n\t}\n\n\treturn calculateAll;\n}\n\nconst CALCULATE_FNS = {};\nCALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);\nCALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);\n\nclass LayoutCalculator {\n\tcalculateLayout(elements, options) {\n\t\tconst calculateFn = CALCULATE_FNS[options.orientation];\n\n\t\tif (!calculateFn) {\n\t\t\tthrow new Error('Unrecognized orientation value: ' + options.orientation);\n\t\t} else {\n\t\t\treturn calculateFn(elements, options);\n\t\t}\n\t}\n\n}\n\nfunction getElement(entity) {\n\treturn entity.element;\n}\n\nfunction isEnabledAndHasEnabledElement(entity) {\n\treturn entity.enabled && entity.element && entity.element.enabled;\n}\n\nclass LayoutGroupComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._orientation = ORIENTATION_HORIZONTAL;\n\t\tthis._reverseX = false;\n\t\tthis._reverseY = true;\n\t\tthis._alignment = new Vec2(0, 1);\n\t\tthis._padding = new Vec4();\n\t\tthis._spacing = new Vec2();\n\t\tthis._widthFitting = FITTING_NONE;\n\t\tthis._heightFitting = FITTING_NONE;\n\t\tthis._wrap = false;\n\t\tthis._layoutCalculator = new LayoutCalculator();\n\n\t\tthis._listenForReflowEvents(this.entity, 'on');\n\n\t\tthis.entity.children.forEach(child => {\n\t\t\tthis._listenForReflowEvents(child, 'on');\n\t\t});\n\t\tthis.entity.on('childinsert', this._onChildInsert, this);\n\t\tthis.entity.on('childremove', this._onChildRemove, this);\n\t\tsystem.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);\n\t\tsystem.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t\tsystem.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);\n\t\tsystem.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t}\n\n\tset orientation(value) {\n\t\tif (value !== this._orientation) {\n\t\t\tthis._orientation = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget orientation() {\n\t\treturn this._orientation;\n\t}\n\n\tset reverseX(value) {\n\t\tif (value !== this._reverseX) {\n\t\t\tthis._reverseX = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget reverseX() {\n\t\treturn this._reverseX;\n\t}\n\n\tset reverseY(value) {\n\t\tif (value !== this._reverseY) {\n\t\t\tthis._reverseY = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget reverseY() {\n\t\treturn this._reverseY;\n\t}\n\n\tset alignment(value) {\n\t\tif (!value.equals(this._alignment)) {\n\t\t\tthis._alignment.copy(value);\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget alignment() {\n\t\treturn this._alignment;\n\t}\n\n\tset padding(value) {\n\t\tif (!value.equals(this._padding)) {\n\t\t\tthis._padding.copy(value);\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget padding() {\n\t\treturn this._padding;\n\t}\n\n\tset spacing(value) {\n\t\tif (!value.equals(this._spacing)) {\n\t\t\tthis._spacing.copy(value);\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget spacing() {\n\t\treturn this._spacing;\n\t}\n\n\tset widthFitting(value) {\n\t\tif (value !== this._widthFitting) {\n\t\t\tthis._widthFitting = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget widthFitting() {\n\t\treturn this._widthFitting;\n\t}\n\n\tset heightFitting(value) {\n\t\tif (value !== this._heightFitting) {\n\t\t\tthis._heightFitting = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget heightFitting() {\n\t\treturn this._heightFitting;\n\t}\n\n\tset wrap(value) {\n\t\tif (value !== this._wrap) {\n\t\t\tthis._wrap = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget wrap() {\n\t\treturn this._wrap;\n\t}\n\n\t_isSelfOrChild(entity) {\n\t\treturn entity === this.entity || this.entity.children.indexOf(entity) !== -1;\n\t}\n\n\t_listenForReflowEvents(target, onOff) {\n\t\tif (target.element) {\n\t\t\ttarget.element[onOff]('enableelement', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('disableelement', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('resize', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('set:pivot', this._scheduleReflow, this);\n\t\t}\n\n\t\tif (target.layoutchild) {\n\t\t\ttarget.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);\n\t\t\ttarget.layoutchild[onOff]('resize', this._scheduleReflow, this);\n\t\t}\n\t}\n\n\t_onElementOrLayoutComponentAdd(entity) {\n\t\tif (this._isSelfOrChild(entity)) {\n\t\t\tthis._listenForReflowEvents(entity, 'on');\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\t_onElementOrLayoutComponentRemove(entity) {\n\t\tif (this._isSelfOrChild(entity)) {\n\t\t\tthis._listenForReflowEvents(entity, 'off');\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\t_onChildInsert(child) {\n\t\tthis._listenForReflowEvents(child, 'on');\n\n\t\tthis._scheduleReflow();\n\t}\n\n\t_onChildRemove(child) {\n\t\tthis._listenForReflowEvents(child, 'off');\n\n\t\tthis._scheduleReflow();\n\t}\n\n\t_scheduleReflow() {\n\t\tif (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {\n\t\t\tthis.system.scheduleReflow(this);\n\t\t}\n\t}\n\n\treflow() {\n\t\tconst container = getElement(this.entity);\n\t\tconst elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);\n\n\t\tif (!container || elements.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst containerWidth = Math.max(container.calculatedWidth, 0);\n\t\tconst containerHeight = Math.max(container.calculatedHeight, 0);\n\t\tconst options = {\n\t\t\torientation: this._orientation,\n\t\t\treverseX: this._reverseX,\n\t\t\treverseY: this._reverseY,\n\t\t\talignment: this._alignment,\n\t\t\tpadding: this._padding,\n\t\t\tspacing: this._spacing,\n\t\t\twidthFitting: this._widthFitting,\n\t\t\theightFitting: this._heightFitting,\n\t\t\twrap: this._wrap,\n\t\t\tcontainerSize: new Vec2(containerWidth, containerHeight)\n\t\t};\n\t\tthis._isPerformingReflow = true;\n\n\t\tconst layoutInfo = this._layoutCalculator.calculateLayout(elements, options);\n\n\t\tthis._isPerformingReflow = false;\n\t\tthis.fire('reflow', layoutInfo);\n\t}\n\n\tonEnable() {\n\t\tthis._scheduleReflow();\n\t}\n\n\tonRemove() {\n\t\tthis.entity.off('childinsert', this._onChildInsert, this);\n\t\tthis.entity.off('childremove', this._onChildRemove, this);\n\n\t\tthis._listenForReflowEvents(this.entity, 'off');\n\n\t\tthis.entity.children.forEach(child => {\n\t\t\tthis._listenForReflowEvents(child, 'off');\n\t\t});\n\t\tthis.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);\n\t\tthis.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t\tthis.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);\n\t\tthis.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t}\n\n}\n\nclass LayoutGroupComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$b = ['enabled'];\nconst MAX_ITERATIONS = 100;\n\nclass LayoutGroupComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'layoutgroup';\n\t\tthis.ComponentType = LayoutGroupComponent;\n\t\tthis.DataType = LayoutGroupComponentData;\n\t\tthis.schema = _schema$b;\n\t\tthis._reflowQueue = [];\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('postUpdate', this._onPostUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) component.enabled = data.enabled;\n\t\tif (data.orientation !== undefined) component.orientation = data.orientation;\n\t\tif (data.reverseX !== undefined) component.reverseX = data.reverseX;\n\t\tif (data.reverseY !== undefined) component.reverseY = data.reverseY;\n\n\t\tif (data.alignment !== undefined) {\n\t\t\tcomponent.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;\n\t\t}\n\n\t\tif (data.padding !== undefined) {\n\t\t\tcomponent.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;\n\t\t}\n\n\t\tif (data.spacing !== undefined) {\n\t\t\tcomponent.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;\n\t\t}\n\n\t\tif (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;\n\t\tif (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;\n\t\tif (data.wrap !== undefined) component.wrap = data.wrap;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst layoutGroup = entity.layoutgroup;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: layoutGroup.enabled,\n\t\t\torientation: layoutGroup.orientation,\n\t\t\treverseX: layoutGroup.reverseX,\n\t\t\treverseY: layoutGroup.reverseY,\n\t\t\talignment: layoutGroup.alignment,\n\t\t\tpadding: layoutGroup.padding,\n\t\t\tspacing: layoutGroup.spacing,\n\t\t\twidthFitting: layoutGroup.widthFitting,\n\t\t\theightFitting: layoutGroup.heightFitting,\n\t\t\twrap: layoutGroup.wrap\n\t\t});\n\t}\n\n\tscheduleReflow(component) {\n\t\tif (this._reflowQueue.indexOf(component) === -1) {\n\t\t\tthis._reflowQueue.push(component);\n\t\t}\n\t}\n\n\t_onPostUpdate() {\n\t\tthis._processReflowQueue();\n\t}\n\n\t_processReflowQueue() {\n\t\tif (this._reflowQueue.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet iterationCount = 0;\n\n\t\twhile (this._reflowQueue.length > 0) {\n\t\t\tconst queue = this._reflowQueue.slice();\n\n\t\t\tthis._reflowQueue.length = 0;\n\t\t\tqueue.sort(function (componentA, componentB) {\n\t\t\t\treturn componentA.entity.graphDepth - componentB.entity.graphDepth;\n\t\t\t});\n\n\t\t\tfor (let i = 0; i < queue.length; ++i) {\n\t\t\t\tqueue[i].reflow();\n\t\t\t}\n\n\t\t\tif (++iterationCount >= MAX_ITERATIONS) {\n\t\t\t\tconsole.warn('Max reflow iterations limit reached, bailing.');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('postUpdate', this._onPostUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(LayoutGroupComponent.prototype, _schema$b);\n\nconst _lightProps = [];\nconst _lightPropsDefault = [];\n\nclass LightComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._cookieAsset = null;\n\t\tthis._cookieAssetId = null;\n\t\tthis._cookieAssetAdd = false;\n\t\tthis._cookieMatrix = null;\n\t}\n\n\taddLightToLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addLight(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveLightFromLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeLight(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addLightToLayers();\n\t\t}\n\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\n\t\tif (index >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tlayer.addLight(this);\n\t\t}\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\n\t\tif (index >= 0) {\n\t\t\tlayer.removeLight(this);\n\t\t}\n\t}\n\n\trefreshProperties() {\n\t\tfor (let i = 0; i < _lightProps.length; i++) {\n\t\t\tconst name = _lightProps[i];\n\t\t\tthis[name] = this[name];\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled) this.onEnable();\n\t}\n\n\tupdateShadow() {\n\t\tthis.light.updateShadow();\n\t}\n\n\tonCookieAssetSet() {\n\t\tlet forceLoad = false;\n\n\t\tif (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {\n\t\t\tthis._cookieAsset.loadFaces = true;\n\t\t\tforceLoad = true;\n\t\t}\n\n\t\tif (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);\n\t\tif (this._cookieAsset.resource) this.onCookieAssetLoad();\n\t}\n\n\tonCookieAssetAdd(asset) {\n\t\tif (this._cookieAssetId !== asset.id) return;\n\t\tthis._cookieAsset = asset;\n\t\tif (this.light.enabled) this.onCookieAssetSet();\n\n\t\tthis._cookieAsset.on('load', this.onCookieAssetLoad, this);\n\n\t\tthis._cookieAsset.on('remove', this.onCookieAssetRemove, this);\n\t}\n\n\tonCookieAssetLoad() {\n\t\tif (!this._cookieAsset || !this._cookieAsset.resource) return;\n\t\tthis.cookie = this._cookieAsset.resource;\n\t}\n\n\tonCookieAssetRemove() {\n\t\tif (!this._cookieAssetId) return;\n\n\t\tif (this._cookieAssetAdd) {\n\t\t\tthis.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);\n\t\t\tthis._cookieAssetAdd = false;\n\t\t}\n\n\t\tif (this._cookieAsset) {\n\t\t\tthis._cookieAsset.off('load', this.onCookieAssetLoad, this);\n\n\t\t\tthis._cookieAsset.off('remove', this.onCookieAssetRemove, this);\n\n\t\t\tthis._cookieAsset = null;\n\t\t}\n\n\t\tthis.cookie = null;\n\t}\n\n\tonEnable() {\n\t\tthis.light.enabled = true;\n\t\tthis.system.app.scene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addLightToLayers();\n\t\t}\n\n\t\tif (this._cookieAsset && !this.cookie) this.onCookieAssetSet();\n\t}\n\n\tonDisable() {\n\t\tthis.light.enabled = false;\n\t\tthis.system.app.scene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tthis.removeLightFromLayers();\n\t}\n\n\tonRemove() {\n\t\tthis.onDisable();\n\t\tthis.light.destroy();\n\t\tthis.cookieAsset = null;\n\t}\n\n}\n\nfunction _defineProperty(name, defaultValue, setFunc, skipEqualsCheck) {\n\tconst c = LightComponent.prototype;\n\n\t_lightProps.push(name);\n\n\t_lightPropsDefault.push(defaultValue);\n\n\tObject.defineProperty(c, name, {\n\t\tget: function () {\n\t\t\treturn this.data[name];\n\t\t},\n\t\tset: function (value) {\n\t\t\tconst data = this.data;\n\t\t\tconst oldValue = data[name];\n\t\t\tif (!skipEqualsCheck && oldValue === value) return;\n\t\t\tdata[name] = value;\n\t\t\tif (setFunc) setFunc.call(this, value, oldValue);\n\t\t},\n\t\tconfigurable: true\n\t});\n}\n\nfunction _defineProps() {\n\t_defineProperty(\"enabled\", true, function (newValue, oldValue) {\n\t\tthis.onSetEnabled(null, oldValue, newValue);\n\t});\n\n\t_defineProperty(\"light\", null);\n\n\t_defineProperty(\"type\", 'directional', function (newValue, oldValue) {\n\t\tthis.system.changeType(this, oldValue, newValue);\n\t\tthis.refreshProperties();\n\t});\n\n\t_defineProperty(\"color\", new Color(1, 1, 1), function (newValue, oldValue) {\n\t\tthis.light.setColor(newValue);\n\t}, true);\n\n\t_defineProperty(\"intensity\", 1, function (newValue, oldValue) {\n\t\tthis.light.intensity = newValue;\n\t});\n\n\t_defineProperty(\"shape\", LIGHTSHAPE_PUNCTUAL, function (newValue, oldValue) {\n\t\tthis.light.shape = newValue;\n\t});\n\n\t_defineProperty(\"castShadows\", false, function (newValue, oldValue) {\n\t\tthis.light.castShadows = newValue;\n\t});\n\n\t_defineProperty(\"shadowDistance\", 40, function (newValue, oldValue) {\n\t\tthis.light.shadowDistance = newValue;\n\t});\n\n\t_defineProperty(\"shadowResolution\", 1024, function (newValue, oldValue) {\n\t\tthis.light.shadowResolution = newValue;\n\t});\n\n\t_defineProperty(\"shadowBias\", 0.05, function (newValue, oldValue) {\n\t\tthis.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"numCascades\", 1, function (newValue, oldValue) {\n\t\tthis.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);\n\t});\n\n\t_defineProperty(\"bakeNumSamples\", 1, function (newValue, oldValue) {\n\t\tthis.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);\n\t});\n\n\t_defineProperty(\"bakeArea\", 0, function (newValue, oldValue) {\n\t\tthis.light.bakeArea = math.clamp(newValue, 0, 180);\n\t});\n\n\t_defineProperty(\"cascadeDistribution\", 0.5, function (newValue, oldValue) {\n\t\tthis.light.cascadeDistribution = math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"normalOffsetBias\", 0, function (newValue, oldValue) {\n\t\tthis.light.normalOffsetBias = math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"range\", 10, function (newValue, oldValue) {\n\t\tthis.light.attenuationEnd = newValue;\n\t});\n\n\t_defineProperty(\"innerConeAngle\", 40, function (newValue, oldValue) {\n\t\tthis.light.innerConeAngle = newValue;\n\t});\n\n\t_defineProperty(\"outerConeAngle\", 45, function (newValue, oldValue) {\n\t\tthis.light.outerConeAngle = newValue;\n\t});\n\n\t_defineProperty(\"falloffMode\", LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {\n\t\tthis.light.falloffMode = newValue;\n\t});\n\n\t_defineProperty(\"shadowType\", SHADOW_PCF3, function (newValue, oldValue) {\n\t\tthis.light.shadowType = newValue;\n\t});\n\n\t_defineProperty(\"vsmBlurSize\", 11, function (newValue, oldValue) {\n\t\tthis.light.vsmBlurSize = newValue;\n\t});\n\n\t_defineProperty(\"vsmBlurMode\", BLUR_GAUSSIAN, function (newValue, oldValue) {\n\t\tthis.light.vsmBlurMode = newValue;\n\t});\n\n\t_defineProperty(\"vsmBias\", 0.01 * 0.25, function (newValue, oldValue) {\n\t\tthis.light.vsmBias = math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"cookieAsset\", null, function (newValue, oldValue) {\n\t\tif (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) return;\n\t\tthis.onCookieAssetRemove();\n\t\tthis._cookieAssetId = null;\n\n\t\tif (newValue instanceof Asset) {\n\t\t\tthis.data.cookieAsset = newValue.id;\n\t\t\tthis._cookieAssetId = newValue.id;\n\t\t\tthis.onCookieAssetAdd(newValue);\n\t\t} else if (typeof newValue === 'number') {\n\t\t\tthis._cookieAssetId = newValue;\n\t\t\tconst asset = this.system.app.assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis.onCookieAssetAdd(asset);\n\t\t\t} else {\n\t\t\t\tthis._cookieAssetAdd = true;\n\t\t\t\tthis.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);\n\t\t\t}\n\t\t}\n\t});\n\n\t_defineProperty(\"cookie\", null, function (newValue, oldValue) {\n\t\tthis.light.cookie = newValue;\n\t});\n\n\t_defineProperty(\"cookieIntensity\", 1, function (newValue, oldValue) {\n\t\tthis.light.cookieIntensity = math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"cookieFalloff\", true, function (newValue, oldValue) {\n\t\tthis.light.cookieFalloff = newValue;\n\t});\n\n\t_defineProperty(\"cookieChannel\", \"rgb\", function (newValue, oldValue) {\n\t\tthis.light.cookieChannel = newValue;\n\t});\n\n\t_defineProperty(\"cookieAngle\", 0, function (newValue, oldValue) {\n\t\tif (newValue !== 0 || this.cookieScale !== null) {\n\t\t\tif (!this._cookieMatrix) this._cookieMatrix = new Vec4();\n\t\t\tlet scx = 1;\n\t\t\tlet scy = 1;\n\n\t\t\tif (this.cookieScale) {\n\t\t\t\tscx = this.cookieScale.x;\n\t\t\t\tscy = this.cookieScale.y;\n\t\t\t}\n\n\t\t\tconst c = Math.cos(newValue * math.DEG_TO_RAD);\n\t\t\tconst s = Math.sin(newValue * math.DEG_TO_RAD);\n\n\t\t\tthis._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);\n\n\t\t\tthis.light.cookieTransform = this._cookieMatrix;\n\t\t} else {\n\t\t\tthis.light.cookieTransform = null;\n\t\t}\n\t});\n\n\t_defineProperty(\"cookieScale\", null, function (newValue, oldValue) {\n\t\tif (newValue !== null || this.cookieAngle !== 0) {\n\t\t\tif (!this._cookieMatrix) this._cookieMatrix = new Vec4();\n\t\t\tconst scx = newValue.x;\n\t\t\tconst scy = newValue.y;\n\t\t\tconst c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);\n\t\t\tconst s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);\n\n\t\t\tthis._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);\n\n\t\t\tthis.light.cookieTransform = this._cookieMatrix;\n\t\t} else {\n\t\t\tthis.light.cookieTransform = null;\n\t\t}\n\t}, true);\n\n\t_defineProperty(\"cookieOffset\", null, function (newValue, oldValue) {\n\t\tthis.light.cookieOffset = newValue;\n\t}, true);\n\n\t_defineProperty(\"shadowUpdateMode\", SHADOWUPDATE_REALTIME, function (newValue, oldValue) {\n\t\tthis.light.shadowUpdateMode = newValue;\n\t}, true);\n\n\t_defineProperty(\"mask\", 1, function (newValue, oldValue) {\n\t\tthis.light.mask = newValue;\n\t});\n\n\t_defineProperty(\"affectDynamic\", true, function (newValue, oldValue) {\n\t\tif (newValue) {\n\t\t\tthis.light.mask |= MASK_AFFECT_DYNAMIC;\n\t\t} else {\n\t\t\tthis.light.mask &= ~MASK_AFFECT_DYNAMIC;\n\t\t}\n\n\t\tthis.light.layersDirty();\n\t});\n\n\t_defineProperty(\"affectLightmapped\", false, function (newValue, oldValue) {\n\t\tif (newValue) {\n\t\t\tthis.light.mask |= MASK_AFFECT_LIGHTMAPPED;\n\t\t\tif (this.bake) this.light.mask &= ~MASK_BAKE;\n\t\t} else {\n\t\t\tthis.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;\n\t\t\tif (this.bake) this.light.mask |= MASK_BAKE;\n\t\t}\n\t});\n\n\t_defineProperty(\"bake\", false, function (newValue, oldValue) {\n\t\tif (newValue) {\n\t\t\tthis.light.mask |= MASK_BAKE;\n\t\t\tif (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;\n\t\t} else {\n\t\t\tthis.light.mask &= ~MASK_BAKE;\n\t\t\tif (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;\n\t\t}\n\n\t\tthis.light.layersDirty();\n\t});\n\n\t_defineProperty(\"bakeDir\", true, function (newValue, oldValue) {\n\t\tthis.light.bakeDir = newValue;\n\t});\n\n\t_defineProperty(\"isStatic\", false, function (newValue, oldValue) {\n\t\tthis.light.isStatic = newValue;\n\t});\n\n\t_defineProperty(\"layers\", [LAYERID_WORLD], function (newValue, oldValue) {\n\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(oldValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeLight(this);\n\t\t}\n\n\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\tif (!layer) continue;\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tlayer.addLight(this);\n\t\t\t}\n\t\t}\n\t});\n}\n\n_defineProps();\n\nclass LightComponentData {\n\tconstructor() {\n\t\tconst _props = _lightProps;\n\t\tconst _propsDefault = _lightPropsDefault;\n\n\t\tfor (let i = 0; i < _props.length; i++) {\n\t\t\tconst value = _propsDefault[i];\n\n\t\t\tif (value && value.clone) {\n\t\t\t\tthis[_props[i]] = value.clone();\n\t\t\t} else {\n\t\t\t\tthis[_props[i]] = value;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nconst lightTypes = {\n\t'directional': LIGHTTYPE_DIRECTIONAL,\n\t'omni': LIGHTTYPE_OMNI,\n\t'point': LIGHTTYPE_OMNI,\n\t'spot': LIGHTTYPE_SPOT\n};\n\nclass LightComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'light';\n\t\tthis.ComponentType = LightComponent;\n\t\tthis.DataType = LightComponentData;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t}\n\n\tinitializeComponentData(component, _data) {\n\t\tconst properties = _lightProps;\n\t\tconst data = {};\n\n\t\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\t\tconst property = properties[i];\n\t\t\tdata[property] = _data[property];\n\t\t}\n\n\t\tif (!data.type) data.type = component.data.type;\n\t\tcomponent.data.type = data.type;\n\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tdata.layers = data.layers.slice(0);\n\t\t}\n\n\t\tif (data.color && Array.isArray(data.color)) data.color = new Color(data.color[0], data.color[1], data.color[2]);\n\t\tif (data.cookieOffset && data.cookieOffset instanceof Array) data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);\n\t\tif (data.cookieScale && data.cookieScale instanceof Array) data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);\n\n\t\tif (data.enable) {\n\t\t\tconsole.warn(\"WARNING: enable: Property is deprecated. Set enabled property instead.\");\n\t\t\tdata.enabled = data.enable;\n\t\t}\n\n\t\tif (!data.shape) {\n\t\t\tdata.shape = LIGHTSHAPE_PUNCTUAL;\n\t\t}\n\n\t\tconst light = new Light(this.app.graphicsDevice);\n\t\tlight.type = lightTypes[data.type];\n\t\tlight._node = component.entity;\n\t\tlight._scene = this.app.scene;\n\t\tcomponent.data.light = light;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst light = entity.light;\n\t\tconst data = [];\n\t\tlet name;\n\t\tconst _props = _lightProps;\n\n\t\tfor (let i = 0; i < _props.length; i++) {\n\t\t\tname = _props[i];\n\t\t\tif (name === \"light\") continue;\n\n\t\t\tif (light[name] && light[name].clone) {\n\t\t\t\tdata[name] = light[name].clone();\n\t\t\t} else {\n\t\t\t\tdata[name] = light[name];\n\t\t\t}\n\t\t}\n\n\t\tthis.addComponent(clone, data);\n\t}\n\n\tchangeType(component, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tcomponent.light.type = lightTypes[newValue];\n\t\t}\n\t}\n\n}\n\nclass ModelComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._type = 'asset';\n\t\tthis._asset = null;\n\t\tthis._model = null;\n\t\tthis._mapping = {};\n\t\tthis._castShadows = true;\n\t\tthis._receiveShadows = true;\n\t\tthis._materialAsset = null;\n\t\tthis._material = system.defaultMaterial;\n\t\tthis._castShadowsLightmap = true;\n\t\tthis._lightmapped = false;\n\t\tthis._lightmapSizeMultiplier = 1;\n\t\tthis._isStatic = false;\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._batchGroupId = -1;\n\t\tthis._customAabb = null;\n\t\tthis._area = null;\n\t\tthis._assetOld = 0;\n\t\tthis._materialEvents = null;\n\t\tthis._dirtyModelAsset = false;\n\t\tthis._dirtyMaterialAsset = false;\n\t\tthis._clonedModel = false;\n\t\tentity.on('remove', this.onRemoveChild, this);\n\t\tentity.on('removehierarchy', this.onRemoveChild, this);\n\t\tentity.on('insert', this.onInsertChild, this);\n\t\tentity.on('inserthierarchy', this.onInsertChild, this);\n\t}\n\n\tset meshInstances(value) {\n\t\tif (!this._model) return;\n\t\tthis._model.meshInstances = value;\n\t}\n\n\tget meshInstances() {\n\t\tif (!this._model) return null;\n\t\treturn this._model.meshInstances;\n\t}\n\n\tset customAabb(value) {\n\t\tthis._customAabb = value;\n\n\t\tif (this._model) {\n\t\t\tconst mi = this._model.meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget customAabb() {\n\t\treturn this._customAabb;\n\t}\n\n\tset type(value) {\n\t\tif (this._type === value) return;\n\t\tthis._area = null;\n\t\tthis._type = value;\n\n\t\tif (value === 'asset') {\n\t\t\tif (this._asset !== null) {\n\t\t\t\tthis._bindModelAsset(this._asset);\n\t\t\t} else {\n\t\t\t\tthis.model = null;\n\t\t\t}\n\t\t} else {\n\t\t\tconst primData = getShapePrimitive(this.system.app.graphicsDevice, value);\n\t\t\tthis._area = primData.area;\n\t\t\tconst mesh = primData.mesh;\n\t\t\tconst node = new GraphNode();\n\t\t\tconst model = new Model();\n\t\t\tmodel.graph = node;\n\t\t\tmodel.meshInstances = [new MeshInstance(mesh, this._material, node)];\n\t\t\tthis.model = model;\n\t\t\tthis._asset = null;\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset asset(value) {\n\t\tconst assets = this.system.app.assets;\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tif (this._asset !== _id) {\n\t\t\tif (this._asset) {\n\t\t\t\tassets.off('add:' + this._asset, this._onModelAssetAdded, this);\n\n\t\t\t\tconst _prev = assets.get(this._asset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindModelAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._asset = _id;\n\n\t\t\tif (this._asset) {\n\t\t\t\tconst asset = assets.get(this._asset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.model = null;\n\t\t\t\t\tassets.on('add:' + this._asset, this._onModelAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindModelAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.model = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget asset() {\n\t\treturn this._asset;\n\t}\n\n\tset model(value) {\n\t\tif (this._model === value) return;\n\n\t\tif (value && value._immutable) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._model) {\n\t\t\tthis._model._immutable = false;\n\t\t\tthis.removeModelFromLayers();\n\t\t\tthis.entity.removeChild(this._model.getGraph());\n\t\t\tdelete this._model._entity;\n\n\t\t\tif (this._clonedModel) {\n\t\t\t\tthis._model.destroy();\n\n\t\t\t\tthis._clonedModel = false;\n\t\t\t}\n\t\t}\n\n\t\tthis._model = value;\n\n\t\tif (this._model) {\n\t\t\tthis._model._immutable = true;\n\t\t\tconst meshInstances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].castShadow = this._castShadows;\n\t\t\t\tmeshInstances[i].receiveShadow = this._receiveShadows;\n\t\t\t\tmeshInstances[i].isStatic = this._isStatic;\n\t\t\t\tmeshInstances[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\n\t\t\tthis.lightmapped = this._lightmapped;\n\t\t\tthis.entity.addChild(this._model.graph);\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addModelToLayers();\n\t\t\t}\n\n\t\t\tthis._model._entity = this.entity;\n\t\t\tif (this.entity.animation) this.entity.animation.setModel(this._model);\n\n\t\t\tif (this.entity.anim) {\n\t\t\t\tif (this.entity.anim.playing) {\n\t\t\t\t\tthis.entity.anim.rebind();\n\t\t\t\t} else {\n\t\t\t\t\tthis.entity.anim.resetStateGraph();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.type === 'asset') {\n\t\t\t\tthis.mapping = this._mapping;\n\t\t\t} else {\n\t\t\t\tthis._unsetMaterialEvents();\n\t\t\t}\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn this._model;\n\t}\n\n\tset lightmapped(value) {\n\t\tif (value !== this._lightmapped) {\n\t\t\tthis._lightmapped = value;\n\n\t\t\tif (this._model) {\n\t\t\t\tconst mi = this._model.meshInstances;\n\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setLightmapped(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget lightmapped() {\n\t\treturn this._lightmapped;\n\t}\n\n\tset castShadows(value) {\n\t\tif (this._castShadows === value) return;\n\t\tconst model = this._model;\n\n\t\tif (model) {\n\t\t\tconst layers = this.layers;\n\t\t\tconst scene = this.system.app.scene;\n\n\t\t\tif (this._castShadows && !value) {\n\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\t\t\tif (!layer) continue;\n\t\t\t\t\tlayer.removeShadowCasters(model.meshInstances);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst meshInstances = model.meshInstances;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].castShadow = value;\n\t\t\t}\n\n\t\t\tif (!this._castShadows && value) {\n\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\t\t\t\t\tif (!layer) continue;\n\t\t\t\t\tlayer.addShadowCasters(model.meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._castShadows = value;\n\t}\n\n\tget castShadows() {\n\t\treturn this._castShadows;\n\t}\n\n\tset receiveShadows(value) {\n\t\tif (this._receiveShadows === value) return;\n\t\tthis._receiveShadows = value;\n\n\t\tif (this._model) {\n\t\t\tconst meshInstances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\t\tmeshInstances[i].receiveShadow = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tget receiveShadows() {\n\t\treturn this._receiveShadows;\n\t}\n\n\tset castShadowsLightmap(value) {\n\t\tthis._castShadowsLightmap = value;\n\t}\n\n\tget castShadowsLightmap() {\n\t\treturn this._castShadowsLightmap;\n\t}\n\n\tset lightmapSizeMultiplier(value) {\n\t\tthis._lightmapSizeMultiplier = value;\n\t}\n\n\tget lightmapSizeMultiplier() {\n\t\treturn this._lightmapSizeMultiplier;\n\t}\n\n\tset isStatic(value) {\n\t\tif (this._isStatic === value) return;\n\t\tthis._isStatic = value;\n\n\t\tif (this._model) {\n\t\t\tconst rcv = this._model.meshInstances;\n\n\t\t\tfor (let i = 0; i < rcv.length; i++) {\n\t\t\t\tconst m = rcv[i];\n\t\t\t\tm.isStatic = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tget isStatic() {\n\t\treturn this._isStatic;\n\t}\n\n\tset layers(value) {\n\t\tconst layers = this.system.app.scene.layers;\n\n\t\tif (this.meshInstances) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\t\tif (!layer) continue;\n\t\t\t\tlayer.removeMeshInstances(this.meshInstances);\n\t\t\t}\n\t\t}\n\n\t\tthis._layers.length = 0;\n\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tthis._layers[i] = value[i];\n\t\t}\n\n\t\tif (!this.enabled || !this.entity.enabled || !this.meshInstances) return;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances(this.meshInstances);\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) return;\n\t\tconst batcher = this.system.app.batcher;\n\n\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\tbatcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tbatcher.insert(BatchGroup.MODEL, value, this.entity);\n\t\t}\n\n\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tthis.addModelToLayers();\n\t\t}\n\n\t\tthis._batchGroupId = value;\n\t}\n\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\n\tset materialAsset(value) {\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (_id !== this._materialAsset) {\n\t\t\tif (this._materialAsset) {\n\t\t\t\tassets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);\n\n\t\t\t\tconst _prev = assets.get(this._materialAsset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindMaterialAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._materialAsset = _id;\n\n\t\t\tif (this._materialAsset) {\n\t\t\t\tconst asset = assets.get(this._materialAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis._setMaterial(this.system.defaultMaterial);\n\n\t\t\t\t\tassets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setMaterial(this.system.defaultMaterial);\n\t\t\t}\n\t\t}\n\t}\n\n\tget materialAsset() {\n\t\treturn this._materialAsset;\n\t}\n\n\tset material(value) {\n\t\tif (this._material === value) return;\n\t\tthis.materialAsset = null;\n\n\t\tthis._setMaterial(value);\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset mapping(value) {\n\t\tif (this._type !== 'asset') return;\n\n\t\tthis._unsetMaterialEvents();\n\n\t\tif (!value) value = {};\n\t\tthis._mapping = value;\n\t\tif (!this._model) return;\n\t\tconst meshInstances = this._model.meshInstances;\n\t\tconst modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;\n\t\tconst assetMapping = modelAsset ? modelAsset.data.mapping : null;\n\t\tlet asset = null;\n\n\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\tif (value[i] !== undefined) {\n\t\t\t\tif (value[i]) {\n\t\t\t\t\tasset = this.system.app.assets.get(value[i]);\n\n\t\t\t\t\tthis._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);\n\t\t\t\t} else {\n\t\t\t\t\tmeshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t} else if (assetMapping) {\n\t\t\t\tif (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {\n\t\t\t\t\tif (assetMapping[i].material !== undefined) {\n\t\t\t\t\t\tasset = this.system.app.assets.get(assetMapping[i].material);\n\t\t\t\t\t} else if (assetMapping[i].path !== undefined) {\n\t\t\t\t\t\tconst url = this._getMaterialAssetUrl(assetMapping[i].path);\n\n\t\t\t\t\t\tif (url) {\n\t\t\t\t\t\t\tasset = this.system.app.assets.getByUrl(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);\n\t\t\t\t} else {\n\t\t\t\t\tmeshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget mapping() {\n\t\treturn this._mapping;\n\t}\n\n\taddModelToLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this.meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveModelFromLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances(this.meshInstances);\n\t\t}\n\t}\n\n\tonRemoveChild() {\n\t\tif (this._model) this.removeModelFromLayers();\n\t}\n\n\tonInsertChild() {\n\t\tif (this._model && this.enabled && this.entity.enabled) this.addModelToLayers();\n\t}\n\n\tonRemove() {\n\t\tthis.asset = null;\n\t\tthis.model = null;\n\t\tthis.materialAsset = null;\n\n\t\tthis._unsetMaterialEvents();\n\n\t\tthis.entity.off('remove', this.onRemoveChild, this);\n\t\tthis.entity.off('insert', this.onInsertChild, this);\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addModelToLayers();\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances(this.meshInstances);\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances(this.meshInstances);\n\t}\n\n\t_setMaterialEvent(index, event, id, handler) {\n\t\tconst evt = event + ':' + id;\n\t\tthis.system.app.assets.on(evt, handler, this);\n\t\tif (!this._materialEvents) this._materialEvents = [];\n\t\tif (!this._materialEvents[index]) this._materialEvents[index] = {};\n\t\tthis._materialEvents[index][evt] = {\n\t\t\tid: id,\n\t\t\thandler: handler\n\t\t};\n\t}\n\n\t_unsetMaterialEvents() {\n\t\tconst assets = this.system.app.assets;\n\t\tconst events = this._materialEvents;\n\t\tif (!events) return;\n\n\t\tfor (let i = 0, len = events.length; i < len; i++) {\n\t\t\tif (!events[i]) continue;\n\t\t\tconst evt = events[i];\n\n\t\t\tfor (const key in evt) {\n\t\t\t\tassets.off(key, evt[key].handler, this);\n\t\t\t}\n\t\t}\n\n\t\tthis._materialEvents = null;\n\t}\n\n\t_getAssetByIdOrPath(idOrPath) {\n\t\tlet asset = null;\n\t\tconst isPath = isNaN(parseInt(idOrPath, 10));\n\n\t\tif (!isPath) {\n\t\t\tasset = this.system.app.assets.get(idOrPath);\n\t\t} else if (this.asset) {\n\t\t\tconst url = this._getMaterialAssetUrl(idOrPath);\n\n\t\t\tif (url) asset = this.system.app.assets.getByUrl(url);\n\t\t}\n\n\t\treturn asset;\n\t}\n\n\t_getMaterialAssetUrl(path) {\n\t\tif (!this.asset) return null;\n\t\tconst modelAsset = this.system.app.assets.get(this.asset);\n\t\treturn modelAsset ? modelAsset.getAbsoluteUrl(path) : null;\n\t}\n\n\t_loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (!materialAsset) return;\n\n\t\tif (materialAsset.resource) {\n\t\t\tmeshInstance.material = materialAsset.resource;\n\n\t\t\tthis._setMaterialEvent(index, 'remove', materialAsset.id, function () {\n\t\t\t\tmeshInstance.material = this.system.defaultMaterial;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {\n\t\t\t\tmeshInstance.material = asset.resource;\n\n\t\t\t\tthis._setMaterialEvent(index, 'remove', materialAsset.id, function () {\n\t\t\t\t\tmeshInstance.material = this.system.defaultMaterial;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (this.enabled && this.entity.enabled) assets.load(materialAsset);\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tscene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tconst isAsset = this._type === 'asset';\n\t\tlet asset;\n\n\t\tif (this._model) {\n\t\t\tthis.addModelToLayers();\n\t\t} else if (isAsset && this._asset) {\n\t\t\tasset = app.assets.get(this._asset);\n\n\t\t\tif (asset && asset.resource !== this._model) {\n\t\t\t\tthis._bindModelAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (this._materialAsset) {\n\t\t\tasset = app.assets.get(this._materialAsset);\n\n\t\t\tif (asset && asset.resource !== this._material) {\n\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (isAsset) {\n\t\t\tif (this._mapping) {\n\t\t\t\tfor (const index in this._mapping) {\n\t\t\t\t\tif (this._mapping[index]) {\n\t\t\t\t\t\tasset = this._getAssetByIdOrPath(this._mapping[index]);\n\n\t\t\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\t\t\tapp.assets.load(asset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tscene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tif (this._model) {\n\t\t\tthis.removeModelFromLayers();\n\t\t}\n\t}\n\n\thide() {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].visible = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tshow() {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].visible = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t_bindMaterialAsset(asset) {\n\t\tasset.on('load', this._onMaterialAssetLoad, this);\n\t\tasset.on('unload', this._onMaterialAssetUnload, this);\n\t\tasset.on('remove', this._onMaterialAssetRemove, this);\n\t\tasset.on('change', this._onMaterialAssetChange, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindMaterialAsset(asset) {\n\t\tasset.off('load', this._onMaterialAssetLoad, this);\n\t\tasset.off('unload', this._onMaterialAssetUnload, this);\n\t\tasset.off('remove', this._onMaterialAssetRemove, this);\n\t\tasset.off('change', this._onMaterialAssetChange, this);\n\t}\n\n\t_onMaterialAssetAdd(asset) {\n\t\tthis.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);\n\n\t\tif (this._materialAsset === asset.id) {\n\t\t\tthis._bindMaterialAsset(asset);\n\t\t}\n\t}\n\n\t_onMaterialAssetLoad(asset) {\n\t\tthis._setMaterial(asset.resource);\n\t}\n\n\t_onMaterialAssetUnload(asset) {\n\t\tthis._setMaterial(this.system.defaultMaterial);\n\t}\n\n\t_onMaterialAssetRemove(asset) {\n\t\tthis._onMaterialAssetUnload(asset);\n\t}\n\n\t_onMaterialAssetChange(asset) {}\n\n\t_bindModelAsset(asset) {\n\t\tthis._unbindModelAsset(asset);\n\n\t\tasset.on('load', this._onModelAssetLoad, this);\n\t\tasset.on('unload', this._onModelAssetUnload, this);\n\t\tasset.on('change', this._onModelAssetChange, this);\n\t\tasset.on('remove', this._onModelAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onModelAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindModelAsset(asset) {\n\t\tasset.off('load', this._onModelAssetLoad, this);\n\t\tasset.off('unload', this._onModelAssetUnload, this);\n\t\tasset.off('change', this._onModelAssetChange, this);\n\t\tasset.off('remove', this._onModelAssetRemove, this);\n\t}\n\n\t_onModelAssetAdded(asset) {\n\t\tthis.system.app.assets.off('add:' + asset.id, this._onModelAssetAdded, this);\n\n\t\tif (asset.id === this._asset) {\n\t\t\tthis._bindModelAsset(asset);\n\t\t}\n\t}\n\n\t_onModelAssetLoad(asset) {\n\t\tthis.model = asset.resource.clone();\n\t\tthis._clonedModel = true;\n\t}\n\n\t_onModelAssetUnload(asset) {\n\t\tthis.model = null;\n\t}\n\n\t_onModelAssetChange(asset, attr, _new, _old) {\n\t\tif (attr === 'data') {\n\t\t\tthis.mapping = this._mapping;\n\t\t}\n\t}\n\n\t_onModelAssetRemove(asset) {\n\t\tthis.model = null;\n\t}\n\n\t_setMaterial(material) {\n\t\tif (this._material === material) return;\n\t\tthis._material = material;\n\t\tconst model = this._model;\n\n\t\tif (model && this._type !== 'asset') {\n\t\t\tconst meshInstances = model.meshInstances;\n\n\t\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\t\tmeshInstances[i].material = material;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass ModelComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$a = ['enabled'];\n\nclass ModelComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'model';\n\t\tthis.ComponentType = ModelComponent;\n\t\tthis.DataType = ModelComponentData;\n\t\tthis.schema = _schema$a;\n\t\tthis.defaultMaterial = DefaultMaterial.get(app.graphicsDevice);\n\t\tthis.on('beforeremove', this.onRemove, this);\n\t}\n\n\tinitializeComponentData(component, _data, properties) {\n\t\tproperties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];\n\n\t\tif (_data.batchGroupId === null || _data.batchGroupId === undefined) {\n\t\t\t_data.batchGroupId = -1;\n\t\t}\n\n\t\tif (_data.layers && _data.layers.length) {\n\t\t\t_data.layers = _data.layers.slice(0);\n\t\t}\n\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tif (_data.hasOwnProperty(properties[i])) {\n\t\t\t\tcomponent[properties[i]] = _data[properties[i]];\n\t\t\t}\n\t\t}\n\n\t\tif (_data.aabbCenter && _data.aabbHalfExtents) {\n\t\t\tcomponent.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));\n\t\t}\n\n\t\tsuper.initializeComponentData(component, _data, ['enabled']);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst data = {\n\t\t\ttype: entity.model.type,\n\t\t\tasset: entity.model.asset,\n\t\t\tcastShadows: entity.model.castShadows,\n\t\t\treceiveShadows: entity.model.receiveShadows,\n\t\t\tcastShadowsLightmap: entity.model.castShadowsLightmap,\n\t\t\tlightmapped: entity.model.lightmapped,\n\t\t\tlightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,\n\t\t\tisStatic: entity.model.isStatic,\n\t\t\tenabled: entity.model.enabled,\n\t\t\tlayers: entity.model.layers,\n\t\t\tbatchGroupId: entity.model.batchGroupId,\n\t\t\tmapping: extend({}, entity.model.mapping)\n\t\t};\n\t\tlet materialAsset = entity.model.materialAsset;\n\n\t\tif (!(materialAsset instanceof Asset) && materialAsset != null) {\n\t\t\tmaterialAsset = this.app.assets.get(materialAsset);\n\t\t}\n\n\t\tconst material = entity.model.material;\n\n\t\tif (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {\n\t\t\tdata.materialAsset = materialAsset;\n\t\t}\n\n\t\tconst component = this.addComponent(clone, data);\n\n\t\tif (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {\n\t\t\tcomponent.model = entity.model.model.clone();\n\t\t\tcomponent._clonedModel = true;\n\t\t}\n\n\t\tif (!data.materialAsset) component.material = material;\n\n\t\tif (entity.model.model) {\n\t\t\tconst meshInstances = entity.model.model.meshInstances;\n\t\t\tconst meshInstancesClone = component.model.meshInstances;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstancesClone[i].mask = meshInstances[i].mask;\n\t\t\t\tmeshInstancesClone[i].material = meshInstances[i].material;\n\t\t\t\tmeshInstancesClone[i].layer = meshInstances[i].layer;\n\t\t\t\tmeshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;\n\t\t\t}\n\t\t}\n\n\t\tif (entity.model.customAabb) {\n\t\t\tcomponent.customAabb = entity.model.customAabb.clone();\n\t\t}\n\t}\n\n\tonRemove(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n}\n\nComponent._buildAccessors(ModelComponent.prototype, _schema$a);\n\nclass RenderComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._type = 'asset';\n\t\tthis._castShadows = true;\n\t\tthis._receiveShadows = true;\n\t\tthis._castShadowsLightmap = true;\n\t\tthis._lightmapped = false;\n\t\tthis._lightmapSizeMultiplier = 1;\n\t\tthis._isStatic = false;\n\t\tthis._batchGroupId = -1;\n\t\tthis._meshInstances = [];\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._renderStyle = RENDERSTYLE_SOLID;\n\t\tthis._customAabb = null;\n\t\tthis._area = null;\n\t\tthis._rootBone = new EntityReference(this, 'rootBone');\n\n\t\tthis._rootBone.on('set:entity', this._onSetRootBone, this);\n\n\t\tthis._assetReference = new AssetReference('asset', this, system.app.assets, {\n\t\t\tadd: this._onRenderAssetAdded,\n\t\t\tload: this._onRenderAssetLoad,\n\t\t\tremove: this._onRenderAssetRemove,\n\t\t\tunload: this._onRenderAssetUnload\n\t\t}, this);\n\t\tthis._material = system.defaultMaterial;\n\t\tthis._materialReferences = [];\n\t\tentity.on('remove', this.onRemoveChild, this);\n\t\tentity.on('removehierarchy', this.onRemoveChild, this);\n\t\tentity.on('insert', this.onInsertChild, this);\n\t\tentity.on('inserthierarchy', this.onInsertChild, this);\n\t}\n\n\tset renderStyle(renderStyle) {\n\t\tif (this._renderStyle !== renderStyle) {\n\t\t\tthis._renderStyle = renderStyle;\n\n\t\t\tMeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);\n\t\t}\n\t}\n\n\tget renderStyle() {\n\t\treturn this._renderStyle;\n\t}\n\n\tset customAabb(value) {\n\t\tthis._customAabb = value;\n\t\tconst mi = this._meshInstances;\n\n\t\tif (mi) {\n\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\t\t}\n\t}\n\n\tget customAabb() {\n\t\treturn this._customAabb;\n\t}\n\n\tset type(value) {\n\t\tif (this._type !== value) {\n\t\t\tthis._area = null;\n\t\t\tthis._type = value;\n\t\t\tthis.destroyMeshInstances();\n\n\t\t\tif (value !== 'asset') {\n\t\t\t\tlet material = this._material;\n\n\t\t\t\tif (!material || material === this.system.defaultMaterial) {\n\t\t\t\t\tmaterial = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;\n\t\t\t\t}\n\n\t\t\t\tconst primData = getShapePrimitive(this.system.app.graphicsDevice, value);\n\t\t\t\tthis._area = primData.area;\n\t\t\t\tthis.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset meshInstances(value) {\n\t\tthis.destroyMeshInstances();\n\t\tthis._meshInstances = value;\n\n\t\tif (this._meshInstances) {\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\tif (!mi[i].node) {\n\t\t\t\t\tmi[i].node = this.entity;\n\t\t\t\t}\n\n\t\t\t\tmi[i].castShadow = this._castShadows;\n\t\t\t\tmi[i].receiveShadow = this._receiveShadows;\n\t\t\t\tmi[i].isStatic = this._isStatic;\n\t\t\t\tmi[i].renderStyle = this._renderStyle;\n\t\t\t\tmi[i].setLightmapped(this._lightmapped);\n\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addToLayers();\n\t\t\t}\n\t\t}\n\t}\n\n\tget meshInstances() {\n\t\treturn this._meshInstances;\n\t}\n\n\tset lightmapped(value) {\n\t\tif (value !== this._lightmapped) {\n\t\t\tthis._lightmapped = value;\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setLightmapped(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget lightmapped() {\n\t\treturn this._lightmapped;\n\t}\n\n\tset castShadows(value) {\n\t\tif (this._castShadows !== value) {\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tconst layers = this.layers;\n\t\t\t\tconst scene = this.system.app.scene;\n\n\t\t\t\tif (this._castShadows && !value) {\n\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\tconst layer = scene.layers.getLayerById(this.layers[i]);\n\n\t\t\t\t\t\tif (layer) {\n\t\t\t\t\t\t\tlayer.removeShadowCasters(mi);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].castShadow = value;\n\t\t\t\t}\n\n\t\t\t\tif (!this._castShadows && value) {\n\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\n\t\t\t\t\t\tif (layer) {\n\t\t\t\t\t\t\tlayer.addShadowCasters(mi);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._castShadows = value;\n\t\t}\n\t}\n\n\tget castShadows() {\n\t\treturn this._castShadows;\n\t}\n\n\tset receiveShadows(value) {\n\t\tif (this._receiveShadows !== value) {\n\t\t\tthis._receiveShadows = value;\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].receiveShadow = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget receiveShadows() {\n\t\treturn this._receiveShadows;\n\t}\n\n\tset castShadowsLightmap(value) {\n\t\tthis._castShadowsLightmap = value;\n\t}\n\n\tget castShadowsLightmap() {\n\t\treturn this._castShadowsLightmap;\n\t}\n\n\tset lightmapSizeMultiplier(value) {\n\t\tthis._lightmapSizeMultiplier = value;\n\t}\n\n\tget lightmapSizeMultiplier() {\n\t\treturn this._lightmapSizeMultiplier;\n\t}\n\n\tset isStatic(value) {\n\t\tif (this._isStatic !== value) {\n\t\t\tthis._isStatic = value;\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].isStatic = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget isStatic() {\n\t\treturn this._isStatic;\n\t}\n\n\tset layers(value) {\n\t\tconst layers = this.system.app.scene.layers;\n\t\tlet layer;\n\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tlayer = layers.getLayerById(this._layers[i]);\n\n\t\t\t\tif (layer) {\n\t\t\t\t\tlayer.removeMeshInstances(this._meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._layers.length = 0;\n\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tthis._layers[i] = value[i];\n\t\t}\n\n\t\tif (!this.enabled || !this.entity.enabled || !this._meshInstances) return;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tlayer = layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this._meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId !== value) {\n\t\t\tconst batcher = this.system.app.batcher;\n\n\t\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\t\tbatcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t\t}\n\n\t\t\tif (this.entity.enabled && value >= 0) {\n\t\t\t\tbatcher.insert(BatchGroup.RENDER, value, this.entity);\n\t\t\t}\n\n\t\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addToLayers();\n\t\t\t}\n\n\t\t\tthis._batchGroupId = value;\n\t\t}\n\t}\n\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\n\tset material(value) {\n\t\tif (this._material !== value) {\n\t\t\tthis._material = value;\n\n\t\t\tif (this._meshInstances && this._type !== 'asset') {\n\t\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\t\tthis._meshInstances[i].material = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset materialAssets(value = []) {\n\t\tif (this._materialReferences.length > value.length) {\n\t\t\tfor (let i = value.length; i < this._materialReferences.length; i++) {\n\t\t\t\tthis._materialReferences[i].id = null;\n\t\t\t}\n\n\t\t\tthis._materialReferences.length = value.length;\n\t\t}\n\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tif (!this._materialReferences[i]) {\n\t\t\t\tthis._materialReferences.push(new AssetReference(i, this, this.system.app.assets, {\n\t\t\t\t\tadd: this._onMaterialAdded,\n\t\t\t\t\tload: this._onMaterialLoad,\n\t\t\t\t\tremove: this._onMaterialRemove,\n\t\t\t\t\tunload: this._onMaterialUnload\n\t\t\t\t}, this));\n\t\t\t}\n\n\t\t\tif (value[i]) {\n\t\t\t\tconst id = value[i] instanceof Asset ? value[i].id : value[i];\n\n\t\t\t\tif (this._materialReferences[i].id !== id) {\n\t\t\t\t\tthis._materialReferences[i].id = id;\n\t\t\t\t}\n\n\t\t\t\tif (this._materialReferences[i].asset) {\n\t\t\t\t\tthis._onMaterialAdded(i, this, this._materialReferences[i].asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._materialReferences[i].id = null;\n\n\t\t\t\tif (this._meshInstances[i]) {\n\t\t\t\t\tthis._meshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget materialAssets() {\n\t\treturn this._materialReferences.map(function (ref) {\n\t\t\treturn ref.id;\n\t\t});\n\t}\n\n\tset asset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\t\tif (this._assetReference.id === id) return;\n\n\t\tif (this._assetReference.asset && this._assetReference.asset.resource) {\n\t\t\tthis._onRenderAssetRemove();\n\t\t}\n\n\t\tthis._assetReference.id = id;\n\n\t\tif (this._assetReference.asset) {\n\t\t\tthis._onRenderAssetAdded();\n\t\t}\n\t}\n\n\tget asset() {\n\t\treturn this._assetReference.id;\n\t}\n\n\t_onSetRootBone(entity) {\n\t\tif (entity) {\n\t\t\tthis._onRootBoneChanged();\n\t\t}\n\t}\n\n\t_onRootBoneChanged() {\n\t\tthis._clearSkinInstances();\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis._cloneSkinInstances();\n\t\t}\n\t}\n\n\tdestroyMeshInstances() {\n\t\tconst meshInstances = this._meshInstances;\n\n\t\tif (meshInstances) {\n\t\t\tthis.removeFromLayers();\n\n\t\t\tthis._clearSkinInstances();\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].destroy();\n\t\t\t}\n\n\t\t\tthis._meshInstances.length = 0;\n\t\t}\n\t}\n\n\taddToLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this._meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveFromLayers() {\n\t\tif (this._meshInstances && this._meshInstances.length) {\n\t\t\tconst layers = this.system.app.scene.layers;\n\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\n\t\t\t\tif (layer) {\n\t\t\t\t\tlayer.removeMeshInstances(this._meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonRemoveChild() {\n\t\tthis.removeFromLayers();\n\t}\n\n\tonInsertChild() {\n\t\tif (this._meshInstances && this.enabled && this.entity.enabled) {\n\t\t\tthis.addToLayers();\n\t\t}\n\t}\n\n\tonRemove() {\n\t\tthis.destroyMeshInstances();\n\t\tthis.asset = null;\n\t\tthis.materialAsset = null;\n\t\tthis.entity.off('remove', this.onRemoveChild, this);\n\t\tthis.entity.off('insert', this.onInsertChild, this);\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addToLayers();\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances(this._meshInstances);\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances(this._meshInstances);\n\t}\n\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\n\t\tthis._rootBone.onParentComponentEnable();\n\n\t\tthis._cloneSkinInstances();\n\n\t\tscene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tscene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tconst isAsset = this._type === 'asset';\n\n\t\tif (this._meshInstances && this._meshInstances.length) {\n\t\t\tthis.addToLayers();\n\t\t} else if (isAsset && this.asset) {\n\t\t\tthis._onRenderAssetAdded();\n\t\t}\n\n\t\tfor (let i = 0; i < this._materialReferences.length; i++) {\n\t\t\tif (this._materialReferences[i].asset) {\n\t\t\t\tthis.system.app.assets.load(this._materialReferences[i].asset);\n\t\t\t}\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tscene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tthis.removeFromLayers();\n\t}\n\n\thide() {\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tthis._meshInstances[i].visible = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tshow() {\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tthis._meshInstances[i].visible = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onRenderAssetAdded() {\n\t\tif (!this._assetReference.asset) return;\n\n\t\tif (this._assetReference.asset.resource) {\n\t\t\tthis._onRenderAssetLoad();\n\t\t} else if (this.enabled && this.entity.enabled) {\n\t\t\tthis.system.app.assets.load(this._assetReference.asset);\n\t\t}\n\t}\n\n\t_onRenderAssetLoad() {\n\t\tthis.destroyMeshInstances();\n\n\t\tif (this._assetReference.asset) {\n\t\t\tconst render = this._assetReference.asset.resource;\n\t\t\trender.off('set:meshes', this._onSetMeshes, this);\n\t\t\trender.on('set:meshes', this._onSetMeshes, this);\n\n\t\t\tif (render.meshes) {\n\t\t\t\tthis._onSetMeshes(render.meshes);\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSetMeshes(meshes) {\n\t\tthis._cloneMeshes(meshes);\n\t}\n\n\t_clearSkinInstances() {\n\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\tconst meshInstance = this._meshInstances[i];\n\t\t\tSkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);\n\t\t\tmeshInstance.skinInstance = null;\n\t\t}\n\t}\n\n\t_cloneSkinInstances() {\n\t\tif (this._meshInstances.length && this._rootBone.entity instanceof GraphNode) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tconst meshInstance = this._meshInstances[i];\n\t\t\t\tconst mesh = meshInstance.mesh;\n\n\t\t\t\tif (mesh.skin && !mesh.skinInstance) {\n\t\t\t\t\tmeshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_cloneMeshes(meshes) {\n\t\tif (meshes && meshes.length) {\n\t\t\tconst meshInstances = [];\n\n\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\tconst mesh = meshes[i];\n\t\t\t\tconst material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;\n\t\t\t\tconst meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);\n\t\t\t\tmeshInstances.push(meshInst);\n\n\t\t\t\tif (mesh.morph) {\n\t\t\t\t\tmeshInst.morphInstance = new MorphInstance(mesh.morph);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.meshInstances = meshInstances;\n\n\t\t\tthis._cloneSkinInstances();\n\t\t}\n\t}\n\n\t_onRenderAssetUnload() {\n\t\tif (this._type === 'asset') {\n\t\t\tthis.destroyMeshInstances();\n\t\t}\n\t}\n\n\t_onRenderAssetRemove() {\n\t\tif (this._assetReference.asset && this._assetReference.asset.resource) {\n\t\t\tthis._assetReference.asset.resource.off('set:meshes', this._onSetMeshes, this);\n\t\t}\n\n\t\tthis._onRenderAssetUnload();\n\t}\n\n\t_onMaterialAdded(index, component, asset) {\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialLoad(index, component, asset);\n\t\t} else {\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateMainMaterial(index, material) {\n\t\tif (index === 0) {\n\t\t\tthis.material = material;\n\t\t}\n\t}\n\n\t_onMaterialLoad(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = asset.resource;\n\t\t}\n\n\t\tthis._updateMainMaterial(index, asset.resource);\n\t}\n\n\t_onMaterialRemove(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = this.system.defaultMaterial;\n\t\t}\n\n\t\tthis._updateMainMaterial(index, this.system.defaultMaterial);\n\t}\n\n\t_onMaterialUnload(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = this.system.defaultMaterial;\n\t\t}\n\n\t\tthis._updateMainMaterial(index, this.system.defaultMaterial);\n\t}\n\n\tresolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {\n\t\tif (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {\n\t\t\tthis.rootBone = duplicatedIdsMap[oldRender.rootBone];\n\t\t}\n\n\t\tthis._clearSkinInstances();\n\t}\n\n}\n\nclass RenderComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.rootBone = null;\n\t}\n\n}\n\nconst _schema$9 = [{\n\tname: 'rootBone',\n\ttype: 'entity'\n}, 'enabled'];\nconst _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId'];\n\nclass RenderComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'render';\n\t\tthis.ComponentType = RenderComponent;\n\t\tthis.DataType = RenderComponentData;\n\t\tthis.schema = _schema$9;\n\t\tthis.defaultMaterial = DefaultMaterial.get(app.graphicsDevice);\n\t\tthis.on('beforeremove', this.onRemove, this);\n\t}\n\n\tinitializeComponentData(component, _data, properties) {\n\t\tif (_data.batchGroupId === null || _data.batchGroupId === undefined) {\n\t\t\t_data.batchGroupId = -1;\n\t\t}\n\n\t\tif (_data.layers && _data.layers.length) {\n\t\t\t_data.layers = _data.layers.slice(0);\n\t\t}\n\n\t\tfor (let i = 0; i < _properties.length; i++) {\n\t\t\tif (_data.hasOwnProperty(_properties[i])) {\n\t\t\t\tcomponent[_properties[i]] = _data[_properties[i]];\n\t\t\t}\n\t\t}\n\n\t\tif (_data.aabbCenter && _data.aabbHalfExtents) {\n\t\t\tcomponent.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));\n\t\t}\n\n\t\tsuper.initializeComponentData(component, _data, _schema$9);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst data = {};\n\n\t\tfor (let i = 0; i < _properties.length; i++) {\n\t\t\tdata[_properties[i]] = entity.render[_properties[i]];\n\t\t}\n\n\t\tdelete data.meshInstances;\n\t\tconst component = this.addComponent(clone, data);\n\t\tconst srcMeshInstances = entity.render.meshInstances;\n\t\tconst meshes = srcMeshInstances.map(mi => mi.mesh);\n\n\t\tcomponent._onSetMeshes(meshes);\n\n\t\tfor (let m = 0; m < srcMeshInstances.length; m++) {\n\t\t\tcomponent.meshInstances[m].material = srcMeshInstances[m].material;\n\t\t}\n\n\t\tif (entity.render.customAabb) {\n\t\t\tcomponent.customAabb = entity.render.customAabb.clone();\n\t\t}\n\t}\n\n\tonRemove(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n}\n\nComponent._buildAccessors(RenderComponent.prototype, _schema$9);\n\nconst SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];\nconst COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];\nconst GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];\nconst ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];\nlet depthLayer;\n\nclass ParticleSystemComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.on(\"set_colorMapAsset\", this.onSetColorMapAsset, this);\n\t\tthis.on(\"set_normalMapAsset\", this.onSetNormalMapAsset, this);\n\t\tthis.on(\"set_meshAsset\", this.onSetMeshAsset, this);\n\t\tthis.on(\"set_mesh\", this.onSetMesh, this);\n\t\tthis.on(\"set_renderAsset\", this.onSetRenderAsset, this);\n\t\tthis.on(\"set_loop\", this.onSetLoop, this);\n\t\tthis.on(\"set_blendType\", this.onSetBlendType, this);\n\t\tthis.on(\"set_depthSoftening\", this.onSetDepthSoftening, this);\n\t\tthis.on(\"set_layers\", this.onSetLayers, this);\n\t\tSIMPLE_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetSimpleProperty, this);\n\t\t});\n\t\tCOMPLEX_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetComplexProperty, this);\n\t\t});\n\t\tGRAPH_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetGraphProperty, this);\n\t\t});\n\t\tthis._requestedDepth = false;\n\t\tthis._drawOrder = 0;\n\t}\n\n\tset drawOrder(drawOrder) {\n\t\tthis._drawOrder = drawOrder;\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.drawOrder = drawOrder;\n\t\t}\n\t}\n\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\n\taddMeshInstanceToLayers() {\n\t\tif (!this.emitter) return;\n\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t\t\tthis.emitter._layer = layer;\n\t\t}\n\t}\n\n\tremoveMeshInstanceFromLayers() {\n\t\tif (!this.emitter) return;\n\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\t}\n\n\tonSetLayers(name, oldValue, newValue) {\n\t\tif (!this.emitter) return;\n\n\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(oldValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\n\t\tif (!this.enabled || !this.entity.enabled) return;\n\n\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addMeshInstanceToLayers();\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tif (!this.emitter) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tif (!this.emitter) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t}\n\n\t_bindColorMapAsset(asset) {\n\t\tasset.on('load', this._onColorMapAssetLoad, this);\n\t\tasset.on('unload', this._onColorMapAssetUnload, this);\n\t\tasset.on('remove', this._onColorMapAssetRemove, this);\n\t\tasset.on('change', this._onColorMapAssetChange, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onColorMapAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindColorMapAsset(asset) {\n\t\tasset.off('load', this._onColorMapAssetLoad, this);\n\t\tasset.off('unload', this._onColorMapAssetUnload, this);\n\t\tasset.off('remove', this._onColorMapAssetRemove, this);\n\t\tasset.off('change', this._onColorMapAssetChange, this);\n\t}\n\n\t_onColorMapAssetLoad(asset) {\n\t\tthis.colorMap = asset.resource;\n\t}\n\n\t_onColorMapAssetUnload(asset) {\n\t\tthis.colorMap = null;\n\t}\n\n\t_onColorMapAssetRemove(asset) {\n\t\tthis._onColorMapAssetUnload(asset);\n\t}\n\n\t_onColorMapAssetChange(asset) {}\n\n\tonSetColorMapAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindColorMapAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.colorMapAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._bindColorMapAsset(asset);\n\t\t\t} else {\n\t\t\t\tassets.once(\"add:\" + newValue, asset => {\n\t\t\t\t\tthis._bindColorMapAsset(asset);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.colorMap = null;\n\t\t}\n\t}\n\n\t_bindNormalMapAsset(asset) {\n\t\tasset.on('load', this._onNormalMapAssetLoad, this);\n\t\tasset.on('unload', this._onNormalMapAssetUnload, this);\n\t\tasset.on('remove', this._onNormalMapAssetRemove, this);\n\t\tasset.on('change', this._onNormalMapAssetChange, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onNormalMapAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindNormalMapAsset(asset) {\n\t\tasset.off('load', this._onNormalMapAssetLoad, this);\n\t\tasset.off('unload', this._onNormalMapAssetUnload, this);\n\t\tasset.off('remove', this._onNormalMapAssetRemove, this);\n\t\tasset.off('change', this._onNormalMapAssetChange, this);\n\t}\n\n\t_onNormalMapAssetLoad(asset) {\n\t\tthis.normalMap = asset.resource;\n\t}\n\n\t_onNormalMapAssetUnload(asset) {\n\t\tthis.normalMap = null;\n\t}\n\n\t_onNormalMapAssetRemove(asset) {\n\t\tthis._onNormalMapAssetUnload(asset);\n\t}\n\n\t_onNormalMapAssetChange(asset) {}\n\n\tonSetNormalMapAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindNormalMapAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.normalMapAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._bindNormalMapAsset(asset);\n\t\t\t} else {\n\t\t\t\tassets.once(\"add:\" + newValue, asset => {\n\t\t\t\t\tthis._bindNormalMapAsset(asset);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.normalMap = null;\n\t\t}\n\t}\n\n\t_bindMeshAsset(asset) {\n\t\tasset.on('load', this._onMeshAssetLoad, this);\n\t\tasset.on('unload', this._onMeshAssetUnload, this);\n\t\tasset.on('remove', this._onMeshAssetRemove, this);\n\t\tasset.on('change', this._onMeshAssetChange, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onMeshAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindMeshAsset(asset) {\n\t\tasset.off('load', this._onMeshAssetLoad, this);\n\t\tasset.off('unload', this._onMeshAssetUnload, this);\n\t\tasset.off('remove', this._onMeshAssetRemove, this);\n\t\tasset.off('change', this._onMeshAssetChange, this);\n\t}\n\n\t_onMeshAssetLoad(asset) {\n\t\tthis._onMeshChanged(asset.resource);\n\t}\n\n\t_onMeshAssetUnload(asset) {\n\t\tthis.mesh = null;\n\t}\n\n\t_onMeshAssetRemove(asset) {\n\t\tthis._onMeshAssetUnload(asset);\n\t}\n\n\t_onMeshAssetChange(asset) {}\n\n\tonSetMeshAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindMeshAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.meshAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._bindMeshAsset(asset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._onMeshChanged(null);\n\t\t}\n\t}\n\n\tonSetMesh(name, oldValue, newValue) {\n\t\tif (!newValue || newValue instanceof Asset || typeof newValue === 'number') {\n\t\t\tthis.meshAsset = newValue;\n\t\t} else {\n\t\t\tthis._onMeshChanged(newValue);\n\t\t}\n\t}\n\n\t_onMeshChanged(mesh) {\n\t\tif (mesh && !(mesh instanceof Mesh)) {\n\t\t\tif (mesh.meshInstances[0]) {\n\t\t\t\tmesh = mesh.meshInstances[0].mesh;\n\t\t\t} else {\n\t\t\t\tmesh = null;\n\t\t\t}\n\t\t}\n\n\t\tthis.data.mesh = mesh;\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.mesh = mesh;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t}\n\t}\n\n\tonSetRenderAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindRenderAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.renderAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._bindRenderAsset(asset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._onRenderChanged(null);\n\t\t}\n\t}\n\n\t_bindRenderAsset(asset) {\n\t\tasset.on('load', this._onRenderAssetLoad, this);\n\t\tasset.on('unload', this._onRenderAssetUnload, this);\n\t\tasset.on('remove', this._onRenderAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onRenderAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindRenderAsset(asset) {\n\t\tasset.off('load', this._onRenderAssetLoad, this);\n\t\tasset.off('unload', this._onRenderAssetUnload, this);\n\t\tasset.off('remove', this._onRenderAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tasset.resource.off('set:meshes', this._onRenderSetMeshes, this);\n\t\t}\n\t}\n\n\t_onRenderAssetLoad(asset) {\n\t\tthis._onRenderChanged(asset.resource);\n\t}\n\n\t_onRenderAssetUnload(asset) {\n\t\tthis._onRenderChanged(null);\n\t}\n\n\t_onRenderAssetRemove(asset) {\n\t\tthis._onRenderAssetUnload(asset);\n\t}\n\n\t_onRenderChanged(render) {\n\t\tif (!render) {\n\t\t\tthis._onMeshChanged(null);\n\n\t\t\treturn;\n\t\t}\n\n\t\trender.off('set:meshes', this._onRenderSetMeshes, this);\n\t\trender.on('set:meshes', this._onRenderSetMeshes, this);\n\n\t\tif (render.meshes) {\n\t\t\tthis._onRenderSetMeshes(render.meshes);\n\t\t}\n\t}\n\n\t_onRenderSetMeshes(meshes) {\n\t\tthis._onMeshChanged(meshes && meshes[0]);\n\t}\n\n\tonSetLoop(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetTime();\n\t\t}\n\t}\n\n\tonSetBlendType(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.material.blendType = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t}\n\t}\n\n\t_requestDepth() {\n\t\tif (this._requestedDepth) return;\n\t\tif (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);\n\n\t\tif (depthLayer) {\n\t\t\tdepthLayer.incrementCounter();\n\t\t\tthis._requestedDepth = true;\n\t\t}\n\t}\n\n\t_releaseDepth() {\n\t\tif (!this._requestedDepth) return;\n\n\t\tif (depthLayer) {\n\t\t\tdepthLayer.decrementCounter();\n\t\t\tthis._requestedDepth = false;\n\t\t}\n\t}\n\n\tonSetDepthSoftening(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (newValue) {\n\t\t\t\tif (this.enabled && this.entity.enabled) this._requestDepth();\n\t\t\t\tif (this.emitter) this.emitter[name] = newValue;\n\t\t\t} else {\n\t\t\t\tif (this.enabled && this.entity.enabled) this._releaseDepth();\n\t\t\t\tif (this.emitter) this.emitter[name] = newValue;\n\t\t\t}\n\n\t\t\tif (this.emitter) {\n\t\t\t\tthis.reset();\n\t\t\t\tthis.emitter.resetMaterial();\n\t\t\t\tthis.rebuild();\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetSimpleProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t}\n\t}\n\n\tonSetComplexProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t\tthis.reset();\n\t\t}\n\t}\n\n\tonSetGraphProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.rebuildGraphs();\n\t\t\tthis.emitter.resetMaterial();\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tconst data = this.data;\n\n\t\tfor (let i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {\n\t\t\tlet asset = data[ASSET_PROPERTIES[i]];\n\n\t\t\tif (asset) {\n\t\t\t\tif (!(asset instanceof Asset)) {\n\t\t\t\t\tconst id = parseInt(asset, 10);\n\n\t\t\t\t\tif (id >= 0) {\n\t\t\t\t\t\tasset = this.system.app.assets.get(asset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.emitter) {\n\t\t\tlet mesh = data.mesh;\n\t\t\tif (!(mesh instanceof Mesh)) mesh = null;\n\t\t\tthis.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {\n\t\t\t\tnumParticles: data.numParticles,\n\t\t\t\temitterExtents: data.emitterExtents,\n\t\t\t\temitterExtentsInner: data.emitterExtentsInner,\n\t\t\t\temitterRadius: data.emitterRadius,\n\t\t\t\temitterRadiusInner: data.emitterRadiusInner,\n\t\t\t\temitterShape: data.emitterShape,\n\t\t\t\tinitialVelocity: data.initialVelocity,\n\t\t\t\twrap: data.wrap,\n\t\t\t\tlocalSpace: data.localSpace,\n\t\t\t\tscreenSpace: data.screenSpace,\n\t\t\t\twrapBounds: data.wrapBounds,\n\t\t\t\tlifetime: data.lifetime,\n\t\t\t\trate: data.rate,\n\t\t\t\trate2: data.rate2,\n\t\t\t\torientation: data.orientation,\n\t\t\t\tparticleNormal: data.particleNormal,\n\t\t\t\tanimTilesX: data.animTilesX,\n\t\t\t\tanimTilesY: data.animTilesY,\n\t\t\t\tanimStartFrame: data.animStartFrame,\n\t\t\t\tanimNumFrames: data.animNumFrames,\n\t\t\t\tanimNumAnimations: data.animNumAnimations,\n\t\t\t\tanimIndex: data.animIndex,\n\t\t\t\trandomizeAnimIndex: data.randomizeAnimIndex,\n\t\t\t\tanimSpeed: data.animSpeed,\n\t\t\t\tanimLoop: data.animLoop,\n\t\t\t\tstartAngle: data.startAngle,\n\t\t\t\tstartAngle2: data.startAngle2,\n\t\t\t\tscaleGraph: data.scaleGraph,\n\t\t\t\tscaleGraph2: data.scaleGraph2,\n\t\t\t\tcolorGraph: data.colorGraph,\n\t\t\t\tcolorGraph2: data.colorGraph2,\n\t\t\t\talphaGraph: data.alphaGraph,\n\t\t\t\talphaGraph2: data.alphaGraph2,\n\t\t\t\tlocalVelocityGraph: data.localVelocityGraph,\n\t\t\t\tlocalVelocityGraph2: data.localVelocityGraph2,\n\t\t\t\tvelocityGraph: data.velocityGraph,\n\t\t\t\tvelocityGraph2: data.velocityGraph2,\n\t\t\t\trotationSpeedGraph: data.rotationSpeedGraph,\n\t\t\t\trotationSpeedGraph2: data.rotationSpeedGraph2,\n\t\t\t\tradialSpeedGraph: data.radialSpeedGraph,\n\t\t\t\tradialSpeedGraph2: data.radialSpeedGraph2,\n\t\t\t\tcolorMap: data.colorMap,\n\t\t\t\tnormalMap: data.normalMap,\n\t\t\t\tloop: data.loop,\n\t\t\t\tpreWarm: data.preWarm,\n\t\t\t\tsort: data.sort,\n\t\t\t\tstretch: data.stretch,\n\t\t\t\talignToMotion: data.alignToMotion,\n\t\t\t\tlighting: data.lighting,\n\t\t\t\thalfLambert: data.halfLambert,\n\t\t\t\tintensity: data.intensity,\n\t\t\t\tdepthSoftening: data.depthSoftening,\n\t\t\t\tscene: this.system.app.scene,\n\t\t\t\tmesh: mesh,\n\t\t\t\tdepthWrite: data.depthWrite,\n\t\t\t\tnoFog: data.noFog,\n\t\t\t\tnode: this.entity,\n\t\t\t\tblendType: data.blendType\n\t\t\t});\n\t\t\tthis.emitter.meshInstance.node = this.entity;\n\t\t\tthis.emitter.drawOrder = this.drawOrder;\n\n\t\t\tif (!data.autoPlay) {\n\t\t\t\tthis.pause();\n\t\t\t\tthis.emitter.meshInstance.visible = false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.emitter.colorMap) {\n\t\t\tthis.addMeshInstanceToLayers();\n\t\t}\n\n\t\tthis.system.app.scene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled && data.depthSoftening) {\n\t\t\tthis._requestDepth();\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tthis.system.app.scene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this.emitter) {\n\t\t\tthis.removeMeshInstanceFromLayers();\n\t\t\tif (this.data.depthSoftening) this._releaseDepth();\n\t\t\tthis.emitter.camera = null;\n\t\t}\n\t}\n\n\tonBeforeRemove() {\n\t\tif (this.enabled) {\n\t\t\tthis.enabled = false;\n\t\t}\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.destroy();\n\t\t\tthis.emitter = null;\n\t\t}\n\n\t\tfor (let i = 0; i < ASSET_PROPERTIES.length; i++) {\n\t\t\tconst prop = ASSET_PROPERTIES[i];\n\n\t\t\tif (this.data[prop]) {\n\t\t\t\tthis[prop] = null;\n\t\t\t}\n\t\t}\n\n\t\tthis.off();\n\t}\n\n\treset() {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.reset();\n\t\t}\n\t}\n\n\tstop() {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.loop = false;\n\t\t\tthis.emitter.resetTime();\n\t\t\tthis.emitter.addTime(0, true);\n\t\t}\n\t}\n\n\tpause() {\n\t\tthis.data.paused = true;\n\t}\n\n\tunpause() {\n\t\tthis.data.paused = false;\n\t}\n\n\tplay() {\n\t\tthis.data.paused = false;\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.meshInstance.visible = true;\n\t\t\tthis.emitter.loop = this.data.loop;\n\t\t\tthis.emitter.resetTime();\n\t\t}\n\t}\n\n\tisPlaying() {\n\t\tif (this.data.paused) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.emitter && this.emitter.loop) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn Date.now() <= this.emitter.endTime;\n\t}\n\n\trebuild() {\n\t\tconst enabled = this.enabled;\n\t\tthis.enabled = false;\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.rebuild();\n\t\t\tthis.emitter.meshInstance.node = this.entity;\n\t\t}\n\n\t\tthis.enabled = enabled;\n\t}\n\n}\n\nclass ParticleSystemComponentData {\n\tconstructor() {\n\t\tthis.numParticles = 1;\n\t\tthis.rate = 1;\n\t\tthis.rate2 = null;\n\t\tthis.startAngle = 0;\n\t\tthis.startAngle2 = null;\n\t\tthis.lifetime = 50;\n\t\tthis.emitterExtents = new Vec3();\n\t\tthis.emitterExtentsInner = new Vec3();\n\t\tthis.emitterRadius = 0;\n\t\tthis.emitterRadiusInner = 0;\n\t\tthis.emitterShape = EMITTERSHAPE_BOX;\n\t\tthis.initialVelocity = 0;\n\t\tthis.wrapBounds = new Vec3();\n\t\tthis.localSpace = false;\n\t\tthis.screenSpace = false;\n\t\tthis.colorMap = null;\n\t\tthis.colorMapAsset = null;\n\t\tthis.normalMap = null;\n\t\tthis.normalMapAsset = null;\n\t\tthis.loop = true;\n\t\tthis.preWarm = false;\n\t\tthis.sort = 0;\n\t\tthis.mode = PARTICLEMODE_GPU;\n\t\tthis.scene = null;\n\t\tthis.lighting = false;\n\t\tthis.halfLambert = false;\n\t\tthis.intensity = 1;\n\t\tthis.stretch = 0.0;\n\t\tthis.alignToMotion = false;\n\t\tthis.depthSoftening = 0;\n\t\tthis.meshAsset = null;\n\t\tthis.mesh = null;\n\t\tthis.depthWrite = false;\n\t\tthis.noFog = false;\n\t\tthis.orientation = PARTICLEORIENTATION_SCREEN;\n\t\tthis.particleNormal = new Vec3(0, 1, 0);\n\t\tthis.animTilesX = 1;\n\t\tthis.animTilesY = 1;\n\t\tthis.animStartFrame = 0;\n\t\tthis.animNumFrames = 1;\n\t\tthis.animNumAnimations = 1;\n\t\tthis.animIndex = 0;\n\t\tthis.randomizeAnimIndex = false;\n\t\tthis.animSpeed = 1;\n\t\tthis.animLoop = true;\n\t\tthis.scaleGraph = null;\n\t\tthis.scaleGraph2 = null;\n\t\tthis.colorGraph = null;\n\t\tthis.colorGraph2 = null;\n\t\tthis.alphaGraph = null;\n\t\tthis.alphaGraph2 = null;\n\t\tthis.localVelocityGraph = null;\n\t\tthis.localVelocityGraph2 = null;\n\t\tthis.velocityGraph = null;\n\t\tthis.velocityGraph2 = null;\n\t\tthis.rotationSpeedGraph = null;\n\t\tthis.rotationSpeedGraph2 = null;\n\t\tthis.radialSpeedGraph = null;\n\t\tthis.radialSpeedGraph2 = null;\n\t\tthis.blendType = BLEND_NORMAL;\n\t\tthis.enabled = true;\n\t\tthis.paused = false;\n\t\tthis.autoPlay = true;\n\t\tthis.layers = [LAYERID_WORLD];\n\t}\n\n}\n\nconst _schema$8 = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];\n\nclass ParticleSystemComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'particlesystem';\n\t\tthis.ComponentType = ParticleSystemComponent;\n\t\tthis.DataType = ParticleSystemComponentData;\n\t\tthis.schema = _schema$8;\n\t\tthis.propertyTypes = {\n\t\t\temitterExtents: 'vec3',\n\t\t\temitterExtentsInner: 'vec3',\n\t\t\tparticleNormal: 'vec3',\n\t\t\twrapBounds: 'vec3',\n\t\t\tlocalVelocityGraph: 'curveset',\n\t\t\tlocalVelocityGraph2: 'curveset',\n\t\t\tvelocityGraph: 'curveset',\n\t\t\tvelocityGraph2: 'curveset',\n\t\t\tcolorGraph: 'curveset',\n\t\t\tcolorGraph2: 'curveset',\n\t\t\talphaGraph: 'curve',\n\t\t\talphaGraph2: 'curve',\n\t\t\trotationSpeedGraph: 'curve',\n\t\t\trotationSpeedGraph2: 'curve',\n\t\t\tradialSpeedGraph: 'curve',\n\t\t\tradialSpeedGraph2: 'curve',\n\t\t\tscaleGraph: 'curve',\n\t\t\tscaleGraph2: 'curve'\n\t\t};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, _data, properties) {\n\t\tconst data = {};\n\t\tproperties = [];\n\t\tconst types = this.propertyTypes;\n\n\t\tif (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {\n\t\t\t_data.meshAsset = _data.mesh;\n\t\t\tdelete _data.mesh;\n\t\t}\n\n\t\tfor (const prop in _data) {\n\t\t\tif (_data.hasOwnProperty(prop)) {\n\t\t\t\tproperties.push(prop);\n\t\t\t\tdata[prop] = _data[prop];\n\t\t\t}\n\n\t\t\tif (types[prop] === 'vec3') {\n\t\t\t\tif (Array.isArray(data[prop])) {\n\t\t\t\t\tdata[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);\n\t\t\t\t}\n\t\t\t} else if (types[prop] === 'curve') {\n\t\t\t\tif (!(data[prop] instanceof Curve)) {\n\t\t\t\t\tconst t = data[prop].type;\n\t\t\t\t\tdata[prop] = new Curve(data[prop].keys);\n\t\t\t\t\tdata[prop].type = t;\n\t\t\t\t}\n\t\t\t} else if (types[prop] === 'curveset') {\n\t\t\t\tif (!(data[prop] instanceof CurveSet)) {\n\t\t\t\t\tconst t = data[prop].type;\n\t\t\t\t\tdata[prop] = new CurveSet(data[prop].keys);\n\t\t\t\t\tdata[prop].type = t;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\t\tdata.layers = data.layers.slice(0);\n\t\t\t}\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.particlesystem.data;\n\t\tconst schema = this.schema;\n\t\tconst data = {};\n\n\t\tfor (let i = 0, len = schema.length; i < len; i++) {\n\t\t\tconst prop = schema[i];\n\t\t\tlet sourceProp = source[prop];\n\n\t\t\tif (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {\n\t\t\t\tsourceProp = sourceProp.clone();\n\t\t\t\tdata[prop] = sourceProp;\n\t\t\t} else if (prop === \"layers\") {\n\t\t\t\tdata.layers = source.layers.slice(0);\n\t\t\t} else {\n\t\t\t\tif (sourceProp !== null && sourceProp !== undefined) {\n\t\t\t\t\tdata[prop] = sourceProp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\t\tlet numSteps;\n\t\tconst stats = this.app.stats.particles;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tconst entity = component.entity;\n\t\t\t\tconst data = component.data;\n\n\t\t\t\tif (data.enabled && entity.enabled) {\n\t\t\t\t\tconst emitter = entity.particlesystem.emitter;\n\t\t\t\t\tif (!emitter.meshInstance.visible) continue;\n\n\t\t\t\t\tif (emitter.lighting) {\n\t\t\t\t\t\tconst layers = data.layers;\n\t\t\t\t\t\tlet lightCube;\n\n\t\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\t\tconst layer = this.app.scene.layers.getLayerById(layers[i]);\n\t\t\t\t\t\t\tif (!layer) continue;\n\n\t\t\t\t\t\t\tif (!layer._lightCube) {\n\t\t\t\t\t\t\t\tlayer._lightCube = new Float32Array(6 * 3);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlightCube = layer._lightCube;\n\n\t\t\t\t\t\t\tfor (let j = 0; j < 6; j++) {\n\t\t\t\t\t\t\t\tlightCube[j * 3] = this.app.scene.ambientLight.r;\n\t\t\t\t\t\t\t\tlightCube[j * 3 + 1] = this.app.scene.ambientLight.g;\n\t\t\t\t\t\t\t\tlightCube[j * 3 + 2] = this.app.scene.ambientLight.b;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst dirs = layer._splitLights[LIGHTTYPE_DIRECTIONAL];\n\n\t\t\t\t\t\t\tfor (let j = 0; j < dirs.length; j++) {\n\t\t\t\t\t\t\t\tfor (let c = 0; c < 6; c++) {\n\t\t\t\t\t\t\t\t\tconst weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;\n\n\t\t\t\t\t\t\t\t\tlightCube[c * 3] += dirs[j]._color.r * weight;\n\t\t\t\t\t\t\t\t\tlightCube[c * 3 + 1] += dirs[j]._color.g * weight;\n\t\t\t\t\t\t\t\t\tlightCube[c * 3 + 2] += dirs[j]._color.b * weight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\temitter.constantLightCube.setValue(lightCube);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!data.paused) {\n\t\t\t\t\t\temitter.simTime += dt;\n\n\t\t\t\t\t\tif (emitter.simTime > emitter.fixedTimeStep) {\n\t\t\t\t\t\t\tnumSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);\n\t\t\t\t\t\t\temitter.simTime -= numSteps * emitter.fixedTimeStep;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (numSteps) {\n\t\t\t\t\t\t\tnumSteps = Math.min(numSteps, emitter.maxSubSteps);\n\n\t\t\t\t\t\t\tfor (let i = 0; i < numSteps; i++) {\n\t\t\t\t\t\t\t\temitter.addTime(emitter.fixedTimeStep, false);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstats._updatesPerFrame += numSteps;\n\t\t\t\t\t\t\tstats._frameTime += emitter._addTimeTime;\n\t\t\t\t\t\t\temitter._addTimeTime = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\temitter.finishFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(ParticleSystemComponent.prototype, _schema$8);\n\nclass ObjectPool {\n\tconstructor(constructorFunc, size) {\n\t\tthis._constructor = constructorFunc;\n\t\tthis._pool = [];\n\t\tthis._count = 0;\n\n\t\tthis._resize(size);\n\t}\n\n\t_resize(size) {\n\t\tif (size > this._pool.length) {\n\t\t\tfor (let i = this._pool.length; i < size; i++) {\n\t\t\t\tthis._pool[i] = new this._constructor();\n\t\t\t}\n\t\t}\n\t}\n\n\tallocate() {\n\t\tif (this._count >= this._pool.length) {\n\t\t\tthis._resize(this._pool.length * 2);\n\t\t}\n\n\t\treturn this._pool[this._count++];\n\t}\n\n\tfreeAll() {\n\t\tthis._count = 0;\n\t}\n\n}\n\nlet ammoTransform;\nlet ammoVec1, ammoVec2, ammoQuat, ammoOrigin;\n\nclass RigidBodyComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._angularDamping = 0;\n\t\tthis._angularFactor = new Vec3(1, 1, 1);\n\t\tthis._angularVelocity = new Vec3();\n\t\tthis._body = null;\n\t\tthis._friction = 0.5;\n\t\tthis._group = BODYGROUP_STATIC;\n\t\tthis._linearDamping = 0;\n\t\tthis._linearFactor = new Vec3(1, 1, 1);\n\t\tthis._linearVelocity = new Vec3();\n\t\tthis._mask = BODYMASK_NOT_STATIC;\n\t\tthis._mass = 1;\n\t\tthis._restitution = 0;\n\t\tthis._rollingFriction = 0;\n\t\tthis._simulationEnabled = false;\n\t\tthis._type = BODYTYPE_STATIC;\n\t}\n\n\tstatic onLibraryLoaded() {\n\t\tif (typeof Ammo !== 'undefined' && !ammoTransform) {\n\t\t\tammoTransform = new Ammo.btTransform();\n\t\t\tammoVec1 = new Ammo.btVector3();\n\t\t\tammoVec2 = new Ammo.btVector3();\n\t\t\tammoQuat = new Ammo.btQuaternion();\n\t\t\tammoOrigin = new Ammo.btVector3(0, 0, 0);\n\t\t}\n\t}\n\n\tset angularDamping(damping) {\n\t\tif (this._angularDamping !== damping) {\n\t\t\tthis._angularDamping = damping;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setDamping(this._linearDamping, damping);\n\t\t\t}\n\t\t}\n\t}\n\n\tget angularDamping() {\n\t\treturn this._angularDamping;\n\t}\n\n\tset angularFactor(factor) {\n\t\tif (!this._angularFactor.equals(factor)) {\n\t\t\tthis._angularFactor.copy(factor);\n\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tammoVec1.setValue(factor.x, factor.y, factor.z);\n\n\t\t\t\tthis._body.setAngularFactor(ammoVec1);\n\t\t\t}\n\t\t}\n\t}\n\n\tget angularFactor() {\n\t\treturn this._angularFactor;\n\t}\n\n\tset angularVelocity(velocity) {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tthis._body.activate();\n\n\t\t\tammoVec1.setValue(velocity.x, velocity.y, velocity.z);\n\n\t\t\tthis._body.setAngularVelocity(ammoVec1);\n\n\t\t\tthis._angularVelocity.copy(velocity);\n\t\t}\n\t}\n\n\tget angularVelocity() {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tconst velocity = this._body.getAngularVelocity();\n\n\t\t\tthis._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());\n\t\t}\n\n\t\treturn this._angularVelocity;\n\t}\n\n\tset body(body) {\n\t\tif (this._body !== body) {\n\t\t\tthis._body = body;\n\n\t\t\tif (body && this._simulationEnabled) {\n\t\t\t\tbody.activate();\n\t\t\t}\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this._body;\n\t}\n\n\tset friction(friction) {\n\t\tif (this._friction !== friction) {\n\t\t\tthis._friction = friction;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setFriction(friction);\n\t\t\t}\n\t\t}\n\t}\n\n\tget friction() {\n\t\treturn this._friction;\n\t}\n\n\tset group(group) {\n\t\tif (this._group !== group) {\n\t\t\tthis._group = group;\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.disableSimulation();\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\n\tget group() {\n\t\treturn this._group;\n\t}\n\n\tset linearDamping(damping) {\n\t\tif (this._linearDamping !== damping) {\n\t\t\tthis._linearDamping = damping;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setDamping(damping, this._angularDamping);\n\t\t\t}\n\t\t}\n\t}\n\n\tget linearDamping() {\n\t\treturn this._linearDamping;\n\t}\n\n\tset linearFactor(factor) {\n\t\tif (!this._linearFactor.equals(factor)) {\n\t\t\tthis._linearFactor.copy(factor);\n\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tammoVec1.setValue(factor.x, factor.y, factor.z);\n\n\t\t\t\tthis._body.setLinearFactor(ammoVec1);\n\t\t\t}\n\t\t}\n\t}\n\n\tget linearFactor() {\n\t\treturn this._linearFactor;\n\t}\n\n\tset linearVelocity(velocity) {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tthis._body.activate();\n\n\t\t\tammoVec1.setValue(velocity.x, velocity.y, velocity.z);\n\n\t\t\tthis._body.setLinearVelocity(ammoVec1);\n\n\t\t\tthis._linearVelocity.copy(velocity);\n\t\t}\n\t}\n\n\tget linearVelocity() {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tconst velocity = this._body.getLinearVelocity();\n\n\t\t\tthis._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());\n\t\t}\n\n\t\treturn this._linearVelocity;\n\t}\n\n\tset mask(mask) {\n\t\tif (this._mask !== mask) {\n\t\t\tthis._mask = mask;\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.disableSimulation();\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\n\tset mass(mass) {\n\t\tif (this._mass !== mass) {\n\t\t\tthis._mass = mass;\n\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tconst enabled = this.enabled && this.entity.enabled;\n\n\t\t\t\tif (enabled) {\n\t\t\t\t\tthis.disableSimulation();\n\t\t\t\t}\n\n\t\t\t\tthis._body.getCollisionShape().calculateLocalInertia(mass, ammoVec1);\n\n\t\t\t\tthis._body.setMassProps(mass, ammoVec1);\n\n\t\t\t\tthis._body.updateInertiaTensor();\n\n\t\t\t\tif (enabled) {\n\t\t\t\t\tthis.enableSimulation();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget mass() {\n\t\treturn this._mass;\n\t}\n\n\tset restitution(restitution) {\n\t\tif (this._restitution !== restitution) {\n\t\t\tthis._restitution = restitution;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setRestitution(restitution);\n\t\t\t}\n\t\t}\n\t}\n\n\tget restitution() {\n\t\treturn this._restitution;\n\t}\n\n\tset rollingFriction(friction) {\n\t\tif (this._rollingFriction !== friction) {\n\t\t\tthis._rollingFriction = friction;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setRollingFriction(friction);\n\t\t\t}\n\t\t}\n\t}\n\n\tget rollingFriction() {\n\t\treturn this._rollingFriction;\n\t}\n\n\tset type(type) {\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\tthis.disableSimulation();\n\n\t\t\tswitch (type) {\n\t\t\t\tcase BODYTYPE_DYNAMIC:\n\t\t\t\t\tthis._group = BODYGROUP_DYNAMIC;\n\t\t\t\t\tthis._mask = BODYMASK_ALL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BODYTYPE_KINEMATIC:\n\t\t\t\t\tthis._group = BODYGROUP_KINEMATIC;\n\t\t\t\t\tthis._mask = BODYMASK_ALL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BODYTYPE_STATIC:\n\t\t\t\tdefault:\n\t\t\t\t\tthis._group = BODYGROUP_STATIC;\n\t\t\t\t\tthis._mask = BODYMASK_NOT_STATIC;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.createBody();\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tcreateBody() {\n\t\tconst entity = this.entity;\n\t\tlet shape;\n\n\t\tif (entity.collision) {\n\t\t\tshape = entity.collision.shape;\n\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t\tdelete entity.trigger;\n\t\t\t}\n\t\t}\n\n\t\tif (shape) {\n\t\t\tif (this._body) this.system.onRemove(entity, this);\n\t\t\tconst mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;\n\n\t\t\tthis._getEntityTransform(ammoTransform);\n\n\t\t\tconst body = this.system.createBody(mass, shape, ammoTransform);\n\t\t\tbody.setRestitution(this._restitution);\n\t\t\tbody.setFriction(this._friction);\n\t\t\tbody.setRollingFriction(this._rollingFriction);\n\t\t\tbody.setDamping(this._linearDamping, this._angularDamping);\n\n\t\t\tif (this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tconst linearFactor = this._linearFactor;\n\t\t\t\tammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);\n\t\t\t\tbody.setLinearFactor(ammoVec1);\n\t\t\t\tconst angularFactor = this._angularFactor;\n\t\t\t\tammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);\n\t\t\t\tbody.setAngularFactor(ammoVec1);\n\t\t\t} else if (this._type === BODYTYPE_KINEMATIC) {\n\t\t\t\tbody.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);\n\t\t\t\tbody.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);\n\t\t\t}\n\n\t\t\tbody.entity = entity;\n\t\t\tthis.body = body;\n\n\t\t\tif (this.enabled && entity.enabled) {\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\n\tisActive() {\n\t\treturn this._body ? this._body.isActive() : false;\n\t}\n\n\tactivate() {\n\t\tif (this._body) {\n\t\t\tthis._body.activate();\n\t\t}\n\t}\n\n\tenableSimulation() {\n\t\tconst entity = this.entity;\n\n\t\tif (entity.collision && entity.collision.enabled && !this._simulationEnabled) {\n\t\t\tconst body = this._body;\n\n\t\t\tif (body) {\n\t\t\t\tthis.system.addBody(body, this._group, this._mask);\n\n\t\t\t\tswitch (this._type) {\n\t\t\t\t\tcase BODYTYPE_DYNAMIC:\n\t\t\t\t\t\tthis.system._dynamic.push(this);\n\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\t\t\t\t\tthis.syncEntityToBody();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase BODYTYPE_KINEMATIC:\n\t\t\t\t\t\tthis.system._kinematic.push(this);\n\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase BODYTYPE_STATIC:\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\t\t\t\t\tthis.syncEntityToBody();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entity.collision.type === 'compound') {\n\t\t\t\t\tthis.system._compounds.push(entity.collision);\n\t\t\t\t}\n\n\t\t\t\tbody.activate();\n\t\t\t\tthis._simulationEnabled = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdisableSimulation() {\n\t\tconst body = this._body;\n\n\t\tif (body && this._simulationEnabled) {\n\t\t\tconst system = this.system;\n\n\t\t\tlet idx = system._compounds.indexOf(this.entity.collision);\n\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._compounds.splice(idx, 1);\n\t\t\t}\n\n\t\t\tidx = system._dynamic.indexOf(this);\n\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._dynamic.splice(idx, 1);\n\t\t\t}\n\n\t\t\tidx = system._kinematic.indexOf(this);\n\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._kinematic.splice(idx, 1);\n\t\t\t}\n\n\t\t\tsystem.removeBody(body);\n\t\t\tbody.forceActivationState(BODYSTATE_DISABLE_SIMULATION);\n\t\t\tthis._simulationEnabled = false;\n\t\t}\n\t}\n\n\tapplyForce() {\n\t\tlet x, y, z;\n\t\tlet px, py, pz;\n\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tpx = arguments[1].x;\n\t\t\t\tpy = arguments[1].y;\n\t\t\t\tpz = arguments[1].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tpx = arguments[3];\n\t\t\t\tpy = arguments[4];\n\t\t\t\tpz = arguments[5];\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tammoVec1.setValue(x, y, z);\n\n\t\t\tif (px !== undefined) {\n\t\t\t\tammoVec2.setValue(px, py, pz);\n\t\t\t\tbody.applyForce(ammoVec1, ammoVec2);\n\t\t\t} else {\n\t\t\t\tbody.applyForce(ammoVec1, ammoOrigin);\n\t\t\t}\n\t\t}\n\t}\n\n\tapplyTorque() {\n\t\tlet x, y, z;\n\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tammoVec1.setValue(x, y, z);\n\t\t\tbody.applyTorque(ammoVec1);\n\t\t}\n\t}\n\n\tapplyImpulse() {\n\t\tlet x, y, z;\n\t\tlet px, py, pz;\n\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tpx = arguments[1].x;\n\t\t\t\tpy = arguments[1].y;\n\t\t\t\tpz = arguments[1].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tpx = arguments[3];\n\t\t\t\tpy = arguments[4];\n\t\t\t\tpz = arguments[5];\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tammoVec1.setValue(x, y, z);\n\n\t\t\tif (px !== undefined) {\n\t\t\t\tammoVec2.setValue(px, py, pz);\n\t\t\t\tbody.applyImpulse(ammoVec1, ammoVec2);\n\t\t\t} else {\n\t\t\t\tbody.applyImpulse(ammoVec1, ammoOrigin);\n\t\t\t}\n\t\t}\n\t}\n\n\tapplyTorqueImpulse() {\n\t\tlet x, y, z;\n\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tammoVec1.setValue(x, y, z);\n\t\t\tbody.applyTorqueImpulse(ammoVec1);\n\t\t}\n\t}\n\n\tisStatic() {\n\t\treturn this._type === BODYTYPE_STATIC;\n\t}\n\n\tisStaticOrKinematic() {\n\t\treturn this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;\n\t}\n\n\tisKinematic() {\n\t\treturn this._type === BODYTYPE_KINEMATIC;\n\t}\n\n\t_getEntityTransform(transform) {\n\t\tconst entity = this.entity;\n\t\tconst pos = entity.getPosition();\n\t\tconst rot = entity.getRotation();\n\t\tammoVec1.setValue(pos.x, pos.y, pos.z);\n\t\tammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\ttransform.setOrigin(ammoVec1);\n\t\ttransform.setRotation(ammoQuat);\n\t}\n\n\tsyncEntityToBody() {\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tthis._getEntityTransform(ammoTransform);\n\n\t\t\tbody.setWorldTransform(ammoTransform);\n\n\t\t\tif (this._type === BODYTYPE_KINEMATIC) {\n\t\t\t\tconst motionState = body.getMotionState();\n\n\t\t\t\tif (motionState) {\n\t\t\t\t\tmotionState.setWorldTransform(ammoTransform);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbody.activate();\n\t\t}\n\t}\n\n\t_updateDynamic() {\n\t\tconst body = this._body;\n\n\t\tif (body.isActive()) {\n\t\t\tconst motionState = body.getMotionState();\n\n\t\t\tif (motionState) {\n\t\t\t\tmotionState.getWorldTransform(ammoTransform);\n\t\t\t\tconst p = ammoTransform.getOrigin();\n\t\t\t\tconst q = ammoTransform.getRotation();\n\t\t\t\tthis.entity.setPosition(p.x(), p.y(), p.z());\n\t\t\t\tthis.entity.setRotation(q.x(), q.y(), q.z(), q.w());\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateKinematic() {\n\t\tconst motionState = this._body.getMotionState();\n\n\t\tif (motionState) {\n\t\t\tthis._getEntityTransform(ammoTransform);\n\n\t\t\tmotionState.setWorldTransform(ammoTransform);\n\t\t}\n\t}\n\n\tteleport() {\n\t\tif (arguments.length < 3) {\n\t\t\tif (arguments[0]) {\n\t\t\t\tthis.entity.setPosition(arguments[0]);\n\t\t\t}\n\n\t\t\tif (arguments[1]) {\n\t\t\t\tif (arguments[1] instanceof Quat) {\n\t\t\t\t\tthis.entity.setRotation(arguments[1]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.entity.setEulerAngles(arguments[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (arguments.length === 6) {\n\t\t\t\tthis.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);\n\t\t\t}\n\n\t\t\tthis.entity.setPosition(arguments[0], arguments[1], arguments[2]);\n\t\t}\n\n\t\tthis.syncEntityToBody();\n\t}\n\n\tonEnable() {\n\t\tif (!this._body) {\n\t\t\tthis.createBody();\n\t\t}\n\n\t\tthis.enableSimulation();\n\t}\n\n\tonDisable() {\n\t\tthis.disableSimulation();\n\t}\n\n}\n\nclass RigidBodyComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nlet ammoRayStart, ammoRayEnd;\n\nclass RaycastResult {\n\tconstructor(entity, point, normal) {\n\t\tthis.entity = entity;\n\t\tthis.point = point;\n\t\tthis.normal = normal;\n\t}\n\n}\n\nclass SingleContactResult {\n\tconstructor(a, b, contactPoint) {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.a = null;\n\t\t\tthis.b = null;\n\t\t\tthis.impulse = 0;\n\t\t\tthis.localPointA = new Vec3();\n\t\t\tthis.localPointB = new Vec3();\n\t\t\tthis.pointA = new Vec3();\n\t\t\tthis.pointB = new Vec3();\n\t\t\tthis.normal = new Vec3();\n\t\t} else {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.impulse = contactPoint.impulse;\n\t\t\tthis.localPointA = contactPoint.localPoint;\n\t\t\tthis.localPointB = contactPoint.localPointOther;\n\t\t\tthis.pointA = contactPoint.point;\n\t\t\tthis.pointB = contactPoint.pointOther;\n\t\t\tthis.normal = contactPoint.normal;\n\t\t}\n\t}\n\n}\n\nclass ContactPoint {\n\tconstructor(localPoint = new Vec3(), localPointOther = new Vec3(), point = new Vec3(), pointOther = new Vec3(), normal = new Vec3(), impulse = 0) {\n\t\tthis.localPoint = localPoint;\n\t\tthis.localPointOther = localPointOther;\n\t\tthis.point = point;\n\t\tthis.pointOther = pointOther;\n\t\tthis.normal = normal;\n\t\tthis.impulse = impulse;\n\t}\n\n}\n\nclass ContactResult {\n\tconstructor(other, contacts) {\n\t\tthis.other = other;\n\t\tthis.contacts = contacts;\n\t}\n\n}\n\nconst _schema$7 = ['enabled'];\n\nclass RigidBodyComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'rigidbody';\n\t\tthis._stats = app.stats.frame;\n\t\tthis.ComponentType = RigidBodyComponent;\n\t\tthis.DataType = RigidBodyComponentData;\n\t\tthis.contactPointPool = null;\n\t\tthis.contactResultPool = null;\n\t\tthis.singleContactResultPool = null;\n\t\tthis.schema = _schema$7;\n\t\tthis.maxSubSteps = 10;\n\t\tthis.fixedTimeStep = 1 / 60;\n\t\tthis.gravity = new Vec3(0, -9.81, 0);\n\t\tthis._dynamic = [];\n\t\tthis._kinematic = [];\n\t\tthis._triggers = [];\n\t\tthis._compounds = [];\n\t\tthis.collisions = {};\n\t\tthis.frameCollisions = {};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.on('remove', this.onRemove, this);\n\t}\n\n\tonLibraryLoaded() {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tthis.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n\t\t\tthis.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);\n\t\t\tthis.overlappingPairCache = new Ammo.btDbvtBroadphase();\n\t\t\tthis.solver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\t\tthis.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);\n\n\t\t\tif (this.dynamicsWorld.setInternalTickCallback) {\n\t\t\t\tconst checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');\n\t\t\t\tthis.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);\n\t\t\t}\n\n\t\t\tammoRayStart = new Ammo.btVector3();\n\t\t\tammoRayEnd = new Ammo.btVector3();\n\t\t\tRigidBodyComponent.onLibraryLoaded();\n\t\t\tthis.contactPointPool = new ObjectPool(ContactPoint, 1);\n\t\t\tthis.contactResultPool = new ObjectPool(ContactResult, 1);\n\t\t\tthis.singleContactResultPool = new ObjectPool(SingleContactResult, 1);\n\t\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\t} else {\n\t\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t\t}\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tconst props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];\n\n\t\tfor (const property of props) {\n\t\t\tif (data.hasOwnProperty(property)) {\n\t\t\t\tconst value = data[property];\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tcomponent[property] = new Vec3(value[0], value[1], value[2]);\n\t\t\t\t} else {\n\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst rigidbody = entity.rigidbody;\n\t\tconst data = {\n\t\t\tenabled: rigidbody.enabled,\n\t\t\tmass: rigidbody.mass,\n\t\t\tlinearDamping: rigidbody.linearDamping,\n\t\t\tangularDamping: rigidbody.angularDamping,\n\t\t\tlinearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],\n\t\t\tangularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],\n\t\t\tfriction: rigidbody.friction,\n\t\t\trollingFriction: rigidbody.rollingFriction,\n\t\t\trestitution: rigidbody.restitution,\n\t\t\ttype: rigidbody.type,\n\t\t\tgroup: rigidbody.group,\n\t\t\tmask: rigidbody.mask\n\t\t};\n\t\tthis.addComponent(clone, data);\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tif (component.enabled) {\n\t\t\tcomponent.enabled = false;\n\t\t}\n\t}\n\n\tonRemove(entity, component) {\n\t\tconst body = component.body;\n\n\t\tif (body) {\n\t\t\tthis.removeBody(body);\n\t\t\tthis.destroyBody(body);\n\t\t\tcomponent.body = null;\n\t\t}\n\t}\n\n\taddBody(body, group, mask) {\n\t\tif (group !== undefined && mask !== undefined) {\n\t\t\tthis.dynamicsWorld.addRigidBody(body, group, mask);\n\t\t} else {\n\t\t\tthis.dynamicsWorld.addRigidBody(body);\n\t\t}\n\t}\n\n\tremoveBody(body) {\n\t\tthis.dynamicsWorld.removeRigidBody(body);\n\t}\n\n\tcreateBody(mass, shape, transform) {\n\t\tconst localInertia = new Ammo.btVector3(0, 0, 0);\n\n\t\tif (mass !== 0) {\n\t\t\tshape.calculateLocalInertia(mass, localInertia);\n\t\t}\n\n\t\tconst motionState = new Ammo.btDefaultMotionState(transform);\n\t\tconst bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n\t\tconst body = new Ammo.btRigidBody(bodyInfo);\n\t\tAmmo.destroy(bodyInfo);\n\t\tAmmo.destroy(localInertia);\n\t\treturn body;\n\t}\n\n\tdestroyBody(body) {\n\t\tconst motionState = body.getMotionState();\n\n\t\tif (motionState) {\n\t\t\tAmmo.destroy(motionState);\n\t\t}\n\n\t\tAmmo.destroy(body);\n\t}\n\n\traycastFirst(start, end) {\n\t\tlet result = null;\n\t\tammoRayStart.setValue(start.x, start.y, start.z);\n\t\tammoRayEnd.setValue(end.x, end.y, end.z);\n\t\tconst rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);\n\t\tthis.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);\n\n\t\tif (rayCallback.hasHit()) {\n\t\t\tconst collisionObj = rayCallback.get_m_collisionObject();\n\t\t\tconst body = Ammo.castObject(collisionObj, Ammo.btRigidBody);\n\n\t\t\tif (body) {\n\t\t\t\tconst point = rayCallback.get_m_hitPointWorld();\n\t\t\t\tconst normal = rayCallback.get_m_hitNormalWorld();\n\t\t\t\tresult = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));\n\n\t\t\t\tif (arguments.length > 2) {\n\t\t\t\t\tconst callback = arguments[2];\n\t\t\t\t\tcallback(result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAmmo.destroy(rayCallback);\n\t\treturn result;\n\t}\n\n\traycastAll(start, end) {\n\t\tconst results = [];\n\t\tammoRayStart.setValue(start.x, start.y, start.z);\n\t\tammoRayEnd.setValue(end.x, end.y, end.z);\n\t\tconst rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);\n\t\tthis.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);\n\n\t\tif (rayCallback.hasHit()) {\n\t\t\tconst collisionObjs = rayCallback.get_m_collisionObjects();\n\t\t\tconst points = rayCallback.get_m_hitPointWorld();\n\t\t\tconst normals = rayCallback.get_m_hitNormalWorld();\n\t\t\tconst numHits = collisionObjs.size();\n\n\t\t\tfor (let i = 0; i < numHits; i++) {\n\t\t\t\tconst body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);\n\n\t\t\t\tif (body) {\n\t\t\t\t\tconst point = points.at(i);\n\t\t\t\t\tconst normal = normals.at(i);\n\t\t\t\t\tconst result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));\n\t\t\t\t\tresults.push(result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAmmo.destroy(rayCallback);\n\t\treturn results;\n\t}\n\n\t_storeCollision(entity, other) {\n\t\tlet isNewCollision = false;\n\t\tconst guid = entity.getGuid();\n\t\tthis.collisions[guid] = this.collisions[guid] || {\n\t\t\tothers: [],\n\t\t\tentity: entity\n\t\t};\n\n\t\tif (this.collisions[guid].others.indexOf(other) < 0) {\n\t\t\tthis.collisions[guid].others.push(other);\n\t\t\tisNewCollision = true;\n\t\t}\n\n\t\tthis.frameCollisions[guid] = this.frameCollisions[guid] || {\n\t\t\tothers: [],\n\t\t\tentity: entity\n\t\t};\n\t\tthis.frameCollisions[guid].others.push(other);\n\t\treturn isNewCollision;\n\t}\n\n\t_createContactPointFromAmmo(contactPoint) {\n\t\tconst localPointA = contactPoint.get_m_localPointA();\n\t\tconst localPointB = contactPoint.get_m_localPointB();\n\t\tconst positionWorldOnA = contactPoint.getPositionWorldOnA();\n\t\tconst positionWorldOnB = contactPoint.getPositionWorldOnB();\n\t\tconst normalWorldOnB = contactPoint.get_m_normalWorldOnB();\n\t\tconst contact = this.contactPointPool.allocate();\n\t\tcontact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());\n\t\tcontact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());\n\t\tcontact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());\n\t\tcontact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());\n\t\tcontact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());\n\t\tcontact.impulse = contactPoint.getAppliedImpulse();\n\t\treturn contact;\n\t}\n\n\t_createReverseContactPointFromAmmo(contactPoint) {\n\t\tconst localPointA = contactPoint.get_m_localPointA();\n\t\tconst localPointB = contactPoint.get_m_localPointB();\n\t\tconst positionWorldOnA = contactPoint.getPositionWorldOnA();\n\t\tconst positionWorldOnB = contactPoint.getPositionWorldOnB();\n\t\tconst normalWorldOnB = contactPoint.get_m_normalWorldOnB();\n\t\tconst contact = this.contactPointPool.allocate();\n\t\tcontact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());\n\t\tcontact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());\n\t\tcontact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());\n\t\tcontact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());\n\t\tcontact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());\n\t\tcontact.impulse = contactPoint.getAppliedImpulse();\n\t\treturn contact;\n\t}\n\n\t_createSingleContactResult(a, b, contactPoint) {\n\t\tconst result = this.singleContactResultPool.allocate();\n\t\tresult.a = a;\n\t\tresult.b = b;\n\t\tresult.localPointA = contactPoint.localPoint;\n\t\tresult.localPointB = contactPoint.localPointOther;\n\t\tresult.pointA = contactPoint.point;\n\t\tresult.pointB = contactPoint.pointOther;\n\t\tresult.normal = contactPoint.normal;\n\t\tresult.impulse = contactPoint.impulse;\n\t\treturn result;\n\t}\n\n\t_createContactResult(other, contacts) {\n\t\tconst result = this.contactResultPool.allocate();\n\t\tresult.other = other;\n\t\tresult.contacts = contacts;\n\t\treturn result;\n\t}\n\n\t_cleanOldCollisions() {\n\t\tfor (const guid in this.collisions) {\n\t\t\tif (this.collisions.hasOwnProperty(guid)) {\n\t\t\t\tconst frameCollision = this.frameCollisions[guid];\n\t\t\t\tconst collision = this.collisions[guid];\n\t\t\t\tconst entity = collision.entity;\n\t\t\t\tconst entityCollision = entity.collision;\n\t\t\t\tconst entityRigidbody = entity.rigidbody;\n\t\t\t\tconst others = collision.others;\n\t\t\t\tconst length = others.length;\n\t\t\t\tlet i = length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tconst other = others[i];\n\n\t\t\t\t\tif (!frameCollision || frameCollision.others.indexOf(other) < 0) {\n\t\t\t\t\t\tothers.splice(i, 1);\n\n\t\t\t\t\t\tif (entity.trigger) {\n\t\t\t\t\t\t\tif (entityCollision) {\n\t\t\t\t\t\t\t\tentityCollision.fire(\"triggerleave\", other);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (other.rigidbody) {\n\t\t\t\t\t\t\t\tother.rigidbody.fire('triggerleave', entity);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!other.trigger) {\n\t\t\t\t\t\t\tif (entityRigidbody) {\n\t\t\t\t\t\t\t\tentityRigidbody.fire(\"collisionend\", other);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (entityCollision) {\n\t\t\t\t\t\t\t\tentityCollision.fire(\"collisionend\", other);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (others.length === 0) {\n\t\t\t\t\tdelete this.collisions[guid];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_hasContactEvent(entity) {\n\t\tconst c = entity.collision;\n\n\t\tif (c && (c.hasEvent(\"collisionstart\") || c.hasEvent(\"collisionend\") || c.hasEvent(\"contact\"))) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst r = entity.rigidbody;\n\t\treturn r && (r.hasEvent(\"collisionstart\") || r.hasEvent(\"collisionend\") || r.hasEvent(\"contact\"));\n\t}\n\n\t_checkForCollisions(world, timeStep) {\n\t\tconst dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);\n\t\tconst dispatcher = dynamicsWorld.getDispatcher();\n\t\tconst numManifolds = dispatcher.getNumManifolds();\n\t\tthis.frameCollisions = {};\n\n\t\tfor (let i = 0; i < numManifolds; i++) {\n\t\t\tconst manifold = dispatcher.getManifoldByIndexInternal(i);\n\t\t\tconst body0 = manifold.getBody0();\n\t\t\tconst body1 = manifold.getBody1();\n\t\t\tconst wb0 = Ammo.castObject(body0, Ammo.btRigidBody);\n\t\t\tconst wb1 = Ammo.castObject(body1, Ammo.btRigidBody);\n\t\t\tconst e0 = wb0.entity;\n\t\t\tconst e1 = wb1.entity;\n\n\t\t\tif (!e0 || !e1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst flags0 = wb0.getCollisionFlags();\n\t\t\tconst flags1 = wb1.getCollisionFlags();\n\t\t\tconst numContacts = manifold.getNumContacts();\n\t\t\tconst forwardContacts = [];\n\t\t\tconst reverseContacts = [];\n\t\t\tlet newCollision;\n\n\t\t\tif (numContacts > 0) {\n\t\t\t\tif (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {\n\t\t\t\t\tconst e0Events = e0.collision && (e0.collision.hasEvent(\"triggerenter\") || e0.collision.hasEvent(\"triggerleave\"));\n\t\t\t\t\tconst e1Events = e1.collision && (e1.collision.hasEvent(\"triggerenter\") || e1.collision.hasEvent(\"triggerleave\"));\n\t\t\t\t\tconst e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent(\"triggerenter\") || e0.rigidbody.hasEvent(\"triggerleave\"));\n\t\t\t\t\tconst e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent(\"triggerenter\") || e1.rigidbody.hasEvent(\"triggerleave\"));\n\n\t\t\t\t\tif (e0Events) {\n\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\n\t\t\t\t\t\tif (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {\n\t\t\t\t\t\t\te0.collision.fire(\"triggerenter\", e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e1Events) {\n\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\n\t\t\t\t\t\tif (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {\n\t\t\t\t\t\t\te1.collision.fire(\"triggerenter\", e0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e0BodyEvents) {\n\t\t\t\t\t\tif (!newCollision) {\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\te0.rigidbody.fire(\"triggerenter\", e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e1BodyEvents) {\n\t\t\t\t\t\tif (!newCollision) {\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\te1.rigidbody.fire(\"triggerenter\", e0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst e0Events = this._hasContactEvent(e0);\n\n\t\t\t\t\tconst e1Events = this._hasContactEvent(e1);\n\n\t\t\t\t\tconst globalEvents = this.hasEvent(\"contact\");\n\n\t\t\t\t\tif (globalEvents || e0Events || e1Events) {\n\t\t\t\t\t\tfor (let j = 0; j < numContacts; j++) {\n\t\t\t\t\t\t\tconst btContactPoint = manifold.getContactPoint(j);\n\n\t\t\t\t\t\t\tconst contactPoint = this._createContactPointFromAmmo(btContactPoint);\n\n\t\t\t\t\t\t\tif (e0Events || e1Events) {\n\t\t\t\t\t\t\t\tforwardContacts.push(contactPoint);\n\n\t\t\t\t\t\t\t\tconst reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);\n\n\t\t\t\t\t\t\t\treverseContacts.push(reverseContactPoint);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (globalEvents) {\n\t\t\t\t\t\t\t\tconst result = this._createSingleContactResult(e0, e1, contactPoint);\n\n\t\t\t\t\t\t\t\tthis.fire(\"contact\", result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (e0Events) {\n\t\t\t\t\t\t\tconst forwardResult = this._createContactResult(e1, forwardContacts);\n\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\n\t\t\t\t\t\t\tif (e0.collision) {\n\t\t\t\t\t\t\t\te0.collision.fire(\"contact\", forwardResult);\n\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te0.collision.fire(\"collisionstart\", forwardResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (e0.rigidbody) {\n\t\t\t\t\t\t\t\te0.rigidbody.fire(\"contact\", forwardResult);\n\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te0.rigidbody.fire(\"collisionstart\", forwardResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (e1Events) {\n\t\t\t\t\t\t\tconst reverseResult = this._createContactResult(e0, reverseContacts);\n\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\n\t\t\t\t\t\t\tif (e1.collision) {\n\t\t\t\t\t\t\t\te1.collision.fire(\"contact\", reverseResult);\n\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te1.collision.fire(\"collisionstart\", reverseResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (e1.rigidbody) {\n\t\t\t\t\t\t\t\te1.rigidbody.fire(\"contact\", reverseResult);\n\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te1.rigidbody.fire(\"collisionstart\", reverseResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._cleanOldCollisions();\n\n\t\tthis.contactPointPool.freeAll();\n\t\tthis.contactResultPool.freeAll();\n\t\tthis.singleContactResultPool.freeAll();\n\t}\n\n\tonUpdate(dt) {\n\t\tlet i, len;\n\t\tconst gravity = this.dynamicsWorld.getGravity();\n\n\t\tif (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {\n\t\t\tgravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);\n\t\t\tthis.dynamicsWorld.setGravity(gravity);\n\t\t}\n\n\t\tconst triggers = this._triggers;\n\n\t\tfor (i = 0, len = triggers.length; i < len; i++) {\n\t\t\ttriggers[i].updateTransform();\n\t\t}\n\n\t\tconst compounds = this._compounds;\n\n\t\tfor (i = 0, len = compounds.length; i < len; i++) {\n\t\t\tcompounds[i]._updateCompound();\n\t\t}\n\n\t\tconst kinematic = this._kinematic;\n\n\t\tfor (i = 0, len = kinematic.length; i < len; i++) {\n\t\t\tkinematic[i]._updateKinematic();\n\t\t}\n\n\t\tthis.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);\n\t\tconst dynamic = this._dynamic;\n\n\t\tfor (i = 0, len = dynamic.length; i < len; i++) {\n\t\t\tdynamic[i]._updateDynamic();\n\t\t}\n\n\t\tif (!this.dynamicsWorld.setInternalTickCallback) this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tAmmo.destroy(this.dynamicsWorld);\n\t\t\tAmmo.destroy(this.solver);\n\t\t\tAmmo.destroy(this.overlappingPairCache);\n\t\t\tAmmo.destroy(this.dispatcher);\n\t\t\tAmmo.destroy(this.collisionConfiguration);\n\t\t\tthis.dynamicsWorld = null;\n\t\t\tthis.solver = null;\n\t\t\tthis.overlappingPairCache = null;\n\t\t\tthis.dispatcher = null;\n\t\t\tthis.collisionConfiguration = null;\n\t\t}\n\t}\n\n}\n\nComponent._buildAccessors(RigidBodyComponent.prototype, _schema$7);\n\nconst SCALEMODE_NONE = \"none\";\nconst SCALEMODE_BLEND = \"blend\";\n\nconst _transform = new Mat4();\n\nclass ScreenComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._resolution = new Vec2(640, 320);\n\t\tthis._referenceResolution = new Vec2(640, 320);\n\t\tthis._scaleMode = SCALEMODE_NONE;\n\t\tthis.scale = 1;\n\t\tthis._scaleBlend = 0.5;\n\t\tthis._priority = 0;\n\t\tthis._screenSpace = false;\n\t\tthis.cull = this._screenSpace;\n\t\tthis._screenMatrix = new Mat4();\n\t\tthis._elements = new Set();\n\t\tsystem.app.graphicsDevice.on(\"resizecanvas\", this._onResize, this);\n\t}\n\n\tsyncDrawOrder() {\n\t\tthis.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);\n\t}\n\n\t_recurseDrawOrderSync(e, i) {\n\t\tif (!(e instanceof Entity)) {\n\t\t\treturn i;\n\t\t}\n\n\t\tif (e.element) {\n\t\t\tconst prevDrawOrder = e.element.drawOrder;\n\t\t\te.element.drawOrder = i++;\n\n\t\t\tif (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {\n\t\t\t\tthis.system.app.batcher.markGroupDirty(e.element._batchGroupId);\n\t\t\t}\n\t\t}\n\n\t\tif (e.particlesystem) {\n\t\t\te.particlesystem.drawOrder = i++;\n\t\t}\n\n\t\tconst children = e.children;\n\n\t\tfor (let j = 0; j < children.length; j++) {\n\t\t\ti = this._recurseDrawOrderSync(children[j], i);\n\t\t}\n\n\t\treturn i;\n\t}\n\n\t_processDrawOrderSync() {\n\t\tconst i = 1;\n\n\t\tthis._recurseDrawOrderSync(this.entity, i);\n\n\t\tthis.fire('syncdraworder');\n\t}\n\n\t_calcProjectionMatrix() {\n\t\tconst w = this._resolution.x / this.scale;\n\t\tconst h = this._resolution.y / this.scale;\n\t\tconst left = 0;\n\t\tconst right = w;\n\t\tconst bottom = -h;\n\t\tconst top = 0;\n\t\tconst near = 1;\n\t\tconst far = -1;\n\n\t\tthis._screenMatrix.setOrtho(left, right, bottom, top, near, far);\n\n\t\tif (!this._screenSpace) {\n\t\t\t_transform.setScale(0.5 * w, 0.5 * h, 1);\n\n\t\t\tthis._screenMatrix.mul2(_transform, this._screenMatrix);\n\t\t}\n\t}\n\n\t_updateScale() {\n\t\tthis.scale = this._calcScale(this._resolution, this.referenceResolution);\n\t}\n\n\t_calcScale(resolution, referenceResolution) {\n\t\tconst lx = Math.log2(resolution.x / referenceResolution.x);\n\t\tconst ly = Math.log2(resolution.y / referenceResolution.y);\n\t\treturn Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);\n\t}\n\n\t_onResize(width, height) {\n\t\tif (this._screenSpace) {\n\t\t\tthis._resolution.set(width, height);\n\n\t\t\tthis.resolution = this._resolution;\n\t\t}\n\t}\n\n\t_bindElement(element) {\n\t\tthis._elements.add(element);\n\t}\n\n\t_unbindElement(element) {\n\t\tthis._elements.delete(element);\n\t}\n\n\tonRemove() {\n\t\tthis.system.app.graphicsDevice.off(\"resizecanvas\", this._onResize, this);\n\t\tthis.fire('remove');\n\n\t\tthis._elements.forEach(element => element._onScreenRemove());\n\n\t\tthis._elements.clear();\n\n\t\tthis.off();\n\t}\n\n\tset resolution(value) {\n\t\tif (!this._screenSpace) {\n\t\t\tthis._resolution.set(value.x, value.y);\n\t\t} else {\n\t\t\tthis._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);\n\t\t}\n\n\t\tthis._updateScale();\n\n\t\tthis._calcProjectionMatrix();\n\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire(\"set:resolution\", this._resolution);\n\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\n\tget resolution() {\n\t\treturn this._resolution;\n\t}\n\n\tset referenceResolution(value) {\n\t\tthis._referenceResolution.set(value.x, value.y);\n\n\t\tthis._updateScale();\n\n\t\tthis._calcProjectionMatrix();\n\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire(\"set:referenceresolution\", this._resolution);\n\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\n\tget referenceResolution() {\n\t\tif (this._scaleMode === SCALEMODE_NONE) {\n\t\t\treturn this._resolution;\n\t\t}\n\n\t\treturn this._referenceResolution;\n\t}\n\n\tset screenSpace(value) {\n\t\tthis._screenSpace = value;\n\n\t\tif (this._screenSpace) {\n\t\t\tthis._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);\n\t\t}\n\n\t\tthis.resolution = this._resolution;\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire('set:screenspace', this._screenSpace);\n\n\t\tthis._elements.forEach(element => element._onScreenSpaceChange());\n\t}\n\n\tget screenSpace() {\n\t\treturn this._screenSpace;\n\t}\n\n\tset scaleMode(value) {\n\t\tif (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {\n\t\t\tvalue = SCALEMODE_NONE;\n\t\t}\n\n\t\tif (!this._screenSpace && value !== SCALEMODE_NONE) {\n\t\t\tvalue = SCALEMODE_NONE;\n\t\t}\n\n\t\tthis._scaleMode = value;\n\t\tthis.resolution = this._resolution;\n\t\tthis.fire(\"set:scalemode\", this._scaleMode);\n\t}\n\n\tget scaleMode() {\n\t\treturn this._scaleMode;\n\t}\n\n\tset scaleBlend(value) {\n\t\tthis._scaleBlend = value;\n\n\t\tthis._updateScale();\n\n\t\tthis._calcProjectionMatrix();\n\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire(\"set:scaleblend\", this._scaleBlend);\n\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\n\tget scaleBlend() {\n\t\treturn this._scaleBlend;\n\t}\n\n\tset priority(value) {\n\t\tif (value > 0xFF) {\n\t\t\tvalue = 0xFF;\n\t\t}\n\n\t\tthis._priority = value;\n\t}\n\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\n}\n\nclass ScreenComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$6 = ['enabled'];\n\nclass ScreenComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'screen';\n\t\tthis.ComponentType = ScreenComponent;\n\t\tthis.DataType = ScreenComponentData;\n\t\tthis.schema = _schema$6;\n\t\tthis.windowResolution = new Vec2();\n\t\tthis._drawOrderSyncQueue = new IndexedList();\n\t\tthis.app.graphicsDevice.on(\"resizecanvas\", this._onResize, this);\n\t\tthis.app.systems.on('update', this._onUpdate, this);\n\t\tthis.on('beforeremove', this.onRemoveComponent, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.priority !== undefined) component.priority = data.priority;\n\t\tif (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;\n\t\tcomponent.cull = component.screenSpace;\n\t\tif (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;\n\t\tif (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;\n\n\t\tif (data.resolution !== undefined) {\n\t\t\tif (data.resolution instanceof Vec2) {\n\t\t\t\tcomponent._resolution.copy(data.resolution);\n\t\t\t} else {\n\t\t\t\tcomponent._resolution.set(data.resolution[0], data.resolution[1]);\n\t\t\t}\n\n\t\t\tcomponent.resolution = component._resolution;\n\t\t}\n\n\t\tif (data.referenceResolution !== undefined) {\n\t\t\tif (data.referenceResolution instanceof Vec2) {\n\t\t\t\tcomponent._referenceResolution.copy(data.referenceResolution);\n\t\t\t} else {\n\t\t\t\tcomponent._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);\n\t\t\t}\n\n\t\t\tcomponent.referenceResolution = component._referenceResolution;\n\t\t}\n\n\t\tcomponent.syncDrawOrder();\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.graphicsDevice.off(\"resizecanvas\", this._onResize, this);\n\t\tthis.app.systems.off('update', this._onUpdate, this);\n\t}\n\n\t_onUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components[id].entity.screen.update) components[id].entity.screen.update(dt);\n\t\t}\n\t}\n\n\t_onResize(width, height) {\n\t\tthis.windowResolution.x = width;\n\t\tthis.windowResolution.y = height;\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst screen = entity.screen;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: screen.enabled,\n\t\t\tscreenSpace: screen.screenSpace,\n\t\t\tscaleMode: screen.scaleMode,\n\t\t\tresolution: screen.resolution.clone(),\n\t\t\treferenceResolution: screen.referenceResolution.clone()\n\t\t});\n\t}\n\n\tonRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tprocessDrawOrderSyncQueue() {\n\t\tconst list = this._drawOrderSyncQueue.list();\n\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst item = list[i];\n\t\t\titem.callback.call(item.scope);\n\t\t}\n\n\t\tthis._drawOrderSyncQueue.clear();\n\t}\n\n\tqueueDrawOrderSync(id, fn, scope) {\n\t\tif (!this._drawOrderSyncQueue.list().length) {\n\t\t\tthis.app.once('prerender', this.processDrawOrderSyncQueue, this);\n\t\t}\n\n\t\tif (!this._drawOrderSyncQueue.has(id)) {\n\t\t\tthis._drawOrderSyncQueue.push(id, {\n\t\t\t\tcallback: fn,\n\t\t\t\tscope: scope\n\t\t\t});\n\t\t}\n\t}\n\n}\n\nComponent._buildAccessors(ScreenComponent.prototype, _schema$6);\n\nclass ScriptComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';\nconst METHOD_INITIALIZE = '_onInitialize';\nconst METHOD_POST_INITIALIZE = '_onPostInitialize';\nconst METHOD_UPDATE = '_onUpdate';\nconst METHOD_POST_UPDATE = '_onPostUpdate';\nlet executionOrderCounter = 0;\n\nclass ScriptComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'script';\n\t\tthis.ComponentType = ScriptComponent;\n\t\tthis.DataType = ScriptComponentData;\n\t\tthis._components = new SortedLoopArray({\n\t\t\tsortBy: '_executionOrder'\n\t\t});\n\t\tthis._enabledComponents = new SortedLoopArray({\n\t\t\tsortBy: '_executionOrder'\n\t\t});\n\t\tthis.preloading = true;\n\t\tthis.on('beforeremove', this._onBeforeRemove, this);\n\t\tthis.app.systems.on('initialize', this._onInitialize, this);\n\t\tthis.app.systems.on('postInitialize', this._onPostInitialize, this);\n\t\tthis.app.systems.on('update', this._onUpdate, this);\n\t\tthis.app.systems.on('postUpdate', this._onPostUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data) {\n\t\tcomponent._executionOrder = executionOrderCounter++;\n\n\t\tthis._components.append(component);\n\n\t\tif (executionOrderCounter > Number.MAX_SAFE_INTEGER) {\n\t\t\tthis._resetExecutionOrder();\n\t\t}\n\n\t\tcomponent.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;\n\n\t\tif (component.enabled && component.entity.enabled) {\n\t\t\tthis._enabledComponents.append(component);\n\t\t}\n\n\t\tif (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {\n\t\t\tcomponent._scriptsData = data.scripts;\n\n\t\t\tfor (let i = 0; i < data.order.length; i++) {\n\t\t\t\tcomponent.create(data.order[i], {\n\t\t\t\t\tenabled: data.scripts[data.order[i]].enabled,\n\t\t\t\t\tattributes: data.scripts[data.order[i]].attributes,\n\t\t\t\t\tpreloading: this.preloading\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst order = [];\n\t\tconst scripts = {};\n\n\t\tfor (let i = 0; i < entity.script._scripts.length; i++) {\n\t\t\tconst scriptInstance = entity.script._scripts[i];\n\t\t\tconst scriptName = scriptInstance.__scriptType.__name;\n\t\t\torder.push(scriptName);\n\t\t\tconst attributes = {};\n\n\t\t\tfor (const key in scriptInstance.__attributes) attributes[key] = scriptInstance.__attributes[key];\n\n\t\t\tscripts[scriptName] = {\n\t\t\t\tenabled: scriptInstance._enabled,\n\t\t\t\tattributes: attributes\n\t\t\t};\n\t\t}\n\n\t\tfor (const key in entity.script._scriptsIndex) {\n\t\t\tif (key.awaiting) {\n\t\t\t\torder.splice(key.ind, 0, key);\n\t\t\t}\n\t\t}\n\n\t\tconst data = {\n\t\t\tenabled: entity.script.enabled,\n\t\t\torder: order,\n\t\t\tscripts: scripts\n\t\t};\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\t_resetExecutionOrder() {\n\t\texecutionOrderCounter = 0;\n\n\t\tfor (let i = 0, len = this._components.length; i < len; i++) {\n\t\t\tthis._components.items[i]._executionOrder = executionOrderCounter++;\n\t\t}\n\t}\n\n\t_callComponentMethod(components, name, dt) {\n\t\tfor (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {\n\t\t\tcomponents.items[components.loopIndex][name](dt);\n\t\t}\n\t}\n\n\t_onInitialize() {\n\t\tthis.preloading = false;\n\n\t\tthis._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);\n\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);\n\t}\n\n\t_onPostInitialize() {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);\n\t}\n\n\t_onUpdate(dt) {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);\n\t}\n\n\t_onPostUpdate(dt) {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);\n\t}\n\n\t_addComponentToEnabled(component) {\n\t\tthis._enabledComponents.insert(component);\n\t}\n\n\t_removeComponentFromEnabled(component) {\n\t\tthis._enabledComponents.remove(component);\n\t}\n\n\t_onBeforeRemove(entity, component) {\n\t\tconst ind = this._components.items.indexOf(component);\n\n\t\tif (ind >= 0) {\n\t\t\tcomponent._onBeforeRemove();\n\t\t}\n\n\t\tthis._removeComponentFromEnabled(component);\n\n\t\tthis._components.remove(component);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('initialize', this._onInitialize, this);\n\t\tthis.app.systems.off('postInitialize', this._onPostInitialize, this);\n\t\tthis.app.systems.off('update', this._onUpdate, this);\n\t\tthis.app.systems.off('postUpdate', this._onPostUpdate, this);\n\t}\n\n}\n\nclass ScriptLegacyComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.on(\"set_scripts\", this.onSetScripts, this);\n\t}\n\n\tsend(name, functionName) {\n\t\tconst args = Array.prototype.slice.call(arguments, 2);\n\t\tconst instances = this.entity.script.instances;\n\t\tlet fn;\n\n\t\tif (instances && instances[name]) {\n\t\t\tfn = instances[name].instance[functionName];\n\n\t\t\tif (fn) {\n\t\t\t\treturn fn.apply(instances[name].instance, args);\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tif (this.data.areScriptsLoaded && !this.system.preloading) {\n\t\t\tif (!this.data.initialized) {\n\t\t\t\tthis.system._initializeScriptComponent(this);\n\t\t\t} else {\n\t\t\t\tthis.system._enableScriptComponent(this);\n\t\t\t}\n\n\t\t\tif (!this.data.postInitialized) {\n\t\t\t\tthis.system._postInitializeScriptComponent(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tthis.system._disableScriptComponent(this);\n\t}\n\n\tonSetScripts(name, oldValue, newValue) {\n\t\tif (!this.system._inTools || this.runInTools) {\n\t\t\tif (this._updateScriptAttributes(oldValue, newValue)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.enabled) {\n\t\t\t\tthis.system._disableScriptComponent(this);\n\t\t\t}\n\n\t\t\tthis.system._destroyScriptComponent(this);\n\n\t\t\tthis.data.areScriptsLoaded = false;\n\t\t\tconst scripts = newValue;\n\t\t\tconst urls = scripts.map(function (s) {\n\t\t\t\treturn s.url;\n\t\t\t});\n\n\t\t\tif (this._loadFromCache(urls)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._loadScripts(urls);\n\t\t}\n\t}\n\n\t_updateScriptAttributes(oldValue, newValue) {\n\t\tlet onlyUpdateAttributes = true;\n\n\t\tif (oldValue.length !== newValue.length) {\n\t\t\tonlyUpdateAttributes = false;\n\t\t} else {\n\t\t\tfor (let i = 0, len = newValue.length; i < len; i++) {\n\t\t\t\tif (oldValue[i].url !== newValue[i].url) {\n\t\t\t\t\tonlyUpdateAttributes = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (onlyUpdateAttributes) {\n\t\t\tfor (const key in this.instances) {\n\t\t\t\tif (this.instances.hasOwnProperty(key)) {\n\t\t\t\t\tthis.system._updateAccessors(this.entity, this.instances[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn onlyUpdateAttributes;\n\t}\n\n\t_loadFromCache(urls) {\n\t\tconst cached = [];\n\t\tconst prefix = this.system.app._scriptPrefix || \"\";\n\t\tconst regex = /^http(s)?:\\/\\//i;\n\n\t\tfor (let i = 0, len = urls.length; i < len; i++) {\n\t\t\tlet url = urls[i];\n\n\t\t\tif (!regex.test(url)) {\n\t\t\t\turl = path.join(prefix, url);\n\t\t\t}\n\n\t\t\tconst type = this.system.app.loader.getFromCache(url, 'script');\n\n\t\t\tif (!type) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcached.push(type);\n\t\t}\n\n\t\tfor (let i = 0, len = cached.length; i < len; i++) {\n\t\t\tconst ScriptType = cached[i];\n\n\t\t\tif (ScriptType === true) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ScriptType && this.entity.script) {\n\t\t\t\tif (!this.entity.script.instances[ScriptType._pcScriptName]) {\n\t\t\t\t\tconst instance = new ScriptType(this.entity);\n\n\t\t\t\t\tthis.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.data) {\n\t\t\tthis.data.areScriptsLoaded = true;\n\t\t}\n\n\t\tif (!this.system.preloading) {\n\t\t\tthis.system.onInitialize(this.entity);\n\t\t\tthis.system.onPostInitialize(this.entity);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t_loadScripts(urls) {\n\t\tlet count = urls.length;\n\t\tconst prefix = this.system.app._scriptPrefix || \"\";\n\t\turls.forEach(url => {\n\t\t\tlet _url = null;\n\t\t\tlet _unprefixed = null;\n\n\t\t\tif (url.toLowerCase().startsWith(\"http://\") || url.toLowerCase().startsWith(\"https://\")) {\n\t\t\t\t_unprefixed = url;\n\t\t\t\t_url = url;\n\t\t\t} else {\n\t\t\t\t_unprefixed = url;\n\t\t\t\t_url = path.join(prefix, url);\n\t\t\t}\n\n\t\t\tthis.system.app.loader.load(_url, \"script\", (err, ScriptType) => {\n\t\t\t\tcount--;\n\n\t\t\t\tif (!err) {\n\t\t\t\t\tif (ScriptType && this.entity.script) {\n\t\t\t\t\t\tif (!this.entity.script.instances[ScriptType._pcScriptName]) {\n\t\t\t\t\t\t\tconst instance = new ScriptType(this.entity);\n\n\t\t\t\t\t\t\tthis.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\n\t\t\t\tif (count === 0) {\n\t\t\t\t\tthis.data.areScriptsLoaded = true;\n\n\t\t\t\t\tif (!this.system.preloading) {\n\t\t\t\t\t\tthis.system.onInitialize(this.entity);\n\t\t\t\t\t\tthis.system.onPostInitialize(this.entity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n}\n\nclass ScriptLegacyComponentData {\n\tconstructor() {\n\t\tthis.scripts = [];\n\t\tthis.enabled = true;\n\t\tthis.instances = {};\n\t\tthis._instances = {};\n\t\tthis.runInTools = false;\n\t\tthis.attributes = {};\n\t\tthis.initialized = false;\n\t\tthis.postInitialized = false;\n\t\tthis.areScriptsLoaded = false;\n\t}\n\n}\n\nconst _schema$5 = ['enabled', 'scripts', 'instances', 'runInTools'];\nconst INITIALIZE = \"initialize\";\nconst POST_INITIALIZE = \"postInitialize\";\nconst UPDATE = \"update\";\nconst POST_UPDATE = \"postUpdate\";\nconst FIXED_UPDATE = \"fixedUpdate\";\nconst TOOLS_UPDATE = \"toolsUpdate\";\nconst ON_ENABLE = 'onEnable';\nconst ON_DISABLE = 'onDisable';\n\nclass ScriptLegacyComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'script';\n\t\tthis.ComponentType = ScriptLegacyComponent;\n\t\tthis.DataType = ScriptLegacyComponentData;\n\t\tthis.schema = _schema$5;\n\t\tthis.preloading = false;\n\t\tthis.instancesWithUpdate = [];\n\t\tthis.instancesWithFixedUpdate = [];\n\t\tthis.instancesWithPostUpdate = [];\n\t\tthis.instancesWithToolsUpdate = [];\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on(INITIALIZE, this.onInitialize, this);\n\t\tthis.app.systems.on(POST_INITIALIZE, this.onPostInitialize, this);\n\t\tthis.app.systems.on(UPDATE, this.onUpdate, this);\n\t\tthis.app.systems.on(FIXED_UPDATE, this.onFixedUpdate, this);\n\t\tthis.app.systems.on(POST_UPDATE, this.onPostUpdate, this);\n\t\tthis.app.systems.on(TOOLS_UPDATE, this.onToolsUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['runInTools', 'enabled', 'scripts'];\n\n\t\tif (data.scripts && data.scripts.length) {\n\t\t\tdata.scripts.forEach(function (script) {\n\t\t\t\tif (script.attributes && Array.isArray(script.attributes)) {\n\t\t\t\t\tconst dict = {};\n\n\t\t\t\t\tfor (let i = 0; i < script.attributes.length; i++) {\n\t\t\t\t\t\tdict[script.attributes[i].name] = script.attributes[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tscript.attributes = dict;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst src = this.store[entity.getGuid()];\n\t\tconst data = {\n\t\t\trunInTools: src.data.runInTools,\n\t\t\tscripts: [],\n\t\t\tenabled: src.data.enabled\n\t\t};\n\t\tconst scripts = src.data.scripts;\n\n\t\tfor (let i = 0, len = scripts.length; i < len; i++) {\n\t\t\tconst attributes = scripts[i].attributes;\n\n\t\t\tif (attributes) {\n\t\t\t\tdelete scripts[i].attributes;\n\t\t\t}\n\n\t\t\tdata.scripts.push(extend({}, scripts[i]));\n\n\t\t\tif (attributes) {\n\t\t\t\tdata.scripts[i].attributes = this._cloneAttributes(attributes);\n\t\t\t\tscripts[i].attributes = attributes;\n\t\t\t}\n\t\t}\n\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tif (component.enabled) {\n\t\t\tthis._disableScriptComponent(component);\n\t\t}\n\n\t\tthis._destroyScriptComponent(component);\n\t}\n\n\tonInitialize(root) {\n\t\tthis._registerInstances(root);\n\n\t\tif (root.enabled) {\n\t\t\tif (root.script && root.script.enabled) {\n\t\t\t\tthis._initializeScriptComponent(root.script);\n\t\t\t}\n\n\t\t\tconst children = root._children;\n\n\t\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\t\tthis.onInitialize(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonPostInitialize(root) {\n\t\tif (root.enabled) {\n\t\t\tif (root.script && root.script.enabled) {\n\t\t\t\tthis._postInitializeScriptComponent(root.script);\n\t\t\t}\n\n\t\t\tconst children = root._children;\n\n\t\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\t\tthis.onPostInitialize(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_callInstancesMethod(script, method) {\n\t\tconst instances = script.data.instances;\n\n\t\tfor (const name in instances) {\n\t\t\tif (instances.hasOwnProperty(name)) {\n\t\t\t\tconst instance = instances[name].instance;\n\n\t\t\t\tif (instance[method]) {\n\t\t\t\t\tinstance[method]();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_initializeScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, INITIALIZE);\n\n\t\tscript.data.initialized = true;\n\n\t\tif (script.enabled && script.entity.enabled) {\n\t\t\tthis._enableScriptComponent(script);\n\t\t}\n\t}\n\n\t_enableScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, ON_ENABLE);\n\t}\n\n\t_disableScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, ON_DISABLE);\n\t}\n\n\t_destroyScriptComponent(script) {\n\t\tconst instances = script.data.instances;\n\n\t\tfor (const name in instances) {\n\t\t\tif (instances.hasOwnProperty(name)) {\n\t\t\t\tconst instance = instances[name].instance;\n\n\t\t\t\tif (instance.destroy) {\n\t\t\t\t\tinstance.destroy();\n\t\t\t\t}\n\n\t\t\t\tif (instance.update) {\n\t\t\t\t\tconst index = this.instancesWithUpdate.indexOf(instance);\n\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (instance.fixedUpdate) {\n\t\t\t\t\tconst index = this.instancesWithFixedUpdate.indexOf(instance);\n\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithFixedUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (instance.postUpdate) {\n\t\t\t\t\tconst index = this.instancesWithPostUpdate.indexOf(instance);\n\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithPostUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (instance.toolsUpdate) {\n\t\t\t\t\tconst index = this.instancesWithToolsUpdate.indexOf(instance);\n\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithToolsUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (script.instances[name].instance === script[name]) {\n\t\t\t\t\tdelete script[name];\n\t\t\t\t}\n\n\t\t\t\tdelete script.instances[name];\n\t\t\t}\n\t\t}\n\t}\n\n\t_postInitializeScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, POST_INITIALIZE);\n\n\t\tscript.data.postInitialized = true;\n\t}\n\n\t_updateInstances(method, updateList, dt) {\n\t\tfor (let i = 0, len = updateList.length; i < len; i++) {\n\t\t\tconst item = updateList[i];\n\n\t\t\tif (item && item.entity && item.entity.enabled && item.entity.script.enabled) {\n\t\t\t\titem[method](dt);\n\t\t\t}\n\t\t}\n\t}\n\n\tonUpdate(dt) {\n\t\tthis._updateInstances(UPDATE, this.instancesWithUpdate, dt);\n\t}\n\n\tonFixedUpdate(dt) {\n\t\tthis._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);\n\t}\n\n\tonPostUpdate(dt) {\n\t\tthis._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);\n\t}\n\n\tonToolsUpdate(dt) {\n\t\tthis._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);\n\t}\n\n\tbroadcast(name, functionName) {\n\t\tconst args = Array.prototype.slice.call(arguments, 2);\n\t\tconst dataStore = this.store;\n\n\t\tfor (const id in dataStore) {\n\t\t\tif (dataStore.hasOwnProperty(id)) {\n\t\t\t\tconst data = dataStore[id].data;\n\n\t\t\t\tif (data.instances[name]) {\n\t\t\t\t\tconst fn = data.instances[name].instance[functionName];\n\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tfn.apply(data.instances[name].instance, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_preRegisterInstance(entity, url, name, instance) {\n\t\tif (entity.script) {\n\t\t\tentity.script.data._instances = entity.script.data._instances || {};\n\n\t\t\tif (entity.script.data._instances[name]) {\n\t\t\t\tthrow Error(`Script name collision '${name}'. Scripts from '${url}' and '${entity.script.data._instances[name].url}' {${entity.getGuid()}}`);\n\t\t\t}\n\n\t\t\tentity.script.data._instances[name] = {\n\t\t\t\turl: url,\n\t\t\t\tname: name,\n\t\t\t\tinstance: instance\n\t\t\t};\n\t\t}\n\t}\n\n\t_registerInstances(entity) {\n\t\tif (entity.script) {\n\t\t\tif (entity.script.data._instances) {\n\t\t\t\tentity.script.instances = entity.script.data._instances;\n\n\t\t\t\tfor (const instanceName in entity.script.instances) {\n\t\t\t\t\tconst preRegistered = entity.script.instances[instanceName];\n\t\t\t\t\tconst instance = preRegistered.instance;\n\t\t\t\t\tevents.attach(instance);\n\n\t\t\t\t\tif (instance.update) {\n\t\t\t\t\t\tthis.instancesWithUpdate.push(instance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (instance.fixedUpdate) {\n\t\t\t\t\t\tthis.instancesWithFixedUpdate.push(instance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (instance.postUpdate) {\n\t\t\t\t\t\tthis.instancesWithPostUpdate.push(instance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (instance.toolsUpdate) {\n\t\t\t\t\t\tthis.instancesWithToolsUpdate.push(instance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (entity.script.scripts) {\n\t\t\t\t\t\tthis._createAccessors(entity, preRegistered);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (entity.script[instanceName]) {\n\t\t\t\t\t\tthrow Error(`Script with name '${instanceName}' is already attached to Script Component`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentity.script[instanceName] = instance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdelete entity.script.data._instances;\n\t\t\t}\n\t\t}\n\n\t\tconst children = entity._children;\n\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\tthis._registerInstances(children[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t_cloneAttributes(attributes) {\n\t\tconst result = {};\n\n\t\tfor (const key in attributes) {\n\t\t\tif (!attributes.hasOwnProperty(key)) continue;\n\n\t\t\tif (attributes[key].type !== 'entity') {\n\t\t\t\tresult[key] = extend({}, attributes[key]);\n\t\t\t} else {\n\t\t\t\tconst val = attributes[key].value;\n\t\t\t\tdelete attributes[key].value;\n\t\t\t\tresult[key] = extend({}, attributes[key]);\n\t\t\t\tresult[key].value = val;\n\t\t\t\tattributes[key].value = val;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_createAccessors(entity, instance) {\n\t\tconst len = entity.script.scripts.length;\n\t\tconst url = instance.url;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst script = entity.script.scripts[i];\n\n\t\t\tif (script.url === url) {\n\t\t\t\tconst attributes = script.attributes;\n\n\t\t\t\tif (script.name && attributes) {\n\t\t\t\t\tfor (const key in attributes) {\n\t\t\t\t\t\tif (attributes.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tthis._createAccessor(attributes[key], instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tentity.script.data.attributes[script.name] = this._cloneAttributes(attributes);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_createAccessor(attribute, instance) {\n\t\tconst self = this;\n\t\tattribute = {\n\t\t\tname: attribute.name,\n\t\t\tvalue: attribute.value,\n\t\t\ttype: attribute.type\n\t\t};\n\n\t\tthis._convertAttributeValue(attribute);\n\n\t\tObject.defineProperty(instance.instance, attribute.name, {\n\t\t\tget: function () {\n\t\t\t\treturn attribute.value;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconst oldValue = attribute.value;\n\t\t\t\tattribute.value = value;\n\n\t\t\t\tself._convertAttributeValue(attribute);\n\n\t\t\t\tinstance.instance.fire(\"set\", attribute.name, oldValue, attribute.value);\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\n\t_updateAccessors(entity, instance) {\n\t\tconst len = entity.script.scripts.length;\n\t\tconst url = instance.url;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst scriptComponent = entity.script;\n\t\t\tconst script = scriptComponent.scripts[i];\n\n\t\t\tif (script.url === url) {\n\t\t\t\tconst name = script.name;\n\t\t\t\tconst attributes = script.attributes;\n\n\t\t\t\tif (name) {\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\tfor (const key in attributes) {\n\t\t\t\t\t\t\tif (attributes.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tthis._createAccessor(attributes[key], instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst previousAttributes = scriptComponent.data.attributes[name];\n\n\t\t\t\t\tif (previousAttributes) {\n\t\t\t\t\t\tfor (const key in previousAttributes) {\n\t\t\t\t\t\t\tconst oldAttribute = previousAttributes[key];\n\n\t\t\t\t\t\t\tif (!(key in attributes)) {\n\t\t\t\t\t\t\t\tdelete instance.instance[oldAttribute.name];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (attributes[key].value !== oldAttribute.value) {\n\t\t\t\t\t\t\t\t\tif (instance.instance.onAttributeChanged) {\n\t\t\t\t\t\t\t\t\t\tinstance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\tscriptComponent.data.attributes[name] = this._cloneAttributes(attributes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete scriptComponent.data.attributes[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_convertAttributeValue(attribute) {\n\t\tif (attribute.type === 'rgb' || attribute.type === 'rgba') {\n\t\t\tif (Array.isArray(attribute.value)) {\n\t\t\t\tattribute.value = attribute.value.length === 3 ? new Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);\n\t\t\t}\n\t\t} else if (attribute.type === 'vec2') {\n\t\t\tif (Array.isArray(attribute.value)) attribute.value = new Vec2(attribute.value[0], attribute.value[1]);\n\t\t} else if (attribute.type === 'vec3' || attribute.type === 'vector') {\n\t\t\tif (Array.isArray(attribute.value)) attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);\n\t\t} else if (attribute.type === 'vec4') {\n\t\t\tif (Array.isArray(attribute.value)) attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);\n\t\t} else if (attribute.type === 'entity') {\n\t\t\tif (attribute.value !== null && typeof attribute.value === 'string') attribute.value = this.app.root.findByGuid(attribute.value);\n\t\t} else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {\n\t\t\tconst curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;\n\t\t\tattribute.value = new curveType(attribute.value.keys);\n\t\t\tattribute.value.type = attribute.value.type;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off(INITIALIZE, this.onInitialize, this);\n\t\tthis.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);\n\t\tthis.app.systems.off(UPDATE, this.onUpdate, this);\n\t\tthis.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);\n\t\tthis.app.systems.off(POST_UPDATE, this.onPostUpdate, this);\n\t\tthis.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(ScriptLegacyComponent.prototype, _schema$5);\n\nconst _inputScreenPosition = new Vec2();\n\nconst _inputWorldPosition = new Vec3();\n\nconst _rayOrigin = new Vec3();\n\nconst _rayDirection = new Vec3();\n\nconst _planeOrigin = new Vec3();\n\nconst _planeNormal = new Vec3();\n\nconst _entityRotation = new Quat();\n\nconst OPPOSITE_AXIS = {\n\tx: 'y',\n\ty: 'x'\n};\n\nclass ElementDragHelper extends EventHandler {\n\tconstructor(element, axis) {\n\t\tsuper();\n\n\t\tif (!element || !(element instanceof ElementComponent)) {\n\t\t\tthrow new Error('Element was null or not an ElementComponent');\n\t\t}\n\n\t\tif (axis && axis !== 'x' && axis !== 'y') {\n\t\t\tthrow new Error('Unrecognized axis: ' + axis);\n\t\t}\n\n\t\tthis._element = element;\n\t\tthis._app = element.system.app;\n\t\tthis._axis = axis || null;\n\t\tthis._enabled = true;\n\t\tthis._dragScale = new Vec3();\n\t\tthis._dragStartMousePosition = new Vec3();\n\t\tthis._dragStartHandlePosition = new Vec3();\n\t\tthis._deltaMousePosition = new Vec3();\n\t\tthis._deltaHandlePosition = new Vec3();\n\t\tthis._isDragging = false;\n\n\t\tthis._toggleLifecycleListeners('on');\n\t}\n\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);\n\n\t\tthis._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);\n\t}\n\n\t_toggleDragListeners(onOrOff) {\n\t\tconst isOn = onOrOff === 'on';\n\t\tconst addOrRemoveEventListener = isOn ? 'addEventListener' : 'removeEventListener';\n\n\t\tif (this._hasDragListeners && isOn) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._handleMouseUpOrTouchEnd) {\n\t\t\tthis._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);\n\t\t}\n\n\t\tif (this._app.mouse) {\n\t\t\tthis._app.mouse[onOrOff]('mousemove', this._onMove, this);\n\n\t\t\twindow[addOrRemoveEventListener]('mouseup', this._handleMouseUpOrTouchEnd, false);\n\t\t}\n\n\t\tif (platform.touch) {\n\t\t\tthis._app.touch[onOrOff]('touchmove', this._onMove, this);\n\n\t\t\twindow[addOrRemoveEventListener]('touchend', this._handleMouseUpOrTouchEnd, false);\n\t\t\twindow[addOrRemoveEventListener]('touchcancel', this._handleMouseUpOrTouchEnd, false);\n\t\t}\n\n\t\tthis._hasDragListeners = isOn;\n\t}\n\n\t_onMouseDownOrTouchStart(event) {\n\t\tif (this._element && !this._isDragging && this.enabled) {\n\t\t\tthis._dragCamera = event.camera;\n\n\t\t\tthis._calculateDragScale();\n\n\t\t\tconst currentMousePosition = this._screenToLocal(event);\n\n\t\t\tif (currentMousePosition) {\n\t\t\t\tthis._toggleDragListeners('on');\n\n\t\t\t\tthis._isDragging = true;\n\n\t\t\t\tthis._dragStartMousePosition.copy(currentMousePosition);\n\n\t\t\t\tthis._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());\n\n\t\t\t\tthis.fire('drag:start');\n\t\t\t}\n\t\t}\n\t}\n\n\t_onMouseUpOrTouchEnd() {\n\t\tif (this._isDragging) {\n\t\t\tthis._isDragging = false;\n\n\t\t\tthis._toggleDragListeners('off');\n\n\t\t\tthis.fire('drag:end');\n\t\t}\n\t}\n\n\t_screenToLocal(event) {\n\t\tthis._determineInputPosition(event);\n\n\t\tthis._chooseRayOriginAndDirection();\n\n\t\t_planeOrigin.copy(this._element.entity.getPosition());\n\n\t\t_planeNormal.copy(this._element.entity.forward).mulScalar(-1);\n\n\t\tconst denominator = _planeNormal.dot(_rayDirection);\n\n\t\tif (Math.abs(denominator) > 0) {\n\t\t\tconst rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);\n\n\t\t\tconst collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;\n\n\t\t\tconst position = _rayOrigin.add(_rayDirection.mulScalar(collisionDistance));\n\n\t\t\t_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);\n\n\t\t\tposition.mul(this._dragScale);\n\t\t\treturn position;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_determineInputPosition(event) {\n\t\tconst devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;\n\n\t\tif (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {\n\t\t\t_inputScreenPosition.x = event.x * devicePixelRatio;\n\t\t\t_inputScreenPosition.y = event.y * devicePixelRatio;\n\t\t} else if (event.changedTouches) {\n\t\t\t_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;\n\t\t\t_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;\n\t\t} else {\n\t\t\tconsole.warn('Could not determine position from input event');\n\t\t}\n\t}\n\n\t_chooseRayOriginAndDirection() {\n\t\tif (this._element.screen && this._element.screen.screen.screenSpace) {\n\t\t\t_rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);\n\n\t\t\t_rayDirection.set(0, 0, -1);\n\t\t} else {\n\t\t\t_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));\n\n\t\t\t_rayOrigin.copy(this._dragCamera.entity.getPosition());\n\n\t\t\t_rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();\n\t\t}\n\t}\n\n\t_calculateDragScale() {\n\t\tlet current = this._element.entity.parent;\n\t\tconst screen = this._element.screen && this._element.screen.screen;\n\t\tconst isWithin2DScreen = screen && screen.screenSpace;\n\t\tconst screenScale = isWithin2DScreen ? screen.scale : 1;\n\t\tconst dragScale = this._dragScale;\n\t\tdragScale.set(screenScale, screenScale, screenScale);\n\n\t\twhile (current) {\n\t\t\tdragScale.mul(current.getLocalScale());\n\t\t\tcurrent = current.parent;\n\n\t\t\tif (isWithin2DScreen && current.screen) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdragScale.x = 1 / dragScale.x;\n\t\tdragScale.y = 1 / dragScale.y;\n\t\tdragScale.z = 1 / dragScale.z;\n\t}\n\n\t_onMove(event) {\n\t\tif (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {\n\t\t\tconst currentMousePosition = this._screenToLocal(event);\n\n\t\t\tif (this._dragStartMousePosition && currentMousePosition) {\n\t\t\t\tthis._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);\n\n\t\t\t\tthis._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);\n\n\t\t\t\tif (this._axis) {\n\t\t\t\t\tconst currentPosition = this._element.entity.getLocalPosition();\n\n\t\t\t\t\tconst constrainedAxis = OPPOSITE_AXIS[this._axis];\n\t\t\t\t\tthis._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];\n\t\t\t\t}\n\n\t\t\t\tthis._element.entity.setLocalPosition(this._deltaHandlePosition);\n\n\t\t\t\tthis.fire('drag:move', this._deltaHandlePosition);\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._toggleLifecycleListeners('off');\n\n\t\tthis._toggleDragListeners('off');\n\t}\n\n\tset enabled(value) {\n\t\tthis._enabled = value;\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tget isDragging() {\n\t\treturn this._isDragging;\n\t}\n\n}\n\nconst SCROLL_MODE_CLAMP = 0;\nconst SCROLL_MODE_BOUNCE = 1;\nconst SCROLL_MODE_INFINITE = 2;\nconst SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;\nconst SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;\n\nconst ACTION_MOUSE = 'mouse';\nconst ACTION_KEYBOARD = 'keyboard';\nconst ACTION_GAMEPAD = 'gamepad';\nconst AXIS_MOUSE_X = 'mousex';\nconst AXIS_MOUSE_Y = 'mousey';\nconst AXIS_PAD_L_X = 'padlx';\nconst AXIS_PAD_L_Y = 'padly';\nconst AXIS_PAD_R_X = 'padrx';\nconst AXIS_PAD_R_Y = 'padry';\nconst AXIS_KEY = 'key';\nconst EVENT_KEYDOWN = 'keydown';\nconst EVENT_KEYUP = 'keyup';\nconst EVENT_MOUSEDOWN = \"mousedown\";\nconst EVENT_MOUSEMOVE = \"mousemove\";\nconst EVENT_MOUSEUP = \"mouseup\";\nconst EVENT_MOUSEWHEEL = \"mousewheel\";\nconst EVENT_TOUCHSTART = 'touchstart';\nconst EVENT_TOUCHEND = 'touchend';\nconst EVENT_TOUCHMOVE = 'touchmove';\nconst EVENT_TOUCHCANCEL = 'touchcancel';\nconst EVENT_SELECT = 'select';\nconst EVENT_SELECTSTART = 'selectstart';\nconst EVENT_SELECTEND = 'selectend';\nconst KEY_BACKSPACE = 8;\nconst KEY_TAB = 9;\nconst KEY_RETURN = 13;\nconst KEY_ENTER = 13;\nconst KEY_SHIFT = 16;\nconst KEY_CONTROL = 17;\nconst KEY_ALT = 18;\nconst KEY_PAUSE = 19;\nconst KEY_CAPS_LOCK = 20;\nconst KEY_ESCAPE = 27;\nconst KEY_SPACE = 32;\nconst KEY_PAGE_UP = 33;\nconst KEY_PAGE_DOWN = 34;\nconst KEY_END = 35;\nconst KEY_HOME = 36;\nconst KEY_LEFT = 37;\nconst KEY_UP = 38;\nconst KEY_RIGHT = 39;\nconst KEY_DOWN = 40;\nconst KEY_PRINT_SCREEN = 44;\nconst KEY_INSERT = 45;\nconst KEY_DELETE = 46;\nconst KEY_0 = 48;\nconst KEY_1 = 49;\nconst KEY_2 = 50;\nconst KEY_3 = 51;\nconst KEY_4 = 52;\nconst KEY_5 = 53;\nconst KEY_6 = 54;\nconst KEY_7 = 55;\nconst KEY_8 = 56;\nconst KEY_9 = 57;\nconst KEY_SEMICOLON = 59;\nconst KEY_EQUAL = 61;\nconst KEY_A = 65;\nconst KEY_B = 66;\nconst KEY_C = 67;\nconst KEY_D = 68;\nconst KEY_E = 69;\nconst KEY_F = 70;\nconst KEY_G = 71;\nconst KEY_H = 72;\nconst KEY_I = 73;\nconst KEY_J = 74;\nconst KEY_K = 75;\nconst KEY_L = 76;\nconst KEY_M = 77;\nconst KEY_N = 78;\nconst KEY_O = 79;\nconst KEY_P = 80;\nconst KEY_Q = 81;\nconst KEY_R = 82;\nconst KEY_S = 83;\nconst KEY_T = 84;\nconst KEY_U = 85;\nconst KEY_V = 86;\nconst KEY_W = 87;\nconst KEY_X = 88;\nconst KEY_Y = 89;\nconst KEY_Z = 90;\nconst KEY_WINDOWS = 91;\nconst KEY_CONTEXT_MENU = 93;\nconst KEY_NUMPAD_0 = 96;\nconst KEY_NUMPAD_1 = 97;\nconst KEY_NUMPAD_2 = 98;\nconst KEY_NUMPAD_3 = 99;\nconst KEY_NUMPAD_4 = 100;\nconst KEY_NUMPAD_5 = 101;\nconst KEY_NUMPAD_6 = 102;\nconst KEY_NUMPAD_7 = 103;\nconst KEY_NUMPAD_8 = 104;\nconst KEY_NUMPAD_9 = 105;\nconst KEY_MULTIPLY = 106;\nconst KEY_ADD = 107;\nconst KEY_SEPARATOR = 108;\nconst KEY_SUBTRACT = 109;\nconst KEY_DECIMAL = 110;\nconst KEY_DIVIDE = 111;\nconst KEY_F1 = 112;\nconst KEY_F2 = 113;\nconst KEY_F3 = 114;\nconst KEY_F4 = 115;\nconst KEY_F5 = 116;\nconst KEY_F6 = 117;\nconst KEY_F7 = 118;\nconst KEY_F8 = 119;\nconst KEY_F9 = 120;\nconst KEY_F10 = 121;\nconst KEY_F11 = 122;\nconst KEY_F12 = 123;\nconst KEY_COMMA = 188;\nconst KEY_PERIOD = 190;\nconst KEY_SLASH = 191;\nconst KEY_OPEN_BRACKET = 219;\nconst KEY_BACK_SLASH = 220;\nconst KEY_CLOSE_BRACKET = 221;\nconst KEY_META = 224;\nconst MOUSEBUTTON_NONE = -1;\nconst MOUSEBUTTON_LEFT = 0;\nconst MOUSEBUTTON_MIDDLE = 1;\nconst MOUSEBUTTON_RIGHT = 2;\nconst PAD_1 = 0;\nconst PAD_2 = 1;\nconst PAD_3 = 2;\nconst PAD_4 = 3;\nconst PAD_FACE_1 = 0;\nconst PAD_FACE_2 = 1;\nconst PAD_FACE_3 = 2;\nconst PAD_FACE_4 = 3;\nconst PAD_L_SHOULDER_1 = 4;\nconst PAD_R_SHOULDER_1 = 5;\nconst PAD_L_SHOULDER_2 = 6;\nconst PAD_R_SHOULDER_2 = 7;\nconst PAD_SELECT = 8;\nconst PAD_START = 9;\nconst PAD_L_STICK_BUTTON = 10;\nconst PAD_R_STICK_BUTTON = 11;\nconst PAD_UP = 12;\nconst PAD_DOWN = 13;\nconst PAD_LEFT = 14;\nconst PAD_RIGHT = 15;\nconst PAD_VENDOR = 16;\nconst PAD_L_STICK_X = 0;\nconst PAD_L_STICK_Y = 1;\nconst PAD_R_STICK_X = 2;\nconst PAD_R_STICK_Y = 3;\n\nconst _tempScrollValue = new Vec2();\n\nclass ScrollViewComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._viewportReference = new EntityReference(this, 'viewportEntity', {\n\t\t\t'element#gain': this._onViewportElementGain,\n\t\t\t'element#resize': this._onSetContentOrViewportSize\n\t\t});\n\t\tthis._contentReference = new EntityReference(this, 'contentEntity', {\n\t\t\t'element#gain': this._onContentElementGain,\n\t\t\t'element#lose': this._onContentElementLose,\n\t\t\t'element#resize': this._onSetContentOrViewportSize\n\t\t});\n\t\tthis._scrollbarUpdateFlags = {};\n\t\tthis._scrollbarReferences = {};\n\t\tthis._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(this, 'horizontalScrollbarEntity', {\n\t\t\t'scrollbar#set:value': this._onSetHorizontalScrollbarValue,\n\t\t\t'scrollbar#gain': this._onHorizontalScrollbarGain\n\t\t});\n\t\tthis._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(this, 'verticalScrollbarEntity', {\n\t\t\t'scrollbar#set:value': this._onSetVerticalScrollbarValue,\n\t\t\t'scrollbar#gain': this._onVerticalScrollbarGain\n\t\t});\n\t\tthis._prevContentSizes = {};\n\t\tthis._prevContentSizes[ORIENTATION_HORIZONTAL] = null;\n\t\tthis._prevContentSizes[ORIENTATION_VERTICAL] = null;\n\t\tthis._scroll = new Vec2();\n\t\tthis._velocity = new Vec3();\n\t\tthis._dragStartPosition = new Vec3();\n\t\tthis._disabledContentInput = false;\n\t\tthis._disabledContentInputEntities = [];\n\n\t\tthis._toggleLifecycleListeners('on', system);\n\n\t\tthis._toggleElementListeners('on');\n\t}\n\n\t_toggleLifecycleListeners(onOrOff, system) {\n\t\tthis[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);\n\t\tthis[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);\n\t\tsystem.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);\n\t\tsystem.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);\n\t}\n\n\t_toggleElementListeners(onOrOff) {\n\t\tif (this.entity.element) {\n\t\t\tif (onOrOff === 'on' && this._hasElementListeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);\n\t\t\tthis.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);\n\t\t\tthis._hasElementListeners = onOrOff === 'on';\n\t\t}\n\t}\n\n\t_onElementComponentAdd(entity) {\n\t\tif (this.entity === entity) {\n\t\t\tthis._toggleElementListeners('on');\n\t\t}\n\t}\n\n\t_onElementComponentRemove(entity) {\n\t\tif (this.entity === entity) {\n\t\t\tthis._toggleElementListeners('off');\n\t\t}\n\t}\n\n\t_onViewportElementGain() {\n\t\tthis._syncAll();\n\t}\n\n\t_onContentElementGain() {\n\t\tthis._destroyDragHelper();\n\n\t\tthis._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);\n\n\t\tthis._contentDragHelper.on('drag:start', this._onContentDragStart, this);\n\n\t\tthis._contentDragHelper.on('drag:end', this._onContentDragEnd, this);\n\n\t\tthis._contentDragHelper.on('drag:move', this._onContentDragMove, this);\n\n\t\tthis._prevContentSizes[ORIENTATION_HORIZONTAL] = null;\n\t\tthis._prevContentSizes[ORIENTATION_VERTICAL] = null;\n\n\t\tthis._syncAll();\n\t}\n\n\t_onContentElementLose() {\n\t\tthis._destroyDragHelper();\n\t}\n\n\t_onContentDragStart() {\n\t\tif (this._contentReference.entity && this.enabled && this.entity.enabled) {\n\t\t\tthis._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());\n\t\t}\n\t}\n\n\t_onContentDragEnd() {\n\t\tthis._prevContentDragPosition = null;\n\n\t\tthis._enableContentInput();\n\t}\n\n\t_onContentDragMove(position) {\n\t\tif (this._contentReference.entity && this.enabled && this.entity.enabled) {\n\t\t\tthis._wasDragged = true;\n\n\t\t\tthis._setScrollFromContentPosition(position);\n\n\t\t\tthis._setVelocityFromContentPositionDelta(position);\n\n\t\t\tif (!this._disabledContentInput) {\n\t\t\t\tconst dx = position.x - this._dragStartPosition.x;\n\t\t\t\tconst dy = position.y - this._dragStartPosition.y;\n\n\t\t\t\tif (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {\n\t\t\t\t\tthis._disableContentInput();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSetContentOrViewportSize() {\n\t\tthis._syncAll();\n\t}\n\n\t_onSetHorizontalScrollbarValue(scrollValueX) {\n\t\tif (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {\n\t\t\tthis._onSetScroll(scrollValueX, null);\n\t\t}\n\t}\n\n\t_onSetVerticalScrollbarValue(scrollValueY) {\n\t\tif (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {\n\t\t\tthis._onSetScroll(null, scrollValueY);\n\t\t}\n\t}\n\n\t_onSetHorizontalScrollingEnabled() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\t}\n\n\t_onSetVerticalScrollingEnabled() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t}\n\n\t_onHorizontalScrollbarGain() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\n\t\tthis._syncScrollbarPosition(ORIENTATION_HORIZONTAL);\n\t}\n\n\t_onVerticalScrollbarGain() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\n\t\tthis._syncScrollbarPosition(ORIENTATION_VERTICAL);\n\t}\n\n\t_onSetScroll(x, y, resetVelocity) {\n\t\tif (resetVelocity !== false) {\n\t\t\tthis._velocity.set(0, 0, 0);\n\t\t}\n\n\t\tlet hasChanged = false;\n\t\thasChanged |= this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);\n\t\thasChanged |= this._updateAxis(y, 'y', ORIENTATION_VERTICAL);\n\n\t\tif (hasChanged) {\n\t\t\tthis.fire('set:scroll', this._scroll);\n\t\t}\n\t}\n\n\t_updateAxis(scrollValue, axis, orientation) {\n\t\tconst hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;\n\n\t\tif (hasChanged || this._isDragging() || scrollValue === 0) {\n\t\t\tthis._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);\n\n\t\t\tthis._syncContentPosition(orientation);\n\n\t\t\tthis._syncScrollbarPosition(orientation);\n\t\t}\n\n\t\treturn hasChanged;\n\t}\n\n\t_determineNewScrollValue(scrollValue, axis, orientation) {\n\t\tif (!this._getScrollingEnabled(orientation)) {\n\t\t\treturn this._scroll[axis];\n\t\t}\n\n\t\tswitch (this.scrollMode) {\n\t\t\tcase SCROLL_MODE_CLAMP:\n\t\t\t\treturn math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));\n\n\t\t\tcase SCROLL_MODE_BOUNCE:\n\t\t\t\tthis._setVelocityFromOvershoot(scrollValue, axis, orientation);\n\n\t\t\t\treturn scrollValue;\n\n\t\t\tcase SCROLL_MODE_INFINITE:\n\t\t\t\treturn scrollValue;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('Unhandled scroll mode:' + this.scrollMode);\n\t\t\t\treturn scrollValue;\n\t\t}\n\t}\n\n\t_syncAll() {\n\t\tthis._syncContentPosition(ORIENTATION_HORIZONTAL);\n\n\t\tthis._syncContentPosition(ORIENTATION_VERTICAL);\n\n\t\tthis._syncScrollbarPosition(ORIENTATION_HORIZONTAL);\n\n\t\tthis._syncScrollbarPosition(ORIENTATION_VERTICAL);\n\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t}\n\n\t_syncContentPosition(orientation) {\n\t\tconst axis = this._getAxis(orientation);\n\n\t\tconst sign = this._getSign(orientation);\n\n\t\tconst contentEntity = this._contentReference.entity;\n\n\t\tif (contentEntity) {\n\t\t\tconst prevContentSize = this._prevContentSizes[orientation];\n\n\t\t\tconst currContentSize = this._getContentSize(orientation);\n\n\t\t\tif (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {\n\t\t\t\tconst prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);\n\n\t\t\t\tconst currMaxOffset = this._getMaxOffset(orientation, currContentSize);\n\n\t\t\t\tif (currMaxOffset === 0) {\n\t\t\t\t\tthis._scroll[axis] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tthis._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst offset = this._scroll[axis] * this._getMaxOffset(orientation);\n\n\t\t\tconst contentPosition = contentEntity.getLocalPosition();\n\t\t\tcontentPosition[axis] = offset * sign;\n\t\t\tcontentEntity.setLocalPosition(contentPosition);\n\t\t\tthis._prevContentSizes[orientation] = currContentSize;\n\t\t}\n\t}\n\n\t_syncScrollbarPosition(orientation) {\n\t\tconst axis = this._getAxis(orientation);\n\n\t\tconst scrollbarEntity = this._scrollbarReferences[orientation].entity;\n\n\t\tif (scrollbarEntity && scrollbarEntity.scrollbar) {\n\t\t\tthis._scrollbarUpdateFlags[orientation] = true;\n\t\t\tscrollbarEntity.scrollbar.value = this._scroll[axis];\n\t\t\tscrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);\n\t\t\tthis._scrollbarUpdateFlags[orientation] = false;\n\t\t}\n\t}\n\n\t_syncScrollbarEnabledState(orientation) {\n\t\tconst entity = this._scrollbarReferences[orientation].entity;\n\n\t\tif (entity) {\n\t\t\tconst isScrollingEnabled = this._getScrollingEnabled(orientation);\n\n\t\t\tconst requestedVisibility = this._getScrollbarVisibility(orientation);\n\n\t\t\tswitch (requestedVisibility) {\n\t\t\t\tcase SCROLLBAR_VISIBILITY_SHOW_ALWAYS:\n\t\t\t\t\tentity.enabled = isScrollingEnabled;\n\t\t\t\t\treturn;\n\n\t\t\t\tcase SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:\n\t\t\t\t\tentity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);\n\t\t\t\t\treturn;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('Unhandled scrollbar visibility:' + requestedVisibility);\n\t\t\t\t\tentity.enabled = isScrollingEnabled;\n\t\t\t}\n\t\t}\n\t}\n\n\t_contentIsLargerThanViewport(orientation) {\n\t\treturn this._getContentSize(orientation) > this._getViewportSize(orientation);\n\t}\n\n\t_contentPositionToScrollValue(contentPosition) {\n\t\tconst maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);\n\n\t\tconst maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);\n\n\t\tif (maxOffsetH === 0) {\n\t\t\t_tempScrollValue.x = 0;\n\t\t} else {\n\t\t\t_tempScrollValue.x = contentPosition.x / maxOffsetH;\n\t\t}\n\n\t\tif (maxOffsetV === 0) {\n\t\t\t_tempScrollValue.y = 0;\n\t\t} else {\n\t\t\t_tempScrollValue.y = contentPosition.y / -maxOffsetV;\n\t\t}\n\n\t\treturn _tempScrollValue;\n\t}\n\n\t_getMaxOffset(orientation, contentSize) {\n\t\tcontentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;\n\n\t\tconst viewportSize = this._getViewportSize(orientation);\n\n\t\tif (contentSize < viewportSize) {\n\t\t\treturn -this._getViewportSize(orientation);\n\t\t}\n\n\t\treturn viewportSize - contentSize;\n\t}\n\n\t_getMaxScrollValue(orientation) {\n\t\treturn this._contentIsLargerThanViewport(orientation) ? 1 : 0;\n\t}\n\n\t_getScrollbarHandleSize(axis, orientation) {\n\t\tconst viewportSize = this._getViewportSize(orientation);\n\n\t\tconst contentSize = this._getContentSize(orientation);\n\n\t\tif (Math.abs(contentSize) < 0.001) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst handleSize = Math.min(viewportSize / contentSize, 1);\n\n\t\tconst overshoot = this._toOvershoot(this._scroll[axis], orientation);\n\n\t\tif (overshoot === 0) {\n\t\t\treturn handleSize;\n\t\t}\n\n\t\treturn handleSize / (1 + Math.abs(overshoot));\n\t}\n\n\t_getViewportSize(orientation) {\n\t\treturn this._getSize(orientation, this._viewportReference);\n\t}\n\n\t_getContentSize(orientation) {\n\t\treturn this._getSize(orientation, this._contentReference);\n\t}\n\n\t_getSize(orientation, entityReference) {\n\t\tif (entityReference.entity && entityReference.entity.element) {\n\t\t\treturn entityReference.entity.element[this._getCalculatedDimension(orientation)];\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_getScrollingEnabled(orientation) {\n\t\tif (orientation === ORIENTATION_HORIZONTAL) {\n\t\t\treturn this.horizontal;\n\t\t} else if (orientation === ORIENTATION_VERTICAL) {\n\t\t\treturn this.vertical;\n\t\t}\n\n\t\tconsole.warn('Unrecognized orientation: ' + orientation);\n\t}\n\n\t_getScrollbarVisibility(orientation) {\n\t\tif (orientation === ORIENTATION_HORIZONTAL) {\n\t\t\treturn this.horizontalScrollbarVisibility;\n\t\t} else if (orientation === ORIENTATION_VERTICAL) {\n\t\t\treturn this.verticalScrollbarVisibility;\n\t\t}\n\n\t\tconsole.warn('Unrecognized orientation: ' + orientation);\n\t}\n\n\t_getSign(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 1 : -1;\n\t}\n\n\t_getAxis(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';\n\t}\n\n\t_getCalculatedDimension(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';\n\t}\n\n\t_destroyDragHelper() {\n\t\tif (this._contentDragHelper) {\n\t\t\tthis._contentDragHelper.destroy();\n\t\t}\n\t}\n\n\tonUpdate() {\n\t\tif (this._contentReference.entity) {\n\t\t\tthis._updateVelocity();\n\n\t\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\n\t\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t\t}\n\t}\n\n\t_updateVelocity() {\n\t\tif (!this._isDragging()) {\n\t\t\tif (this.scrollMode === SCROLL_MODE_BOUNCE) {\n\t\t\t\tif (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {\n\t\t\t\t\tthis._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);\n\t\t\t\t}\n\n\t\t\t\tif (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {\n\t\t\t\t\tthis._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {\n\t\t\t\tconst position = this._contentReference.entity.getLocalPosition();\n\n\t\t\t\tposition.x += this._velocity.x;\n\t\t\t\tposition.y += this._velocity.y;\n\n\t\t\t\tthis._contentReference.entity.setLocalPosition(position);\n\n\t\t\t\tthis._setScrollFromContentPosition(position);\n\t\t\t}\n\n\t\t\tthis._velocity.x *= 1 - this.friction;\n\t\t\tthis._velocity.y *= 1 - this.friction;\n\t\t}\n\t}\n\n\t_hasOvershoot(axis, orientation) {\n\t\treturn Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;\n\t}\n\n\t_toOvershoot(scrollValue, orientation) {\n\t\tconst maxScrollValue = this._getMaxScrollValue(orientation);\n\n\t\tif (scrollValue < 0) {\n\t\t\treturn scrollValue;\n\t\t} else if (scrollValue > maxScrollValue) {\n\t\t\treturn scrollValue - maxScrollValue;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_setVelocityFromOvershoot(scrollValue, axis, orientation) {\n\t\tconst overshootValue = this._toOvershoot(scrollValue, orientation);\n\n\t\tconst overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);\n\n\t\tif (Math.abs(overshootPixels) > 0) {\n\t\t\tthis._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);\n\t\t}\n\t}\n\n\t_setVelocityFromContentPositionDelta(position) {\n\t\tif (this._prevContentDragPosition) {\n\t\t\tthis._velocity.sub2(position, this._prevContentDragPosition);\n\n\t\t\tthis._prevContentDragPosition.copy(position);\n\t\t} else {\n\t\t\tthis._velocity.set(0, 0, 0);\n\n\t\t\tthis._prevContentDragPosition = position.clone();\n\t\t}\n\t}\n\n\t_setScrollFromContentPosition(position) {\n\t\tlet scrollValue = this._contentPositionToScrollValue(position);\n\n\t\tif (this._isDragging()) {\n\t\t\tscrollValue = this._applyScrollValueTension(scrollValue);\n\t\t}\n\n\t\tthis._onSetScroll(scrollValue.x, scrollValue.y, false);\n\t}\n\n\t_applyScrollValueTension(scrollValue) {\n\t\tconst factor = 1;\n\n\t\tlet max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);\n\n\t\tlet overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);\n\n\t\tif (overshoot > 0) {\n\t\t\tscrollValue.x = max + factor * Math.log10(1 + overshoot);\n\t\t} else if (overshoot < 0) {\n\t\t\tscrollValue.x = -factor * Math.log10(1 - overshoot);\n\t\t}\n\n\t\tmax = this._getMaxScrollValue(ORIENTATION_VERTICAL);\n\t\tovershoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);\n\n\t\tif (overshoot > 0) {\n\t\t\tscrollValue.y = max + factor * Math.log10(1 + overshoot);\n\t\t} else if (overshoot < 0) {\n\t\t\tscrollValue.y = -factor * Math.log10(1 - overshoot);\n\t\t}\n\n\t\treturn scrollValue;\n\t}\n\n\t_isDragging() {\n\t\treturn this._contentDragHelper && this._contentDragHelper.isDragging;\n\t}\n\n\t_setScrollbarComponentsEnabled(enabled) {\n\t\tif (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {\n\t\t\tthis._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;\n\t\t}\n\n\t\tif (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {\n\t\t\tthis._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;\n\t\t}\n\t}\n\n\t_setContentDraggingEnabled(enabled) {\n\t\tif (this._contentDragHelper) {\n\t\t\tthis._contentDragHelper.enabled = enabled;\n\t\t}\n\t}\n\n\t_onMouseWheel(event) {\n\t\tif (this.useMouseWheel) {\n\t\t\tconst wheelEvent = event.event;\n\t\t\tconst normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;\n\t\t\tconst normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;\n\t\t\tconst scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));\n\t\t\tconst scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));\n\t\t\tthis.scroll = new Vec2(scrollX, scrollY);\n\t\t}\n\t}\n\n\t_enableContentInput() {\n\t\twhile (this._disabledContentInputEntities.length) {\n\t\t\tconst e = this._disabledContentInputEntities.pop();\n\n\t\t\tif (e.element) {\n\t\t\t\te.element.useInput = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._disabledContentInput = false;\n\t}\n\n\t_disableContentInput() {\n\t\tconst _disableInput = e => {\n\t\t\tif (e.element && e.element.useInput) {\n\t\t\t\tthis._disabledContentInputEntities.push(e);\n\n\t\t\t\te.element.useInput = false;\n\t\t\t}\n\n\t\t\tconst children = e.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t_disableInput(children[i]);\n\t\t\t}\n\t\t};\n\n\t\tconst contentEntity = this._contentReference.entity;\n\n\t\tif (contentEntity) {\n\t\t\tconst children = contentEntity.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t_disableInput(children[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis._disabledContentInput = true;\n\t}\n\n\tonEnable() {\n\t\tthis._viewportReference.onParentComponentEnable();\n\n\t\tthis._contentReference.onParentComponentEnable();\n\n\t\tthis._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();\n\n\t\tthis._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();\n\n\t\tthis._setScrollbarComponentsEnabled(true);\n\n\t\tthis._setContentDraggingEnabled(true);\n\n\t\tthis._syncAll();\n\t}\n\n\tonDisable() {\n\t\tthis._setScrollbarComponentsEnabled(false);\n\n\t\tthis._setContentDraggingEnabled(false);\n\t}\n\n\tonRemove() {\n\t\tthis._toggleLifecycleListeners('off', this.system);\n\n\t\tthis._toggleElementListeners('off');\n\n\t\tthis._destroyDragHelper();\n\t}\n\n\tset scroll(value) {\n\t\tthis._onSetScroll(value.x, value.y);\n\t}\n\n\tget scroll() {\n\t\treturn this._scroll;\n\t}\n\n}\n\nclass ScrollViewComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$4 = [{\n\tname: 'enabled',\n\ttype: 'boolean'\n}, {\n\tname: 'horizontal',\n\ttype: 'boolean'\n}, {\n\tname: 'vertical',\n\ttype: 'boolean'\n}, {\n\tname: 'scrollMode',\n\ttype: 'number'\n}, {\n\tname: 'bounceAmount',\n\ttype: 'number'\n}, {\n\tname: 'friction',\n\ttype: 'number'\n}, {\n\tname: 'dragThreshold',\n\ttype: 'number'\n}, {\n\tname: 'useMouseWheel',\n\ttype: 'boolean'\n}, {\n\tname: 'mouseWheelSensitivity',\n\ttype: 'vec2'\n}, {\n\tname: 'horizontalScrollbarVisibility',\n\ttype: 'number'\n}, {\n\tname: 'verticalScrollbarVisibility',\n\ttype: 'number'\n}, {\n\tname: 'viewportEntity',\n\ttype: 'entity'\n}, {\n\tname: 'contentEntity',\n\ttype: 'entity'\n}, {\n\tname: 'horizontalScrollbarEntity',\n\ttype: 'entity'\n}, {\n\tname: 'verticalScrollbarEntity',\n\ttype: 'entity'\n}];\nconst DEFAULT_DRAG_THRESHOLD = 10;\n\nclass ScrollViewComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'scrollview';\n\t\tthis.ComponentType = ScrollViewComponent;\n\t\tthis.DataType = ScrollViewComponentData;\n\t\tthis.schema = _schema$4;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.dragThreshold === undefined) {\n\t\t\tdata.dragThreshold = DEFAULT_DRAG_THRESHOLD;\n\t\t}\n\n\t\tif (data.useMouseWheel === undefined) {\n\t\t\tdata.useMouseWheel = true;\n\t\t}\n\n\t\tif (data.mouseWheelSensitivity === undefined) {\n\t\t\tdata.mouseWheelSensitivity = new Vec2(1, 1);\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, _schema$4);\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tconst entity = components[id].entity;\n\t\t\tconst component = entity.scrollview;\n\n\t\t\tif (component.enabled && entity.enabled) {\n\t\t\t\tcomponent.onUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(ScrollViewComponent.prototype, _schema$4);\n\nclass ScrollbarComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._app = system.app;\n\t\tthis._handleReference = new EntityReference(this, 'handleEntity', {\n\t\t\t'element#gain': this._onHandleElementGain,\n\t\t\t'element#lose': this._onHandleElementLose,\n\t\t\t'element#set:anchor': this._onSetHandleAlignment,\n\t\t\t'element#set:margin': this._onSetHandleAlignment,\n\t\t\t'element#set:pivot': this._onSetHandleAlignment\n\t\t});\n\n\t\tthis._toggleLifecycleListeners('on');\n\t}\n\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis[onOrOff]('set_value', this._onSetValue, this);\n\t\tthis[onOrOff]('set_handleSize', this._onSetHandleSize, this);\n\t\tthis[onOrOff]('set_orientation', this._onSetOrientation, this);\n\t}\n\n\t_onHandleElementGain() {\n\t\tthis._destroyDragHelper();\n\n\t\tthis._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());\n\n\t\tthis._handleDragHelper.on('drag:move', this._onHandleDrag, this);\n\n\t\tthis._updateHandlePositionAndSize();\n\t}\n\n\t_onHandleElementLose() {\n\t\tthis._destroyDragHelper();\n\t}\n\n\t_onHandleDrag(position) {\n\t\tif (this._handleReference.entity && this.enabled && this.entity.enabled) {\n\t\t\tthis.value = this._handlePositionToScrollValue(position[this._getAxis()]);\n\t\t}\n\t}\n\n\t_onSetValue(name, oldValue, newValue) {\n\t\tif (Math.abs(newValue - oldValue) > 1e-5) {\n\t\t\tthis.data.value = math.clamp(newValue, 0, 1);\n\n\t\t\tthis._updateHandlePositionAndSize();\n\n\t\t\tthis.fire('set:value', this.data.value);\n\t\t}\n\t}\n\n\t_onSetHandleSize(name, oldValue, newValue) {\n\t\tif (Math.abs(newValue - oldValue) > 1e-5) {\n\t\t\tthis.data.handleSize = math.clamp(newValue, 0, 1);\n\n\t\t\tthis._updateHandlePositionAndSize();\n\t\t}\n\t}\n\n\t_onSetHandleAlignment() {\n\t\tthis._updateHandlePositionAndSize();\n\t}\n\n\t_onSetOrientation(name, oldValue, newValue) {\n\t\tif (newValue !== oldValue && this._handleReference.hasComponent('element')) {\n\t\t\tthis._handleReference.entity.element[this._getOppositeDimension()] = 0;\n\t\t}\n\t}\n\n\t_updateHandlePositionAndSize() {\n\t\tconst handleEntity = this._handleReference.entity;\n\t\tconst handleElement = handleEntity && handleEntity.element;\n\n\t\tif (handleEntity) {\n\t\t\tconst position = handleEntity.getLocalPosition();\n\t\t\tposition[this._getAxis()] = this._getHandlePosition();\n\n\t\t\tthis._handleReference.entity.setLocalPosition(position);\n\t\t}\n\n\t\tif (handleElement) {\n\t\t\thandleElement[this._getDimension()] = this._getHandleLength();\n\t\t}\n\t}\n\n\t_handlePositionToScrollValue(handlePosition) {\n\t\treturn handlePosition * this._getSign() / this._getUsableTrackLength();\n\t}\n\n\t_scrollValueToHandlePosition(value) {\n\t\treturn value * this._getSign() * this._getUsableTrackLength();\n\t}\n\n\t_getUsableTrackLength() {\n\t\treturn Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);\n\t}\n\n\t_getTrackLength() {\n\t\tif (this.entity.element) {\n\t\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_getHandleLength() {\n\t\treturn this._getTrackLength() * this.handleSize;\n\t}\n\n\t_getHandlePosition() {\n\t\treturn this._scrollValueToHandlePosition(this.value);\n\t}\n\n\t_getSign() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;\n\t}\n\n\t_getAxis() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';\n\t}\n\n\t_getDimension() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';\n\t}\n\n\t_getOppositeDimension() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';\n\t}\n\n\t_destroyDragHelper() {\n\t\tif (this._handleDragHelper) {\n\t\t\tthis._handleDragHelper.destroy();\n\t\t}\n\t}\n\n\t_setHandleDraggingEnabled(enabled) {\n\t\tif (this._handleDragHelper) {\n\t\t\tthis._handleDragHelper.enabled = enabled;\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tthis._handleReference.onParentComponentEnable();\n\n\t\tthis._setHandleDraggingEnabled(true);\n\t}\n\n\tonDisable() {\n\t\tthis._setHandleDraggingEnabled(false);\n\t}\n\n\tonRemove() {\n\t\tthis._destroyDragHelper();\n\n\t\tthis._toggleLifecycleListeners('off');\n\t}\n\n}\n\nclass ScrollbarComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$3 = [{\n\tname: 'enabled',\n\ttype: 'boolean'\n}, {\n\tname: 'orientation',\n\ttype: 'number'\n}, {\n\tname: 'value',\n\ttype: 'number'\n}, {\n\tname: 'handleSize',\n\ttype: 'number'\n}, {\n\tname: 'handleEntity',\n\ttype: 'entity'\n}];\n\nclass ScrollbarComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'scrollbar';\n\t\tthis.ComponentType = ScrollbarComponent;\n\t\tthis.DataType = ScrollbarComponentData;\n\t\tthis.schema = _schema$3;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tsuper.initializeComponentData(component, data, _schema$3);\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n}\n\nComponent._buildAccessors(ScrollbarComponent.prototype, _schema$3);\n\nconst STATE_PLAYING = 0;\nconst STATE_PAUSED = 1;\nconst STATE_STOPPED = 2;\n\nfunction capTime(time, duration) {\n\treturn time % duration || 0;\n}\n\nclass SoundInstance extends EventHandler {\n\tconstructor(manager, sound, options) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;\n\t\tthis._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;\n\t\tthis._loop = !!(options.loop !== undefined ? options.loop : false);\n\t\tthis._sound = sound;\n\t\tthis._state = STATE_STOPPED;\n\t\tthis._suspended = false;\n\t\tthis._suspendEndEvent = false;\n\t\tthis._suspendInstanceEvents = false;\n\t\tthis._playWhenLoaded = true;\n\t\tthis._startTime = Math.max(0, Number(options.startTime) || 0);\n\t\tthis._duration = Math.max(0, Number(options.duration) || 0);\n\t\tthis._startOffset = null;\n\t\tthis.source = null;\n\t\tthis._onPlayCallback = options.onPlay;\n\t\tthis._onPauseCallback = options.onPause;\n\t\tthis._onResumeCallback = options.onResume;\n\t\tthis._onStopCallback = options.onStop;\n\t\tthis._onEndCallback = options.onEnd;\n\n\t\tif (hasAudioContext()) {\n\t\t\tthis._startedAt = 0;\n\t\t\tthis._currentTime = 0;\n\t\t\tthis._currentOffset = 0;\n\t\t\tthis._inputNode = null;\n\t\t\tthis._connectorNode = null;\n\t\t\tthis._firstNode = null;\n\t\t\tthis._lastNode = null;\n\n\t\t\tthis._initializeNodes();\n\n\t\t\tthis._endedHandler = this._onEnded.bind(this);\n\t\t} else {\n\t\t\tthis._isReady = false;\n\t\t\tthis._loadedMetadataHandler = this._onLoadedMetadata.bind(this);\n\t\t\tthis._timeUpdateHandler = this._onTimeUpdate.bind(this);\n\t\t\tthis._endedHandler = this._onEnded.bind(this);\n\n\t\t\tthis._createSource();\n\t\t}\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = Math.max(0, Number(value) || 0);\n\t\tconst isPlaying = this._state === STATE_PLAYING;\n\t\tthis.stop();\n\n\t\tif (isPlaying) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\n\tget duration() {\n\t\tif (!this._sound) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (this._duration) {\n\t\t\treturn capTime(this._duration, this._sound.duration);\n\t\t}\n\n\t\treturn this._sound.duration;\n\t}\n\n\tget isPaused() {\n\t\treturn this._state === STATE_PAUSED;\n\t}\n\n\tget isPlaying() {\n\t\treturn this._state === STATE_PLAYING;\n\t}\n\n\tget isStopped() {\n\t\treturn this._state === STATE_STOPPED;\n\t}\n\n\tget isSuspended() {\n\t\treturn this._suspended;\n\t}\n\n\tset loop(value) {\n\t\tthis._loop = !!value;\n\n\t\tif (this.source) {\n\t\t\tthis.source.loop = this._loop;\n\t\t}\n\t}\n\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\n\tset startTime(value) {\n\t\tthis._startTime = Math.max(0, Number(value) || 0);\n\t\tconst isPlaying = this._state === STATE_PLAYING;\n\t\tthis.stop();\n\n\t\tif (isPlaying) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\n\tget startTime() {\n\t\treturn this._startTime;\n\t}\n\n\t_onPlay() {\n\t\tthis.fire('play');\n\t\tif (this._onPlayCallback) this._onPlayCallback(this);\n\t}\n\n\t_onPause() {\n\t\tthis.fire('pause');\n\t\tif (this._onPauseCallback) this._onPauseCallback(this);\n\t}\n\n\t_onResume() {\n\t\tthis.fire('resume');\n\t\tif (this._onResumeCallback) this._onResumeCallback(this);\n\t}\n\n\t_onStop() {\n\t\tthis.fire('stop');\n\t\tif (this._onStopCallback) this._onStopCallback(this);\n\t}\n\n\t_onEnded() {\n\t\tif (this._suspendEndEvent) {\n\t\t\tthis._suspendEndEvent = false;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fire('end');\n\t\tif (this._onEndCallback) this._onEndCallback(this);\n\t\tthis.stop();\n\t}\n\n\t_onManagerVolumeChange() {\n\t\tthis.volume = this._volume;\n\t}\n\n\t_onManagerSuspend() {\n\t\tif (this._state === STATE_PLAYING && !this._suspended) {\n\t\t\tthis._suspended = true;\n\t\t\tthis.pause();\n\t\t}\n\t}\n\n\t_onManagerResume() {\n\t\tif (this._suspended) {\n\t\t\tthis._suspended = false;\n\t\t\tthis.resume();\n\t\t}\n\t}\n\n}\n\nif (hasAudioContext()) {\n\tObject.assign(SoundInstance.prototype, {\n\t\t_initializeNodes: function () {\n\t\t\tthis.gain = this._manager.context.createGain();\n\t\t\tthis._inputNode = this.gain;\n\t\t\tthis._connectorNode = this.gain;\n\n\t\t\tthis._connectorNode.connect(this._manager.context.destination);\n\t\t},\n\t\tplay: function () {\n\t\t\tif (this._state !== STATE_STOPPED) {\n\t\t\t\tthis.stop();\n\t\t\t}\n\n\t\t\tif (!this.source) {\n\t\t\t\tthis._createSource();\n\t\t\t}\n\n\t\t\tlet offset = capTime(this._startOffset, this.duration);\n\t\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\t\tthis._startOffset = null;\n\n\t\t\tif (this._duration) {\n\t\t\t\tthis.source.start(0, offset, this._duration);\n\t\t\t} else {\n\t\t\t\tthis.source.start(0, offset);\n\t\t\t}\n\n\t\t\tthis._startedAt = this._manager.context.currentTime;\n\t\t\tthis._currentTime = 0;\n\t\t\tthis._currentOffset = offset;\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis.volume = this._volume;\n\t\t\tthis.loop = this._loop;\n\t\t\tthis.pitch = this._pitch;\n\n\t\t\tthis._manager.on('volumechange', this._onManagerVolumeChange, this);\n\n\t\t\tthis._manager.on('suspend', this._onManagerSuspend, this);\n\n\t\t\tthis._manager.on('resume', this._onManagerResume, this);\n\n\t\t\tthis._manager.on('destroy', this._onManagerDestroy, this);\n\n\t\t\tif (this._manager.suspended) {\n\t\t\t\tthis._onManagerSuspend();\n\t\t\t}\n\n\t\t\tif (!this._suspendInstanceEvents) this._onPlay();\n\t\t\treturn true;\n\t\t},\n\t\tpause: function () {\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tif (this._state !== STATE_PLAYING || !this.source) return false;\n\n\t\t\tthis._updateCurrentTime();\n\n\t\t\tthis._state = STATE_PAUSED;\n\t\t\tthis._suspendEndEvent = true;\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t\tthis._startOffset = null;\n\t\t\tif (!this._suspendInstanceEvents) this._onPause();\n\t\t\treturn true;\n\t\t},\n\t\tresume: function () {\n\t\t\tif (this._state !== STATE_PAUSED) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.source) {\n\t\t\t\tthis._createSource();\n\t\t\t}\n\n\t\t\tlet offset = this.currentTime;\n\n\t\t\tif (this._startOffset !== null) {\n\t\t\t\toffset = capTime(this._startOffset, this.duration);\n\t\t\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\t\t\tthis._startOffset = null;\n\t\t\t}\n\n\t\t\tif (this._duration) {\n\t\t\t\tthis.source.start(0, offset, this._duration);\n\t\t\t} else {\n\t\t\t\tthis.source.start(0, offset);\n\t\t\t}\n\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._startedAt = this._manager.context.currentTime;\n\t\t\tthis._currentOffset = offset;\n\t\t\tthis.volume = this._volume;\n\t\t\tthis.loop = this._loop;\n\t\t\tthis.pitch = this._pitch;\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tif (!this._suspendInstanceEvents) this._onResume();\n\t\t\treturn true;\n\t\t},\n\t\tstop: function () {\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tif (this._state === STATE_STOPPED || !this.source) return false;\n\n\t\t\tthis._manager.off('volumechange', this._onManagerVolumeChange, this);\n\n\t\t\tthis._manager.off('suspend', this._onManagerSuspend, this);\n\n\t\t\tthis._manager.off('resume', this._onManagerResume, this);\n\n\t\t\tthis._manager.off('destroy', this._onManagerDestroy, this);\n\n\t\t\tthis._startedAt = 0;\n\t\t\tthis._currentTime = 0;\n\t\t\tthis._currentOffset = 0;\n\t\t\tthis._startOffset = null;\n\t\t\tthis._suspendEndEvent = true;\n\n\t\t\tif (this._state === STATE_PLAYING) {\n\t\t\t\tthis.source.stop(0);\n\t\t\t}\n\n\t\t\tthis.source = null;\n\t\t\tthis._state = STATE_STOPPED;\n\t\t\tif (!this._suspendInstanceEvents) this._onStop();\n\t\t\treturn true;\n\t\t},\n\t\tsetExternalNodes: function (firstNode, lastNode) {\n\t\t\tif (!firstNode) {\n\t\t\t\tconsole.error('The firstNode must be a valid Audio Node');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!lastNode) {\n\t\t\t\tlastNode = firstNode;\n\t\t\t}\n\n\t\t\tconst speakers = this._manager.context.destination;\n\n\t\t\tif (this._firstNode !== firstNode) {\n\t\t\t\tif (this._firstNode) {\n\t\t\t\t\tthis._connectorNode.disconnect(this._firstNode);\n\t\t\t\t} else {\n\t\t\t\t\tthis._connectorNode.disconnect(speakers);\n\t\t\t\t}\n\n\t\t\t\tthis._firstNode = firstNode;\n\n\t\t\t\tthis._connectorNode.connect(firstNode);\n\t\t\t}\n\n\t\t\tif (this._lastNode !== lastNode) {\n\t\t\t\tif (this._lastNode) {\n\t\t\t\t\tthis._lastNode.disconnect(speakers);\n\t\t\t\t}\n\n\t\t\t\tthis._lastNode = lastNode;\n\n\t\t\t\tthis._lastNode.connect(speakers);\n\t\t\t}\n\t\t},\n\t\tclearExternalNodes: function () {\n\t\t\tconst speakers = this._manager.context.destination;\n\n\t\t\tif (this._firstNode) {\n\t\t\t\tthis._connectorNode.disconnect(this._firstNode);\n\n\t\t\t\tthis._firstNode = null;\n\t\t\t}\n\n\t\t\tif (this._lastNode) {\n\t\t\t\tthis._lastNode.disconnect(speakers);\n\n\t\t\t\tthis._lastNode = null;\n\t\t\t}\n\n\t\t\tthis._connectorNode.connect(speakers);\n\t\t},\n\t\tgetExternalNodes: function () {\n\t\t\treturn [this._firstNode, this._lastNode];\n\t\t},\n\t\t_createSource: function () {\n\t\t\tif (!this._sound) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst context = this._manager.context;\n\n\t\t\tif (this._sound.buffer) {\n\t\t\t\tthis.source = context.createBufferSource();\n\t\t\t\tthis.source.buffer = this._sound.buffer;\n\t\t\t\tthis.source.connect(this._inputNode);\n\t\t\t\tthis.source.onended = this._endedHandler;\n\t\t\t\tthis.source.loopStart = capTime(this._startTime, this.source.buffer.duration);\n\n\t\t\t\tif (this._duration) {\n\t\t\t\t\tthis.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.source;\n\t\t},\n\t\t_updateCurrentTime: function () {\n\t\t\tthis._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);\n\t\t},\n\t\t_onManagerDestroy: function () {\n\t\t\tif (this.source && this._state === STATE_PLAYING) {\n\t\t\t\tthis.source.stop(0);\n\t\t\t\tthis.source = null;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'volume', {\n\t\tget: function () {\n\t\t\treturn this._volume;\n\t\t},\n\t\tset: function (volume) {\n\t\t\tvolume = math.clamp(volume, 0, 1);\n\t\t\tthis._volume = volume;\n\n\t\t\tif (this.gain) {\n\t\t\t\tthis.gain.gain.value = volume * this._manager.volume;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'pitch', {\n\t\tget: function () {\n\t\t\treturn this._pitch;\n\t\t},\n\t\tset: function (pitch) {\n\t\t\tthis._currentOffset = this.currentTime;\n\t\t\tthis._startedAt = this._manager.context.currentTime;\n\t\t\tthis._pitch = Math.max(Number(pitch) || 0, 0.01);\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.playbackRate.value = this._pitch;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'sound', {\n\t\tget: function () {\n\t\t\treturn this._sound;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._sound = value;\n\n\t\t\tif (this._state !== STATE_STOPPED) {\n\t\t\t\tthis.stop();\n\t\t\t} else {\n\t\t\t\tthis._createSource();\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'currentTime', {\n\t\tget: function () {\n\t\t\tif (this._startOffset !== null) {\n\t\t\t\treturn this._startOffset;\n\t\t\t}\n\n\t\t\tif (this._state === STATE_PAUSED) {\n\t\t\t\treturn this._currentTime;\n\t\t\t}\n\n\t\t\tif (this._state === STATE_STOPPED || !this.source) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tthis._updateCurrentTime();\n\n\t\t\treturn this._currentTime;\n\t\t},\n\t\tset: function (value) {\n\t\t\tif (value < 0) return;\n\n\t\t\tif (this._state === STATE_PLAYING) {\n\t\t\t\tconst suspend = this._suspendInstanceEvents;\n\t\t\t\tthis._suspendInstanceEvents = true;\n\t\t\t\tthis.stop();\n\t\t\t\tthis._startOffset = value;\n\t\t\t\tthis.play();\n\t\t\t\tthis._suspendInstanceEvents = suspend;\n\t\t\t} else {\n\t\t\t\tthis._startOffset = value;\n\t\t\t\tthis._currentTime = value;\n\t\t\t}\n\t\t}\n\t});\n} else {\n\tObject.assign(SoundInstance.prototype, {\n\t\tplay: function () {\n\t\t\tif (this._state !== STATE_STOPPED) {\n\t\t\t\tthis.stop();\n\t\t\t}\n\n\t\t\tif (!this.source) {\n\t\t\t\tif (!this._createSource()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.volume = this._volume;\n\t\t\tthis.pitch = this._pitch;\n\t\t\tthis.loop = this._loop;\n\t\t\tthis.source.play();\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._playWhenLoaded = false;\n\n\t\t\tthis._manager.on('volumechange', this._onManagerVolumeChange, this);\n\n\t\t\tthis._manager.on('suspend', this._onManagerSuspend, this);\n\n\t\t\tthis._manager.on('resume', this._onManagerResume, this);\n\n\t\t\tthis._manager.on('destroy', this._onManagerDestroy, this);\n\n\t\t\tif (this._manager.suspended) this._onManagerSuspend();\n\t\t\tif (!this._suspendInstanceEvents) this._onPlay();\n\t\t\treturn true;\n\t\t},\n\t\tpause: function () {\n\t\t\tif (!this.source || this._state !== STATE_PLAYING) return false;\n\t\t\tthis._suspendEndEvent = true;\n\t\t\tthis.source.pause();\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis._state = STATE_PAUSED;\n\t\t\tthis._startOffset = null;\n\t\t\tif (!this._suspendInstanceEvents) this._onPause();\n\t\t\treturn true;\n\t\t},\n\t\tresume: function () {\n\t\t\tif (!this.source || this._state !== STATE_PAUSED) return false;\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._playWhenLoaded = false;\n\n\t\t\tif (this.source.paused) {\n\t\t\t\tthis.source.play();\n\t\t\t\tif (!this._suspendInstanceEvents) this._onResume();\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\t\tstop: function () {\n\t\t\tif (!this.source || this._state === STATE_STOPPED) return false;\n\n\t\t\tthis._manager.off('volumechange', this._onManagerVolumeChange, this);\n\n\t\t\tthis._manager.off('suspend', this._onManagerSuspend, this);\n\n\t\t\tthis._manager.off('resume', this._onManagerResume, this);\n\n\t\t\tthis._manager.off('destroy', this._onManagerDestroy, this);\n\n\t\t\tthis._suspendEndEvent = true;\n\t\t\tthis.source.pause();\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis._state = STATE_STOPPED;\n\t\t\tthis._startOffset = null;\n\t\t\tif (!this._suspendInstanceEvents) this._onStop();\n\t\t\treturn true;\n\t\t},\n\t\tsetExternalNodes: function () {},\n\t\tclearExternalNodes: function () {},\n\t\tgetExternalNodes: function () {\n\t\t\treturn [null, null];\n\t\t},\n\t\t_onLoadedMetadata: function () {\n\t\t\tthis.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);\n\t\t\tthis._isReady = true;\n\t\t\tlet offset = capTime(this._startOffset, this.duration);\n\t\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\t\tthis._startOffset = null;\n\t\t\tthis.source.currentTime = offset;\n\t\t},\n\t\t_createSource: function () {\n\t\t\tif (this._sound && this._sound.audio) {\n\t\t\t\tthis._isReady = false;\n\t\t\t\tthis.source = this._sound.audio.cloneNode(true);\n\t\t\t\tthis.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);\n\t\t\t\tthis.source.addEventListener('timeupdate', this._timeUpdateHandler);\n\t\t\t\tthis.source.onended = this._endedHandler;\n\t\t\t}\n\n\t\t\treturn this.source;\n\t\t},\n\t\t_onTimeUpdate: function () {\n\t\t\tif (!this._duration) return;\n\n\t\t\tif (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {\n\t\t\t\tif (this.loop) {\n\t\t\t\t\tthis.source.currentTime = capTime(this._startTime, this.source.duration);\n\t\t\t\t} else {\n\t\t\t\t\tthis.source.removeEventListener('timeupdate', this._timeUpdateHandler);\n\t\t\t\t\tthis.source.pause();\n\n\t\t\t\t\tthis._onEnded();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_onManagerDestroy: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'volume', {\n\t\tget: function () {\n\t\t\treturn this._volume;\n\t\t},\n\t\tset: function (volume) {\n\t\t\tvolume = math.clamp(volume, 0, 1);\n\t\t\tthis._volume = volume;\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.volume = volume * this._manager.volume;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'pitch', {\n\t\tget: function () {\n\t\t\treturn this._pitch;\n\t\t},\n\t\tset: function (pitch) {\n\t\t\tthis._pitch = Math.max(Number(pitch) || 0, 0.01);\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.playbackRate = this._pitch;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'sound', {\n\t\tget: function () {\n\t\t\treturn this._sound;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.stop();\n\t\t\tthis._sound = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'currentTime', {\n\t\tget: function () {\n\t\t\tif (this._startOffset !== null) {\n\t\t\t\treturn this._startOffset;\n\t\t\t}\n\n\t\t\tif (this._state === STATE_STOPPED || !this.source) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn this.source.currentTime - this._startTime;\n\t\t},\n\t\tset: function (value) {\n\t\t\tif (value < 0) return;\n\t\t\tthis._startOffset = value;\n\n\t\t\tif (this.source && this._isReady) {\n\t\t\t\tthis.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);\n\t\t\t\tthis._startOffset = null;\n\t\t\t}\n\t\t}\n\t});\n}\n\nconst MAX_DISTANCE = 10000;\n\nclass SoundInstance3d extends SoundInstance {\n\tconstructor(manager, sound, options) {\n\t\tsuper(manager, sound, options);\n\t\toptions = options || {};\n\t\tthis._position = new Vec3();\n\t\tif (options.position) this.position = options.position;\n\t\tthis._velocity = new Vec3();\n\t\tif (options.velocity) this.velocity = options.velocity;\n\t\tthis.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;\n\t\tthis.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;\n\t\tthis.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;\n\t\tthis.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;\n\t}\n\n}\n\nif (hasAudioContext()) {\n\tObject.assign(SoundInstance3d.prototype, {\n\t\t_initializeNodes: function () {\n\t\t\tthis.gain = this._manager.context.createGain();\n\t\t\tthis.panner = this._manager.context.createPanner();\n\t\t\tthis.panner.connect(this.gain);\n\t\t\tthis._inputNode = this.panner;\n\t\t\tthis._connectorNode = this.gain;\n\n\t\t\tthis._connectorNode.connect(this._manager.context.destination);\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'position', {\n\t\tget: function () {\n\t\t\treturn this._position;\n\t\t},\n\t\tset: function (position) {\n\t\t\tthis._position.copy(position);\n\n\t\t\tthis.panner.setPosition(position.x, position.y, position.z);\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'velocity', {\n\t\tget: function () {\n\t\t\treturn this._velocity;\n\t\t},\n\t\tset: function (velocity) {\n\t\t\tthis._velocity.copy(velocity);\n\n\t\t\tthis.panner.setVelocity(velocity.x, velocity.y, velocity.z);\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'maxDistance', {\n\t\tget: function () {\n\t\t\treturn this.panner.maxDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.panner.maxDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'refDistance', {\n\t\tget: function () {\n\t\t\treturn this.panner.refDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.panner.refDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {\n\t\tget: function () {\n\t\t\treturn this.panner.rolloffFactor;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.panner.rolloffFactor = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'distanceModel', {\n\t\tget: function () {\n\t\t\treturn this.panner.distanceModel;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.panner.distanceModel = value;\n\t\t}\n\t});\n} else {\n\tlet offset = new Vec3();\n\n\tconst fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {\n\t\toffset = offset.sub2(posOne, posTwo);\n\t\tconst distance = offset.length();\n\n\t\tif (distance < refDistance) {\n\t\t\treturn 1;\n\t\t} else if (distance > maxDistance) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet result = 0;\n\n\t\tif (distanceModel === DISTANCE_LINEAR) {\n\t\t\tresult = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);\n\t\t} else if (distanceModel === DISTANCE_INVERSE) {\n\t\t\tresult = refDistance / (refDistance + rollOffFactor * (distance - refDistance));\n\t\t} else if (distanceModel === DISTANCE_EXPONENTIAL) {\n\t\t\tresult = Math.pow(distance / refDistance, -rollOffFactor);\n\t\t}\n\n\t\treturn math.clamp(result, 0, 1);\n\t};\n\n\tObject.defineProperty(SoundInstance3d.prototype, 'position', {\n\t\tget: function () {\n\t\t\treturn this._position;\n\t\t},\n\t\tset: function (position) {\n\t\t\tthis._position.copy(position);\n\n\t\t\tif (this.source) {\n\t\t\t\tconst listener = this._manager.listener;\n\t\t\t\tconst lpos = listener.getPosition();\n\t\t\t\tconst factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);\n\t\t\t\tconst v = this.volume;\n\t\t\t\tthis.source.volume = v * factor * this._manager.volume;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'velocity', {\n\t\tget: function () {\n\t\t\treturn this._velocity;\n\t\t},\n\t\tset: function (velocity) {\n\t\t\tthis._velocity.copy(velocity);\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'maxDistance', {\n\t\tget: function () {\n\t\t\treturn this._maxDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._maxDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'refDistance', {\n\t\tget: function () {\n\t\t\treturn this._refDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._refDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {\n\t\tget: function () {\n\t\t\treturn this._rollOffFactor;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._rollOffFactor = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'distanceModel', {\n\t\tget: function () {\n\t\t\treturn this._distanceModel;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._distanceModel = value;\n\t\t}\n\t});\n}\n\nconst instanceOptions = {\n\tvolume: 0,\n\tpitch: 0,\n\tloop: false,\n\tstartTime: 0,\n\tduration: 0,\n\tposition: new Vec3(),\n\tmaxDistance: 0,\n\trefDistance: 0,\n\trollOffFactor: 0,\n\tdistanceModel: 0,\n\tonPlay: null,\n\tonPause: null,\n\tonResume: null,\n\tonStop: null,\n\tonEnd: null\n};\n\nclass SoundSlot extends EventHandler {\n\tconstructor(component, name = 'Untitled', options = {}) {\n\t\tsuper();\n\t\tthis.name = void 0;\n\t\tthis.instances = [];\n\t\tthis._component = component;\n\t\tthis._assets = component.system.app.assets;\n\t\tthis._manager = component.system.manager;\n\t\tthis.name = name;\n\t\tthis._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;\n\t\tthis._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;\n\t\tthis._loop = !!(options.loop !== undefined ? options.loop : false);\n\t\tthis._duration = options.duration > 0 ? options.duration : null;\n\t\tthis._startTime = Math.max(0, Number(options.startTime) || 0);\n\t\tthis._overlap = !!options.overlap;\n\t\tthis._autoPlay = !!options.autoPlay;\n\t\tthis._firstNode = null;\n\t\tthis._lastNode = null;\n\t\tthis._asset = options.asset;\n\n\t\tif (this._asset instanceof Asset) {\n\t\t\tthis._asset = this._asset.id;\n\t\t}\n\n\t\tthis._onInstancePlayHandler = this._onInstancePlay.bind(this);\n\t\tthis._onInstancePauseHandler = this._onInstancePause.bind(this);\n\t\tthis._onInstanceResumeHandler = this._onInstanceResume.bind(this);\n\t\tthis._onInstanceStopHandler = this._onInstanceStop.bind(this);\n\t\tthis._onInstanceEndHandler = this._onInstanceEnd.bind(this);\n\t}\n\n\tplay() {\n\t\tif (!this.overlap) {\n\t\t\tthis.stop();\n\t\t}\n\n\t\tif (!this.isLoaded && !this._hasAsset()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst instance = this._createInstance();\n\n\t\tthis.instances.push(instance);\n\n\t\tif (!this.isLoaded) {\n\t\t\tconst onLoad = function onLoad(sound) {\n\t\t\t\tconst playWhenLoaded = instance._playWhenLoaded;\n\t\t\t\tinstance.sound = sound;\n\n\t\t\t\tif (playWhenLoaded) {\n\t\t\t\t\tinstance.play();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.off('load', onLoad);\n\t\t\tthis.once('load', onLoad);\n\t\t\tthis.load();\n\t\t} else {\n\t\t\tinstance.play();\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\tpause() {\n\t\tlet paused = false;\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].pause()) {\n\t\t\t\tpaused = true;\n\t\t\t}\n\t\t}\n\n\t\treturn paused;\n\t}\n\n\tresume() {\n\t\tlet resumed = false;\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].resume()) resumed = true;\n\t\t}\n\n\t\treturn resumed;\n\t}\n\n\tstop() {\n\t\tlet stopped = false;\n\t\tconst instances = this.instances;\n\t\tlet i = instances.length;\n\n\t\twhile (i--) {\n\t\t\tinstances[i].stop();\n\t\t\tstopped = true;\n\t\t}\n\n\t\tinstances.length = 0;\n\t\treturn stopped;\n\t}\n\n\tload() {\n\t\tif (!this._hasAsset()) return;\n\n\t\tconst asset = this._assets.get(this._asset);\n\n\t\tif (!asset) {\n\t\t\tthis._assets.off('add:' + this._asset, this._onAssetAdd, this);\n\n\t\t\tthis._assets.once('add:' + this._asset, this._onAssetAdd, this);\n\n\t\t\treturn;\n\t\t}\n\n\t\tasset.off('remove', this._onAssetRemoved, this);\n\t\tasset.on('remove', this._onAssetRemoved, this);\n\n\t\tif (!asset.resource) {\n\t\t\tasset.off('load', this._onAssetLoad, this);\n\t\t\tasset.once('load', this._onAssetLoad, this);\n\n\t\t\tthis._assets.load(asset);\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fire('load', asset.resource);\n\t}\n\n\tsetExternalNodes(firstNode, lastNode) {\n\t\tif (!firstNode) {\n\t\t\tconsole.error('The firstNode must have a valid AudioNode');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!lastNode) {\n\t\t\tlastNode = firstNode;\n\t\t}\n\n\t\tthis._firstNode = firstNode;\n\t\tthis._lastNode = lastNode;\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].setExternalNodes(firstNode, lastNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tclearExternalNodes() {\n\t\tthis._firstNode = null;\n\t\tthis._lastNode = null;\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].clearExternalNodes();\n\t\t\t}\n\t\t}\n\t}\n\n\tgetExternalNodes() {\n\t\treturn [this._firstNode, this._lastNode];\n\t}\n\n\t_hasAsset() {\n\t\treturn this._asset != null;\n\t}\n\n\t_createInstance() {\n\t\tlet instance = null;\n\t\tconst component = this._component;\n\t\tlet sound = null;\n\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\n\t\t\tif (asset) {\n\t\t\t\tsound = asset.resource;\n\t\t\t}\n\t\t}\n\n\t\tconst data = instanceOptions;\n\t\tdata.volume = this._volume * component.volume;\n\t\tdata.pitch = this._pitch * component.pitch;\n\t\tdata.loop = this._loop;\n\t\tdata.startTime = this._startTime;\n\t\tdata.duration = this._duration;\n\t\tdata.onPlay = this._onInstancePlayHandler;\n\t\tdata.onPause = this._onInstancePauseHandler;\n\t\tdata.onResume = this._onInstanceResumeHandler;\n\t\tdata.onStop = this._onInstanceStopHandler;\n\t\tdata.onEnd = this._onInstanceEndHandler;\n\n\t\tif (component.positional) {\n\t\t\tdata.position.copy(component.entity.getPosition());\n\t\t\tdata.maxDistance = component.maxDistance;\n\t\t\tdata.refDistance = component.refDistance;\n\t\t\tdata.rollOffFactor = component.rollOffFactor;\n\t\t\tdata.distanceModel = component.distanceModel;\n\t\t\tinstance = new SoundInstance3d(this._manager, sound, data);\n\t\t} else {\n\t\t\tinstance = new SoundInstance(this._manager, sound, data);\n\t\t}\n\n\t\tif (this._firstNode) {\n\t\t\tinstance.setExternalNodes(this._firstNode, this._lastNode);\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\t_onInstancePlay(instance) {\n\t\tthis.fire('play', instance);\n\n\t\tthis._component.fire('play', this, instance);\n\t}\n\n\t_onInstancePause(instance) {\n\t\tthis.fire('pause', instance);\n\n\t\tthis._component.fire('pause', this, instance);\n\t}\n\n\t_onInstanceResume(instance) {\n\t\tthis.fire('resume', instance);\n\n\t\tthis._component.fire('resume', this, instance);\n\t}\n\n\t_onInstanceStop(instance) {\n\t\tconst idx = this.instances.indexOf(instance);\n\n\t\tif (idx !== -1) {\n\t\t\tthis.instances.splice(idx, 1);\n\t\t}\n\n\t\tthis.fire('stop', instance);\n\n\t\tthis._component.fire('stop', this, instance);\n\t}\n\n\t_onInstanceEnd(instance) {\n\t\tconst idx = this.instances.indexOf(instance);\n\n\t\tif (idx !== -1) {\n\t\t\tthis.instances.splice(idx, 1);\n\t\t}\n\n\t\tthis.fire('end', instance);\n\n\t\tthis._component.fire('end', this, instance);\n\t}\n\n\t_onAssetAdd(asset) {\n\t\tthis.load();\n\t}\n\n\t_onAssetLoad(asset) {\n\t\tthis.load();\n\t}\n\n\t_onAssetRemoved(asset) {\n\t\tasset.off('remove', this._onAssetRemoved, this);\n\n\t\tthis._assets.off('add:' + asset.id, this._onAssetAdd, this);\n\n\t\tthis.stop();\n\t}\n\n\tupdatePosition(position) {\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tinstances[i].position = position;\n\t\t}\n\t}\n\n\tset asset(value) {\n\t\tconst old = this._asset;\n\n\t\tif (old) {\n\t\t\tthis._assets.off('add:' + old, this._onAssetAdd, this);\n\n\t\t\tconst oldAsset = this._assets.get(old);\n\n\t\t\tif (oldAsset) {\n\t\t\t\toldAsset.off('remove', this._onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tthis._asset = value;\n\n\t\tif (this._asset instanceof Asset) {\n\t\t\tthis._asset = this._asset.id;\n\t\t}\n\n\t\tif (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {\n\t\t\tthis.load();\n\t\t}\n\t}\n\n\tget asset() {\n\t\treturn this._asset;\n\t}\n\n\tset autoPlay(value) {\n\t\tthis._autoPlay = !!value;\n\t}\n\n\tget autoPlay() {\n\t\treturn this._autoPlay;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = Math.max(0, Number(value) || 0) || null;\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].duration = this._duration;\n\t\t\t}\n\t\t}\n\t}\n\n\tget duration() {\n\t\tlet assetDuration = 0;\n\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\n\t\t\tassetDuration = asset != null && asset.resource ? asset.resource.duration : 0;\n\t\t}\n\n\t\tif (this._duration != null) {\n\t\t\treturn this._duration % (assetDuration || 1);\n\t\t}\n\n\t\treturn assetDuration;\n\t}\n\n\tget isLoaded() {\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\n\t\t\tif (asset) {\n\t\t\t\treturn !!asset.resource;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget isPaused() {\n\t\tconst instances = this.instances;\n\t\tconst len = instances.length;\n\t\tif (len === 0) return false;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (!instances[i].isPaused) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget isPlaying() {\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].isPlaying) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget isStopped() {\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (!instances[i].isStopped) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tset loop(value) {\n\t\tthis._loop = !!value;\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tinstances[i].loop = this._loop;\n\t\t}\n\t}\n\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\n\tset overlap(value) {\n\t\tthis._overlap = !!value;\n\t}\n\n\tget overlap() {\n\t\treturn this._overlap;\n\t}\n\n\tset pitch(value) {\n\t\tthis._pitch = Math.max(Number(value) || 0, 0.01);\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].pitch = this.pitch * this._component.pitch;\n\t\t\t}\n\t\t}\n\t}\n\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\n\tset startTime(value) {\n\t\tthis._startTime = Math.max(0, Number(value) || 0);\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].startTime = this._startTime;\n\t\t\t}\n\t\t}\n\t}\n\n\tget startTime() {\n\t\treturn this._startTime;\n\t}\n\n\tset volume(value) {\n\t\tthis._volume = math.clamp(Number(value) || 0, 0, 1);\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].volume = this._volume * this._component.volume;\n\t\t\t}\n\t\t}\n\t}\n\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\n}\n\nclass SoundComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._volume = 1;\n\t\tthis._pitch = 1;\n\t\tthis._positional = true;\n\t\tthis._refDistance = 1;\n\t\tthis._maxDistance = 10000;\n\t\tthis._rollOffFactor = 1;\n\t\tthis._distanceModel = DISTANCE_LINEAR;\n\t\tthis._slots = {};\n\t\tthis._playingBeforeDisable = {};\n\t}\n\n\t_updateSoundInstances(property, value, isFactor) {\n\t\tconst slots = this._slots;\n\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\n\t\t\tif (!slot.overlap) {\n\t\t\t\tconst instances = slot.instances;\n\n\t\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\t\tinstances[i][property] = isFactor ? slot[property] * value : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset distanceModel(value) {\n\t\tthis._distanceModel = value;\n\n\t\tthis._updateSoundInstances('distanceModel', value, false);\n\t}\n\n\tget distanceModel() {\n\t\treturn this._distanceModel;\n\t}\n\n\tset maxDistance(value) {\n\t\tthis._maxDistance = value;\n\n\t\tthis._updateSoundInstances('maxDistance', value, false);\n\t}\n\n\tget maxDistance() {\n\t\treturn this._maxDistance;\n\t}\n\n\tset refDistance(value) {\n\t\tthis._refDistance = value;\n\n\t\tthis._updateSoundInstances('refDistance', value, false);\n\t}\n\n\tget refDistance() {\n\t\treturn this._refDistance;\n\t}\n\n\tset rollOffFactor(value) {\n\t\tthis._rollOffFactor = value;\n\n\t\tthis._updateSoundInstances('rollOffFactor', value, false);\n\t}\n\n\tget rollOffFactor() {\n\t\treturn this._rollOffFactor;\n\t}\n\n\tset pitch(value) {\n\t\tthis._pitch = value;\n\n\t\tthis._updateSoundInstances('pitch', value, true);\n\t}\n\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\n\tset volume(value) {\n\t\tthis._volume = value;\n\n\t\tthis._updateSoundInstances('volume', value, true);\n\t}\n\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\n\tset positional(newValue) {\n\t\tthis._positional = newValue;\n\t\tconst slots = this._slots;\n\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\n\t\t\tif (!slot.overlap) {\n\t\t\t\tconst instances = slot.instances;\n\t\t\t\tconst oldLength = instances.length;\n\n\t\t\t\tfor (let i = oldLength - 1; i >= 0; i--) {\n\t\t\t\t\tconst isPlaying = instances[i].isPlaying || instances[i].isSuspended;\n\t\t\t\t\tconst currentTime = instances[i].currentTime;\n\t\t\t\t\tif (isPlaying) instances[i].stop();\n\n\t\t\t\t\tconst instance = slot._createInstance();\n\n\t\t\t\t\tif (isPlaying) {\n\t\t\t\t\t\tinstance.play();\n\t\t\t\t\t\tinstance.currentTime = currentTime;\n\t\t\t\t\t}\n\n\t\t\t\t\tinstances.push(instance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget positional() {\n\t\treturn this._positional;\n\t}\n\n\tset slots(newValue) {\n\t\tconst oldValue = this._slots;\n\n\t\tif (oldValue) {\n\t\t\tfor (const key in oldValue) {\n\t\t\t\toldValue[key].stop();\n\t\t\t}\n\t\t}\n\n\t\tconst slots = {};\n\n\t\tfor (const key in newValue) {\n\t\t\tif (!(newValue[key] instanceof SoundSlot)) {\n\t\t\t\tif (newValue[key].name) {\n\t\t\t\t\tslots[newValue[key].name] = new SoundSlot(this, newValue[key].name, newValue[key]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslots[newValue[key].name] = newValue[key];\n\t\t\t}\n\t\t}\n\n\t\tthis._slots = slots;\n\t\tif (this.enabled && this.entity.enabled) this.onEnable();\n\t}\n\n\tget slots() {\n\t\treturn this._slots;\n\t}\n\n\tonEnable() {\n\t\tif (this.system._inTools) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst slots = this._slots;\n\t\tconst playingBeforeDisable = this._playingBeforeDisable;\n\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\n\t\t\tif (slot.autoPlay && slot.isStopped) {\n\t\t\t\tslot.play();\n\t\t\t} else if (playingBeforeDisable[key]) {\n\t\t\t\tslot.resume();\n\t\t\t} else if (!slot.isLoaded) {\n\t\t\t\tslot.load();\n\t\t\t}\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tconst slots = this._slots;\n\t\tconst playingBeforeDisable = {};\n\n\t\tfor (const key in slots) {\n\t\t\tif (!slots[key].overlap) {\n\t\t\t\tif (slots[key].isPlaying) {\n\t\t\t\t\tslots[key].pause();\n\t\t\t\t\tplayingBeforeDisable[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._playingBeforeDisable = playingBeforeDisable;\n\t}\n\n\tonRemove() {\n\t\tthis.off();\n\t}\n\n\taddSlot(name, options) {\n\t\tconst slots = this._slots;\n\n\t\tif (slots[name]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst slot = new SoundSlot(this, name, options);\n\t\tslots[name] = slot;\n\n\t\tif (slot.autoPlay && this.enabled && this.entity.enabled) {\n\t\t\tslot.play();\n\t\t}\n\n\t\treturn slot;\n\t}\n\n\tremoveSlot(name) {\n\t\tconst slots = this._slots;\n\n\t\tif (slots[name]) {\n\t\t\tslots[name].stop();\n\t\t\tdelete slots[name];\n\t\t}\n\t}\n\n\tslot(name) {\n\t\treturn this._slots[name];\n\t}\n\n\tplay(name) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst slot = this._slots[name];\n\n\t\tif (!slot) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn slot.play();\n\t}\n\n\tpause(name) {\n\t\tconst slots = this._slots;\n\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tslot.pause();\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].pause();\n\t\t\t}\n\t\t}\n\t}\n\n\tresume(name) {\n\t\tconst slots = this._slots;\n\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (slot.isPaused) {\n\t\t\t\tslot.resume();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].resume();\n\t\t\t}\n\t\t}\n\t}\n\n\tstop(name) {\n\t\tconst slots = this._slots;\n\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tslot.stop();\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].stop();\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass SoundComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$2 = ['enabled'];\n\nclass SoundComponentSystem extends ComponentSystem {\n\tconstructor(app, manager) {\n\t\tsuper(app);\n\t\tthis.id = \"sound\";\n\t\tthis.ComponentType = SoundComponent;\n\t\tthis.DataType = SoundComponentData;\n\t\tthis.schema = _schema$2;\n\t\tthis.manager = manager;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t}\n\n\tset volume(volume) {\n\t\tthis.manager.volume = volume;\n\t}\n\n\tget volume() {\n\t\treturn this.manager.volume;\n\t}\n\n\tget context() {\n\t\tif (!hasAudioContext()) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.manager.context;\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];\n\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tif (data.hasOwnProperty(properties[i])) {\n\t\t\t\tcomponent[properties[i]] = data[properties[i]];\n\t\t\t}\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst srcComponent = entity.sound;\n\t\tconst srcSlots = srcComponent.slots;\n\t\tconst slots = {};\n\n\t\tfor (const key in srcSlots) {\n\t\t\tconst srcSlot = srcSlots[key];\n\t\t\tslots[key] = {\n\t\t\t\tname: srcSlot.name,\n\t\t\t\tvolume: srcSlot.volume,\n\t\t\t\tpitch: srcSlot.pitch,\n\t\t\t\tloop: srcSlot.loop,\n\t\t\t\tduration: srcSlot.duration,\n\t\t\t\tstartTime: srcSlot.startTime,\n\t\t\t\toverlap: srcSlot.overlap,\n\t\t\t\tautoPlay: srcSlot.autoPlay,\n\t\t\t\tasset: srcSlot.asset\n\t\t\t};\n\t\t}\n\n\t\tconst cloneData = {\n\t\t\tdistanceModel: srcComponent.distanceModel,\n\t\t\tenabled: srcComponent.enabled,\n\t\t\tmaxDistance: srcComponent.maxDistance,\n\t\t\tpitch: srcComponent.pitch,\n\t\t\tpositional: srcComponent.positional,\n\t\t\trefDistance: srcComponent.refDistance,\n\t\t\trollOffFactor: srcComponent.rollOffFactor,\n\t\t\tslots: slots,\n\t\t\tvolume: srcComponent.volume\n\t\t};\n\t\treturn this.addComponent(clone, cloneData);\n\t}\n\n\tonUpdate(dt) {\n\t\tconst store = this.store;\n\n\t\tfor (const id in store) {\n\t\t\tif (store.hasOwnProperty(id)) {\n\t\t\t\tconst item = store[id];\n\t\t\t\tconst entity = item.entity;\n\n\t\t\t\tif (entity.enabled) {\n\t\t\t\t\tconst component = entity.sound;\n\n\t\t\t\t\tif (component.enabled && component.positional) {\n\t\t\t\t\t\tconst position = entity.getPosition();\n\t\t\t\t\t\tconst slots = component.slots;\n\n\t\t\t\t\t\tfor (const key in slots) {\n\t\t\t\t\t\t\tslots[key].updatePosition(position);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tconst slots = component.slots;\n\n\t\tfor (const key in slots) {\n\t\t\tif (!slots[key].overlap) {\n\t\t\t\tslots[key].stop();\n\t\t\t}\n\t\t}\n\n\t\tcomponent.onRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(SoundComponent.prototype, _schema$2);\n\nconst SPRITETYPE_SIMPLE = 'simple';\nconst SPRITETYPE_ANIMATED = 'animated';\n\nclass SpriteAnimationClip extends EventHandler {\n\tconstructor(component, data) {\n\t\tsuper();\n\t\tthis._component = component;\n\t\tthis._frame = 0;\n\t\tthis._sprite = null;\n\t\tthis._spriteAsset = null;\n\t\tthis.spriteAsset = data.spriteAsset;\n\t\tthis.name = data.name;\n\t\tthis.fps = data.fps || 0;\n\t\tthis.loop = data.loop || false;\n\t\tthis._playing = false;\n\t\tthis._paused = false;\n\t\tthis._time = 0;\n\t}\n\n\tget duration() {\n\t\tif (this._sprite) {\n\t\t\tconst fps = this.fps || Number.MIN_VALUE;\n\t\t\treturn this._sprite.frameKeys.length / Math.abs(fps);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tset frame(value) {\n\t\tthis._setFrame(value);\n\n\t\tconst fps = this.fps || Number.MIN_VALUE;\n\n\t\tthis._setTime(this._frame / fps);\n\t}\n\n\tget frame() {\n\t\treturn this._frame;\n\t}\n\n\tget isPaused() {\n\t\treturn this._paused;\n\t}\n\n\tget isPlaying() {\n\t\treturn this._playing;\n\t}\n\n\tset sprite(value) {\n\t\tif (this._sprite) {\n\t\t\tthis._sprite.off('set:meshes', this._onSpriteMeshesChange, this);\n\n\t\t\tthis._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);\n\n\t\t\tthis._sprite.off('set:atlas', this._onSpriteMeshesChange, this);\n\n\t\t\tif (this._sprite.atlas) {\n\t\t\t\tthis._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);\n\t\t\t}\n\t\t}\n\n\t\tthis._sprite = value;\n\n\t\tif (this._sprite) {\n\t\t\tthis._sprite.on('set:meshes', this._onSpriteMeshesChange, this);\n\n\t\t\tthis._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);\n\n\t\t\tthis._sprite.on('set:atlas', this._onSpriteMeshesChange, this);\n\n\t\t\tif (this._sprite.atlas) {\n\t\t\t\tthis._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);\n\t\t\t}\n\t\t}\n\n\t\tif (this._component.currentClip === this) {\n\t\t\tlet mi;\n\n\t\t\tif (!value || !value.atlas) {\n\t\t\t\tmi = this._component._meshInstance;\n\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.deleteParameter('texture_emissiveMap');\n\t\t\t\t\tmi.deleteParameter('texture_opacityMap');\n\t\t\t\t}\n\n\t\t\t\tthis._component._hideModel();\n\t\t\t} else {\n\t\t\t\tif (value.atlas.texture) {\n\t\t\t\t\tmi = this._component._meshInstance;\n\n\t\t\t\t\tif (mi) {\n\t\t\t\t\t\tmi.setParameter('texture_emissiveMap', value.atlas.texture);\n\t\t\t\t\t\tmi.setParameter('texture_opacityMap', value.atlas.texture);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._component.enabled && this._component.entity.enabled) {\n\t\t\t\t\t\tthis._component._showModel();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.time && this.fps) {\n\t\t\t\t\tthis.time = this.time;\n\t\t\t\t} else {\n\t\t\t\t\tthis.frame = this.frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget sprite() {\n\t\treturn this._sprite;\n\t}\n\n\tset spriteAsset(value) {\n\t\tconst assets = this._component.system.app.assets;\n\t\tlet id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\tid = value.id;\n\t\t}\n\n\t\tif (this._spriteAsset !== id) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst prev = assets.get(this._spriteAsset);\n\n\t\t\t\tif (prev) {\n\t\t\t\t\tthis._unbindSpriteAsset(prev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._spriteAsset = id;\n\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst asset = assets.get(this._spriteAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.sprite = null;\n\t\t\t\t\tassets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget spriteAsset() {\n\t\treturn this._spriteAsset;\n\t}\n\n\tset time(value) {\n\t\tthis._setTime(value);\n\n\t\tif (this._sprite) {\n\t\t\tthis.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));\n\t\t} else {\n\t\t\tthis.frame = 0;\n\t\t}\n\t}\n\n\tget time() {\n\t\treturn this._time;\n\t}\n\n\t_onSpriteAssetAdded(asset) {\n\t\tthis._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);\n\n\t\tif (this._spriteAsset === asset.id) {\n\t\t\tthis._bindSpriteAsset(asset);\n\t\t}\n\t}\n\n\t_bindSpriteAsset(asset) {\n\t\tasset.on(\"load\", this._onSpriteAssetLoad, this);\n\t\tasset.on(\"remove\", this._onSpriteAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onSpriteAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._component.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindSpriteAsset(asset) {\n\t\tasset.off(\"load\", this._onSpriteAssetLoad, this);\n\t\tasset.off(\"remove\", this._onSpriteAssetRemove, this);\n\n\t\tif (asset.resource && asset.resource.atlas) {\n\t\t\tthis._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);\n\t\t}\n\t}\n\n\t_onSpriteAssetLoad(asset) {\n\t\tif (!asset.resource) {\n\t\t\tthis.sprite = null;\n\t\t} else {\n\t\t\tif (!asset.resource.atlas) {\n\t\t\t\tconst atlasAssetId = asset.data.textureAtlasAsset;\n\t\t\t\tconst assets = this._component.system.app.assets;\n\t\t\t\tassets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n\t\t\t\tassets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n\t\t\t} else {\n\t\t\t\tthis.sprite = asset.resource;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onTextureAtlasLoad(atlasAsset) {\n\t\tconst spriteAsset = this._spriteAsset;\n\n\t\tif (spriteAsset instanceof Asset) {\n\t\t\tthis._onSpriteAssetLoad(spriteAsset);\n\t\t} else {\n\t\t\tthis._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));\n\t\t}\n\t}\n\n\t_onSpriteAssetRemove(asset) {\n\t\tthis.sprite = null;\n\t}\n\n\t_onSpriteMeshesChange() {\n\t\tif (this._component.currentClip === this) {\n\t\t\tthis._component._showFrame(this.frame);\n\t\t}\n\t}\n\n\t_onSpritePpuChanged() {\n\t\tif (this._component.currentClip === this) {\n\t\t\tif (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {\n\t\t\t\tthis._component._showFrame(this.frame);\n\t\t\t}\n\t\t}\n\t}\n\n\t_update(dt) {\n\t\tif (this.fps === 0) return;\n\t\tif (!this._playing || this._paused || !this._sprite) return;\n\t\tconst dir = this.fps < 0 ? -1 : 1;\n\t\tconst time = this._time + dt * this._component.speed * dir;\n\t\tconst duration = this.duration;\n\t\tconst end = time > duration || time < 0;\n\n\t\tthis._setTime(time);\n\n\t\tlet frame = this.frame;\n\n\t\tif (this._sprite) {\n\t\t\tframe = Math.floor(this._sprite.frameKeys.length * this._time / duration);\n\t\t} else {\n\t\t\tframe = 0;\n\t\t}\n\n\t\tif (frame !== this._frame) {\n\t\t\tthis._setFrame(frame);\n\t\t}\n\n\t\tif (end) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis.fire('loop');\n\n\t\t\t\tthis._component.fire('loop', this);\n\t\t\t} else {\n\t\t\t\tthis._playing = false;\n\t\t\t\tthis._paused = false;\n\t\t\t\tthis.fire('end');\n\n\t\t\t\tthis._component.fire('end', this);\n\t\t\t}\n\t\t}\n\t}\n\n\t_setTime(value) {\n\t\tthis._time = value;\n\t\tconst duration = this.duration;\n\n\t\tif (this._time < 0) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis._time = this._time % duration + duration;\n\t\t\t} else {\n\t\t\t\tthis._time = 0;\n\t\t\t}\n\t\t} else if (this._time > duration) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis._time %= duration;\n\t\t\t} else {\n\t\t\t\tthis._time = duration;\n\t\t\t}\n\t\t}\n\t}\n\n\t_setFrame(value) {\n\t\tif (this._sprite) {\n\t\t\tthis._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);\n\t\t} else {\n\t\t\tthis._frame = value;\n\t\t}\n\n\t\tif (this._component.currentClip === this) {\n\t\t\tthis._component._showFrame(this._frame);\n\t\t}\n\t}\n\n\t_destroy() {\n\t\tif (this._sprite) {\n\t\t\tthis.sprite = null;\n\t\t}\n\n\t\tif (this._spriteAsset) {\n\t\t\tthis.spriteAsset = null;\n\t\t}\n\t}\n\n\tplay() {\n\t\tif (this._playing) return;\n\t\tthis._playing = true;\n\t\tthis._paused = false;\n\t\tthis.frame = 0;\n\t\tthis.fire('play');\n\n\t\tthis._component.fire('play', this);\n\t}\n\n\tpause() {\n\t\tif (!this._playing || this._paused) return;\n\t\tthis._paused = true;\n\t\tthis.fire('pause');\n\n\t\tthis._component.fire('pause', this);\n\t}\n\n\tresume() {\n\t\tif (!this._paused) return;\n\t\tthis._paused = false;\n\t\tthis.fire('resume');\n\n\t\tthis._component.fire('resume', this);\n\t}\n\n\tstop() {\n\t\tif (!this._playing) return;\n\t\tthis._playing = false;\n\t\tthis._paused = false;\n\t\tthis._time = 0;\n\t\tthis.frame = 0;\n\t\tthis.fire('stop');\n\n\t\tthis._component.fire('stop', this);\n\t}\n\n}\n\nconst PARAM_EMISSIVE_MAP = 'texture_emissiveMap';\nconst PARAM_OPACITY_MAP = 'texture_opacityMap';\nconst PARAM_EMISSIVE = 'material_emissive';\nconst PARAM_OPACITY = 'material_opacity';\nconst PARAM_INNER_OFFSET = 'innerOffset';\nconst PARAM_OUTER_SCALE = 'outerScale';\nconst PARAM_ATLAS_RECT = 'atlasRect';\n\nclass SpriteComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._type = SPRITETYPE_SIMPLE;\n\t\tthis._material = system.defaultMaterial;\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array(3);\n\t\tthis._speed = 1;\n\t\tthis._flipX = false;\n\t\tthis._flipY = false;\n\t\tthis._width = 1;\n\t\tthis._height = 1;\n\t\tthis._drawOrder = 0;\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._outerScale = new Vec2(1, 1);\n\t\tthis._outerScaleUniform = new Float32Array(2);\n\t\tthis._innerOffset = new Vec4();\n\t\tthis._innerOffsetUniform = new Float32Array(4);\n\t\tthis._atlasRect = new Vec4();\n\t\tthis._atlasRectUniform = new Float32Array(4);\n\t\tthis._batchGroupId = -1;\n\t\tthis._batchGroup = null;\n\t\tthis._node = new GraphNode();\n\t\tthis._model = new Model();\n\t\tthis._model.graph = this._node;\n\t\tthis._meshInstance = null;\n\t\tentity.addChild(this._model.graph);\n\t\tthis._model._entity = entity;\n\t\tthis._updateAabbFunc = this._updateAabb.bind(this);\n\t\tthis._addedModel = false;\n\t\tthis._autoPlayClip = null;\n\t\tthis._clips = {};\n\t\tthis._defaultClip = new SpriteAnimationClip(this, {\n\t\t\tname: this.entity.name,\n\t\t\tfps: 0,\n\t\t\tloop: false,\n\t\t\tspriteAsset: null\n\t\t});\n\t\tthis._currentClip = this._defaultClip;\n\t}\n\n\tset type(value) {\n\t\tif (this._type === value) return;\n\t\tthis._type = value;\n\n\t\tif (this._type === SPRITETYPE_SIMPLE) {\n\t\t\tthis.stop();\n\t\t\tthis._currentClip = this._defaultClip;\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis._currentClip.frame = this.frame;\n\n\t\t\t\tif (this._currentClip.sprite) {\n\t\t\t\t\tthis._showModel();\n\t\t\t\t} else {\n\t\t\t\t\tthis._hideModel();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this._type === SPRITETYPE_ANIMATED) {\n\t\t\tthis.stop();\n\n\t\t\tif (this._autoPlayClip) {\n\t\t\t\tthis._tryAutoPlay();\n\t\t\t}\n\n\t\t\tif (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {\n\t\t\t\tthis._showModel();\n\t\t\t} else {\n\t\t\t\tthis._hideModel();\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset frame(value) {\n\t\tthis._currentClip.frame = value;\n\t}\n\n\tget frame() {\n\t\treturn this._currentClip.frame;\n\t}\n\n\tset spriteAsset(value) {\n\t\tthis._defaultClip.spriteAsset = value;\n\t}\n\n\tget spriteAsset() {\n\t\treturn this._defaultClip._spriteAsset;\n\t}\n\n\tset sprite(value) {\n\t\tthis._currentClip.sprite = value;\n\t}\n\n\tget sprite() {\n\t\treturn this._currentClip.sprite;\n\t}\n\n\tset material(value) {\n\t\tthis._material = value;\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.material = value;\n\t\t}\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset color(value) {\n\t\tthis._color.r = value.r;\n\t\tthis._color.g = value.g;\n\t\tthis._color.b = value.b;\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);\n\t\t}\n\t}\n\n\tget color() {\n\t\treturn this._color;\n\t}\n\n\tset opacity(value) {\n\t\tthis._color.a = value;\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY, value);\n\t\t}\n\t}\n\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\n\tset clips(value) {\n\t\tif (!value) {\n\t\t\tfor (const name in this._clips) {\n\t\t\t\tthis.removeClip(name);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const name in this._clips) {\n\t\t\tlet found = false;\n\n\t\t\tfor (const key in value) {\n\t\t\t\tif (value[key].name === name) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tthis._clips[name].fps = value[key].fps;\n\t\t\t\t\tthis._clips[name].loop = value[key].loop;\n\n\t\t\t\t\tif (value[key].hasOwnProperty('sprite')) {\n\t\t\t\t\t\tthis._clips[name].sprite = value[key].sprite;\n\t\t\t\t\t} else if (value[key].hasOwnProperty('spriteAsset')) {\n\t\t\t\t\t\tthis._clips[name].spriteAsset = value[key].spriteAsset;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tthis.removeClip(name);\n\t\t\t}\n\t\t}\n\n\t\tfor (const key in value) {\n\t\t\tif (this._clips[value[key].name]) continue;\n\t\t\tthis.addClip(value[key]);\n\t\t}\n\n\t\tif (this._autoPlayClip) {\n\t\t\tthis._tryAutoPlay();\n\t\t}\n\n\t\tif (!this._currentClip || !this._currentClip.sprite) {\n\t\t\tthis._hideModel();\n\t\t}\n\t}\n\n\tget clips() {\n\t\treturn this._clips;\n\t}\n\n\tget currentClip() {\n\t\treturn this._currentClip;\n\t}\n\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\n\tset flipX(value) {\n\t\tif (this._flipX === value) return;\n\t\tthis._flipX = value;\n\n\t\tthis._updateTransform();\n\t}\n\n\tget flipX() {\n\t\treturn this._flipX;\n\t}\n\n\tset flipY(value) {\n\t\tif (this._flipY === value) return;\n\t\tthis._flipY = value;\n\n\t\tthis._updateTransform();\n\t}\n\n\tget flipY() {\n\t\treturn this._flipY;\n\t}\n\n\tset width(value) {\n\t\tif (value === this._width) return;\n\t\tthis._width = value;\n\t\tthis._outerScale.x = this._width;\n\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {\n\t\t\tthis._updateTransform();\n\t\t}\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\n\tset height(value) {\n\t\tif (value === this._height) return;\n\t\tthis._height = value;\n\t\tthis._outerScale.y = this.height;\n\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {\n\t\t\tthis._updateTransform();\n\t\t}\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) return;\n\t\tconst prev = this._batchGroupId;\n\t\tthis._batchGroupId = value;\n\n\t\tif (this.entity.enabled && prev >= 0) {\n\t\t\tthis.system.app.batcher.remove(BatchGroup.SPRITE, prev, this.entity);\n\t\t}\n\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tthis.system.app.batcher.insert(BatchGroup.SPRITE, value, this.entity);\n\t\t} else {\n\t\t\tif (prev >= 0) {\n\t\t\t\tif (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {\n\t\t\t\t\tthis._showModel();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\n\tset autoPlayClip(value) {\n\t\tthis._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;\n\n\t\tthis._tryAutoPlay();\n\t}\n\n\tget autoPlayClip() {\n\t\treturn this._autoPlayClip;\n\t}\n\n\tset drawOrder(value) {\n\t\tthis._drawOrder = value;\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.drawOrder = value;\n\t\t}\n\t}\n\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\n\tset layers(value) {\n\t\tif (this._addedModel) {\n\t\t\tthis._hideModel();\n\t\t}\n\n\t\tthis._layers = value;\n\n\t\tif (!this._meshInstance) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis._showModel();\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tget aabb() {\n\t\tif (this._meshInstance) {\n\t\t\treturn this._meshInstance.aabb;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.on(\"set:layers\", this._onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.on(\"add\", this._onLayerAdded, this);\n\t\t\tscene.layers.on(\"remove\", this._onLayerRemoved, this);\n\t\t}\n\n\t\tthis._showModel();\n\n\t\tif (this._autoPlayClip) this._tryAutoPlay();\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.off(\"set:layers\", this._onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.off(\"add\", this._onLayerAdded, this);\n\t\t\tscene.layers.off(\"remove\", this._onLayerRemoved, this);\n\t\t}\n\n\t\tthis.stop();\n\n\t\tthis._hideModel();\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);\n\t\t}\n\t}\n\n\tonDestroy() {\n\t\tthis._currentClip = null;\n\n\t\tif (this._defaultClip) {\n\t\t\tthis._defaultClip._destroy();\n\n\t\t\tthis._defaultClip = null;\n\t\t}\n\n\t\tfor (const key in this._clips) {\n\t\t\tthis._clips[key]._destroy();\n\t\t}\n\n\t\tthis._clips = null;\n\n\t\tthis._hideModel();\n\n\t\tthis._model = null;\n\n\t\tif (this._node) {\n\t\t\tif (this._node.parent) this._node.parent.removeChild(this._node);\n\t\t\tthis._node = null;\n\t\t}\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.material = null;\n\t\t\tthis._meshInstance.mesh = null;\n\t\t\tthis._meshInstance = null;\n\t\t}\n\t}\n\n\t_showModel() {\n\t\tif (this._addedModel) return;\n\t\tif (!this._meshInstance) return;\n\t\tconst meshInstances = [this._meshInstance];\n\n\t\tfor (let i = 0, len = this._layers.length; i < len; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(meshInstances);\n\t\t\t}\n\t\t}\n\n\t\tthis._addedModel = true;\n\t}\n\n\t_hideModel() {\n\t\tif (!this._addedModel || !this._meshInstance) return;\n\t\tconst meshInstances = [this._meshInstance];\n\n\t\tfor (let i = 0, len = this._layers.length; i < len; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeMeshInstances(meshInstances);\n\t\t\t}\n\t\t}\n\n\t\tthis._addedModel = false;\n\t}\n\n\t_showFrame(frame) {\n\t\tif (!this.sprite) return;\n\t\tconst mesh = this.sprite.meshes[frame];\n\n\t\tif (!mesh) {\n\t\t\tif (this._meshInstance) {\n\t\t\t\tthis._meshInstance.mesh = null;\n\t\t\t\tthis._meshInstance.visible = false;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tlet material;\n\n\t\tif (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tmaterial = this.system.default9SlicedMaterialSlicedMode;\n\t\t} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tmaterial = this.system.default9SlicedMaterialTiledMode;\n\t\t} else {\n\t\t\tmaterial = this.system.defaultMaterial;\n\t\t}\n\n\t\tif (!this._meshInstance) {\n\t\t\tthis._meshInstance = new MeshInstance(mesh, this._material, this._node);\n\t\t\tthis._meshInstance.castShadow = false;\n\t\t\tthis._meshInstance.receiveShadow = false;\n\t\t\tthis._meshInstance.drawOrder = this._drawOrder;\n\n\t\t\tthis._model.meshInstances.push(this._meshInstance);\n\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);\n\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY, this._color.a);\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis._showModel();\n\t\t\t}\n\t\t}\n\n\t\tif (this._meshInstance.material !== material) {\n\t\t\tthis._meshInstance.material = material;\n\t\t}\n\n\t\tif (this._meshInstance.mesh !== mesh) {\n\t\t\tthis._meshInstance.mesh = mesh;\n\t\t\tthis._meshInstance.visible = true;\n\t\t\tthis._meshInstance._aabbVer = -1;\n\t\t}\n\n\t\tif (this.sprite.atlas && this.sprite.atlas.texture) {\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);\n\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);\n\n\t\t\tthis._meshInstance.deleteParameter(PARAM_OPACITY_MAP);\n\t\t}\n\n\t\tif (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tthis._meshInstance._updateAabbFunc = this._updateAabbFunc;\n\t\t\tconst frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];\n\n\t\t\tif (frameData) {\n\t\t\t\tconst borderWidthScale = 2 / frameData.rect.z;\n\t\t\t\tconst borderHeightScale = 2 / frameData.rect.w;\n\n\t\t\t\tthis._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);\n\n\t\t\t\tconst tex = this.sprite.atlas.texture;\n\n\t\t\t\tthis._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);\n\t\t\t} else {\n\t\t\t\tthis._innerOffset.set(0, 0, 0, 0);\n\t\t\t}\n\n\t\t\tthis._innerOffsetUniform[0] = this._innerOffset.x;\n\t\t\tthis._innerOffsetUniform[1] = this._innerOffset.y;\n\t\t\tthis._innerOffsetUniform[2] = this._innerOffset.z;\n\t\t\tthis._innerOffsetUniform[3] = this._innerOffset.w;\n\n\t\t\tthis._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);\n\n\t\t\tthis._atlasRectUniform[0] = this._atlasRect.x;\n\t\t\tthis._atlasRectUniform[1] = this._atlasRect.y;\n\t\t\tthis._atlasRectUniform[2] = this._atlasRect.z;\n\t\t\tthis._atlasRectUniform[3] = this._atlasRect.w;\n\n\t\t\tthis._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);\n\t\t} else {\n\t\t\tthis._meshInstance._updateAabbFunc = null;\n\t\t}\n\n\t\tthis._updateTransform();\n\t}\n\n\t_updateTransform() {\n\t\tlet scaleX = this.flipX ? -1 : 1;\n\t\tlet scaleY = this.flipY ? -1 : 1;\n\t\tlet posX = 0;\n\t\tlet posY = 0;\n\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tlet w = 1;\n\t\t\tlet h = 1;\n\n\t\t\tif (this.sprite.atlas) {\n\t\t\t\tconst frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];\n\n\t\t\t\tif (frameData) {\n\t\t\t\t\tw = frameData.rect.z;\n\t\t\t\t\th = frameData.rect.w;\n\t\t\t\t\tposX = (0.5 - frameData.pivot.x) * this._width;\n\t\t\t\t\tposY = (0.5 - frameData.pivot.y) * this._height;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst scaleMulX = w / this.sprite.pixelsPerUnit;\n\t\t\tconst scaleMulY = h / this.sprite.pixelsPerUnit;\n\n\t\t\tthis._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));\n\n\t\t\tscaleX *= scaleMulX;\n\t\t\tscaleY *= scaleMulY;\n\t\t\tthis._outerScale.x /= scaleMulX;\n\t\t\tthis._outerScale.y /= scaleMulY;\n\t\t\tscaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);\n\t\t\tscaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);\n\n\t\t\tif (this._meshInstance) {\n\t\t\t\tthis._outerScaleUniform[0] = this._outerScale.x;\n\t\t\t\tthis._outerScaleUniform[1] = this._outerScale.y;\n\n\t\t\t\tthis._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);\n\t\t\t}\n\t\t}\n\n\t\tthis._node.setLocalScale(scaleX, scaleY, 1);\n\n\t\tthis._node.setLocalPosition(posX, posY, 0);\n\t}\n\n\t_updateAabb(aabb) {\n\t\taabb.center.set(0, 0, 0);\n\t\taabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);\n\t\taabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());\n\t\treturn aabb;\n\t}\n\n\t_tryAutoPlay() {\n\t\tif (!this._autoPlayClip) return;\n\t\tif (this.type !== SPRITETYPE_ANIMATED) return;\n\t\tconst clip = this._clips[this._autoPlayClip];\n\n\t\tif (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.play(clip.name);\n\t\t\t}\n\t\t}\n\t}\n\n\t_onLayersChanged(oldComp, newComp) {\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis._showModel();\n\t\t}\n\t}\n\n\t_onLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\n\t\tif (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {\n\t\t\tlayer.addMeshInstances([this._meshInstance]);\n\t\t}\n\t}\n\n\t_onLayerRemoved(layer) {\n\t\tif (!this._meshInstance) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances([this._meshInstance]);\n\t}\n\n\tremoveModelFromLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this._meshInstance]);\n\t\t}\n\t}\n\n\taddClip(data) {\n\t\tconst clip = new SpriteAnimationClip(this, {\n\t\t\tname: data.name,\n\t\t\tfps: data.fps,\n\t\t\tloop: data.loop,\n\t\t\tspriteAsset: data.spriteAsset\n\t\t});\n\t\tthis._clips[data.name] = clip;\n\t\tif (clip.name && clip.name === this._autoPlayClip) this._tryAutoPlay();\n\t\treturn clip;\n\t}\n\n\tremoveClip(name) {\n\t\tdelete this._clips[name];\n\t}\n\n\tclip(name) {\n\t\treturn this._clips[name];\n\t}\n\n\tplay(name) {\n\t\tconst clip = this._clips[name];\n\t\tconst current = this._currentClip;\n\n\t\tif (current && current !== clip) {\n\t\t\tcurrent._playing = false;\n\t\t}\n\n\t\tthis._currentClip = clip;\n\n\t\tif (this._currentClip) {\n\t\t\tthis._currentClip = clip;\n\n\t\t\tthis._currentClip.play();\n\t\t}\n\n\t\treturn clip;\n\t}\n\n\tpause() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\n\t\tif (this._currentClip.isPlaying) {\n\t\t\tthis._currentClip.pause();\n\t\t}\n\t}\n\n\tresume() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\n\t\tif (this._currentClip.isPaused) {\n\t\t\tthis._currentClip.resume();\n\t\t}\n\t}\n\n\tstop() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\n\t\tthis._currentClip.stop();\n\t}\n\n}\n\nclass SpriteComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$1 = ['enabled'];\n\nclass SpriteComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'sprite';\n\t\tthis.ComponentType = SpriteComponent;\n\t\tthis.DataType = SpriteComponentData;\n\t\tthis.schema = _schema$1;\n\t\tthis._defaultTexture = null;\n\t\tthis._defaultMaterial = null;\n\t\tthis._default9SlicedMaterialSlicedMode = null;\n\t\tthis._default9SlicedMaterialTiledMode = null;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t}\n\n\tset defaultMaterial(material) {\n\t\tthis._defaultMaterial = material;\n\t}\n\n\tget defaultMaterial() {\n\t\tif (!this._defaultMaterial) {\n\t\t\tconst texture = new Texture(this.app.graphicsDevice, {\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8\n\t\t\t});\n\t\t\tconst pixels = new Uint8Array(texture.lock());\n\t\t\tpixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;\n\t\t\ttexture.name = 'sprite';\n\t\t\ttexture.unlock();\n\t\t\tconst material = new StandardMaterial();\n\t\t\tmaterial.diffuse.set(0, 0, 0);\n\t\t\tmaterial.emissive.set(0.5, 0.5, 0.5);\n\t\t\tmaterial.emissiveMap = texture;\n\t\t\tmaterial.emissiveMapTint = true;\n\t\t\tmaterial.opacityMap = texture;\n\t\t\tmaterial.opacityMapChannel = \"a\";\n\t\t\tmaterial.opacityTint = true;\n\t\t\tmaterial.opacity = 0;\n\t\t\tmaterial.useLighting = false;\n\t\t\tmaterial.useGammaTonemap = false;\n\t\t\tmaterial.useFog = false;\n\t\t\tmaterial.useSkybox = false;\n\t\t\tmaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\tmaterial.depthWrite = false;\n\t\t\tmaterial.pixelSnap = false;\n\t\t\tmaterial.cull = CULLFACE_NONE;\n\t\t\tmaterial.update();\n\t\t\tthis._defaultTexture = texture;\n\t\t\tthis._defaultMaterial = material;\n\t\t}\n\n\t\treturn this._defaultMaterial;\n\t}\n\n\tset default9SlicedMaterialSlicedMode(material) {\n\t\tthis._default9SlicedMaterialSlicedMode = material;\n\t}\n\n\tget default9SlicedMaterialSlicedMode() {\n\t\tif (!this._default9SlicedMaterialSlicedMode) {\n\t\t\tconst material = this.defaultMaterial.clone();\n\t\t\tmaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\tmaterial.update();\n\t\t\tthis._default9SlicedMaterialSlicedMode = material;\n\t\t}\n\n\t\treturn this._default9SlicedMaterialSlicedMode;\n\t}\n\n\tset default9SlicedMaterialTiledMode(material) {\n\t\tthis._default9SlicedMaterialTiledMode = material;\n\t}\n\n\tget default9SlicedMaterialTiledMode() {\n\t\tif (!this._default9SlicedMaterialTiledMode) {\n\t\t\tconst material = this.defaultMaterial.clone();\n\t\t\tmaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\tmaterial.update();\n\t\t\tthis._default9SlicedMaterialTiledMode = material;\n\t\t}\n\n\t\treturn this._default9SlicedMaterialTiledMode;\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\n\t\tif (this._defaultTexture) {\n\t\t\tthis._defaultTexture.destroy();\n\n\t\t\tthis._defaultTexture = null;\n\t\t}\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) {\n\t\t\tcomponent.enabled = data.enabled;\n\t\t}\n\n\t\tcomponent.type = data.type;\n\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tcomponent.layers = data.layers.slice(0);\n\t\t}\n\n\t\tif (data.drawOrder !== undefined) {\n\t\t\tcomponent.drawOrder = data.drawOrder;\n\t\t}\n\n\t\tif (data.color !== undefined) {\n\t\t\tif (data.color instanceof Color) {\n\t\t\t\tcomponent.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);\n\t\t\t} else {\n\t\t\t\tcomponent.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);\n\t\t\t}\n\n\t\t\tcomponent.color = component.color;\n\t\t}\n\n\t\tif (data.opacity !== undefined) {\n\t\t\tcomponent.opacity = data.opacity;\n\t\t}\n\n\t\tif (data.flipX !== undefined) {\n\t\t\tcomponent.flipX = data.flipX;\n\t\t}\n\n\t\tif (data.flipY !== undefined) {\n\t\t\tcomponent.flipY = data.flipY;\n\t\t}\n\n\t\tif (data.width !== undefined) {\n\t\t\tcomponent.width = data.width;\n\t\t}\n\n\t\tif (data.height !== undefined) {\n\t\t\tcomponent.height = data.height;\n\t\t}\n\n\t\tif (data.spriteAsset !== undefined) {\n\t\t\tcomponent.spriteAsset = data.spriteAsset;\n\t\t}\n\n\t\tif (data.sprite) {\n\t\t\tcomponent.sprite = data.sprite;\n\t\t}\n\n\t\tif (data.frame !== undefined) {\n\t\t\tcomponent.frame = data.frame;\n\t\t}\n\n\t\tif (data.clips) {\n\t\t\tfor (const name in data.clips) {\n\t\t\t\tcomponent.addClip(data.clips[name]);\n\t\t\t}\n\t\t}\n\n\t\tif (data.speed !== undefined) {\n\t\t\tcomponent.speed = data.speed;\n\t\t}\n\n\t\tif (data.autoPlayClip) {\n\t\t\tcomponent.autoPlayClip = data.autoPlayClip;\n\t\t}\n\n\t\tcomponent.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.sprite;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: source.enabled,\n\t\t\ttype: source.type,\n\t\t\tspriteAsset: source.spriteAsset,\n\t\t\tsprite: source.sprite,\n\t\t\tframe: source.frame,\n\t\t\tcolor: source.color.clone(),\n\t\t\topacity: source.opacity,\n\t\t\tflipX: source.flipX,\n\t\t\tflipY: source.flipY,\n\t\t\tspeed: source.speed,\n\t\t\tclips: source.clips,\n\t\t\tautoPlayClip: source.autoPlayClip,\n\t\t\tbatchGroupId: source.batchGroupId,\n\t\t\tdrawOrder: source.drawOrder,\n\t\t\tlayers: source.layers.slice(0)\n\t\t});\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\n\t\t\t\tif (component.data.enabled && component.entity.enabled) {\n\t\t\t\t\tconst sprite = component.entity.sprite;\n\n\t\t\t\t\tif (sprite._currentClip) {\n\t\t\t\t\t\tsprite._currentClip._update(dt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onDestroy();\n\t}\n\n}\n\nComponent._buildAccessors(SpriteComponent.prototype, _schema$1);\n\nclass ZoneComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._oldState = true;\n\t\tthis._size = new Vec3();\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\n\tset size(data) {\n\t\tif (data instanceof Vec3) {\n\t\t\tthis._size.copy(data);\n\t\t} else if (data instanceof Array && data.length >= 3) {\n\t\t\tthis.size.set(data[0], data[1], data[2]);\n\t\t}\n\t}\n\n\tget size() {\n\t\treturn this._size;\n\t}\n\n\tonEnable() {\n\t\tthis._checkState();\n\t}\n\n\tonDisable() {\n\t\tthis._checkState();\n\t}\n\n\t_onSetEnabled(prop, old, value) {\n\t\tthis._checkState();\n\t}\n\n\t_checkState() {\n\t\tconst state = this.enabled && this.entity.enabled;\n\t\tif (state === this._oldState) return;\n\t\tthis._oldState = state;\n\t\tthis.fire('enable');\n\t\tthis.fire('state', this.enabled);\n\t}\n\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\t}\n\n}\n\nclass ZoneComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema = ['enabled'];\n\nclass ZoneComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'zone';\n\t\tthis.ComponentType = ZoneComponent;\n\t\tthis.DataType = ZoneComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this._onBeforeRemove, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;\n\n\t\tif (data.size) {\n\t\t\tif (data.size instanceof Vec3) {\n\t\t\t\tcomponent.size.copy(data.size);\n\t\t\t} else if (data.size instanceof Array && data.size.length >= 3) {\n\t\t\t\tcomponent.size.set(data.size[0], data.size[1], data.size[2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst data = {\n\t\t\tsize: entity.zone.size\n\t\t};\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\t_onBeforeRemove(entity, component) {\n\t\tcomponent._onBeforeRemove();\n\t}\n\n}\n\nComponent._buildAccessors(ZoneComponent.prototype, _schema);\n\nclass ApplicationStats {\n\tconstructor(device) {\n\t\tthis.frame = {\n\t\t\tfps: 0,\n\t\t\tms: 0,\n\t\t\tdt: 0,\n\t\t\tupdateStart: 0,\n\t\t\tupdateTime: 0,\n\t\t\trenderStart: 0,\n\t\t\trenderTime: 0,\n\t\t\tphysicsStart: 0,\n\t\t\tphysicsTime: 0,\n\t\t\tcullTime: 0,\n\t\t\tsortTime: 0,\n\t\t\tskinTime: 0,\n\t\t\tmorphTime: 0,\n\t\t\tinstancingTime: 0,\n\t\t\ttriangles: 0,\n\t\t\totherPrimitives: 0,\n\t\t\tshaders: 0,\n\t\t\tmaterials: 0,\n\t\t\tcameras: 0,\n\t\t\tshadowMapUpdates: 0,\n\t\t\tshadowMapTime: 0,\n\t\t\tdepthMapTime: 0,\n\t\t\tforwardTime: 0,\n\t\t\tlightClustersTime: 0,\n\t\t\tlightClusters: 0,\n\t\t\t_timeToCountFrames: 0,\n\t\t\t_fpsAccum: 0\n\t\t};\n\t\tthis.drawCalls = {\n\t\t\tforward: 0,\n\t\t\tdepth: 0,\n\t\t\tshadow: 0,\n\t\t\timmediate: 0,\n\t\t\tmisc: 0,\n\t\t\ttotal: 0,\n\t\t\tskinned: 0,\n\t\t\tinstanced: 0,\n\t\t\tremovedByInstancing: 0\n\t\t};\n\t\tthis.misc = {\n\t\t\trenderTargetCreationTime: 0\n\t\t};\n\t\tthis.particles = {\n\t\t\tupdatesPerFrame: 0,\n\t\t\t_updatesPerFrame: 0,\n\t\t\tframeTime: 0,\n\t\t\t_frameTime: 0\n\t\t};\n\t\tthis.shaders = device._shaderStats;\n\t\tthis.vram = device._vram;\n\t\tObject.defineProperty(this.vram, 'totalUsed', {\n\t\t\tget: function () {\n\t\t\t\treturn this.tex + this.vb + this.ib;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.vram, 'geom', {\n\t\t\tget: function () {\n\t\t\t\treturn this.vb + this.ib;\n\t\t\t}\n\t\t});\n\t}\n\n\tget scene() {\n\t\treturn getApplication().scene._stats;\n\t}\n\n\tget lightmapper() {\n\t\treturn getApplication().lightmapper.stats;\n\t}\n\n\tget batcher() {\n\t\treturn getApplication().batcher._stats;\n\t}\n\n}\n\nclass SceneRegistryItem {\n\tconstructor(name, url) {\n\t\tthis.name = name;\n\t\tthis.url = url;\n\t\tthis.data = null;\n\t\tthis._loading = false;\n\t\tthis._onLoadedCallbacks = [];\n\t}\n\n\tget loaded() {\n\t\treturn !!this.data;\n\t}\n\n\tget loading() {\n\t\treturn this._loading;\n\t}\n\n}\n\nclass SceneRegistry {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis._list = [];\n\t\tthis._index = {};\n\t\tthis._urlIndex = {};\n\t}\n\n\tdestroy() {\n\t\tthis._app = null;\n\t}\n\n\tlist() {\n\t\treturn this._list;\n\t}\n\n\tadd(name, url) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst item = new SceneRegistryItem(name, url);\n\n\t\tconst i = this._list.push(item);\n\n\t\tthis._index[item.name] = i - 1;\n\t\tthis._urlIndex[item.url] = i - 1;\n\t\treturn true;\n\t}\n\n\tfind(name) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\treturn this._list[this._index[name]];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfindByUrl(url) {\n\t\tif (this._urlIndex.hasOwnProperty(url)) {\n\t\t\treturn this._list[this._urlIndex[url]];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tremove(name) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\tconst idx = this._index[name];\n\t\t\tlet item = this._list[idx];\n\t\t\tdelete this._urlIndex[item.url];\n\t\t\tdelete this._index[name];\n\n\t\t\tthis._list.splice(idx, 1);\n\n\t\t\tfor (let i = 0; i < this._list.length; i++) {\n\t\t\t\titem = this._list[i];\n\t\t\t\tthis._index[item.name] = i;\n\t\t\t\tthis._urlIndex[item.url] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t_loadSceneData(sceneItem, storeInCache, callback) {\n\t\tlet url = sceneItem;\n\n\t\tif (sceneItem instanceof SceneRegistryItem) {\n\t\t\turl = sceneItem.url;\n\t\t} else {\n\t\t\tsceneItem = this.findByUrl(url);\n\n\t\t\tif (!sceneItem) {\n\t\t\t\tsceneItem = new SceneRegistryItem('Untitled', url);\n\t\t\t}\n\t\t}\n\n\t\tif (!sceneItem.url) {\n\t\t\tcallback(\"URL or SceneRegistryItem is null when loading a scene\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (sceneItem.loaded) {\n\t\t\tcallback(null, sceneItem);\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this._app.loader.getHandler(\"hierarchy\");\n\n\t\tif (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {\n\t\t\turl = path.join(this._app.assets.prefix, url);\n\t\t}\n\n\t\tsceneItem._onLoadedCallbacks.push(callback);\n\n\t\tif (!sceneItem._loading) {\n\t\t\thandler.load(url, function (err, data) {\n\t\t\t\tsceneItem.data = data;\n\t\t\t\tsceneItem._loading = false;\n\n\t\t\t\tfor (let i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {\n\t\t\t\t\tsceneItem._onLoadedCallbacks[i](err, sceneItem);\n\t\t\t\t}\n\n\t\t\t\tif (!storeInCache) {\n\t\t\t\t\tsceneItem.data = null;\n\t\t\t\t}\n\n\t\t\t\tsceneItem._onLoadedCallbacks.length = 0;\n\t\t\t});\n\t\t}\n\n\t\tsceneItem._loading = true;\n\t}\n\n\tloadSceneData(sceneItem, callback) {\n\t\tthis._loadSceneData(sceneItem, true, callback);\n\t}\n\n\tunloadSceneData(sceneItem) {\n\t\tif (typeof sceneItem === 'string') {\n\t\t\tsceneItem = this.findByUrl(sceneItem);\n\t\t}\n\n\t\tif (sceneItem) {\n\t\t\tsceneItem.data = null;\n\t\t}\n\t}\n\n\tloadSceneHierarchy(sceneItem, callback) {\n\t\tconst self = this;\n\n\t\tconst handler = this._app.loader.getHandler(\"hierarchy\");\n\n\t\tthis._loadSceneData(sceneItem, false, function (err, sceneItem) {\n\t\t\tif (err) {\n\t\t\t\tif (callback) callback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst url = sceneItem.url;\n\t\t\tconst data = sceneItem.data;\n\n\t\t\tconst _loaded = function _loaded() {\n\t\t\t\tself._app.systems.script.preloading = true;\n\t\t\t\tconst entity = handler.open(url, data);\n\t\t\t\tself._app.systems.script.preloading = false;\n\n\t\t\t\tself._app.loader.clearCache(url, \"hierarchy\");\n\n\t\t\t\tself._app.root.addChild(entity);\n\n\t\t\t\tself._app.systems.fire('initialize', entity);\n\n\t\t\t\tself._app.systems.fire('postInitialize', entity);\n\n\t\t\t\tself._app.systems.fire('postPostInitialize', entity);\n\n\t\t\t\tif (callback) callback(err, entity);\n\t\t\t};\n\n\t\t\tself._app._preloadScripts(data, _loaded);\n\t\t});\n\t}\n\n\tloadSceneSettings(sceneItem, callback) {\n\t\tconst self = this;\n\n\t\tthis._loadSceneData(sceneItem, false, function (err, sceneItem) {\n\t\t\tif (!err) {\n\t\t\t\tself._app.applySceneSettings(sceneItem.data.settings);\n\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tloadScene(url, callback) {\n\t\tconst self = this;\n\n\t\tconst handler = this._app.loader.getHandler(\"scene\");\n\n\t\tif (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {\n\t\t\turl = path.join(this._app.assets.prefix, url);\n\t\t}\n\n\t\thandler.load(url, function (err, data) {\n\t\t\tif (!err) {\n\t\t\t\tconst _loaded = function _loaded() {\n\t\t\t\t\tself._app.systems.script.preloading = true;\n\t\t\t\t\tconst scene = handler.open(url, data);\n\t\t\t\t\tconst sceneItem = self.findByUrl(url);\n\n\t\t\t\t\tif (sceneItem && !sceneItem.loaded) {\n\t\t\t\t\t\tsceneItem.data = data;\n\t\t\t\t\t}\n\n\t\t\t\t\tself._app.systems.script.preloading = false;\n\n\t\t\t\t\tself._app.loader.clearCache(url, \"scene\");\n\n\t\t\t\t\tself._app.loader.patch({\n\t\t\t\t\t\tresource: scene,\n\t\t\t\t\t\ttype: \"scene\"\n\t\t\t\t\t}, self._app.assets);\n\n\t\t\t\t\tself._app.root.addChild(scene.root);\n\n\t\t\t\t\tif (self._app.systems.rigidbody && typeof Ammo !== 'undefined') {\n\t\t\t\t\t\tself._app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback(null, scene);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tself._app._preloadScripts(data, _loaded);\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n}\n\nclass SceneDepth {\n\tconstructor(application) {\n\t\tthis.application = application;\n\t\tthis.device = application.graphicsDevice;\n\t\tthis.clearOptions = null;\n\t\tthis.layer = null;\n\t\tthis.init();\n\t}\n\n\tallocateTexture(device, name, format) {\n\t\tconst texture = new Texture(device, {\n\t\t\tformat: format,\n\t\t\twidth: device.width,\n\t\t\theight: device.height,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\ttexture.name = name;\n\t\tdevice.scope.resolve(\"uDepthMap\").setValue(texture);\n\t\treturn texture;\n\t}\n\n\tallocateRenderTarget(renderTarget, device, name, format, isDepth) {\n\t\tconst buffer = this.allocateTexture(device, name, format);\n\n\t\tif (renderTarget) {\n\t\t\trenderTarget.destroyFrameBuffers();\n\n\t\t\tif (isDepth) {\n\t\t\t\trenderTarget._depthBuffer = buffer;\n\t\t\t} else {\n\t\t\t\trenderTarget._colorBuffer = buffer;\n\t\t\t}\n\t\t} else {\n\t\t\trenderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: isDepth ? null : buffer,\n\t\t\t\tdepthBuffer: isDepth ? buffer : null,\n\t\t\t\tdepth: !isDepth,\n\t\t\t\tstencil: device.supportsStencil,\n\t\t\t\tautoResolve: false\n\t\t\t});\n\t\t}\n\n\t\treturn renderTarget;\n\t}\n\n\treleaseRenderTarget(rt) {\n\t\tif (rt) {\n\t\t\trt.destroyTextureBuffers();\n\t\t\trt.destroy();\n\t\t}\n\t}\n\n\tinitWebGl2() {\n\t\tconst app = this.application;\n\t\tconst self = this;\n\t\tthis.clearOptions = {\n\t\t\tflags: 0\n\t\t};\n\t\tthis.layer = new Layer({\n\t\t\tenabled: false,\n\t\t\tname: \"Depth\",\n\t\t\tid: LAYERID_DEPTH,\n\t\t\tonEnable: function () {\n\t\t\t\tself.releaseRenderTarget(this.renderTarget);\n\t\t\t\tthis.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, \"rt-depth2\", PIXELFORMAT_DEPTHSTENCIL, true);\n\t\t\t},\n\t\t\tonDisable: function () {\n\t\t\t\tself.releaseRenderTarget(this.renderTarget);\n\t\t\t\tthis.renderTarget = null;\n\t\t\t},\n\t\t\tonPreRenderOpaque: function (cameraPass) {\n\t\t\t\tconst gl = app.graphicsDevice.gl;\n\t\t\t\tthis.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n\n\t\t\t\tif (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {\n\t\t\t\t\tthis.onEnable();\n\t\t\t\t}\n\n\t\t\t\tthis.oldClear = this.cameras[cameraPass].camera._clearOptions;\n\t\t\t\tthis.cameras[cameraPass].camera._clearOptions = self.clearOptions;\n\t\t\t},\n\t\t\tonPostRenderOpaque: function (cameraPass) {\n\t\t\t\tif (this.renderTarget) {\n\t\t\t\t\tthis.cameras[cameraPass].camera._clearOptions = this.oldClear;\n\t\t\t\t\tapp.graphicsDevice.setRenderTarget(this.renderTarget);\n\t\t\t\t\tapp.graphicsDevice.updateBegin();\n\t\t\t\t\tconst gl = app.graphicsDevice.gl;\n\t\t\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);\n\t\t\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer);\n\t\t\t\t\tgl.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tinitWebGl1() {\n\t\tconst app = this.application;\n\t\tconst self = this;\n\t\tthis.clearOptions = {\n\t\t\tcolor: [254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255],\n\t\t\tdepth: 1.0,\n\t\t\tflags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH\n\t\t};\n\t\tthis.layer = new Layer({\n\t\t\tenabled: false,\n\t\t\tname: \"Depth\",\n\t\t\tid: LAYERID_DEPTH,\n\t\t\tshaderPass: SHADER_DEPTH,\n\t\t\tonEnable: function () {\n\t\t\t\tself.releaseRenderTarget(this.renderTarget);\n\t\t\t\tthis.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, \"rt-depth1\", PIXELFORMAT_R8_G8_B8_A8, false);\n\t\t\t},\n\t\t\tonDisable: function () {\n\t\t\t\tself.releaseRenderTarget(this.renderTarget);\n\t\t\t\tthis.renderTarget = null;\n\t\t\t},\n\t\t\tonPostCull: function (cameraPass) {\n\t\t\t\tconst visibleObjects = this.instances.visibleOpaque[cameraPass];\n\t\t\t\tconst visibleList = visibleObjects.list;\n\t\t\t\tconst layerComposition = app.scene.layers;\n\t\t\t\tconst subLayerEnabled = layerComposition.subLayerEnabled;\n\t\t\t\tconst isTransparent = layerComposition.subLayerList;\n\t\t\t\tconst rt = app.scene.layers.getLayerById(LAYERID_WORLD).renderTarget;\n\t\t\t\tconst cam = this.cameras[cameraPass];\n\t\t\t\tlet visibleLength = 0;\n\t\t\t\tconst layers = layerComposition.layerList;\n\n\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\tconst layer = layers[i];\n\t\t\t\t\tif (layer === this) break;\n\t\t\t\t\tif (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;\n\t\t\t\t\tconst layerCamId = layer.cameras.indexOf(cam);\n\t\t\t\t\tif (layerCamId < 0) continue;\n\t\t\t\t\tconst transparent = isTransparent[i];\n\t\t\t\t\tlet layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];\n\t\t\t\t\tconst layerVisibleListLength = layerVisibleList.length;\n\t\t\t\t\tlayerVisibleList = layerVisibleList.list;\n\n\t\t\t\t\tfor (let j = 0; j < layerVisibleListLength; j++) {\n\t\t\t\t\t\tconst drawCall = layerVisibleList[j];\n\n\t\t\t\t\t\tif (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {\n\t\t\t\t\t\t\tvisibleList[visibleLength] = drawCall;\n\t\t\t\t\t\t\tvisibleLength++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvisibleObjects.length = visibleLength;\n\t\t\t},\n\t\t\tonPreRenderOpaque: function (cameraPass) {\n\t\t\t\tif (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {\n\t\t\t\t\tthis.onEnable();\n\t\t\t\t}\n\n\t\t\t\tthis.oldClear = this.cameras[cameraPass].camera._clearOptions;\n\t\t\t\tthis.cameras[cameraPass].camera._clearOptions = self.clearOptions;\n\t\t\t},\n\t\t\tonDrawCall: function () {\n\t\t\t\tapp.graphicsDevice.setColorWrite(true, true, true, true);\n\t\t\t},\n\t\t\tonPostRenderOpaque: function (cameraPass) {\n\t\t\t\tif (!this.renderTarget) return;\n\t\t\t\tthis.cameras[cameraPass].camera._clearOptions = this.oldClear;\n\t\t\t}\n\t\t});\n\t}\n\n\tinit() {\n\t\tif (this.device.webgl2) {\n\t\t\tthis.initWebGl2();\n\t\t} else {\n\t\t\tthis.initWebGl1();\n\t\t}\n\t}\n\n\tpatch(layer) {\n\t\tlayer.onEnable = this.layer.onEnable;\n\t\tlayer.onDisable = this.layer.onDisable;\n\t\tlayer.onPreRenderOpaque = this.layer.onPreRenderOpaque;\n\t\tlayer.onPostRenderOpaque = this.layer.onPostRenderOpaque;\n\t\tlayer.shaderPass = this.layer.shaderPass;\n\t\tlayer.onPostCull = this.layer.onPostCull;\n\t\tlayer.onDrawCall = this.layer.onDrawCall;\n\t}\n\n}\n\nclass Progress {\n\tconstructor(length) {\n\t\tthis.length = length;\n\t\tthis.count = 0;\n\t}\n\n\tinc() {\n\t\tthis.count++;\n\t}\n\n\tdone() {\n\t\treturn this.count === this.length;\n\t}\n\n}\n\nlet app = null;\n\nclass Application extends EventHandler {\n\tconstructor(canvas, options = {}) {\n\t\tsuper();\n\t\tApplication._applications[canvas.id] = this;\n\t\tsetApplication(this);\n\t\tapp = this;\n\t\tthis._destroyRequested = false;\n\t\tthis._inFrameUpdate = false;\n\t\tthis._time = 0;\n\t\tthis.timeScale = 1;\n\t\tthis.maxDeltaTime = 0.1;\n\t\tthis.frame = 0;\n\t\tthis.autoRender = true;\n\t\tthis.renderNextFrame = false;\n\t\tthis.useLegacyScriptAttributeCloning = script.legacy;\n\t\tthis._librariesLoaded = false;\n\t\tthis._fillMode = FILLMODE_KEEP_ASPECT;\n\t\tthis._resolutionMode = RESOLUTION_FIXED;\n\t\tthis._allowResize = true;\n\t\tthis.context = this;\n\t\tif (!options.graphicsDeviceOptions) options.graphicsDeviceOptions = {};\n\n\t\tif (platform.browser && !!navigator.xr) {\n\t\t\toptions.graphicsDeviceOptions.xrCompatible = true;\n\t\t}\n\n\t\toptions.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;\n\t\tthis.graphicsDevice = new GraphicsDevice(canvas, options.graphicsDeviceOptions);\n\n\t\tthis._initDefaultMaterial();\n\n\t\tthis.stats = new ApplicationStats(this.graphicsDevice);\n\t\tthis._soundManager = new SoundManager(options);\n\t\tthis.loader = new ResourceLoader(this);\n\t\tLightsBuffer.init(this.graphicsDevice);\n\t\tthis._entityIndex = {};\n\t\tthis.scene = new Scene(this.graphicsDevice);\n\n\t\tthis._registerSceneImmediate(this.scene);\n\n\t\tthis.root = new Entity();\n\t\tthis.root._enabledInHierarchy = true;\n\t\tthis._enableList = [];\n\t\tthis._enableList.size = 0;\n\t\tthis.assets = new AssetRegistry(this.loader);\n\t\tif (options.assetPrefix) this.assets.prefix = options.assetPrefix;\n\t\tthis.bundles = new BundleRegistry(this.assets);\n\t\tthis.enableBundles = typeof TextDecoder !== 'undefined';\n\t\tthis.scriptsOrder = options.scriptsOrder || [];\n\t\tthis.scripts = new ScriptRegistry(this);\n\t\tthis.i18n = new I18n(this);\n\t\tthis.scenes = new SceneRegistry(this);\n\t\tconst self = this;\n\t\tthis.defaultLayerWorld = new Layer({\n\t\t\tname: \"World\",\n\t\t\tid: LAYERID_WORLD\n\t\t});\n\t\tthis.sceneDepth = new SceneDepth(this);\n\t\tthis.defaultLayerDepth = this.sceneDepth.layer;\n\t\tthis.defaultLayerSkybox = new Layer({\n\t\t\tenabled: true,\n\t\t\tname: \"Skybox\",\n\t\t\tid: LAYERID_SKYBOX,\n\t\t\topaqueSortMode: SORTMODE_NONE\n\t\t});\n\t\tthis.defaultLayerUi = new Layer({\n\t\t\tenabled: true,\n\t\t\tname: \"UI\",\n\t\t\tid: LAYERID_UI,\n\t\t\ttransparentSortMode: SORTMODE_MANUAL,\n\t\t\tpassThrough: false\n\t\t});\n\t\tthis.defaultLayerImmediate = new Layer({\n\t\t\tenabled: true,\n\t\t\tname: \"Immediate\",\n\t\t\tid: LAYERID_IMMEDIATE,\n\t\t\topaqueSortMode: SORTMODE_NONE,\n\t\t\tpassThrough: true\n\t\t});\n\t\tconst defaultLayerComposition = new LayerComposition(\"default\");\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerWorld);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerDepth);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerSkybox);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerWorld);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerImmediate);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerImmediate);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerUi);\n\t\tthis.scene.layers = defaultLayerComposition;\n\t\tthis._immediateLayer = this.defaultLayerImmediate;\n\t\tthis.scene.on('set:layers', function (oldComp, newComp) {\n\t\t\tconst list = newComp.layerList;\n\t\t\tlet layer;\n\n\t\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\t\tlayer = list[i];\n\n\t\t\t\tswitch (layer.id) {\n\t\t\t\t\tcase LAYERID_DEPTH:\n\t\t\t\t\t\tself.sceneDepth.patch(layer);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LAYERID_UI:\n\t\t\t\t\t\tlayer.passThrough = self.defaultLayerUi.passThrough;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LAYERID_IMMEDIATE:\n\t\t\t\t\t\tlayer.passThrough = self.defaultLayerImmediate.passThrough;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tAreaLightLuts.createPlaceholder(this.graphicsDevice);\n\t\tthis.renderer = new ForwardRenderer(this.graphicsDevice);\n\t\tthis.renderer.scene = this.scene;\n\t\tthis.lightmapper = new Lightmapper(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);\n\t\tthis.once('prerender', this._firstBake, this);\n\t\tthis.batcher = new BatchManager(this.graphicsDevice, this.root, this.scene);\n\t\tthis.once('prerender', this._firstBatch, this);\n\t\tthis.keyboard = options.keyboard || null;\n\t\tthis.mouse = options.mouse || null;\n\t\tthis.touch = options.touch || null;\n\t\tthis.gamepads = options.gamepads || null;\n\t\tthis.elementInput = options.elementInput || null;\n\t\tif (this.elementInput) this.elementInput.app = this;\n\t\tthis.vr = null;\n\t\tthis.xr = new XrManager(this);\n\t\tif (this.elementInput) this.elementInput.attachSelectEvents();\n\t\tthis._inTools = false;\n\t\tthis._skyboxAsset = null;\n\t\tthis._scriptPrefix = options.scriptPrefix || '';\n\n\t\tif (this.enableBundles) {\n\t\t\tthis.loader.addHandler(\"bundle\", new BundleHandler(this.assets));\n\t\t}\n\n\t\tthis.loader.addHandler(\"animation\", new AnimationHandler());\n\t\tthis.loader.addHandler(\"animclip\", new AnimClipHandler());\n\t\tthis.loader.addHandler(\"animstategraph\", new AnimStateGraphHandler());\n\t\tthis.loader.addHandler(\"model\", new ModelHandler(this.graphicsDevice));\n\t\tthis.loader.addHandler(\"render\", new RenderHandler(this.assets));\n\t\tthis.loader.addHandler(\"material\", new MaterialHandler(this));\n\t\tthis.loader.addHandler(\"texture\", new TextureHandler(this.graphicsDevice, this.assets, this.loader));\n\t\tthis.loader.addHandler(\"text\", new TextHandler());\n\t\tthis.loader.addHandler(\"json\", new JsonHandler());\n\t\tthis.loader.addHandler(\"audio\", new AudioHandler(this._soundManager));\n\t\tthis.loader.addHandler(\"script\", new ScriptHandler(this));\n\t\tthis.loader.addHandler(\"scene\", new SceneHandler(this));\n\t\tthis.loader.addHandler(\"cubemap\", new CubemapHandler(this.graphicsDevice, this.assets, this.loader));\n\t\tthis.loader.addHandler(\"html\", new HtmlHandler());\n\t\tthis.loader.addHandler(\"css\", new CssHandler());\n\t\tthis.loader.addHandler(\"shader\", new ShaderHandler());\n\t\tthis.loader.addHandler(\"hierarchy\", new HierarchyHandler(this));\n\t\tthis.loader.addHandler(\"folder\", new FolderHandler());\n\t\tthis.loader.addHandler(\"font\", new FontHandler(this.loader));\n\t\tthis.loader.addHandler(\"binary\", new BinaryHandler());\n\t\tthis.loader.addHandler(\"textureatlas\", new TextureAtlasHandler(this.loader));\n\t\tthis.loader.addHandler(\"sprite\", new SpriteHandler(this.assets, this.graphicsDevice));\n\t\tthis.loader.addHandler(\"template\", new TemplateHandler(this));\n\t\tthis.loader.addHandler(\"container\", new ContainerHandler(this.graphicsDevice, this.assets));\n\t\tthis.systems = new ComponentSystemRegistry();\n\t\tthis.systems.add(new RigidBodyComponentSystem(this));\n\t\tthis.systems.add(new CollisionComponentSystem(this));\n\t\tthis.systems.add(new JointComponentSystem(this));\n\t\tthis.systems.add(new AnimationComponentSystem(this));\n\t\tthis.systems.add(new AnimComponentSystem(this));\n\t\tthis.systems.add(new ModelComponentSystem(this));\n\t\tthis.systems.add(new RenderComponentSystem(this));\n\t\tthis.systems.add(new CameraComponentSystem(this));\n\t\tthis.systems.add(new LightComponentSystem(this));\n\n\t\tif (script.legacy) {\n\t\t\tthis.systems.add(new ScriptLegacyComponentSystem(this));\n\t\t} else {\n\t\t\tthis.systems.add(new ScriptComponentSystem(this));\n\t\t}\n\n\t\tthis.systems.add(new AudioSourceComponentSystem(this, this._soundManager));\n\t\tthis.systems.add(new SoundComponentSystem(this, this._soundManager));\n\t\tthis.systems.add(new AudioListenerComponentSystem(this, this._soundManager));\n\t\tthis.systems.add(new ParticleSystemComponentSystem(this));\n\t\tthis.systems.add(new ScreenComponentSystem(this));\n\t\tthis.systems.add(new ElementComponentSystem(this));\n\t\tthis.systems.add(new ButtonComponentSystem(this));\n\t\tthis.systems.add(new ScrollViewComponentSystem(this));\n\t\tthis.systems.add(new ScrollbarComponentSystem(this));\n\t\tthis.systems.add(new SpriteComponentSystem(this));\n\t\tthis.systems.add(new LayoutGroupComponentSystem(this));\n\t\tthis.systems.add(new LayoutChildComponentSystem(this));\n\t\tthis.systems.add(new ZoneComponentSystem(this));\n\t\tthis._visibilityChangeHandler = this.onVisibilityChange.bind(this);\n\n\t\tif (typeof document !== 'undefined') {\n\t\t\tif (document.hidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'hidden';\n\t\t\t\tdocument.addEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.mozHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'mozHidden';\n\t\t\t\tdocument.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.msHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'msHidden';\n\t\t\t\tdocument.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.webkitHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'webkitHidden';\n\t\t\t\tdocument.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t}\n\t\t}\n\n\t\tthis.tick = makeTick(this);\n\t}\n\n\tstatic getApplication(id) {\n\t\treturn id ? Application._applications[id] : getApplication();\n\t}\n\n\t_initDefaultMaterial() {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.name = \"Default Material\";\n\t\tmaterial.shadingModel = SPECULAR_BLINN;\n\t\tDefaultMaterial.add(this.graphicsDevice, material);\n\t}\n\n\tget fillMode() {\n\t\treturn this._fillMode;\n\t}\n\n\tget resolutionMode() {\n\t\treturn this._resolutionMode;\n\t}\n\n\tconfigure(url, callback) {\n\t\thttp.get(url, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst props = response.application_properties;\n\t\t\tconst scenes = response.scenes;\n\t\t\tconst assets = response.assets;\n\n\t\t\tthis._parseApplicationProperties(props, err => {\n\t\t\t\tthis._parseScenes(scenes);\n\n\t\t\t\tthis._parseAssets(assets);\n\n\t\t\t\tif (!err) {\n\t\t\t\t\tcallback(null);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpreload(callback) {\n\t\tthis.fire(\"preload:start\");\n\t\tconst assets = this.assets.list({\n\t\t\tpreload: true\n\t\t});\n\t\tconst progress = new Progress(assets.length);\n\t\tlet _done = false;\n\n\t\tconst done = () => {\n\t\t\tif (!this.graphicsDevice) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!_done && progress.done()) {\n\t\t\t\t_done = true;\n\t\t\t\tthis.fire(\"preload:end\");\n\t\t\t\tcallback();\n\t\t\t}\n\t\t};\n\n\t\tconst total = assets.length;\n\n\t\tif (progress.length) {\n\t\t\tconst onAssetLoad = asset => {\n\t\t\t\tprogress.inc();\n\t\t\t\tthis.fire('preload:progress', progress.count / total);\n\t\t\t\tif (progress.done()) done();\n\t\t\t};\n\n\t\t\tconst onAssetError = (err, asset) => {\n\t\t\t\tprogress.inc();\n\t\t\t\tthis.fire('preload:progress', progress.count / total);\n\t\t\t\tif (progress.done()) done();\n\t\t\t};\n\n\t\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\t\tif (!assets[i].loaded) {\n\t\t\t\t\tassets[i].once('load', onAssetLoad);\n\t\t\t\t\tassets[i].once('error', onAssetError);\n\t\t\t\t\tthis.assets.load(assets[i]);\n\t\t\t\t} else {\n\t\t\t\t\tprogress.inc();\n\t\t\t\t\tthis.fire(\"preload:progress\", progress.count / total);\n\t\t\t\t\tif (progress.done()) done();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdone();\n\t\t}\n\t}\n\n\t_preloadScripts(sceneData, callback) {\n\t\tif (!script.legacy) {\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.systems.script.preloading = true;\n\n\t\tconst scripts = this._getScriptReferences(sceneData);\n\n\t\tconst l = scripts.length;\n\t\tconst progress = new Progress(l);\n\t\tconst regex = /^http(s)?:\\/\\//;\n\n\t\tif (l) {\n\t\t\tconst onLoad = (err, ScriptType) => {\n\t\t\t\tif (err) console.error(err);\n\t\t\t\tprogress.inc();\n\n\t\t\t\tif (progress.done()) {\n\t\t\t\t\tthis.systems.script.preloading = false;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\tlet scriptUrl = scripts[i];\n\t\t\t\tif (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) scriptUrl = path.join(self._scriptPrefix, scripts[i]);\n\t\t\t\tthis.loader.load(scriptUrl, 'script', onLoad);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.systems.script.preloading = false;\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t_handleAreaLightDataProperty(prop) {\n\t\tconst asset = this.assets.get(prop);\n\n\t\tif (asset) {\n\t\t\tthis.setAreaLightLuts(asset);\n\t\t} else {\n\t\t\tthis.assets.once('add:' + prop, this.setAreaLightLuts, this);\n\t\t}\n\t}\n\n\t_parseApplicationProperties(props, callback) {\n\t\tif (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {\n\t\t\tthis.loader.enableRetry(props.maxAssetRetries);\n\t\t}\n\n\t\tif (!props.useDevicePixelRatio) props.useDevicePixelRatio = props.use_device_pixel_ratio;\n\t\tif (!props.resolutionMode) props.resolutionMode = props.resolution_mode;\n\t\tif (!props.fillMode) props.fillMode = props.fill_mode;\n\t\tthis._width = props.width;\n\t\tthis._height = props.height;\n\n\t\tif (props.useDevicePixelRatio) {\n\t\t\tthis.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\t\t}\n\n\t\tthis.setCanvasResolution(props.resolutionMode, this._width, this._height);\n\t\tthis.setCanvasFillMode(props.fillMode, this._width, this._height);\n\n\t\tif (props.layers && props.layerOrder) {\n\t\t\tconst composition = new LayerComposition(\"application\");\n\t\t\tconst layers = {};\n\n\t\t\tfor (const key in props.layers) {\n\t\t\t\tconst data = props.layers[key];\n\t\t\t\tdata.id = parseInt(key, 10);\n\t\t\t\tdata.enabled = data.id !== LAYERID_DEPTH;\n\t\t\t\tlayers[key] = new Layer(data);\n\t\t\t}\n\n\t\t\tfor (let i = 0, len = props.layerOrder.length; i < len; i++) {\n\t\t\t\tconst sublayer = props.layerOrder[i];\n\t\t\t\tconst layer = layers[sublayer.layer];\n\t\t\t\tif (!layer) continue;\n\n\t\t\t\tif (sublayer.transparent) {\n\t\t\t\t\tcomposition.pushTransparent(layer);\n\t\t\t\t} else {\n\t\t\t\t\tcomposition.pushOpaque(layer);\n\t\t\t\t}\n\n\t\t\t\tcomposition.subLayerEnabled[i] = sublayer.enabled;\n\t\t\t}\n\n\t\t\tthis.scene.layers = composition;\n\t\t}\n\n\t\tif (props.batchGroups) {\n\t\t\tfor (let i = 0, len = props.batchGroups.length; i < len; i++) {\n\t\t\t\tconst grp = props.batchGroups[i];\n\t\t\t\tthis.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);\n\t\t\t}\n\t\t}\n\n\t\tif (props.i18nAssets) {\n\t\t\tthis.i18n.assets = props.i18nAssets;\n\t\t}\n\n\t\tif (props.areaLightDataAsset) {\n\t\t\tthis._handleAreaLightDataProperty(props.areaLightDataAsset);\n\t\t}\n\n\t\tthis._loadLibraries(props.libraries, callback);\n\t}\n\n\t_loadLibraries(urls, callback) {\n\t\tconst len = urls.length;\n\t\tlet count = len;\n\t\tconst regex = /^http(s)?:\\/\\//;\n\n\t\tif (len) {\n\t\t\tconst onLoad = (err, script) => {\n\t\t\t\tcount--;\n\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else if (count === 0) {\n\t\t\t\t\tthis.onLibrariesLoaded();\n\t\t\t\t\tcallback(null);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\tlet url = urls[i];\n\t\t\t\tif (!regex.test(url.toLowerCase()) && this._scriptPrefix) url = path.join(this._scriptPrefix, url);\n\t\t\t\tthis.loader.load(url, 'script', onLoad);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.onLibrariesLoaded();\n\t\t\tcallback(null);\n\t\t}\n\t}\n\n\t_parseScenes(scenes) {\n\t\tif (!scenes) return;\n\n\t\tfor (let i = 0; i < scenes.length; i++) {\n\t\t\tthis.scenes.add(scenes[i].name, scenes[i].url);\n\t\t}\n\t}\n\n\t_parseAssets(assets) {\n\t\tconst list = [];\n\t\tconst scriptsIndex = {};\n\t\tconst bundlesIndex = {};\n\n\t\tif (!script.legacy) {\n\t\t\tfor (let i = 0; i < this.scriptsOrder.length; i++) {\n\t\t\t\tconst id = this.scriptsOrder[i];\n\t\t\t\tif (!assets[id]) continue;\n\t\t\t\tscriptsIndex[id] = true;\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\n\t\t\tif (this.enableBundles) {\n\t\t\t\tfor (const id in assets) {\n\t\t\t\t\tif (assets[id].type === 'bundle') {\n\t\t\t\t\t\tbundlesIndex[id] = true;\n\t\t\t\t\t\tlist.push(assets[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const id in assets) {\n\t\t\t\tif (scriptsIndex[id] || bundlesIndex[id]) continue;\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.enableBundles) {\n\t\t\t\tfor (const id in assets) {\n\t\t\t\t\tif (assets[id].type === 'bundle') {\n\t\t\t\t\t\tbundlesIndex[id] = true;\n\t\t\t\t\t\tlist.push(assets[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const id in assets) {\n\t\t\t\tif (bundlesIndex[id]) continue;\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst data = list[i];\n\t\t\tconst asset = new Asset(data.name, data.type, data.file, data.data);\n\t\t\tasset.id = parseInt(data.id, 10);\n\t\t\tasset.preload = data.preload ? data.preload : false;\n\t\t\tasset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;\n\t\t\tasset.tags.add(data.tags);\n\n\t\t\tif (data.i18n) {\n\t\t\t\tfor (const locale in data.i18n) {\n\t\t\t\t\tasset.addLocalizedAssetId(locale, data.i18n[locale]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.assets.add(asset);\n\t\t}\n\t}\n\n\t_getScriptReferences(scene) {\n\t\tlet priorityScripts = [];\n\n\t\tif (scene.settings.priority_scripts) {\n\t\t\tpriorityScripts = scene.settings.priority_scripts;\n\t\t}\n\n\t\tconst _scripts = [];\n\t\tconst _index = {};\n\n\t\tfor (let i = 0; i < priorityScripts.length; i++) {\n\t\t\t_scripts.push(priorityScripts[i]);\n\n\t\t\t_index[priorityScripts[i]] = true;\n\t\t}\n\n\t\tconst entities = scene.entities;\n\n\t\tfor (const key in entities) {\n\t\t\tif (!entities[key].components.script) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst scripts = entities[key].components.script.scripts;\n\n\t\t\tfor (let i = 0; i < scripts.length; i++) {\n\t\t\t\tif (_index[scripts[i].url]) continue;\n\n\t\t\t\t_scripts.push(scripts[i].url);\n\n\t\t\t\t_index[scripts[i].url] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn _scripts;\n\t}\n\n\tstart() {\n\t\tthis.frame = 0;\n\t\tthis.fire(\"start\", {\n\t\t\ttimestamp: now(),\n\t\t\ttarget: this\n\t\t});\n\n\t\tif (!this._librariesLoaded) {\n\t\t\tthis.onLibrariesLoaded();\n\t\t}\n\n\t\tthis.systems.fire('initialize', this.root);\n\t\tthis.fire('initialize');\n\t\tthis.systems.fire('postInitialize', this.root);\n\t\tthis.systems.fire('postPostInitialize', this.root);\n\t\tthis.fire('postinitialize');\n\t\tthis.tick();\n\t}\n\n\tinputUpdate(dt) {\n\t\tif (this.controller) {\n\t\t\tthis.controller.update(dt);\n\t\t}\n\n\t\tif (this.mouse) {\n\t\t\tthis.mouse.update(dt);\n\t\t}\n\n\t\tif (this.keyboard) {\n\t\t\tthis.keyboard.update(dt);\n\t\t}\n\n\t\tif (this.gamepads) {\n\t\t\tthis.gamepads.update(dt);\n\t\t}\n\t}\n\n\tupdate(dt) {\n\t\tthis.frame++;\n\t\tthis.graphicsDevice.updateClientRect();\n\t\tif (this.vr) this.vr.poll();\n\t\tif (script.legacy) this.systems.fire('fixedUpdate', 1.0 / 60.0);\n\t\tthis.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);\n\t\tthis.systems.fire('animationUpdate', dt);\n\t\tthis.systems.fire('postUpdate', dt);\n\t\tthis.fire(\"update\", dt);\n\t\tthis.inputUpdate(dt);\n\t}\n\n\trender() {\n\t\tthis.fire('prerender');\n\t\tthis.root.syncHierarchy();\n\t\tthis.batcher.updateAll();\n\t\tthis.renderer.renderComposition(this.scene.layers);\n\t\tthis.fire('postrender');\n\t}\n\n\t_fillFrameStatsBasic(now, dt, ms) {\n\t\tconst stats = this.stats.frame;\n\t\tstats.dt = dt;\n\t\tstats.ms = ms;\n\n\t\tif (now > stats._timeToCountFrames) {\n\t\t\tstats.fps = stats._fpsAccum;\n\t\t\tstats._fpsAccum = 0;\n\t\t\tstats._timeToCountFrames = now + 1000;\n\t\t} else {\n\t\t\tstats._fpsAccum++;\n\t\t}\n\n\t\tthis.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;\n\t\tthis.graphicsDevice._drawCallsPerFrame = 0;\n\t}\n\n\t_fillFrameStats() {\n\t\tlet stats = this.stats.frame;\n\t\tstats.cameras = this.renderer._camerasRendered;\n\t\tstats.materials = this.renderer._materialSwitches;\n\t\tstats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;\n\t\tstats.shadowMapUpdates = this.renderer._shadowMapUpdates;\n\t\tstats.shadowMapTime = this.renderer._shadowMapTime;\n\t\tstats.depthMapTime = this.renderer._depthMapTime;\n\t\tstats.forwardTime = this.renderer._forwardTime;\n\t\tconst prims = this.graphicsDevice._primsPerFrame;\n\t\tstats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);\n\t\tstats.cullTime = this.renderer._cullTime;\n\t\tstats.sortTime = this.renderer._sortTime;\n\t\tstats.skinTime = this.renderer._skinTime;\n\t\tstats.morphTime = this.renderer._morphTime;\n\t\tstats.instancingTime = this.renderer._instancingTime;\n\t\tstats.lightClusters = this.renderer._lightClusters;\n\t\tstats.lightClustersTime = this.renderer._lightClustersTime;\n\t\tstats.otherPrimitives = 0;\n\n\t\tfor (let i = 0; i < prims.length; i++) {\n\t\t\tif (i < PRIMITIVE_TRIANGLES) {\n\t\t\t\tstats.otherPrimitives += prims[i];\n\t\t\t}\n\n\t\t\tprims[i] = 0;\n\t\t}\n\n\t\tthis.renderer._camerasRendered = 0;\n\t\tthis.renderer._materialSwitches = 0;\n\t\tthis.renderer._shadowMapUpdates = 0;\n\t\tthis.graphicsDevice._shaderSwitchesPerFrame = 0;\n\t\tthis.renderer._cullTime = 0;\n\t\tthis.renderer._layerCompositionUpdateTime = 0;\n\t\tthis.renderer._lightClustersTime = 0;\n\t\tthis.renderer._sortTime = 0;\n\t\tthis.renderer._skinTime = 0;\n\t\tthis.renderer._morphTime = 0;\n\t\tthis.renderer._instancingTime = 0;\n\t\tthis.renderer._shadowMapTime = 0;\n\t\tthis.renderer._depthMapTime = 0;\n\t\tthis.renderer._forwardTime = 0;\n\t\tstats = this.stats.drawCalls;\n\t\tstats.forward = this.renderer._forwardDrawCalls;\n\t\tstats.culled = this.renderer._numDrawCallsCulled;\n\t\tstats.depth = 0;\n\t\tstats.shadow = this.renderer._shadowDrawCalls;\n\t\tstats.skinned = this.renderer._skinDrawCalls;\n\t\tstats.immediate = 0;\n\t\tstats.instanced = 0;\n\t\tstats.removedByInstancing = 0;\n\t\tstats.misc = stats.total - (stats.forward + stats.shadow);\n\t\tthis.renderer._depthDrawCalls = 0;\n\t\tthis.renderer._shadowDrawCalls = 0;\n\t\tthis.renderer._forwardDrawCalls = 0;\n\t\tthis.renderer._numDrawCallsCulled = 0;\n\t\tthis.renderer._skinDrawCalls = 0;\n\t\tthis.renderer._immediateRendered = 0;\n\t\tthis.renderer._instancedDrawCalls = 0;\n\t\tthis.renderer._removedByInstancing = 0;\n\t\tthis.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;\n\t\tstats = this.stats.particles;\n\t\tstats.updatesPerFrame = stats._updatesPerFrame;\n\t\tstats.frameTime = stats._frameTime;\n\t\tstats._updatesPerFrame = 0;\n\t\tstats._frameTime = 0;\n\t}\n\n\tsetCanvasFillMode(mode, width, height) {\n\t\tthis._fillMode = mode;\n\t\tthis.resizeCanvas(width, height);\n\t}\n\n\tsetCanvasResolution(mode, width, height) {\n\t\tthis._resolutionMode = mode;\n\n\t\tif (mode === RESOLUTION_AUTO && width === undefined) {\n\t\t\twidth = this.graphicsDevice.canvas.clientWidth;\n\t\t\theight = this.graphicsDevice.canvas.clientHeight;\n\t\t}\n\n\t\tthis.graphicsDevice.resizeCanvas(width, height);\n\t}\n\n\tisHidden() {\n\t\treturn document[this._hiddenAttr];\n\t}\n\n\tonVisibilityChange() {\n\t\tif (this.isHidden()) {\n\t\t\tthis._soundManager.suspend();\n\t\t} else {\n\t\t\tthis._soundManager.resume();\n\t\t}\n\t}\n\n\tresizeCanvas(width, height) {\n\t\tif (!this._allowResize) return;\n\t\tif (this.xr && this.xr.session) return;\n\t\tconst windowWidth = window.innerWidth;\n\t\tconst windowHeight = window.innerHeight;\n\n\t\tif (this._fillMode === FILLMODE_KEEP_ASPECT) {\n\t\t\tconst r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;\n\t\t\tconst winR = windowWidth / windowHeight;\n\n\t\t\tif (r > winR) {\n\t\t\t\twidth = windowWidth;\n\t\t\t\theight = width / r;\n\t\t\t} else {\n\t\t\t\theight = windowHeight;\n\t\t\t\twidth = height * r;\n\t\t\t}\n\t\t} else if (this._fillMode === FILLMODE_FILL_WINDOW) {\n\t\t\twidth = windowWidth;\n\t\t\theight = windowHeight;\n\t\t}\n\n\t\tthis.graphicsDevice.canvas.style.width = width + 'px';\n\t\tthis.graphicsDevice.canvas.style.height = height + 'px';\n\t\tthis.updateCanvasSize();\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\tupdateCanvasSize() {\n\t\tif (!this._allowResize || this.xr.active) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._resolutionMode === RESOLUTION_AUTO) {\n\t\t\tconst canvas = this.graphicsDevice.canvas;\n\t\t\tthis.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);\n\t\t}\n\t}\n\n\tonLibrariesLoaded() {\n\t\tthis._librariesLoaded = true;\n\t\tthis.systems.rigidbody.onLibraryLoaded();\n\t}\n\n\tapplySceneSettings(settings) {\n\t\tlet asset;\n\n\t\tif (this.systems.rigidbody && typeof Ammo !== 'undefined') {\n\t\t\tconst gravity = settings.physics.gravity;\n\t\t\tthis.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);\n\t\t}\n\n\t\tthis.scene.applySettings(settings);\n\n\t\tif (settings.render.hasOwnProperty('skybox')) {\n\t\t\tif (settings.render.skybox) {\n\t\t\t\tasset = this.assets.get(settings.render.skybox);\n\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis.setSkybox(asset);\n\t\t\t\t} else {\n\t\t\t\t\tthis.assets.once('add:' + settings.render.skybox, this.setSkybox, this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.setSkybox(null);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetAreaLightLuts(asset) {\n\t\tif (asset) {\n\t\t\tconst device = this.graphicsDevice;\n\t\t\tasset.ready(asset => {\n\t\t\t\tAreaLightLuts.set(device, asset.resource);\n\t\t\t});\n\t\t\tthis.assets.load(asset);\n\t\t}\n\t}\n\n\tsetSkybox(asset) {\n\t\tif (asset !== this._skyboxAsset) {\n\t\t\tconst onSkyboxRemoved = () => {\n\t\t\t\tthis.setSkybox(null);\n\t\t\t};\n\n\t\t\tconst onSkyboxChanged = () => {\n\t\t\t\tthis.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);\n\t\t\t};\n\n\t\t\tif (this._skyboxAsset) {\n\t\t\t\tthis.assets.off('load:' + this._skyboxAsset.id, onSkyboxChanged, this);\n\t\t\t\tthis.assets.off('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);\n\n\t\t\t\tthis._skyboxAsset.off('change', onSkyboxChanged, this);\n\t\t\t}\n\n\t\t\tthis._skyboxAsset = asset;\n\n\t\t\tif (this._skyboxAsset) {\n\t\t\t\tthis.assets.on('load:' + this._skyboxAsset.id, onSkyboxChanged, this);\n\t\t\t\tthis.assets.once('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);\n\n\t\t\t\tthis._skyboxAsset.on('change', onSkyboxChanged, this);\n\n\t\t\t\tif (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {\n\t\t\t\t\tthis._skyboxAsset.loadFaces = true;\n\t\t\t\t}\n\n\t\t\t\tthis.assets.load(this._skyboxAsset);\n\t\t\t}\n\n\t\t\tonSkyboxChanged();\n\t\t}\n\t}\n\n\tenableVr() {\n\t\tif (!this.vr) {\n\t\t\tthis.vr = new VrManager(this);\n\t\t}\n\t}\n\n\tdisableVr() {\n\t\tif (this.vr) {\n\t\t\tthis.vr.destroy();\n\t\t\tthis.vr = null;\n\t\t}\n\t}\n\n\t_firstBake() {\n\t\tthis.lightmapper.bake(null, this.scene.lightmapMode);\n\t}\n\n\t_firstBatch() {\n\t\tthis.batcher.generate();\n\t}\n\n\t_processTimestamp(timestamp) {\n\t\treturn timestamp;\n\t}\n\n\tdrawLine(start, end, color, depthTest, layer) {\n\t\tthis.scene.drawLine(start, end, color, depthTest, layer);\n\t}\n\n\tdrawLines(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.drawLines(positions, colors, depthTest, layer);\n\t}\n\n\tdrawLineArrays(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.drawLineArrays(positions, colors, depthTest, layer);\n\t}\n\n\tdrawWireSphere(center, radius, color = Color.WHITE, segments = 20, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);\n\t}\n\n\tdrawWireAlignedBox(minPoint, maxPoint, color = Color.WHITE, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer);\n\t}\n\n\tdrawMeshInstance(meshInstance, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(null, null, null, meshInstance, layer);\n\t}\n\n\tdrawMesh(mesh, material, matrix, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(material, matrix, mesh, null, layer);\n\t}\n\n\tdrawQuad(matrix, material, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);\n\t}\n\n\tdrawTexture(x, y, width, height, texture, material, layer = this.scene.defaultDrawLayer) {\n\t\tconst matrix = new Mat4();\n\t\tmatrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, height, 0.0));\n\n\t\tif (!material) {\n\t\t\tmaterial = new Material();\n\t\t\tmaterial.setParameter(\"colorMap\", texture);\n\t\t\tmaterial.shader = this.scene.immediate.getTextureShader();\n\t\t\tmaterial.update();\n\t\t}\n\n\t\tthis.drawQuad(matrix, material, layer);\n\t}\n\n\tdrawDepthTexture(x, y, width, height, layer = this.scene.defaultDrawLayer) {\n\t\tconst material = new Material();\n\t\tmaterial.shader = this.scene.immediate.getDepthTextureShader();\n\t\tmaterial.update();\n\t\tthis.drawTexture(x, y, width, height, null, material, layer);\n\t}\n\n\tdestroy() {\n\t\tif (this._inFrameUpdate) {\n\t\t\tthis._destroyRequested = true;\n\t\t\treturn;\n\t\t}\n\n\t\tconst canvasId = this.graphicsDevice.canvas.id;\n\t\tthis.off('librariesloaded');\n\n\t\tif (typeof document !== 'undefined') {\n\t\t\tdocument.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);\n\t\t}\n\n\t\tthis._visibilityChangeHandler = null;\n\t\tthis.root.destroy();\n\t\tthis.root = null;\n\n\t\tif (this.mouse) {\n\t\t\tthis.mouse.off();\n\t\t\tthis.mouse.detach();\n\t\t\tthis.mouse = null;\n\t\t}\n\n\t\tif (this.keyboard) {\n\t\t\tthis.keyboard.off();\n\t\t\tthis.keyboard.detach();\n\t\t\tthis.keyboard = null;\n\t\t}\n\n\t\tif (this.touch) {\n\t\t\tthis.touch.off();\n\t\t\tthis.touch.detach();\n\t\t\tthis.touch = null;\n\t\t}\n\n\t\tif (this.elementInput) {\n\t\t\tthis.elementInput.detach();\n\t\t\tthis.elementInput = null;\n\t\t}\n\n\t\tif (this.controller) {\n\t\t\tthis.controller = null;\n\t\t}\n\n\t\tthis.systems.destroy();\n\n\t\tif (this.scene.layers) {\n\t\t\tthis.scene.layers.destroy();\n\t\t}\n\n\t\tconst assets = this.assets.list();\n\n\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\tassets[i].unload();\n\t\t\tassets[i].off();\n\t\t}\n\n\t\tthis.assets.off();\n\t\tthis.bundles.destroy();\n\t\tthis.bundles = null;\n\t\tthis.i18n.destroy();\n\t\tthis.i18n = null;\n\n\t\tfor (const key in this.loader.getHandler('script')._cache) {\n\t\t\tconst element = this.loader.getHandler('script')._cache[key];\n\n\t\t\tconst parent = element.parentNode;\n\t\t\tif (parent) parent.removeChild(element);\n\t\t}\n\n\t\tthis.loader.getHandler('script')._cache = {};\n\t\tthis.loader.destroy();\n\t\tthis.loader = null;\n\t\tthis.scene.destroy();\n\t\tthis.scene = null;\n\t\tthis.systems = null;\n\t\tthis.context = null;\n\t\tthis.scripts.destroy();\n\t\tthis.scripts = null;\n\t\tthis.scenes.destroy();\n\t\tthis.scenes = null;\n\t\tthis.lightmapper.destroy();\n\t\tthis.lightmapper = null;\n\t\tthis.batcher.destroy();\n\t\tthis.batcher = null;\n\t\tthis._entityIndex = {};\n\t\tthis.defaultLayerDepth.onPreRenderOpaque = null;\n\t\tthis.defaultLayerDepth.onPostRenderOpaque = null;\n\t\tthis.defaultLayerDepth.onDisable = null;\n\t\tthis.defaultLayerDepth.onEnable = null;\n\t\tthis.defaultLayerDepth = null;\n\t\tthis.defaultLayerWorld = null;\n\t\tdestroyPostEffectQuad();\n\n\t\tif (this.vr) {\n\t\t\tthis.vr.destroy();\n\t\t\tthis.vr = null;\n\t\t}\n\n\t\tthis.xr.end();\n\t\tParticleEmitter.staticDestroy();\n\t\tthis.renderer.destroy();\n\t\tthis.renderer = null;\n\t\tDefaultMaterial.remove(this.graphicsDevice);\n\t\tthis.graphicsDevice.destroy();\n\t\tthis.graphicsDevice = null;\n\t\tthis.tick = null;\n\t\tthis.off();\n\n\t\tif (this._soundManager) {\n\t\t\tthis._soundManager.destroy();\n\n\t\t\tthis._soundManager = null;\n\t\t}\n\n\t\tscript.app = null;\n\t\tApplication._applications[canvasId] = null;\n\n\t\tif (getApplication() === this) {\n\t\t\tsetApplication(null);\n\t\t}\n\t}\n\n\tgetEntityFromIndex(guid) {\n\t\treturn this._entityIndex[guid];\n\t}\n\n\t_registerSceneImmediate(scene) {\n\t\tthis.on('postrender', scene.immediate.onPostRender, scene.immediate);\n\t}\n\n}\n\nApplication._applications = {};\nconst _frameEndData = {};\n\nconst makeTick = function makeTick(_app) {\n\tconst application = _app;\n\tlet frameRequest;\n\treturn function (timestamp, frame) {\n\t\tif (!application.graphicsDevice) return;\n\t\tsetApplication(application);\n\n\t\tif (frameRequest) {\n\t\t\twindow.cancelAnimationFrame(frameRequest);\n\t\t\tframeRequest = null;\n\t\t}\n\n\t\tapp = application;\n\t\tconst currentTime = application._processTimestamp(timestamp) || now();\n\t\tconst ms = currentTime - (application._time || currentTime);\n\t\tlet dt = ms / 1000.0;\n\t\tdt = math.clamp(dt, 0, application.maxDeltaTime);\n\t\tdt *= application.timeScale;\n\t\tapplication._time = currentTime;\n\n\t\tif (application.vr && application.vr.display) {\n\t\t\tframeRequest = application.vr.display.requestAnimationFrame(application.tick);\n\t\t} else if (application.xr.session) {\n\t\t\tframeRequest = application.xr.session.requestAnimationFrame(application.tick);\n\t\t} else {\n\t\t\tframeRequest = platform.browser ? window.requestAnimationFrame(application.tick) : null;\n\t\t}\n\n\t\tif (application.graphicsDevice.contextLost) return;\n\n\t\tapplication._fillFrameStatsBasic(currentTime, dt, ms);\n\n\t\tapplication._inFrameUpdate = true;\n\t\tapplication.fire(\"frameupdate\", ms);\n\n\t\tif (frame) {\n\t\t\tapplication.xr.update(frame);\n\t\t\tapplication.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;\n\t\t} else {\n\t\t\tapplication.graphicsDevice.defaultFramebuffer = null;\n\t\t}\n\n\t\tapplication.update(dt);\n\t\tapplication.fire(\"framerender\");\n\n\t\tif (application.autoRender || application.renderNextFrame) {\n\t\t\tapplication.updateCanvasSize();\n\t\t\tapplication.render();\n\t\t\tapplication.renderNextFrame = false;\n\t\t}\n\n\t\t_frameEndData.timestamp = now();\n\t\t_frameEndData.target = application;\n\t\tapplication.fire(\"frameend\", _frameEndData);\n\t\tapplication.fire(\"frameEnd\", _frameEndData);\n\n\t\tif (application.vr && application.vr.display && application.vr.display.presenting) {\n\t\t\tapplication.vr.display.submitFrame();\n\t\t}\n\n\t\tapplication._inFrameUpdate = false;\n\n\t\tif (application._destroyRequested) {\n\t\t\tapplication.destroy();\n\t\t}\n\t};\n};\n\nclass Entity extends GraphNode {\n\tconstructor(name, app) {\n\t\tsuper(name);\n\t\tthis.anim = void 0;\n\t\tthis.animation = void 0;\n\t\tthis.audiolistener = void 0;\n\t\tthis.button = void 0;\n\t\tthis.camera = void 0;\n\t\tthis.collision = void 0;\n\t\tthis.element = void 0;\n\t\tthis.layoutchild = void 0;\n\t\tthis.layoutgroup = void 0;\n\t\tthis.light = void 0;\n\t\tthis.model = void 0;\n\t\tthis.particlesystem = void 0;\n\t\tthis.render = void 0;\n\t\tthis.rigidbody = void 0;\n\t\tthis.screen = void 0;\n\t\tthis.script = void 0;\n\t\tthis.scrollbar = void 0;\n\t\tthis.scrollview = void 0;\n\t\tthis.sound = void 0;\n\t\tthis.sprite = void 0;\n\t\tif (name instanceof Application) app = name;\n\t\tthis._batchHandle = null;\n\t\tthis.c = {};\n\t\tthis._app = app;\n\n\t\tif (!app) {\n\t\t\tthis._app = Application.getApplication();\n\n\t\t\tif (!this._app) {\n\t\t\t\tthrow new Error(\"Couldn't find current application\");\n\t\t\t}\n\t\t}\n\n\t\tthis._guid = null;\n\t\tthis._destroying = false;\n\t\tthis._template = false;\n\t}\n\n\taddComponent(type, data) {\n\t\tconst system = this._app.systems[type];\n\n\t\tif (!system) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.c[type]) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn system.addComponent(this, data);\n\t}\n\n\tremoveComponent(type) {\n\t\tconst system = this._app.systems[type];\n\n\t\tif (!system) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.c[type]) {\n\t\t\treturn;\n\t\t}\n\n\t\tsystem.removeComponent(this);\n\t}\n\n\tfindComponent(type) {\n\t\tconst entity = this.findOne(function (node) {\n\t\t\treturn node.c && node.c[type];\n\t\t});\n\t\treturn entity && entity.c[type];\n\t}\n\n\tfindComponents(type) {\n\t\tconst entities = this.find(function (node) {\n\t\t\treturn node.c && node.c[type];\n\t\t});\n\t\treturn entities.map(function (entity) {\n\t\t\treturn entity.c[type];\n\t\t});\n\t}\n\n\tgetGuid() {\n\t\tif (!this._guid) {\n\t\t\tthis.setGuid(guid.create());\n\t\t}\n\n\t\treturn this._guid;\n\t}\n\n\tsetGuid(guid) {\n\t\tconst index = this._app._entityIndex;\n\n\t\tif (this._guid) {\n\t\t\tdelete index[this._guid];\n\t\t}\n\n\t\tthis._guid = guid;\n\t\tindex[this._guid] = this;\n\t}\n\n\t_notifyHierarchyStateChanged(node, enabled) {\n\t\tlet enableFirst = false;\n\t\tif (node === this && this._app._enableList.length === 0) enableFirst = true;\n\t\tnode._beingEnabled = true;\n\n\t\tnode._onHierarchyStateChanged(enabled);\n\n\t\tif (node._onHierarchyStatePostChanged) this._app._enableList.push(node);\n\t\tconst c = node._children;\n\n\t\tfor (let i = 0, len = c.length; i < len; i++) {\n\t\t\tif (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);\n\t\t}\n\n\t\tnode._beingEnabled = false;\n\n\t\tif (enableFirst) {\n\t\t\tfor (let i = 0; i < this._app._enableList.length; i++) {\n\t\t\t\tthis._app._enableList[i]._onHierarchyStatePostChanged();\n\t\t\t}\n\n\t\t\tthis._app._enableList.length = 0;\n\t\t}\n\t}\n\n\t_onHierarchyStateChanged(enabled) {\n\t\tsuper._onHierarchyStateChanged(enabled);\n\n\t\tconst components = this.c;\n\n\t\tfor (const type in components) {\n\t\t\tif (components.hasOwnProperty(type)) {\n\t\t\t\tconst component = components[type];\n\n\t\t\t\tif (component.enabled) {\n\t\t\t\t\tif (enabled) {\n\t\t\t\t\t\tcomponent.onEnable();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomponent.onDisable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onHierarchyStatePostChanged() {\n\t\tconst components = this.c;\n\n\t\tfor (const type in components) {\n\t\t\tif (components.hasOwnProperty(type)) components[type].onPostStateChange();\n\t\t}\n\t}\n\n\tfindByGuid(guid) {\n\t\tif (this._guid === guid) return this;\n\t\tconst e = this._app._entityIndex[guid];\n\n\t\tif (e && (e === this || e.isDescendantOf(this))) {\n\t\t\treturn e;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdestroy() {\n\t\tthis._destroying = true;\n\n\t\tfor (const name in this.c) {\n\t\t\tthis.c[name].enabled = false;\n\t\t}\n\n\t\tfor (const name in this.c) {\n\t\t\tthis.c[name].system.removeComponent(this);\n\t\t}\n\n\t\tif (this._parent) this._parent.removeChild(this);\n\t\tconst children = this._children;\n\t\tlet child = children.shift();\n\n\t\twhile (child) {\n\t\t\tif (child instanceof Entity) {\n\t\t\t\tchild.destroy();\n\t\t\t}\n\n\t\t\tchild._parent = null;\n\t\t\tchild = children.shift();\n\t\t}\n\n\t\tthis.fire('destroy', this);\n\t\tthis.off();\n\n\t\tif (this._guid) {\n\t\t\tdelete this._app._entityIndex[this._guid];\n\t\t}\n\n\t\tthis._destroying = false;\n\t}\n\n\tclone() {\n\t\tconst duplicatedIdsMap = {};\n\n\t\tconst clone = this._cloneRecursively(duplicatedIdsMap);\n\n\t\tduplicatedIdsMap[this.getGuid()] = clone;\n\t\tresolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);\n\t\treturn clone;\n\t}\n\n\t_cloneRecursively(duplicatedIdsMap) {\n\t\tconst clone = new Entity(this._app);\n\n\t\tsuper._cloneInternal(clone);\n\n\t\tfor (const type in this.c) {\n\t\t\tconst component = this.c[type];\n\t\t\tcomponent.system.cloneComponent(this, clone);\n\t\t}\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst oldChild = this._children[i];\n\n\t\t\tif (oldChild instanceof Entity) {\n\t\t\t\tconst newChild = oldChild._cloneRecursively(duplicatedIdsMap);\n\n\t\t\t\tclone.addChild(newChild);\n\t\t\t\tduplicatedIdsMap[oldChild.getGuid()] = newChild;\n\t\t\t}\n\t\t}\n\n\t\treturn clone;\n\t}\n\n}\n\nfunction resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {\n\tif (oldEntity instanceof Entity) {\n\t\tconst components = oldEntity.c;\n\n\t\tfor (const componentName in components) {\n\t\t\tconst component = components[componentName];\n\t\t\tconst entityProperties = component.system.getPropertiesOfType('entity');\n\n\t\t\tfor (let i = 0, len = entityProperties.length; i < len; i++) {\n\t\t\t\tconst propertyDescriptor = entityProperties[i];\n\t\t\t\tconst propertyName = propertyDescriptor.name;\n\t\t\t\tconst oldEntityReferenceId = component[propertyName];\n\t\t\t\tconst entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);\n\n\t\t\t\tif (entityIsWithinOldSubtree) {\n\t\t\t\t\tconst newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();\n\n\t\t\t\t\tif (newEntityReferenceId) {\n\t\t\t\t\t\tnewEntity.c[componentName][propertyName] = newEntityReferenceId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {\n\t\t\tnewEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);\n\t\t}\n\n\t\tif (components.render) {\n\t\t\tnewEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);\n\t\t}\n\n\t\tif (components.anim) {\n\t\t\tnewEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);\n\t\t}\n\n\t\tconst _old = oldEntity.children.filter(function (e) {\n\t\t\treturn e instanceof Entity;\n\t\t});\n\n\t\tconst _new = newEntity.children.filter(function (e) {\n\t\t\treturn e instanceof Entity;\n\t\t});\n\n\t\tfor (let i = 0, len = _old.length; i < len; i++) {\n\t\t\tresolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);\n\t\t}\n\t}\n}\n\nconst _tempPoint = new Vec3();\n\nclass BakeLightAmbient extends BakeLight {\n\tconstructor(scene) {\n\t\tconst lightEntity = new Entity(\"AmbientLight\");\n\t\tlightEntity.addComponent(\"light\", {\n\t\t\ttype: \"directional\",\n\t\t\taffectDynamic: true,\n\t\t\taffectLightmapped: false,\n\t\t\tbake: true,\n\t\t\tbakeNumSamples: scene.ambientBakeNumSamples,\n\t\t\tcastShadows: true,\n\t\t\tnormalOffsetBias: 0.05,\n\t\t\tshadowBias: 0.2,\n\t\t\tshadowDistance: 1,\n\t\t\tshadowResolution: 2048,\n\t\t\tshadowType: SHADOW_PCF3,\n\t\t\tcolor: Color.WHITE,\n\t\t\tintensity: 1\n\t\t});\n\t\tsuper(scene, lightEntity.light.light);\n\t}\n\n\tget numVirtualLights() {\n\t\treturn this.light.bakeNumSamples;\n\t}\n\n\tprepareVirtualLight(index, numVirtualLights) {\n\t\trandom.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);\n\n\t\tthis.light._node.lookAt(_tempPoint.mulScalar(-1));\n\n\t\tthis.light._node.rotateLocal(90, 0, 0);\n\n\t\tconst gamma = this.scene.gammaCorrection ? 2.2 : 1;\n\t\tconst fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;\n\t\tconst linearIntensity = Math.pow(fullIntensity, gamma);\n\t\tthis.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);\n\t}\n\n}\n\nclass BakeMeshNode {\n\tconstructor(node, meshInstances = null) {\n\t\tthis.node = node;\n\t\tthis.component = node.render || node.model;\n\t\tmeshInstances = meshInstances || this.component.meshInstances;\n\t\tthis.store();\n\t\tthis.meshInstances = meshInstances;\n\t\tthis.bounds = null;\n\t\tthis.renderTargets = [];\n\t}\n\n\tstore() {\n\t\tthis.castShadows = this.component.castShadows;\n\t}\n\n\trestore() {\n\t\tthis.component.castShadows = this.castShadows;\n\t}\n\n}\n\nconst DENOISE_FILTER_SIZE = 15;\n\nclass LightmapFilters {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.dilatePS, \"lmDilate\");\n\t\tthis.constantTexSource = device.scope.resolve(\"source\");\n\t\tthis.constantPixelOffset = device.scope.resolve(\"pixelOffset\");\n\t\tthis.pixelOffset = new Float32Array(2);\n\t\tthis.shaderDenoise = null;\n\t\tthis.sigmas = null;\n\t\tthis.constantSigmas = null;\n\t\tthis.kernel = null;\n\t}\n\n\tsetSourceTexture(texture) {\n\t\tthis.constantTexSource.setValue(texture);\n\t}\n\n\tprepare(textureWidth, textureHeight) {\n\t\tthis.pixelOffset[0] = 1 / textureWidth;\n\t\tthis.pixelOffset[1] = 1 / textureHeight;\n\t\tthis.constantPixelOffset.setValue(this.pixelOffset);\n\t}\n\n\tprepareDenoise(filterRange, filterSmoothness) {\n\t\tif (!this.shaderDenoise) {\n\t\t\tthis.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunks.bilateralDeNoisePS, \"lmBilateralDeNoise\");\n\t\t\tthis.sigmas = new Float32Array(2);\n\t\t\tthis.constantSigmas = this.device.scope.resolve(\"sigmas\");\n\t\t\tthis.constantKernel = this.device.scope.resolve(\"kernel[0]\");\n\t\t\tthis.bZnorm = this.device.scope.resolve(\"bZnorm\");\n\t\t}\n\n\t\tthis.sigmas[0] = filterRange;\n\t\tthis.sigmas[1] = filterSmoothness;\n\t\tthis.constantSigmas.setValue(this.sigmas);\n\t\tthis.evaluateDenoiseUniforms(filterRange, filterSmoothness);\n\t}\n\n\tevaluateDenoiseUniforms(filterRange, filterSmoothness) {\n\t\tfunction normpdf(x, sigma) {\n\t\t\treturn 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\t\t}\n\n\t\tthis.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);\n\t\tconst kernel = this.kernel;\n\t\tconst kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);\n\n\t\tfor (let j = 0; j <= kSize; ++j) {\n\t\t\tconst value = normpdf(j, filterRange);\n\t\t\tkernel[kSize + j] = value;\n\t\t\tkernel[kSize - j] = value;\n\t\t}\n\n\t\tthis.constantKernel.setValue(this.kernel);\n\t\tconst bZnorm = 1 / normpdf(0.0, filterSmoothness);\n\t\tthis.bZnorm.setValue(bZnorm);\n\t}\n\n}\n\nconst MAX_LIGHTMAP_SIZE = 2048;\nconst PASS_COLOR = 0;\nconst PASS_DIR = 1;\nconst tempVec = new Vec3();\n\nclass Lightmapper {\n\tconstructor(device, root, scene, renderer, assets) {\n\t\tthis.device = device;\n\t\tthis.root = root;\n\t\tthis.scene = scene;\n\t\tthis.renderer = renderer;\n\t\tthis.assets = assets;\n\t\tthis.shadowMapCache = renderer._shadowRenderer.shadowMapCache;\n\t\tthis._tempSet = new Set();\n\t\tthis._initCalled = false;\n\t\tthis.passMaterials = [];\n\t\tthis.ambientAOMaterial = null;\n\t\tthis.fog = \"\";\n\t\tthis.ambientLight = new Color();\n\t\tthis.renderTargets = new Map();\n\t\tthis.stats = {\n\t\t\trenderPasses: 0,\n\t\t\tlightmapCount: 0,\n\t\t\ttotalRenderTime: 0,\n\t\t\tforwardTime: 0,\n\t\t\tfboTime: 0,\n\t\t\tshadowMapTime: 0,\n\t\t\tcompileTime: 0,\n\t\t\tshadersLinked: 0\n\t\t};\n\t}\n\n\tdestroy() {\n\t\tLightmapCache.decRef(this.blackTex);\n\t\tthis.blackTex = null;\n\t\tLightmapCache.destroy();\n\t\tthis.device = null;\n\t\tthis.root = null;\n\t\tthis.scene = null;\n\t\tthis.renderer = null;\n\t\tthis.assets = null;\n\t}\n\n\tinitBake(device) {\n\t\tif (!this._initCalled) {\n\t\t\tthis._initCalled = true;\n\t\t\tthis.lightmapFilters = new LightmapFilters(device);\n\t\t\tthis.constantBakeDir = device.scope.resolve(\"bakeDir\");\n\t\t\tthis.materials = [];\n\t\t\tthis.blackTex = new Texture(this.device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\t\ttype: TEXTURETYPE_RGBM\n\t\t\t});\n\t\t\tthis.blackTex.name = 'lightmapBlack';\n\t\t\tLightmapCache.incRef(this.blackTex);\n\t\t\tconst camera = new Camera();\n\t\t\tcamera.clearColor.set(0, 0, 0, 0);\n\t\t\tcamera.clearColorBuffer = true;\n\t\t\tcamera.clearDepthBuffer = false;\n\t\t\tcamera.clearStencilBuffer = false;\n\t\t\tcamera.frustumCulling = false;\n\t\t\tcamera.projection = PROJECTION_ORTHOGRAPHIC;\n\t\t\tcamera.aspectRatio = 1;\n\t\t\tcamera.node = new GraphNode();\n\t\t\tthis.camera = camera;\n\t\t}\n\n\t\tif (this.scene.clusteredLightingEnabled) {\n\t\t\tconst lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, () => {});\n\t\t\tthis.lightingParams = lightingParams;\n\t\t\tconst srcParams = this.scene.lighting;\n\t\t\tlightingParams.shadowsEnabled = srcParams.shadowsEnabled;\n\t\t\tlightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;\n\t\t\tlightingParams.cookiesEnabled = srcParams.cookiesEnabled;\n\t\t\tlightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;\n\t\t\tlightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;\n\t\t\tlightingParams.cells = new Vec3(3, 3, 3);\n\t\t\tlightingParams.maxLightsPerCell = 4;\n\t\t\tthis.worldClusters = new WorldClusters(device);\n\t\t\tthis.worldClusters.name = \"ClusterLightmapper\";\n\t\t}\n\t}\n\n\tfinishBake(bakeNodes) {\n\t\tthis.materials = [];\n\n\t\tfunction destroyRT(rt) {\n\t\t\tLightmapCache.decRef(rt.colorBuffer);\n\t\t\trt.destroy();\n\t\t}\n\n\t\tthis.renderTargets.forEach(rt => {\n\t\t\tdestroyRT(rt);\n\t\t});\n\t\tthis.renderTargets.clear();\n\t\tbakeNodes.forEach(node => {\n\t\t\tnode.renderTargets.forEach(rt => {\n\t\t\t\tdestroyRT(rt);\n\t\t\t});\n\t\t\tnode.renderTargets.length = 0;\n\t\t});\n\t\tthis.ambientAOMaterial = null;\n\n\t\tif (this.worldClusters) {\n\t\t\tthis.worldClusters.destroy();\n\t\t\tthis.worldClusters = null;\n\t\t}\n\t}\n\n\tcreateMaterialForPass(device, scene, pass, addAmbient) {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.name = `lmMaterial-pass:${pass}-ambient:${addAmbient}`;\n\t\tmaterial.chunks.transformVS = \"#define UV1LAYOUT\\n\" + shaderChunks.transformVS;\n\n\t\tif (pass === PASS_COLOR) {\n\t\t\tlet bakeLmEndChunk = shaderChunks.bakeLmEndPS;\n\n\t\t\tif (addAmbient) {\n\t\t\t\tbakeLmEndChunk = `\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = ((dDiffuseLight - 0.5) * max(${scene.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight += vec3(${scene.ambientBakeOcclusionBrightness.toFixed(1)});\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = saturate(dDiffuseLight);\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight *= dAmbientLight;\n\t\t\t\t\t\t\t\t` + bakeLmEndChunk;\n\t\t\t} else {\n\t\t\t\tmaterial.ambient = new Color(0, 0, 0);\n\t\t\t\tmaterial.ambientTint = true;\n\t\t\t}\n\n\t\t\tmaterial.chunks.endPS = bakeLmEndChunk;\n\t\t\tmaterial.lightMap = this.blackTex;\n\t\t} else {\n\t\t\tmaterial.chunks.basePS = shaderChunks.basePS + \"\\nuniform sampler2D texture_dirLightMap;\\nuniform float bakeDir;\\n\";\n\t\t\tmaterial.chunks.endPS = shaderChunks.bakeDirLmEndPS;\n\t\t}\n\n\t\tmaterial.chunks.outputAlphaPS = \"\\n\";\n\t\tmaterial.chunks.outputAlphaOpaquePS = \"\\n\";\n\t\tmaterial.chunks.outputAlphaPremulPS = \"\\n\";\n\t\tmaterial.cull = CULLFACE_NONE;\n\t\tmaterial.forceUv1 = true;\n\t\tmaterial.update();\n\t\tmaterial.updateShader(device, scene);\n\t\treturn material;\n\t}\n\n\tcreateMaterials(device, scene, passCount) {\n\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\tif (!this.passMaterials[pass]) {\n\t\t\t\tthis.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);\n\t\t\t}\n\t\t}\n\n\t\tif (!this.ambientAOMaterial) {\n\t\t\tthis.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);\n\n\t\t\tthis.ambientAOMaterial.onUpdateShader = function (options) {\n\t\t\t\toptions.lightMapWithoutAmbient = true;\n\t\t\t\toptions.separateAmbient = true;\n\t\t\t\treturn options;\n\t\t\t};\n\t\t}\n\t}\n\n\tcreateTexture(size, type, name) {\n\t\tconst tex = new Texture(this.device, {\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\tmipmaps: false,\n\t\t\ttype: type,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\ttex.name = name;\n\t\treturn tex;\n\t}\n\n\tcollectModels(node, bakeNodes, allNodes) {\n\t\tvar _node$model, _node$model2, _node$render;\n\n\t\tif (!node.enabled) return;\n\t\tlet meshInstances;\n\n\t\tif ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {\n\t\t\tif (allNodes) allNodes.push(new BakeMeshNode(node));\n\n\t\t\tif (node.model.lightmapped) {\n\t\t\t\tif (bakeNodes) {\n\t\t\t\t\tmeshInstances = node.model.model.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((_node$render = node.render) != null && _node$render.enabled) {\n\t\t\tif (allNodes) allNodes.push(new BakeMeshNode(node));\n\n\t\t\tif (node.render.lightmapped) {\n\t\t\t\tif (bakeNodes) {\n\t\t\t\t\tmeshInstances = node.render.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (meshInstances) {\n\t\t\tlet hasUv1 = true;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {\n\t\t\t\t\thasUv1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUv1) {\n\t\t\t\tconst notInstancedMeshInstances = [];\n\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tconst mesh = meshInstances[i].mesh;\n\n\t\t\t\t\tif (this._tempSet.has(mesh)) {\n\t\t\t\t\t\tbakeNodes.push(new BakeMeshNode(node, [meshInstances[i]]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnotInstancedMeshInstances.push(meshInstances[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._tempSet.add(mesh);\n\t\t\t\t}\n\n\t\t\t\tthis._tempSet.clear();\n\n\t\t\t\tif (notInstancedMeshInstances.length > 0) {\n\t\t\t\t\tbakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\tthis.collectModels(node._children[i], bakeNodes, allNodes);\n\t\t}\n\t}\n\n\tprepareShadowCasters(nodes) {\n\t\tconst casters = [];\n\n\t\tfor (let n = 0; n < nodes.length; n++) {\n\t\t\tconst component = nodes[n].component;\n\t\t\tcomponent.castShadows = component.castShadowsLightmap;\n\n\t\t\tif (component.castShadowsLightmap) {\n\t\t\t\tconst meshes = nodes[n].meshInstances;\n\n\t\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\t\tmeshes[i].visibleThisFrame = true;\n\t\t\t\t\tcasters.push(meshes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn casters;\n\t}\n\n\tupdateTransforms(nodes) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst meshInstances = nodes[i].meshInstances;\n\n\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\tmeshInstances[j].node.getWorldTransform();\n\t\t\t}\n\t\t}\n\t}\n\n\tcalculateLightmapSize(node) {\n\t\tlet data;\n\t\tconst sizeMult = this.scene.lightmapSizeMultiplier || 16;\n\t\tconst scale = tempVec;\n\t\tlet srcArea, lightmapSizeMultiplier;\n\n\t\tif (node.model) {\n\t\t\tlightmapSizeMultiplier = node.model.lightmapSizeMultiplier;\n\n\t\t\tif (node.model.asset) {\n\t\t\t\tdata = this.assets.get(node.model.asset).data;\n\n\t\t\t\tif (data.area) {\n\t\t\t\t\tsrcArea = data.area;\n\t\t\t\t}\n\t\t\t} else if (node.model._area) {\n\t\t\t\tdata = node.model;\n\n\t\t\t\tif (data._area) {\n\t\t\t\t\tsrcArea = data._area;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.render) {\n\t\t\tlightmapSizeMultiplier = node.render.lightmapSizeMultiplier;\n\n\t\t\tif (node.render.type !== 'asset') {\n\t\t\t\tif (node.render._area) {\n\t\t\t\t\tdata = node.render;\n\n\t\t\t\t\tif (data._area) {\n\t\t\t\t\t\tsrcArea = data._area;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst area = {\n\t\t\tx: 1,\n\t\t\ty: 1,\n\t\t\tz: 1,\n\t\t\tuv: 1\n\t\t};\n\n\t\tif (srcArea) {\n\t\t\tarea.x = srcArea.x;\n\t\t\tarea.y = srcArea.y;\n\t\t\tarea.z = srcArea.z;\n\t\t\tarea.uv = srcArea.uv;\n\t\t}\n\n\t\tconst areaMult = lightmapSizeMultiplier || 1;\n\t\tarea.x *= areaMult;\n\t\tarea.y *= areaMult;\n\t\tarea.z *= areaMult;\n\t\tconst component = node.render || node.model;\n\t\tconst bounds = this.computeNodeBounds(component.meshInstances);\n\t\tscale.copy(bounds.halfExtents);\n\t\tlet totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;\n\t\ttotalArea /= area.uv;\n\t\ttotalArea = Math.sqrt(totalArea);\n\t\tconst lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);\n\t\treturn lightmapSize;\n\t}\n\n\tsetLightmapping(nodes, value, passCount, shaderDefs) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tconst meshInstances = node.meshInstances;\n\n\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\tconst meshInstance = meshInstances[j];\n\t\t\t\tmeshInstance.setLightmapped(value);\n\n\t\t\t\tif (value) {\n\t\t\t\t\tif (shaderDefs) {\n\t\t\t\t\t\tmeshInstance._shaderDefs |= shaderDefs;\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshInstance.mask = MASK_AFFECT_LIGHTMAPPED;\n\n\t\t\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\t\t\tconst tex = node.renderTargets[pass].colorBuffer;\n\t\t\t\t\t\ttex.minFilter = FILTER_LINEAR;\n\t\t\t\t\t\ttex.magFilter = FILTER_LINEAR;\n\t\t\t\t\t\tmeshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbake(nodes, mode = BAKE_COLORDIR) {\n\t\tconst device = this.device;\n\t\tconst startTime = now();\n\n\t\tthis.scene._updateSkybox(device);\n\n\t\tthis.stats.renderPasses = 0;\n\t\tthis.stats.shadowMapTime = 0;\n\t\tthis.stats.forwardTime = 0;\n\t\tconst startShaders = device._shaderStats.linked;\n\t\tconst startFboTime = device._renderTargetCreationTime;\n\t\tconst startCompileTime = device._shaderStats.compileTime;\n\t\tconst bakeNodes = [];\n\t\tconst allNodes = [];\n\n\t\tif (nodes) {\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tthis.collectModels(nodes[i], bakeNodes, null);\n\t\t\t}\n\n\t\t\tthis.collectModels(this.root, null, allNodes);\n\t\t} else {\n\t\t\tthis.collectModels(this.root, bakeNodes, allNodes);\n\t\t}\n\n\t\tif (bakeNodes.length > 0) {\n\t\t\tconst passCount = mode === BAKE_COLORDIR ? 2 : 1;\n\t\t\tthis.setLightmapping(bakeNodes, false, passCount);\n\t\t\tthis.initBake(device);\n\t\t\tthis.bakeInternal(passCount, bakeNodes, allNodes);\n\t\t\tlet shaderDefs = SHADERDEF_LM;\n\n\t\t\tif (mode === BAKE_COLORDIR) {\n\t\t\t\tshaderDefs |= SHADERDEF_DIRLM;\n\t\t\t}\n\n\t\t\tif (this.scene.ambientBake) {\n\t\t\t\tshaderDefs |= SHADERDEF_LMAMBIENT;\n\t\t\t}\n\n\t\t\tthis.setLightmapping(bakeNodes, true, passCount, shaderDefs);\n\t\t\tthis.finishBake(bakeNodes);\n\t\t}\n\n\t\tconst nowTime = now();\n\t\tthis.stats.totalRenderTime = nowTime - startTime;\n\t\tthis.stats.shadersLinked = device._shaderStats.linked - startShaders;\n\t\tthis.stats.compileTime = device._shaderStats.compileTime - startCompileTime;\n\t\tthis.stats.fboTime = device._renderTargetCreationTime - startFboTime;\n\t\tthis.stats.lightmapCount = bakeNodes.length;\n\t}\n\n\tallocateTextures(bakeNodes, passCount) {\n\t\tfor (let i = 0; i < bakeNodes.length; i++) {\n\t\t\tconst bakeNode = bakeNodes[i];\n\t\t\tconst size = this.calculateLightmapSize(bakeNode.node);\n\n\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\tconst tex = this.createTexture(size, TEXTURETYPE_DEFAULT, \"lightmapper_lightmap_\" + i);\n\t\t\t\tLightmapCache.incRef(tex);\n\t\t\t\tbakeNode.renderTargets[pass] = new RenderTarget({\n\t\t\t\t\tcolorBuffer: tex,\n\t\t\t\t\tdepth: false\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!this.renderTargets.has(size)) {\n\t\t\t\tconst tex = this.createTexture(size, TEXTURETYPE_DEFAULT, \"lightmapper_temp_lightmap_\" + size);\n\t\t\t\tLightmapCache.incRef(tex);\n\t\t\t\tthis.renderTargets.set(size, new RenderTarget({\n\t\t\t\t\tcolorBuffer: tex,\n\t\t\t\t\tdepth: false\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t}\n\n\tprepareLightsToBake(layerComposition, allLights, bakeLights) {\n\t\tif (this.scene.ambientBake) {\n\t\t\tconst ambientLight = new BakeLightAmbient(this.scene);\n\t\t\tbakeLights.push(ambientLight);\n\t\t}\n\n\t\tconst sceneLights = layerComposition._lights;\n\n\t\tfor (let i = 0; i < sceneLights.length; i++) {\n\t\t\tconst light = sceneLights[i];\n\t\t\tconst bakeLight = new BakeLightSimple(this.scene, light);\n\t\t\tallLights.push(bakeLight);\n\n\t\t\tif (light.enabled && (light.mask & MASK_BAKE) !== 0) {\n\t\t\t\tlight.isStatic = false;\n\t\t\t\tlight.mask = 0xFFFFFFFF;\n\t\t\t\tlight.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;\n\t\t\t\tbakeLights.push(bakeLight);\n\t\t\t}\n\t\t}\n\n\t\tbakeLights.sort();\n\t}\n\n\trestoreLights(allLights) {\n\t\tfor (let i = 0; i < allLights.length; i++) {\n\t\t\tallLights[i].restore();\n\t\t}\n\t}\n\n\tsetupScene() {\n\t\tthis.revertStatic = false;\n\n\t\tif (this.scene._needsStaticPrepare) {\n\t\t\tthis.scene._needsStaticPrepare = false;\n\t\t\tthis.revertStatic = true;\n\t\t}\n\n\t\tthis.fog = this.scene.fog;\n\t\tthis.ambientLight.copy(this.scene.ambientLight);\n\t\tthis.scene.fog = FOG_NONE;\n\n\t\tif (!this.scene.ambientBake) {\n\t\t\tthis.scene.ambientLight.set(0, 0, 0);\n\t\t}\n\n\t\tthis.renderer.setSceneConstants();\n\t}\n\n\trestoreScene() {\n\t\tthis.scene.fog = this.fog;\n\t\tthis.scene.ambientLight.copy(this.ambientLight);\n\n\t\tif (this.revertStatic) {\n\t\t\tthis.scene._needsStaticPrepare = true;\n\t\t}\n\t}\n\n\tcomputeNodeBounds(meshInstances) {\n\t\tconst bounds = new BoundingBox();\n\n\t\tif (meshInstances.length > 0) {\n\t\t\tbounds.copy(meshInstances[0].aabb);\n\n\t\t\tfor (let m = 1; m < meshInstances.length; m++) {\n\t\t\t\tbounds.add(meshInstances[m].aabb);\n\t\t\t}\n\t\t}\n\n\t\treturn bounds;\n\t}\n\n\tcomputeNodesBounds(nodes) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst meshInstances = nodes[i].meshInstances;\n\t\t\tnodes[i].bounds = this.computeNodeBounds(meshInstances);\n\t\t}\n\t}\n\n\tcomputeBounds(meshInstances) {\n\t\tconst bounds = new BoundingBox();\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tbounds.copy(meshInstances[0].aabb);\n\n\t\t\tfor (let m = 1; m < meshInstances.length; m++) {\n\t\t\t\tbounds.add(meshInstances[m].aabb);\n\t\t\t}\n\t\t}\n\n\t\treturn bounds;\n\t}\n\n\tbackupMaterials(meshInstances) {\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tthis.materials[i] = meshInstances[i].material;\n\t\t}\n\t}\n\n\trestoreMaterials(meshInstances) {\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].material = this.materials[i];\n\t\t}\n\t}\n\n\tlightCameraPrepare(device, bakeLight) {\n\t\tconst light = bakeLight.light;\n\t\tlet shadowCam;\n\n\t\tif (light.type === LIGHTTYPE_SPOT) {\n\t\t\tconst lightRenderData = light.getRenderData(null, 0);\n\t\t\tshadowCam = lightRenderData.shadowCamera;\n\n\t\t\tshadowCam._node.setPosition(light._node.getPosition());\n\n\t\t\tshadowCam._node.setRotation(light._node.getRotation());\n\n\t\t\tshadowCam._node.rotateLocal(-90, 0, 0);\n\n\t\t\tshadowCam.projection = PROJECTION_PERSPECTIVE;\n\t\t\tshadowCam.nearClip = light.attenuationEnd / 1000;\n\t\t\tshadowCam.farClip = light.attenuationEnd;\n\t\t\tshadowCam.aspectRatio = 1;\n\t\t\tshadowCam.fov = light._outerConeAngle * 2;\n\t\t\tthis.renderer.updateCameraFrustum(shadowCam);\n\t\t}\n\n\t\treturn shadowCam;\n\t}\n\n\tlightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {\n\t\tconst light = bakeLight.light;\n\t\tlet lightAffectsNode = true;\n\n\t\tif (light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\ttempVec.copy(casterBounds.center);\n\t\t\ttempVec.y += casterBounds.halfExtents.y;\n\t\t\tthis.camera.node.setPosition(tempVec);\n\t\t\tthis.camera.node.setEulerAngles(-90, 0, 0);\n\t\t\tthis.camera.nearClip = 0;\n\t\t\tthis.camera.farClip = casterBounds.halfExtents.y * 2;\n\t\t\tconst frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);\n\t\t\tthis.camera.orthoHeight = frustumSize;\n\t\t} else {\n\t\t\tif (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {\n\t\t\t\tlightAffectsNode = false;\n\t\t\t}\n\t\t}\n\n\t\tif (light.type === LIGHTTYPE_SPOT) {\n\t\t\tlet nodeVisible = false;\n\t\t\tconst meshInstances = bakeNode.meshInstances;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (meshInstances[i]._isVisible(shadowCam)) {\n\t\t\t\t\tnodeVisible = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!nodeVisible) {\n\t\t\t\tlightAffectsNode = false;\n\t\t\t}\n\t\t}\n\n\t\treturn lightAffectsNode;\n\t}\n\n\tsetupLightArray(lightArray, light) {\n\t\tlightArray[LIGHTTYPE_DIRECTIONAL].length = 0;\n\t\tlightArray[LIGHTTYPE_OMNI].length = 0;\n\t\tlightArray[LIGHTTYPE_SPOT].length = 0;\n\t\tlightArray[light.type][0] = light;\n\t\tlight.visibleThisFrame = true;\n\t}\n\n\trenderShadowMap(shadowMapRendered, casters, lightArray, bakeLight) {\n\t\tconst light = bakeLight.light;\n\n\t\tif (!shadowMapRendered && light.castShadows) {\n\t\t\tif (!light.shadowMap && !this.scene.clusteredLightingEnabled) {\n\t\t\t\tlight.shadowMap = this.shadowMapCache.get(this.device, light);\n\t\t\t}\n\n\t\t\tif (light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tthis.renderer._shadowRenderer.cullDirectional(light, casters, this.camera);\n\t\t\t} else {\n\t\t\t\tthis.renderer._shadowRenderer.cullLocal(light, casters);\n\t\t\t}\n\n\t\t\tthis.renderer.renderShadows(lightArray[light.type], this.camera);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpostprocessTextures(device, bakeNodes, passCount) {\n\t\tconst numDilates2x = 1;\n\t\tconst dilateShader = this.lightmapFilters.shaderDilate;\n\t\tconst filterLightmap = this.scene.lightmapFilterEnabled;\n\n\t\tif (filterLightmap) {\n\t\t\tthis.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);\n\t\t}\n\n\t\tfor (let node = 0; node < bakeNodes.length; node++) {\n\t\t\tconst bakeNode = bakeNodes[node];\n\n\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\tconst nodeRT = bakeNode.renderTargets[pass];\n\t\t\t\tconst lightmap = nodeRT.colorBuffer;\n\t\t\t\tconst tempRT = this.renderTargets.get(lightmap.width);\n\t\t\t\tconst tempTex = tempRT.colorBuffer;\n\t\t\t\tthis.lightmapFilters.prepare(lightmap.width, lightmap.height);\n\n\t\t\t\tfor (let i = 0; i < numDilates2x; i++) {\n\t\t\t\t\tthis.lightmapFilters.setSourceTexture(lightmap);\n\t\t\t\t\tconst bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;\n\t\t\t\t\tdrawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);\n\t\t\t\t\tthis.lightmapFilters.setSourceTexture(tempTex);\n\t\t\t\t\tdrawQuadWithShader(device, nodeRT, dilateShader);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbakeInternal(passCount, bakeNodes, allNodes) {\n\t\tconst scene = this.scene;\n\t\tconst device = this.device;\n\t\tconst clusteredLightingEnabled = scene.clusteredLightingEnabled;\n\t\tthis.createMaterials(device, scene, passCount);\n\t\tthis.setupScene();\n\n\t\tscene.layers._update();\n\n\t\tthis.computeNodesBounds(bakeNodes);\n\t\tthis.allocateTextures(bakeNodes, passCount);\n\t\tconst allLights = [],\n\t\t\t\t\tbakeLights = [];\n\t\tthis.prepareLightsToBake(scene.layers, allLights, bakeLights);\n\t\tthis.updateTransforms(allNodes);\n\t\tconst casters = this.prepareShadowCasters(allNodes);\n\t\tthis.renderer.updateCpuSkinMatrices(casters);\n\t\tthis.renderer.gpuUpdate(casters);\n\t\tconst casterBounds = this.computeBounds(casters);\n\t\tlet i, j, rcv, m;\n\n\t\tfor (i = 0; i < bakeNodes.length; i++) {\n\t\t\tconst bakeNode = bakeNodes[i];\n\t\t\trcv = bakeNode.meshInstances;\n\n\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\tm = rcv[j];\n\t\t\t\tm.setLightmapped(false);\n\t\t\t\tm.mask = MASK_BAKE;\n\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);\n\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < bakeLights.length; j++) {\n\t\t\tbakeLights[j].light.enabled = false;\n\t\t}\n\n\t\tconst lightArray = [[], [], []];\n\t\tlet pass, node;\n\t\tlet shadersUpdatedOn1stPass = false;\n\n\t\tfor (i = 0; i < bakeLights.length; i++) {\n\t\t\tconst bakeLight = bakeLights[i];\n\t\t\tconst isAmbientLight = bakeLight instanceof BakeLightAmbient;\n\t\t\tlet numVirtualLights = bakeLight.numVirtualLights;\n\n\t\t\tif (passCount > 1 && numVirtualLights > 1) {\n\t\t\t\tnumVirtualLights = 1;\n\t\t\t}\n\n\t\t\tfor (let virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {\n\t\t\t\tif (numVirtualLights > 1) {\n\t\t\t\t\tbakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);\n\t\t\t\t}\n\n\t\t\t\tbakeLight.startBake();\n\t\t\t\tlet shadowMapRendered = false;\n\t\t\t\tconst shadowCam = this.lightCameraPrepare(device, bakeLight);\n\n\t\t\t\tfor (node = 0; node < bakeNodes.length; node++) {\n\t\t\t\t\tconst bakeNode = bakeNodes[node];\n\t\t\t\t\trcv = bakeNode.meshInstances;\n\t\t\t\t\tconst lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds);\n\n\t\t\t\t\tif (!lightAffectsNode) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setupLightArray(lightArray, bakeLight.light);\n\n\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\tthis.renderer.lightTextureAtlas.update(lightArray[LIGHTTYPE_SPOT], lightArray[LIGHTTYPE_OMNI], this.lightingParams);\n\t\t\t\t\t}\n\n\t\t\t\t\tshadowMapRendered = this.renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight);\n\n\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\tconst clusterLights = lightArray[LIGHTTYPE_SPOT].concat(lightArray[LIGHTTYPE_OMNI]);\n\t\t\t\t\t\tthis.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.backupMaterials(rcv);\n\n\t\t\t\t\tfor (pass = 0; pass < passCount; pass++) {\n\t\t\t\t\t\tif (pass > 0 && virtualLightIndex > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isAmbientLight && pass > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst nodeRT = bakeNode.renderTargets[pass];\n\t\t\t\t\t\tconst lightmapSize = bakeNode.renderTargets[pass].colorBuffer.width;\n\t\t\t\t\t\tconst tempRT = this.renderTargets.get(lightmapSize);\n\t\t\t\t\t\tconst tempTex = tempRT.colorBuffer;\n\n\t\t\t\t\t\tif (pass === 0) {\n\t\t\t\t\t\t\tshadersUpdatedOn1stPass = scene.updateShaders;\n\t\t\t\t\t\t} else if (shadersUpdatedOn1stPass) {\n\t\t\t\t\t\t\tscene.updateShaders = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet passMaterial = this.passMaterials[pass];\n\n\t\t\t\t\t\tif (isAmbientLight) {\n\t\t\t\t\t\t\tconst lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;\n\n\t\t\t\t\t\t\tif (lastVirtualLightForPass && pass === 0) {\n\t\t\t\t\t\t\t\tpassMaterial = this.ambientAOMaterial;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\t\t\t\trcv[j].material = passMaterial;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.renderer.updateShaders(rcv);\n\t\t\t\t\t\tthis.renderer.setCamera(this.camera, tempRT, true);\n\n\t\t\t\t\t\tif (pass === PASS_DIR) {\n\t\t\t\t\t\t\tthis.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\t\tthis.worldClusters.activate(this.renderer.lightTextureAtlas);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.renderer._forwardTime = 0;\n\t\t\t\t\t\tthis.renderer._shadowMapTime = 0;\n\t\t\t\t\t\tthis.renderer.renderForward(this.camera, rcv, rcv.length, lightArray, SHADER_FORWARDHDR);\n\t\t\t\t\t\tbakeNode.renderTargets[pass] = tempRT;\n\t\t\t\t\t\tthis.renderTargets.set(lightmapSize, nodeRT);\n\n\t\t\t\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\t\t\t\tm = rcv[j];\n\t\t\t\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);\n\t\t\t\t\t\t\tm._shaderDefs |= SHADERDEF_LM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.restoreMaterials(rcv);\n\t\t\t\t}\n\n\t\t\t\tbakeLight.endBake(this.shadowMapCache);\n\t\t\t}\n\t\t}\n\n\t\tthis.postprocessTextures(device, bakeNodes, passCount);\n\n\t\tfor (node = 0; node < allNodes.length; node++) {\n\t\t\tallNodes[node].restore();\n\t\t}\n\n\t\tthis.restoreLights(allLights);\n\t\tthis.restoreScene();\n\n\t\tif (!clusteredLightingEnabled) {\n\t\t\tthis.shadowMapCache.clear();\n\t\t}\n\t}\n\n}\n\nconst tempSet = new Set();\nconst clearDepthOptions = {\n\tdepth: 1.0,\n\tflags: CLEARFLAG_DEPTH\n};\n\nclass Picker {\n\tconstructor(app, width, height) {\n\t\tif (app instanceof GraphicsDevice) {\n\t\t\tapp = getApplication();\n\t\t}\n\n\t\tthis.app = app;\n\t\tthis.device = app.graphicsDevice;\n\t\tthis.pickColor = new Float32Array(4);\n\t\tthis.pickColor[3] = 1;\n\t\tthis.mapping = [];\n\t\tthis.cameraEntity = null;\n\t\tthis.layer = null;\n\t\tthis.layerComp = null;\n\t\tthis.initLayerComposition();\n\t\tthis._renderTarget = null;\n\t\tconst device = this.device;\n\t\tthis.clearDepthCommand = new Command(0, 0, function () {\n\t\t\tdevice.clear(clearDepthOptions);\n\t\t});\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\tthis.resize(width, height);\n\t}\n\n\tgetSelection(x, y, width, height) {\n\t\tconst device = this.device;\n\n\t\tif (typeof x === 'object') {\n\t\t\tconst rect = x;\n\t\t\tx = rect.x;\n\t\t\ty = rect.y;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\t\t} else {\n\t\t\ty = this.renderTarget.height - (y + (height || 1));\n\t\t}\n\n\t\tx = Math.floor(x);\n\t\ty = Math.floor(y);\n\t\twidth = Math.floor(Math.max(width || 1, 1));\n\t\theight = Math.floor(Math.max(height || 1, 1));\n\t\tconst origRenderTarget = device.renderTarget;\n\t\tdevice.setRenderTarget(this.renderTarget);\n\t\tdevice.updateBegin();\n\t\tconst pixels = new Uint8Array(4 * width * height);\n\t\tdevice.readPixels(x, y, width, height, pixels);\n\t\tdevice.updateEnd();\n\t\tdevice.setRenderTarget(origRenderTarget);\n\t\tconst mapping = this.mapping;\n\n\t\tfor (let i = 0; i < width * height; i++) {\n\t\t\tconst r = pixels[4 * i + 0];\n\t\t\tconst g = pixels[4 * i + 1];\n\t\t\tconst b = pixels[4 * i + 2];\n\t\t\tconst index = r << 16 | g << 8 | b;\n\n\t\t\tif (index !== 0xffffff) {\n\t\t\t\ttempSet.add(mapping[index]);\n\t\t\t}\n\t\t}\n\n\t\tconst selection = [];\n\t\ttempSet.forEach(meshInstance => selection.push(meshInstance));\n\t\ttempSet.clear();\n\t\treturn selection;\n\t}\n\n\tallocateRenderTarget() {\n\t\tconst colorBuffer = new Texture(this.device, {\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\twidth: this.width,\n\t\t\theight: this.height,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tcolorBuffer.name = 'pick';\n\t\tthis.renderTarget = new RenderTarget({\n\t\t\tcolorBuffer: colorBuffer,\n\t\t\tdepth: true\n\t\t});\n\t}\n\n\treleaseRenderTarget() {\n\t\tthis.cameraEntity.camera.renderTarget = null;\n\n\t\tif (this._renderTarget) {\n\t\t\tthis._renderTarget._colorBuffer.destroy();\n\n\t\t\tthis._renderTarget.destroy();\n\n\t\t\tthis._renderTarget = null;\n\t\t}\n\t}\n\n\tinitLayerComposition() {\n\t\tconst device = this.device;\n\t\tconst self = this;\n\t\tconst pickColorId = device.scope.resolve('uColor');\n\t\tthis.cameraEntity = new Entity();\n\t\tthis.cameraEntity.addComponent(\"camera\");\n\t\tthis.layer = new Layer({\n\t\t\tname: \"Picker\",\n\t\t\tshaderPass: SHADER_PICK,\n\t\t\topaqueSortMode: SORTMODE_NONE,\n\t\t\tonDrawCall: function (meshInstance, index) {\n\t\t\t\tself.pickColor[0] = (index >> 16 & 0xff) / 255;\n\t\t\t\tself.pickColor[1] = (index >> 8 & 0xff) / 255;\n\t\t\t\tself.pickColor[2] = (index & 0xff) / 255;\n\t\t\t\tpickColorId.setValue(self.pickColor);\n\t\t\t\tdevice.setBlending(false);\n\t\t\t\tself.mapping[index] = meshInstance;\n\t\t\t}\n\t\t});\n\t\tthis.layer.addCamera(this.cameraEntity.camera);\n\t\tthis.layerComp = new LayerComposition(\"picker\");\n\t\tthis.layerComp.pushOpaque(this.layer);\n\t}\n\n\tprepare(camera, scene, layers) {\n\t\tif (camera instanceof Camera) {\n\t\t\tcamera = camera.node.camera;\n\t\t}\n\n\t\tif (layers instanceof Layer) {\n\t\t\tlayers = [layers];\n\t\t}\n\n\t\tthis.layer.clearMeshInstances();\n\t\tconst destMeshInstances = this.layer.opaqueMeshInstances;\n\t\tconst srcLayers = scene.layers.layerList;\n\t\tconst subLayerEnabled = scene.layers.subLayerEnabled;\n\t\tconst isTransparent = scene.layers.subLayerList;\n\n\t\tfor (let i = 0; i < srcLayers.length; i++) {\n\t\t\tconst srcLayer = srcLayers[i];\n\n\t\t\tif (layers && layers.indexOf(srcLayer) < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (srcLayer.enabled && subLayerEnabled[i]) {\n\t\t\t\tconst layerCamId = srcLayer.cameras.indexOf(camera);\n\n\t\t\t\tif (layerCamId >= 0) {\n\t\t\t\t\tif (srcLayer._clearDepthBuffer) {\n\t\t\t\t\t\tdestMeshInstances.push(this.clearDepthCommand);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst meshInstances = isTransparent[i] ? srcLayer.instances.transparentMeshInstances : srcLayer.instances.opaqueMeshInstances;\n\n\t\t\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\t\t\tconst meshInstance = meshInstances[j];\n\n\t\t\t\t\t\tif (meshInstance.pick) {\n\t\t\t\t\t\t\tdestMeshInstances.push(meshInstance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {\n\t\t\tthis.releaseRenderTarget();\n\t\t\tthis.allocateRenderTarget();\n\t\t}\n\n\t\tthis.updateCamera(camera);\n\t\tthis.mapping.length = 0;\n\t\tthis.app.renderer.renderComposition(this.layerComp);\n\t}\n\n\tupdateCamera(srcCamera) {\n\t\tthis.cameraEntity.copy(srcCamera.entity);\n\t\tthis.cameraEntity.name = \"PickerCamera\";\n\t\tconst destCamera = this.cameraEntity.camera;\n\t\tdestCamera.copy(srcCamera);\n\t\tdestCamera.clearColorBuffer = true;\n\t\tdestCamera.clearDepthBuffer = true;\n\t\tdestCamera.clearStencilBuffer = true;\n\t\tdestCamera.clearColor = Color.WHITE;\n\t\tdestCamera.renderTarget = this.renderTarget;\n\t\tthis.layer.clearCameras();\n\t\tthis.layer.addCamera(destCamera);\n\t\tdestCamera.layers = [this.layer.id];\n\t}\n\n\tresize(width, height) {\n\t\tthis.width = Math.floor(width);\n\t\tthis.height = Math.floor(height);\n\t}\n\n}\n\nconst MAX_TEXTURE_SIZE = 4096;\nconst DEFAULT_TEXTURE_SIZE = 512;\n\nclass CanvasFont extends EventHandler {\n\tconstructor(app, options = {}) {\n\t\tsuper();\n\t\tthis.type = \"bitmap\";\n\t\tthis.app = app;\n\t\tthis.intensity = 0;\n\t\tthis.fontWeight = options.fontWeight || 'normal';\n\t\tthis.fontSize = parseInt(options.fontSize, 10);\n\t\tthis.glyphSize = this.fontSize;\n\t\tthis.fontName = options.fontName || 'Arial';\n\t\tthis.color = options.color || new Color(1, 1, 1);\n\t\tthis.padding = options.padding || 0;\n\t\tconst w = options.width > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.width || DEFAULT_TEXTURE_SIZE;\n\t\tconst h = options.height > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.height || DEFAULT_TEXTURE_SIZE;\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.height = h;\n\t\tcanvas.width = w;\n\t\tconst texture = new Texture(this.app.graphicsDevice, {\n\t\t\tname: 'font',\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\tminFilter: FILTER_LINEAR_MIPMAP_LINEAR,\n\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tmipmaps: true\n\t\t});\n\t\ttexture.setSource(canvas);\n\t\tthis.textures = [texture];\n\t\tthis.chars = \"\";\n\t\tthis.data = {};\n\t}\n\n\tcreateTextures(text) {\n\t\tconst _chars = this._normalizeCharsSet(text);\n\n\t\tif (_chars.length !== this.chars.length) {\n\t\t\tthis._renderAtlas(_chars);\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < _chars.length; i++) {\n\t\t\tif (_chars[i] !== this.chars[i]) {\n\t\t\t\tthis._renderAtlas(_chars);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateTextures(text) {\n\t\tconst _chars = this._normalizeCharsSet(text);\n\n\t\tconst newCharsSet = [];\n\n\t\tfor (let i = 0; i < _chars.length; i++) {\n\t\t\tconst char = _chars[i];\n\n\t\t\tif (!this.data.chars[char]) {\n\t\t\t\tnewCharsSet.push(char);\n\t\t\t}\n\t\t}\n\n\t\tif (newCharsSet.length > 0) {\n\t\t\tthis._renderAtlas(this.chars.concat(newCharsSet));\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tfor (let i = 0; i < this.textures.length; i++) {\n\t\t\tthis.textures[i].destroy();\n\t\t}\n\n\t\tthis.chars = null;\n\t\tthis.color = null;\n\t\tthis.data = null;\n\t\tthis.fontName = null;\n\t\tthis.fontSize = null;\n\t\tthis.glyphSize = null;\n\t\tthis.intensity = null;\n\t\tthis.textures = null;\n\t\tthis.type = null;\n\t\tthis.fontWeight = null;\n\t}\n\n\t_getAndClearContext(canvas, clearColor) {\n\t\tconst w = canvas.width;\n\t\tconst h = canvas.height;\n\t\tconst ctx = canvas.getContext('2d', {\n\t\t\talpha: true\n\t\t});\n\t\tctx.clearRect(0, 0, w, h);\n\t\tctx.fillStyle = clearColor;\n\t\tctx.fillRect(0, 0, w, h);\n\t\treturn ctx;\n\t}\n\n\t_colorToRgbString(color, alpha) {\n\t\tlet str;\n\t\tconst r = Math.round(255 * color.r);\n\t\tconst g = Math.round(255 * color.g);\n\t\tconst b = Math.round(255 * color.b);\n\n\t\tif (alpha) {\n\t\t\tstr = `rgba(${r}, ${g}, ${b}, ${color.a})`;\n\t\t} else {\n\t\t\tstr = `rgb(${r}, ${g}, ${b})`;\n\t\t}\n\n\t\treturn str;\n\t}\n\n\trenderCharacter(context, char, x, y, color) {\n\t\tcontext.fillStyle = color;\n\t\tcontext.fillText(char, x, y);\n\t}\n\n\t_renderAtlas(charsArray) {\n\t\tthis.chars = charsArray;\n\t\tlet numTextures = 1;\n\t\tlet canvas = this.textures[numTextures - 1].getSource();\n\t\tconst w = canvas.width;\n\t\tconst h = canvas.height;\n\n\t\tconst color = this._colorToRgbString(this.color, false);\n\n\t\tconst a = this.color.a;\n\t\tthis.color.a = 1 / 255;\n\n\t\tconst transparent = this._colorToRgbString(this.color, true);\n\n\t\tthis.color.a = a;\n\t\tconst TEXT_ALIGN = 'center';\n\t\tconst TEXT_BASELINE = 'alphabetic';\n\n\t\tlet ctx = this._getAndClearContext(canvas, transparent);\n\n\t\tctx.font = this.fontWeight + ' ' + this.fontSize.toString() + 'px ' + this.fontName;\n\t\tctx.textAlign = TEXT_ALIGN;\n\t\tctx.textBaseline = TEXT_BASELINE;\n\t\tthis.data = this._createJson(this.chars, this.fontName, w, h);\n\t\tconst symbols = string.getSymbols(this.chars.join(''));\n\t\tconst prevNumTextures = this.textures.length;\n\t\tlet maxHeight = 0;\n\t\tlet maxDescent = 0;\n\t\tconst metrics = {};\n\n\t\tfor (let i = 0; i < symbols.length; i++) {\n\t\t\tconst ch = symbols[i];\n\t\t\tmetrics[ch] = this._getTextMetrics(ch);\n\t\t\tmaxHeight = Math.max(maxHeight, metrics[ch].height);\n\t\t\tmaxDescent = Math.max(maxDescent, metrics[ch].descent);\n\t\t}\n\n\t\tthis.glyphSize = Math.max(this.glyphSize, maxHeight);\n\t\tconst sx = this.glyphSize + this.padding * 2;\n\t\tconst sy = this.glyphSize + this.padding * 2;\n\n\t\tconst _xOffset = this.glyphSize / 2 + this.padding;\n\n\t\tconst _yOffset = sy - maxDescent - this.padding;\n\n\t\tlet _x = 0;\n\t\tlet _y = 0;\n\n\t\tfor (let i = 0; i < symbols.length; i++) {\n\t\t\tconst ch = symbols[i];\n\t\t\tconst code = string.getCodePoint(symbols[i]);\n\t\t\tlet fs = this.fontSize;\n\t\t\tctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;\n\t\t\tctx.textAlign = TEXT_ALIGN;\n\t\t\tctx.textBaseline = TEXT_BASELINE;\n\t\t\tlet width = ctx.measureText(ch).width;\n\n\t\t\tif (width > fs) {\n\t\t\t\tfs = this.fontSize * this.fontSize / width;\n\t\t\t\tctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;\n\t\t\t\twidth = this.fontSize;\n\t\t\t}\n\n\t\t\tthis.renderCharacter(ctx, ch, _x + _xOffset, _y + _yOffset, color);\n\t\t\tconst xoffset = this.padding + (this.glyphSize - width) / 2;\n\t\t\tconst yoffset = -this.padding + metrics[ch].descent - maxDescent;\n\t\t\tconst xadvance = width;\n\n\t\t\tthis._addChar(this.data, ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, numTextures - 1, w, h);\n\n\t\t\t_x += sx;\n\n\t\t\tif (_x + sx > w) {\n\t\t\t\t_x = 0;\n\t\t\t\t_y += sy;\n\n\t\t\t\tif (_y + sy > h) {\n\t\t\t\t\tthis.textures[numTextures - 1].upload();\n\t\t\t\t\tnumTextures++;\n\t\t\t\t\t_y = 0;\n\n\t\t\t\t\tif (numTextures > prevNumTextures) {\n\t\t\t\t\t\tcanvas = document.createElement('canvas');\n\t\t\t\t\t\tcanvas.height = h;\n\t\t\t\t\t\tcanvas.width = w;\n\t\t\t\t\t\tctx = this._getAndClearContext(canvas, transparent);\n\t\t\t\t\t\tconst texture = new Texture(this.app.graphicsDevice, {\n\t\t\t\t\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\t\t\t\t\tmipmaps: true\n\t\t\t\t\t\t});\n\t\t\t\t\t\ttexture.name = 'font-atlas';\n\t\t\t\t\t\ttexture.setSource(canvas);\n\t\t\t\t\t\ttexture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;\n\t\t\t\t\t\ttexture.magFilter = FILTER_LINEAR;\n\t\t\t\t\t\ttexture.addressU = ADDRESS_CLAMP_TO_EDGE;\n\t\t\t\t\t\ttexture.addressV = ADDRESS_CLAMP_TO_EDGE;\n\t\t\t\t\t\tthis.textures.push(texture);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanvas = this.textures[numTextures - 1].getSource();\n\t\t\t\t\t\tctx = this._getAndClearContext(canvas, transparent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.textures[numTextures - 1].upload();\n\n\t\tif (numTextures < prevNumTextures) {\n\t\t\tfor (let i = numTextures; i < prevNumTextures; i++) {\n\t\t\t\tthis.textures[i].destroy();\n\t\t\t}\n\n\t\t\tthis.textures.splice(numTextures);\n\t\t}\n\n\t\tthis.fire(\"render\");\n\t}\n\n\t_createJson(chars, fontName, width, height) {\n\t\tconst base = {\n\t\t\t\"version\": 3,\n\t\t\t\"intensity\": this.intensity,\n\t\t\t\"info\": {\n\t\t\t\t\"face\": fontName,\n\t\t\t\t\"width\": width,\n\t\t\t\t\"height\": height,\n\t\t\t\t\"maps\": [{\n\t\t\t\t\t\"width\": width,\n\t\t\t\t\t\"height\": height\n\t\t\t\t}]\n\t\t\t},\n\t\t\t\"chars\": {}\n\t\t};\n\t\treturn base;\n\t}\n\n\t_addChar(json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {\n\t\tif (json.info.maps.length < mapNum + 1) {\n\t\t\tjson.info.maps.push({\n\t\t\t\t\"width\": mapW,\n\t\t\t\t\"height\": mapH\n\t\t\t});\n\t\t}\n\n\t\tconst scale = this.fontSize / 32;\n\t\tjson.chars[char] = {\n\t\t\t\"id\": charCode,\n\t\t\t\"letter\": char,\n\t\t\t\"x\": x,\n\t\t\t\"y\": y,\n\t\t\t\"width\": w,\n\t\t\t\"height\": h,\n\t\t\t\"xadvance\": xadvance / scale,\n\t\t\t\"xoffset\": xoffset / scale,\n\t\t\t\"yoffset\": (yoffset + this.padding) / scale,\n\t\t\t\"scale\": scale,\n\t\t\t\"range\": 1,\n\t\t\t\"map\": mapNum,\n\t\t\t\"bounds\": [0, 0, w / scale, h / scale]\n\t\t};\n\t}\n\n\t_normalizeCharsSet(text) {\n\t\tconst unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();\n\n\t\tif (unicodeConverterFunc) {\n\t\t\ttext = unicodeConverterFunc(text);\n\t\t}\n\n\t\tconst set = {};\n\t\tconst symbols = string.getSymbols(text);\n\n\t\tfor (let i = 0; i < symbols.length; i++) {\n\t\t\tconst ch = symbols[i];\n\t\t\tif (set[ch]) continue;\n\t\t\tset[ch] = ch;\n\t\t}\n\n\t\tconst chars = Object.keys(set);\n\t\treturn chars.sort();\n\t}\n\n\t_getTextMetrics(text) {\n\t\tconst textSpan = document.createElement('span');\n\t\ttextSpan.id = 'content-span';\n\t\ttextSpan.innerHTML = text;\n\t\tconst block = document.createElement(\"div\");\n\t\tblock.id = 'content-block';\n\t\tblock.style.display = 'inline-block';\n\t\tblock.style.width = '1px';\n\t\tblock.style.height = '0px';\n\t\tconst div = document.createElement('div');\n\t\tdiv.appendChild(textSpan);\n\t\tdiv.appendChild(block);\n\t\tdiv.style.font = this.fontSize + 'px ' + this.fontName;\n\t\tconst body = document.body;\n\t\tbody.appendChild(div);\n\t\tlet ascent = -1;\n\t\tlet descent = -1;\n\t\tlet height = -1;\n\n\t\ttry {\n\t\t\tblock.style['vertical-align'] = 'baseline';\n\t\t\tascent = block.offsetTop - textSpan.offsetTop;\n\t\t\tblock.style['vertical-align'] = 'bottom';\n\t\t\theight = block.offsetTop - textSpan.offsetTop;\n\t\t\tdescent = height - ascent;\n\t\t} finally {\n\t\t\tdocument.body.removeChild(div);\n\t\t}\n\n\t\treturn {\n\t\t\tascent: ascent,\n\t\t\tdescent: descent,\n\t\t\theight: height\n\t\t};\n\t}\n\n}\n\nclass ResourceHandler {\n\tload(url, callback, asset) {\n\t\tthrow new Error('not implemented');\n\t}\n\n\topen(url, data, asset) {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass SceneSettingsHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tSceneUtils.load(url, this.maxRetries, callback);\n\t}\n\n\topen(url, data) {\n\t\treturn data.settings;\n\t}\n\n}\n\nconst reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);\n\nfunction createScript(name, app) {\n\tif (script.legacy) {\n\t\treturn null;\n\t}\n\n\tif (reservedScriptNames.has(name)) throw new Error(`script name: '${name}' is reserved, please change script name`);\n\n\tconst scriptType = function scriptType(args) {\n\t\tEventHandler.prototype.initEventHandler.call(this);\n\t\tScriptType.prototype.initScriptType.call(this, args);\n\t};\n\n\tscriptType.prototype = Object.create(ScriptType.prototype);\n\tscriptType.prototype.constructor = scriptType;\n\tscriptType.extend = ScriptType.extend;\n\tscriptType.attributes = new ScriptAttributes(scriptType);\n\tregisterScript(scriptType, name, app);\n\treturn scriptType;\n}\n\nconst reservedAttributes = {};\nScriptAttributes.reservedNames.forEach((value, value2, set) => {\n\treservedAttributes[value] = 1;\n});\ncreateScript.reservedAttributes = reservedAttributes;\n\nfunction registerScript(script, name, app) {\n\tif (script.legacy) {\n\t\treturn;\n\t}\n\n\tif (typeof script !== 'function') throw new Error(`script class: '${script}' must be a constructor function (i.e. class).`);\n\tif (!(script.prototype instanceof ScriptType)) throw new Error(`script class: '${ScriptType.__getScriptName(script)}' does not extend pc.ScriptType.`);\n\tname = name || script.__name || ScriptType.__getScriptName(script);\n\tif (reservedScriptNames.has(name)) throw new Error(`script name: '${name}' is reserved, please change script name`);\n\tscript.__name = name;\n\tconst registry = app ? app.scripts : Application.getApplication().scripts;\n\tregistry.add(script);\n\n\tScriptHandler._push(script);\n}\n\nclass KeyboardEvent {\n\tconstructor(keyboard, event) {\n\t\tif (event) {\n\t\t\tthis.key = event.keyCode;\n\t\t\tthis.element = event.target;\n\t\t\tthis.event = event;\n\t\t} else {\n\t\t\tthis.key = null;\n\t\t\tthis.element = null;\n\t\t\tthis.event = null;\n\t\t}\n\t}\n\n}\n\nconst _keyboardEvent = new KeyboardEvent();\n\nfunction makeKeyboardEvent(event) {\n\t_keyboardEvent.key = event.keyCode;\n\t_keyboardEvent.element = event.target;\n\t_keyboardEvent.event = event;\n\treturn _keyboardEvent;\n}\n\nfunction toKeyCode(s) {\n\tif (typeof s === \"string\") {\n\t\treturn s.toUpperCase().charCodeAt(0);\n\t}\n\n\treturn s;\n}\n\nconst _keyCodeToKeyIdentifier = {\n\t'9': 'Tab',\n\t'13': 'Enter',\n\t'16': 'Shift',\n\t'17': 'Control',\n\t'18': 'Alt',\n\t'27': 'Escape',\n\t'37': 'Left',\n\t'38': 'Up',\n\t'39': 'Right',\n\t'40': 'Down',\n\t'46': 'Delete',\n\t'91': 'Win'\n};\n\nclass Keyboard extends EventHandler {\n\tconstructor(element, options = {}) {\n\t\tsuper();\n\t\tthis._element = null;\n\t\tthis._keyDownHandler = this._handleKeyDown.bind(this);\n\t\tthis._keyUpHandler = this._handleKeyUp.bind(this);\n\t\tthis._keyPressHandler = this._handleKeyPress.bind(this);\n\t\tthis._visibilityChangeHandler = this._handleVisibilityChange.bind(this);\n\t\tthis._windowBlurHandler = this._handleWindowBlur.bind(this);\n\t\tthis._keymap = {};\n\t\tthis._lastmap = {};\n\n\t\tif (element) {\n\t\t\tthis.attach(element);\n\t\t}\n\n\t\tthis.preventDefault = options.preventDefault || false;\n\t\tthis.stopPropagation = options.stopPropagation || false;\n\t}\n\n\tattach(element) {\n\t\tif (this._element) {\n\t\t\tthis.detach();\n\t\t}\n\n\t\tthis._element = element;\n\n\t\tthis._element.addEventListener(\"keydown\", this._keyDownHandler, false);\n\n\t\tthis._element.addEventListener(\"keypress\", this._keyPressHandler, false);\n\n\t\tthis._element.addEventListener(\"keyup\", this._keyUpHandler, false);\n\n\t\tdocument.addEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\twindow.addEventListener('blur', this._windowBlurHandler, false);\n\t}\n\n\tdetach() {\n\t\tif (!this._element) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._element.removeEventListener(\"keydown\", this._keyDownHandler);\n\n\t\tthis._element.removeEventListener(\"keypress\", this._keyPressHandler);\n\n\t\tthis._element.removeEventListener(\"keyup\", this._keyUpHandler);\n\n\t\tthis._element = null;\n\t\tdocument.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\twindow.removeEventListener('blur', this._windowBlurHandler, false);\n\t}\n\n\ttoKeyIdentifier(keyCode) {\n\t\tkeyCode = toKeyCode(keyCode);\n\n\t\tconst id = _keyCodeToKeyIdentifier[keyCode.toString()];\n\n\t\tif (id) {\n\t\t\treturn id;\n\t\t}\n\n\t\tlet hex = keyCode.toString(16).toUpperCase();\n\t\tconst length = hex.length;\n\n\t\tfor (let count = 0; count < 4 - length; count++) {\n\t\t\thex = '0' + hex;\n\t\t}\n\n\t\treturn 'U+' + hex;\n\t}\n\n\t_handleKeyDown(event) {\n\t\tconst code = event.keyCode || event.charCode;\n\t\tif (code === undefined) return;\n\t\tconst id = this.toKeyIdentifier(code);\n\t\tthis._keymap[id] = true;\n\t\tthis.fire(\"keydown\", makeKeyboardEvent(event));\n\n\t\tif (this.preventDefault) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\tif (this.stopPropagation) {\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\t_handleKeyUp(event) {\n\t\tconst code = event.keyCode || event.charCode;\n\t\tif (code === undefined) return;\n\t\tconst id = this.toKeyIdentifier(code);\n\t\tdelete this._keymap[id];\n\t\tthis.fire(\"keyup\", makeKeyboardEvent(event));\n\n\t\tif (this.preventDefault) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\tif (this.stopPropagation) {\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\t_handleKeyPress(event) {\n\t\tthis.fire(\"keypress\", makeKeyboardEvent(event));\n\n\t\tif (this.preventDefault) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\tif (this.stopPropagation) {\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\t_handleVisibilityChange() {\n\t\tif (document.visibilityState === 'hidden') {\n\t\t\tthis._handleWindowBlur();\n\t\t}\n\t}\n\n\t_handleWindowBlur() {\n\t\tthis._keymap = {};\n\t\tthis._lastmap = {};\n\t}\n\n\tupdate() {\n\t\tfor (const prop in this._lastmap) {\n\t\t\tdelete this._lastmap[prop];\n\t\t}\n\n\t\tfor (const prop in this._keymap) {\n\t\t\tif (this._keymap.hasOwnProperty(prop)) {\n\t\t\t\tthis._lastmap[prop] = this._keymap[prop];\n\t\t\t}\n\t\t}\n\t}\n\n\tisPressed(key) {\n\t\tconst keyCode = toKeyCode(key);\n\t\tconst id = this.toKeyIdentifier(keyCode);\n\t\treturn !!this._keymap[id];\n\t}\n\n\twasPressed(key) {\n\t\tconst keyCode = toKeyCode(key);\n\t\tconst id = this.toKeyIdentifier(keyCode);\n\t\treturn !!this._keymap[id] && !!!this._lastmap[id];\n\t}\n\n\twasReleased(key) {\n\t\tconst keyCode = toKeyCode(key);\n\t\tconst id = this.toKeyIdentifier(keyCode);\n\t\treturn !!!this._keymap[id] && !!this._lastmap[id];\n\t}\n\n}\n\nfunction isMousePointerLocked() {\n\treturn !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);\n}\n\nclass MouseEvent {\n\tconstructor(mouse, event) {\n\t\tlet coords = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\n\t\tif (event) {\n\t\t\tif (event instanceof MouseEvent) {\n\t\t\t\tthrow Error(\"Expected MouseEvent\");\n\t\t\t}\n\n\t\t\tcoords = mouse._getTargetCoords(event);\n\t\t} else {\n\t\t\tevent = {};\n\t\t}\n\n\t\tif (coords) {\n\t\t\tthis.x = coords.x;\n\t\t\tthis.y = coords.y;\n\t\t} else if (isMousePointerLocked()) {\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.wheelDelta = 0;\n\n\t\tif (event.type === 'wheel') {\n\t\t\tif (event.deltaY > 0) {\n\t\t\t\tthis.wheelDelta = 1;\n\t\t\t} else if (event.deltaY < 0) {\n\t\t\t\tthis.wheelDelta = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (isMousePointerLocked()) {\n\t\t\tthis.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;\n\t\t\tthis.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;\n\t\t} else {\n\t\t\tthis.dx = this.x - mouse._lastX;\n\t\t\tthis.dy = this.y - mouse._lastY;\n\t\t}\n\n\t\tif (event.type === 'mousedown' || event.type === 'mouseup') {\n\t\t\tthis.button = event.button;\n\t\t} else {\n\t\t\tthis.button = MOUSEBUTTON_NONE;\n\t\t}\n\n\t\tthis.buttons = mouse._buttons.slice(0);\n\t\tthis.element = event.target;\n\t\tthis.ctrlKey = event.ctrlKey || false;\n\t\tthis.altKey = event.altKey || false;\n\t\tthis.shiftKey = event.shiftKey || false;\n\t\tthis.metaKey = event.metaKey || false;\n\t\tthis.event = event;\n\t}\n\n}\n\nclass Mouse extends EventHandler {\n\tconstructor(element) {\n\t\tsuper();\n\t\tthis._lastX = 0;\n\t\tthis._lastY = 0;\n\t\tthis._buttons = [false, false, false];\n\t\tthis._lastbuttons = [false, false, false];\n\t\tthis._upHandler = this._handleUp.bind(this);\n\t\tthis._downHandler = this._handleDown.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._wheelHandler = this._handleWheel.bind(this);\n\n\t\tthis._contextMenuHandler = event => {\n\t\t\tevent.preventDefault();\n\t\t};\n\n\t\tthis._target = null;\n\t\tthis._attached = false;\n\t\tthis.attach(element);\n\t}\n\n\tstatic isPointerLocked() {\n\t\treturn isMousePointerLocked();\n\t}\n\n\tattach(element) {\n\t\tthis._target = element;\n\t\tif (this._attached) return;\n\t\tthis._attached = true;\n\t\tconst opts = platform.passiveEvents ? {\n\t\t\tpassive: false\n\t\t} : false;\n\t\twindow.addEventListener(\"mouseup\", this._upHandler, opts);\n\t\twindow.addEventListener(\"mousedown\", this._downHandler, opts);\n\t\twindow.addEventListener(\"mousemove\", this._moveHandler, opts);\n\t\twindow.addEventListener(\"wheel\", this._wheelHandler, opts);\n\t}\n\n\tdetach() {\n\t\tif (!this._attached) return;\n\t\tthis._attached = false;\n\t\tthis._target = null;\n\t\tconst opts = platform.passiveEvents ? {\n\t\t\tpassive: false\n\t\t} : false;\n\t\twindow.removeEventListener(\"mouseup\", this._upHandler, opts);\n\t\twindow.removeEventListener(\"mousedown\", this._downHandler, opts);\n\t\twindow.removeEventListener(\"mousemove\", this._moveHandler, opts);\n\t\twindow.removeEventListener(\"wheel\", this._wheelHandler, opts);\n\t}\n\n\tdisableContextMenu() {\n\t\tif (!this._target) return;\n\n\t\tthis._target.addEventListener(\"contextmenu\", this._contextMenuHandler);\n\t}\n\n\tenableContextMenu() {\n\t\tif (!this._target) return;\n\n\t\tthis._target.removeEventListener(\"contextmenu\", this._contextMenuHandler);\n\t}\n\n\tenablePointerLock(success, error) {\n\t\tif (!document.body.requestPointerLock) {\n\t\t\tif (error) error();\n\t\t\treturn;\n\t\t}\n\n\t\tconst s = () => {\n\t\t\tsuccess();\n\t\t\tdocument.removeEventListener('pointerlockchange', s);\n\t\t};\n\n\t\tconst e = () => {\n\t\t\terror();\n\t\t\tdocument.removeEventListener('pointerlockerror', e);\n\t\t};\n\n\t\tif (success) {\n\t\t\tdocument.addEventListener('pointerlockchange', s, false);\n\t\t}\n\n\t\tif (error) {\n\t\t\tdocument.addEventListener('pointerlockerror', e, false);\n\t\t}\n\n\t\tdocument.body.requestPointerLock();\n\t}\n\n\tdisablePointerLock(success) {\n\t\tif (!document.exitPointerLock) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst s = () => {\n\t\t\tsuccess();\n\t\t\tdocument.removeEventListener('pointerlockchange', s);\n\t\t};\n\n\t\tif (success) {\n\t\t\tdocument.addEventListener('pointerlockchange', s, false);\n\t\t}\n\n\t\tdocument.exitPointerLock();\n\t}\n\n\tupdate() {\n\t\tthis._lastbuttons[0] = this._buttons[0];\n\t\tthis._lastbuttons[1] = this._buttons[1];\n\t\tthis._lastbuttons[2] = this._buttons[2];\n\t}\n\n\tisPressed(button) {\n\t\treturn this._buttons[button];\n\t}\n\n\twasPressed(button) {\n\t\treturn this._buttons[button] && !this._lastbuttons[button];\n\t}\n\n\twasReleased(button) {\n\t\treturn !this._buttons[button] && this._lastbuttons[button];\n\t}\n\n\t_handleUp(event) {\n\t\tthis._buttons[event.button] = false;\n\t\tconst e = new MouseEvent(this, event);\n\t\tif (!e.event) return;\n\t\tthis.fire(EVENT_MOUSEUP, e);\n\t}\n\n\t_handleDown(event) {\n\t\tthis._buttons[event.button] = true;\n\t\tconst e = new MouseEvent(this, event);\n\t\tif (!e.event) return;\n\t\tthis.fire(EVENT_MOUSEDOWN, e);\n\t}\n\n\t_handleMove(event) {\n\t\tconst e = new MouseEvent(this, event);\n\t\tif (!e.event) return;\n\t\tthis.fire(EVENT_MOUSEMOVE, e);\n\t\tthis._lastX = e.x;\n\t\tthis._lastY = e.y;\n\t}\n\n\t_handleWheel(event) {\n\t\tconst e = new MouseEvent(this, event);\n\t\tif (!e.event) return;\n\t\tthis.fire(EVENT_MOUSEWHEEL, e);\n\t}\n\n\t_getTargetCoords(event) {\n\t\tconst rect = this._target.getBoundingClientRect();\n\n\t\tconst left = Math.floor(rect.left);\n\t\tconst top = Math.floor(rect.top);\n\n\t\tif (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tx: event.clientX - left,\n\t\t\ty: event.clientY - top\n\t\t};\n\t}\n\n}\n\nclass Controller {\n\tconstructor(element, options = {}) {\n\t\tthis._keyboard = options.keyboard || null;\n\t\tthis._mouse = options.mouse || null;\n\t\tthis._gamepads = options.gamepads || null;\n\t\tthis._element = null;\n\t\tthis._actions = {};\n\t\tthis._axes = {};\n\t\tthis._axesValues = {};\n\n\t\tif (element) {\n\t\t\tthis.attach(element);\n\t\t}\n\t}\n\n\tattach(element) {\n\t\tthis._element = element;\n\n\t\tif (this._keyboard) {\n\t\t\tthis._keyboard.attach(element);\n\t\t}\n\n\t\tif (this._mouse) {\n\t\t\tthis._mouse.attach(element);\n\t\t}\n\t}\n\n\tdetach() {\n\t\tif (this._keyboard) {\n\t\t\tthis._keyboard.detach();\n\t\t}\n\n\t\tif (this._mouse) {\n\t\t\tthis._mouse.detach();\n\t\t}\n\n\t\tthis._element = null;\n\t}\n\n\tdisableContextMenu() {\n\t\tif (!this._mouse) {\n\t\t\tthis._enableMouse();\n\t\t}\n\n\t\tthis._mouse.disableContextMenu();\n\t}\n\n\tenableContextMenu() {\n\t\tif (!this._mouse) {\n\t\t\tthis._enableMouse();\n\t\t}\n\n\t\tthis._mouse.enableContextMenu();\n\t}\n\n\tupdate(dt) {\n\t\tif (this._keyboard) {\n\t\t\tthis._keyboard.update(dt);\n\t\t}\n\n\t\tif (this._mouse) {\n\t\t\tthis._mouse.update(dt);\n\t\t}\n\n\t\tif (this._gamepads) {\n\t\t\tthis._gamepads.update(dt);\n\t\t}\n\n\t\tthis._axesValues = {};\n\n\t\tfor (const key in this._axes) {\n\t\t\tthis._axesValues[key] = [];\n\t\t}\n\t}\n\n\tregisterKeys(action, keys) {\n\t\tif (!this._keyboard) {\n\t\t\tthis._enableKeyboard();\n\t\t}\n\n\t\tif (this._actions[action]) {\n\t\t\tthrow new Error(`Action: ${action} already registered`);\n\t\t}\n\n\t\tif (keys === undefined) {\n\t\t\tthrow new Error(\"Invalid button\");\n\t\t}\n\n\t\tif (!keys.length) {\n\t\t\tkeys = [keys];\n\t\t}\n\n\t\tif (this._actions[action]) {\n\t\t\tthis._actions[action].push({\n\t\t\t\ttype: ACTION_KEYBOARD,\n\t\t\t\tkeys: keys\n\t\t\t});\n\t\t} else {\n\t\t\tthis._actions[action] = [{\n\t\t\t\ttype: ACTION_KEYBOARD,\n\t\t\t\tkeys: keys\n\t\t\t}];\n\t\t}\n\t}\n\n\tregisterMouse(action, button) {\n\t\tif (!this._mouse) {\n\t\t\tthis._enableMouse();\n\t\t}\n\n\t\tif (button === undefined) {\n\t\t\tthrow new Error('Invalid button');\n\t\t}\n\n\t\tif (this._actions[action]) {\n\t\t\tthis._actions[action].push({\n\t\t\t\ttype: ACTION_MOUSE,\n\t\t\t\tbutton: button\n\t\t\t});\n\t\t} else {\n\t\t\tthis._actions[action] = [{\n\t\t\t\ttype: ACTION_MOUSE,\n\t\t\t\tbutton: -button\n\t\t\t}];\n\t\t}\n\t}\n\n\tregisterPadButton(action, pad, button) {\n\t\tif (button === undefined) {\n\t\t\tthrow new Error('Invalid button');\n\t\t}\n\n\t\tif (this._actions[action]) {\n\t\t\tthis._actions[action].push({\n\t\t\t\ttype: ACTION_GAMEPAD,\n\t\t\t\tbutton: button,\n\t\t\t\tpad: pad\n\t\t\t});\n\t\t} else {\n\t\t\tthis._actions[action] = [{\n\t\t\t\ttype: ACTION_GAMEPAD,\n\t\t\t\tbutton: button,\n\t\t\t\tpad: pad\n\t\t\t}];\n\t\t}\n\t}\n\n\tregisterAxis(options) {\n\t\tconst name = options.name;\n\n\t\tif (!this._axes[name]) {\n\t\t\tthis._axes[name] = [];\n\t\t}\n\n\t\tconst i = this._axes[name].push(name);\n\n\t\toptions = options || {};\n\t\toptions.pad = options.pad || PAD_1;\n\n\t\tconst bind = function bind(controller, source, value, key) {\n\t\t\tswitch (source) {\n\t\t\t\tcase 'mousex':\n\t\t\t\t\tcontroller._mouse.on(EVENT_MOUSEMOVE, function (e) {\n\t\t\t\t\t\tcontroller._axesValues[name][i] = e.dx / 10;\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mousey':\n\t\t\t\t\tcontroller._mouse.on(EVENT_MOUSEMOVE, function (e) {\n\t\t\t\t\t\tcontroller._axesValues[name][i] = e.dy / 10;\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'key':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._keyboard.isPressed(key) ? value : 0;\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'padrx':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'padry':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'padlx':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'padly':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown axis');\n\t\t\t}\n\t\t};\n\n\t\tbind(this, options.positive, 1, options.positiveKey);\n\n\t\tif (options.negativeKey || options.negative !== options.positive) {\n\t\t\tbind(this, options.negative, -1, options.negativeKey);\n\t\t}\n\t}\n\n\tisPressed(actionName) {\n\t\tif (!this._actions[actionName]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst length = this._actions[actionName].length;\n\n\t\tfor (let index = 0; index < length; ++index) {\n\t\t\tconst action = this._actions[actionName][index];\n\n\t\t\tswitch (action.type) {\n\t\t\t\tcase ACTION_KEYBOARD:\n\t\t\t\t\tif (this._keyboard) {\n\t\t\t\t\t\tconst len = action.keys.length;\n\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tif (this._keyboard.isPressed(action.keys[i])) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACTION_MOUSE:\n\t\t\t\t\tif (this._mouse && this._mouse.isPressed(action.button)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACTION_GAMEPAD:\n\t\t\t\t\tif (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\twasPressed(actionName) {\n\t\tif (!this._actions[actionName]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst length = this._actions[actionName].length;\n\n\t\tfor (let index = 0; index < length; ++index) {\n\t\t\tconst action = this._actions[actionName][index];\n\n\t\t\tswitch (action.type) {\n\t\t\t\tcase ACTION_KEYBOARD:\n\t\t\t\t\tif (this._keyboard) {\n\t\t\t\t\t\tconst len = action.keys.length;\n\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tif (this._keyboard.wasPressed(action.keys[i])) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACTION_MOUSE:\n\t\t\t\t\tif (this._mouse && this._mouse.wasPressed(action.button)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACTION_GAMEPAD:\n\t\t\t\t\tif (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetAxis(name) {\n\t\tlet value = 0;\n\n\t\tif (this._axes[name]) {\n\t\t\tconst len = this._axes[name].length;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tif (type(this._axes[name][i]) === 'function') {\n\t\t\t\t\tconst v = this._axes[name][i]();\n\n\t\t\t\t\tif (Math.abs(v) > Math.abs(value)) {\n\t\t\t\t\t\tvalue = v;\n\t\t\t\t\t}\n\t\t\t\t} else if (this._axesValues[name]) {\n\t\t\t\t\tif (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {\n\t\t\t\t\t\tvalue = this._axesValues[name][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t_enableMouse() {\n\t\tthis._mouse = new Mouse();\n\n\t\tif (!this._element) {\n\t\t\tthrow new Error(\"Controller must be attached to an Element\");\n\t\t}\n\n\t\tthis._mouse.attach(this._element);\n\t}\n\n\t_enableKeyboard() {\n\t\tthis._keyboard = new Keyboard();\n\n\t\tif (!this._element) {\n\t\t\tthrow new Error(\"Controller must be attached to an Element\");\n\t\t}\n\n\t\tthis._keyboard.attach(this._element);\n\t}\n\n}\n\nlet targetX, targetY;\nconst vecA = new Vec3();\nconst vecB = new Vec3();\nconst rayA = new Ray();\nconst rayB = new Ray();\nconst rayC = new Ray();\nrayA.end = new Vec3();\nrayB.end = new Vec3();\nrayC.end = new Vec3();\n\nconst _pq = new Vec3();\n\nconst _pa = new Vec3();\n\nconst _pb = new Vec3();\n\nconst _pc = new Vec3();\n\nconst _pd = new Vec3();\n\nconst _m = new Vec3();\n\nconst _au = new Vec3();\n\nconst _bv = new Vec3();\n\nconst _cw = new Vec3();\n\nconst _ir = new Vec3();\n\nconst _sct = new Vec3();\n\nconst _accumulatedScale = new Vec3();\n\nconst _paddingTop = new Vec3();\n\nconst _paddingBottom = new Vec3();\n\nconst _paddingLeft = new Vec3();\n\nconst _paddingRight = new Vec3();\n\nconst _cornerBottomLeft = new Vec3();\n\nconst _cornerBottomRight = new Vec3();\n\nconst _cornerTopRight = new Vec3();\n\nconst _cornerTopLeft = new Vec3();\n\nconst ZERO_VEC4 = new Vec4();\n\nfunction scalarTriple(p1, p2, p3) {\n\treturn _sct.cross(p1, p2).dot(p3);\n}\n\nfunction intersectLineQuad(p, q, corners) {\n\t_pq.sub2(q, p);\n\n\t_pa.sub2(corners[0], p);\n\n\t_pb.sub2(corners[1], p);\n\n\t_pc.sub2(corners[2], p);\n\n\t_m.cross(_pc, _pq);\n\n\tlet v = _pa.dot(_m);\n\n\tlet u;\n\tlet w;\n\n\tif (v >= 0) {\n\t\tu = -_pb.dot(_m);\n\t\tif (u < 0) return -1;\n\t\tw = scalarTriple(_pq, _pb, _pa);\n\t\tif (w < 0) return -1;\n\t\tconst denom = 1.0 / (u + v + w);\n\n\t\t_au.copy(corners[0]).mulScalar(u * denom);\n\n\t\t_bv.copy(corners[1]).mulScalar(v * denom);\n\n\t\t_cw.copy(corners[2]).mulScalar(w * denom);\n\n\t\t_ir.copy(_au).add(_bv).add(_cw);\n\t} else {\n\t\t_pd.sub2(corners[3], p);\n\n\t\tu = _pd.dot(_m);\n\t\tif (u < 0) return -1;\n\t\tw = scalarTriple(_pq, _pa, _pd);\n\t\tif (w < 0) return -1;\n\t\tv = -v;\n\t\tconst denom = 1.0 / (u + v + w);\n\n\t\t_au.copy(corners[0]).mulScalar(u * denom);\n\n\t\t_bv.copy(corners[3]).mulScalar(v * denom);\n\n\t\t_cw.copy(corners[2]).mulScalar(w * denom);\n\n\t\t_ir.copy(_au).add(_bv).add(_cw);\n\t}\n\n\tif (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;\n\tif (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;\n\treturn _ir.sub(p).lengthSq();\n}\n\nclass ElementInputEvent {\n\tconstructor(event, element, camera) {\n\t\tthis.event = event;\n\t\tthis.element = element;\n\t\tthis.camera = camera;\n\t\tthis._stopPropagation = false;\n\t}\n\n\tstopPropagation() {\n\t\tthis._stopPropagation = true;\n\n\t\tif (this.event) {\n\t\t\tthis.event.stopImmediatePropagation();\n\t\t\tthis.event.stopPropagation();\n\t\t}\n\t}\n\n}\n\nclass ElementMouseEvent extends ElementInputEvent {\n\tconstructor(event, element, camera, x, y, lastX, lastY) {\n\t\tsuper(event, element, camera);\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.ctrlKey = event.ctrlKey || false;\n\t\tthis.altKey = event.altKey || false;\n\t\tthis.shiftKey = event.shiftKey || false;\n\t\tthis.metaKey = event.metaKey || false;\n\t\tthis.button = event.button;\n\n\t\tif (Mouse.isPointerLocked()) {\n\t\t\tthis.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;\n\t\t\tthis.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;\n\t\t} else {\n\t\t\tthis.dx = x - lastX;\n\t\t\tthis.dy = y - lastY;\n\t\t}\n\n\t\tthis.wheelDelta = 0;\n\n\t\tif (event.type === 'wheel') {\n\t\t\tif (event.deltaY > 0) {\n\t\t\t\tthis.wheelDelta = 1;\n\t\t\t} else if (event.deltaY < 0) {\n\t\t\t\tthis.wheelDelta = -1;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass ElementTouchEvent extends ElementInputEvent {\n\tconstructor(event, element, camera, x, y, touch) {\n\t\tsuper(event, element, camera);\n\t\tthis.touches = event.touches;\n\t\tthis.changedTouches = event.changedTouches;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.touch = touch;\n\t}\n\n}\n\nclass ElementSelectEvent extends ElementInputEvent {\n\tconstructor(event, element, camera, inputSource) {\n\t\tsuper(event, element, camera);\n\t\tthis.inputSource = inputSource;\n\t}\n\n}\n\nclass ElementInput {\n\tconstructor(domElement, options) {\n\t\tthis._app = null;\n\t\tthis._attached = false;\n\t\tthis._target = null;\n\t\tthis._enabled = true;\n\t\tthis._lastX = 0;\n\t\tthis._lastY = 0;\n\t\tthis._upHandler = this._handleUp.bind(this);\n\t\tthis._downHandler = this._handleDown.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._wheelHandler = this._handleWheel.bind(this);\n\t\tthis._touchstartHandler = this._handleTouchStart.bind(this);\n\t\tthis._touchendHandler = this._handleTouchEnd.bind(this);\n\t\tthis._touchcancelHandler = this._touchendHandler;\n\t\tthis._touchmoveHandler = this._handleTouchMove.bind(this);\n\t\tthis._sortHandler = this._sortElements.bind(this);\n\t\tthis._elements = [];\n\t\tthis._hoveredElement = null;\n\t\tthis._pressedElement = null;\n\t\tthis._touchedElements = {};\n\t\tthis._touchesForWhichTouchLeaveHasFired = {};\n\t\tthis._selectedElements = {};\n\t\tthis._selectedPressedElements = {};\n\t\tthis._useMouse = !options || options.useMouse !== false;\n\t\tthis._useTouch = !options || options.useTouch !== false;\n\t\tthis._useXr = !options || options.useXr !== false;\n\t\tthis._selectEventsAttached = false;\n\t\tif (platform.touch) this._clickedEntities = {};\n\t\tthis.attach(domElement);\n\t}\n\n\tset enabled(value) {\n\t\tthis._enabled = value;\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tset app(value) {\n\t\tthis._app = value;\n\t}\n\n\tget app() {\n\t\treturn this._app || getApplication();\n\t}\n\n\tattach(domElement) {\n\t\tif (this._attached) {\n\t\t\tthis._attached = false;\n\t\t\tthis.detach();\n\t\t}\n\n\t\tthis._target = domElement;\n\t\tthis._attached = true;\n\t\tconst opts = platform.passiveEvents ? {\n\t\t\tpassive: true\n\t\t} : false;\n\n\t\tif (this._useMouse) {\n\t\t\twindow.addEventListener('mouseup', this._upHandler, opts);\n\t\t\twindow.addEventListener('mousedown', this._downHandler, opts);\n\t\t\twindow.addEventListener('mousemove', this._moveHandler, opts);\n\t\t\twindow.addEventListener('wheel', this._wheelHandler, opts);\n\t\t}\n\n\t\tif (this._useTouch && platform.touch) {\n\t\t\tthis._target.addEventListener('touchstart', this._touchstartHandler, opts);\n\n\t\t\tthis._target.addEventListener('touchend', this._touchendHandler, false);\n\n\t\t\tthis._target.addEventListener('touchmove', this._touchmoveHandler, false);\n\n\t\t\tthis._target.addEventListener('touchcancel', this._touchcancelHandler, false);\n\t\t}\n\n\t\tthis.attachSelectEvents();\n\t}\n\n\tattachSelectEvents() {\n\t\tif (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {\n\t\t\tif (!this._clickedEntities) this._clickedEntities = {};\n\t\t\tthis._selectEventsAttached = true;\n\t\t\tthis.app.xr.on('start', this._onXrStart, this);\n\t\t}\n\t}\n\n\tdetach() {\n\t\tif (!this._attached) return;\n\t\tthis._attached = false;\n\t\tconst opts = platform.passiveEvents ? {\n\t\t\tpassive: true\n\t\t} : false;\n\n\t\tif (this._useMouse) {\n\t\t\twindow.removeEventListener('mouseup', this._upHandler, opts);\n\t\t\twindow.removeEventListener('mousedown', this._downHandler, opts);\n\t\t\twindow.removeEventListener('mousemove', this._moveHandler, opts);\n\t\t\twindow.removeEventListener('wheel', this._wheelHandler, opts);\n\t\t}\n\n\t\tif (this._useTouch) {\n\t\t\tthis._target.removeEventListener('touchstart', this._touchstartHandler, opts);\n\n\t\t\tthis._target.removeEventListener('touchend', this._touchendHandler, false);\n\n\t\t\tthis._target.removeEventListener('touchmove', this._touchmoveHandler, false);\n\n\t\t\tthis._target.removeEventListener('touchcancel', this._touchcancelHandler, false);\n\t\t}\n\n\t\tif (this._selectEventsAttached) {\n\t\t\tthis._selectEventsAttached = false;\n\t\t\tthis.app.xr.off('start', this._onXrStart, this);\n\t\t\tthis.app.xr.off('end', this._onXrEnd, this);\n\t\t\tthis.app.xr.off('update', this._onXrUpdate, this);\n\t\t\tthis.app.xr.input.off('selectstart', this._onSelectStart, this);\n\t\t\tthis.app.xr.input.off('selectend', this._onSelectEnd, this);\n\t\t\tthis.app.xr.input.off('remove', this._onXrInputRemove, this);\n\t\t}\n\n\t\tthis._target = null;\n\t}\n\n\taddElement(element) {\n\t\tif (this._elements.indexOf(element) === -1) this._elements.push(element);\n\t}\n\n\tremoveElement(element) {\n\t\tconst idx = this._elements.indexOf(element);\n\n\t\tif (idx !== -1) this._elements.splice(idx, 1);\n\t}\n\n\t_handleUp(event) {\n\t\tif (!this._enabled) return;\n\t\tif (Mouse.isPointerLocked()) return;\n\n\t\tthis._calcMouseCoords(event);\n\n\t\tif (targetX === null) return;\n\n\t\tthis._onElementMouseEvent('mouseup', event);\n\t}\n\n\t_handleDown(event) {\n\t\tif (!this._enabled) return;\n\t\tif (Mouse.isPointerLocked()) return;\n\n\t\tthis._calcMouseCoords(event);\n\n\t\tif (targetX === null) return;\n\n\t\tthis._onElementMouseEvent('mousedown', event);\n\t}\n\n\t_handleMove(event) {\n\t\tif (!this._enabled) return;\n\n\t\tthis._calcMouseCoords(event);\n\n\t\tif (targetX === null) return;\n\n\t\tthis._onElementMouseEvent('mousemove', event);\n\n\t\tthis._lastX = targetX;\n\t\tthis._lastY = targetY;\n\t}\n\n\t_handleWheel(event) {\n\t\tif (!this._enabled) return;\n\n\t\tthis._calcMouseCoords(event);\n\n\t\tif (targetX === null) return;\n\n\t\tthis._onElementMouseEvent('mousewheel', event);\n\t}\n\n\t_determineTouchedElements(event) {\n\t\tconst touchedElements = {};\n\t\tconst cameras = this.app.systems.camera.cameras;\n\n\t\tfor (let i = cameras.length - 1; i >= 0; i--) {\n\t\t\tconst camera = cameras[i];\n\t\t\tlet done = 0;\n\t\t\tconst len = event.changedTouches.length;\n\n\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\tif (touchedElements[event.changedTouches[j].identifier]) {\n\t\t\t\t\tdone++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst coords = this._calcTouchCoords(event.changedTouches[j]);\n\n\t\t\t\tconst element = this._getTargetElement(camera, coords.x, coords.y);\n\n\t\t\t\tif (element) {\n\t\t\t\t\tdone++;\n\t\t\t\t\ttouchedElements[event.changedTouches[j].identifier] = {\n\t\t\t\t\t\telement: element,\n\t\t\t\t\t\tcamera: camera,\n\t\t\t\t\t\tx: coords.x,\n\t\t\t\t\t\ty: coords.y\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (done === len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn touchedElements;\n\t}\n\n\t_handleTouchStart(event) {\n\t\tif (!this._enabled) return;\n\n\t\tconst newTouchedElements = this._determineTouchedElements(event);\n\n\t\tfor (let i = 0, len = event.changedTouches.length; i < len; i++) {\n\t\t\tconst touch = event.changedTouches[i];\n\t\t\tconst newTouchInfo = newTouchedElements[touch.identifier];\n\t\t\tconst oldTouchInfo = this._touchedElements[touch.identifier];\n\n\t\t\tif (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {\n\t\t\t\tthis._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));\n\n\t\t\t\tthis._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const touchId in newTouchedElements) {\n\t\t\tthis._touchedElements[touchId] = newTouchedElements[touchId];\n\t\t}\n\t}\n\n\t_handleTouchEnd(event) {\n\t\tif (!this._enabled) return;\n\t\tconst cameras = this.app.systems.camera.cameras;\n\n\t\tfor (const key in this._clickedEntities) {\n\t\t\tdelete this._clickedEntities[key];\n\t\t}\n\n\t\tfor (let i = 0, len = event.changedTouches.length; i < len; i++) {\n\t\t\tconst touch = event.changedTouches[i];\n\t\t\tconst touchInfo = this._touchedElements[touch.identifier];\n\t\t\tif (!touchInfo) continue;\n\t\t\tconst element = touchInfo.element;\n\t\t\tconst camera = touchInfo.camera;\n\t\t\tconst x = touchInfo.x;\n\t\t\tconst y = touchInfo.y;\n\t\t\tdelete this._touchedElements[touch.identifier];\n\t\t\tdelete this._touchesForWhichTouchLeaveHasFired[touch.identifier];\n\n\t\t\tthis._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));\n\n\t\t\tif (event.touches.length === 0) {\n\t\t\t\tconst coords = this._calcTouchCoords(touch);\n\n\t\t\t\tfor (let c = cameras.length - 1; c >= 0; c--) {\n\t\t\t\t\tconst hovered = this._getTargetElement(cameras[c], coords.x, coords.y);\n\n\t\t\t\t\tif (hovered === element) {\n\t\t\t\t\t\tif (!this._clickedEntities[element.entity.getGuid()]) {\n\t\t\t\t\t\t\tthis._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));\n\n\t\t\t\t\t\t\tthis._clickedEntities[element.entity.getGuid()] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_handleTouchMove(event) {\n\t\tevent.preventDefault();\n\t\tif (!this._enabled) return;\n\n\t\tconst newTouchedElements = this._determineTouchedElements(event);\n\n\t\tfor (let i = 0, len = event.changedTouches.length; i < len; i++) {\n\t\t\tconst touch = event.changedTouches[i];\n\t\t\tconst newTouchInfo = newTouchedElements[touch.identifier];\n\t\t\tconst oldTouchInfo = this._touchedElements[touch.identifier];\n\n\t\t\tif (oldTouchInfo) {\n\t\t\t\tconst coords = this._calcTouchCoords(touch);\n\n\t\t\t\tif ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {\n\t\t\t\t\tthis._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));\n\n\t\t\t\t\tthis._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;\n\t\t\t\t}\n\n\t\t\t\tthis._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));\n\t\t\t}\n\t\t}\n\t}\n\n\t_onElementMouseEvent(eventType, event) {\n\t\tlet element;\n\t\tconst hovered = this._hoveredElement;\n\t\tthis._hoveredElement = null;\n\t\tconst cameras = this.app.systems.camera.cameras;\n\t\tlet camera;\n\n\t\tfor (let i = cameras.length - 1; i >= 0; i--) {\n\t\t\tcamera = cameras[i];\n\t\t\telement = this._getTargetElement(camera, targetX, targetY);\n\t\t\tif (element) break;\n\t\t}\n\n\t\tif (element) {\n\t\t\tthis._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));\n\n\t\t\tthis._hoveredElement = element;\n\n\t\t\tif (eventType === 'mousedown') {\n\t\t\t\tthis._pressedElement = element;\n\t\t\t}\n\t\t}\n\n\t\tif (hovered !== this._hoveredElement) {\n\t\t\tif (hovered) {\n\t\t\t\tthis._fireEvent('mouseleave', new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));\n\t\t\t}\n\n\t\t\tif (this._hoveredElement) {\n\t\t\t\tthis._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));\n\t\t\t}\n\t\t}\n\n\t\tif (eventType === 'mouseup' && this._pressedElement) {\n\t\t\tif (this._pressedElement === this._hoveredElement) {\n\t\t\t\tthis._pressedElement = null;\n\n\t\t\t\tif (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {\n\t\t\t\t\tthis._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._pressedElement = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onXrStart() {\n\t\tthis.app.xr.on('end', this._onXrEnd, this);\n\t\tthis.app.xr.on('update', this._onXrUpdate, this);\n\t\tthis.app.xr.input.on('selectstart', this._onSelectStart, this);\n\t\tthis.app.xr.input.on('selectend', this._onSelectEnd, this);\n\t\tthis.app.xr.input.on('remove', this._onXrInputRemove, this);\n\t}\n\n\t_onXrEnd() {\n\t\tthis.app.xr.off('update', this._onXrUpdate, this);\n\t\tthis.app.xr.input.off('selectstart', this._onSelectStart, this);\n\t\tthis.app.xr.input.off('selectend', this._onSelectEnd, this);\n\t\tthis.app.xr.input.off('remove', this._onXrInputRemove, this);\n\t}\n\n\t_onXrUpdate() {\n\t\tif (!this._enabled) return;\n\t\tconst inputSources = this.app.xr.input.inputSources;\n\n\t\tfor (let i = 0; i < inputSources.length; i++) {\n\t\t\tthis._onElementSelectEvent('selectmove', inputSources[i], null);\n\t\t}\n\t}\n\n\t_onXrInputRemove(inputSource) {\n\t\tconst hovered = this._selectedElements[inputSource.id];\n\n\t\tif (hovered) {\n\t\t\tinputSource._elementEntity = null;\n\n\t\t\tthis._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));\n\t\t}\n\n\t\tdelete this._selectedElements[inputSource.id];\n\t\tdelete this._selectedPressedElements[inputSource.id];\n\t}\n\n\t_onSelectStart(inputSource, event) {\n\t\tif (!this._enabled) return;\n\n\t\tthis._onElementSelectEvent('selectstart', inputSource, event);\n\t}\n\n\t_onSelectEnd(inputSource, event) {\n\t\tif (!this._enabled) return;\n\n\t\tthis._onElementSelectEvent('selectend', inputSource, event);\n\t}\n\n\t_onElementSelectEvent(eventType, inputSource, event) {\n\t\tlet element;\n\t\tconst hoveredBefore = this._selectedElements[inputSource.id];\n\t\tlet hoveredNow;\n\t\tconst cameras = this.app.systems.camera.cameras;\n\t\tlet camera;\n\n\t\tif (inputSource.elementInput) {\n\t\t\trayC.set(inputSource.getOrigin(), inputSource.getDirection());\n\n\t\t\tfor (let i = cameras.length - 1; i >= 0; i--) {\n\t\t\t\tcamera = cameras[i];\n\t\t\t\telement = this._getTargetElementByRay(rayC, camera);\n\t\t\t\tif (element) break;\n\t\t\t}\n\t\t}\n\n\t\tinputSource._elementEntity = element || null;\n\n\t\tif (element) {\n\t\t\tthis._selectedElements[inputSource.id] = element;\n\t\t\thoveredNow = element;\n\t\t} else {\n\t\t\tdelete this._selectedElements[inputSource.id];\n\t\t}\n\n\t\tif (hoveredBefore !== hoveredNow) {\n\t\t\tif (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n\t\t\tif (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));\n\t\t}\n\n\t\tif (eventType === 'selectstart') {\n\t\t\tthis._selectedPressedElements[inputSource.id] = hoveredNow;\n\t\t\tif (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));\n\t\t}\n\n\t\tconst pressed = this._selectedPressedElements[inputSource.id];\n\n\t\tif (!inputSource.elementInput && pressed) {\n\t\t\tdelete this._selectedPressedElements[inputSource.id];\n\t\t\tif (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n\t\t}\n\n\t\tif (eventType === 'selectend' && inputSource.elementInput) {\n\t\t\tdelete this._selectedPressedElements[inputSource.id];\n\t\t\tif (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n\n\t\t\tif (pressed && pressed === hoveredBefore) {\n\t\t\t\tthis._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));\n\t\t\t}\n\t\t}\n\t}\n\n\t_fireEvent(name, evt) {\n\t\tlet element = evt.element;\n\n\t\twhile (true) {\n\t\t\telement.fire(name, evt);\n\t\t\tif (evt._stopPropagation) break;\n\t\t\tif (!element.entity.parent) break;\n\t\t\telement = element.entity.parent.element;\n\t\t\tif (!element) break;\n\t\t}\n\t}\n\n\t_calcMouseCoords(event) {\n\t\tconst rect = this._target.getBoundingClientRect();\n\n\t\tconst left = Math.floor(rect.left);\n\t\tconst top = Math.floor(rect.top);\n\n\t\tif (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {\n\t\t\ttargetX = null;\n\t\t\ttargetY = null;\n\t\t} else {\n\t\t\ttargetX = event.clientX - left;\n\t\t\ttargetY = event.clientY - top;\n\t\t}\n\t}\n\n\t_calcTouchCoords(touch) {\n\t\tlet totalOffsetX = 0;\n\t\tlet totalOffsetY = 0;\n\t\tlet target = touch.target;\n\n\t\twhile (!(target instanceof HTMLElement)) {\n\t\t\ttarget = target.parentNode;\n\t\t}\n\n\t\tlet currentElement = target;\n\n\t\tdo {\n\t\t\ttotalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;\n\t\t\ttotalOffsetY += currentElement.offsetTop - currentElement.scrollTop;\n\t\t\tcurrentElement = currentElement.offsetParent;\n\t\t} while (currentElement);\n\n\t\treturn {\n\t\t\tx: touch.pageX - totalOffsetX,\n\t\t\ty: touch.pageY - totalOffsetY\n\t\t};\n\t}\n\n\t_sortElements(a, b) {\n\t\tconst layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);\n\t\tif (layerOrder !== 0) return layerOrder;\n\t\tif (a.screen && !b.screen) return -1;\n\t\tif (!a.screen && b.screen) return 1;\n\t\tif (!a.screen && !b.screen) return 0;\n\t\tif (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) return -1;\n\t\tif (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) return 1;\n\t\treturn b.drawOrder - a.drawOrder;\n\t}\n\n\t_getTargetElement(camera, x, y) {\n\t\tlet result = null;\n\t\tlet closestDistance3d = Infinity;\n\n\t\tthis._elements.sort(this._sortHandler);\n\n\t\tlet rayScreen, ray3d;\n\n\t\tfor (let i = 0, len = this._elements.length; i < len; i++) {\n\t\t\tconst element = this._elements[i];\n\n\t\t\tif (element.screen && element.screen.screen.screenSpace) {\n\t\t\t\tif (rayScreen === undefined) {\n\t\t\t\t\trayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;\n\t\t\t\t}\n\n\t\t\t\tif (!rayScreen) continue;\n\n\t\t\t\tconst currentDistance = this._checkElement(rayScreen, element, true);\n\n\t\t\t\tif (currentDistance >= 0) {\n\t\t\t\t\tresult = element;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ray3d === undefined) {\n\t\t\t\t\tray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;\n\t\t\t\t}\n\n\t\t\t\tif (!ray3d) continue;\n\n\t\t\t\tconst currentDistance = this._checkElement(ray3d, element, false);\n\n\t\t\t\tif (currentDistance >= 0) {\n\t\t\t\t\tif (currentDistance < closestDistance3d) {\n\t\t\t\t\t\tresult = element;\n\t\t\t\t\t\tclosestDistance3d = currentDistance;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.screen) {\n\t\t\t\t\t\tresult = element;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_getTargetElementByRay(ray, camera) {\n\t\tlet result = null;\n\t\trayA.origin.copy(ray.origin);\n\t\trayA.direction.copy(ray.direction);\n\t\trayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);\n\n\t\tthis._elements.sort(this._sortHandler);\n\n\t\tfor (let i = 0, len = this._elements.length; i < len; i++) {\n\t\t\tconst element = this._elements[i];\n\n\t\t\tif (!element.screen || !element.screen.screen.screenSpace) {\n\t\t\t\tif (this._checkElement(rayA, element, false) >= 0) {\n\t\t\t\t\tresult = element;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_buildHitCorners(element, screenOrWorldCorners, scaleX, scaleY, scaleZ) {\n\t\tlet hitCorners = screenOrWorldCorners;\n\t\tconst button = element.entity && element.entity.button;\n\n\t\tif (button) {\n\t\t\tconst hitPadding = element.entity.button.hitPadding || ZERO_VEC4;\n\n\t\t\t_paddingTop.copy(element.entity.up);\n\n\t\t\t_paddingBottom.copy(_paddingTop).mulScalar(-1);\n\n\t\t\t_paddingRight.copy(element.entity.right);\n\n\t\t\t_paddingLeft.copy(_paddingRight).mulScalar(-1);\n\n\t\t\t_paddingTop.mulScalar(hitPadding.w * scaleY);\n\n\t\t\t_paddingBottom.mulScalar(hitPadding.y * scaleY);\n\n\t\t\t_paddingRight.mulScalar(hitPadding.z * scaleX);\n\n\t\t\t_paddingLeft.mulScalar(hitPadding.x * scaleX);\n\n\t\t\t_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);\n\n\t\t\t_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);\n\n\t\t\t_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);\n\n\t\t\t_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);\n\n\t\t\thitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];\n\t\t}\n\n\t\tif (scaleX < 0) {\n\t\t\tconst left = hitCorners[2].x;\n\t\t\tconst right = hitCorners[0].x;\n\t\t\thitCorners[0].x = left;\n\t\t\thitCorners[1].x = right;\n\t\t\thitCorners[2].x = right;\n\t\t\thitCorners[3].x = left;\n\t\t}\n\n\t\tif (scaleY < 0) {\n\t\t\tconst bottom = hitCorners[2].y;\n\t\t\tconst top = hitCorners[0].y;\n\t\t\thitCorners[0].y = bottom;\n\t\t\thitCorners[1].y = bottom;\n\t\t\thitCorners[2].y = top;\n\t\t\thitCorners[3].y = top;\n\t\t}\n\n\t\tif (scaleZ < 0) {\n\t\t\tconst x = hitCorners[2].x;\n\t\t\tconst y = hitCorners[2].y;\n\t\t\tconst z = hitCorners[2].z;\n\t\t\thitCorners[2].x = hitCorners[0].x;\n\t\t\thitCorners[2].y = hitCorners[0].y;\n\t\t\thitCorners[2].z = hitCorners[0].z;\n\t\t\thitCorners[0].x = x;\n\t\t\thitCorners[0].y = y;\n\t\t\thitCorners[0].z = z;\n\t\t}\n\n\t\treturn hitCorners;\n\t}\n\n\t_calculateScaleToScreen(element) {\n\t\tlet current = element.entity;\n\t\tconst screenScale = element.screen.screen.scale;\n\n\t\t_accumulatedScale.set(screenScale, screenScale, screenScale);\n\n\t\twhile (current && !current.screen) {\n\t\t\t_accumulatedScale.mul(current.getLocalScale());\n\n\t\t\tcurrent = current.parent;\n\t\t}\n\n\t\treturn _accumulatedScale;\n\t}\n\n\t_calculateScaleToWorld(element) {\n\t\tlet current = element.entity;\n\n\t\t_accumulatedScale.set(1, 1, 1);\n\n\t\twhile (current) {\n\t\t\t_accumulatedScale.mul(current.getLocalScale());\n\n\t\t\tcurrent = current.parent;\n\t\t}\n\n\t\treturn _accumulatedScale;\n\t}\n\n\t_calculateRayScreen(x, y, camera, ray) {\n\t\tconst sw = this.app.graphicsDevice.width;\n\t\tconst sh = this.app.graphicsDevice.height;\n\t\tconst cameraWidth = camera.rect.z * sw;\n\t\tconst cameraHeight = camera.rect.w * sh;\n\t\tconst cameraLeft = camera.rect.x * sw;\n\t\tconst cameraRight = cameraLeft + cameraWidth;\n\t\tconst cameraBottom = (1 - camera.rect.y) * sh;\n\t\tconst cameraTop = cameraBottom - cameraHeight;\n\n\t\tlet _x = x * sw / this._target.clientWidth;\n\n\t\tlet _y = y * sh / this._target.clientHeight;\n\n\t\tif (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {\n\t\t\t_x = sw * (_x - cameraLeft) / cameraWidth;\n\t\t\t_y = sh * (_y - cameraTop) / cameraHeight;\n\t\t\t_y = sh - _y;\n\t\t\tray.origin.set(_x, _y, 1);\n\t\t\tray.direction.set(0, 0, -1);\n\t\t\tray.end.copy(ray.direction).mulScalar(2).add(ray.origin);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_calculateRay3d(x, y, camera, ray) {\n\t\tconst sw = this._target.clientWidth;\n\t\tconst sh = this._target.clientHeight;\n\t\tconst cameraWidth = camera.rect.z * sw;\n\t\tconst cameraHeight = camera.rect.w * sh;\n\t\tconst cameraLeft = camera.rect.x * sw;\n\t\tconst cameraRight = cameraLeft + cameraWidth;\n\t\tconst cameraBottom = (1 - camera.rect.y) * sh;\n\t\tconst cameraTop = cameraBottom - cameraHeight;\n\t\tlet _x = x;\n\t\tlet _y = y;\n\n\t\tif (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {\n\t\t\t_x = sw * (_x - cameraLeft) / cameraWidth;\n\t\t\t_y = sh * (_y - cameraTop) / cameraHeight;\n\t\t\tcamera.screenToWorld(_x, _y, camera.nearClip, vecA);\n\t\t\tcamera.screenToWorld(_x, _y, camera.farClip, vecB);\n\t\t\tray.origin.copy(vecA);\n\t\t\tray.direction.set(0, 0, -1);\n\t\t\tray.end.copy(vecB);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_checkElement(ray, element, screen) {\n\t\tif (element.maskedBy) {\n\t\t\tif (this._checkElement(ray, element.maskedBy.element, screen) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tlet scale;\n\n\t\tif (screen) {\n\t\t\tscale = this._calculateScaleToScreen(element);\n\t\t} else {\n\t\t\tscale = this._calculateScaleToWorld(element);\n\t\t}\n\n\t\tconst corners = this._buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale.x, scale.y, scale.z);\n\n\t\treturn intersectLineQuad(ray.origin, ray.end, corners);\n\t}\n\n}\n\nconst MAPS = {\n\tDEFAULT: {\n\t\tbuttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],\n\t\taxes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']\n\t},\n\tPS3: {\n\t\tbuttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_4', 'PAD_FACE_3', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],\n\t\taxes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']\n\t}\n};\nconst PRODUCT_CODES = {\n\t'Product: 0268': 'PS3'\n};\n\nclass GamePads {\n\tconstructor() {\n\t\tthis.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;\n\t\tthis.current = [];\n\t\tthis.previous = [];\n\t\tthis.deadZone = 0.25;\n\t}\n\n\tupdate() {\n\t\tfor (let i = 0, l = this.current.length; i < l; i++) {\n\t\t\tconst buttons = this.current[i].pad.buttons;\n\t\t\tconst buttonsLen = buttons.length;\n\n\t\t\tfor (let j = 0; j < buttonsLen; j++) {\n\t\t\t\tif (this.previous[i] === undefined) {\n\t\t\t\t\tthis.previous[i] = [];\n\t\t\t\t}\n\n\t\t\t\tthis.previous[i][j] = buttons[j].pressed;\n\t\t\t}\n\t\t}\n\n\t\tthis.poll(this.current);\n\t}\n\n\tpoll(pads = []) {\n\t\tif (pads.length > 0) {\n\t\t\tpads.length = 0;\n\t\t}\n\n\t\tif (this.gamepadsSupported) {\n\t\t\tconst padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();\n\n\t\t\tfor (let i = 0, len = padDevices.length; i < len; i++) {\n\t\t\t\tif (padDevices[i]) {\n\t\t\t\t\tpads.push({\n\t\t\t\t\t\tmap: this.getMap(padDevices[i]),\n\t\t\t\t\t\tpad: padDevices[i]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pads;\n\t}\n\n\tgetMap(pad) {\n\t\tfor (const code in PRODUCT_CODES) {\n\t\t\tif (pad.id.indexOf(code) >= 0) {\n\t\t\t\treturn MAPS[PRODUCT_CODES[code]];\n\t\t\t}\n\t\t}\n\n\t\treturn MAPS.DEFAULT;\n\t}\n\n\tisPressed(index, button) {\n\t\tif (!this.current[index]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst key = this.current[index].map.buttons[button];\n\t\treturn this.current[index].pad.buttons[pc[key]].pressed;\n\t}\n\n\twasPressed(index, button) {\n\t\tif (!this.current[index]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst key = this.current[index].map.buttons[button];\n\t\tconst i = pc[key];\n\t\treturn this.current[index].pad.buttons[i].pressed && !(this.previous[index] && this.previous[index][i]);\n\t}\n\n\twasReleased(index, button) {\n\t\tif (!this.current[index]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst key = this.current[index].map.buttons[button];\n\t\tconst i = pc[key];\n\t\treturn !this.current[index].pad.buttons[i].pressed && this.previous[index] && this.previous[index][i];\n\t}\n\n\tgetAxis(index, axes) {\n\t\tif (!this.current[index]) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst key = this.current[index].map.axes[axes];\n\t\tlet value = this.current[index].pad.axes[pc[key]];\n\n\t\tif (Math.abs(value) < this.deadZone) {\n\t\t\tvalue = 0;\n\t\t}\n\n\t\treturn value;\n\t}\n\n}\n\nfunction getTouchTargetCoords(touch) {\n\tlet totalOffsetX = 0;\n\tlet totalOffsetY = 0;\n\tlet target = touch.target;\n\n\twhile (!(target instanceof HTMLElement)) {\n\t\ttarget = target.parentNode;\n\t}\n\n\tlet currentElement = target;\n\n\tdo {\n\t\ttotalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;\n\t\ttotalOffsetY += currentElement.offsetTop - currentElement.scrollTop;\n\t\tcurrentElement = currentElement.offsetParent;\n\t} while (currentElement);\n\n\treturn {\n\t\tx: touch.pageX - totalOffsetX,\n\t\ty: touch.pageY - totalOffsetY\n\t};\n}\n\nclass Touch {\n\tconstructor(touch) {\n\t\tconst coords = getTouchTargetCoords(touch);\n\t\tthis.id = touch.identifier;\n\t\tthis.x = coords.x;\n\t\tthis.y = coords.y;\n\t\tthis.target = touch.target;\n\t\tthis.touch = touch;\n\t}\n\n}\n\nclass TouchEvent {\n\tconstructor(device, event) {\n\t\tthis.element = event.target;\n\t\tthis.event = event;\n\t\tthis.touches = [];\n\t\tthis.changedTouches = [];\n\n\t\tif (event) {\n\t\t\tfor (let i = 0, l = event.touches.length; i < l; i++) {\n\t\t\t\tthis.touches.push(new Touch(event.touches[i]));\n\t\t\t}\n\n\t\t\tfor (let i = 0, l = event.changedTouches.length; i < l; i++) {\n\t\t\t\tthis.changedTouches.push(new Touch(event.changedTouches[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\tgetTouchById(id, list) {\n\t\tfor (let i = 0, l = list.length; i < l; i++) {\n\t\t\tif (list[i].id === id) {\n\t\t\t\treturn list[i];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n\nclass TouchDevice extends EventHandler {\n\tconstructor(element) {\n\t\tsuper();\n\t\tthis._element = null;\n\t\tthis._startHandler = this._handleTouchStart.bind(this);\n\t\tthis._endHandler = this._handleTouchEnd.bind(this);\n\t\tthis._moveHandler = this._handleTouchMove.bind(this);\n\t\tthis._cancelHandler = this._handleTouchCancel.bind(this);\n\t\tthis.attach(element);\n\t}\n\n\tattach(element) {\n\t\tif (this._element) {\n\t\t\tthis.detach();\n\t\t}\n\n\t\tthis._element = element;\n\n\t\tthis._element.addEventListener('touchstart', this._startHandler, false);\n\n\t\tthis._element.addEventListener('touchend', this._endHandler, false);\n\n\t\tthis._element.addEventListener('touchmove', this._moveHandler, false);\n\n\t\tthis._element.addEventListener('touchcancel', this._cancelHandler, false);\n\t}\n\n\tdetach() {\n\t\tif (this._element) {\n\t\t\tthis._element.removeEventListener('touchstart', this._startHandler, false);\n\n\t\t\tthis._element.removeEventListener('touchend', this._endHandler, false);\n\n\t\t\tthis._element.removeEventListener('touchmove', this._moveHandler, false);\n\n\t\t\tthis._element.removeEventListener('touchcancel', this._cancelHandler, false);\n\t\t}\n\n\t\tthis._element = null;\n\t}\n\n\t_handleTouchStart(e) {\n\t\tthis.fire('touchstart', new TouchEvent(this, e));\n\t}\n\n\t_handleTouchEnd(e) {\n\t\tthis.fire('touchend', new TouchEvent(this, e));\n\t}\n\n\t_handleTouchMove(e) {\n\t\te.preventDefault();\n\t\tthis.fire('touchmove', new TouchEvent(this, e));\n\t}\n\n\t_handleTouchCancel(e) {\n\t\tthis.fire('touchcancel', new TouchEvent(this, e));\n\t}\n\n}\n\nconst log = {\n\twrite: function (text) {\n\t\tconsole.log(text);\n\t},\n\topen: function () {\n\t\tlog.write(\"Powered by PlayCanvas \" + version + \" \" + revision);\n\t},\n\tinfo: function (text) {\n\t\tconsole.info(\"INFO:\t\t\" + text);\n\t},\n\tdebug: function (text) {\n\t\tconsole.debug(\"DEBUG:\t \" + text);\n\t},\n\terror: function (text) {\n\t\tconsole.error(\"ERROR:\t \" + text);\n\t},\n\twarning: function (text) {\n\t\tconsole.warn(\"WARNING: \" + text);\n\t},\n\talert: function (text) {\n\t\tlog.write(\"ALERT:\t \" + text);\n\t\talert(text);\n\t},\n\tassert: function (condition, text) {\n\t\tif (condition === false) {\n\t\t\tlog.write(\"ASSERT:\t\" + text);\n\t\t}\n\t}\n};\n\nstring.endsWith = function (s, subs) {\n\treturn s.endsWith(subs);\n};\n\nstring.startsWith = function (s, subs) {\n\treturn s.startsWith(subs);\n};\n\nconst time = {\n\tnow: now,\n\tTimer: Timer\n};\nObject.defineProperty(Color.prototype, \"data\", {\n\tget: function () {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Float32Array(4);\n\t\t}\n\n\t\tthis._data[0] = this.r;\n\t\tthis._data[1] = this.g;\n\t\tthis._data[2] = this.b;\n\t\tthis._data[3] = this.a;\n\t\treturn this._data;\n\t}\n});\nObject.defineProperty(Color.prototype, \"data3\", {\n\tget: function () {\n\t\tif (!this._data3) {\n\t\t\tthis._data3 = new Float32Array(3);\n\t\t}\n\n\t\tthis._data3[0] = this.r;\n\t\tthis._data3[1] = this.g;\n\t\tthis._data3[2] = this.b;\n\t\treturn this._data3;\n\t}\n});\nfunction inherits(Self, Super) {\n\tconst Temp = function Temp() {};\n\n\tconst Func = function Func(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n\t\tSuper.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n\t\tSelf.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n\t};\n\n\tFunc._super = Super.prototype;\n\tTemp.prototype = Super.prototype;\n\tFunc.prototype = new Temp();\n\treturn Func;\n}\nfunction makeArray(arr) {\n\treturn Array.prototype.slice.call(arr);\n}\nmath.INV_LOG2 = Math.LOG2E;\nmath.intToBytes = math.intToBytes32;\nmath.bytesToInt = math.bytesToInt32;\nObject.defineProperty(Vec2.prototype, \"data\", {\n\tget: function () {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Float32Array(2);\n\t\t}\n\n\t\tthis._data[0] = this.x;\n\t\tthis._data[1] = this.y;\n\t\treturn this._data;\n\t}\n});\nVec2.prototype.scale = Vec2.prototype.mulScalar;\nObject.defineProperty(Vec3.prototype, \"data\", {\n\tget: function () {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Float32Array(3);\n\t\t}\n\n\t\tthis._data[0] = this.x;\n\t\tthis._data[1] = this.y;\n\t\tthis._data[2] = this.z;\n\t\treturn this._data;\n\t}\n});\nVec3.prototype.scale = Vec3.prototype.mulScalar;\nObject.defineProperty(Vec4.prototype, \"data\", {\n\tget: function () {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Float32Array(4);\n\t\t}\n\n\t\tthis._data[0] = this.x;\n\t\tthis._data[1] = this.y;\n\t\tthis._data[2] = this.z;\n\t\tthis._data[3] = this.w;\n\t\treturn this._data;\n\t}\n});\nVec4.prototype.scale = Vec4.prototype.mulScalar;\nconst shape = {\n\tAabb: BoundingBox,\n\tSphere: BoundingSphere,\n\tPlane: Plane\n};\nBoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;\n\nFrustum.prototype.update = function (projectionMatrix, viewMatrix) {\n\tconst viewProj = new Mat4();\n\tviewProj.mul2(projectionMatrix, viewMatrix);\n\tthis.setFromMat4(viewProj);\n};\n\nconst ELEMENTTYPE_INT8 = TYPE_INT8;\nconst ELEMENTTYPE_UINT8 = TYPE_UINT8;\nconst ELEMENTTYPE_INT16 = TYPE_INT16;\nconst ELEMENTTYPE_UINT16 = TYPE_UINT16;\nconst ELEMENTTYPE_INT32 = TYPE_INT32;\nconst ELEMENTTYPE_UINT32 = TYPE_UINT32;\nconst ELEMENTTYPE_FLOAT32 = TYPE_FLOAT32;\nfunction UnsupportedBrowserError(message) {\n\tthis.name = \"UnsupportedBrowserError\";\n\tthis.message = message || \"\";\n}\nUnsupportedBrowserError.prototype = Error.prototype;\nfunction ContextCreationError(message) {\n\tthis.name = \"ContextCreationError\";\n\tthis.message = message || \"\";\n}\nContextCreationError.prototype = Error.prototype;\nconst gfx = {\n\tADDRESS_CLAMP_TO_EDGE: ADDRESS_CLAMP_TO_EDGE,\n\tADDRESS_MIRRORED_REPEAT: ADDRESS_MIRRORED_REPEAT,\n\tADDRESS_REPEAT: ADDRESS_REPEAT,\n\tBLENDMODE_ZERO: BLENDMODE_ZERO,\n\tBLENDMODE_ONE: BLENDMODE_ONE,\n\tBLENDMODE_SRC_COLOR: BLENDMODE_SRC_COLOR,\n\tBLENDMODE_ONE_MINUS_SRC_COLOR: BLENDMODE_ONE_MINUS_SRC_COLOR,\n\tBLENDMODE_DST_COLOR: BLENDMODE_DST_COLOR,\n\tBLENDMODE_ONE_MINUS_DST_COLOR: BLENDMODE_ONE_MINUS_DST_COLOR,\n\tBLENDMODE_SRC_ALPHA: BLENDMODE_SRC_ALPHA,\n\tBLENDMODE_SRC_ALPHA_SATURATE: BLENDMODE_SRC_ALPHA_SATURATE,\n\tBLENDMODE_ONE_MINUS_SRC_ALPHA: BLENDMODE_ONE_MINUS_SRC_ALPHA,\n\tBLENDMODE_DST_ALPHA: BLENDMODE_DST_ALPHA,\n\tBLENDMODE_ONE_MINUS_DST_ALPHA: BLENDMODE_ONE_MINUS_DST_ALPHA,\n\tBUFFER_STATIC: BUFFER_STATIC,\n\tBUFFER_DYNAMIC: BUFFER_DYNAMIC,\n\tBUFFER_STREAM: BUFFER_STREAM,\n\tCULLFACE_NONE: CULLFACE_NONE,\n\tCULLFACE_BACK: CULLFACE_BACK,\n\tCULLFACE_FRONT: CULLFACE_FRONT,\n\tCULLFACE_FRONTANDBACK: CULLFACE_FRONTANDBACK,\n\tELEMENTTYPE_INT8: TYPE_INT8,\n\tELEMENTTYPE_UINT8: TYPE_UINT8,\n\tELEMENTTYPE_INT16: TYPE_INT16,\n\tELEMENTTYPE_UINT16: TYPE_UINT16,\n\tELEMENTTYPE_INT32: TYPE_INT32,\n\tELEMENTTYPE_UINT32: TYPE_UINT32,\n\tELEMENTTYPE_FLOAT32: TYPE_FLOAT32,\n\tFILTER_NEAREST: FILTER_NEAREST,\n\tFILTER_LINEAR: FILTER_LINEAR,\n\tFILTER_NEAREST_MIPMAP_NEAREST: FILTER_NEAREST_MIPMAP_NEAREST,\n\tFILTER_NEAREST_MIPMAP_LINEAR: FILTER_NEAREST_MIPMAP_LINEAR,\n\tFILTER_LINEAR_MIPMAP_NEAREST: FILTER_LINEAR_MIPMAP_NEAREST,\n\tFILTER_LINEAR_MIPMAP_LINEAR: FILTER_LINEAR_MIPMAP_LINEAR,\n\tINDEXFORMAT_UINT8: INDEXFORMAT_UINT8,\n\tINDEXFORMAT_UINT16: INDEXFORMAT_UINT16,\n\tINDEXFORMAT_UINT32: INDEXFORMAT_UINT32,\n\tPIXELFORMAT_R5_G6_B5: PIXELFORMAT_R5_G6_B5,\n\tPIXELFORMAT_R8_G8_B8: PIXELFORMAT_R8_G8_B8,\n\tPIXELFORMAT_R8_G8_B8_A8: PIXELFORMAT_R8_G8_B8_A8,\n\tPRIMITIVE_POINTS: PRIMITIVE_POINTS,\n\tPRIMITIVE_LINES: PRIMITIVE_LINES,\n\tPRIMITIVE_LINELOOP: PRIMITIVE_LINELOOP,\n\tPRIMITIVE_LINESTRIP: PRIMITIVE_LINESTRIP,\n\tPRIMITIVE_TRIANGLES: PRIMITIVE_TRIANGLES,\n\tPRIMITIVE_TRISTRIP: PRIMITIVE_TRISTRIP,\n\tPRIMITIVE_TRIFAN: PRIMITIVE_TRIFAN,\n\tSEMANTIC_POSITION: SEMANTIC_POSITION,\n\tSEMANTIC_NORMAL: SEMANTIC_NORMAL,\n\tSEMANTIC_COLOR: SEMANTIC_COLOR,\n\tSEMANTIC_TEXCOORD: SEMANTIC_TEXCOORD,\n\tSEMANTIC_TEXCOORD0: SEMANTIC_TEXCOORD0,\n\tSEMANTIC_TEXCOORD1: SEMANTIC_TEXCOORD1,\n\tSEMANTIC_ATTR0: SEMANTIC_ATTR0,\n\tSEMANTIC_ATTR1: SEMANTIC_ATTR1,\n\tSEMANTIC_ATTR2: SEMANTIC_ATTR2,\n\tSEMANTIC_ATTR3: SEMANTIC_ATTR3,\n\tTEXTURELOCK_READ: TEXTURELOCK_READ,\n\tTEXTURELOCK_WRITE: TEXTURELOCK_WRITE,\n\tdrawQuadWithShader: drawQuadWithShader,\n\tprogramlib: programlib,\n\tshaderChunks: shaderChunks,\n\tContextCreationError: ContextCreationError,\n\tDevice: GraphicsDevice,\n\tIndexBuffer: IndexBuffer,\n\tProgramLibrary: ProgramLibrary,\n\tRenderTarget: RenderTarget,\n\tScopeId: ScopeId,\n\tShader: Shader,\n\tShaderInput: ShaderInput,\n\tTexture: Texture,\n\tUnsupportedBrowserError: UnsupportedBrowserError,\n\tVertexBuffer: VertexBuffer,\n\tVertexFormat: VertexFormat,\n\tVertexIterator: VertexIterator\n};\nconst posteffect = {\n\tcreateFullscreenQuad: createFullscreenQuad,\n\tdrawFullscreenQuad: drawFullscreenQuad,\n\tPostEffect: PostEffect$1,\n\tPostEffectQueue: PostEffectQueue\n};\nObject.defineProperty(shaderChunks, \"transformSkinnedVS\", {\n\tget: function () {\n\t\treturn \"#define SKIN\\n\" + shaderChunks.transformVS;\n\t}\n});\nconst deprecatedChunks = {\n\t'ambientPrefilteredCube.frag': 'ambientEnv.frag',\n\t'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',\n\t'dpAtlasQuad.frag': null,\n\t'genParaboloid.frag': null,\n\t'prefilterCubemap.frag': null,\n\t'reflectionDpAtlas.frag': 'reflectionEnv.frag',\n\t'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',\n\t'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'\n};\nObject.keys(deprecatedChunks).forEach(chunkName => {\n\tdeprecatedChunks[chunkName];\n\tObject.defineProperty(shaderChunks, chunkName, {\n\t\tget: function () {\n\t\t\treturn null;\n\t\t},\n\t\tset: function () {}\n\t});\n});\nObject.defineProperties(Texture.prototype, {\n\trgbm: {\n\t\tget: function () {\n\t\t\treturn this.type === TEXTURETYPE_RGBM;\n\t\t},\n\t\tset: function (rgbm) {\n\t\t\tthis.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t}\n\t},\n\tswizzleGGGR: {\n\t\tget: function () {\n\t\t\treturn this.type === TEXTURETYPE_SWIZZLEGGGR;\n\t\t},\n\t\tset: function (swizzleGGGR) {\n\t\t\tthis.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;\n\t\t}\n\t}\n});\nconst PhongMaterial = StandardMaterial;\nconst scene = {\n\tpartitionSkin: partitionSkin,\n\tprocedural: {\n\t\tcalculateTangents: calculateTangents,\n\t\tcreateMesh: createMesh$1,\n\t\tcreateTorus: createTorus,\n\t\tcreateCylinder: createCylinder,\n\t\tcreateCapsule: createCapsule,\n\t\tcreateCone: createCone,\n\t\tcreateSphere: createSphere,\n\t\tcreatePlane: createPlane,\n\t\tcreateBox: createBox\n\t},\n\tBasicMaterial: BasicMaterial,\n\tCommand: Command,\n\tDepthMaterial: DepthMaterial,\n\tForwardRenderer: ForwardRenderer,\n\tGraphNode: GraphNode,\n\tMaterial: Material,\n\tMesh: Mesh,\n\tMeshInstance: MeshInstance,\n\tModel: Model,\n\tParticleEmitter: ParticleEmitter,\n\tPhongMaterial: StandardMaterial,\n\tPicker: Picker,\n\tProjection: {\n\t\tORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,\n\t\tPERSPECTIVE: PROJECTION_PERSPECTIVE\n\t},\n\tScene: Scene,\n\tSkin: Skin,\n\tSkinInstance: SkinInstance\n};\nObject.defineProperty(Scene.prototype, 'defaultMaterial', {\n\tget: function () {\n\t\treturn DefaultMaterial.get(getApplication().graphicsDevice);\n\t}\n});\n['128', '64', '32', '16', '8', '4'].forEach((size, index) => {\n\tObject.defineProperty(Scene.prototype, `skyboxPrefiltered${size}`, {\n\t\tget: function () {\n\t\t\treturn this._prefilteredCubemaps[index];\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._prefilteredCubemaps[index] = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t});\n});\nObject.defineProperty(Batch.prototype, 'model', {\n\tget: function () {\n\t\treturn null;\n\t}\n});\n\nMeshInstance.prototype.syncAabb = function () {};\n\nMorph.prototype.getTarget = function (index) {\n\treturn this.targets[index];\n};\n\nGraphNode.prototype._dirtify = function (local) {\n\tif (local) this._dirtifyLocal();else this._dirtifyWorld();\n};\n\nGraphNode.prototype.addLabel = function (label) {\n\tthis._labels[label] = true;\n};\n\nGraphNode.prototype.getLabels = function () {\n\treturn Object.keys(this._labels);\n};\n\nGraphNode.prototype.hasLabel = function (label) {\n\treturn !!this._labels[label];\n};\n\nGraphNode.prototype.removeLabel = function (label) {\n\tdelete this._labels[label];\n};\n\nGraphNode.prototype.findByLabel = function (label, results = []) {\n\tif (this.hasLabel(label)) {\n\t\tresults.push(this);\n\t}\n\n\tfor (let i = 0; i < this._children.length; ++i) {\n\t\tresults = this._children[i].findByLabel(label, results);\n\t}\n\n\treturn results;\n};\n\nGraphNode.prototype.getChildren = function () {\n\treturn this.children;\n};\n\nGraphNode.prototype.getName = function () {\n\treturn this.name;\n};\n\nGraphNode.prototype.getPath = function () {\n\treturn this.path;\n};\n\nGraphNode.prototype.getRoot = function () {\n\treturn this.root;\n};\n\nGraphNode.prototype.getParent = function () {\n\treturn this.parent;\n};\n\nGraphNode.prototype.setName = function (name) {\n\tthis.name = name;\n};\n\nMaterial.prototype.getName = function () {\n\treturn this.name;\n};\n\nMaterial.prototype.setName = function (name) {\n\tthis.name = name;\n};\n\nMaterial.prototype.getShader = function () {\n\treturn this.shader;\n};\n\nMaterial.prototype.setShader = function (shader) {\n\tthis.shader = shader;\n};\n\nfunction _defineAlias(newName, oldName) {\n\tObject.defineProperty(StandardMaterial.prototype, oldName, {\n\t\tget: function () {\n\t\t\treturn this[newName];\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis[newName] = value;\n\t\t}\n\t});\n}\n\n_defineAlias(\"diffuseTint\", \"diffuseMapTint\");\n\n_defineAlias(\"specularTint\", \"specularMapTint\");\n\n_defineAlias(\"emissiveTint\", \"emissiveMapTint\");\n\n_defineAlias(\"aoVertexColor\", \"aoMapVertexColor\");\n\n_defineAlias(\"diffuseVertexColor\", \"diffuseMapVertexColor\");\n\n_defineAlias(\"specularVertexColor\", \"specularMapVertexColor\");\n\n_defineAlias(\"emissiveVertexColor\", \"emissiveMapVertexColor\");\n\n_defineAlias(\"metalnessVertexColor\", \"metalnessMapVertexColor\");\n\n_defineAlias(\"glossVertexColor\", \"glossMapVertexColor\");\n\n_defineAlias(\"opacityVertexColor\", \"opacityMapVertexColor\");\n\n_defineAlias(\"lightVertexColor\", \"lightMapVertexColor\");\n\nconst anim = {\n\tAnimation: Animation,\n\tKey: Key,\n\tNode: Node,\n\tSkeleton: Skeleton\n};\n\nAnimation.prototype.getDuration = function () {\n\treturn this.duration;\n};\n\nAnimation.prototype.getName = function () {\n\treturn this.name;\n};\n\nAnimation.prototype.getNodes = function () {\n\treturn this.nodes;\n};\n\nAnimation.prototype.setDuration = function (duration) {\n\tthis.duration = duration;\n};\n\nAnimation.prototype.setName = function (name) {\n\tthis.name = name;\n};\n\nSkeleton.prototype.getAnimation = function () {\n\treturn this.animation;\n};\n\nSkeleton.prototype.getCurrentTime = function () {\n\treturn this.currentTime;\n};\n\nSkeleton.prototype.getLooping = function () {\n\treturn this.looping;\n};\n\nSkeleton.prototype.getNumNodes = function () {\n\treturn this.numNodes;\n};\n\nSkeleton.prototype.setAnimation = function (animation) {\n\tthis.animation = animation;\n};\n\nSkeleton.prototype.setCurrentTime = function (time) {\n\tthis.currentTime = time;\n};\n\nSkeleton.prototype.setLooping = function (looping) {\n\tthis.looping = looping;\n};\n\nconst audio = {\n\tAudioManager: SoundManager,\n\tChannel: Channel,\n\tChannel3d: Channel3d,\n\tListener: Listener,\n\tSound: Sound\n};\n\nSoundManager.prototype.getListener = function () {\n\treturn this.listener;\n};\n\nSoundManager.prototype.getVolume = function () {\n\treturn this.volume;\n};\n\nSoundManager.prototype.setVolume = function (volume) {\n\tthis.volume = volume;\n};\n\nconst asset = {\n\tASSET_ANIMATION: 'animation',\n\tASSET_AUDIO: 'audio',\n\tASSET_IMAGE: 'image',\n\tASSET_JSON: 'json',\n\tASSET_MODEL: 'model',\n\tASSET_MATERIAL: 'material',\n\tASSET_TEXT: 'text',\n\tASSET_TEXTURE: 'texture',\n\tASSET_CUBEMAP: 'cubemap',\n\tASSET_SCRIPT: 'script'\n};\n\nAssetRegistry.prototype.getAssetById = function (id) {\n\treturn this.get(id);\n};\n\nObject.defineProperty(XrInputSource.prototype, 'ray', {\n\tget: function () {\n\t\treturn this._rayLocal;\n\t}\n});\nObject.defineProperty(XrInputSource.prototype, 'position', {\n\tget: function () {\n\t\treturn this._localPosition;\n\t}\n});\nObject.defineProperty(XrInputSource.prototype, 'rotation', {\n\tget: function () {\n\t\treturn this._localRotation;\n\t}\n});\nconst input = {\n\tgetTouchTargetCoords: getTouchTargetCoords,\n\tController: Controller,\n\tGamePads: GamePads,\n\tKeyboard: Keyboard,\n\tKeyboardEvent: KeyboardEvent,\n\tMouse: Mouse,\n\tMouseEvent: MouseEvent,\n\tTouch: Touch,\n\tTouchDevice: TouchDevice,\n\tTouchEvent: TouchEvent\n};\nObject.defineProperty(ElementInput.prototype, 'wheel', {\n\tget: function () {\n\t\treturn this.wheelDelta * -2;\n\t}\n});\nObject.defineProperty(MouseEvent.prototype, 'wheel', {\n\tget: function () {\n\t\treturn this.wheelDelta * -2;\n\t}\n});\nconst RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;\nconst RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;\nconst RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;\nconst RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;\nconst RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;\nconst RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;\nconst RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;\nconst RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;\nconst RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;\nconst RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;\nconst RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;\nconst fw = {\n\tApplication: Application,\n\tComponent: Component,\n\tComponentSystem: ComponentSystem,\n\tEntity: Entity,\n\tFillMode: {\n\t\tNONE: FILLMODE_NONE,\n\t\tFILL_WINDOW: FILLMODE_FILL_WINDOW,\n\t\tKEEP_ASPECT: FILLMODE_KEEP_ASPECT\n\t},\n\tResolutionMode: {\n\t\tAUTO: RESOLUTION_AUTO,\n\t\tFIXED: RESOLUTION_FIXED\n\t}\n};\n\nApplication.prototype.isFullscreen = function () {\n\treturn !!document.fullscreenElement;\n};\n\nApplication.prototype.enableFullscreen = function (element, success, error) {\n\telement = element || this.graphicsDevice.canvas;\n\n\tconst s = function s() {\n\t\tsuccess();\n\t\tdocument.removeEventListener('fullscreenchange', s);\n\t};\n\n\tconst e = function e() {\n\t\terror();\n\t\tdocument.removeEventListener('fullscreenerror', e);\n\t};\n\n\tif (success) {\n\t\tdocument.addEventListener('fullscreenchange', s, false);\n\t}\n\n\tif (error) {\n\t\tdocument.addEventListener('fullscreenerror', e, false);\n\t}\n\n\tif (element.requestFullscreen) {\n\t\telement.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n\t} else {\n\t\terror();\n\t}\n};\n\nApplication.prototype.disableFullscreen = function (success) {\n\tconst s = function s() {\n\t\tsuccess();\n\t\tdocument.removeEventListener('fullscreenchange', s);\n\t};\n\n\tif (success) {\n\t\tdocument.addEventListener('fullscreenchange', s, false);\n\t}\n\n\tdocument.exitFullscreen();\n};\n\nApplication.prototype.getSceneUrl = function (name) {\n\tconst entry = this.scenes.find(name);\n\n\tif (entry) {\n\t\treturn entry.url;\n\t}\n\n\treturn null;\n};\n\nApplication.prototype.loadScene = function (url, callback) {\n\tthis.scenes.loadScene(url, callback);\n};\n\nApplication.prototype.loadSceneHierarchy = function (url, callback) {\n\tthis.scenes.loadSceneHierarchy(url, callback);\n};\n\nApplication.prototype.loadSceneSettings = function (url, callback) {\n\tthis.scenes.loadSceneSettings(url, callback);\n};\n\nApplication.prototype.renderMeshInstance = function (meshInstance, options) {\n\tconst layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;\n\tthis.scene.immediate.drawMesh(null, null, null, meshInstance, layer);\n};\n\nApplication.prototype.renderMesh = function (mesh, material, matrix, options) {\n\tconst layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;\n\tthis.scene.immediate.drawMesh(material, matrix, mesh, null, layer);\n};\n\nApplication.prototype._addLines = function (positions, colors, options) {\n\tconst layer = options && options.layer ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);\n\tconst depthTest = options && options.depthTest !== undefined ? options.depthTest : true;\n\tconst batch = this.scene.immediate.getBatch(layer, depthTest);\n\tbatch.addLines(positions, colors);\n};\n\nApplication.prototype.renderLine = function (start, end, color) {\n\tlet endColor = color;\n\tlet options;\n\tconst arg3 = arguments[3];\n\tconst arg4 = arguments[4];\n\n\tif (arg3 instanceof Color) {\n\t\tendColor = arg3;\n\n\t\tif (typeof arg4 === 'number') {\n\t\t\tif (arg4 === LINEBATCH_OVERLAY) {\n\t\t\t\toptions = {\n\t\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\t\tdepthTest: false\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\toptions = {\n\t\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\t\tdepthTest: true\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\toptions = arg4;\n\t\t}\n\t} else if (typeof arg3 === 'number') {\n\t\tendColor = color;\n\n\t\tif (arg3 === LINEBATCH_OVERLAY) {\n\t\t\toptions = {\n\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\tdepthTest: false\n\t\t\t};\n\t\t} else {\n\t\t\toptions = {\n\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\tdepthTest: true\n\t\t\t};\n\t\t}\n\t} else if (arg3) {\n\t\toptions = arg3;\n\t}\n\n\tthis._addLines([start, end], [color, endColor], options);\n};\n\nApplication.prototype.renderLines = function (position, color, options) {\n\tif (!options) {\n\t\toptions = {\n\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\tdepthTest: true\n\t\t};\n\t} else if (typeof options === 'number') {\n\t\tif (options === LINEBATCH_OVERLAY) {\n\t\t\toptions = {\n\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\tdepthTest: false\n\t\t\t};\n\t\t} else {\n\t\t\toptions = {\n\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\tdepthTest: true\n\t\t\t};\n\t\t}\n\t}\n\n\tconst multiColor = !!color.length;\n\n\tif (multiColor) {\n\t\tif (position.length !== color.length) {\n\t\t\tconsole.error(\"renderLines: position/color arrays have different lengths\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (position.length % 2 !== 0) {\n\t\tconsole.error(\"renderLines: array length is not divisible by 2\");\n\t\treturn;\n\t}\n\n\tthis._addLines(position, color, options);\n};\n\nObject.defineProperty(CameraComponent.prototype, \"node\", {\n\tget: function () {\n\t\treturn this.entity;\n\t}\n});\nObject.defineProperty(LightComponent.prototype, \"enable\", {\n\tget: function () {\n\t\treturn this.enabled;\n\t},\n\tset: function (value) {\n\t\tthis.enabled = value;\n\t}\n});\n\nModelComponent.prototype.setVisible = function (visible) {\n\tthis.enabled = visible;\n};\n\nObject.defineProperty(ModelComponent.prototype, \"aabb\", {\n\tget: function () {\n\t\treturn null;\n\t},\n\tset: function (type) {}\n});\nObject.defineProperty(RenderComponent.prototype, \"aabb\", {\n\tget: function () {\n\t\treturn null;\n\t},\n\tset: function (type) {}\n});\nObject.defineProperty(RigidBodyComponent.prototype, \"bodyType\", {\n\tget: function () {\n\t\treturn this.type;\n\t},\n\tset: function (type) {\n\t\tthis.type = type;\n\t}\n});\n\nRigidBodyComponent.prototype.syncBodyToEntity = function () {\n\tthis._updateDynamic();\n};\n\nRigidBodyComponentSystem.prototype.setGravity = function () {\n\tif (arguments.length === 1) {\n\t\tthis.gravity.copy(arguments[0]);\n\t} else {\n\t\tthis.gravity.set(arguments[0], arguments[1], arguments[2]);\n\t}\n};\n\nfunction basisSetDownloadConfig(glueUrl, wasmUrl, fallbackUrl) {\n\tbasisInitialize({\n\t\tglueUrl: glueUrl,\n\t\twasmUrl: wasmUrl,\n\t\tfallbackUrl: fallbackUrl,\n\t\tlazyInit: true\n\t});\n}\nfunction prefilterCubemap(options) {}\nclass AssetListLoader extends EventHandler {\n\tconstructor(assetList, assetRegistry) {\n\t\tsuper();\n\t\tthis._assets = [];\n\t\tthis._registry = assetRegistry;\n\t\tthis._loaded = false;\n\t\tthis._count = 0;\n\t\tthis._total = 0;\n\t\tthis._failed = [];\n\t\tthis._waitingAssets = [];\n\n\t\tif (assetList.length && assetList[0] instanceof Asset) {\n\t\t\tthis._assets = assetList;\n\t\t} else {\n\t\t\tfor (let i = 0; i < assetList.length; i++) {\n\t\t\t\tconst asset = assetRegistry.get(assetList[i]);\n\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis._assets.push(asset);\n\t\t\t\t} else {\n\t\t\t\t\tthis._waitForAsset(assetList[i]);\n\n\t\t\t\t\tthis._total++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._registry.off(\"load\", this._onLoad);\n\n\t\tthis._registry.off(\"error\", this._onError);\n\n\t\tthis._waitingAssets.forEach(id => {\n\t\t\tthis._registry.off(\"add:\" + id, this._onAddAsset);\n\t\t});\n\n\t\tthis.off(\"progress\");\n\t\tthis.off(\"load\");\n\t}\n\n\tload(done, scope) {\n\t\tthis._count = 0;\n\t\tthis._failed = [];\n\t\tthis._callback = done;\n\t\tthis._scope = scope;\n\n\t\tthis._registry.on(\"load\", this._onLoad, this);\n\n\t\tthis._registry.on(\"error\", this._onError, this);\n\n\t\tfor (let i = 0, l = this._assets.length; i < l; i++) {\n\t\t\tconst asset = this._assets[i];\n\n\t\t\tif (!asset.loading && !asset.loaded) {\n\t\t\t\tthis._registry.load(asset);\n\n\t\t\t\tthis._total++;\n\t\t\t}\n\t\t}\n\t}\n\n\tready(done, scope) {\n\t\tscope = scope || this;\n\n\t\tif (this._loaded) {\n\t\t\tdone.call(scope, this._assets);\n\t\t} else {\n\t\t\tthis.once(\"load\", function (assets) {\n\t\t\t\tdone.call(scope, assets);\n\t\t\t});\n\t\t}\n\t}\n\n\t_loadingComplete() {\n\t\tthis._loaded = true;\n\n\t\tthis._registry.off(\"load\", this._onLoad, this);\n\n\t\tthis._registry.off(\"error\", this._onError, this);\n\n\t\tif (this._failed && this._failed.length) {\n\t\t\tif (this._callback) {\n\t\t\t\tthis._callback.call(this._scope, \"Failed to load some assets\", this._failed);\n\t\t\t}\n\n\t\t\tthis.fire(\"error\", this._failed);\n\t\t} else {\n\t\t\tif (this._callback) {\n\t\t\t\tthis._callback.call(this._scope);\n\t\t\t}\n\n\t\t\tthis.fire(\"load\", this._assets);\n\t\t}\n\t}\n\n\t_onLoad(asset) {\n\t\tif (this._assets.indexOf(asset) >= 0) {\n\t\t\tthis._count++;\n\t\t\tthis.fire(\"progress\", asset);\n\t\t}\n\n\t\tif (this._count === this._total) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._loadingComplete(this._failed);\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\t_onError(err, asset) {\n\t\tif (this._assets.indexOf(asset) >= 0) {\n\t\t\tthis._count++;\n\n\t\t\tthis._failed.push(asset);\n\t\t}\n\n\t\tif (this._count === this._total) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._loadingComplete(this._failed);\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\t_onAddAsset(asset) {\n\t\tconst index = this._waitingAssets.indexOf(asset);\n\n\t\tif (index >= 0) {\n\t\t\tthis._waitingAssets.splice(index, 1);\n\t\t}\n\n\t\tthis._assets.push(asset);\n\n\t\tfor (let i = 0, l = this._assets.length; i < l; i++) {\n\t\t\tasset = this._assets[i];\n\n\t\t\tif (!asset.loading && !asset.loaded) {\n\t\t\t\tthis._registry.load(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\t_waitForAsset(assetId) {\n\t\tthis._waitingAssets.push(assetId);\n\n\t\tthis._registry.once('add:' + assetId, this._onAddAsset, this);\n\t}\n\n}\n\nexport { ABSOLUTE_URL, ACTION_GAMEPAD, ACTION_KEYBOARD, ACTION_MOUSE, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START, ASPECT_AUTO, ASPECT_MANUAL, ASSET_ANIMATION, ASSET_AUDIO, ASSET_CONTAINER, ASSET_CSS, ASSET_CUBEMAP, ASSET_HTML, ASSET_IMAGE, ASSET_JSON, ASSET_MATERIAL, ASSET_MODEL, ASSET_SCRIPT, ASSET_SHADER, ASSET_TEXT, ASSET_TEXTURE, AXIS_KEY, AXIS_MOUSE_X, AXIS_MOUSE_Y, AXIS_PAD_L_X, AXIS_PAD_L_Y, AXIS_PAD_R_X, AXIS_PAD_R_Y, AnimBinder, AnimClip, AnimClipHandler, AnimComponent, AnimComponentLayer, AnimComponentSystem, AnimController, AnimCurve, AnimData, AnimEvaluator, AnimEvents, AnimSnapshot, AnimStateGraph, AnimStateGraphHandler, AnimTarget, AnimTrack, Animation, AnimationComponent, AnimationComponentSystem, AnimationHandler, Application, Asset, AssetListLoader, AssetReference, AssetRegistry, AudioHandler, AudioListenerComponent, AudioListenerComponentSystem, AudioSourceComponent, AudioSourceComponentSystem, BAKE_COLOR, BAKE_COLORDIR, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MAX, BLEND_MIN, BLEND_MULTIPLICATIVE, BLEND_MULTIPLICATIVE2X, BLEND_NONE, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_SCREEN, BLEND_SUBTRACTIVE, BLUR_BOX, BLUR_GAUSSIAN, BODYFLAG_KINEMATIC_OBJECT, BODYFLAG_NORESPONSE_OBJECT, BODYFLAG_STATIC_OBJECT, BODYGROUP_DEFAULT, BODYGROUP_DYNAMIC, BODYGROUP_ENGINE_1, BODYGROUP_ENGINE_2, BODYGROUP_ENGINE_3, BODYGROUP_KINEMATIC, BODYGROUP_NONE, BODYGROUP_STATIC, BODYGROUP_TRIGGER, BODYGROUP_USER_1, BODYGROUP_USER_2, BODYGROUP_USER_3, BODYGROUP_USER_4, BODYGROUP_USER_5, BODYGROUP_USER_6, BODYGROUP_USER_7, BODYGROUP_USER_8, BODYMASK_ALL, BODYMASK_NONE, BODYMASK_NOT_STATIC, BODYMASK_NOT_STATIC_KINEMATIC, BODYMASK_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_DISABLE_SIMULATION, BODYSTATE_ISLAND_SLEEPING, BODYSTATE_WANTS_DEACTIVATION, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYTYPE_STATIC, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT, BasicMaterial, Batch, BatchGroup, BatchManager, BinaryHandler, BoundingBox, BoundingSphere, Bundle, BundleHandler, BundleRegistry, ButtonComponent, ButtonComponentSystem, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, COMPUPDATED_BLEND, COMPUPDATED_CAMERAS, COMPUPDATED_INSTANCES, COMPUPDATED_LIGHTS, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CUBEPROJ_BOX, CUBEPROJ_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, CURVE_CARDINAL, CURVE_CATMULL, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_SPLINE, CURVE_STEP, Camera, CameraComponent, CameraComponentSystem, CanvasFont, CollisionComponent, CollisionComponentSystem, Color, Command, Component, ComponentSystem, ComponentSystemRegistry, ContactPoint, ContactResult, ContainerHandler, ContainerResource, ContextCreationError, Controller, CssHandler, CubemapHandler, Curve, CurveSet, DETAILMODE_ADD, DETAILMODE_MAX, DETAILMODE_MIN, DETAILMODE_MUL, DETAILMODE_OVERLAY, DETAILMODE_SCREEN, DISTANCE_EXPONENTIAL, DISTANCE_INVERSE, DISTANCE_LINEAR, DefaultAnimBinder, DepthMaterial, ELEMENTTYPE_FLOAT32, ELEMENTTYPE_GROUP, ELEMENTTYPE_IMAGE, ELEMENTTYPE_INT16, ELEMENTTYPE_INT32, ELEMENTTYPE_INT8, ELEMENTTYPE_TEXT, ELEMENTTYPE_UINT16, ELEMENTTYPE_UINT32, ELEMENTTYPE_UINT8, EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, EVENT_KEYDOWN, EVENT_KEYUP, EVENT_MOUSEDOWN, EVENT_MOUSEMOVE, EVENT_MOUSEUP, EVENT_MOUSEWHEEL, EVENT_SELECT, EVENT_SELECTEND, EVENT_SELECTSTART, EVENT_TOUCHCANCEL, EVENT_TOUCHEND, EVENT_TOUCHMOVE, EVENT_TOUCHSTART, ElementComponent, ElementComponentSystem, ElementDragHelper, ElementInput, ElementInputEvent, ElementMouseEvent, ElementSelectEvent, ElementTouchEvent, Entity, EntityReference, EnvLighting, EventHandler, FILLMODE_FILL_WINDOW, FILLMODE_KEEP_ASPECT, FILLMODE_NONE, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FITTING_BOTH, FITTING_NONE, FITTING_SHRINK, FITTING_STRETCH, FOG_EXP, FOG_EXP2, FOG_LINEAR, FOG_NONE, FONT_BITMAP, FONT_MSDF, FRESNEL_NONE, FRESNEL_SCHLICK, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, FolderHandler, Font, FontHandler, ForwardRenderer, Frustum, GAMMA_NONE, GAMMA_SRGB, GAMMA_SRGBFAST, GAMMA_SRGBHDR, GamePads, GraphNode, GraphicsDevice, HierarchyHandler, HtmlHandler, Http, I18n, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, INTERPOLATION_CUBIC, INTERPOLATION_LINEAR, INTERPOLATION_STEP, ImageElement, IndexBuffer, IndexedList, JointComponent, JointComponentSystem, JsonHandler, JsonStandardMaterialParser, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_A, KEY_ADD, KEY_ALT, KEY_B, KEY_BACKSPACE, KEY_BACK_SLASH, KEY_C, KEY_CAPS_LOCK, KEY_CLOSE_BRACKET, KEY_COMMA, KEY_CONTEXT_MENU, KEY_CONTROL, KEY_D, KEY_DECIMAL, KEY_DELETE, KEY_DIVIDE, KEY_DOWN, KEY_E, KEY_END, KEY_ENTER, KEY_EQUAL, KEY_ESCAPE, KEY_F, KEY_F1, KEY_F10, KEY_F11, KEY_F12, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_G, KEY_H, KEY_HOME, KEY_I, KEY_INSERT, KEY_J, KEY_K, KEY_L, KEY_LEFT, KEY_M, KEY_META, KEY_MULTIPLY, KEY_N, KEY_NUMPAD_0, KEY_NUMPAD_1, KEY_NUMPAD_2, KEY_NUMPAD_3, KEY_NUMPAD_4, KEY_NUMPAD_5, KEY_NUMPAD_6, KEY_NUMPAD_7, KEY_NUMPAD_8, KEY_NUMPAD_9, KEY_O, KEY_OPEN_BRACKET, KEY_P, KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_PAUSE, KEY_PERIOD, KEY_PRINT_SCREEN, KEY_Q, KEY_R, KEY_RETURN, KEY_RIGHT, KEY_S, KEY_SEMICOLON, KEY_SEPARATOR, KEY_SHIFT, KEY_SLASH, KEY_SPACE, KEY_SUBTRACT, KEY_T, KEY_TAB, KEY_U, KEY_UP, KEY_V, KEY_W, KEY_WINDOWS, KEY_X, KEY_Y, KEY_Z, Key, Keyboard, KeyboardEvent, LAYERID_DEPTH, LAYERID_IMMEDIATE, LAYERID_SKYBOX, LAYERID_UI, LAYERID_WORLD, LAYER_FX, LAYER_GIZMO, LAYER_HUD, LAYER_WORLD, LIGHTFALLOFF_INVERSESQUARED, LIGHTFALLOFF_LINEAR, LIGHTSHAPE_DISK, LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_SPHERE, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, LINEBATCH_GIZMO, LINEBATCH_OVERLAY, LINEBATCH_WORLD, Layer, LayerComposition, LayoutCalculator, LayoutChildComponent, LayoutChildComponentSystem, LayoutGroupComponent, LayoutGroupComponentSystem, Light, LightComponent, LightComponentSystem, LightingParams, Lightmapper, LocalizedAsset, MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, MOTION_FREE, MOTION_LIMITED, MOTION_LOCKED, MOUSEBUTTON_LEFT, MOUSEBUTTON_MIDDLE, MOUSEBUTTON_NONE, MOUSEBUTTON_RIGHT, Mat3, Mat4, Material, MaterialHandler, Mesh, MeshInstance, Model, ModelComponent, ModelComponentSystem, ModelHandler, Morph, MorphInstance, MorphTarget, Mouse, MouseEvent, Node, ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL, OrientedBox, PAD_1, PAD_2, PAD_3, PAD_4, PAD_DOWN, PAD_FACE_1, PAD_FACE_2, PAD_FACE_3, PAD_FACE_4, PAD_LEFT, PAD_L_SHOULDER_1, PAD_L_SHOULDER_2, PAD_L_STICK_BUTTON, PAD_L_STICK_X, PAD_L_STICK_Y, PAD_RIGHT, PAD_R_SHOULDER_1, PAD_R_SHOULDER_2, PAD_R_STICK_BUTTON, PAD_R_STICK_X, PAD_R_STICK_Y, PAD_SELECT, PAD_START, PAD_UP, PAD_VENDOR, PARTICLEMODE_CPU, PARTICLEMODE_GPU, PARTICLEORIENTATION_EMITTER, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLESORT_DISTANCE, PARTICLESORT_NEWER_FIRST, PARTICLESORT_NONE, PARTICLESORT_OLDER_FIRST, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT3, PIXELFORMAT_DXT5, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_L8, PIXELFORMAT_L8_A8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R32F, PIXELFORMAT_R4_G4_B4_A4, PIXELFORMAT_R5_G5_B5_A1, PIXELFORMAT_R5_G6_B5, PIXELFORMAT_R8_G8_B8, PIXELFORMAT_R8_G8_B8_A8, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_SRGB, PIXELFORMAT_SRGBA, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, ParticleEmitter, ParticleSystemComponent, ParticleSystemComponentSystem, PhongMaterial, Picker, Plane, PostEffect$1 as PostEffect, PostEffectQueue, ProgramLibrary, Quat, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID, RENDERSTYLE_WIREFRAME, RESOLUTION_AUTO, RESOLUTION_FIXED, RIGIDBODY_ACTIVE_TAG, RIGIDBODY_CF_KINEMATIC_OBJECT, RIGIDBODY_CF_NORESPONSE_OBJECT, RIGIDBODY_CF_STATIC_OBJECT, RIGIDBODY_DISABLE_DEACTIVATION, RIGIDBODY_DISABLE_SIMULATION, RIGIDBODY_ISLAND_SLEEPING, RIGIDBODY_TYPE_DYNAMIC, RIGIDBODY_TYPE_KINEMATIC, RIGIDBODY_TYPE_STATIC, RIGIDBODY_WANTS_DEACTIVATION, Ray, RaycastResult, ReadStream, RenderComponent, RenderComponentSystem, RenderHandler, RenderTarget, ResourceHandler, ResourceLoader, RigidBodyComponent, RigidBodyComponentSystem, SCALEMODE_BLEND, SCALEMODE_NONE, SCROLLBAR_VISIBILITY_SHOW_ALWAYS, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLL_MODE_INFINITE, SEMANTIC_ATTR, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERDEF_DIRLM, SHADERDEF_INSTANCING, SHADERDEF_LM, SHADERDEF_LMAMBIENT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_NOSHADOW, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_TANGENTS, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERTAG_MATERIAL, SHADER_DEPTH, SHADER_FORWARD, SHADER_FORWARDHDR, SHADER_PICK, SHADER_SHADOW, SHADOWUPDATE_NONE, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, SHADOW_COUNT, SHADOW_DEPTH, SHADOW_PCF1, SHADOW_PCF3, SHADOW_PCF5, SHADOW_VSM16, SHADOW_VSM32, SHADOW_VSM8, SORTKEY_DEPTH, SORTKEY_FORWARD, SORTMODE_BACK2FRONT, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTMODE_MANUAL, SORTMODE_MATERIALMESH, SORTMODE_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, SPECOCC_NONE, SPECULAR_BLINN, SPECULAR_PHONG, SPRITETYPE_ANIMATED, SPRITETYPE_SIMPLE, SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, Scene, SceneHandler, SceneRegistry, SceneRegistryItem, SceneSettingsHandler, ScopeId, ScopeSpace, ScreenComponent, ScreenComponentSystem, ScriptAttributes, ScriptComponent, ScriptComponentSystem, ScriptHandler, ScriptLegacyComponent, ScriptLegacyComponentSystem, ScriptRegistry, ScriptType, ScrollViewComponent, ScrollViewComponentSystem, ScrollbarComponent, ScrollbarComponentSystem, Shader, ShaderHandler, SingleContactResult, Skeleton, Skin, SkinBatchInstance, SkinInstance, SortedLoopArray, Sound, SoundComponent, SoundComponentSystem, SoundInstance, SoundInstance3d, SoundManager, SoundSlot, Sprite, SpriteAnimationClip, SpriteComponent, SpriteComponentSystem, SpriteHandler, StandardMaterial, StencilParameters, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_SWIZZLEGGGR, TONEMAP_ACES, TONEMAP_ACES2, TONEMAP_FILMIC, TONEMAP_HEJL, TONEMAP_LINEAR, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, Tags, Template, TemplateHandler, TextElement, TextHandler, Texture, TextureAtlas, TextureAtlasHandler, TextureHandler, TextureParser, Timer, Touch, TouchDevice, TouchEvent, TransformFeedback, UNIFORMTYPE_BOOL, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC4, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC4, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, URI, UnsupportedBrowserError, VIEW_CENTER, VIEW_LEFT, VIEW_RIGHT, Vec2, Vec3, Vec4, VertexBuffer, VertexFormat, VertexIterator, VrDisplay, VrManager, WorldClusters, XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGUSAGE_GPU, XRHAND_LEFT, XRHAND_NONE, XRHAND_RIGHT, XRSPACE_BOUNDEDFLOOR, XRSPACE_LOCAL, XRSPACE_LOCALFLOOR, XRSPACE_UNBOUNDED, XRSPACE_VIEWER, XRTARGETRAY_GAZE, XRTARGETRAY_POINTER, XRTARGETRAY_SCREEN, XRTRACKABLE_MESH, XRTRACKABLE_PLANE, XRTRACKABLE_POINT, XRTYPE_AR, XRTYPE_INLINE, XRTYPE_VR, XrDepthSensing, XrDomOverlay, XrHitTest, XrHitTestSource, XrImageTracking, XrInput, XrInputSource, XrLightEstimation, XrManager, XrPlane, XrPlaneDetection, XrTrackedImage, ZoneComponent, ZoneComponentSystem, anim, app, apps, asset, audio, basisInitialize, basisSetDownloadConfig, basisTranscode, calculateNormals, calculateTangents, common, config, createBox, createCapsule, createCone, createCylinder, createMesh$1 as createMesh, createPlane, createScript, createSphere, createStyle, createTorus, createURI, data, drawFullscreenQuad, drawQuadWithShader, drawTexture, events, extend, fw, getTouchTargetCoords, gfx, guid, http, inherits, input, isDefined, log, makeArray, math, now, path, platform, posteffect, prefilterCubemap, programlib, registerScript, reprojectTexture, revision, scene, script, semanticToLocation, shFromCubemap, shaderChunks, shadowTypeToString, shape, string, time, type, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, version };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./index/index.ts\");\n",""],"names":[],"sourceRoot":""}