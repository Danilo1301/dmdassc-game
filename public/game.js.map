{"version":3,"file":"game.js","mappings":";;;;;;;;;;AACA;AACA;AACA;;AAEA,eAAe;;AAEf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC9KA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;AAC1B;;;;;;;;;;;ACjDA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAA4C;;AAEvD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,oDAAU;;AAEnC,OAAO,YAAY;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;AC3QA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,sCAAI;AACpC;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,EAKuB;AAC7B,CAAC;AACD,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mBAAmB,+BAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,+BAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA;AACA,UAAU,+BAAmB;AAC7B,eAAe,+BAAmB;AAClC,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA,iEAAiE,iBAAiB;AAClF;AACA,0DAA0D,aAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,+BAAmB;AAC7B,gCAAgC,+BAAmB;AACnD;AACA;AACA;AACA,WAAW,+BAAmB;AAC9B,kDAAkD,gCAAgC;AAClF,0EAA0E,+BAAmB,4BAA4B,oBAAoB;AAC7I;AACA;AACA;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA,oCAAoC,4BAA4B;AAChE,0CAA0C;AAC1C,WAAW,+BAAmB;AAC9B;AACA;AACA;AACA;AACA,UAAU,+BAAmB,kCAAkC;AAC/D;AACA;AACA,UAAU,+BAAmB;AAC7B;AACA;AACA;AACA,iBAAiB,+BAAmB,CAAC,+BAAmB;AACxD,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,SAAS;AACxB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,gCAAgC,sBAAsB;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,MAAM;AACrB,kBAAkB;AAClB;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,kBAAkB;AAClB;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD,OAAO;AACzD;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAM;AACxC,yBAAyB,qBAAM;AAC/B;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY,IAAI,cAAc,IAAI,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,oCAAoC;AAC9D,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA,wBAAwB;;AAExB,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,UAAU;AACV,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,oBAAoB,qBAAqB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,gCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,kBAAkB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,WAAW,gCAAmB;;AAE9B;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,cAAc;AAC7B,gBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA,iDAAiD,gBAAgB;;AAEjE,wBAAwB,oBAAoB;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD,gBAAgB;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,cAAc;AAC7B,eAAe,SAAS;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA,oDAAoD,gBAAgB;;AAEpE,wBAAwB,oBAAoB;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mDAAmD,gBAAgB;;AAEnE;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,eAAe,SAAS;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,MAAM;AACrB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,YAAY;AAC3B,eAAe,SAAS;AACxB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA,wEAAwE,uBAAuB;AAC/F,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,wBAAwB,iCAAiC;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,cAAc;AAC9B;AACA;AACA;;AAEA,wBAAwB,iCAAiC;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,aAAa;AAC7B;AACA;AACA;;AAEA,wBAAwB,iCAAiC;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,eAAe,gCAAmB;AAClC,aAAa,gCAAmB;AAChC,eAAe,gCAAmB;AAClC,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,WAAW,gCAAmB;;AAE9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,wBAAwB,YAAY;AACpC,qBAAqB,YAAY;AACjC;AACA,+BAA+B,YAAY;AAC3C,iCAAiC,sBAAsB;AACvD;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,eAAe,MAAM;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,0CAA0C;AAC1F;AACA,gDAAgD,wCAAwC;;AAExF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA,sDAAsD,uBAAuB;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY,IAAI,cAAc,IAAI,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;AAChC,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;AAChC,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,YAAY;AAC5B;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,cAAc,iCAAmB;;AAEjC;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;AAChC,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO,yDAAyD,YAAY;AAC3F,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,gCAAgC,YAAY;AAC5C;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,uBAAuB;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;;AAEA,gCAAgC,kBAAkB;AAClD;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,2BAA2B;AAC/D,wCAAwC,2BAA2B;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,uBAAuB;;AAEtE;AACA,qCAAqC,YAAY;;AAEjD;AACA,UAAU;AACV;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,oCAAoC;AACpC,kCAAkC;AAClC,yBAAyB;AACzB,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,UAAU,iCAAmB;AAC7B,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA,wBAAwB,4BAA4B;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,wBAAwB;AACrF;;AAEA,iEAAiE,wBAAwB;AACzF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,WAAW;AAC1B,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;;AAEhC;;AAEA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,oBAAoB,QAAQ;AAC5B,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,+BAA+B;AACvD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET,wBAAwB,0BAA0B;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,qBAAqB,QAAQ;AAC7B,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,gBAAgB,iCAAmB;AACnC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,YAAY,iCAAmB;;AAE/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,+BAA+B,yBAAyB;;AAErH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mBAAmB;AACnB;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,WAAW;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA,oDAAoD,uBAAuB;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA,wCAAwC,0BAA0B;AAClE;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA,oDAAoD,uBAAuB;AAC3E;;AAEA;;AAEA,4BAA4B,0BAA0B;AACtD;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA,+CAA+C,kBAAkB;AACjE;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,mDAAmD,kBAAkB;AACrE;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;;AAEA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;;AAEA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,eAAe,iCAAmB;AAClC,eAAe,iCAAmB;AAClC,YAAY,iCAAmB;AAC/B,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;AAChC,gBAAgB,iCAAmB;AACnC,iBAAiB,iCAAmB;AACpC,aAAa,iCAAmB;AAChC,WAAW,iCAAmB;;AAE9B;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2DAA2D,gBAAgB;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,6BAA6B;;AAEpF;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;;AAEA;AACA;AACA,wDAAwD,8BAA8B;;AAEtF;AACA,qDAAqD,2BAA2B;;AAEhF;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,2CAA2C,qBAAqB;AAChE,+CAA+C,qBAAqB;AACpE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD,8BAA8B,iCAAmB;AACjD;AACA,cAAc,iCAAmB;AACjC,gBAAgB,iCAAmB;AACnC,cAAc,iCAAmB;AACjC,gBAAgB,iCAAmB;AACnC,gBAAgB,iCAAmB;AACnC,mBAAmB,iCAAmB;AACtC,oBAAoB,iCAAmB;AACvC,oBAAoB,iCAAmB;AACvC,iBAAiB,iCAAmB;AACpC,kBAAkB,iCAAmB;AACrC,gBAAgB,iCAAmB;AACnC,gBAAgB,iCAAmB;AACnC,cAAc,iCAAmB;AACjC,eAAe,iCAAmB;AAClC,yBAAyB,iCAAmB;AAC5C,cAAc,iCAAmB;AACjC,eAAe,iCAAmB;AAClC,gBAAgB,iCAAmB;AACnC,eAAe,iCAAmB;AAClC,gBAAgB,iCAAmB;AACnC,kBAAkB,iCAAmB;AACrC,gBAAgB,iCAAmB;AACnC,aAAa,iCAAmB;AAChC,kBAAkB,iCAAmB;AACrC,aAAa,iCAAmB;AAChC,gBAAgB,iCAAmB;AACnC,kBAAkB,iCAAmB;AACrC,eAAe,iCAAmB;AAClC;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,sBAAsB,KAAI,cAAc,CAAS;AACjD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,iCAAmB;AACnC,iBAAiB,iCAAmB;AACpC,aAAa,iCAAmB;AAChC,WAAW,iCAAmB;AAC9B,aAAa,iCAAmB;AAChC;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,WAAW;AAC3B;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,yCAAyC;;AAEpF;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAqD;AAC/E;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC,0BAA0B,eAAe;AACzC;AACA;AACA,qFAAqF,4BAA4B;AACjH;;AAEA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA,yFAAyF,4BAA4B;;AAErH;AACA;AACA,6FAA6F,4BAA4B;AACzH;;AAEA;AACA;AACA,6FAA6F,4BAA4B;AACzH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAkE;AAC7G;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA,+CAA+C,yBAAyB;;AAExE,wBAAwB,YAAY;AACpC;AACA;AACA,sBAAsB,8EAA8E;AACpG,iDAAiD,UAAU,wCAAwC,iBAAiB;;AAEpH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB,WAAW;AAC3B;AACA;AACA,0CAA0C,mBAAmB;AAC7D,4CAA4C,0BAA0B,gCAAgC;;AAEtG;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,iCAAmB;AAClC,eAAe,iCAAmB;AAClC,YAAY,iCAAmB;AAC/B,aAAa,iCAAmB;AAChC,eAAe,iCAAmB;AAClC,iBAAiB,iCAAmB;AACpC,gBAAgB,iCAAmB;AACnC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA,oEAAoE,uBAAuB;AAC3F;AACA;AACA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA,+EAA+E,0BAA0B;;AAEzG;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,6DAA6D,0BAA0B;AACvF;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,2DAA2D,cAAc;;AAEzE;AACA,2DAA2D,cAAc;;AAEzE;AACA,yDAAyD,cAAc;;AAEvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,UAAU,iCAAmB;AAC7B,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,eAAe,iCAAmB;;AAElC;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,+DAA+D,wBAAwB;AACvF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sEAAsE,iBAAiB;AACvF;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,8DAA8D,uBAAuB;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc,QAAQ;AACtB,gBAAgB;AAChB,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,iCAAmB;AAChC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,oCAAoC;AACxD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,iCAAmB;AACnC,aAAa,iCAAmB;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;AAGD,OAAO;AACP;AACA,CAAC;;;;;;;;;;ACttUD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA,cAAc;AACd;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;;AAEA,yGAAyG,IAAI,GAAG,IAAI,SAAS,IAAI;;AAEjI;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;AACxE;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wEAAwE;AACxE,kFAAkF;AAClF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,IAAI;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;;;;;;;;;;;;;;;;ACnEA,sHAA+B;AAC/B,iGAAkD;AAClD,2FAA8C;AAC9C,wFAA4C;AAE5C,MAAM,QAAQ,GAAG,IAAI,mBAAQ,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;AAC/D,QAAQ,CAAC,KAAK,EAAE,CAAC;AAEjB,MAAM,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC;AAC9B,MAAM,CAAC,QAAQ,CAAC,GAAG,eAAM,CAAC;AAC1B,MAAM,CAAC,OAAO,CAAC,GAAG,aAAK,CAAC;AAExB,kBAAkB,EAAE,CAAC;AAErB,SAAS,kBAAkB;IACvB,MAAM,KAAK,GAAG,GAAG,CAAC;IAClB,MAAM,MAAM,GAAG,GAAG,CAAC;IACnB,MAAM,CAAC,GAAG,CAAC,CAAC;IAEZ,WAAW;IACX,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAO,CAAC;IACtD,MAAM,MAAM,GAAG,mBAAM,CAAC,MAAM,CAAC,MAAM,CAAC;QAChC,OAAO,EAAE,QAAQ,CAAC,IAAI;QACtB,MAAM,EAAE,MAAM;QACd,MAAM,EAAE;YACJ,GAAG,EAAE;gBACD,CAAC,EAAE,CAAC,KAAK,GAAC,CAAC,GAAG,CAAC;gBACf,CAAC,EAAE,CAAC,MAAM,GAAC,CAAC,GAAG,CAAC;aACnB;YACD,GAAG,EAAE;gBACD,CAAC,EAAE,KAAK,GAAC,CAAC,GAAG,CAAC;gBACd,CAAC,EAAE,MAAM,GAAC,CAAC,GAAG,CAAC;aAClB;SACH;QACD,OAAO,EAAE;YACL,SAAS,EAAE,IAAI;YACf,KAAK,EAAE,KAAK;YACZ,MAAM,EAAE,MAAM;YACd,kBAAkB,EAAE,IAAI;SAC3B;KACL,CAAC,CAAC;IACH,mBAAM,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAI1B,mBAAmB;IACnB,MAAM,WAAW,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAM,CAAC;IAE1D,MAAM,UAAU,GAAQ;QACpB,SAAS,EAAE,GAAG;QACd,MAAM,EAAE;YACJ,OAAO,EAAE,KAAK;SACjB;KACJ,CAAC;IACF,MAAM,KAAK,GAAG,mBAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IACjD,MAAM,eAAe,GAAG,mBAAM,CAAC,eAAe,CAAC,MAAM,CAAC,MAAM,EAAE;QAC1D,KAAK,EAAE,KAAK;QACZ,UAAU,EAAE,UAAU;KACzB,CAAC,CAAC;IACH,mBAAM,CAAC,SAAS,CAAC,GAAG,CAAC,WAAW,EAAE,eAAe,CAAC,CAAC;AACvD,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5DD,iHAAiC;AAEjC,qFAAsC;AACtC,+EAAkC;AAElC,MAAa,MAAM;IAGR,MAAM,KAAK,OAAO,KAAK,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IAM/C,MAAM,CAAC,IAAI;QACd,MAAM,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC;IAC9B,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,EAAU;;QAC3B,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;QAE/B,qBAAM,CAAC,MAAM,0CAAE,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;QAEtG,IAAI,CAAC,eAAe,EAAE,CAAC;IAC3B,CAAC;IAEO,MAAM,CAAC,eAAe;QAC1B,IAAG,IAAI,CAAC,QAAQ,EAAE;YAEd,qBAAqB;YAErB,MAAM,MAAM,GAAG,mBAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;YAExC,IAAG,CAAC,MAAM;gBAAE,OAAO;YAEnB,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;YAEhD,sDAAsD;YACtD,iGAAiG;YACjG,eAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;YACnC,eAAM,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC;SAEhE;IACL,CAAC;IAEM,MAAM,CAAC,WAAW,CAAC,CAAS,EAAE,CAAS;QAC1C,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;QACrB,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;IACzB,CAAC;;AA3CL,wBA4CC;AA3CiB,aAAM,GAAW,IAAI,CAAC;AACtB,mBAAY,GAAY,IAAI,CAAC;AAG7B,eAAQ,GAAY,KAAK,CAAC;AAEzB,gBAAS,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZ7C,iHAAiC;AACjC,+EAAkC;AAElC,iFAAsC;AACtC,oFAAwC;AACxC,kFAAoC;AACpC,+EAAkC;AAClC,iIAA6D;AAC7D,oFAAgD;AAChD,uHAA6D;AAG7D,MAAa,QAAQ;IAgBjB,YAAY,MAAM;QAZX,wBAAmB,GAAW,EAAE,CAAC;QAapC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,KAAK,GAAG,IAAI,WAAI,EAAE,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,IAAI,iBAAO,EAAE,CAAC;QAE9B,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC;IAC7B,CAAC;IAhBD,IAAW,IAAI,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IACxC,IAAW,OAAO,KAAK,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC9C,IAAW,GAAG,KAAK,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAgB/B,KAAK;QACR,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;QAEpB,eAAM,CAAC,IAAI,EAAE,CAAC;QACd,eAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACvB,aAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEtB,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;QAElB,MAAM,aAAa,GAAG,IAAI,CAAC;QAE3B,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QAC7C,IAAG,aAAa;YAAE,KAAK,CAAC,QAAQ,GAAG,qBAAa,CAAC,MAAM,CAAC;QACxD,KAAK,CAAC,IAAI,EAAE,CAAC;QAEb,eAAM,CAAC,KAAK,GAAG,KAAK,CAAC;QAIrB,IAAG,aAAa,EAAE;YACd,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YACvB,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;SACtC;aAAM;YACH,KAAK,CAAC,aAAa,EAAE,CAAC;YAEtB,MAAM,MAAM,GAAG,KAAK,CAAC,WAAW,CAAC,2BAAY,CAAC,CAAC;YAC/C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;SAC1B;IACL,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,uBAAuB;QACvB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAExB,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAE9B,eAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACtB,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,eAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACtB,CAAC;IAGO,cAAc;QAClB,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,EAAE,CAAC,WAAW,CAAC,MAAM,EAAE;YAC/C,KAAK,EAAE,IAAI,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC;YAC3B,KAAK,EAAE,IAAI,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC;YACjC,QAAQ,EAAE,IAAI,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC;SAC3C,CAAC,CAAC;QAEH,EAAE,CAAC,cAAc,CAAC,uBAAU,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC;QAGjD,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QAC3B,GAAG,CAAC,iBAAiB,CAAC,EAAE,CAAC,oBAAoB,CAAC,CAAC;QAC/C,GAAG,CAAC,mBAAmB,CAAC,EAAE,CAAC,eAAe,CAAC,CAAC;QAE5C,GAAG,CAAC,KAAK,CAAC,YAAY,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;QAErD,GAAG,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,EAAU,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;QAClD,GAAG,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,EAAU,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;QAClD,GAAG,CAAC,KAAK,EAAE,CAAC;QAEZ,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE,UAAS,KAAK;YAC5C,GAAG,CAAC,YAAY,EAAE;QACtB,CAAC,EAAE,IAAI,CAAC,CAAC;QAGT,IAAI;QAEJ;;;;;;UAME;IACN,CAAC;IAEM,SAAS,CAAC,MAAc;QAC3B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,kEAAkE;QAClE,yEAAyE;QAEzE,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC;IAC7B,CAAC;IAEM,sBAAsB;IAE7B,CAAC;CACJ;AAtHD,4BAsHC;;;;;;;;;;;;;;;ACjID,6HAA8C;AAE9C,qFAAsC;AACtC,uFAAiN;AACjN,iHAAyD;AAEzD,gIAAkE;AAIlE,MAAa,OAAO;IAApB;QACW,uBAAkB,GAAW,EAAE,CAAC;QAG/B,oBAAe,GAAW,CAAC,CAAC;IA2QxC,CAAC;IAzQG,IAAW,OAAO;QACd,IAAG,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;YAAE,OAAO,GAAG,QAAQ,CAAC,QAAQ,KAAK,QAAQ,CAAC,IAAI,GAAG,CAAC;QACzF,OAAO,iCAAiC,CAAC;IAC7C,CAAC;IAEM,IAAI;QACP,IAAI,CAAC,OAAO,GAAG,yBAAE,EAAC,IAAI,CAAC,OAAO,EAAE;YAC5B,kBAAkB;YAClB,WAAW,EAAE,KAAK;YAClB,YAAY,EAAE,KAAK;SACtB,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,UAAsB,EAAE,IAAS,EAAE,EAAE;YACvD,MAAM,MAAM,GAAW;gBACnB,IAAI,EAAE,UAAU;gBAChB,IAAI,EAAE,IAAI;aACb;YAED,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QACjC,CAAC,CAAC;QAEF,OAAO,CAAC,GAAG,CAAC,uBAAuB,IAAI,CAAC,OAAO,GAAG,CAAC;IACvD,CAAC;IAEM,OAAO;QACV,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;IAEM,cAAc,CAAC,EAAU;QAC5B,IAAI,CAAC,UAAU,CAAyB,mBAAU,CAAC,WAAW,EAAE,EAAC,EAAE,EAAE,EAAE,EAAC,CAAC,CAAC;IAC9E,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,IAAI,CAAC,eAAe,IAAI,EAAE,CAAC;QAC3B,IAAG,IAAI,CAAC,eAAe,IAAI,IAAI,CAAC,kBAAkB,GAAG,IAAI,EAAE;YACvD,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;YAEzB,MAAM,MAAM,GAAG,mBAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;YACxC,IAAG,MAAM;gBAAE,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;SAC1C;IACL,CAAC;IAEM,cAAc,CAAC,MAAc;QAEhC,4CAA4C;QAE5C,mBAAmB;QAEnB,iCAAiC;QAEjC,8FAA8F;QAE9F;;;;;UAKE;IACN,CAAC;IAEM,UAAU,CAAI,IAAgB,EAAE,UAAa;QAChD,MAAM,MAAM,GAAW;YACnB,IAAI,EAAE,IAAI;YACV,IAAI,EAAE,UAAU;SACnB;QACD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IACnC,CAAC;IAEM,eAAe,CAAC,MAAc;QACjC,IAAG,MAAM,CAAC,IAAI,IAAI,mBAAU,CAAC,WAAW,EAAE;YACtC,MAAM,UAAU,GAA2B,MAAM,CAAC,IAAI,CAAC;YAEvD,MAAM,EAAE,GAAW,UAAU,CAAC,EAAE,CAAC;YAEjC,kBAAkB;YAElB,MAAM,KAAK,GAAG,mBAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC/C,IAAI,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;YAEjC,IAAG,CAAC,MAAM,EAAE;gBACR,MAAM,GAAG,IAAI,uBAAU,CAAC,KAAK,CAAC,CAAC;gBAC/B,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBACjB,MAAM,CAAC,YAAY,CAAC,IAAI,6BAAa,EAAE,CAAC,CAAC;gBACzC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;aAC3B;YAED,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SAClC;QAED,IAAG,MAAM,CAAC,IAAI,IAAI,mBAAU,CAAC,YAAY,EAAE;YACvC,MAAM,UAAU,GAA4B,MAAM,CAAC,IAAI,CAAC;YAExD,MAAM,QAAQ,GAAG,UAAU,CAAC,EAAE,CAAC;YAC/B,MAAM,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC;YAGnC,MAAM,KAAK,GAAG,mBAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAE/C,IAAI,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;YAEvC,IAAG,MAAM;gBAAE,OAAO;YAElB,MAAM,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;YAEhE,MAAM,GAAG,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC;YACtB,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAEvB,MAAM,aAAa,GAAG,MAAM,CAAC,YAAY,CAAC,IAAI,6BAAa,EAAE,CAAC,CAAC;YAE/D,MAAM,CAAC,QAAQ,EAAE;YACjB,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAElC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YAExB,aAAa,CAAC,SAAS,EAAE,CAAC;YAG1B,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,UAAU,CAAC;SAC1C;QAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA+EE;QAEF,oDAAoD;QAEpD;;;;;;;;;;;;;;;;;;;UAmBE;QAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAuCE;IACN,CAAC;CACJ;AA/QD,0BA+QC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1RD,iHAAiC;AAEjC,MAAa,UAAW,SAAQ,EAAE,CAAC,UAAU;IAA7C;;QAEW,SAAI,GAAW,WAAW,CAAC;QAC3B,aAAQ,GAAW,EAAE,CAAC;QAMtB,WAAM,GAAW,EAAE,CAAC;QAEpB,eAAU,GAAG,GAAG,EAAE;YACrB,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAExB,2CAA2C;YAC3C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;YAC/C,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAA6B,CAAC;YAExE,IAAI,CAAC,OAAO,GAAG,IAAI,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE;gBACnD,MAAM,EAAE,EAAE,CAAC,uBAAuB;aACrC,CAAC,CAAC;YACH,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAEpC,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,EAAE,CAAC,2BAA2B,CAAC;YACxD,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,EAAE,CAAC,aAAa,CAAC;YAG1C,IAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,EAAE,CAAC,qBAAqB,CAAC;YACjD,IAAI,CAAC,OAAO,CAAC,QAAQ,GAAG,EAAE,CAAC,qBAAqB,CAAC;YAEjD,MAAM,QAAQ,GAAG,IAAI,EAAE,CAAC,gBAAgB,EAAE,CAAC;YAC3C,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,QAAQ,EAAE;gBAC/B,QAAQ,EAAE,QAAQ;gBAClB,IAAI,EAAE,OAAO;aAChB,CAAC,CAAC;YAEH,IAAI,CAAC,MAAM,CAAC,MAAO,CAAC,WAAW,GAAG,KAAK,CAAC;YACxC,IAAI,CAAC,MAAM,CAAC,MAAO,CAAC,cAAc,GAAG,KAAK,CAAC;YAE3C,sCAAsC;YAEtC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC;YACnC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC;YACnC,QAAQ,CAAC,SAAS,GAAG,EAAE,CAAC,YAAY,CAAC;YACrC,6BAA6B;YAC7B,QAAQ,CAAC,MAAM,EAAE,CAAC;YAElB,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC;YACrC,IAAI,CAAC,UAAU,EAAE,CAAC;QAEtB,CAAC;QA+CM,mBAAc,GAAG,GAAG,EAAE;YAGzB,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAChC,CAAC;QAIM,WAAM,GAAG,CAAC,EAAE,EAAE,EAAE;YACnB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;QAC5B,CAAC;QAEM,eAAU,GAAG,CAAC,EAAE,EAAE,EAAE;YACvB,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;YAE5B,4CAA4C;YAE5C,0CAA0C;YAE1C,6BAA6B;YAC7B,oBAAoB;QACxB,CAAC;QAEM,SAAI,GAAG,GAAG,EAAE;YACf,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtB,CAAC;IACL,CAAC;IAvEW,cAAc,CAAC,CAAS,EAAE,CAAS;QACvC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;QACtB,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;QACvB,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;IACpD,CAAC;IAEO,OAAO,CAAC,IAAY;QACxB,IAAI,CAAC,SAAS,EAAE;QAEhB,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;QACzB,MAAM,KAAK,GAAG,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;QAE1C,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC;QAEvC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC;QACzB,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC;QAE1B,4BAA4B;QAC5B,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC1B,2BAA2B;QAE3B,IAAI,CAAC,SAAS,EAAE;QAChB,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;QAEjC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;IAC1B,CAAC;IAEO,SAAS;QACb,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;QACvB,GAAG,CAAC,IAAI,GAAG,OAAO,GAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAC,YAAY,CAAC;QACtD,GAAG,CAAC,SAAS,GAAG,QAAQ,CAAC;QACzB,GAAG,CAAC,YAAY,GAAG,QAAQ,CAAC;QAC5B,GAAG,CAAC,SAAS,GAAG,OAAO,CAAC;IAC5B,CAAC;IAEO,UAAU;QACd,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAExB,WAAW,CAAC,GAAG,EAAE;YACb,gCAAgC;YAEhC,0BAA0B;QAC9B,CAAC,EAAE,GAAG,CAAC;IACX,CAAC;CA4BJ;AA3HD,gCA2HC;AAED,oEAAoE;AACpE,8DAA8D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChI9D,iHAAgC;AAGhC,yEAA6B;AAE7B,MAAa,MAAM;IAQR,MAAM,CAAC,IAAI,CAAC,GAAmB;QAClC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QAEf,IAAI,CAAC,qBAAqB,EAAE,CAAC;IACjC,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,EAAU;QAC3B,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC;IAEO,MAAM,CAAC,WAAW,CAAC,EAAU;QACjC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACzB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QAErB,IAAG,CAAC,KAAK;YAAE,OAAO;QAGlB,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,QAAQ,EAAE;YAGjC,IAAG,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;gBAC1C,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAErC,MAAM,CAAC,cAAc,EAAE,CAAC;gBAExB,OAAO,CAAC,GAAG,CAAC,uBAAuB,CAAC,CAAC;gBAErC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAEnC,2CAA2C;gBAC3C,qEAAqE;gBAErE,IAAG,CAAC,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE;oBAC/C,MAAM,QAAQ,GAAG,IAAI,EAAE,CAAC,gBAAgB,EAAE,CAAC;oBAC3C,QAAQ,CAAC,OAAO,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBACzC,QAAQ,CAAC,MAAM,EAAE,CAAC;oBAElB,MAAM,cAAc,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;oBACpD,cAAc,CAAC,YAAY,CAAC,QAAQ,EAAE;wBAClC,QAAQ,EAAE,QAAQ;wBAClB,IAAI,EAAE,KAAK;qBACd,CAAC,CAAC;oBACH,cAAc,CAAC,MAAO,CAAC,WAAW,GAAG,KAAK,CAAC;oBAC3C,cAAc,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;oBACzD,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;oBAE7C,oCAAoC;iBACvC;gBAID;;kBAEE;aAEL;YAGD,MAAM,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;YACnC,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;YACzC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;YACrE,MAAM,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;SAGxF;QAED,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC1C,IAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,EACnC;gBACI,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;gBAE3E,OAAO,CAAC,GAAG,CAAC,0BAA0B,CAAC,CAAC;gBACxC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;aACzC;SACJ;QAED,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC1C,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACrB;QAED,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC1C,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;SACzB;IACL,CAAC;IAEM,MAAM,CAAC,qBAAqB;QAC/B,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QACrB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACrD,MAAM,CAAC,YAAY,CAAC,QAAQ,EAAE;YAC1B,UAAU,EAAE,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;SAC1C,CAAC,CAAC;QACH,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC1B,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QAC7B,yBAAyB;QACzB,MAAM,CAAC,cAAc,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAChC,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAwB,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;QAG7E,OAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEb,qCAAqC;QAErC,EAAE;QAEF;;;;;;;;;;;;;;;;;;;;UAoBE;QAGF,EAAE;QAGF;;;;UAIE;QAEF,IAAI,CAAC,IAAI,EAAE,CAAC;IAChB,CAAC;IAEO,MAAM,CAAC,IAAI;QACf,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QAErB,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACrC,MAAM,cAAc,GAAG,KAAK,CAAC,YAAY,CAAC,OAAO,CAAsB,CAAC;QACxE,KAAK,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC1B,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAEzB,cAAc,CAAC,IAAI,GAAG,OAAO;QAC7B,cAAc,CAAC,KAAK,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC7C,cAAc,CAAC,KAAK,GAAG,EAAE,CAAC;QAC1B,cAAc,CAAC,SAAS,GAAG,CAAC,CAAC;QAC7B,cAAc,CAAC,UAAU,GAAG,GAAG;QAE/B,cAAc,CAAC,WAAW,GAAG,IAAI,CAAC;QAElC,MAAM,CAAC,WAAW,CAAC,GAAG,cAAc;QACpC,gCAAgC;QAChC,oCAAoC;QAEpC;;;;UAIE;QAEF,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC;QAC5B,8CAA8C;IAClD,CAAC;IAEM,MAAM,CAAC,SAAS,CAAC,GAAW,EAAE,QAAmC;QACpE,MAAM,QAAQ,GAAG,GAAG,CAAC;QACrB,MAAM,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC;QAEvB,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,aAAa,CAAC,GAAG,WAAW,CAAC;QAE9D,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,WAAW,EAAE,SAAS,EAAE,EAAC,GAAG,EAAE,QAAQ,EAAC,CAAC,CAAC;QAEpE,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,UAAU,OAAO;YAC/B,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,KAAK,CAAC,EAAE,CAAC,MAAM,EAAE,UAAU,KAAK;YAC5B,QAAQ,CAAC,KAAK,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;QAEH,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACtB,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvB,OAAO,KAAK,CAAC;IACjB,CAAC;IAEM,MAAM,CAAC,cAAc,CAAC,CAAS,EAAE,CAAS;QAC7C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QAErB,IAAG,CAAC,GAAG;YAAE,OAAO;QAEhB,MAAM,KAAK,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACrC,MAAM,cAAc,GAAG,KAAK,CAAC,YAAY,CAAC,OAAO,CAAsB,CAAC;QACxE,KAAK,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC;QAC1C,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAEzB,cAAc,CAAC,IAAI,GAAG,OAAO;QAC7B,cAAc,CAAC,KAAK,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC7C,cAAc,CAAC,KAAK,GAAG,CAAC,CAAC;QACzB,cAAc,CAAC,SAAS,GAAG,CAAC;QAE5B,UAAU,CAAC,GAAG,EAAE;YACZ,KAAK,CAAC,OAAO,EAAE,CAAC;YAChB,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAChC,CAAC,EAAE,EAAE,CAAC,CAAC;IACX,CAAC;;AAzNL,wBA0NC;AApNkB,yBAAkB,GAAa,EAAE,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXrD,iHAAgC;AAChC,gFAAmC;AAEnC,MAAa,MAAM;IAKf,YAAY,CAAS,EAAE,CAAS,EAAE,IAAY,EAAE,SAAS;QACrD,MAAM,MAAM,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QACxC,MAAM,CAAC,YAAY,CAAC,SAAS,EAAE;YAC3B,6DAA6D;YAC7D,SAAS,EAAE,SAAS;YACpB,QAAQ,EAAE,EAAE;YACZ,4DAA4D;YAC5D,IAAI,EAAE,IAAI;YACV,IAAI,EAAE,EAAE,CAAC,gBAAgB;SAC5B,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAhBD,IAAW,MAAM,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAkBrC,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1C,CAAC;CACJ;AAtBD,wBAsBC;AAED,MAAa,EAAE;IACJ,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAK5C,MAAM,CAAC,IAAI,CAAC,GAAmB;QAClC,MAAM,YAAY,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAChD,IAAI,CAAC,OAAO,GAAG,YAAY,CAAC,YAAY,CAAC,QAAQ,EAAE;YAC/C,WAAW,EAAE,IAAI;YACjB,SAAS,EAAE,EAAE,CAAC,eAAe;YAC7B,UAAU,EAAE,GAAG;SAClB,CAAuB,CAAC;QACzB,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAEhC,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;QAC1C,qCAAqC;QAErC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;IACtB,CAAC;IAEM,MAAM,CAAC,OAAO,CAAC,CAAS,EAAE,CAAS,EAAE,IAAY;QACpD,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;QAC3D,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAEzB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAE5C,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,MAAM,CAAC,QAAQ;QAClB,MAAM,OAAO,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QAC7C,OAAO,CAAC,YAAY,CAAC,SAAS,EAAE;YAC5B,IAAI,EAAE,EAAE,CAAC,iBAAiB;SAC7B,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAC1C,CAAC;IAEM,MAAM,CAAC,YAAY;QACtB,MAAM,GAAG,GAAG,eAAM,CAAC,GAAG,CAAC;QAEvB,IAAG,IAAI,CAAC,UAAU,IAAI,SAAS;YAAE,OAAO,IAAI,CAAC,UAAU,CAAC;QAExD,IAAI,CAAC,UAAU,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,EAAE,EAAE,GAAG,EAAE,0BAA0B,EAAE,CAAC,CAAC;QAC1F,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,MAAM,EAAE;YACvB,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC;QAC9B,CAAC,CAAC,CAAC;QAEH,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAChC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAGjC,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;CACJ;AAxDD,gBAwDC;;;;;;;;;;;;;;;;;;ACnFD,sHAA+B;AAG/B,kGAAwC;AAExC,IAAK,QAGJ;AAHD,WAAK,QAAQ;IACT,iDAAS;IACT,2CAAM;AACV,CAAC,EAHI,QAAQ,KAAR,QAAQ,QAGZ;AAED,MAAM,QAAQ;IAeV,YAAY,GAAW,EAAE,CAAS,EAAE,CAAS,EAAE,IAAc;QATtD,UAAK,GAAW,CAAC;QACjB,WAAM,GAAW,CAAC;QAElB,WAAM,GAAW,CAAC;QAElB,WAAM,GAAY,KAAK,CAAC;QAK3B,IAAI,CAAC,GAAG,GAAG,GAAG;QACd,IAAI,CAAC,CAAC,GAAG,CAAC;QACV,IAAI,CAAC,CAAC,GAAG,CAAC;QACV,IAAI,CAAC,IAAI,GAAG,IAAI;IACpB,CAAC;CACJ;AAGD,MAAa,kBAAmB,SAAQ,qBAAS;IAAjD;;QAEW,aAAQ,GAAW,GAAG,CAAC;QAEvB,YAAO,GAAsC,EAAC,IAAI,EAAE,EAAE,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC;QAK3F,eAAU,GAAG,IAAI,GAAG,EAAoB,CAAC;IA4GrD,CAAC;IA/GG,IAAW,IAAI,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAKjC,UAAU,CAAC,CAAS,EAAE,CAAS;QAClC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAEvB,IAAG,CAAC,IAAI;YAAE,OAAO;QAEjB,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE/B,mBAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,CAAC,CAAC;IACzD,CAAC;IAEM,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;QAEb,IAAI,CAAC,UAAU,EAAE,CAAC;IACtB,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAEjB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAEvB,IAAG,IAAI,EAAE;YACL,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAC/C,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAC/C,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClD,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClD,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;SACjD;IACL,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;QAEpB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAEvB,IAAG,IAAI,EAAE;YACL,mBAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE;gBAC1B,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBAC/B,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;aAClC,CAAC,CAAC;YACH,mBAAM,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAG;gBAC3B,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI;gBAClC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI;aACrC,CAAC,CAAC;YACH,mBAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAChE;IAEL,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC;IAEO,UAAU;QAEd,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,KAAM,CAAC;QACpD,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAChD,MAAM,KAAK,GAAkB,EAAE,CAAC;QAGhC,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,EAAE;YAE7C,OAAO,CAAC,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC;YACnC,IAAG,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,SAAS;gBAAE,QAAQ,CAAC,IAAI,GAAG,mBAAM,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC;YACjJ,IAAG,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,MAAM;gBAAE,QAAQ,CAAC,IAAI,GAAG,mBAAM,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC;YAE3H,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAK,CAAC;SAC7B;QAED,OAAO,CAAC,QAAQ,GAAG,KAAK,CAAC;QACzB,OAAO,CAAC,KAAK,GAAG,KAAK;QAErB,MAAM,IAAI,GAAG,mBAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QAEzC,mBAAM,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,EAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,CAAC,CAAC;QAE1C,mBAAM,CAAC,SAAS,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QAExC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,CAAC;IAEM,WAAW,CAAC,GAAW;QAC1B,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACpC,CAAC;IAEM,YAAY,CAAC,GAAW,EAAE,CAAS,EAAE,CAAS,EAAE,KAAa,EAAE,MAAc,EAAE,SAAkB,KAAK;QACzG,IAAI,QAAQ,GAAG,IAAI,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,SAAS,CAAC;QAE1D,QAAQ,CAAC,KAAK,GAAG,KAAK;QACtB,QAAQ,CAAC,MAAM,GAAG,MAAM;QACxB,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAC;QAEzB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC;QAElC,OAAO,QAAQ;IACnB,CAAC;IAEM,SAAS,CAAC,GAAW,EAAE,CAAS,EAAE,CAAS,EAAE,MAAc;QAC9D,IAAI,QAAQ,GAAG,IAAI,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC;QAEvD,QAAQ,CAAC,MAAM,GAAG,MAAM;QAExB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC;QAElC,OAAO,QAAQ;IACnB,CAAC;CACJ;AArHD,gDAqHC;;;;;;;;;;;;;;;ACrJD,4FAA2C;AAE3C,MAAa,SAAS;IAAtB;QAIW,aAAQ,GAAW,CAAC,CAAC;QAEpB,WAAM,GAAkB,IAAI,CAAC;QAC7B,OAAE,GAAY,KAAK,CAAC;IAuChC,CAAC;IArCU,IAAI;QACP,iDAAiD;IACrD,CAAC;IACM,QAAQ;QACX,iDAAiD;IACrD,CAAC;IACM,OAAO;QACV,oDAAoD;IACxD,CAAC;IACM,SAAS,CAAC,EAAU,IAAG,CAAC;IACxB,MAAM,CAAC,EAAU;QACpB,IAAG,CAAC,IAAI,CAAC,EAAE,EAAE;YACT,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC;YACf,mDAAmD;SACtD;IACL,CAAC;IACM,UAAU,CAAC,EAAU,IAAG,CAAC;IAEzB,MAAM,CAAC,EAAU,IAAG,CAAC;IACrB,UAAU,CAAC,EAAU,IAAG,CAAC;IAEzB,kBAAkB,CAAC,KAAa,EAAE,IAAI,EAAE,UAAmB;QAC9D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,uBAAU,CAAC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IACpG,CAAC;IAEM,uBAAuB,CAAC,KAAa,EAAE,IAAI,EAAE,UAAmB;QACnE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,uBAAU,CAAC,eAAe,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IACnG,CAAC;IAEM,uBAAuB,CAAC,KAAa,EAAE,IAAI,EAAE,UAAmB,IAAG,CAAC;IAEpE,QAAQ;QACX,IAAG,IAAI,CAAC,MAAM,IAAI,IAAI,EAAE;YACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;SAChF;QACD,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;CACJ;AA9CD,8BA8CC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDD,iHAAiC;AACjC,0FAA6C;AAC7C,oFAAgD;AAIhD,kGAAwC;AAGxC,MAAa,cAAe,SAAQ,qBAAS;IAA7C;;QAEW,aAAQ,GAAW,CAAC,CAAC;QAIpB,eAAU,GAAG,IAAI,GAAG,EAAkB,CAAC;IA2DnD,CAAC;IAzDU,QAAQ;IAEf,CAAC;IAEM,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;QAEb,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC9D,CAAC;IAEM,WAAW,CAAC,IAAY,EAAE,IAAY;QACzC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACpC,CAAC;IAEM,MAAM,CAAC,EAAU;QAEpB,IAAG,CAAC,eAAM,CAAC,GAAG;YAAE,OAAO;QAEvB,IAAG,CAAC,IAAI,CAAC,OAAO,EAAE;YAEd,IAAI,CAAC,OAAO,GAAG,OAAE,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;YACpC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC;SAC5C;QAGD,uDAAuD;QAEvD,IAAI,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;QAClD,IAAI,SAAS,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;QAE9B,0BAA0B;QAC1B,eAAM,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;QAExD,IAAI,UAAU,GAAG,eAAM,CAAC,GAAG,CAAC,cAAc,CAAC,aAAa,CAAC;QACzD,SAAS,CAAC,CAAC,IAAI,UAAU,CAAC;QAC1B,SAAS,CAAC,CAAC,IAAI,UAAU,CAAC;QAE1B,2CAA2C;QAC3C,IAAI,YAAY,GAAG,OAAE,CAAC,MAAM,CAAC,MAAM,CAAC;QACpC,IAAI,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC;QAEtC,IAAI,MAAM,GAAG,eAAM,CAAC,GAAG,CAAC,cAAc,CAAC;QAEvC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC,MAAM,CAAC,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC,CAAC,CAAC;QAEpG,IAAI,GAAG,GAAG,EAAE,CAAC;QAEb,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,UAAU,EAAE;YAChC,GAAG,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;SACzB;QAED,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,GAAG,GAAG,CAAC;IAC3C,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrB,CAAC;CACJ;AAjED,wCAiEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1ED,iHAAiC;AAGjC,kGAAwC;AAExC,MAAa,qBAAsB,SAAQ,qBAAS;IAApD;;QAEW,aAAQ,GAAW,CAAC,CAAC;QAEpB,oBAAe,GAAG,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QACxC,qBAAgB,GAAG,CAAC,CAAC;IA4DjC,CAAC;IA1DU,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAEjB,IAAI,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;QAC5B,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;IAC7B,CAAC;IAEO,kBAAkB,CAAC,EAAU;QACjC,IAAI,CAAC,gBAAgB,IAAI,EAAE,CAAC;QAC5B,IAAG,IAAI,CAAC,gBAAgB,IAAI,CAAC,EAAE;YAC3B,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,MAAM,EAAE,GAAC,CAAC,CAAC;YAExC,MAAM,KAAK,GAAG,IAAI,CAAC;YAEnB,IAAI,CAAC,eAAe,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAC,KAAK,GAAC,CAAC,KAAK,GAAC,CAAC,CAAC,CAAC;YACvD,IAAI,CAAC,eAAe,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAC,KAAK,GAAC,CAAC,KAAK,GAAC,CAAC,CAAC,CAAC;SAC1D;IACL,CAAC;IAEO,eAAe,CAAC,EAAU;QAE9B,MAAM,KAAK,GAAG;YACV,UAAU,EAAE,CAAC;YACb,QAAQ,EAAE,CAAC;SACd,CAAC;QAEF,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;QAErD,IAAG,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE;YACpC,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC;SACxB;aAAM;YACH,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;SACzB;QAED,IAAG,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE;YACpC,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC;SACtB;aAAM;YACH,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;SACvB;QAED,IAAG,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,EAAE;YAC7C,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC;YACnB,KAAK,CAAC,UAAU,GAAG,CAAC,CAAC;SACxB;QAGD,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,GAAG,CAAC,GAAG,EAAE,EAAE,KAAK,CAAC,QAAQ,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;QACrF,0CAA0C;QAC1C,gGAAgG;IACpG,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC;CACJ;AAjED,sDAiEC;;;;;;;;;;;;;;;ACpED,6EAAyC;AAEzC,kGAAwC;AACxC,iHAAkD;AAQlD,MAAa,eAAgB,SAAQ,qBAAS;IAA9C;;QAEW,aAAQ,GAAW,CAAC,CAAC;QAErB,SAAI,GAA0B;YACjC,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,CAAC;SACX;IAuBL,CAAC;IArBU,QAAQ;QACX,IAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,IAAI,qBAAa,CAAC,MAAM,EAAE;YACnD,WAAW,CAAC,GAAG,EAAE;gBACb,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACrB,CAAC,EAAE,IAAI,CAAC;SACX;IACL,CAAC;IAEM,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;IAGjB,CAAC;IAIM,MAAM,CAAC,EAAU;;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAEjB,UAAI,CAAC,MAAM,CAAC,YAAY,CAAC,+BAAc,CAAC,0CAAE,WAAW,CAAC,YAAY,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;IAChH,CAAC;CACJ;AA9BD,0CA8BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CD,iHAAiC;AAGjC,kGAAwC;AAExC,IAAY,QAIX;AAJD,WAAY,QAAQ;IAChB,iDAAS;IACT,qDAAW;IACX,qDAAW;AACf,CAAC,EAJW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAInB;AAED,MAAa,aAAc,SAAQ,qBAAS;IAA5C;;QAEW,aAAQ,GAAW,IAAI,CAAC;QAExB,aAAQ,GAAa,QAAQ,CAAC,WAAW,CAAC;QAC1C,iBAAY,GAAW,IAAI,CAAC;QAE3B,oBAAe,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;QAChC,oBAAe,GAAG,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;QAChC,iBAAY,GAAG,CAAC,CAAC;QACjB,iBAAY,GAAW,CAAC,CAAC;IA+ErC,CAAC;IA7EU,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;IACjB,CAAC;IAEM,WAAW;QAEd,IAAG,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,SAAS;YAAE,OAAO;QAE/C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAEvB,IAAI,EAAE,GAAG,GAAG,CAAC;QACb,IAAI,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,CAAC;QAEnE,iBAAiB;QAGjB,iFAAiF;QAGjF,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;QAExC,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;QAEzC,IAAI,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC;QAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACzD,IAAG,QAAQ,GAAG,EAAE,EAAE;YACd,OAAO,GAAG,CAAC,CAAC;SACf;QAED,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,OAAO,GAAG,UAAU,CAAC,CAAC;QACjF,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,OAAO,GAAG,UAAU,CAAC,CAAC;QAEjF,IAAI,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,YAAY,EAAE,GAAG,GAAG,UAAU,CAAC,CAAC;QACzF,IAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,CAAC,EAAE,GAAC,CAAC;YAAE,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;QAE/E,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;QAEzC,MAAM,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,GAAG,CAAE,CAAC;QACpE,MAAM,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,GAAG,CAAE,CAAC;QAGpE,SAAS,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5B,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC1B,SAAS,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAElC,yBAAyB;QACzB,kCAAkC;IACtC,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;QAEpB,IAAI,CAAC,WAAW,EAAE,CAAC;IACvB,CAAC;IAEM,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnC,CAAC;IAEM,QAAQ,CAAC,KAAa;QACzB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;IAC9B,CAAC;IAEM,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACnC,CAAC;IAEM,SAAS;QACZ,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;QAExC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;QACtE,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QACtC,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IAC1E,CAAC;CACJ;AAzFD,sCAyFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpGD,iHAAiC;AAEjC,6HAA0D;AAC1D,kGAAwC;AAWxC,MAAa,kBAAmB,SAAQ,qBAAS;IAAjD;;QAEW,aAAQ,GAAW,IAAI,CAAC;QAIxB,SAAI,GAA6B;YACpC,KAAK,EAAE,CAAC;YACR,QAAQ,EAAE,CAAC;YACX,CAAC,EAAE,CAAC;YACJ,CAAC,EAAE,CAAC;YACJ,IAAI,EAAE,CAAC;YACP,IAAI,EAAE,CAAC;SACV;IAyDL,CAAC;IAvDU,QAAQ;QACX,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;IAC3B,CAAC;IAEM,QAAQ,CAAC,KAAa;QACzB,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IAC5B,CAAC;IAEM,WAAW;QACd,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;IAC3B,CAAC;IAEM,WAAW,CAAC,KAAa;QAC5B,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;IAC/B,CAAC;IAEM,WAAW;QACd,OAAO,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjD,CAAC;IAEM,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IACpB,CAAC;IAEM,WAAW;QACd,OAAO,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACvD,CAAC;IAEM,WAAW,CAAC,CAAS,EAAE,CAAS;QACnC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;IACvB,CAAC;IAEM,UAAU,CAAC,CAAS,EAAE,CAAS;;QAClC,UAAI,CAAC,mBAAmB,0CAAE,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/C,CAAC;IAEM,IAAI;QACP,KAAK,CAAC,IAAI,EAAE,CAAC;QAEb,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,uCAAkB,CAAC,CAAC;IAC5E,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrB,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC;CACJ;AAtED,gDAsEC;;;;;;;;;;;;;;;AClFD,MAAa,aAAa;IAA1B;QAEY,mBAAc,GAAyC,EAAE,CAAC;QAC1D,iBAAY,GAAsC,EAAE,CAAC;IAoCjE,CAAC;IAjCU,cAAc,CAAmB,MAAkC;QACtE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC;IAEM,iBAAiB,CAAsB,MAAkC;QAC5E,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACrC,CAAC;IAEM,mBAAmB,CAAsB,CAAI;QAChD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,cAAc,EAAE;YACtC,IAAG,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI;gBAAE,OAAO,CAAC,CAAC;YAC/C,CAAC,EAAE,CAAC;SACP;QACD,MAAM,YAAY,GAAG,CAAC,CAAC,WAAW,CAAC,IAAI,GAAG,YAAY,CAAC;IAC3D,CAAC;IAEM,gBAAgB,CAAC,KAAa;QACjC,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEM,mBAAmB,CAAC,KAAa;QACpC,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAEM,gBAAgB,CAAmB,CAAI;QAC1C,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,EAAE;YAC7C,IAAG,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI;gBAAE,OAAO,CAAC,CAAC;YAC/C,CAAC,EAAE,CAAC;SACP;QACD,MAAM,SAAS,GAAG,CAAC,CAAC,WAAW,CAAC,IAAI,GAAG,YAAY,CAAC;IACxD,CAAC;CACJ;AAvCD,sCAuCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1CD,iHAAiC;AACjC,gGAAoC;AAEpC,yHAA2D;AAC3D,wIAA+F;AAG/F,MAAa,WAAW;IAAxB;QAEY,UAAK,GAAQ,EAAE,CAAC;IAgE5B,CAAC;IA/DG,iCAAiC;IAE1B,OAAO,CAAC,IAAS;QAEpB,qDAAqD;QACrD,gDAAgD;QAEhD,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACnD,0DAA0D;QAE1D,uCAAuC;QACvC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;QAE9C,OAAO,WAAW,CAAC;IACvB,CAAC;IAEM,OAAO,CAAC,CAAM,EAAE,OAAY;QAC/B,4CAA4C;QAE5C,IAAI,MAAM,GAAQ,SAAS,CAAC;QAE5B,MAAM,SAAS,GAAG,CAAC,GAAW,EAAE,KAAU,EAAE,EAAE;YAC1C,IAAG,MAAM,IAAI,SAAS;gBAAE,MAAM,GAAG,EAAE,CAAC;YAEpC,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACxB,CAAC;QAED,KAAK,MAAM,CAAC,IAAI,CAAC,EAAE;YAEf,sBAAsB;YAItB,IAAG,CAAC,CAAC,CAAC,CAAC,YAAY,MAAM,EAAE;gBAGvB,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;gBAEjD,IAAG,SAAS,IAAI,SAAS,EAAE;oBACvB,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC;iBAC1B;aACJ;iBAAM;gBAEH,IAAG,OAAO,IAAI,SAAS,EAAE;oBACrB,oCAAoC;oBAEpC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBACtB;qBAAM;oBAEH,IAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;wBAEnB,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;qBAErB;iBAEJ;aAEJ;SAEJ;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;CACJ;AAlED,kCAkEC;AAED,MAAa,MAAM;IAkCf,YAAY,KAAY,EAAE,QAAoB;QAjCvC,cAAS,GAAY,KAAK,CAAC;QAE3B,gBAAW,GAAgB,IAAI,WAAW,EAAE,CAAC;QAE7C,YAAO,GAAY,IAAI,CAAC;QAS/B;;;;;;;;UAQE;QAGM,WAAM,GAAkB,IAAI,CAAC;QAE7B,QAAG,GAAW,aAAM,GAAE,CAAC;QAEvB,gBAAW,GAAgB,EAAE,CAAC;QAE9B,mBAAc,GAAY,KAAK,CAAC;QAChC,uBAAkB,GAAY,KAAK,CAAC;QAGxC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAG,QAAQ;YAAE,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QACvC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,uCAAkB,EAAE,CAAC,CAAC;IAClE,CAAC;IA/BD,IAAW,EAAE,KAAK,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IACpC,IAAW,KAAK,KAAK,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAC1C,IAAW,UAAU,KAAK,OAAO,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;IACpD,IAAW,SAAS,KAAK,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;IAClD,IAAW,QAAQ,KAAK,OAAO,IAAI,CAAC,SAAU,CAAC,CAAC,CAAC;IACjD,IAAW,YAAY,KAAK,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAE,CAAC,CAAC,CAAC;IA4BhE,WAAW;QACd,IAAI,QAAQ,GAAQ,SAAS,CAAC;QAE9B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;YACrC,MAAM,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;YAE5B,IAAG,IAAI,IAAI,SAAS;gBAAE,SAAS;YAE/B,IAAG,QAAQ,IAAI,SAAS;gBAAE,QAAQ,GAAG,EAAE,CAAC;YAExC,QAAQ,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,GAAG,IAAI,CAAC;SAEzC;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IAEM,SAAS,CAAC,IAAS;QACtB,IAAG,IAAI,IAAI,SAAS;YAAE,OAAO;QAE7B,EAAE;QACF,MAAM,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;QAEtD,IAAG,aAAa,IAAI,SAAS,EAAE;YAC3B,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;YAEjC,MAAM,KAAK,GAAG,SAAS,CAAC,QAAQ,EAAE,CAAC;YACnC,MAAM,WAAW,GAAG,aAAa,CAAC,KAAK,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC;YAEnF,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;YACzC,MAAM,cAAc,GAAG;gBACnB,CAAC,EAAE,aAAa,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;gBAC9D,CAAC,EAAE,aAAa,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;aACjE;YAED,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC;YACzC,MAAM,cAAc,GAAG;gBACnB,CAAC,EAAE,aAAa,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;gBACpE,CAAC,EAAE,aAAa,CAAC,IAAI,IAAI,SAAS,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;aACvE;YAED,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;YAE7C,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;YAElC,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,6BAAa,CAAC,CAAC;YAEvD,IAAG,aAAa,EAAE;gBACd,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC9C,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAC9C,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAE1B,aAAa,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;gBAC9D,aAAa,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC;gBAC9D,aAAa,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;aACvC;SACJ;QAED,EAAE;QAEF,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW,EAAE;YACtC,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;YACzC,IAAG,KAAK,IAAI,SAAS;gBAAE,SAAS;YAChC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SACxC;IAOL,CAAC;IAEM,KAAK,CAAC,EAAU;QACnB,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;IAClB,CAAC;IAEM,YAAY,CAAsB,CAAI;QACzC,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;QAChB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAEzB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAE3E,IAAG,IAAI,CAAC,cAAc;YAAE,CAAC,CAAC,IAAI,EAAE,CAAC;QACjC,OAAO,CAAC,CAAC;IACb,CAAC;IAEM,cAAc;QACjB,IAAG,CAAC,IAAI,CAAC,SAAS,EAAE;YAChB,IAAI,CAAC,SAAS,GAAG,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YACzC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SACjD;IACL,CAAC;IAED;;;;;MAKE;IAEK,YAAY,CAAsB,MAAkC;QACvE,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,IAAI,SAAS,YAAY,MAAM;gBAAE,OAAO,SAAc,CAAC;QACjG,OAAM;IACV,CAAC;IAEM,QAAQ;QACX,IAAG,IAAI,CAAC,kBAAkB;YAAE,OAAO;QAEnC,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,QAAQ,EAAE,CAAC;QAC/D,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;IACnC,CAAC;IAEM,IAAI;QACP,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,IAAI,EAAE,CAAC;QAC3D,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC/B,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IACtE,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACnE,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACvE,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACnE,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACvE,CAAC;IAEM,OAAO;QACV,IAAG,IAAI,CAAC,SAAS;YAAE,OAAO;QAC1B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QAEtB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,WAAW;YAAE,SAAS,CAAC,OAAO,EAAE,CAAC;IAClE,CAAC;IAEM,QAAQ;QAEX,IAAG,IAAI,CAAC,MAAM,IAAI,IAAI,EAAE;YACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;SACtE;QACD,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;CACJ;AAhMD,wBAgMC;;;;;;;;;;;;;;;AC3QD,wIAAqE;AACrE,4HAA6D;AAC7D,+HAA+D;AAE/D,sFAAkC;AAElC,MAAa,UAAW,SAAQ,eAAM;IAClC,YAAY,KAAY;QACpB,KAAK,CAAC,KAAK,CAAC,CAAC;QAEb,IAAI,CAAC,YAAY,CAAC,IAAI,iCAAe,EAAE,CAAC,CAAC;QACzC,IAAI,CAAC,YAAY,CAAC,IAAI,+BAAc,EAAE,CAAC,CAAC;QACxC,iDAAiD;QAEjD,0DAA0D;QAC1D,wDAAwD;QAExD,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,uCAAkB,EAAE,CAAC,CAAC;QAC9D,sCAAsC;QACtC,SAAS,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;IAC7C,CAAC;CACJ;AAfD,gCAeC;;;;;;;;;;;;;;;ACrBD,wIAAqE;AACrE,4HAA6D;AAG7D,sFAAkC;AAElC,MAAa,YAAa,SAAQ,eAAM;IACpC,YAAY,KAAY;QACpB,KAAK,CAAC,KAAK,CAAC,CAAC;QAEb,IAAI,CAAC,YAAY,CAAC,IAAI,+BAAc,EAAE,CAAC,CAAC;QAGxC,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,uCAAkB,EAAE,CAAC,CAAC;QAC9D,sCAAsC;QACtC,SAAS,CAAC,YAAY,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;IACpD,CAAC;CACJ;AAXD,oCAWC;;;;;;;;;;;;;;;ACfD,kGAA0C;AAE1C,MAAa,YAAa,SAAQ,uBAAU;IACxC,YAAY,KAAY;QACpB,KAAK,CAAC,KAAK,CAAC,CAAC;IACjB,CAAC;CACJ;AAJD,oCAIC;;;;;;;;;;;;;;;ACRD,MAAa,YAAY;IAAzB;QACY,YAAO,GAAG,IAAI,GAAG,EAAsC,CAAC;IAwBpE,CAAC;IAtBU,EAAE,CAAC,KAAa,EAAE,EAA0B;QAC/C,OAAO,CAAC,GAAG,CAAC,sBAAsB,KAAK,EAAE,CAAC,CAAC;QAE3C,IAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YACzB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;SAC/B;QAED,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAElC,2BAA2B;IAC/B,CAAC;IAEM,IAAI,CAAC,KAAa,EAAE,GAAG,IAAI;QAC9B,0BAA0B;QAE1B,IAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC;YAAE,OAAO;QAEpC,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAE,EAAE;YACvC,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACxB;IAEL,CAAC;CACJ;AAzBD,oCAyBC;;;;;;;;;;;;;;;ACzBD,uIAAoE;AACpE,oGAAgD;AAChD,4EAAgC;AAChC,6GAAsD;AACtD,yGAAiD;AACjD,+GAAqD;AACrD,uIAAoE;AACpE,8HAA8D;AAC9D,gJAA0E;AAC1E,+GAAqD;AACrD,wHAA0D;AAC1D,2HAA4D;AAE5D,MAAa,IAAI;IAWb;QAPQ,YAAO,GAAG,IAAI,GAAG,EAAiB,CAAC;QAIpC,mBAAc,GAAW,EAAE,CAAC;QAC5B,YAAO,GAAW,IAAI,CAAC;QAG1B,IAAI,CAAC,cAAc,GAAG,IAAI,6BAAa,EAAE,CAAC;QAE1C,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,uCAAkB,CAAC,CAAC;QAC1D,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,uCAAkB,CAAC,CAAC;QAC1D,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,iCAAe,CAAC,CAAC;QACvD,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,6CAAqB,CAAC,CAAC;QAC7D,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,6BAAa,CAAC,CAAC;QACrD,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,+BAAc,CAAC,CAAC;QAGtD,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,uBAAU,CAAC,CAAC;QAC/C,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,2BAAY,CAAC,CAAC;QACjD,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,2BAAY,CAAC,CAAC;QAEjD,IAAI,CAAC,iBAAiB,GAAG,IAAI,mCAAgB,EAAE,CAAC;QAEhD,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QACjE,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE1B,IAAI,CAAC,GAAW,CAAC,CAAC,CAAC;QAEnB,IAAI,QAAQ,GAAG,CAAC,CAAC;QACjB,WAAW,CAAC,GAAG,EAAE;YACb,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAIrB,IAAG,GAAG,GAAG,QAAQ,IAAI,IAAI,CAAC,cAAc,EAAE;gBACtC,eAAe;gBAEf,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC,QAAQ,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC;gBACzD,QAAQ,GAAG,GAAG,CAAC;gBAEf;;;;;kBAKE;gBAEF,IAAG,EAAE,IAAI,CAAC;oBAAE,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;aAC/B;YAKD,kBAAkB;QACtB,CAAC,CAAC;IACN,CAAC;IA3DD,IAAW,MAAM,KAAK,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;IACjE,IAAW,aAAa,KAAK,OAAO,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;IA4DnD,KAAK;QACR,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAChC,CAAC;IAEM,MAAM,CAAC,EAAU;QACpB,qCAAqC;QAGrC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;YAC7B,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SAClB;IAEL,CAAC;IAEM,WAAW,CAAC,IAAY;QAC3B,OAAO,CAAC,GAAG,CAAC,wBAAwB,IAAI,GAAG,CAAC,CAAC;QAE7C,MAAM,KAAK,GAAG,IAAI,aAAK,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC9B,OAAO,KAAK,CAAC;IACjB,CAAC;CACJ;AAnFD,oBAmFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChGD,iHAAgC;AAEhC,MAAa,KAAK;IACP,MAAM,KAAK,aAAa,KAAK,OAAO,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;IAC1D,MAAM,KAAK,SAAS,KAAK,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;IAMlD,MAAM,CAAC,IAAI,CAAC,GAAmB;QAClC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAE5B,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QACxD,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAEpD,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QACzD,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QACzD,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAEzD,CAAC;IAEO,MAAM,CAAC,mBAAmB,CAAC,KAAiB;QAChD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;IAC7C,CAAC;IAEO,MAAM,CAAC,WAAW,CAAC,KAAiB;QACxC,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEO,MAAM,CAAC,WAAW,CAAC,KAAiB;QACxC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEO,MAAM,CAAC,SAAS,CAAC,KAAiB;QACtC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IACpC,CAAC;IAEM,MAAM,CAAC,MAAM,CAAC,EAAU;IAE/B,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,GAAoB;QACzC,MAAM,QAAQ,GAAa,EAAE;QAE7B,IAAG,OAAO,GAAG,IAAI,QAAQ,EAAE;YACvB,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC9C,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SACjD;aAAM;YACH,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC;SACrB;QAED,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;YAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC;YAC/C,IAAG,KAAK;gBAAE,OAAO,IAAI,CAAC;SACzB;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAEO,MAAM,CAAC,SAAS,CAAC,CAAgB;QACrC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;QAChC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAClC,CAAC;IAEO,MAAM,CAAC,OAAO,CAAC,CAAgB;QACnC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;QAChC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACnC,CAAC;;AApEL,sBAsEC;AAlEkB,WAAK,GAAG,IAAI,GAAG,EAAmB,CAAC;AACnC,oBAAc,GAAG,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACnC,gBAAU,GAAY,KAAK,CAAC;;;;;;;;;;;;;;;ACR/C,gGAAoC;AAEpC,MAAa,IAAI;IAAjB;QAGY,QAAG,GAAW,aAAM,GAAE,CAAC;IACnC,CAAC;IAHG,IAAW,EAAE,KAAK,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;CAGvC;AAJD,oBAIC;AAED,MAAa,GAAG;CAEf;AAFD,kBAEC;AAED,MAAa,SAAS;IAKlB;QAHQ,UAAK,GAAU,EAAE,CAAC;IAK1B,CAAC;IAEM,SAAS,CAAC,MAAc,EAAE,MAAc;IAE/C,CAAC;CAEJ;AAbD,8BAaC;AAED,MAAa,gBAAgB;IAElB,eAAe,CAAC,EAAU;QAC7B,MAAM,SAAS,GAAG,IAAI,SAAS,EAAE,CAAC;QAClC,OAAO,SAAS,CAAC;IACrB,CAAC;CAGJ;AARD,4CAQC;;;;;;;;;;;;;ACnCD,sCAAsC;;;AAEtC,IAAY,UAQX;AARD,WAAY,UAAU;IAClB,yDAAW;IACX,yDAAW;IACX,2DAAY;IACZ,+DAAc;IACd,+DAAc;IACd,yDAAW;IACX,iEAAe;AACnB,CAAC,EARW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAQrB;AAqCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgDE;;;;;;;;;;;;;;;;;;AC/FF,sHAA+B;AAK/B,iGAA8C;AAC9C,2FAA0C;AAC1C,6FAA8C;AAC9C,+EAAkE;AAElE,+GAAqD;AACrD,yGAAiD;AACjD,gJAA0E;AAE1E,+GAAqD;AAErD,IAAI,KAAK,GAAG,CAAC,CAAC;AACd,IAAI,KAAK,GAAG,CAAC,CAAC;AAQd,IAAY,aAIX;AAJD,WAAY,aAAa;IACrB,iEAAY;IACZ,qDAAM;IACN,iDAAI;AACR,CAAC,EAJW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAIxB;AAED,MAAa,KAAK;IAYd,YAAY,IAAU;QAXf,WAAM,GAAiB,IAAI,2BAAY,EAAE,CAAC;QAE1C,aAAQ,GAAkB,aAAa,CAAC,YAAY,CAAC;QAErD,WAAM,GAAiB,EAAE;QAIxB,cAAS,GAAa,EAAE,CAAC;QAI7B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAElB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,uBAAU,CAAC,eAAe,EAAE,CAAC,SAAoB,EAAE,KAAa,EAAE,SAAkB,EAAE,IAAS,EAAE,UAAmB,EAAE,EAAE;YACnI,+FAA+F;YAE/F,IAAG,IAAI,CAAC,QAAQ,IAAI,aAAa,CAAC,MAAM,EAAE;gBAEtC,MAAM,UAAU,GAA+B;oBAC3C,MAAM,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE;oBAC3B,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,SAAS,CAAC;oBACjE,KAAK,EAAE,KAAK;oBACZ,IAAI,EAAE,IAAI;iBACb;gBAED,mBAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,mBAAU,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;gBAG7E,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC;aAEhC;iBAAM;gBAEH,IAAG,UAAU,EAAE;oBAEX,MAAM,UAAU,GAA+B;wBAC3C,MAAM,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE;wBAC3B,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC,SAAS,CAAC;wBACjE,KAAK,EAAE,KAAK;wBACZ,IAAI,EAAE,IAAI;qBACb;oBAED,UAAU,CAAC,UAAU,CAAC,mBAAU,CAAC,eAAe,EAAE,UAAU,CAAC,CAAC;iBACjE;gBAED,SAAS,CAAC,uBAAuB,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC,CAAC;aACjF;QACL,CAAC,CAAC;IACN,CAAC;IA3CD,IAAW,QAAQ,KAAK,OAAO,IAAI,CAAC,SAAS,EAAC,CAAC;IAAA,CAAC;IAChD,IAAW,IAAI,KAAK,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAAA,CAAC;IA4ClC,IAAI;QACP,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAE5B,IAAI;YACA,MAAM,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC;SAC1B;QAAC,OAAM,CAAC,EAAE;SAEV;QAED,IAAI,CAAC,eAAe,EAAE,CAAC;QAEvB;;;;;;;;UAQE;IACN,CAAC;IAEM,IAAI,CAAC,EAAU;QAClB,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;QAElB,oBAAoB;QACpB,mBAAM,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAO,EAAE,kBAAkB,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACjF,uBAAuB;QAEpB,kGAAkG;QACrG,4CAA4C;QAE5C,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAEhB,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACxB,CAAC;IAEO,UAAU,CAAC,EAAU;IAE7B,CAAC;IAGM,SAAS,CAAC,EAAU;QACvB,wBAAwB;QAExB,KAAI,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;SACrB;IACL,CAAC;IAGM,MAAM,CAAC,EAAU;QACpB,KAAK,EAAE,CAAC;QACR,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAO,CAAC,MAAM,CAAC,SAAS,CAAC;QAE7C,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;QAEpB,KAAI,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC;SAClB;IACL,CAAC;IAEM,UAAU,CAAC,EAAU;QACxB,sBAAsB;QACtB,KAAI,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC;SACtB;IACL,CAAC;IAEO,eAAe;QACnB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,mBAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QAC3D,MAAM,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;QACrB,MAAM,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;QAErB,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;QAE/C;;;;;;;;;;;;;UAaE;QAEF,WAAW,CAAC,GAAG,EAAE;YACb,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,gBAAgB,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,qBAAqB,IAAI,CAAC,IAAI,CAAC,cAAc,WAAW,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;YAChJ,KAAK,GAAG,CAAC,CAAC;QACd,CAAC,EAAE,IAAI,CAAC;IACZ,CAAC;IAEO,aAAa;QAEjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;YACzB,IAAI,CAAC,WAAW,EAAE;SACrB;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;YACzB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,GAAC,GAAG,GAAC,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,GAAC,GAAG,GAAC,EAAE,CAAC;SAC5D;IAEL,CAAC;IAEM,WAAW;QACd,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,2BAAY,CAAC,CAAC;IAE/C,CAAC;IAEM,WAAW;QACd,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,2BAAY,CAAC,CAAC;IAClD,CAAC;IAEM,QAAQ,CAAC,CAAS,EAAE,CAAS;QAChC,IAAI,EAAE,GAAG,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAChC,IAAI,EAAE,GAAG,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEhC,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,uBAAU,CAAC,CAAC;QACzC,GAAG,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,EAAE,EAAE,CAAC;QACjC,GAAG,CAAC,YAAY,CAAC,IAAI,6CAAqB,EAAE,CAAC,CAAC;QAE9C,+BAA+B;QAE/B,WAAW,CAAC,GAAG,EAAE;YAEb;;;;;cAKE;QAEN,CAAC,EAAE,GAAG,CAAC;QAEP,gDAAgD;QAChD,OAAO,GAAG,CAAC;IACf,CAAC;IAEM,aAAa;QAChB,OAAO,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAC;QAEtC,IAAI,CAAC,aAAa,EAAE,CAAC;IACzB,CAAC;IAIM,WAAW,CAAC,CAAgB;QAC/B,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;QAE3B,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAClC,CAAC;IAEM,SAAS,CAAC,MAAc;QAC3B,+DAA+D;QAE/D,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC5B,MAAM,CAAC,IAAI,EAAE,CAAC;QACd,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,SAAS,CAAC,EAAU;QACvB,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;YAChC,IAAG,MAAM,CAAC,EAAE,IAAI,EAAE;gBAAE,OAAO,MAAM,CAAC;SACrC;IACL,CAAC;CACJ;AA7ND,sBA6NC;;;;;;;;;;;;;;;AC5PD,IAAY,UAEX;AAFD,WAAY,UAAU;IAClB,iDAAmC;AACvC,CAAC,EAFW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAErB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFuC;AACA;AACA;AACA;AACE;AACQ;AACE;AACE;;;;;;;;;;;;;;;;ACPtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,GAAG;;;;;;;;;;;;;;;ACtNlB,iEAAe,sCAAsC;;;;;;;;;;;;;;;;ACAhB;;AAErC;AACA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,qBAAqB;;AAErB;AACA,qBAAqB;;AAErB;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;AClCpB,iEAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC;;;;;;;;;;;;;;;ACApI;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD;;AAEnD;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iEAAe,IAAI;;;;;;;;;;;;;;;;AC/FkB;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,0gBAA0gB;AAC1gB;AACA;AACA;AACA;;AAEA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,SAAS;;;;;;;;;;;;;;;;;AC7BG;AACY,CAAC;AACxC;AACA;AACA;;AAEA;;AAEA,eAAe;;;AAGf;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;;AAEA;AACA,sDAAsD,+CAAG;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA,wEAAwE;AACxE;;AAEA,4EAA4E;;AAE5E,8DAA8D;;AAE9D;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA,uBAAuB;;AAEvB,oCAAoC;;AAEpC,8BAA8B;;AAE9B,kCAAkC;;AAElC,4BAA4B;;AAE5B,kBAAkB,OAAO;AACzB;AACA;;AAEA,gBAAgB,yDAAS;AACzB;;AAEA,iEAAe,EAAE;;;;;;;;;;;;;;;;;AC9FU;AACA;AAC3B,SAAS,mDAAG,aAAa,+CAAG;AAC5B,iEAAe,EAAE;;;;;;;;;;;;;;;;;;;ACHsB;AACR;;AAE/B;AACA,2CAA2C;;AAE3C;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;;AAEO;AACA;AACP,6BAAe,oCAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qDAAK;AACvB;;AAEA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA;;AAEA,WAAW,yDAAS;AACpB,IAAI;;;AAGJ;AACA,8BAA8B;AAC9B,IAAI,eAAe;;;AAGnB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/D2B;AACY;;AAEvC;AACA;AACA,+CAA+C,+CAAG,KAAK;;AAEvD;AACA,mCAAmC;;AAEnC;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA,SAAS,yDAAS;AAClB;;AAEA,iEAAe,EAAE;;;;;;;;;;;;;;;;;ACvBU;AACE;AAC7B,SAAS,mDAAG,aAAa,gDAAI;AAC7B,iEAAe,EAAE;;;;;;;;;;;;;;;;ACHc;;AAE/B;AACA,qCAAqC,sDAAU;AAC/C;;AAEA,iEAAe,QAAQ;;;;;;;;;;;;;;;;ACNc;;AAErC;AACA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,OAAO;;;;;;;;;;;ACVT;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA,cAAc,gBAAgB;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,YAAY;;AAEnB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACZY;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,cAAc;AAC1G,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,0CAAyC,EAAE,qCAAqC,8BAA8B,EAAC;AAC/G,gBAAgB;AAChB,qBAAqB,mBAAO,CAAC,8EAAgB;AAC7C,6CAA4C,EAAE,qCAAqC,oCAAoC,EAAC;AACxH,iBAAiB,mBAAO,CAAC,4FAAuB;AAChD,8CAA6C,EAAE,qCAAqC,iCAAiC,EAAC;AACtH,gBAAgB,mBAAO,CAAC,oEAAW;AACnC,yDAAwD,EAAE,qCAAqC,2CAA2C,EAAC;;;;;;;;;;;;ACX9H;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,mBAAmB,mBAAO,CAAC,4FAAuB;AAClD,kBAAkB,mBAAO,CAAC,oEAAW;AACrC,kCAAkC,mBAAO,CAAC,gDAAS;AACnD,mCAAmC,mBAAO,CAAC,kDAAU;AACrD,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gCAAgC;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7kBa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,kBAAkB,mBAAO,CAAC,oEAAW;AACrC,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,kEAAkE;AAClE;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACxHJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,yBAAyB,mBAAO,CAAC,6FAAkB;AACnD,uBAAuB,mBAAO,CAAC,yFAAgB;AAC/C,kBAAkB;AAClB;AACA;AACA;;;;;;;;;;;;ACRa;AACb;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,WAAW;AAC7B,4CAA4C,mBAAO,CAAC,2GAAqB;AACzE,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,wCAAwC,mBAAO,CAAC,yFAAkB;AAClE,kBAAkB,mBAAO,CAAC,qEAAY;AACtC,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,qBAAqB,mBAAO,CAAC,qFAAc;AAC3C,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,qBAAqB;AACrB,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrRa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,uBAAuB,mBAAO,CAAC,+EAAiB;AAChD,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,gCAAgC,mBAAO,CAAC,4CAAO;AAC/C,kCAAkC,mBAAO,CAAC,gDAAS;AACnD,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;ACvLF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,6BAA6B,GAAG,iBAAiB,GAAG,gBAAgB;AAChG,wCAAwC,mBAAO,CAAC,yFAAkB;AAClE,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iBAAiB;AACjB,6BAA6B;AAC7B,yBAAyB;;;;;;;;;;;;AClBZ;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,UAAU;AACV,uBAAuB,mBAAO,CAAC,+EAAiB;AAChD,kCAAkC,mBAAO,CAAC,gDAAS;AACnD,gCAAgC,mBAAO,CAAC,4CAAO;AAC/C,kBAAkB,mBAAO,CAAC,qEAAY;AACtC,mCAAmC,mBAAO,CAAC,yHAA4B;AACvE,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;;;;;;;;;;;ACjMG;AACb;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC,mBAAO,CAAC,kDAAU;AACrD,wCAAwC,mBAAO,CAAC,yFAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACxBF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,YAAY;AAC5C,wCAAwC,mBAAO,CAAC,wFAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;;AC7BhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,4BAA4B,GAAG,oBAAoB;AAC1E,0CAA0C;AAC1C,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,CAAC;AACD,uBAAuB;AACvB,oBAAoB;;;;;;;;;;;;AClBP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,6BAA6B,mBAAO,CAAC,4FAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kBAAe;;;;;;;;;;;;AClDF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;AC1CF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,gBAAgB;AAC9G,0BAA0B,mBAAO,CAAC,4FAAmB;AACrD,oBAAoB;AACpB,0BAA0B,mBAAO,CAAC,4FAAmB;AACrD,oBAAoB;AACpB,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,gBAAgB;;;;;;;;;;;;ACrCH;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAe,GAAG,eAAe,GAAG,UAAU,GAAG,cAAc,GAAG,eAAe,GAAG,gBAAgB;AACpG,iBAAiB,mBAAO,CAAC,kEAAU;AACnC,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,2CAA0C,EAAE,qCAAqC,gCAAgC,EAAC;AAClH,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,0CAAyC,EAAE,qCAAqC,8BAA8B,EAAC;AAC/G,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,eAAe;AACf,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,0GAAkB;AACnD,4CAA2C,EAAE,qCAAqC,uCAAuC,EAAC;;AAE1H;;;;;;;;;;;;ACpEa;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,2BAA2B,mBAAO,CAAC,4EAAkB;AACrD,oBAAoB,mBAAO,CAAC,wEAAa;AACzC,4BAA4B,mBAAO,CAAC,0GAAkB;AACtD,gBAAgB,mBAAO,CAAC,gEAAS;AACjC,iCAAiC,mBAAO,CAAC,8CAAQ;AACjD,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;AChZF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;;;;;;;;;;;ACTG;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,2BAA2B,mBAAO,CAAC,0GAAkB;AACrD,gBAAgB,mBAAO,CAAC,gEAAS;AACjC,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAmD;AACjF,aAAa;AACb;AACA;AACA,0BAA0B,8DAA8D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAgD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;;AC1cD;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW;AACX,mCAAmC,mBAAO,CAAC,kDAAU;AACrD,gCAAgC,mBAAO,CAAC,kDAAO,IAAI;AACnD,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;;;;;;;;;;;ACrEE;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,yBAAyB;AACrD,uBAAuB,mBAAO,CAAC,4GAAgB;AAC/C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,eAAe,GAAG,kBAAkB,GAAG,gBAAgB;AACzE,4BAA4B,mBAAO,CAAC,0FAA8B;AAClE,oBAAoB,mBAAO,CAAC,sGAAa;AACzC,uBAAuB,mBAAO,CAAC,4GAAgB;AAC/C,gBAAgB,mBAAO,CAAC,kDAAO,GAAG;AAClC,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,wBAAwB;AACxB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA,iBAAiB,qDAAqD;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;;AAEnC;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,kBAAkB,mGAAmG;AACrH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,iBAAiB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA,MAAM;AACN,iBAAiB,sBAAsB;AACvC;AACA;AACA,MAAM;AACN;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,KAAK;AACL,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,mBAAmB,gBAAgB;AACnC;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,wBAAwB,WAAW,GAAG,aAAa;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,IAAI,KAAK,UAAU,WAAW,gBAAgB,YAAY;AACnF;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,SAAS;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA,MAAM;AACN,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;;AAEA,mBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO,IAAI,OAAO;AAC/B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AACrD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AACrD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2CAA2C,2BAA2B,+BAA+B,GAAG;;AAExG,4CAA4C,yCAAyC,GAAG;;AAExF,6FAA6F,6BAA6B,8DAA8D,4FAA4F,+CAA+C,+BAA+B,gDAAgD,GAAG;;AAErZ,6CAA6C,qBAAqB,qCAAqC,6SAA6S,+DAA+D,GAAG;;AAEtd,+DAA+D,0BAA0B,cAAc,kEAAkE,oEAAoE,mCAAmC,GAAG;;AAEnR,mEAAmE,0BAA0B,6CAA6C,4FAA4F,mEAAmE,8BAA8B,2BAA2B,GAAG;;AAErW,gDAAgD,6CAA6C,4FAA4F,8BAA8B,2BAA2B,GAAG;;AAErP,sDAAsD,wBAAwB,8BAA8B,2BAA2B,GAAG;;AAE1I,yEAAyE,0BAA0B,qEAAqE,8BAA8B,2BAA2B,GAAG;;AAEpO,0EAA0E,wBAAwB,6BAA6B,gDAAgD,kCAAkC,sGAAsG,0CAA0C,0DAA0D,QAAQ,MAAM,6BAA6B,OAAO,MAAM,MAAM,mCAAmC,yEAAyE,KAAK;;AAE1kB,sDAAsD,wDAAwD,4BAA4B,wHAAwH,0DAA0D,uCAAuC;;AAEnW,yCAAyC,mCAAmC,yBAAyB,eAAe,GAAG,2BAA2B,8BAA8B,GAAG,yBAAyB,0CAA0C,GAAG;;AAEzP,6CAA6C,+BAA+B,gCAAgC,kCAAkC,kCAAkC,8BAA8B,qCAAqC,4BAA4B,6BAA6B,kBAAkB,oBAAoB,qBAAqB;;AAEvW,+DAA+D,wBAAwB,mCAAmC,kCAAkC,iCAAiC,oBAAoB;;AAEjN,+DAA+D,wBAAwB,mCAAmC,kCAAkC,iCAAiC;;AAE7L,4FAA4F,wBAAwB,mCAAmC,kCAAkC,iCAAiC,oBAAoB;;AAE9O,6FAA6F,mBAAmB,GAAG;;AAEnH,mCAAmC,2BAA2B,2BAA2B,8CAA8C,uDAAuD,mCAAmC,GAAG,iCAAiC,oCAAoC,qBAAqB,+CAA+C,eAAe,GAAG,2BAA2B,6BAA6B,0DAA0D,kBAAkB,WAAW,MAAM,8DAA8D,+EAA+E,iEAAiE,kCAAkC,iBAAiB,+CAA+C,uGAAuG,uEAAuE,aAAa;;AAE//B,qEAAqE,oEAAoE,+BAA+B,wBAAwB,2DAA2D,6FAA6F,8EAA8E,aAAa;;AAEnb,oFAAoF,yEAAyE,yCAAyC,uBAAuB,oEAAoE,iGAAiG,6EAA6E,wCAAwC,GAAG;;AAE1f,yFAAyF,4CAA4C,qCAAqC,mGAAmG,4FAA4F,iCAAiC,mDAAmD,qEAAqE,GAAG;;AAErgB,wHAAwH,yBAAyB,aAAa,YAAY,+CAA+C,0CAA0C,wBAAwB,sDAAsD,yBAAyB,6CAA6C,MAAM,2BAA2B,0CAA0C,wBAAwB,qDAAqD,yBAAyB,6CAA6C,MAAM,MAAM,0CAA0C,wBAAwB,sDAAsD,yBAAyB,6CAA6C,KAAK,yBAAyB,GAAG,wIAAwI,oBAAoB,oBAAoB,oEAAoE,8CAA8C,6DAA6D,+CAA+C,4DAA4D,wBAAwB,qCAAqC,+BAA+B,cAAc,GAAG;;AAEv5C,kIAAkI,+DAA+D,uEAAuE,GAAG,iIAAiI,wDAAwD,6FAA6F,GAAG,wLAAwL,4GAA4G,yEAAyE,GAAG;;AAEp5B,gOAAgO,qDAAqD,8GAA8G,oEAAoE,mDAAmD,KAAK,iMAAiM,qDAAqD,8GAA8G,oEAAoE,uCAAuC,0DAA0D,KAAK,iMAAiM,qDAAqD,8GAA8G,oEAAoE,uCAAuC,0DAA0D,KAAK,kMAAkM,qDAAqD,8GAA8G,0DAA0D,oEAAoE,yCAAyC,KAAK,gOAAgO,qDAAqD,8GAA8G,oEAAoE,uCAAuC,0DAA0D,KAAK,2LAA2L,2GAA2G,KAAK,2JAA2J,8CAA8C,KAAK,uIAAuI,0DAA0D,KAAK,uIAAuI,0DAA0D,KAAK,wIAAwI,uEAAuE,gDAAgD,KAAK,sKAAsK,0DAA0D,KAAK,iIAAiI,iEAAiE,KAAK;;AAE9oI,8DAA8D,mCAAmC,6CAA6C,uFAAuF,oDAAoD,mFAAmF,6CAA6C,6CAA6C,oCAAoC,kCAAkC,gCAAgC,kCAAkC,+BAA+B,+BAA+B,wCAAwC,iCAAiC,sCAAsC,2BAA2B,iBAAiB,eAAe,gBAAgB,mBAAmB,oBAAoB,sBAAsB,sBAAsB,qBAAqB,2BAA2B,kBAAkB,mBAAmB,gBAAgB,4BAA4B,4BAA4B,eAAe,2BAA2B,iBAAiB,oBAAoB,0BAA0B,2BAA2B,eAAe,IAAI,6BAA6B,ouBAAouB,iLAAiL,GAAG,2PAA2P,sGAAsG,GAAG,kFAAkF,0GAA0G,GAAG,0FAA0F,0EAA0E,qFAAqF,wCAAwC,yCAAyC,+CAA+C,+CAA+C,oFAAoF,oFAAoF,0IAA0I,uCAAuC,qCAAqC,mIAAmI,oDAAoD,+CAA+C,qGAAqG,uDAAuD,mGAAmG,0FAA0F,0FAA0F,oJAAoJ,sFAAsF,mFAAmF,gGAAgG,gGAAgG,gGAAgG,yHAAyH,aAAa,wEAAwE,2FAA2F,gFAAgF,gFAAgF,GAAG,qFAAqF,mJAAmJ,2GAA2G,kGAAkG,oIAAoI,aAAa,4EAA4E,gJAAgJ,kHAAkH,6GAA6G,oGAAoG,oGAAoG,oJAAoJ,sGAAsG,sGAAsG,sGAAsG,wJAAwJ,aAAa,wFAAwF,oHAAoH,oFAAoF,oFAAoF,oFAAoF,gGAAgG,uFAAuF,uFAAuF,uFAAuF,+DAA+D,uFAAuF,uFAAuF,uFAAuF,uFAAuF,+DAA+D,uFAAuF,uFAAuF,uFAAuF,uFAAuF,+DAA+D,uFAAuF,uFAAuF,uFAAuF,uFAAuF,yIAAyI,2DAA2D,GAAG,8EAA8E,wFAAwF,2IAA2I,GAAG,8EAA8E,sFAAsF,iDAAiD,2CAA2C,4GAA4G,GAAG,8CAA8C,wBAAwB,qCAAqC,mEAAmE,wCAAwC,0CAA0C,sCAAsC,6BAA6B,OAAO,wCAAwC,+EAA+E,QAAQ,uCAAuC,+EAA+E,QAAQ,MAAM,iFAAiF,OAAO,6CAA6C,MAAM,mBAAmB,8FAA8F,6DAA6D,KAAK,2BAA2B,uEAAuE,0CAA0C,iDAAiD,UAAU,uCAAuC,iDAAiD,UAAU,MAAM,mDAAmD,SAAS,QAAQ,uBAAuB,oCAAoC,OAAO,wCAAwC,sCAAsC,mGAAmG,OAAO,2FAA2F,iFAAiF,4CAA4C,0DAA0D,YAAY,MAAM,uDAAuD,WAAW,8DAA8D,uDAAuD,8EAA8E,gDAAgD,8CAA8C,sLAAsL,cAAc,MAAM,qOAAqO,aAAa,WAAW,kGAAkG,gDAAgD,2HAA2H,8CAA8C,0FAA0F,0IAA0I,4IAA4I,4IAA4I,kCAAkC,MAAM,oDAAoD,iMAAiM,mMAAmM,mMAAmM,iCAAiC,WAAW,yBAAyB,OAAO,mFAAmF,SAAS,wEAAwE,6IAA6I,uDAAuD,SAAS,iEAAiE,4CAA4C,uDAAuD,YAAY,uCAAuC,uDAAuD,YAAY,MAAM,yDAAyD,WAAW,8FAA8F,yEAAyE,8CAA8C,6DAA6D,cAAc,uCAAuC,6DAA6D,cAAc,MAAM,+DAA+D,aAAa,oGAAoG,sCAAsC,uBAAuB,SAAS,gEAAgE,oLAAoL,2DAA2D,SAAS,0CAA0C,wFAAwF,0FAA0F,iEAAiE,WAAW,uHAAuH,qFAAqF,4DAA4D,qCAAqC,KAAK,GAAG,+CAA+C,sCAAsC,yDAAyD,gFAAgF,GAAG,6BAA6B,6FAA6F,wGAAwG,yDAAyD,+DAA+D,qEAAqE,yDAAyD,8CAA8C,uCAAuC,gCAAgC,mBAAmB,iIAAiI,4CAA4C,wBAAwB,OAAO,MAAM,kDAAkD,0CAA0C,iCAAiC,SAAS,oDAAoD,gBAAgB,SAAS,OAAO,KAAK,GAAG;;AAEl4iB,iDAAiD,wGAAwG,GAAG;;AAE5J,6CAA6C,mCAAmC,GAAG;;AAEnF,qDAAqD,wGAAwG,GAAG;;AAEhK,+DAA+D,uGAAuG,GAAG;;AAEzK,2DAA2D,mEAAmE,GAAG;;AAEjI,mFAAmF,uBAAuB,oIAAoI,GAAG;;AAEjP,wDAAwD,wGAAwG,GAAG;;AAEnK,kFAAkF,qDAAqD,4BAA4B,iEAAiE,GAAG,wEAAwE,qDAAqD,4BAA4B,sHAAsH,iEAAiE,GAAG,+GAA+G,qDAAqD,4BAA4B,+BAA+B,sEAAsE,yDAAyD,GAAG,mHAAmH,qDAAqD,4BAA4B,+BAA+B,sHAAsH,sEAAsE,yDAAyD,GAAG,wEAAwE,yFAAyF,GAAG;;AAE1hD,6DAA6D,mCAAmC,iCAAiC,kDAAkD,kDAAkD,kBAAkB,gDAAgD,gDAAgD,gDAAgD,4DAA4D,4CAA4C,mDAAmD,2CAA2C,GAAG;;AAEhlB,2DAA2D,8BAA8B,GAAG;;AAE5F,mFAAmF,2CAA2C,mEAAmE,yBAAyB,WAAW;;AAErO,6CAA6C,mBAAmB,GAAG,8BAA8B,mCAAmC,GAAG,6BAA6B,yCAAyC,yBAAyB,GAAG,6BAA6B,uBAAuB,iCAAiC,MAAM,MAAM,uDAAuD,KAAK,GAAG,qCAAqC,8BAA8B,6EAA6E,GAAG,gCAAgC,0DAA0D,kCAAkC,GAAG,gCAAgC,yCAAyC,kCAAkC,6IAA6I,GAAG,6CAA6C,gCAAgC,mDAAmD,GAAG,qCAAqC,gCAAgC,yDAAyD,GAAG;;AAE1pC,4DAA4D,mBAAmB,GAAG,yCAAyC,mBAAmB,GAAG,4CAA4C,uCAAuC,GAAG,6CAA6C,gFAAgF,GAAG,yCAAyC,uBAAuB,GAAG,yCAAyC,uBAAuB,GAAG;;AAE7e,gEAAgE,kEAAkE,4BAA4B,wBAAwB,uDAAuD,yHAAyH,2FAA2F,aAAa;;AAE9c,wFAAwF,6CAA6C,gGAAgG,wDAAwD,2BAA2B,aAAa;;AAErU,8DAA8D,2BAA2B,2BAA2B,mBAAmB,qCAAqC,2DAA2D,uEAAuE,mFAAmF,uEAAuE,sEAAsE,mFAAmF,sEAAsE,2DAA2D,qBAAqB,GAAG;;AAE1vB,2GAA2G,qEAAqE,GAAG,8BAA8B,2CAA2C,yBAAyB,GAAG,2BAA2B,8BAA8B,GAAG,+BAA+B,iBAAiB,4CAA4C,6BAA6B,8FAA8F,gDAAgD,6BAA6B,mBAAmB,GAAG,sCAAsC,2BAA2B,2BAA2B,sBAAsB,uBAAuB,8BAA8B,mBAAmB,6CAA6C,6BAA6B,+BAA+B,cAAc,KAAK,2BAA2B,4BAA4B,0CAA0C,oCAAoC,kCAAkC,kCAAkC,yBAAyB,YAAY,MAAM,2BAA2B,YAAY,MAAM,mEAAmE,6CAA6C,2BAA2B,sCAAsC,+DAA+D,8DAA8D,yCAAyC,sCAAsC,SAAS,OAAO,KAAK,kEAAkE,GAAG;;AAE5rD,kEAAkE,oEAAoE,mEAAmE,8BAA8B,8BAA8B,8DAA8D,+DAA+D,8FAA8F,4FAA4F,8BAA8B,GAAG;;AAE7lB,uEAAuE,+CAA+C,gDAAgD,gDAAgD,gEAAgE,4DAA4D;;AAElV;;AAEA,uDAAuD,iBAAiB,GAAG;;AAE3E,mDAAmD,uCAAuC,mCAAmC,GAAG;;AAEhI;;AAEA;;AAEA,sEAAsE,gDAAgD,wCAAwC,6EAA6E,GAAG,iDAAiD,gDAAgD,0CAA0C,wCAAwC,oBAAoB,iFAAiF,mBAAmB,GAAG;;AAE5hB,kEAAkE,iCAAiC,uDAAuD,GAAG;;AAE7J,yEAAyE,eAAe,GAAG,2BAA2B,eAAe,GAAG,sDAAsD,eAAe,GAAG,2BAA2B,mBAAmB,GAAG,oDAAoD,eAAe,GAAG;;AAEvU,4EAA4E,yBAAyB,kDAAkD,+CAA+C,oCAAoC,oCAAoC,oCAAoC,eAAe,GAAG,2BAA2B,yBAAyB,oCAAoC,+CAA+C,oCAAoC,oCAAoC,oCAAoC,eAAe,GAAG,sDAAsD,yBAAyB,gCAAgC,+CAA+C,oCAAoC,oCAAoC,oCAAoC,eAAe,GAAG,2BAA2B,yBAAyB,+CAA+C,6GAA6G,GAAG,oDAAoD,6CAA6C,GAAG;;AAE5pC,uDAAuD,6CAA6C,GAAG,iCAAiC,4DAA4D,GAAG,iCAAiC,8EAA8E,GAAG,4DAA4D,6CAA6C,GAAG,4DAA4D,6CAA6C,GAAG,4DAA4D,6CAA6C,GAAG,4CAA4C,yDAAyD,mDAAmD,kCAAkC,GAAG;;AAE1zB,uCAAuC,4BAA4B,kCAAkC,2BAA2B,kDAAkD,gDAAgD,2CAA2C,kEAAkE,GAAG;;AAElV,wCAAwC,4BAA4B,kCAAkC,2BAA2B,kDAAkD,sEAAsE,2CAA2C,kEAAkE,GAAG;;AAEzW,0CAA0C,0BAA0B,wBAAwB,kCAAkC,2BAA2B,kDAAkD,gEAAgE,2CAA2C,6CAA6C,kEAAkE,GAAG;;AAExa,iDAAiD,2BAA2B,iBAAiB,GAAG;;AAEhG,6DAA6D,qBAAqB,6DAA6D,uCAAuC,mCAAmC,yCAAyC,iEAAiE,4EAA4E,iCAAiC,mCAAmC,2CAA2C,oEAAoE,aAAa;;AAE/kB,0CAA0C,2BAA2B,mBAAmB,2CAA2C,GAAG;;AAEtI,uDAAuD,oBAAoB,oBAAoB,kDAAkD,sCAAsC,GAAG;;AAE1L,8DAA8D,8BAA8B,GAAG,0DAA0D,oCAAoC,GAAG,mDAAmD,iCAAiC,GAAG,uCAAuC,iBAAiB,GAAG,sCAAsC,iBAAiB,GAAG,wCAAwC,iBAAiB,GAAG,sCAAsC,iBAAiB,GAAG;;AAElgB,sDAAsD,iCAAiC,GAAG,wCAAwC,2BAA2B,GAAG,sCAAsC,oDAAoD,GAAG,8CAA8C,mCAAmC,2CAA2C,gBAAgB,GAAG,0DAA0D,yCAAyC,2CAA2C,gBAAgB,GAAG,mDAAmD,sCAAsC,2CAA2C,gBAAgB,GAAG,uCAAuC,+BAA+B,sCAAsC,kCAAkC,aAAa;;AAE/1B,+DAA+D;;AAE/D;;AAEA,iEAAiE,gEAAgE,gCAAgC,sBAAsB,yDAAyD,uFAAuF,4EAA4E,uCAAuC,GAAG;;AAE7b,kDAAkD,gCAAgC,gCAAgC,gCAAgC;;AAElJ,sDAAsD,oDAAoD,GAAG;;AAE7G,8DAA8D,wCAAwC,2CAA2C,2BAA2B,GAAG;;AAE/K,wDAAwD,wCAAwC,sBAAsB,6DAA6D,uDAAuD,wCAAwC,6BAA6B,MAAM,MAAM,wDAAwD,oEAAoE,8DAA8D,wDAAwD,4CAA4C,KAAK,iDAAiD,GAAG;;AAElpB,8EAA8E,8BAA8B,wBAAwB,2EAA2E,mEAAmE,kCAAkC,GAAG;;AAEvT,gDAAgD,gDAAgD,GAAG;;AAEnG,0FAA0F,iCAAiC,4EAA4E,uDAAuD,8DAA8D,8DAA8D,0EAA0E,iCAAiC,gCAAgC,gCAAgC,uBAAuB,gDAAgD,yBAAyB,uBAAuB,wCAAwC,wCAAwC,wCAAwC,8CAA8C,8CAA8C,yCAAyC,+CAA+C,gEAAgE,gEAAgE,wCAAwC,iBAAiB,GAAG,4BAA4B,oDAAoD,GAAG,8BAA8B,sDAAsD,GAAG;;AAE9yC,uFAAuF,sDAAsD,8CAA8C,6CAA6C,2CAA2C,mCAAmC,oDAAoD,GAAG,4BAA4B,oDAAoD,GAAG,8BAA8B,sDAAsD,GAAG;;AAEvhB,wFAAwF,gCAAgC,2CAA2C,4EAA4E,GAAG,4BAA4B,qDAAqD,GAAG,8BAA8B,uDAAuD,GAAG;;AAE9Z,kDAAkD,aAAa,oDAAoD,oDAAoD,oDAAoD,eAAe,GAAG,6EAA6E,gCAAgC,0DAA0D,0CAA0C,0CAA0C,qDAAqD,mCAAmC,cAAc,GAAG,wDAAwD,0BAA0B,qDAAqD,GAAG,uEAAuE,4BAA4B,uBAAuB,4DAA4D,gDAAgD,oBAAoB,+FAA+F,4CAA4C,GAAG,iBAAiB,gBAAgB,gBAAgB,gBAAgB,gBAAgB,IAAI,8HAA8H,oDAAoD,oDAAoD,uCAAuC,oEAAoE,gBAAgB,0CAA0C,iCAAiC,yDAAyD,qBAAqB,kDAAkD,kDAAkD,kDAAkD,kDAAkD,2CAA2C,2CAA2C,2CAA2C,2CAA2C,wCAAwC,6EAA6E,6EAA6E,6EAA6E,6EAA6E,mEAAmE,kBAAkB,GAAG,oBAAoB,2EAA2E,kBAAkB,sDAAsD,sDAAsD,sDAAsD,sDAAsD,kBAAkB,GAAG,sBAAsB,8EAA8E,+DAA+D,oEAAoE,6CAA6C,oCAAoC,6EAA6E,GAAG,cAAc,iCAAiC,iEAAiE,4EAA4E,oDAAoD,GAAG,oBAAoB,uCAAuC,iEAAiE,iDAAiD,+DAA+D,+BAA+B,gFAAgF,GAAG,8BAA8B,kDAAkD,mEAAmE,uEAAuE,4EAA4E,WAAW,6EAA6E,oEAAoE,GAAG,6EAA6E,yDAAyD,GAAG,+EAA+E,uEAAuE,GAAG,sCAAsC,uBAAuB,qCAAqC,0BAA0B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,oMAAoM,sEAAsE,wBAAwB,kBAAkB,KAAK,sBAAsB,0BAA0B,+CAA+C,yDAAyD,iDAAiD,oEAAoE,eAAe,oDAAoD,4BAA4B,4BAA4B,KAAK,KAAK,oBAAoB,0BAA0B,mDAAmD,6DAA6D,iDAAiD,oEAAoE,eAAe,kDAAkD,4BAA4B,6BAA6B,KAAK,4BAA4B,6CAA6C,4BAA4B,mDAAmD,kEAAkE,qEAAqE,0EAA0E,gBAAgB,GAAG,6EAA6E,gBAAgB,sCAAsC,sBAAsB,gDAAgD,iBAAiB,wCAAwC,wCAAwC,wCAAwC,wBAAwB,mCAAmC,oCAAoC,oCAAoC,iBAAiB,mBAAmB,mBAAmB,eAAe,4BAA4B,4BAA4B,4BAA4B,iDAAiD,2BAA2B,yCAAyC,sBAAsB,2CAA2C,2CAA2C,sCAAsC,sCAAsC,oBAAoB,2BAA2B,4CAA4C,4CAA4C,OAAO,iBAAiB,wCAAwC,wCAAwC,OAAO,sBAAsB,sBAAsB,0BAA0B,0BAA0B,KAAK,aAAa,4BAA4B,4BAA4B,oBAAoB,oBAAoB,KAAK,4BAA4B,0CAA0C,yBAAyB,8BAA8B,8BAA8B,8BAA8B,8BAA8B,eAAe,eAAe,qBAAqB,yDAAyD,+DAA+D,mBAAmB,kDAAkD,uBAAuB,uBAAuB,uBAAuB,kEAAkE,mCAAmC,6BAA6B,+BAA+B,8BAA8B,8BAA8B,gFAAgF,gCAAgC,0DAA0D,0CAA0C,qDAAqD,iCAAiC,uDAAuD,4BAA4B,GAAG,+BAA+B,wFAAwF,GAAG,+BAA+B,wFAAwF,GAAG,iCAAiC,kFAAkF,qCAAqC,GAAG,oCAAoC,iDAAiD,+EAA+E,4CAA4C,+GAA+G,GAAG,uDAAuD,sCAAsC,iFAAiF,GAAG,gCAAgC,mDAAmD,GAAG,oDAAoD,qDAAqD,GAAG,+DAA+D,sCAAsC,iFAAiF,GAAG,gCAAgC,mDAAmD,GAAG,oDAAoD,qDAAqD,GAAG,0CAA0C,mDAAmD,GAAG,sDAAsD,qDAAqD,GAAG;;AAE5xU,2DAA2D,oCAAoC,+DAA+D,+BAA+B,GAAG,oDAAoD,oEAAoE,iCAAiC,0BAA0B,uDAAuD,yFAAyF,0EAA0E,0CAA0C,GAAG;;AAE1nB,gDAAgD,mJAAmJ,6CAA6C,GAAG,6CAA6C,mCAAmC,GAAG,kCAAkC,6BAA6B,kCAAkC,6BAA6B,kCAAkC,4BAA4B,6BAA6B,8BAA8B,wDAAwD,uCAAuC,0DAA0D,4DAA4D,gEAAgE,6BAA6B,+CAA+C,uFAAuF,oCAAoC,yEAAyE,kCAAkC,+DAA+D,sDAAsD,4EAA4E,uEAAuE,uBAAuB,gFAAgF,mFAAmF,+EAA+E,wHAAwH,wCAAwC,iHAAiH,0CAA0C,kBAAkB,GAAG;;AAEr+D,6FAA6F,4BAA4B,uGAAuG,kHAAkH,2CAA2C,8CAA8C,8FAA8F,kDAAkD,kDAAkD,kDAAkD,qFAAqF,kDAAkD,kDAAkD,kDAAkD,uGAAuG,8DAA8D,8BAA8B,2DAA2D,GAAG;;AAE3oC,sFAAsF,kDAAkD,uCAAuC,wBAAwB,0BAA0B,+CAA+C,GAAG,gDAAgD,sGAAsG,8GAA8G,oDAAoD,8BAA8B,aAAa;;AAEtnB,2CAA2C,qFAAqF,oDAAoD,GAAG;;AAEvL,uDAAuD,mCAAmC,oBAAoB,qEAAqE,mFAAmF,4CAA4C,iCAAiC,GAAG;;AAEtV,2DAA2D,oBAAoB,qEAAqE,4CAA4C,iCAAiC,GAAG;;AAEpO,yCAAyC,wFAAwF,oDAAoD,GAAG;;AAExL,wCAAwC,yCAAyC,GAAG;;AAEpF,gDAAgD,gBAAgB,oCAAoC,+DAA+D,kBAAkB,GAAG;;AAExL,iDAAiD,gCAAgC,GAAG;;AAEpF,iEAAiE,kEAAkE,6BAA6B,iBAAiB,kDAAkD,oFAAoF,8EAA8E,aAAa;;AAElZ,6CAA6C;;AAE7C,gDAAgD;;AAEhD,sDAAsD,0BAA0B;;AAEhF,yCAAyC,6BAA6B,sBAAsB,2BAA2B,8BAA8B,GAAG,+BAA+B,0CAA0C,2BAA2B,sFAAsF,4CAA4C,yBAAyB,iBAAiB,GAAG,mBAAmB,+BAA+B,0BAA0B,aAAa,oBAAoB,kCAAkC,MAAM,qBAAqB,kCAAkC,MAAM,qBAAqB,gCAAgC,MAAM,qBAAqB,kCAAkC,MAAM,qBAAqB,iCAAiC,MAAM,MAAM,mCAAmC,KAAK,4CAA4C,iEAAiE,GAAG;;AAE/8B,uCAAuC,2BAA2B,mBAAmB,2CAA2C,GAAG;;AAEnI,gDAAgD,kFAAkF,2EAA2E,0EAA0E,+BAA+B,eAAe,GAAG;;AAExU,oDAAoD,kFAAkF,2EAA2E,0EAA0E,gBAAgB,+BAA+B,eAAe,GAAG;;AAE5V,sDAAsD,yCAAyC,sBAAsB,mDAAmD,yDAAyD,wDAAwD,qCAAqC,uBAAuB,oDAAoD,GAAG;;AAE5Y,kDAAkD,6BAA6B,+BAA+B,gCAAgC,gCAAgC,yEAAyE,kCAAkC,0BAA0B,2BAA2B,8BAA8B,GAAG,+EAA+E,uGAAuG,2CAA2C,iBAAiB,GAAG,2BAA2B,+FAA+F,2EAA2E,0BAA0B,mCAAmC,kCAAkC,6BAA6B;;AAEr6B,kDAAkD,yBAAyB,iCAAiC,mCAAmC,yBAAyB,GAAG,2BAA2B,8BAA8B,GAAG,oDAAoD,sGAAsG,GAAG,gEAAgE,+BAA+B,iDAAiD,0CAA0C,yCAAyC,yCAAyC,qCAAqC,wBAAwB,GAAG,iEAAiE,6BAA6B,6BAA6B,+BAA+B,kBAAkB,sBAAsB,GAAG,oDAAoD,8FAA8F,wGAAwG,yBAAyB,GAAG,qDAAqD,8DAA8D,eAAe,GAAG,8BAA8B,wBAAwB,mCAAmC,GAAG,mBAAmB,gDAAgD,4CAA4C,kDAAkD,qFAAqF,oCAAoC,kBAAkB,2DAA2D,2EAA2E,sCAAsC,wFAAwF,kCAAkC,6DAA6D,kBAAkB,wEAAwE,2BAA2B,gCAAgC,gCAAgC,8EAA8E,6IAA6I,0HAA0H,qCAAqC,sCAAsC,mBAAmB;;AAEnoF,0IAA0I;;AAE1I,+IAA+I;;AAE/I,gDAAgD,sCAAsC,+FAA+F,MAAM,MAAM,sEAAsE,KAAK,uEAAuE,oEAAoE,2BAA2B,mDAAmD,kDAAkD;;AAEvhB,sDAAsD,wDAAwD,yDAAyD,oBAAoB,qBAAqB,qDAAqD,0BAA0B,oBAAoB,GAAG;;AAEtT,qFAAqF,8BAA8B,uBAAuB,gCAAgC,mCAAmC,GAAG,sCAAsC,0EAA0E,GAAG,4BAA4B,0DAA0D,0DAA0D,0DAA0D,0DAA0D,yFAAyF,gEAAgE,qBAAqB,yCAAyC,2CAA2C,0BAA0B,mCAAmC,4EAA4E,oCAAoC,6DAA6D,GAAG;;AAEtjC,iDAAiD,6BAA6B,iEAAiE,MAAM,MAAM,2CAA2C,KAAK,GAAG;;AAE9M,uDAAuD,4BAA4B,iCAAiC,oCAAoC,qBAAqB,+CAA+C,eAAe,GAAG,mCAAmC,0DAA0D,qBAAqB,8DAA8D,eAAe,GAAG,sBAAsB,kDAAkD,qCAAqC,2CAA2C,4EAA4E,oCAAoC,iEAAiE,+BAA+B,4EAA4E,MAAM,gCAAgC,4EAA4E,MAAM,gCAAgC,mDAAmD,MAAM,MAAM,8CAA8C,KAAK,GAAG;;AAEjnC,sDAAsD,kCAAkC,0DAA0D,oCAAoC,2BAA2B,+DAA+D,mEAAmE,wEAAwE,wEAAwE,wEAAwE,+DAA+D,oCAAoC,WAAW,oEAAoE,iDAAiD,GAAG;;AAEjxB,4CAA4C,GAAG;;AAE/C,+CAA+C,wCAAwC,uCAAuC,uCAAuC,uCAAuC,uCAAuC,+CAA+C,4BAA4B,8EAA8E,wGAAwG,wCAAwC,gCAAgC,gCAAgC,gCAAgC,aAAa,aAAa,gBAAgB,cAAc,eAAe,gBAAgB,cAAc,cAAc,iBAAiB,eAAe,gBAAgB;;AAE/xB,8DAA8D,oEAAoE,qBAAqB,KAAK;;AAE5J,wEAAwE;;AAExE,4DAA4D,oEAAoE,oBAAoB,KAAK,0CAA0C;;AAEnM,+DAA+D,4CAA4C,0DAA0D,2CAA2C,oDAAoD,uFAAuF,0EAA0E,+CAA+C,WAAW,oEAAoE,uEAAuE,GAAG;;AAE7mB,uDAAuD,8BAA8B,GAAG,kCAAkC,yBAAyB,iCAAiC,mCAAmC,yBAAyB,GAAG,gEAAgE,gCAAgC,kDAAkD,4CAA4C,yCAAyC,yCAAyC,qCAAqC,gCAAgC,GAAG,4EAA4E,0CAA0C,iCAAiC,uGAAuG,GAAG,mBAAmB,+CAA+C,sBAAsB,iCAAiC,mDAAmD,sDAAsD,6BAA6B,sDAAsD,0BAA0B,qBAAqB,kBAAkB,uFAAuF,+EAA+E,2EAA2E,8BAA8B,mCAAmC,8EAA8E,uCAAuC,0CAA0C,wDAAwD,4EAA4E,4EAA4E,6DAA6D,kCAAkC,8GAA8G,+FAA+F,wGAAwG,4FAA4F,8EAA8E,qDAAqD,wGAAwG,6FAA6F,4CAA4C,0CAA0C;;AAEjvF,0EAA0E,mDAAmD;;AAE7H,uDAAuD,oDAAoD,oDAAoD;;AAE/J,qEAAqE,8CAA8C;;AAEnH,sDAAsD;;AAEtD,yDAAyD,sCAAsC,sCAAsC,uCAAuC,+HAA+H,qCAAqC,4BAA4B,mEAAmE,qCAAqC,kCAAkC,6BAA6B,yBAAyB,wBAAwB,qBAAqB,iEAAiE,2CAA2C,uCAAuC,uCAAuC,uCAAuC,0BAA0B,kCAAkC,kEAAkE,6BAA6B,6BAA6B,+BAA+B,kBAAkB,sBAAsB,GAAG,qDAAqD,6FAA6F,eAAe,GAAG,sDAAsD,8DAA8D,eAAe,GAAG,oBAAoB,+CAA+C,6BAA6B,4CAA4C,8FAA8F,2CAA2C,kDAAkD,qFAAqF,2DAA2D,uEAAuE,6BAA6B,uHAAuH,yGAAyG,2BAA2B,2CAA2C,sCAAsC,iDAAiD;;AAE9xE,8EAA8E,4BAA4B,8DAA8D;;AAExK,2EAA2E,oDAAoD;;AAE/H,0CAA0C,uBAAuB,kCAAkC,gCAAgC,GAAG;;AAEtI,yDAAyD,4BAA4B,gFAAgF,2EAA2E;;AAEhP,gEAAgE,qCAAqC,2BAA2B,2BAA2B;;AAE3J,0DAA0D,8CAA8C,6CAA6C,4BAA4B,6BAA6B,kCAAkC,mEAAmE,sDAAsD,gCAAgC,gCAAgC,wBAAwB,0BAA0B,iEAAiE,wGAAwG,kDAAkD,uCAAuC,uCAAuC,uCAAuC,yEAAyE,0CAA0C,aAAa,aAAa,gBAAgB,cAAc,eAAe;;AAEr+B,oEAAoE,6CAA6C;;AAEjH,oOAAoO,iBAAiB;;AAErP,yFAAyF;;AAEzF,sDAAsD,0DAA0D,0DAA0D,mCAAmC;;AAE7M,oFAAoF;;AAEpF,uJAAuJ,0CAA0C;;AAEjM,wEAAwE;;AAExE,8DAA8D,iCAAiC,uEAAuE,mBAAmB;;AAEzL,2DAA2D;;AAE3D,2DAA2D,yCAAyC,gCAAgC,wEAAwE,uEAAuE,2DAA2D;;AAE9U,sIAAsI,iHAAiH;;AAEvP,4DAA4D,uCAAuC,kEAAkE,uCAAuC,qDAAqD;;AAEjQ,wCAAwC,sCAAsC,GAAG;;AAEjF,iDAAiD,+BAA+B,kFAAkF,2EAA2E,0EAA0E,+BAA+B,eAAe,GAAG,mBAAmB,6CAA6C,sDAAsD,mCAAmC,GAAG;;AAEpgB,oCAAoC,yDAAyD,GAAG;;AAEhG,yCAAyC,wDAAwD,uDAAuD,sEAAsE,qEAAqE,6EAA6E,oGAAoG,gDAAgD,GAAG;;AAEvgB,qFAAqF,0BAA0B,mGAAmG,GAAG;;AAErN,4DAA4D,sCAAsC,0DAA0D,yDAAyD,wBAAwB,4DAA4D,GAAG,wBAAwB,uFAAuF,GAAG;;AAE9Z,gGAAgG,8CAA8C,gCAAgC,uBAAuB,uBAAuB,6CAA6C,yBAAyB,yBAAyB,uFAAuF,mDAAmD,GAAG,0DAA0D,gEAAgE,iCAAiC,oDAAoD,gCAAgC,iDAAiD,kCAAkC,kBAAkB,iBAAiB,wBAAwB,gCAAgC,sCAAsC,gCAAgC,MAAM,MAAM,6CAA6C,mBAAmB,KAAK,6DAA6D,6DAA6D,iDAAiD,0FAA0F,qEAAqE,GAAG,wBAAwB,uFAAuF,GAAG;;AAE37C,2FAA2F,8CAA8C,sCAAsC,0DAA0D,wDAAwD,8FAA8F,6CAA6C,8DAA8D,GAAG,wBAAwB,uFAAuF,GAAG;;AAE/lB,iEAAiE,sCAAsC,0DAA0D,6BAA6B,+CAA+C,8DAA8D,GAAG,wBAAwB,uFAAuF,GAAG;;AAEha,gFAAgF,uDAAuD,oCAAoC,gDAAgD,iEAAiE,mBAAmB,GAAG,wBAAwB,yBAAyB,4BAA4B,4BAA4B,yEAAyE,oBAAoB,uFAAuF,oBAAoB,uBAAuB,GAAG;;AAE7nB,qCAAqC,8BAA8B,iCAAiC,+BAA+B,qCAAqC,sBAAsB,uBAAuB,uBAAuB,kBAAkB,0BAA0B,kBAAkB,gCAAgC,kBAAkB,gCAAgC,kBAAkB,8BAA8B,mBAAmB,8BAA8B,mBAAmB,+BAA+B,2BAA2B,8BAA8B,GAAG,kCAAkC,sBAAsB,GAAG,kCAAkC,6BAA6B,GAAG,iCAAiC,sCAAsC,GAAG,iCAAiC,+DAA+D,GAAG,8BAA8B,2CAA2C,yBAAyB,GAAG,gCAAgC,gBAAgB,4CAA4C,4BAA4B,0FAA0F,8CAA8C,2BAA2B,kBAAkB,GAAG,gCAAgC,0BAA0B,iCAAiC,MAAM,MAAM,6DAA6D,KAAK,GAAG,gCAAgC,0DAA0D,yBAAyB,8BAA8B,MAAM,MAAM,mCAAmC,6DAA6D,KAAK,GAAG,2CAA2C,yBAAyB,+CAA+C,+HAA+H,GAAG,8BAA8B,6EAA6E,GAAG,+BAA+B,2FAA2F,GAAG,+BAA+B,wFAAwF,GAAG,iCAAiC,6CAA6C,wDAAwD,GAAG,iCAAiC,4CAA4C,GAAG,gCAAgC,kFAAkF,GAAG,gCAAgC,6CAA6C,GAAG,iDAAiD,6CAA6C,gGAAgG,+DAA+D,WAAW,iDAAiD,sDAAsD,GAAG,gDAAgD,2IAA2I,0GAA0G,WAAW,gDAAgD,uDAAuD,GAAG,6BAA6B,kCAAkC,GAAG,4BAA4B,oDAAoD,GAAG,0BAA0B,uDAAuD,oBAAoB,mDAAmD,KAAK,wBAAwB,GAAG,iCAAiC,6DAA6D,GAAG,6BAA6B,kDAAkD,wCAAwC,oBAAoB,+DAA+D,KAAK,kBAAkB,GAAG,mCAAmC,yCAAyC,wDAAwD,GAAG,mCAAmC,gDAAgD,GAAG,mDAAmD,yCAAyC,gGAAgG,+DAA+D,WAAW,mDAAmD,0DAA0D,GAAG,8BAA8B,+BAA+B,8BAA8B,aAAa,sBAAsB,kCAAkC,MAAM,uBAAuB,kCAAkC,MAAM,uBAAuB,gCAAgC,MAAM,uBAAuB,kCAAkC,MAAM,uBAAuB,iCAAiC,MAAM,MAAM,mCAAmC,KAAK,4EAA4E,GAAG,iCAAiC,gCAAgC,6BAA6B,iDAAiD,iDAAiD,2BAA2B,GAAG,qCAAqC,2GAA2G,qCAAqC,yBAAyB,yBAAyB,GAAG,oBAAoB,2BAA2B,kEAAkE,MAAM,MAAM,4CAA4C,4BAA4B,4BAA4B,8DAA8D,8BAA8B,0BAA0B,sBAAsB,MAAM,4BAA4B,sBAAsB,MAAM,kLAAkL,SAAS,OAAO,yEAAyE,KAAK,GAAG,6EAA6E,4DAA4D,6DAA6D,yDAAyD,aAAa,iEAAiE,6BAA6B,iEAAiE,6BAA6B,iEAAiE,6BAA6B,gEAAgE,gCAAgC,2BAA2B,GAAG,2BAA2B,wDAAwD,WAAW,mBAAmB,4BAA4B,4BAA4B,oBAAoB,iBAAiB,MAAM,mCAAmC,uEAAuE,yBAAyB,KAAK,6CAA6C,GAAG,qCAAqC,wDAAwD,WAAW,mBAAmB,4BAA4B,4BAA4B,oBAAoB,iBAAiB,MAAM,mCAAmC,iEAAiE,KAAK,oDAAoD,GAAG,mBAAmB,kCAAkC,GAAG;;AAE5yP,0DAA0D,0CAA0C,GAAG,mDAAmD,6CAA6C,GAAG;;AAE1M,uDAAuD,mEAAmE,2EAA2E,iFAAiF,qDAAqD,sBAAsB,yDAAyD,GAAG,sFAAsF,uGAAuG,oCAAoC,GAAG,uDAAuD,sFAAsF,4EAA4E,aAAa,sDAAsD,+CAA+C,oCAAoC,GAAG,0CAA0C,6CAA6C,GAAG;;AAE7kC,sDAAsD,wBAAwB,uHAAuH,uCAAuC,6BAA6B,wBAAwB,iBAAiB,MAAM,mDAAmD,yBAAyB,cAAc,OAAO,KAAK,+DAA+D,8EAA8E,yCAAyC,kDAAkD,OAAO,qCAAqC,kDAAkD,OAAO,qCAAqC,kDAAkD,OAAO,YAAY,kDAAkD,OAAO,aAAa,oDAAoD,uCAAuC,iEAAiE,kCAAkC,KAAK,GAAG;;AAEjmC,uEAAuE,yCAAyC,uIAAuI,iCAAiC,qBAAqB,GAAG;;AAEhT,iGAAiG,wDAAwD,uDAAuD,yFAAyF,aAAa,8EAA8E,kDAAkD,4BAA4B,iCAAiC,yDAAyD,yFAAyF,aAAa,kEAAkE,iEAAiE,GAAG,kEAAkE,iEAAiE,GAAG,8EAA8E,wEAAwE,uIAAuI,2DAA2D,GAAG,8EAA8E,2HAA2H,2DAA2D,GAAG;;AAEhgD,oHAAoH,kDAAkD,6BAA6B,+BAA+B,GAAG,qFAAqF,wEAAwE,uIAAuI,kEAAkE,GAAG,yEAAyE,wEAAwE,GAAG;;AAEluB,yHAAyH,iDAAiD,wDAAwD,GAAG,+EAA+E,sGAAsG,GAAG,mFAAmF,4IAA4I,GAAG;;AAE/nB,0HAA0H,uCAAuC,iCAAiC,6CAA6C,kEAAkE,kEAAkE,+DAA+D,4CAA4C,kCAAkC,kCAAkC,qCAAqC,wDAAwD,GAAG,+EAA+E,sGAAsG,GAAG,mFAAmF,4IAA4I,GAAG;;AAE5hC,wDAAwD,2CAA2C,GAAG,+EAA+E,uGAAuG,oCAAoC,GAAG,4FAA4F,6BAA6B,+CAA+C,kDAAkD,mCAAmC,uCAAuC,uCAAuC,yBAAyB,gCAAgC,oBAAoB,gCAAgC,gCAAgC,qCAAqC,6BAA6B,gCAAgC,gCAAgC,qCAAqC,6BAA6B,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2DAA2D,2DAA2D,2DAA2D,2DAA2D,uBAAuB,eAAe,GAAG,uEAAuE,qDAAqD,GAAG,2EAA2E,yDAAyD,GAAG,4FAA4F,sBAAsB,oCAAoC,uCAAuC,iEAAiE,iEAAiE,iEAAiE,oEAAoE,+EAA+E,+EAA+E,sBAAsB,oFAAoF,oFAAoF,oFAAoF,oFAAoF,mDAAmD,GAAG,kEAAkE,oCAAoC,yCAAyC,yBAAyB,wBAAwB,qBAAqB,2FAA2F,2FAA2F,2FAA2F,2FAA2F,0EAA0E,2FAA2F,2FAA2F,2FAA2F,2FAA2F,mEAAmE,GAAG,iEAAiE,qDAAqD,GAAG,qEAAqE,yDAAyD,GAAG,qFAAqF,6BAA6B,yBAAyB,kCAAkC,kCAAkC,iCAAiC,qDAAqD,+BAA+B,+BAA+B,6BAA6B,MAAM,sDAAsD,+BAA+B,+BAA+B,6BAA6B,KAAK,wFAAwF,wDAAwD,wDAAwD,wBAAwB,wBAAwB,uBAAuB,uBAAuB,sBAAsB,qBAAqB,4EAA4E,sEAAsE,4EAA4E,sEAAsE,gEAAgE,sEAAsE,4EAA4E,sEAAsE,4EAA4E,uEAAuE,+DAA+D,+DAA+D,+DAA+D,kEAAkE,wDAAwD,+EAA+E,+EAA+E,sBAAsB,oFAAoF,oFAAoF,oFAAoF,oFAAoF,yDAAyD,GAAG,wEAAwE,gEAAgE,GAAG;;AAEzhN,iGAAiG,6BAA6B,+CAA+C,kDAAkD,mCAAmC,uCAAuC,uCAAuC,yBAAyB,gCAAgC,gCAAgC,oBAAoB,gCAAgC,2CAA2C,+BAA+B,6BAA6B,gCAAgC,oBAAoB,gCAAgC,2CAA2C,+BAA+B,6BAA6B,oBAAoB,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2CAA2C,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,2DAA2D,wBAAwB,iCAAiC,wBAAwB,eAAe,GAAG,uEAAuE,qDAAqD,GAAG,2EAA2E,yDAAyD,GAAG;;AAEj5D,+EAA+E,4BAA4B,mCAAmC,iDAAiD,iEAAiE,GAAG,gCAAgC,mCAAmC,GAAG,uGAAuG,uCAAuC,uEAAuE,8CAA8C,GAAG,+EAA+E,iGAAiG,GAAG,mFAAmF,uIAAuI,GAAG;;AAE/9B,oEAAoE,uCAAuC,GAAG,uDAAuD,sCAAsC,GAAG,wGAAwG,yDAAyD,0CAA0C,+BAA+B,iDAAiD,6DAA6D,4CAA4C,GAAG,6EAA6E,sBAAsB,0CAA0C,iFAAiF,4BAA4B,wDAAwD,iDAAiD,2EAA2E,GAAG;;AAEtgC,2DAA2D,2CAA2C,wCAAwC,wCAAwC,8CAA8C,8CAA8C,6HAA6H,GAAG;;AAElZ,yDAAyD,0CAA0C,mCAAmC,wCAAwC,sBAAsB,qCAAqC,qCAAqC,4BAA4B,8CAA8C,uBAAuB,kEAAkE,kEAAkE,kEAAkE,6HAA6H,GAAG;;AAErrB,qDAAqD,oCAAoC,2CAA2C,+EAA+E,mCAAmC,yCAAyC,yCAAyC,GAAG,oEAAoE,oBAAoB,yCAAyC,oBAAoB,yCAAyC,oBAAoB,yCAAyC,oBAAoB,yCAAyC,gFAAgF,gFAAgF,gFAAgF,wCAAwC,+HAA+H,GAAG;;AAE7hC,mDAAmD,oCAAoC,0CAA0C,mCAAmC,+EAA+E,sBAAsB,qCAAqC,qCAAqC,4BAA4B,8CAA8C,uBAAuB,6DAA6D,6DAA6D,6DAA6D,GAAG,oEAAoE,oBAAoB,yCAAyC,oBAAoB,yCAAyC,oBAAoB,yCAAyC,oBAAoB,yCAAyC,gFAAgF,gFAAgF,gFAAgF,wCAAwC,+HAA+H,GAAG;;AAEh0C,yCAAyC,qCAAqC,yBAAyB,mBAAmB,+CAA+C,4CAA4C,qFAAqF,sFAAsF,GAAG;;AAEnY,yCAAyC,sCAAsC,mBAAmB,sBAAsB,kBAAkB,6GAA6G,2BAA2B,sCAAsC,oCAAoC,GAAG;;AAE/V,yCAAyC,mEAAmE,+CAA+C,qCAAqC,wBAAwB,mBAAmB,4BAA4B,+CAA+C,wEAAwE,4CAA4C,iDAAiD,GAAG;;AAE9d,kEAAkE,mEAAmE,iCAAiC,6BAA6B,yDAAyD,2FAA2F,6EAA6E,aAAa;;AAEjb,gEAAgE,iBAAiB,GAAG;;AAEpF,mEAAmE,oDAAoD,uDAAuD,yDAAyD,GAAG;;AAE1O,uEAAuE,oDAAoD,uDAAuD,2BAA2B,GAAG;;AAEhN,6GAA6G,wDAAwD,0EAA0E,GAAG;;AAElP,gCAAgC,4BAA4B,6BAA6B,0BAA0B,2BAA2B,kDAAkD,2BAA2B;;AAE3N,gCAAgC,gCAAgC;;AAEhE,+CAA+C,0CAA0C;;AAEzF,2EAA2E,4DAA4D,wDAAwD,2HAA2H,wDAAwD,wEAAwE,0CAA0C;;AAEpe,iDAAiD,4BAA4B,gCAAgC,oDAAoD;;AAEjK,4CAA4C,yDAAyD,GAAG,sBAAsB,yDAAyD,GAAG,2BAA2B,oDAAoD,GAAG;;AAE5Q,4BAA4B,wFAAwF,GAAG;;AAEvH,8CAA8C,iBAAiB,kBAAkB,kCAAkC,kCAAkC,2BAA2B,2BAA2B,gDAAgD,gDAAgD,iDAAiD,iDAAiD,4CAA4C,mEAAmE,0DAA0D,GAAG;;AAEzjB,gCAAgC,uDAAuD,GAAG;;AAE1F,uCAAuC,oDAAoD,sCAAsC,2BAA2B,gFAAgF,yCAAyC,6CAA6C,mCAAmC,OAAO,8CAA8C,6CAA6C,mCAAmC,OAAO,8CAA8C,6CAA6C,mCAAmC,OAAO,KAAK,uEAAuE,GAAG;;AAErsB,gDAAgD,4BAA4B,oBAAoB,oBAAoB,oBAAoB,oBAAoB,oBAAoB,8BAA8B,0CAA0C,GAAG;;AAE3P,iDAAiD,8HAA8H,sIAAsI,6BAA6B,+CAA+C,uDAAuD,iBAAiB,GAAG,4BAA4B,sBAAsB,iCAAiC,gCAAgC,kCAAkC,mCAAmC,iBAAiB,GAAG;;AAExpB,gDAAgD,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,uBAAuB,yBAAyB,kCAAkC,mDAAmD,GAAG,4BAA4B,gDAAgD,2DAA2D,+BAA+B,iBAAiB,GAAG;;AAEre,gDAAgD,4BAA4B,sBAAsB,qEAAqE,2BAA2B,mDAAmD,yIAAyI,GAAG;;AAEjY,kDAAkD,4BAA4B,4BAA4B,GAAG;;AAE7G,mDAAmD,iBAAiB,GAAG;;AAEvE,8DAA8D,wDAAwD,+BAA+B,uEAAuE,gCAAgC,qCAAqC,2CAA2C,8CAA8C,0DAA0D,+DAA+D,oFAAoF,GAAG,2FAA2F,iCAAiC,oEAAoE,uGAAuG,6GAA6G,iCAAiC,aAAa,sBAAsB,oCAAoC,oCAAoC,mDAAmD,8EAA8E,+EAA+E,sHAAsH,wEAAwE,wBAAwB,4BAA4B,0GAA0G,oDAAoD,oDAAoD,oDAAoD,uFAAuF,oDAAoD,oDAAoD,oDAAoD,yGAAyG,6DAA6D,yBAAyB,6DAA6D,mDAAmD,oCAAoC,mBAAmB,kFAAkF,oDAAoD,sDAAsD,4EAA4E,mCAAmC,uCAAuC,mCAAmC,8CAA8C,yCAAyC,GAAG,2BAA2B,sBAAsB,GAAG;;AAE94F,sDAAsD,4BAA4B,qCAAqC,kBAAkB,oBAAoB;;AAE7J,+CAA+C,iCAAiC,8EAA8E,+EAA+E,6GAA6G,yBAAyB,0CAA0C,gCAAgC,cAAc,GAAG,wBAAwB,4BAA4B,GAAG;;AAErgB,4BAA4B,4BAA4B,GAAG;;AAE3D,oCAAoC,sDAAsD,GAAG;;AAE7F,qFAAqF,gCAAgC,wCAAwC,GAAG;;AAEhK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uDAAuD;;AAEvD;AACA,2EAA2E;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,0BAA0B;AACpD;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,wCAAwC;AACxC,gCAAgC;AAChC;;AAEA;AACA,4CAA4C;AAC5C,8BAA8B;AAC9B;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA,yCAAyC;;AAEzC;AACA,yFAAyF;AACzF;;AAEA;AACA,oCAAoC;AACpC;;AAEA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,IAAI;AACJ,gCAAgC;AAChC;;AAEA;AACA,8BAA8B;AAC9B,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;;AAEA;AACA,oCAAoC;AACpC,IAAI;AACJ,oCAAoC;AACpC;;AAEA;AACA,kEAAkE;AAClE;;AAEA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA,gDAAgD;AAChD,KAAK;AACL;AACA,2DAA2D;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,gEAAgE;AAChE,qEAAqE;AACrE,mEAAmE;AACnE,8DAA8D;AAC9D,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;;AAEf;AACA;AACA,sCAAsC;AACtC,KAAK;AACL,2CAA2C;AAC3C;;AAEA,2CAA2C;AAC3C;;AAEA,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA,sEAAsE;AACtE;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,aAAa,GAAG,aAAa,GAAG,YAAY,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,cAAc,GAAG,qBAAqB,GAAG,YAAY,cAAc,aAAa,GAAG,iBAAiB,GAAG,qBAAqB,GAAG,cAAc,GAAG,oBAAoB;AAC9S,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA,IAAI;AACJ,sBAAsB,UAAU;AAChC,oBAAoB,yBAAyB;AAC7C;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,UAAU,GAAG,OAAO;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;;AAEnC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,UAAU;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,QAAQ;AACR,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO,EAAE,KAAK,EAAE,YAAY;AACnD,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,QAAQ;;AAE1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,oBAAoB,YAAY;;AAEhC;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA,6BAA6B,KAAK;AAClC;AACA,8BAA8B,QAAQ,EAAE;AACxC,8BAA8B,QAAQ,EAAE;;AAExC;AACA,kCAAkC,GAAG,GAAG,IAAI;AAC5C,uBAAuB,GAAG,GAAG,IAAI,oBAAoB,GAAG,QAAQ,QAAQ,iBAAiB,GAAG,QAAQ,QAAQ,IAAI;AAChH;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA,0CAA0C,WAAW,6BAA6B,WAAW,gCAAgC,WAAW,qBAAqB;AAC7J,2CAA2C,eAAe,EAAE;AAC5D;;AAEA;AACA,6BAA6B,WAAW,yBAAyB;AACjE;AACA,EAAE;AACF;AACA,8BAA8B,aAAa,IAAI,eAAe,EAAE;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA,sEAAsE;AACtE,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,uCAAuC;AACvC,uCAAuC;AACvC;;AAEA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,2CAA2C;AAC3C,8CAA8C;AAC9C,+BAA+B;AAC/B,yDAAyD;AACzD,yBAAyB;AACzB,aAAa;AACb;;AAEA;;AAEA;AACA,2BAA2B;AAC3B,gCAAgC;AAChC;;AAEA;;AAEA;AACA,6FAA6F;AAC7F,IAAI;AACJ,2CAA2C;AAC3C;;AAEA;AACA;AACA,wDAAwD,0CAA0C;AAClG,+GAA+G;AAC/G,+CAA+C;AAC/C,KAAK;AACL,+CAA+C;AAC/C;AACA,IAAI;AACJ,uCAAuC;;AAEvC;AACA,oCAAoC;AACpC;AACA,IAAI;AACJ,oFAAoF;AACpF,IAAI;AACJ;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;;AAElD;AACA,iCAAiC;AACjC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,uCAAuC;AACvC;AACA,qFAAqF;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C,8CAA8C;AAC9C,KAAK;AACL;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA,uDAAuD;AACvD;;AAEA;AACA,8CAA8C;AAC9C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mGAAmG;AACnG;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B;AAC5B,iCAAiC;AACjC;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iCAAiC;AACjC;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B;AAC5B,iCAAiC;AACjC;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE,oEAAoE;AACpE;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA,mDAAmD;AACnD,KAAK;AACL,kDAAkD;AAClD,iDAAiD;;AAEjD;AACA,oDAAoD;AACpD,0DAA0D;AAC1D,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA,mDAAmD;AACnD,oDAAoD;AACpD;;AAEA;AACA,sDAAsD;;AAEtD;AACA,iEAAiE;AACjE,qEAAqE;AACrE,8DAA8D;AAC9D;;AAEA;AACA,uDAAuD;AACvD,MAAM;AACN;AACA,uDAAuD;AACvD;;AAEA;AACA,2DAA2D;AAC3D,MAAM;AACN;AACA,gEAAgE;AAChE,OAAO;AACP,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD,4DAA4D;AAC5D,oGAAoG;AACpG;AACA,MAAM;AACN;AACA,uDAAuD;AACvD,4DAA4D;AAC5D,oGAAoG;;AAEpG;AACA,yDAAyD;AACzD,yDAAyD;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS,eAAe,SAAS;;AAEhF;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4EAA4E;;AAE5E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sFAAsF;AACtF;;AAEA;AACA;AACA;AACA,oJAAoJ;AACpJ,MAAM;AACN,qDAAqD;AACrD;AACA,KAAK;AACL;AACA,yIAAyI;AACzI,MAAM;AACN,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA,sIAAsI;AACtI,yIAAyI;AACzI,MAAM;AACN,sCAAsC;AACtC,wCAAwC;AACxC;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B;AAC3B,IAAI;AACJ;AACA;AACA,KAAK;AACL,4BAA4B;;AAE5B;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B;;AAE3B;AACA,wBAAwB;AACxB;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA,4BAA4B;;AAE5B;AACA,kCAAkC;AAClC;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA,4BAA4B;AAC5B;AACA;;AAEA,yBAAyB;;AAEzB;AACA,6BAA6B;AAC7B,uCAAuC;AACvC,mCAAmC;AACnC;;AAEA;AACA,+BAA+B;AAC/B,wDAAwD;;AAExD;AACA;AACA,iDAAiD;AACjD;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA,yDAAyD;AACzD;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;;AAEA;AACA,wBAAwB;AACxB;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA,+BAA+B;AAC/B;;AAEA;AACA,iDAAiD;AACjD,+CAA+C;AAC/C,8CAA8C;AAC9C,uFAAuF;AACvF,oCAAoC;AACpC;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iIAAiI;AACjI;;AAEA;AACA,0DAA0D;AAC1D,6BAA6B;AAC7B,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;;AAEA;AACA;AACA,mVAAmV;AACnV,QAAQ;AACR,2JAA2J;AAC3J;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA,QAAQ;AACR,uEAAuE;AACvE;AACA;AACA,OAAO;AACP,kEAAkE;AAClE;AACA;;AAEA,uCAAuC;;AAEvC;AACA;AACA,oIAAoI;AACpI;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C,OAAO;AACP,yEAAyE;AACzE;AACA,MAAM;AACN,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,kFAAkF;;AAElF;AACA,0EAA0E;AAC1E;;AAEA;AACA,QAAQ;AACR,oCAAoC,EAAE;AACtC,sCAAsC,EAAE;AACxC;AACA;AACA,iKAAiK;AACjK;AACA;AACA;;AAEA;AACA;AACA,qJAAqJ;AACrJ,OAAO;AACP,yHAAyH;AACzH;AACA,MAAM;AACN;AACA,yIAAyI;AACzI,OAAO;AACP,6GAA6G;AAC7G;AACA;;AAEA;AACA,mMAAmM;AACnM,6LAA6L;AAC7L,MAAM;AACN;AACA,iLAAiL;AACjL,2KAA2K;AAC3K,OAAO;AACP,iKAAiK;AACjK,4JAA4J;AAC5J;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA,oIAAoI;AACpI,oKAAoK;AACpK,2EAA2E;AAC3E;;AAEA,yCAAyC;AACzC;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,qDAAqD;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oEAAoE;AACpE,sDAAsD;AACtD,4DAA4D;AAC5D,gEAAgE;AAChE,8DAA8D;AAC9D,0EAA0E;AAC1E,gEAAgE;AAChE,kEAAkE;AAClE,gEAAgE;AAChE,gEAAgE;AAChE,wEAAwE;AACxE,0EAA0E;AAC1E,0EAA0E;AAC1E,kEAAkE;AAClE,kEAAkE;AAClE,sEAAsE;AACtE,kEAAkE;AAClE,sEAAsE;AACtE,kFAAkF;AAClF,gEAAgE;AAChE,qEAAqE;AACrE,2DAA2D;AAC3D,2DAA2D;AAC3D,6DAA6D;AAC7D,4DAA4D;AAC5D,qDAAqD;AACrD,wDAAwD;AACxD,sEAAsE;AACtE,gEAAgE;AAChE,kEAAkE;AAClE,4EAA4E;AAC5E,yEAAyE;AACzE,qFAAqF;AACrF,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,gCAAgC,WAAW,GAAG,kBAAkB;AAChE;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA,8BAA8B,WAAW,GAAG,cAAc;AAC1D;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA,4BAA4B,WAAW,GAAG,cAAc,GAAG,kBAAkB;AAC7E;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C,6BAA6B,kBAAkB;AAC/C,6BAA6B,qCAAqC;AAClE,mCAAmC,qCAAqC;AACxE;AACA,sBAAsB,YAAY,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW;AACxG;AACA;;AAEA;AACA,0CAA0C,YAAY,6BAA6B,WAAW,6BAA6B,WAAW,6BAA6B,WAAW,6BAA6B,WAAW,6BAA6B,WAAW;AAC9P;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAmD,QAAQ,IAAI,yBAAyB;AACxF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,8BAA8B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;;AAEA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;;AAEA,mBAAmB,iCAAiC;AACpD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,4BAA4B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qIAAqI;;AAErI;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,UAAU;;AAEpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,UAAU;;AAEpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;;AAEF;AACA;AACA,YAAY,KAAK;AACjB;AACA,GAAG;AACH;;AAEA;AACA;AACA,YAAY,KAAK;AACjB;AACA,GAAG;;AAEH;AACA;AACA,aAAa,KAAK;AAClB;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB;AACA,GAAG;AACH;;AAEA,sBAAsB,KAAK;AAC3B,sBAAsB,KAAK;AAC3B,wBAAwB,KAAK;AAC7B,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA,IAAI;AACJ,qBAAqB,aAAa;AAClC;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE,0EAA0E;AAC1E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,yFAAyF,MAAM,MAAM,KAAK;AAC1G;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,2GAA2G;AAC3G;AACA;;AAEA,kBAAkB,qCAAqC;AACvD;AACA;;AAEA,eAAe;AACf,iDAAiD;AACjD;AACA,uHAAuH;AACvH;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,uBAAuB;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,iCAAiC;AACvD,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,8BAA8B;AACjD;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,YAAY,aAAa,QAAQ,IAAI,KAAK;AAClF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C,UAAU;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA,iBAAiB,cAAc;AAC/B,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,UAAU;AAC9B,kBAAkB,cAAc;AAChC,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,WAAW;AAC/B;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,sBAAsB,eAAe;AACrC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,mBAAmB,mCAAmC;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,qBAAqB;AACzC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,qBAAqB;AACzC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mCAAmC;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,+BAA+B;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,6BAA6B;AAChD;AACA;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;;AAEA,mBAAmB,+BAA+B;AAClD;AACA;;AAEA,mBAAmB,8BAA8B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,+BAA+B;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,cAAc;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,oCAAoC;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,gCAAgC;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC,yBAAyB,WAAW;AACpC,0BAA0B,WAAW;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4HAA4H,OAAO;AACnI;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sBAAsB,kBAAkB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA,uBAAuB,oBAAoB;AAC3C,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,UAAU,GAAG,WAAW,GAAG,WAAW;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,6CAA6C,iCAAiC;AAC9E,qBAAqB,mBAAmB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,aAAa;AACjC;AACA;;AAEA;AACA;;AAEA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,+CAA+C;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;;AAEA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;;AAEA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,QAAQ;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,6BAA6B;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG,IAAI;AACJ;AACA;AACA;AACA,kHAAkH;AAClH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,2BAA2B;;AAEjD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,kCAAkC;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sDAAsD;AAC7E;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;;AAEA,mBAAmB,wBAAwB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA,mBAAmB,4BAA4B;AAC/C;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,4DAA4D;AACnG;;AAEA,kBAAkB,iBAAiB;AACnC,qEAAqE;AACrE;;AAEA,uCAAuC,6CAA6C;;AAEpF,kBAAkB,iBAAiB;AACnC,yGAAyG;AACzG;;AAEA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,gCAAgC;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,uBAAuB;AAC7C,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,SAAS;AACpE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;;AAEA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,yCAAyC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,oBAAoB;AAClC;AACA;;AAEA,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,aAAa,kCAAkC;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA,cAAc,yCAAyC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,iBAAiB;AAChC,gBAAgB,UAAU;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,eAAe;AAC7B,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,cAAc,eAAe;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;;AAEA;AACA,0EAA0E,0EAA0E,wCAAwC,wBAAwB,+DAA+D,6FAA6F,kFAAkF,oDAAoD,mCAAmC,KAAK;AAC9hB,2EAA2E,6EAA6E,yCAAyC,+BAA+B,mEAAmE,mGAAmG,mFAAmF,yFAAyF,iBAAiB;AACnkB,6FAA6F,mFAAmF,iDAAiD,yBAAyB,0EAA0E,uGAAuG,mFAAmF,sDAAsD,oCAAoC,KAAK;AAC7lB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B,gBAAgB,UAAU;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mCAAmC;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,uBAAuB;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAmB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;;AAEA,mBAAmB,8BAA8B;AACjD;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,WAAW;AAC7B;;AAEA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qFAAqF,mBAAmB;AACxG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,6BAA6B;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,MAAM;AACN,KAAK;AACL,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,cAAc,GAAG,IAAI;AACvE,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,cAAc,GAAG,IAAI;AAC5E,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;;AAEA,oBAAoB,kCAAkC;AACtD;;AAEA;AACA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,cAAc,GAAG,IAAI;AACnF,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,IAAI;AACJ;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,+CAA+C,cAAc,GAAG,IAAI;AACpE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,qBAAqB;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,4CAA4C,cAAc,GAAG,IAAI;AACjE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,kBAAkB,sCAAsC;AACxD;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;;AAEA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG,IAAI;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,MAAM;AACN,8CAA8C,cAAc,GAAG,IAAI;AACnE;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,+BAA+B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,kCAAkC;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,cAAc,GAAG,IAAI;AAC9D;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,qBAAqB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;AACA;;AAEA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA,eAAe,0BAA0B;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,0BAA0B;AACzC;AACA;;AAEA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,oCAAoC;AAClF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,uBAAuB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA,gBAAgB,kCAAkC;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,iBAAiB,gCAAgC;AACjD;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA,eAAe,uBAAuB;AACtC;;AAEA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,8BAA8B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAc,4BAA4B;AAC1C;AACA;;AAEA,eAAe,yCAAyC;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,6BAA6B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,6BAA6B;AAC5C;AACA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,+BAA+B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,6BAA6B;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,0BAA0B;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,qCAAqC,cAAc,GAAG,IAAI;AAC1D;AACA,GAAG;AACH;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,gCAAgC;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,gCAAgC;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAE;AACF,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,MAAM;AACN;;AAEA,qBAAqB,iCAAiC;;AAEtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,+CAA+C,cAAc,GAAG,IAAI;AACpE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,KAAK,QAAQ,OAAO,SAAS,QAAQ,SAAS,OAAO;AACxG;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,KAAK,QAAQ,OAAO,SAAS,QAAQ,SAAS,QAAQ,SAAS,OAAO;AACzH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,IAAI;AAC5D,KAAK;AACL,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA,+CAA+C,WAAW;AAC1D;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gDAAgD,YAAY,kBAAkB,WAAW;AACzF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL,6CAA6C,YAAY;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,kDAAkD;AAC9E;;AAEA;AACA;AACA;;AAEA;;AAEA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oCAAoC;AACtD;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC,mBAAmB,kBAAkB;AACrC,oBAAoB,OAAO;AAC3B;;AAEA,sBAAsB,SAAS;AAC/B,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,2BAA2B;AACrE;AACA;;AAEA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,sCAAsC;AAC3D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,kCAAkC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,OAAO;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,UAAU;AAC3C,IAAI;AACJ;;AAEA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,gBAAgB;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gBAAgB,uBAAuB,IAAI;AAChE;;AAEA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,KAAK;AACxB;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,WAAW,uBAAuB,IAAI;AAC7D;AACA;;AAEA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qDAAqD,EAAE,EAAE,IAAI;AAClE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;;AAEA,qBAAqB,SAAS;;AAE9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,8BAA8B;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,8BAA8B;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,WAAW,gCAAgC,iBAAiB;AACvF,IAAI;AACJ;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,kDAAkD,WAAW;AAC7D;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,0CAA0C;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,mBAAmB,4BAA4B;;AAE/C,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,0CAA0C,SAAS;AACnD;;AAEA;AACA,sDAAsD,EAAE;AACxD;;AAEA;AACA,sDAAsD,EAAE;AACxD;;AAEA;AACA,8CAA8C,EAAE;AAChD;;AAEA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,UAAU;AACjD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,qBAAqB;AACzC;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,gBAAgB,wBAAwB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA,mBAAmB,8BAA8B;AACjD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,oCAAoC;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,mBAAmB,mCAAmC;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA,IAAI;AACJ,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,aAAa;AAC/B,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,8DAA8D,GAAG,UAAU,GAAG,oEAAoE;AAC9J;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,kBAAkB;AACzC,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,6DAA6D,qDAAqD;AAClH;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,mCAAmC;AACtD;AACA;;AAEA;AACA;AACA,IAAI;AACJ,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mCAAmC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qCAAqC;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,gCAAgC;AACtD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kCAAkC;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sBAAsB,EAAE,EAAE,EAAE;;AAE5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,EAAE,EAAE,EAAE;;AAE5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;;AAEA;AACA,wCAAwC;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,uCAAuC;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,uCAAuC;AACzD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kCAAkC;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA,mBAAmB,2CAA2C;AAC9D;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mCAAmC;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,2CAA2C;AAC/D;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;AACA;;AAEA;AACA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,oBAAoB,6BAA6B;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,UAAU,GAAG,UAAU;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,8BAA8B;AAChD;;AAEA,wCAAwC;AACxC;;AAEA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,qCAAqC;;AAErC,kBAAkB,yBAAyB;AAC3C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL,IAAI;AACJ,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,uCAAuC;AACzD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uCAAuC;AACzD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,mBAAmB,4BAA4B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,KAAK;AACL;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,GAAG;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD,GAAG;AACnD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR,uBAAuB,EAAE,EAAE,EAAE;AAC7B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,8DAA8D,KAAK;AACnE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;;AAEA,yBAAyB,UAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oDAAoD,SAAS;AAC7D;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,2CAA2C,2BAA2B;AACtE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mCAAmC;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,4BAA4B;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;;AAEA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD,YAAY;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;;AAEA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,IAAI;AACJ,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,eAAe;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;;AAEA;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAmB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;;AAEA;AACA,qBAAqB,mBAAmB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,qCAAqC;AACnE;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,SAAS;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC,wBAAwB,OAAO;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,cAAc;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;;AAEA;AACA,sBAAsB,iBAAiB;AACvC;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iDAAiD,SAAS;AAC1D;AACA;AACA;;AAEA;AACA,iCAAiC,0CAA0C;AAC3E;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C,SAAS;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,KAAK,mBAAmB,IAAI,SAAS,wCAAwC,GAAG,EAAE,kBAAkB;AAC9I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC,oCAAoC;AACpC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,yCAAyC;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,SAAS;AAC3D;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;;AAEA;;AAEA;AACA,mBAAmB,kCAAkC;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,KAAK,WAAW,WAAW;AAChE;;AAEA;AACA;;AAEA;AACA;AACA,yDAAyD,+CAA+C;AACxG,kCAAkC,gDAAgD;AAClF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,2FAA2F,wBAAwB;AACnH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,sBAAsB;AACpC;AACA;;AAEA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,sCAAsC;AACzE;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,0BAA0B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,QAAQ;AAC3C,IAAI;AACJ,gBAAgB,EAAE,IAAI,EAAE,IAAI,EAAE;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B,qBAAqB;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qEAAqE,KAAK;;AAE1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA,qEAAqE,OAAO;AAC5E,kFAAkF,mCAAmC;AACrH;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,gBAAgB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,gBAAgB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,+CAA+C,SAAS;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+CAA+C,SAAS;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,OAAO;AAClD;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,OAAO;AACpD;AACA;;AAEA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4DAA4D,KAAK;AACjE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC;AACD;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC;AACD;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2CAA2C,OAAO;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2CAA2C,OAAO;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEiqd;;;;;;;UCp3vEjqd;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack://dmdassc-game/./node_modules/@socket.io/component-emitter/index.js","webpack://dmdassc-game/./node_modules/backo2/index.js","webpack://dmdassc-game/./node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","webpack://dmdassc-game/./node_modules/debug/src/browser.js","webpack://dmdassc-game/./node_modules/debug/src/common.js","webpack://dmdassc-game/./node_modules/has-cors/index.js","webpack://dmdassc-game/./node_modules/matter-js/build/matter.js","webpack://dmdassc-game/./node_modules/ms/index.js","webpack://dmdassc-game/./node_modules/parseqs/index.js","webpack://dmdassc-game/./node_modules/parseuri/index.js","webpack://dmdassc-game/./index/index.ts","webpack://dmdassc-game/./src/client/camera.ts","webpack://dmdassc-game/./src/client/gameface.ts","webpack://dmdassc-game/./src/client/network.ts","webpack://dmdassc-game/./src/client/playcanvas/scripts/textScript.ts","webpack://dmdassc-game/./src/client/render.ts","webpack://dmdassc-game/./src/client/ui/ui.ts","webpack://dmdassc-game/./src/shared/component/collisionComponent.ts","webpack://dmdassc-game/./src/shared/component/component.ts","webpack://dmdassc-game/./src/shared/component/debugComponent.ts","webpack://dmdassc-game/./src/shared/component/npcBehaviourComponent.ts","webpack://dmdassc-game/./src/shared/component/playerComponent.ts","webpack://dmdassc-game/./src/shared/component/syncComponent.ts","webpack://dmdassc-game/./src/shared/component/transformComponent.ts","webpack://dmdassc-game/./src/shared/entityFactory.ts","webpack://dmdassc-game/./src/shared/entity/entity.ts","webpack://dmdassc-game/./src/shared/entity/entityChar.ts","webpack://dmdassc-game/./src/shared/entity/entityObject.ts","webpack://dmdassc-game/./src/shared/entity/entityPlayer.ts","webpack://dmdassc-game/./src/shared/eventEmitter.ts","webpack://dmdassc-game/./src/shared/game.ts","webpack://dmdassc-game/./src/shared/input.ts","webpack://dmdassc-game/./src/shared/inventoryManager.ts","webpack://dmdassc-game/./src/shared/packet.ts","webpack://dmdassc-game/./src/shared/world.ts","webpack://dmdassc-game/./src/shared/worldEvent.ts","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/index.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/md5.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/nil.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/parse.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/regex.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/rng.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/sha1.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v1.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v3.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v35.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v4.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/v5.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/validate.js","webpack://dmdassc-game/./node_modules/uuid/dist/esm-browser/version.js","webpack://dmdassc-game/./node_modules/yeast/index.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/globalThis.browser.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/index.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/socket.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transport.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/index.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/polling-xhr.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/polling.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/websocket.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js","webpack://dmdassc-game/./node_modules/engine.io-client/build/cjs/util.js","webpack://dmdassc-game/./node_modules/engine.io-parser/build/cjs/commons.js","webpack://dmdassc-game/./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js","webpack://dmdassc-game/./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js","webpack://dmdassc-game/./node_modules/engine.io-parser/build/cjs/index.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/index.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/manager.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/on.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/socket.js","webpack://dmdassc-game/./node_modules/socket.io-client/build/cjs/url.js","webpack://dmdassc-game/./node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/binary.js","webpack://dmdassc-game/./node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/index.js","webpack://dmdassc-game/./node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/is-binary.js","webpack://dmdassc-game/./node_modules/playcanvas/build/playcanvas.mjs","webpack://dmdassc-game/webpack/bootstrap","webpack://dmdassc-game/webpack/runtime/define property getters","webpack://dmdassc-game/webpack/runtime/global","webpack://dmdassc-game/webpack/runtime/hasOwnProperty shorthand","webpack://dmdassc-game/webpack/runtime/make namespace object","webpack://dmdassc-game/webpack/before-startup","webpack://dmdassc-game/webpack/startup","webpack://dmdassc-game/webpack/after-startup"],"sourcesContent":["\n/**\n * Expose `Emitter`.\n */\n\nexports.Emitter = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n","\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n","/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = typeof XMLHttpRequest !== 'undefined' &&\n    'withCredentials' in new XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n","/*!\n * matter-js 0.17.1 by @liabru\n * http://brm.io/matter-js/\n * License MIT\n * \n * The MIT License (MIT)\n * \n * Copyright (c) Liam Brummitt and contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Matter\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Matter\"] = factory();\n\telse\n\t\troot[\"Matter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 22);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Common` module contains utility functions that are common to all modules.\n*\n* @class Common\n*/\n\nvar Common = {};\n\nmodule.exports = Common;\n\n(function() {\n\n    Common._nextId = 0;\n    Common._seed = 0;\n    Common._nowStartTime = +(new Date());\n    Common._warnedOnce = {};\n    Common._decomp = null;\n    \n    /**\n     * Extends the object in the first argument using the object in the second argument.\n     * @method extend\n     * @param {} obj\n     * @param {boolean} deep\n     * @return {} obj extended\n     */\n    Common.extend = function(obj, deep) {\n        var argsStart,\n            args,\n            deepClone;\n\n        if (typeof deep === 'boolean') {\n            argsStart = 2;\n            deepClone = deep;\n        } else {\n            argsStart = 1;\n            deepClone = true;\n        }\n\n        for (var i = argsStart; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            if (source) {\n                for (var prop in source) {\n                    if (deepClone && source[prop] && source[prop].constructor === Object) {\n                        if (!obj[prop] || obj[prop].constructor === Object) {\n                            obj[prop] = obj[prop] || {};\n                            Common.extend(obj[prop], deepClone, source[prop]);\n                        } else {\n                            obj[prop] = source[prop];\n                        }\n                    } else {\n                        obj[prop] = source[prop];\n                    }\n                }\n            }\n        }\n        \n        return obj;\n    };\n\n    /**\n     * Creates a new clone of the object, if deep is true references will also be cloned.\n     * @method clone\n     * @param {} obj\n     * @param {bool} deep\n     * @return {} obj cloned\n     */\n    Common.clone = function(obj, deep) {\n        return Common.extend({}, deep, obj);\n    };\n\n    /**\n     * Returns the list of keys for the given object.\n     * @method keys\n     * @param {} obj\n     * @return {string[]} keys\n     */\n    Common.keys = function(obj) {\n        if (Object.keys)\n            return Object.keys(obj);\n\n        // avoid hasOwnProperty for performance\n        var keys = [];\n        for (var key in obj)\n            keys.push(key);\n        return keys;\n    };\n\n    /**\n     * Returns the list of values for the given object.\n     * @method values\n     * @param {} obj\n     * @return {array} Array of the objects property values\n     */\n    Common.values = function(obj) {\n        var values = [];\n        \n        if (Object.keys) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length; i++) {\n                values.push(obj[keys[i]]);\n            }\n            return values;\n        }\n        \n        // avoid hasOwnProperty for performance\n        for (var key in obj)\n            values.push(obj[key]);\n        return values;\n    };\n\n    /**\n     * Gets a value from `base` relative to the `path` string.\n     * @method get\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} The object at the given path\n     */\n    Common.get = function(obj, path, begin, end) {\n        path = path.split('.').slice(begin, end);\n\n        for (var i = 0; i < path.length; i += 1) {\n            obj = obj[path[i]];\n        }\n\n        return obj;\n    };\n\n    /**\n     * Sets a value on `base` relative to the given `path` string.\n     * @method set\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {} val The value to set\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} Pass through `val` for chaining\n     */\n    Common.set = function(obj, path, val, begin, end) {\n        var parts = path.split('.').slice(begin, end);\n        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\n        return val;\n    };\n\n    /**\n     * Shuffles the given array in-place.\n     * The function uses a seeded random generator.\n     * @method shuffle\n     * @param {array} array\n     * @return {array} array shuffled randomly\n     */\n    Common.shuffle = function(array) {\n        for (var i = array.length - 1; i > 0; i--) {\n            var j = Math.floor(Common.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n        return array;\n    };\n\n    /**\n     * Randomly chooses a value from a list with equal probability.\n     * The function uses a seeded random generator.\n     * @method choose\n     * @param {array} choices\n     * @return {object} A random choice object from the array\n     */\n    Common.choose = function(choices) {\n        return choices[Math.floor(Common.random() * choices.length)];\n    };\n\n    /**\n     * Returns true if the object is a HTMLElement, otherwise false.\n     * @method isElement\n     * @param {object} obj\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\n     */\n    Common.isElement = function(obj) {\n        if (typeof HTMLElement !== 'undefined') {\n            return obj instanceof HTMLElement;\n        }\n\n        return !!(obj && obj.nodeType && obj.nodeName);\n    };\n\n    /**\n     * Returns true if the object is an array.\n     * @method isArray\n     * @param {object} obj\n     * @return {boolean} True if the object is an array, otherwise false\n     */\n    Common.isArray = function(obj) {\n        return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n\n    /**\n     * Returns true if the object is a function.\n     * @method isFunction\n     * @param {object} obj\n     * @return {boolean} True if the object is a function, otherwise false\n     */\n    Common.isFunction = function(obj) {\n        return typeof obj === \"function\";\n    };\n\n    /**\n     * Returns true if the object is a plain object.\n     * @method isPlainObject\n     * @param {object} obj\n     * @return {boolean} True if the object is a plain object, otherwise false\n     */\n    Common.isPlainObject = function(obj) {\n        return typeof obj === 'object' && obj.constructor === Object;\n    };\n\n    /**\n     * Returns true if the object is a string.\n     * @method isString\n     * @param {object} obj\n     * @return {boolean} True if the object is a string, otherwise false\n     */\n    Common.isString = function(obj) {\n        return toString.call(obj) === '[object String]';\n    };\n    \n    /**\n     * Returns the given value clamped between a minimum and maximum value.\n     * @method clamp\n     * @param {number} value\n     * @param {number} min\n     * @param {number} max\n     * @return {number} The value clamped between min and max inclusive\n     */\n    Common.clamp = function(value, min, max) {\n        if (value < min)\n            return min;\n        if (value > max)\n            return max;\n        return value;\n    };\n    \n    /**\n     * Returns the sign of the given value.\n     * @method sign\n     * @param {number} value\n     * @return {number} -1 if negative, +1 if 0 or positive\n     */\n    Common.sign = function(value) {\n        return value < 0 ? -1 : 1;\n    };\n    \n    /**\n     * Returns the current timestamp since the time origin (e.g. from page load).\n     * The result is in milliseconds and will use high-resolution timing if available.\n     * @method now\n     * @return {number} the current timestamp in milliseconds\n     */\n    Common.now = function() {\n        if (typeof window !== 'undefined' && window.performance) {\n            if (window.performance.now) {\n                return window.performance.now();\n            } else if (window.performance.webkitNow) {\n                return window.performance.webkitNow();\n            }\n        }\n\n        if (Date.now) {\n            return Date.now();\n        }\n\n        return (new Date()) - Common._nowStartTime;\n    };\n    \n    /**\n     * Returns a random value between a minimum and a maximum value inclusive.\n     * The function uses a seeded random generator.\n     * @method random\n     * @param {number} min\n     * @param {number} max\n     * @return {number} A random number between min and max inclusive\n     */\n    Common.random = function(min, max) {\n        min = (typeof min !== \"undefined\") ? min : 0;\n        max = (typeof max !== \"undefined\") ? max : 1;\n        return min + _seededRandom() * (max - min);\n    };\n\n    var _seededRandom = function() {\n        // https://en.wikipedia.org/wiki/Linear_congruential_generator\n        Common._seed = (Common._seed * 9301 + 49297) % 233280;\n        return Common._seed / 233280;\n    };\n\n    /**\n     * Converts a CSS hex colour string into an integer.\n     * @method colorToNumber\n     * @param {string} colorString\n     * @return {number} An integer representing the CSS hex string\n     */\n    Common.colorToNumber = function(colorString) {\n        colorString = colorString.replace('#','');\n\n        if (colorString.length == 3) {\n            colorString = colorString.charAt(0) + colorString.charAt(0)\n                        + colorString.charAt(1) + colorString.charAt(1)\n                        + colorString.charAt(2) + colorString.charAt(2);\n        }\n\n        return parseInt(colorString, 16);\n    };\n\n    /**\n     * The console logging level to use, where each level includes all levels above and excludes the levels below.\n     * The default level is 'debug' which shows all console messages.  \n     *\n     * Possible level values are:\n     * - 0 = None\n     * - 1 = Debug\n     * - 2 = Info\n     * - 3 = Warn\n     * - 4 = Error\n     * @property Common.logLevel\n     * @type {Number}\n     * @default 1\n     */\n    Common.logLevel = 1;\n\n    /**\n     * Shows a `console.log` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method log\n     * @param ...objs {} The objects to log.\n     */\n    Common.log = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Shows a `console.info` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method info\n     * @param ...objs {} The objects to log.\n     */\n    Common.info = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\n            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method warn\n     * @param ...objs {} The objects to log.\n     */\n    Common.warn = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Uses `Common.warn` to log the given message one time only.\n     * @method warnOnce\n     * @param ...objs {} The objects to log.\n     */\n    Common.warnOnce = function() {\n        var message = Array.prototype.slice.call(arguments).join(' ');\n\n        if (!Common._warnedOnce[message]) {\n            Common.warn(message);\n            Common._warnedOnce[message] = true;\n        }\n    };\n\n    /**\n     * Shows a deprecated console warning when the function on the given object is called.\n     * The target function will be replaced with a new function that first shows the warning\n     * and then calls the original function.\n     * @method deprecated\n     * @param {object} obj The object or module\n     * @param {string} name The property name of the function on obj\n     * @param {string} warning The one-time message to show if the function is called\n     */\n    Common.deprecated = function(obj, prop, warning) {\n        obj[prop] = Common.chain(function() {\n            Common.warnOnce(' deprecated ', warning);\n        }, obj[prop]);\n    };\n\n    /**\n     * Returns the next unique sequential ID.\n     * @method nextId\n     * @return {Number} Unique sequential ID\n     */\n    Common.nextId = function() {\n        return Common._nextId++;\n    };\n\n    /**\n     * A cross browser compatible indexOf implementation.\n     * @method indexOf\n     * @param {array} haystack\n     * @param {object} needle\n     * @return {number} The position of needle in haystack, otherwise -1.\n     */\n    Common.indexOf = function(haystack, needle) {\n        if (haystack.indexOf)\n            return haystack.indexOf(needle);\n\n        for (var i = 0; i < haystack.length; i++) {\n            if (haystack[i] === needle)\n                return i;\n        }\n\n        return -1;\n    };\n\n    /**\n     * A cross browser compatible array map implementation.\n     * @method map\n     * @param {array} list\n     * @param {function} func\n     * @return {array} Values from list transformed by func.\n     */\n    Common.map = function(list, func) {\n        if (list.map) {\n            return list.map(func);\n        }\n\n        var mapped = [];\n\n        for (var i = 0; i < list.length; i += 1) {\n            mapped.push(func(list[i]));\n        }\n\n        return mapped;\n    };\n\n    /**\n     * Takes a directed graph and returns the partially ordered set of vertices in topological order.\n     * Circular dependencies are allowed.\n     * @method topologicalSort\n     * @param {object} graph\n     * @return {array} Partially ordered set of vertices in topological order.\n     */\n    Common.topologicalSort = function(graph) {\n        // https://github.com/mgechev/javascript-algorithms\n        // Copyright (c) Minko Gechev (MIT license)\n        // Modifications: tidy formatting and naming\n        var result = [],\n            visited = [],\n            temp = [];\n\n        for (var node in graph) {\n            if (!visited[node] && !temp[node]) {\n                Common._topologicalSort(node, visited, temp, graph, result);\n            }\n        }\n\n        return result;\n    };\n\n    Common._topologicalSort = function(node, visited, temp, graph, result) {\n        var neighbors = graph[node] || [];\n        temp[node] = true;\n\n        for (var i = 0; i < neighbors.length; i += 1) {\n            var neighbor = neighbors[i];\n\n            if (temp[neighbor]) {\n                // skip circular dependencies\n                continue;\n            }\n\n            if (!visited[neighbor]) {\n                Common._topologicalSort(neighbor, visited, temp, graph, result);\n            }\n        }\n\n        temp[node] = false;\n        visited[node] = true;\n\n        result.push(node);\n    };\n\n    /**\n     * Takes _n_ functions as arguments and returns a new function that calls them in order.\n     * The arguments applied when calling the new function will also be applied to every function passed.\n     * The value of `this` refers to the last value returned in the chain that was not `undefined`.\n     * Therefore if a passed function does not return a value, the previously returned value is maintained.\n     * After all passed functions have been called the new function returns the last returned value (if any).\n     * If any of the passed functions are a chain, then the chain will be flattened.\n     * @method chain\n     * @param ...funcs {function} The functions to chain.\n     * @return {function} A new function that calls the passed functions in order.\n     */\n    Common.chain = function() {\n        var funcs = [];\n\n        for (var i = 0; i < arguments.length; i += 1) {\n            var func = arguments[i];\n\n            if (func._chained) {\n                // flatten already chained functions\n                funcs.push.apply(funcs, func._chained);\n            } else {\n                funcs.push(func);\n            }\n        }\n\n        var chain = function() {\n            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\n            var lastResult,\n                args = new Array(arguments.length);\n\n            for (var i = 0, l = arguments.length; i < l; i++) {\n                args[i] = arguments[i];\n            }\n\n            for (i = 0; i < funcs.length; i += 1) {\n                var result = funcs[i].apply(lastResult, args);\n\n                if (typeof result !== 'undefined') {\n                    lastResult = result;\n                }\n            }\n\n            return lastResult;\n        };\n\n        chain._chained = funcs;\n\n        return chain;\n    };\n\n    /**\n     * Chains a function to excute before the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathBefore\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain before the original\n     * @return {function} The chained function that replaced the original\n     */\n    Common.chainPathBefore = function(base, path, func) {\n        return Common.set(base, path, Common.chain(\n            func,\n            Common.get(base, path)\n        ));\n    };\n\n    /**\n     * Chains a function to excute after the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathAfter\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain after the original\n     * @return {function} The chained function that replaced the original\n     */\n    Common.chainPathAfter = function(base, path, func) {\n        return Common.set(base, path, Common.chain(\n            Common.get(base, path),\n            func\n        ));\n    };\n\n    /**\n     * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable\n     * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require('poly-decomp'))`.\n     * @method setDecomp\n     * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module.\n     */\n    Common.setDecomp = function(decomp) {\n        Common._decomp = decomp;\n    };\n\n    /**\n     * Returns the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module provided through `Common.setDecomp`,\n     * otherwise returns the global `decomp` if set.\n     * @method getDecomp\n     * @return {} The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module if provided.\n     */\n    Common.getDecomp = function() {\n        // get user provided decomp if set\n        var decomp = Common._decomp;\n\n        try {\n            // otherwise from window global\n            if (!decomp && typeof window !== 'undefined') {\n                decomp = window.decomp;\n            }\n    \n            // otherwise from node global\n            if (!decomp && typeof global !== 'undefined') {\n                decomp = global.decomp;\n            }\n        } catch (e) {\n            // decomp not available\n            decomp = null;\n        }\n\n        return decomp;\n    };\n})();\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\n*\n* @class Bounds\n*/\n\nvar Bounds = {};\n\nmodule.exports = Bounds;\n\n(function() {\n\n    /**\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\n     * @method create\n     * @param {vertices} vertices\n     * @return {bounds} A new bounds object\n     */\n    Bounds.create = function(vertices) {\n        var bounds = { \n            min: { x: 0, y: 0 }, \n            max: { x: 0, y: 0 }\n        };\n\n        if (vertices)\n            Bounds.update(bounds, vertices);\n        \n        return bounds;\n    };\n\n    /**\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\n     * @method update\n     * @param {bounds} bounds\n     * @param {vertices} vertices\n     * @param {vector} velocity\n     */\n    Bounds.update = function(bounds, vertices, velocity) {\n        bounds.min.x = Infinity;\n        bounds.max.x = -Infinity;\n        bounds.min.y = Infinity;\n        bounds.max.y = -Infinity;\n\n        for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n        }\n        \n        if (velocity) {\n            if (velocity.x > 0) {\n                bounds.max.x += velocity.x;\n            } else {\n                bounds.min.x += velocity.x;\n            }\n            \n            if (velocity.y > 0) {\n                bounds.max.y += velocity.y;\n            } else {\n                bounds.min.y += velocity.y;\n            }\n        }\n    };\n\n    /**\n     * Returns true if the bounds contains the given point.\n     * @method contains\n     * @param {bounds} bounds\n     * @param {vector} point\n     * @return {boolean} True if the bounds contain the point, otherwise false\n     */\n    Bounds.contains = function(bounds, point) {\n        return point.x >= bounds.min.x && point.x <= bounds.max.x \n               && point.y >= bounds.min.y && point.y <= bounds.max.y;\n    };\n\n    /**\n     * Returns true if the two bounds intersect.\n     * @method overlaps\n     * @param {bounds} boundsA\n     * @param {bounds} boundsB\n     * @return {boolean} True if the bounds overlap, otherwise false\n     */\n    Bounds.overlaps = function(boundsA, boundsB) {\n        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x\n                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);\n    };\n\n    /**\n     * Translates the bounds by the given vector.\n     * @method translate\n     * @param {bounds} bounds\n     * @param {vector} vector\n     */\n    Bounds.translate = function(bounds, vector) {\n        bounds.min.x += vector.x;\n        bounds.max.x += vector.x;\n        bounds.min.y += vector.y;\n        bounds.max.y += vector.y;\n    };\n\n    /**\n     * Shifts the bounds to the given position.\n     * @method shift\n     * @param {bounds} bounds\n     * @param {vector} position\n     */\n    Bounds.shift = function(bounds, position) {\n        var deltaX = bounds.max.x - bounds.min.x,\n            deltaY = bounds.max.y - bounds.min.y;\n            \n        bounds.min.x = position.x;\n        bounds.max.x = position.x + deltaX;\n        bounds.min.y = position.y;\n        bounds.max.y = position.y + deltaY;\n    };\n    \n})();\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\n* Vectors are the basis of all the geometry related operations in the engine.\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vector\n*/\n\n// TODO: consider params for reusing vector objects\n\nvar Vector = {};\n\nmodule.exports = Vector;\n\n(function() {\n\n    /**\n     * Creates a new vector.\n     * @method create\n     * @param {number} x\n     * @param {number} y\n     * @return {vector} A new vector\n     */\n    Vector.create = function(x, y) {\n        return { x: x || 0, y: y || 0 };\n    };\n\n    /**\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\n     * @method clone\n     * @param {vector} vector\n     * @return {vector} A new cloned vector\n     */\n    Vector.clone = function(vector) {\n        return { x: vector.x, y: vector.y };\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector.\n     * @method magnitude\n     * @param {vector} vector\n     * @return {number} The magnitude of the vector\n     */\n    Vector.magnitude = function(vector) {\n        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\n     * @method magnitudeSquared\n     * @param {vector} vector\n     * @return {number} The squared magnitude of the vector\n     */\n    Vector.magnitudeSquared = function(vector) {\n        return (vector.x * vector.x) + (vector.y * vector.y);\n    };\n\n    /**\n     * Rotates the vector about (0, 0) by specified angle.\n     * @method rotate\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} [output]\n     * @return {vector} The vector rotated about (0, 0)\n     */\n    Vector.rotate = function(vector, angle, output) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        if (!output) output = {};\n        var x = vector.x * cos - vector.y * sin;\n        output.y = vector.x * sin + vector.y * cos;\n        output.x = x;\n        return output;\n    };\n\n    /**\n     * Rotates the vector about a specified point by specified angle.\n     * @method rotateAbout\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} point\n     * @param {vector} [output]\n     * @return {vector} A new vector rotated about the point\n     */\n    Vector.rotateAbout = function(vector, angle, point, output) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        if (!output) output = {};\n        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);\n        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);\n        output.x = x;\n        return output;\n    };\n\n    /**\n     * Normalises a vector (such that its magnitude is `1`).\n     * @method normalise\n     * @param {vector} vector\n     * @return {vector} A new vector normalised\n     */\n    Vector.normalise = function(vector) {\n        var magnitude = Vector.magnitude(vector);\n        if (magnitude === 0)\n            return { x: 0, y: 0 };\n        return { x: vector.x / magnitude, y: vector.y / magnitude };\n    };\n\n    /**\n     * Returns the dot-product of two vectors.\n     * @method dot\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The dot product of the two vectors\n     */\n    Vector.dot = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);\n    };\n\n    /**\n     * Returns the cross-product of two vectors.\n     * @method cross\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The cross product of the two vectors\n     */\n    Vector.cross = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);\n    };\n\n    /**\n     * Returns the cross-product of three vectors.\n     * @method cross3\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} vectorC\n     * @return {number} The cross product of the three vectors\n     */\n    Vector.cross3 = function(vectorA, vectorB, vectorC) {\n        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);\n    };\n\n    /**\n     * Adds the two vectors.\n     * @method add\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB added\n     */\n    Vector.add = function(vectorA, vectorB, output) {\n        if (!output) output = {};\n        output.x = vectorA.x + vectorB.x;\n        output.y = vectorA.y + vectorB.y;\n        return output;\n    };\n\n    /**\n     * Subtracts the two vectors.\n     * @method sub\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB subtracted\n     */\n    Vector.sub = function(vectorA, vectorB, output) {\n        if (!output) output = {};\n        output.x = vectorA.x - vectorB.x;\n        output.y = vectorA.y - vectorB.y;\n        return output;\n    };\n\n    /**\n     * Multiplies a vector and a scalar.\n     * @method mult\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector multiplied by scalar\n     */\n    Vector.mult = function(vector, scalar) {\n        return { x: vector.x * scalar, y: vector.y * scalar };\n    };\n\n    /**\n     * Divides a vector and a scalar.\n     * @method div\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector divided by scalar\n     */\n    Vector.div = function(vector, scalar) {\n        return { x: vector.x / scalar, y: vector.y / scalar };\n    };\n\n    /**\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\n     * @method perp\n     * @param {vector} vector\n     * @param {bool} [negate=false]\n     * @return {vector} The perpendicular vector\n     */\n    Vector.perp = function(vector, negate) {\n        negate = negate === true ? -1 : 1;\n        return { x: negate * -vector.y, y: negate * vector.x };\n    };\n\n    /**\n     * Negates both components of a vector such that it points in the opposite direction.\n     * @method neg\n     * @param {vector} vector\n     * @return {vector} The negated vector\n     */\n    Vector.neg = function(vector) {\n        return { x: -vector.x, y: -vector.y };\n    };\n\n    /**\n     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.\n     * @method angle\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The angle in radians\n     */\n    Vector.angle = function(vectorA, vectorB) {\n        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\n    };\n\n    /**\n     * Temporary vector pool (not thread-safe).\n     * @property _temp\n     * @type {vector[]}\n     * @private\n     */\n    Vector._temp = [\n        Vector.create(), Vector.create(), \n        Vector.create(), Vector.create(), \n        Vector.create(), Vector.create()\n    ];\n\n})();\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vertices\n*/\n\nvar Vertices = {};\n\nmodule.exports = Vertices;\n\nvar Vector = __webpack_require__(2);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new set of `Matter.Body` compatible vertices.\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\n     * but with some additional references required for efficient collision detection routines.\n     *\n     * Vertices must be specified in clockwise order.\n     *\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\n     *\n     * @method create\n     * @param {vector[]} points\n     * @param {body} body\n     */\n    Vertices.create = function(points, body) {\n        var vertices = [];\n\n        for (var i = 0; i < points.length; i++) {\n            var point = points[i],\n                vertex = {\n                    x: point.x,\n                    y: point.y,\n                    index: i,\n                    body: body,\n                    isInternal: false\n                };\n\n            vertices.push(vertex);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \n     * into a `Matter.Vertices` object for the given `Matter.Body`.\n     * For parsing SVG paths, see `Svg.pathToVertices`.\n     * @method fromPath\n     * @param {string} path\n     * @param {body} body\n     * @return {vertices} vertices\n     */\n    Vertices.fromPath = function(path, body) {\n        var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig,\n            points = [];\n\n        path.replace(pathPattern, function(match, x, y) {\n            points.push({ x: parseFloat(x), y: parseFloat(y) });\n        });\n\n        return Vertices.create(points, body);\n    };\n\n    /**\n     * Returns the centre (centroid) of the set of vertices.\n     * @method centre\n     * @param {vertices} vertices\n     * @return {vector} The centre point\n     */\n    Vertices.centre = function(vertices) {\n        var area = Vertices.area(vertices, true),\n            centre = { x: 0, y: 0 },\n            cross,\n            temp,\n            j;\n\n        for (var i = 0; i < vertices.length; i++) {\n            j = (i + 1) % vertices.length;\n            cross = Vector.cross(vertices[i], vertices[j]);\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n            centre = Vector.add(centre, temp);\n        }\n\n        return Vector.div(centre, 6 * area);\n    };\n\n    /**\n     * Returns the average (mean) of the set of vertices.\n     * @method mean\n     * @param {vertices} vertices\n     * @return {vector} The average point\n     */\n    Vertices.mean = function(vertices) {\n        var average = { x: 0, y: 0 };\n\n        for (var i = 0; i < vertices.length; i++) {\n            average.x += vertices[i].x;\n            average.y += vertices[i].y;\n        }\n\n        return Vector.div(average, vertices.length);\n    };\n\n    /**\n     * Returns the area of the set of vertices.\n     * @method area\n     * @param {vertices} vertices\n     * @param {bool} signed\n     * @return {number} The area\n     */\n    Vertices.area = function(vertices, signed) {\n        var area = 0,\n            j = vertices.length - 1;\n\n        for (var i = 0; i < vertices.length; i++) {\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n            j = i;\n        }\n\n        if (signed)\n            return area / 2;\n\n        return Math.abs(area) / 2;\n    };\n\n    /**\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\n     * @method inertia\n     * @param {vertices} vertices\n     * @param {number} mass\n     * @return {number} The polygon's moment of inertia\n     */\n    Vertices.inertia = function(vertices, mass) {\n        var numerator = 0,\n            denominator = 0,\n            v = vertices,\n            cross,\n            j;\n\n        // find the polygon's moment of inertia, using second moment of area\n        // from equations at http://www.physicsforums.com/showthread.php?t=25293\n        for (var n = 0; n < v.length; n++) {\n            j = (n + 1) % v.length;\n            cross = Math.abs(Vector.cross(v[j], v[n]));\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n            denominator += cross;\n        }\n\n        return (mass / 6) * (numerator / denominator);\n    };\n\n    /**\n     * Translates the set of vertices in-place.\n     * @method translate\n     * @param {vertices} vertices\n     * @param {vector} vector\n     * @param {number} scalar\n     */\n    Vertices.translate = function(vertices, vector, scalar) {\n        var i;\n        if (scalar) {\n            for (i = 0; i < vertices.length; i++) {\n                vertices[i].x += vector.x * scalar;\n                vertices[i].y += vector.y * scalar;\n            }\n        } else {\n            for (i = 0; i < vertices.length; i++) {\n                vertices[i].x += vector.x;\n                vertices[i].y += vector.y;\n            }\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Rotates the set of vertices in-place.\n     * @method rotate\n     * @param {vertices} vertices\n     * @param {number} angle\n     * @param {vector} point\n     */\n    Vertices.rotate = function(vertices, angle, point) {\n        if (angle === 0)\n            return;\n\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n\n        for (var i = 0; i < vertices.length; i++) {\n            var vertice = vertices[i],\n                dx = vertice.x - point.x,\n                dy = vertice.y - point.y;\n                \n            vertice.x = point.x + (dx * cos - dy * sin);\n            vertice.y = point.y + (dx * sin + dy * cos);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Returns `true` if the `point` is inside the set of `vertices`.\n     * @method contains\n     * @param {vertices} vertices\n     * @param {vector} point\n     * @return {boolean} True if the vertices contains point, otherwise false\n     */\n    Vertices.contains = function(vertices, point) {\n        for (var i = 0; i < vertices.length; i++) {\n            var vertice = vertices[i],\n                nextVertice = vertices[(i + 1) % vertices.length];\n            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Scales the vertices from a point (default is centre) in-place.\n     * @method scale\n     * @param {vertices} vertices\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     */\n    Vertices.scale = function(vertices, scaleX, scaleY, point) {\n        if (scaleX === 1 && scaleY === 1)\n            return vertices;\n\n        point = point || Vertices.centre(vertices);\n\n        var vertex,\n            delta;\n\n        for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            delta = Vector.sub(vertex, point);\n            vertices[i].x = point.x + delta.x * scaleX;\n            vertices[i].y = point.y + delta.y * scaleY;\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\n     * @method chamfer\n     * @param {vertices} vertices\n     * @param {number[]} radius\n     * @param {number} quality\n     * @param {number} qualityMin\n     * @param {number} qualityMax\n     */\n    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\n        if (typeof radius === 'number') {\n            radius = [radius];\n        } else {\n            radius = radius || [8];\n        }\n\n        // quality defaults to -1, which is auto\n        quality = (typeof quality !== 'undefined') ? quality : -1;\n        qualityMin = qualityMin || 2;\n        qualityMax = qualityMax || 14;\n\n        var newVertices = [];\n\n        for (var i = 0; i < vertices.length; i++) {\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\n                vertex = vertices[i],\n                nextVertex = vertices[(i + 1) % vertices.length],\n                currentRadius = radius[i < radius.length ? i : radius.length - 1];\n\n            if (currentRadius === 0) {\n                newVertices.push(vertex);\n                continue;\n            }\n\n            var prevNormal = Vector.normalise({ \n                x: vertex.y - prevVertex.y, \n                y: prevVertex.x - vertex.x\n            });\n\n            var nextNormal = Vector.normalise({ \n                x: nextVertex.y - vertex.y, \n                y: vertex.x - nextVertex.x\n            });\n\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\n                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\n                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\n                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n\n            var precision = quality;\n\n            if (quality === -1) {\n                // automatically decide precision\n                precision = Math.pow(currentRadius, 0.32) * 1.75;\n            }\n\n            precision = Common.clamp(precision, qualityMin, qualityMax);\n\n            // use an even value for precision, more likely to reduce axes by using symmetry\n            if (precision % 2 === 1)\n                precision += 1;\n\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\n                theta = alpha / precision;\n\n            for (var j = 0; j < precision; j++) {\n                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n            }\n        }\n\n        return newVertices;\n    };\n\n    /**\n     * Sorts the input vertices into clockwise order in place.\n     * @method clockwiseSort\n     * @param {vertices} vertices\n     * @return {vertices} vertices\n     */\n    Vertices.clockwiseSort = function(vertices) {\n        var centre = Vertices.mean(vertices);\n\n        vertices.sort(function(vertexA, vertexB) {\n            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n        });\n\n        return vertices;\n    };\n\n    /**\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\n     * @method isConvex\n     * @param {vertices} vertices\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\n     */\n    Vertices.isConvex = function(vertices) {\n        // http://paulbourke.net/geometry/polygonmesh/\n        // Copyright (c) Paul Bourke (use permitted)\n\n        var flag = 0,\n            n = vertices.length,\n            i,\n            j,\n            k,\n            z;\n\n        if (n < 3)\n            return null;\n\n        for (i = 0; i < n; i++) {\n            j = (i + 1) % n;\n            k = (i + 2) % n;\n            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n\n            if (z < 0) {\n                flag |= 1;\n            } else if (z > 0) {\n                flag |= 2;\n            }\n\n            if (flag === 3) {\n                return false;\n            }\n        }\n\n        if (flag !== 0){\n            return true;\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * Returns the convex hull of the input vertices as a new array of points.\n     * @method hull\n     * @param {vertices} vertices\n     * @return [vertex] vertices\n     */\n    Vertices.hull = function(vertices) {\n        // http://geomalgorithms.com/a10-_hull-1.html\n\n        var upper = [],\n            lower = [], \n            vertex,\n            i;\n\n        // sort vertices on x-axis (y-axis for ties)\n        vertices = vertices.slice(0);\n        vertices.sort(function(vertexA, vertexB) {\n            var dx = vertexA.x - vertexB.x;\n            return dx !== 0 ? dx : vertexA.y - vertexB.y;\n        });\n\n        // build lower hull\n        for (i = 0; i < vertices.length; i += 1) {\n            vertex = vertices[i];\n\n            while (lower.length >= 2 \n                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\n                lower.pop();\n            }\n\n            lower.push(vertex);\n        }\n\n        // build upper hull\n        for (i = vertices.length - 1; i >= 0; i -= 1) {\n            vertex = vertices[i];\n\n            while (upper.length >= 2 \n                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\n                upper.pop();\n            }\n\n            upper.push(vertex);\n        }\n\n        // concatenation of the lower and upper hulls gives the convex hull\n        // omit last points because they are repeated at the beginning of the other list\n        upper.pop();\n        lower.pop();\n\n        return upper.concat(lower);\n    };\n\n})();\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Events` module contains methods to fire and listen to events on other objects.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Events\n*/\n\nvar Events = {};\n\nmodule.exports = Events;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Subscribes a callback function to the given object's `eventName`.\n     * @method on\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.on = function(object, eventNames, callback) {\n        var names = eventNames.split(' '),\n            name;\n\n        for (var i = 0; i < names.length; i++) {\n            name = names[i];\n            object.events = object.events || {};\n            object.events[name] = object.events[name] || [];\n            object.events[name].push(callback);\n        }\n\n        return callback;\n    };\n\n    /**\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\n     * @method off\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.off = function(object, eventNames, callback) {\n        if (!eventNames) {\n            object.events = {};\n            return;\n        }\n\n        // handle Events.off(object, callback)\n        if (typeof eventNames === 'function') {\n            callback = eventNames;\n            eventNames = Common.keys(object.events).join(' ');\n        }\n\n        var names = eventNames.split(' ');\n\n        for (var i = 0; i < names.length; i++) {\n            var callbacks = object.events[names[i]],\n                newCallbacks = [];\n\n            if (callback && callbacks) {\n                for (var j = 0; j < callbacks.length; j++) {\n                    if (callbacks[j] !== callback)\n                        newCallbacks.push(callbacks[j]);\n                }\n            }\n\n            object.events[names[i]] = newCallbacks;\n        }\n    };\n\n    /**\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\n     * @method trigger\n     * @param {} object\n     * @param {string} eventNames\n     * @param {} event\n     */\n    Events.trigger = function(object, eventNames, event) {\n        var names,\n            name,\n            callbacks,\n            eventClone;\n\n        var events = object.events;\n        \n        if (events && Common.keys(events).length > 0) {\n            if (!event)\n                event = {};\n\n            names = eventNames.split(' ');\n\n            for (var i = 0; i < names.length; i++) {\n                name = names[i];\n                callbacks = events[name];\n\n                if (callbacks) {\n                    eventClone = Common.clone(event, false);\n                    eventClone.name = name;\n                    eventClone.source = object;\n\n                    for (var j = 0; j < callbacks.length; j++) {\n                        callbacks[j].apply(object, [eventClone]);\n                    }\n                }\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* A composite is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite` objects.\n*\n* They are a container that can represent complex objects made of multiple parts, even if they are not physically connected.\n* A composite could contain anything from a single body all the way up to a whole world.\n* \n* When making any changes to composites, use the included functions rather than changing their properties directly.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composite\n*/\n\nvar Composite = {};\n\nmodule.exports = Composite;\n\nvar Events = __webpack_require__(4);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\nvar Body = __webpack_require__(6);\n\n(function() {\n\n    /**\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} [options]\n     * @return {composite} A new composite\n     */\n    Composite.create = function(options) {\n        return Common.extend({ \n            id: Common.nextId(),\n            type: 'composite',\n            parent: null,\n            isModified: false,\n            bodies: [], \n            constraints: [], \n            composites: [],\n            label: 'Composite',\n            plugin: {}\n        }, options);\n    };\n\n    /**\n     * Sets the composite's `isModified` flag. \n     * If `updateParents` is true, all parents will be set (default: false).\n     * If `updateChildren` is true, all children will be set (default: false).\n     * @method setModified\n     * @param {composite} composite\n     * @param {boolean} isModified\n     * @param {boolean} [updateParents=false]\n     * @param {boolean} [updateChildren=false]\n     */\n    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\n        composite.isModified = isModified;\n\n        if (updateParents && composite.parent) {\n            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n        }\n\n        if (updateChildren) {\n            for(var i = 0; i < composite.composites.length; i++) {\n                var childComposite = composite.composites[i];\n                Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n            }\n        }\n    };\n\n    /**\n     * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\n     * @method add\n     * @param {composite} composite\n     * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s)\n     * @return {composite} The original composite with the objects added\n     */\n    Composite.add = function(composite, object) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeAdd', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                // skip adding compound parts\n                if (obj.parent !== obj) {\n                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\n                    break;\n                }\n\n                Composite.addBody(composite, obj);\n                break;\n            case 'constraint':\n                Composite.addConstraint(composite, obj);\n                break;\n            case 'composite':\n                Composite.addComposite(composite, obj);\n                break;\n            case 'mouseConstraint':\n                Composite.addConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterAdd', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\n     * Optionally searching its children recursively.\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\n     * @method remove\n     * @param {composite} composite\n     * @param {object|array} object\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the objects removed\n     */\n    Composite.remove = function(composite, object, deep) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeRemove', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                Composite.removeBody(composite, obj, deep);\n                break;\n            case 'constraint':\n                Composite.removeConstraint(composite, obj, deep);\n                break;\n            case 'composite':\n                Composite.removeComposite(composite, obj, deep);\n                break;\n            case 'mouseConstraint':\n                Composite.removeConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterRemove', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Adds a composite to the given composite.\n     * @private\n     * @method addComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @return {composite} The original compositeA with the objects from compositeB added\n     */\n    Composite.addComposite = function(compositeA, compositeB) {\n        compositeA.composites.push(compositeB);\n        compositeB.parent = compositeA;\n        Composite.setModified(compositeA, true, true, false);\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @param {boolean} [deep=false]\n     * @return {composite} The original compositeA with the composite removed\n     */\n    Composite.removeComposite = function(compositeA, compositeB, deep) {\n        var position = Common.indexOf(compositeA.composites, compositeB);\n        if (position !== -1) {\n            Composite.removeCompositeAt(compositeA, position);\n            Composite.setModified(compositeA, true, true, false);\n        }\n\n        if (deep) {\n            for (var i = 0; i < compositeA.composites.length; i++){\n                Composite.removeComposite(compositeA.composites[i], compositeB, true);\n            }\n        }\n\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite.\n     * @private\n     * @method removeCompositeAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the composite removed\n     */\n    Composite.removeCompositeAt = function(composite, position) {\n        composite.composites.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a body to the given composite.\n     * @private\n     * @method addBody\n     * @param {composite} composite\n     * @param {body} body\n     * @return {composite} The original composite with the body added\n     */\n    Composite.addBody = function(composite, body) {\n        composite.bodies.push(body);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeBody\n     * @param {composite} composite\n     * @param {body} body\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBody = function(composite, body, deep) {\n        var position = Common.indexOf(composite.bodies, body);\n        if (position !== -1) {\n            Composite.removeBodyAt(composite, position);\n            Composite.setModified(composite, true, true, false);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeBody(composite.composites[i], body, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeBodyAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBodyAt = function(composite, position) {\n        composite.bodies.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a constraint to the given composite.\n     * @private\n     * @method addConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @return {composite} The original composite with the constraint added\n     */\n    Composite.addConstraint = function(composite, constraint) {\n        composite.constraints.push(constraint);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraint = function(composite, constraint, deep) {\n        var position = Common.indexOf(composite.constraints, constraint);\n        if (position !== -1) {\n            Composite.removeConstraintAt(composite, position);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeConstraint(composite.composites[i], constraint, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeConstraintAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraintAt = function(composite, position) {\n        composite.constraints.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes all bodies, constraints and composites from the given composite.\n     * Optionally clearing its children recursively.\n     * @method clear\n     * @param {composite} composite\n     * @param {boolean} keepStatic\n     * @param {boolean} [deep=false]\n     */\n    Composite.clear = function(composite, keepStatic, deep) {\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.clear(composite.composites[i], keepStatic, true);\n            }\n        }\n        \n        if (keepStatic) {\n            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });\n        } else {\n            composite.bodies.length = 0;\n        }\n\n        composite.constraints.length = 0;\n        composite.composites.length = 0;\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\n     * @method allBodies\n     * @param {composite} composite\n     * @return {body[]} All the bodies\n     */\n    Composite.allBodies = function(composite) {\n        var bodies = [].concat(composite.bodies);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n\n        return bodies;\n    };\n\n    /**\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\n     * @method allConstraints\n     * @param {composite} composite\n     * @return {constraint[]} All the constraints\n     */\n    Composite.allConstraints = function(composite) {\n        var constraints = [].concat(composite.constraints);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n\n        return constraints;\n    };\n\n    /**\n     * Returns all composites in the given composite, including all composites in its children, recursively.\n     * @method allComposites\n     * @param {composite} composite\n     * @return {composite[]} All the composites\n     */\n    Composite.allComposites = function(composite) {\n        var composites = [].concat(composite.composites);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            composites = composites.concat(Composite.allComposites(composite.composites[i]));\n\n        return composites;\n    };\n\n    /**\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\n     * @method get\n     * @param {composite} composite\n     * @param {number} id\n     * @param {string} type\n     * @return {object} The requested object, if found\n     */\n    Composite.get = function(composite, id, type) {\n        var objects,\n            object;\n\n        switch (type) {\n        case 'body':\n            objects = Composite.allBodies(composite);\n            break;\n        case 'constraint':\n            objects = Composite.allConstraints(composite);\n            break;\n        case 'composite':\n            objects = Composite.allComposites(composite).concat(composite);\n            break;\n        }\n\n        if (!objects)\n            return null;\n\n        object = objects.filter(function(object) { \n            return object.id.toString() === id.toString(); \n        });\n\n        return object.length === 0 ? null : object[0];\n    };\n\n    /**\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\n     * @method move\n     * @param {compositeA} compositeA\n     * @param {object[]} objects\n     * @param {compositeB} compositeB\n     * @return {composite} Returns compositeA\n     */\n    Composite.move = function(compositeA, objects, compositeB) {\n        Composite.remove(compositeA, objects);\n        Composite.add(compositeB, objects);\n        return compositeA;\n    };\n\n    /**\n     * Assigns new ids for all objects in the composite, recursively.\n     * @method rebase\n     * @param {composite} composite\n     * @return {composite} Returns composite\n     */\n    Composite.rebase = function(composite) {\n        var objects = Composite.allBodies(composite)\n            .concat(Composite.allConstraints(composite))\n            .concat(Composite.allComposites(composite));\n\n        for (var i = 0; i < objects.length; i++) {\n            objects[i].id = Common.nextId();\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Translates all children in the composite by a given vector relative to their current positions, \n     * without imparting any velocity.\n     * @method translate\n     * @param {composite} composite\n     * @param {vector} translation\n     * @param {bool} [recursive=true]\n     */\n    Composite.translate = function(composite, translation, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            Body.translate(bodies[i], translation);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\n     * @method rotate\n     * @param {composite} composite\n     * @param {number} rotation\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.rotate = function(composite, rotation, point, recursive) {\n        var cos = Math.cos(rotation),\n            sin = Math.sin(rotation),\n            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            });\n\n            Body.rotate(body, rotation);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\n     * @method scale\n     * @param {composite} composite\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + dx * scaleX,\n                y: point.y + dy * scaleY\n            });\n\n            Body.scale(body, scaleX, scaleY);\n        }\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Returns the union of the bounds of all of the composite's bodies.\n     * @method bounds\n     * @param {composite} composite The composite.\n     * @returns {bounds} The composite bounds.\n     */\n    Composite.bounds = function(composite) {\n        var bodies = Composite.allBodies(composite),\n            vertices = [];\n\n        for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i];\n            vertices.push(body.bounds.min, body.bounds.max);\n        }\n\n        return Bounds.create(vertices);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, before objects have been added.\n    *\n    * @event beforeAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, after objects have been added.\n    *\n    * @event afterAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\n    *\n    * @event beforeRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\n    *\n    * @event afterRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"composite\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage composites.\n     *\n     * @property label\n     * @type string\n     * @default \"Composite\"\n     */\n\n    /**\n     * A flag that specifies whether the composite has been modified during the current step.\n     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.\n     * If you need to change it manually, you should use the `Composite.setModified` method.\n     *\n     * @property isModified\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\n     *\n     * @property parent\n     * @type composite\n     * @default null\n     */\n\n    /**\n     * An array of `Body` that are _direct_ children of this composite.\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\n     *\n     * @property bodies\n     * @type body[]\n     * @default []\n     */\n\n    /**\n     * An array of `Constraint` that are _direct_ children of this composite.\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\n     *\n     * @property constraints\n     * @type constraint[]\n     * @default []\n     */\n\n    /**\n     * An array of `Composite` that are _direct_ children of this composite.\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\n     *\n     * @property composites\n     * @type composite[]\n     * @default []\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n})();\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Body` module contains methods for creating and manipulating body models.\n* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.\n* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n\n* @class Body\n*/\n\nvar Body = {};\n\nmodule.exports = Body;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\nvar Sleeping = __webpack_require__(7);\nvar Render = __webpack_require__(16);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\nvar Axes = __webpack_require__(10);\n\n(function() {\n\n    Body._inertiaScale = 4;\n    Body._nextCollidingGroupId = 1;\n    Body._nextNonCollidingGroupId = -1;\n    Body._nextCategory = 0x0001;\n\n    /**\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * Vertices must be specified in clockwise order.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {body} body\n     */\n    Body.create = function(options) {\n        var defaults = {\n            id: Common.nextId(),\n            type: 'body',\n            label: 'Body',\n            parts: [],\n            plugin: {},\n            angle: 0,\n            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),\n            position: { x: 0, y: 0 },\n            force: { x: 0, y: 0 },\n            torque: 0,\n            positionImpulse: { x: 0, y: 0 },\n            constraintImpulse: { x: 0, y: 0, angle: 0 },\n            totalContacts: 0,\n            speed: 0,\n            angularSpeed: 0,\n            velocity: { x: 0, y: 0 },\n            angularVelocity: 0,\n            isSensor: false,\n            isStatic: false,\n            isSleeping: false,\n            motion: 0,\n            sleepThreshold: 60,\n            density: 0.001,\n            restitution: 0,\n            friction: 0.1,\n            frictionStatic: 0.5,\n            frictionAir: 0.01,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            },\n            slop: 0.05,\n            timeScale: 1,\n            render: {\n                visible: true,\n                opacity: 1,\n                strokeStyle: null,\n                fillStyle: null,\n                lineWidth: null,\n                sprite: {\n                    xScale: 1,\n                    yScale: 1,\n                    xOffset: 0,\n                    yOffset: 0\n                }\n            },\n            events: null,\n            bounds: null,\n            chamfer: null,\n            circleRadius: 0,\n            positionPrev: null,\n            anglePrev: 0,\n            parent: null,\n            axes: null,\n            area: 0,\n            mass: 0,\n            inertia: 0,\n            _original: null\n        };\n\n        var body = Common.extend(defaults, options);\n\n        _initProperties(body, options);\n\n        return body;\n    };\n\n    /**\n     * Returns the next unique group index for which bodies will collide.\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\n     * See `body.collisionFilter` for more information.\n     * @method nextGroup\n     * @param {bool} [isNonColliding=false]\n     * @return {Number} Unique group index\n     */\n    Body.nextGroup = function(isNonColliding) {\n        if (isNonColliding)\n            return Body._nextNonCollidingGroupId--;\n\n        return Body._nextCollidingGroupId++;\n    };\n\n    /**\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\n     * There are 32 available. See `body.collisionFilter` for more information.\n     * @method nextCategory\n     * @return {Number} Unique category bitfield\n     */\n    Body.nextCategory = function() {\n        Body._nextCategory = Body._nextCategory << 1;\n        return Body._nextCategory;\n    };\n\n    /**\n     * Initialises body properties.\n     * @method _initProperties\n     * @private\n     * @param {body} body\n     * @param {} [options]\n     */\n    var _initProperties = function(body, options) {\n        options = options || {};\n\n        // init required properties (order is important)\n        Body.set(body, {\n            bounds: body.bounds || Bounds.create(body.vertices),\n            positionPrev: body.positionPrev || Vector.clone(body.position),\n            anglePrev: body.anglePrev || body.angle,\n            vertices: body.vertices,\n            parts: body.parts || [body],\n            isStatic: body.isStatic,\n            isSleeping: body.isSleeping,\n            parent: body.parent || body\n        });\n\n        Vertices.rotate(body.vertices, body.angle, body.position);\n        Axes.rotate(body.axes, body.angle);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n\n        // allow options to override the automatically calculated properties\n        Body.set(body, {\n            axes: options.axes || body.axes,\n            area: options.area || body.area,\n            mass: options.mass || body.mass,\n            inertia: options.inertia || body.inertia\n        });\n\n        // render properties\n        var defaultFillStyle = (body.isStatic ? '#14151f' : Common.choose(['#f19648', '#f5d259', '#f55a3c', '#063e7b', '#ececd1'])),\n            defaultStrokeStyle = body.isStatic ? '#555' : '#ccc',\n            defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;\n        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n        body.render.lineWidth = body.render.lineWidth || defaultLineWidth;\n        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n    };\n\n    /**\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\n     * Prefer to use the actual setter functions in performance critical situations.\n     * @method set\n     * @param {body} body\n     * @param {} settings A property name (or map of properties and values) to set on the body.\n     * @param {} value The value to set if `settings` is a single property name.\n     */\n    Body.set = function(body, settings, value) {\n        var property;\n\n        if (typeof settings === 'string') {\n            property = settings;\n            settings = {};\n            settings[property] = value;\n        }\n\n        for (property in settings) {\n            if (!Object.prototype.hasOwnProperty.call(settings, property))\n                continue;\n\n            value = settings[property];\n            switch (property) {\n\n            case 'isStatic':\n                Body.setStatic(body, value);\n                break;\n            case 'isSleeping':\n                Sleeping.set(body, value);\n                break;\n            case 'mass':\n                Body.setMass(body, value);\n                break;\n            case 'density':\n                Body.setDensity(body, value);\n                break;\n            case 'inertia':\n                Body.setInertia(body, value);\n                break;\n            case 'vertices':\n                Body.setVertices(body, value);\n                break;\n            case 'position':\n                Body.setPosition(body, value);\n                break;\n            case 'angle':\n                Body.setAngle(body, value);\n                break;\n            case 'velocity':\n                Body.setVelocity(body, value);\n                break;\n            case 'angularVelocity':\n                Body.setAngularVelocity(body, value);\n                break;\n            case 'parts':\n                Body.setParts(body, value);\n                break;\n            case 'centre':\n                Body.setCentre(body, value);\n                break;\n            default:\n                body[property] = value;\n\n            }\n        }\n    };\n\n    /**\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\n     * @method setStatic\n     * @param {body} body\n     * @param {bool} isStatic\n     */\n    Body.setStatic = function(body, isStatic) {\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.isStatic = isStatic;\n\n            if (isStatic) {\n                part._original = {\n                    restitution: part.restitution,\n                    friction: part.friction,\n                    mass: part.mass,\n                    inertia: part.inertia,\n                    density: part.density,\n                    inverseMass: part.inverseMass,\n                    inverseInertia: part.inverseInertia\n                };\n\n                part.restitution = 0;\n                part.friction = 1;\n                part.mass = part.inertia = part.density = Infinity;\n                part.inverseMass = part.inverseInertia = 0;\n\n                part.positionPrev.x = part.position.x;\n                part.positionPrev.y = part.position.y;\n                part.anglePrev = part.angle;\n                part.angularVelocity = 0;\n                part.speed = 0;\n                part.angularSpeed = 0;\n                part.motion = 0;\n            } else if (part._original) {\n                part.restitution = part._original.restitution;\n                part.friction = part._original.friction;\n                part.mass = part._original.mass;\n                part.inertia = part._original.inertia;\n                part.density = part._original.density;\n                part.inverseMass = part._original.inverseMass;\n                part.inverseInertia = part._original.inverseInertia;\n\n                part._original = null;\n            }\n        }\n    };\n\n    /**\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\n     * @method setMass\n     * @param {body} body\n     * @param {number} mass\n     */\n    Body.setMass = function(body, mass) {\n        var moment = body.inertia / (body.mass / 6);\n        body.inertia = moment * (mass / 6);\n        body.inverseInertia = 1 / body.inertia;\n\n        body.mass = mass;\n        body.inverseMass = 1 / body.mass;\n        body.density = body.mass / body.area;\n    };\n\n    /**\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\n     * @method setDensity\n     * @param {body} body\n     * @param {number} density\n     */\n    Body.setDensity = function(body, density) {\n        Body.setMass(body, density * body.area);\n        body.density = density;\n    };\n\n    /**\n     * Sets the moment of inertia (i.e. second moment of area) of the body. \n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\n     * @method setInertia\n     * @param {body} body\n     * @param {number} inertia\n     */\n    Body.setInertia = function(body, inertia) {\n        body.inertia = inertia;\n        body.inverseInertia = 1 / body.inertia;\n    };\n\n    /**\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\n     * They are then automatically translated to world space based on `body.position`.\n     *\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\n     * Vertices must form a convex hull, concave hulls are not supported.\n     *\n     * @method setVertices\n     * @param {body} body\n     * @param {vector[]} vertices\n     */\n    Body.setVertices = function(body, vertices) {\n        // change vertices\n        if (vertices[0].body === body) {\n            body.vertices = vertices;\n        } else {\n            body.vertices = Vertices.create(vertices, body);\n        }\n\n        // update properties\n        body.axes = Axes.fromVertices(body.vertices);\n        body.area = Vertices.area(body.vertices);\n        Body.setMass(body, body.density * body.area);\n\n        // orient vertices around the centre of mass at origin (0, 0)\n        var centre = Vertices.centre(body.vertices);\n        Vertices.translate(body.vertices, centre, -1);\n\n        // update inertia while vertices are at origin (0, 0)\n        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\n\n        // update geometry\n        Vertices.translate(body.vertices, body.position);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Sets the parts of the `body` and updates mass, inertia and centroid.\n     * Each part will have its parent set to `body`.\n     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\n     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\n     * @method setParts\n     * @param {body} body\n     * @param [body] parts\n     * @param {bool} [autoHull=true]\n     */\n    Body.setParts = function(body, parts, autoHull) {\n        var i;\n\n        // add all the parts, ensuring that the first part is always the parent body\n        parts = parts.slice(0);\n        body.parts.length = 0;\n        body.parts.push(body);\n        body.parent = body;\n\n        for (i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            if (part !== body) {\n                part.parent = body;\n                body.parts.push(part);\n            }\n        }\n\n        if (body.parts.length === 1)\n            return;\n\n        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;\n\n        // find the convex hull of all parts to set on the parent body\n        if (autoHull) {\n            var vertices = [];\n            for (i = 0; i < parts.length; i++) {\n                vertices = vertices.concat(parts[i].vertices);\n            }\n\n            Vertices.clockwiseSort(vertices);\n\n            var hull = Vertices.hull(vertices),\n                hullCentre = Vertices.centre(hull);\n\n            Body.setVertices(body, hull);\n            Vertices.translate(body.vertices, hullCentre);\n        }\n\n        // sum the properties of all compound parts of the parent body\n        var total = Body._totalProperties(body);\n\n        body.area = total.area;\n        body.parent = body;\n        body.position.x = total.centre.x;\n        body.position.y = total.centre.y;\n        body.positionPrev.x = total.centre.x;\n        body.positionPrev.y = total.centre.y;\n\n        Body.setMass(body, total.mass);\n        Body.setInertia(body, total.inertia);\n        Body.setPosition(body, total.centre);\n    };\n\n    /**\n     * Set the centre of mass of the body. \n     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\n     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\n     * This is equal to moving `body.position` but not the `body.vertices`.\n     * Invalid if the `centre` falls outside the body's convex hull.\n     * @method setCentre\n     * @param {body} body\n     * @param {vector} centre\n     * @param {bool} relative\n     */\n    Body.setCentre = function(body, centre, relative) {\n        if (!relative) {\n            body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\n            body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\n            body.position.x = centre.x;\n            body.position.y = centre.y;\n        } else {\n            body.positionPrev.x += centre.x;\n            body.positionPrev.y += centre.y;\n            body.position.x += centre.x;\n            body.position.y += centre.y;\n        }\n    };\n\n    /**\n     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.\n     * @method setPosition\n     * @param {body} body\n     * @param {vector} position\n     */\n    Body.setPosition = function(body, position) {\n        var delta = Vector.sub(position, body.position);\n        body.positionPrev.x += delta.x;\n        body.positionPrev.y += delta.y;\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.position.x += delta.x;\n            part.position.y += delta.y;\n            Vertices.translate(part.vertices, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n    };\n\n    /**\n     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.\n     * @method setAngle\n     * @param {body} body\n     * @param {number} angle\n     */\n    Body.setAngle = function(body, angle) {\n        var delta = angle - body.angle;\n        body.anglePrev += delta;\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.angle += delta;\n            Vertices.rotate(part.vertices, delta, body.position);\n            Axes.rotate(part.axes, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n            if (i > 0) {\n                Vector.rotateAbout(part.position, delta, body.position, part.position);\n            }\n        }\n    };\n\n    /**\n     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\n     * @method setVelocity\n     * @param {body} body\n     * @param {vector} velocity\n     */\n    Body.setVelocity = function(body, velocity) {\n        body.positionPrev.x = body.position.x - velocity.x;\n        body.positionPrev.y = body.position.y - velocity.y;\n        body.velocity.x = velocity.x;\n        body.velocity.y = velocity.y;\n        body.speed = Vector.magnitude(body.velocity);\n    };\n\n    /**\n     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.\n     * @method setAngularVelocity\n     * @param {body} body\n     * @param {number} velocity\n     */\n    Body.setAngularVelocity = function(body, velocity) {\n        body.anglePrev = body.angle - velocity;\n        body.angularVelocity = velocity;\n        body.angularSpeed = Math.abs(body.angularVelocity);\n    };\n\n    /**\n     * Moves a body by a given vector relative to its current position, without imparting any velocity.\n     * @method translate\n     * @param {body} body\n     * @param {vector} translation\n     */\n    Body.translate = function(body, translation) {\n        Body.setPosition(body, Vector.add(body.position, translation));\n    };\n\n    /**\n     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.\n     * @method rotate\n     * @param {body} body\n     * @param {number} rotation\n     * @param {vector} [point]\n     */\n    Body.rotate = function(body, rotation, point) {\n        if (!point) {\n            Body.setAngle(body, body.angle + rotation);\n        } else {\n            var cos = Math.cos(rotation),\n                sin = Math.sin(rotation),\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            });\n\n            Body.setAngle(body, body.angle + rotation);\n        }\n    };\n\n    /**\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\n     * @method scale\n     * @param {body} body\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} [point]\n     */\n    Body.scale = function(body, scaleX, scaleY, point) {\n        var totalArea = 0,\n            totalInertia = 0;\n\n        point = point || body.position;\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            // scale vertices\n            Vertices.scale(part.vertices, scaleX, scaleY, point);\n\n            // update properties\n            part.axes = Axes.fromVertices(part.vertices);\n            part.area = Vertices.area(part.vertices);\n            Body.setMass(part, body.density * part.area);\n\n            // update inertia (requires vertices to be at origin)\n            Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });\n            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n            Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });\n\n            if (i > 0) {\n                totalArea += part.area;\n                totalInertia += part.inertia;\n            }\n\n            // scale position\n            part.position.x = point.x + (part.position.x - point.x) * scaleX;\n            part.position.y = point.y + (part.position.y - point.y) * scaleY;\n\n            // update bounds\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n\n        // handle parent body\n        if (body.parts.length > 1) {\n            body.area = totalArea;\n\n            if (!body.isStatic) {\n                Body.setMass(body, body.density * totalArea);\n                Body.setInertia(body, totalInertia);\n            }\n        }\n\n        // handle circles\n        if (body.circleRadius) { \n            if (scaleX === scaleY) {\n                body.circleRadius *= scaleX;\n            } else {\n                // body is no longer a circle\n                body.circleRadius = null;\n            }\n        }\n    };\n\n    /**\n     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.\n     * @method update\n     * @param {body} body\n     * @param {number} deltaTime\n     * @param {number} timeScale\n     * @param {number} correction\n     */\n    Body.update = function(body, deltaTime, timeScale, correction) {\n        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);\n\n        // from the previous step\n        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,\n            velocityPrevX = body.position.x - body.positionPrev.x,\n            velocityPrevY = body.position.y - body.positionPrev.y;\n\n        // update velocity with Verlet integration\n        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;\n        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;\n\n        body.positionPrev.x = body.position.x;\n        body.positionPrev.y = body.position.y;\n        body.position.x += body.velocity.x;\n        body.position.y += body.velocity.y;\n\n        // update angular velocity with Verlet integration\n        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;\n        body.anglePrev = body.angle;\n        body.angle += body.angularVelocity;\n\n        // track speed and acceleration\n        body.speed = Vector.magnitude(body.velocity);\n        body.angularSpeed = Math.abs(body.angularVelocity);\n\n        // transform the body geometry\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            Vertices.translate(part.vertices, body.velocity);\n            \n            if (i > 0) {\n                part.position.x += body.velocity.x;\n                part.position.y += body.velocity.y;\n            }\n\n            if (body.angularVelocity !== 0) {\n                Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n                Axes.rotate(part.axes, body.angularVelocity);\n                if (i > 0) {\n                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n                }\n            }\n\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n    };\n\n    /**\n     * Applies a force to a body from a given world-space position, including resulting torque.\n     * @method applyForce\n     * @param {body} body\n     * @param {vector} position\n     * @param {vector} force\n     */\n    Body.applyForce = function(body, position, force) {\n        body.force.x += force.x;\n        body.force.y += force.y;\n        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };\n        body.torque += offset.x * force.y - offset.y * force.x;\n    };\n\n    /**\n     * Returns the sums of the properties of all compound parts of the parent body.\n     * @method _totalProperties\n     * @private\n     * @param {body} body\n     * @return {}\n     */\n    Body._totalProperties = function(body) {\n        // from equations at:\n        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n        // http://output.to/sideway/default.asp?qno=121100087\n\n        var properties = {\n            mass: 0,\n            area: 0,\n            inertia: 0,\n            centre: { x: 0, y: 0 }\n        };\n\n        // sum the properties of all compound parts of the parent body\n        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\n            var part = body.parts[i],\n                mass = part.mass !== Infinity ? part.mass : 1;\n\n            properties.mass += mass;\n            properties.area += part.area;\n            properties.inertia += part.inertia;\n            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n        }\n\n        properties.centre = Vector.div(properties.centre, properties.mass);\n\n        return properties;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a body starts sleeping (where `this` is the body).\n    *\n    * @event sleepStart\n    * @this {body} The body that has started sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a body ends sleeping (where `this` is the body).\n    *\n    * @event sleepEnd\n    * @this {body} The body that has ended sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"body\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Body\"\n     */\n\n    /**\n     * An array of bodies that make up this body. \n     * The first body in the array must always be a self reference to the current body instance.\n     * All bodies in the `parts` array together form a single rigid compound body.\n     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\n     * Parts themselves should never be added to a `World`, only the parent body should be.\n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\n     *\n     * @property parts\n     * @type body[]\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * A self reference if the body is _not_ a part of another body.\n     * Otherwise this is a reference to the body that this is a part of.\n     * See `body.parts`.\n     *\n     * @property parent\n     * @type body\n     */\n\n    /**\n     * A `Number` specifying the angle of the body, in radians.\n     *\n     * @property angle\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * An array of `Vector` objects that specify the convex hull of the rigid body.\n     * These should be provided about the origin `(0, 0)`. E.g.\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).\n     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. \n     *\n     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).\n     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.\n     *\n     * @property vertices\n     * @type vector[]\n     */\n\n    /**\n     * A `Vector` that specifies the current world-space position of the body.\n     *\n     * @property position\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.\n     *\n     * @property force\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.\n     *\n     * @property torque\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).\n     *\n     * @readOnly\n     * @property speed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).\n     *\n     * @readOnly\n     * @property angularSpeed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. \n     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).\n     *\n     * @readOnly\n     * @property velocity\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. \n     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).\n     *\n     * @readOnly\n     * @property angularVelocity\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\n     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.\n     *\n     * @property isStatic\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\n     *\n     * @property isSensor\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\n     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.\n     *\n     * @property isSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.\n     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.\n     *\n     * @readOnly\n     * @property motion\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\n     *\n     * @property sleepThreshold\n     * @type number\n     * @default 60\n     */\n\n    /**\n     * A `Number` that defines the density of the body, that is its mass per unit area.\n     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.\n     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).\n     *\n     * @property density\n     * @type number\n     * @default 0.001\n     */\n\n    /**\n     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.\n     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).\n     *\n     * @property mass\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\n     * If you modify this value, you must also modify the `body.mass` property.\n     *\n     * @property inverseMass\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.\n     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.\n     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).\n     *\n     * @property inertia\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\n     * If you modify this value, you must also modify the `body.inertia` property.\n     *\n     * @property inverseInertia\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\n     *\n     *     Math.max(bodyA.restitution, bodyB.restitution)\n     *\n     * @property restitution\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means that the body may slide indefinitely.\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\n     *\n     * The effects of the value may be non-linear. \n     * High values may be unstable depending on the body.\n     * The engine uses a Coulomb friction model including static and kinetic friction.\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\n     *\n     *     Math.min(bodyA.friction, bodyB.friction)\n     *\n     * @property friction\n     * @type number\n     * @default 0.1\n     */\n\n    /**\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\n     *\n     * @property frictionStatic\n     * @type number\n     * @default 0.5\n     */\n\n    /**\n     * A `Number` that defines the air friction of the body (air resistance). \n     * A value of `0` means the body will never slow as it moves through space.\n     * The higher the value, the faster a body slows when moving through space.\n     * The effects of the value are non-linear. \n     *\n     * @property frictionAir\n     * @type number\n     * @default 0.01\n     */\n\n    /**\n     * An `Object` that specifies the collision filtering properties of this body.\n     *\n     * Collisions between two bodies will obey the following rules:\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\n     *   they will always collide if the value is positive, and they will never collide\n     *   if the value is negative.\n     * - If the two bodies have different values of `collisionFilter.group` or if one\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\n     *\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\n     * value is used as a bit field and the category should have only one bit set, meaning that\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\n     * different collision categories available.\n     *\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\n     *\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\n     * are both true.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n    /**\n     * An Integer `Number`, that specifies the collision group this body belongs to.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.group\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * A bit field that specifies the collision category this body belongs to.\n     * The category value should have only one bit set, for example `0x0001`.\n     * This means there are up to 32 unique collision categories available.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.category\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * A bit mask that specifies the collision categories this body may collide with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.mask\n     * @type object\n     * @default -1\n     */\n\n    /**\n     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.\n     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.\n     * The default should generally suffice, although very large bodies may require larger values for stable stacking.\n     *\n     * @property slop\n     * @type number\n     * @default 0.05\n     */\n\n    /**\n     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.\n     *\n     * @property timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the body should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * Sets the opacity to use when rendering.\n     *\n     * @property render.opacity\n     * @type number\n     * @default 1\n    */\n\n    /**\n     * An `Object` that defines the sprite properties to use when rendering, if any.\n     *\n     * @property render.sprite\n     * @type object\n     */\n\n    /**\n     * An `String` that defines the path to the image to use as the sprite texture, if any.\n     *\n     * @property render.sprite.texture\n     * @type string\n     */\n     \n    /**\n     * A `Number` that defines the scaling in the x-axis for the sprite, if any.\n     *\n     * @property render.sprite.xScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that defines the scaling in the y-axis for the sprite, if any.\n     *\n     * @property render.sprite.yScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\n      *\n      * @property render.sprite.xOffset\n      * @type number\n      * @default 0\n      */\n\n    /**\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\n      *\n      * @property render.sprite.yOffset\n      * @type number\n      * @default 0\n      */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.fillStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * An array of unique axis vectors (edge normals) used for collision detection.\n     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.\n     * They are constantly updated by `Body.update` during the simulation.\n     *\n     * @property axes\n     * @type vector[]\n     */\n     \n    /**\n     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.\n     *\n     * @property area\n     * @type string\n     * @default \n     */\n\n    /**\n     * A `Bounds` object that defines the AABB region for the body.\n     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.\n     *\n     * @property bounds\n     * @type bounds\n     */\n\n})();\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\n*\n* @class Sleeping\n*/\n\nvar Sleeping = {};\n\nmodule.exports = Sleeping;\n\nvar Events = __webpack_require__(4);\n\n(function() {\n\n    Sleeping._motionWakeThreshold = 0.18;\n    Sleeping._motionSleepThreshold = 0.08;\n    Sleeping._minBias = 0.9;\n\n    /**\n     * Puts bodies to sleep or wakes them up depending on their motion.\n     * @method update\n     * @param {body[]} bodies\n     * @param {number} timeScale\n     */\n    Sleeping.update = function(bodies, timeScale) {\n        var timeFactor = timeScale * timeScale * timeScale;\n\n        // update bodies sleeping status\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;\n\n            // wake up bodies if they have a force applied\n            if (body.force.x !== 0 || body.force.y !== 0) {\n                Sleeping.set(body, false);\n                continue;\n            }\n\n            var minMotion = Math.min(body.motion, motion),\n                maxMotion = Math.max(body.motion, motion);\n        \n            // biased average motion estimation between frames\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n            \n            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {\n                body.sleepCounter += 1;\n                \n                if (body.sleepCounter >= body.sleepThreshold)\n                    Sleeping.set(body, true);\n            } else if (body.sleepCounter > 0) {\n                body.sleepCounter -= 1;\n            }\n        }\n    };\n\n    /**\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\n     * @method afterCollisions\n     * @param {pair[]} pairs\n     * @param {number} timeScale\n     */\n    Sleeping.afterCollisions = function(pairs, timeScale) {\n        var timeFactor = timeScale * timeScale * timeScale;\n\n        // wake up bodies involved in collisions\n        for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n            \n            // don't wake inactive pairs\n            if (!pair.isActive)\n                continue;\n\n            var collision = pair.collision,\n                bodyA = collision.bodyA.parent, \n                bodyB = collision.bodyB.parent;\n        \n            // don't wake if at least one body is static\n            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)\n                continue;\n        \n            if (bodyA.isSleeping || bodyB.isSleeping) {\n                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,\n                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n\n                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {\n                    Sleeping.set(sleepingBody, false);\n                }\n            }\n        }\n    };\n  \n    /**\n     * Set a body as sleeping or awake.\n     * @method set\n     * @param {body} body\n     * @param {boolean} isSleeping\n     */\n    Sleeping.set = function(body, isSleeping) {\n        var wasSleeping = body.isSleeping;\n\n        if (isSleeping) {\n            body.isSleeping = true;\n            body.sleepCounter = body.sleepThreshold;\n\n            body.positionImpulse.x = 0;\n            body.positionImpulse.y = 0;\n\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n\n            body.anglePrev = body.angle;\n            body.speed = 0;\n            body.angularSpeed = 0;\n            body.motion = 0;\n\n            if (!wasSleeping) {\n                Events.trigger(body, 'sleepStart');\n            }\n        } else {\n            body.isSleeping = false;\n            body.sleepCounter = 0;\n\n            if (wasSleeping) {\n                Events.trigger(body, 'sleepEnd');\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\n* The stiffness of constraints can be modified to create springs or elastic.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Constraint\n*/\n\nvar Constraint = {};\n\nmodule.exports = Constraint;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\nvar Sleeping = __webpack_require__(7);\nvar Bounds = __webpack_require__(1);\nvar Axes = __webpack_require__(10);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    Constraint._warming = 0.4;\n    Constraint._torqueDampen = 1;\n    Constraint._minLength = 0.000001;\n\n    /**\n     * Creates a new constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\n     * For compound bodies, constraints must be applied to the parent body (not one of its parts).\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {constraint} constraint\n     */\n    Constraint.create = function(options) {\n        var constraint = options;\n\n        // if bodies defined but no points, use body centre\n        if (constraint.bodyA && !constraint.pointA)\n            constraint.pointA = { x: 0, y: 0 };\n        if (constraint.bodyB && !constraint.pointB)\n            constraint.pointB = { x: 0, y: 0 };\n\n        // calculate static length using initial world space points\n        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,\n            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,\n            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\n    \n        constraint.length = typeof constraint.length !== 'undefined' ? constraint.length : length;\n\n        // option defaults\n        constraint.id = constraint.id || Common.nextId();\n        constraint.label = constraint.label || 'Constraint';\n        constraint.type = 'constraint';\n        constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);\n        constraint.damping = constraint.damping || 0;\n        constraint.angularStiffness = constraint.angularStiffness || 0;\n        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\n        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\n        constraint.plugin = {};\n\n        // render\n        var render = {\n            visible: true,\n            lineWidth: 2,\n            strokeStyle: '#ffffff',\n            type: 'line',\n            anchors: true\n        };\n\n        if (constraint.length === 0 && constraint.stiffness > 0.1) {\n            render.type = 'pin';\n            render.anchors = false;\n        } else if (constraint.stiffness < 0.9) {\n            render.type = 'spring';\n        }\n\n        constraint.render = Common.extend(render, constraint.render);\n\n        return constraint;\n    };\n\n    /**\n     * Prepares for solving by constraint warming.\n     * @private\n     * @method preSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.preSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\n                continue;\n            }\n\n            body.position.x += impulse.x;\n            body.position.y += impulse.y;\n            body.angle += impulse.angle;\n        }\n    };\n\n    /**\n     * Solves all constraints in a list of collisions.\n     * @private\n     * @method solveAll\n     * @param {constraint[]} constraints\n     * @param {number} timeScale\n     */\n    Constraint.solveAll = function(constraints, timeScale) {\n        // Solve fixed constraints first.\n        for (var i = 0; i < constraints.length; i += 1) {\n            var constraint = constraints[i],\n                fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic),\n                fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\n\n            if (fixedA || fixedB) {\n                Constraint.solve(constraints[i], timeScale);\n            }\n        }\n\n        // Solve free constraints last.\n        for (i = 0; i < constraints.length; i += 1) {\n            constraint = constraints[i];\n            fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic);\n            fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\n\n            if (!fixedA && !fixedB) {\n                Constraint.solve(constraints[i], timeScale);\n            }\n        }\n    };\n\n    /**\n     * Solves a distance constraint with Gauss-Siedel method.\n     * @private\n     * @method solve\n     * @param {constraint} constraint\n     * @param {number} timeScale\n     */\n    Constraint.solve = function(constraint, timeScale) {\n        var bodyA = constraint.bodyA,\n            bodyB = constraint.bodyB,\n            pointA = constraint.pointA,\n            pointB = constraint.pointB;\n\n        if (!bodyA && !bodyB)\n            return;\n\n        // update reference angle\n        if (bodyA && !bodyA.isStatic) {\n            Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);\n            constraint.angleA = bodyA.angle;\n        }\n        \n        // update reference angle\n        if (bodyB && !bodyB.isStatic) {\n            Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);\n            constraint.angleB = bodyB.angle;\n        }\n\n        var pointAWorld = pointA,\n            pointBWorld = pointB;\n\n        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\n        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\n\n        if (!pointAWorld || !pointBWorld)\n            return;\n\n        var delta = Vector.sub(pointAWorld, pointBWorld),\n            currentLength = Vector.magnitude(delta);\n\n        // prevent singularity\n        if (currentLength < Constraint._minLength) {\n            currentLength = Constraint._minLength;\n        }\n\n        // solve distance constraint with Gauss-Siedel method\n        var difference = (currentLength - constraint.length) / currentLength,\n            stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness,\n            force = Vector.mult(delta, difference * stiffness),\n            massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0),\n            inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0),\n            resistanceTotal = massTotal + inertiaTotal,\n            torque,\n            share,\n            normal,\n            normalVelocity,\n            relativeVelocity;\n\n        if (constraint.damping) {\n            var zero = Vector.create();\n            normal = Vector.div(delta, currentLength);\n\n            relativeVelocity = Vector.sub(\n                bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero,\n                bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero\n            );\n\n            normalVelocity = Vector.dot(normal, relativeVelocity);\n        }\n\n        if (bodyA && !bodyA.isStatic) {\n            share = bodyA.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyA.constraintImpulse.x -= force.x * share;\n            bodyA.constraintImpulse.y -= force.y * share;\n\n            // apply forces\n            bodyA.position.x -= force.x * share;\n            bodyA.position.y -= force.y * share;\n\n            // apply damping\n            if (constraint.damping) {\n                bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;\n                bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = (Vector.cross(pointA, force) / resistanceTotal) * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);\n            bodyA.constraintImpulse.angle -= torque;\n            bodyA.angle -= torque;\n        }\n\n        if (bodyB && !bodyB.isStatic) {\n            share = bodyB.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyB.constraintImpulse.x += force.x * share;\n            bodyB.constraintImpulse.y += force.y * share;\n            \n            // apply forces\n            bodyB.position.x += force.x * share;\n            bodyB.position.y += force.y * share;\n\n            // apply damping\n            if (constraint.damping) {\n                bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;\n                bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = (Vector.cross(pointB, force) / resistanceTotal) * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);\n            bodyB.constraintImpulse.angle += torque;\n            bodyB.angle += torque;\n        }\n\n    };\n\n    /**\n     * Performs body updates required after solving constraints.\n     * @private\n     * @method postSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.postSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\n                continue;\n            }\n\n            Sleeping.set(body, false);\n\n            // update geometry and reset\n            for (var j = 0; j < body.parts.length; j++) {\n                var part = body.parts[j];\n                \n                Vertices.translate(part.vertices, impulse);\n\n                if (j > 0) {\n                    part.position.x += impulse.x;\n                    part.position.y += impulse.y;\n                }\n\n                if (impulse.angle !== 0) {\n                    Vertices.rotate(part.vertices, impulse.angle, body.position);\n                    Axes.rotate(part.axes, impulse.angle);\n                    if (j > 0) {\n                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);\n                    }\n                }\n\n                Bounds.update(part.bounds, part.vertices, body.velocity);\n            }\n\n            // dampen the cached impulse for warming next step\n            impulse.angle *= Constraint._warming;\n            impulse.x *= Constraint._warming;\n            impulse.y *= Constraint._warming;\n        }\n    };\n\n    /**\n     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.\n     * @method pointAWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */\n    Constraint.pointAWorld = function(constraint) {\n        return {\n            x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,\n            y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y\n        };\n    };\n\n    /**\n     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.\n     * @method pointBWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */\n    Constraint.pointBWorld = function(constraint) {\n        return {\n            x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,\n            y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y\n        };\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Constraint\"\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the constraint should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the constraint outline.\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the constraint rendering type. \n     * The possible values are 'line', 'pin', 'spring'.\n     * An appropriate render type will be automatically chosen unless one is given in options.\n     *\n     * @property render.type\n     * @type string\n     * @default 'line'\n     */\n\n    /**\n     * A `Boolean` that defines if the constraint's anchor points should be rendered.\n     *\n     * @property render.anchors\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * The first possible `Body` that this constraint is attached to.\n     *\n     * @property bodyA\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The second possible `Body` that this constraint is attached to.\n     *\n     * @property bodyB\n     * @type body\n     * @default null\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n     *\n     * @property pointA\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.\n     *\n     * @property pointB\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\n     * A value of `1` means the constraint should be very stiff.\n     * A value of `0.2` means the constraint acts like a soft spring.\n     *\n     * @property stiffness\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the damping of the constraint, \n     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\n     * Damping will only be apparent when the constraint also has a very low `stiffness`.\n     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\n     * A value of `0` means the constraint will apply no damping.\n     *\n     * @property damping\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that specifies the target resting length of the constraint. \n     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     *\n     * @property length\n     * @type number\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n})();\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\n*\n* @class Pair\n*/\n\nvar Pair = {};\n\nmodule.exports = Pair;\n\nvar Contact = __webpack_require__(17);\n\n(function() {\n    \n    /**\n     * Creates a pair.\n     * @method create\n     * @param {collision} collision\n     * @param {number} timestamp\n     * @return {pair} A new pair\n     */\n    Pair.create = function(collision, timestamp) {\n        var bodyA = collision.bodyA,\n            bodyB = collision.bodyB,\n            parentA = collision.parentA,\n            parentB = collision.parentB;\n\n        var pair = {\n            id: Pair.id(bodyA, bodyB),\n            bodyA: bodyA,\n            bodyB: bodyB,\n            contacts: {},\n            activeContacts: [],\n            separation: 0,\n            isActive: true,\n            confirmedActive: true,\n            isSensor: bodyA.isSensor || bodyB.isSensor,\n            timeCreated: timestamp,\n            timeUpdated: timestamp,\n            inverseMass: parentA.inverseMass + parentB.inverseMass,\n            friction: Math.min(parentA.friction, parentB.friction),\n            frictionStatic: Math.max(parentA.frictionStatic, parentB.frictionStatic),\n            restitution: Math.max(parentA.restitution, parentB.restitution),\n            slop: Math.max(parentA.slop, parentB.slop)\n        };\n\n        Pair.update(pair, collision, timestamp);\n\n        return pair;\n    };\n\n    /**\n     * Updates a pair given a collision.\n     * @method update\n     * @param {pair} pair\n     * @param {collision} collision\n     * @param {number} timestamp\n     */\n    Pair.update = function(pair, collision, timestamp) {\n        var contacts = pair.contacts,\n            supports = collision.supports,\n            activeContacts = pair.activeContacts,\n            parentA = collision.parentA,\n            parentB = collision.parentB;\n        \n        pair.collision = collision;\n        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n        pair.friction = Math.min(parentA.friction, parentB.friction);\n        pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);\n        pair.restitution = Math.max(parentA.restitution, parentB.restitution);\n        pair.slop = Math.max(parentA.slop, parentB.slop);\n        activeContacts.length = 0;\n        \n        if (collision.collided) {\n            for (var i = 0; i < supports.length; i++) {\n                var support = supports[i],\n                    contactId = Contact.id(support),\n                    contact = contacts[contactId];\n\n                if (contact) {\n                    activeContacts.push(contact);\n                } else {\n                    activeContacts.push(contacts[contactId] = Contact.create(support));\n                }\n            }\n\n            pair.separation = collision.depth;\n            Pair.setActive(pair, true, timestamp);\n        } else {\n            if (pair.isActive === true)\n                Pair.setActive(pair, false, timestamp);\n        }\n    };\n    \n    /**\n     * Set a pair as active or inactive.\n     * @method setActive\n     * @param {pair} pair\n     * @param {bool} isActive\n     * @param {number} timestamp\n     */\n    Pair.setActive = function(pair, isActive, timestamp) {\n        if (isActive) {\n            pair.isActive = true;\n            pair.timeUpdated = timestamp;\n        } else {\n            pair.isActive = false;\n            pair.activeContacts.length = 0;\n        }\n    };\n\n    /**\n     * Get the id for the given pair.\n     * @method id\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {string} Unique pairId\n     */\n    Pair.id = function(bodyA, bodyB) {\n        if (bodyA.id < bodyB.id) {\n            return 'A' + bodyA.id + 'B' + bodyB.id;\n        } else {\n            return 'A' + bodyB.id + 'B' + bodyA.id;\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\n*\n* @class Axes\n*/\n\nvar Axes = {};\n\nmodule.exports = Axes;\n\nvar Vector = __webpack_require__(2);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new set of axes from the given vertices.\n     * @method fromVertices\n     * @param {vertices} vertices\n     * @return {axes} A new axes from the given vertices\n     */\n    Axes.fromVertices = function(vertices) {\n        var axes = {};\n\n        // find the unique axes, using edge normal gradients\n        for (var i = 0; i < vertices.length; i++) {\n            var j = (i + 1) % vertices.length, \n                normal = Vector.normalise({ \n                    x: vertices[j].y - vertices[i].y, \n                    y: vertices[i].x - vertices[j].x\n                }),\n                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);\n            \n            // limit precision\n            gradient = gradient.toFixed(3).toString();\n            axes[gradient] = normal;\n        }\n\n        return Common.values(axes);\n    };\n\n    /**\n     * Rotates a set of axes by the given angle.\n     * @method rotate\n     * @param {axes} axes\n     * @param {number} angle\n     */\n    Axes.rotate = function(axes, angle) {\n        if (angle === 0)\n            return;\n        \n        var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n\n        for (var i = 0; i < axes.length; i++) {\n            var axis = axes[i],\n                xx;\n            xx = axis.x * cos - axis.y * sin;\n            axis.y = axis.x * sin + axis.y * cos;\n            axis.x = xx;\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \n* with commonly used body configurations (such as rectangles, circles and other polygons).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Bodies\n*/\n\n// TODO: true circle bodies\n\nvar Bodies = {};\n\nmodule.exports = Bodies;\n\nvar Vertices = __webpack_require__(3);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(6);\nvar Bounds = __webpack_require__(1);\nvar Vector = __webpack_require__(2);\n\n(function() {\n\n    /**\n     * Creates a new rigid body model with a rectangle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method rectangle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {object} [options]\n     * @return {body} A new rectangle body\n     */\n    Bodies.rectangle = function(x, y, width, height, options) {\n        options = options || {};\n\n        var rectangle = { \n            label: 'Rectangle Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, rectangle, options));\n    };\n    \n    /**\n     * Creates a new rigid body model with a trapezoid hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method trapezoid\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} slope\n     * @param {object} [options]\n     * @return {body} A new trapezoid body\n     */\n    Bodies.trapezoid = function(x, y, width, height, slope, options) {\n        options = options || {};\n\n        slope *= 0.5;\n        var roof = (1 - (slope * 2)) * width;\n        \n        var x1 = width * slope,\n            x2 = x1 + roof,\n            x3 = x2 + x1,\n            verticesPath;\n\n        if (slope < 0.5) {\n            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\n        } else {\n            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\n        }\n\n        var trapezoid = { \n            label: 'Trapezoid Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(verticesPath)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, trapezoid, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a circle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {object} [options]\n     * @param {number} [maxSides]\n     * @return {body} A new circle body\n     */\n    Bodies.circle = function(x, y, radius, options, maxSides) {\n        options = options || {};\n\n        var circle = {\n            label: 'Circle Body',\n            circleRadius: radius\n        };\n        \n        // approximate circles with polygons until true circles implemented in SAT\n        maxSides = maxSides || 25;\n        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\n\n        // optimisation: always use even number of sides (half the number of unique axes)\n        if (sides % 2 === 1)\n            sides += 1;\n\n        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method polygon\n     * @param {number} x\n     * @param {number} y\n     * @param {number} sides\n     * @param {number} radius\n     * @param {object} [options]\n     * @return {body} A new regular polygon body\n     */\n    Bodies.polygon = function(x, y, sides, radius, options) {\n        options = options || {};\n\n        if (sides < 3)\n            return Bodies.circle(x, y, radius, options);\n\n        var theta = 2 * Math.PI / sides,\n            path = '',\n            offset = theta * 0.5;\n\n        for (var i = 0; i < sides; i += 1) {\n            var angle = offset + (i * theta),\n                xx = Math.cos(angle) * radius,\n                yy = Math.sin(angle) * radius;\n\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\n        }\n\n        var polygon = { \n            label: 'Polygon Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(path)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, polygon, options));\n    };\n\n    /**\n     * Utility to create a compound body based on set(s) of vertices.\n     * \n     * _Note:_ To optionally enable automatic concave vertices decomposition the [poly-decomp](https://github.com/schteppe/poly-decomp.js) \n     * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.\n     * \n     * The resulting vertices are reorientated about their centre of mass,\n     * and offset such that `body.position` corresponds to this point.\n     * \n     * The resulting offset may be found if needed by subtracting `body.bounds` from the original input bounds.\n     * To later move the centre of mass see `Body.setCentre`.\n     * \n     * Note that automatic conconcave decomposition results are not always optimal. \n     * For best results, simplify the input vertices as much as possible first.\n     * By default this function applies some addtional simplification to help.\n     * \n     * Some outputs may also require further manual processing afterwards to be robust.\n     * In particular some parts may need to be overlapped to avoid collision gaps.\n     * Thin parts and sharp points should be avoided or removed where possible.\n     *\n     * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults.\n     * \n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method fromVertices\n     * @param {number} x\n     * @param {number} y\n     * @param {array} vertexSets One or more arrays of vertex points e.g. `[[{ x: 0, y: 0 }...], ...]`.\n     * @param {object} [options] The body options.\n     * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`.\n     * @param {number} [removeCollinear=0.01] Threshold when simplifying vertices along the same edge.\n     * @param {number} [minimumArea=10] Threshold when removing small parts.\n     * @param {number} [removeDuplicatePoints=0.01] Threshold when simplifying nearby vertices.\n     * @return {body}\n     */\n    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {\n        var decomp = Common.getDecomp(),\n            canDecomp,\n            body,\n            parts,\n            isConvex,\n            isConcave,\n            vertices,\n            i,\n            j,\n            k,\n            v,\n            z;\n\n        // check decomp is as expected\n        canDecomp = Boolean(decomp && decomp.quickDecomp);\n\n        options = options || {};\n        parts = [];\n\n        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\n        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\n        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\n        removeDuplicatePoints = typeof removeDuplicatePoints !== 'undefined' ? removeDuplicatePoints : 0.01;\n\n        // ensure vertexSets is an array of arrays\n        if (!Common.isArray(vertexSets[0])) {\n            vertexSets = [vertexSets];\n        }\n\n        for (v = 0; v < vertexSets.length; v += 1) {\n            vertices = vertexSets[v];\n            isConvex = Vertices.isConvex(vertices);\n            isConcave = !isConvex;\n\n            if (isConcave && !canDecomp) {\n                Common.warnOnce(\n                    'Bodies.fromVertices: Install the \\'poly-decomp\\' library and use Common.setDecomp or provide \\'decomp\\' as a global to decompose concave vertices.'\n                );\n            }\n\n            if (isConvex || !canDecomp) {\n                if (isConvex) {\n                    vertices = Vertices.clockwiseSort(vertices);\n                } else {\n                    // fallback to convex hull when decomposition is not possible\n                    vertices = Vertices.hull(vertices);\n                }\n\n                parts.push({\n                    position: { x: x, y: y },\n                    vertices: vertices\n                });\n            } else {\n                // initialise a decomposition\n                var concave = vertices.map(function(vertex) {\n                    return [vertex.x, vertex.y];\n                });\n\n                // vertices are concave and simple, we can decompose into parts\n                decomp.makeCCW(concave);\n                if (removeCollinear !== false)\n                    decomp.removeCollinearPoints(concave, removeCollinear);\n                if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints)\n                    decomp.removeDuplicatePoints(concave, removeDuplicatePoints);\n\n                // use the quick decomposition algorithm (Bayazit)\n                var decomposed = decomp.quickDecomp(concave);\n\n                // for each decomposed chunk\n                for (i = 0; i < decomposed.length; i++) {\n                    var chunk = decomposed[i];\n\n                    // convert vertices into the correct structure\n                    var chunkVertices = chunk.map(function(vertices) {\n                        return {\n                            x: vertices[0],\n                            y: vertices[1]\n                        };\n                    });\n\n                    // skip small chunks\n                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)\n                        continue;\n\n                    // create a compound part\n                    parts.push({\n                        position: Vertices.centre(chunkVertices),\n                        vertices: chunkVertices\n                    });\n                }\n            }\n        }\n\n        // create body parts\n        for (i = 0; i < parts.length; i++) {\n            parts[i] = Body.create(Common.extend(parts[i], options));\n        }\n\n        // flag internal edges (coincident part edges)\n        if (flagInternal) {\n            var coincident_max_dist = 5;\n\n            for (i = 0; i < parts.length; i++) {\n                var partA = parts[i];\n\n                for (j = i + 1; j < parts.length; j++) {\n                    var partB = parts[j];\n\n                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n                        var pav = partA.vertices,\n                            pbv = partB.vertices;\n\n                        // iterate vertices of both parts\n                        for (k = 0; k < partA.vertices.length; k++) {\n                            for (z = 0; z < partB.vertices.length; z++) {\n                                // find distances between the vertices\n                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),\n                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\n\n                                // if both vertices are very close, consider the edge concident (internal)\n                                if (da < coincident_max_dist && db < coincident_max_dist) {\n                                    pav[k].isInternal = true;\n                                    pbv[z].isInternal = true;\n                                }\n                            }\n                        }\n\n                    }\n                }\n            }\n        }\n\n        if (parts.length > 1) {\n            // create the parent body to be returned, that contains generated compound parts\n            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));\n\n            // offset such that body.position is at the centre off mass\n            Body.setPosition(body, { x: x, y: y });\n\n            return body;\n        } else {\n            return parts[0];\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.\n*\n* @class Mouse\n*/\n\nvar Mouse = {};\n\nmodule.exports = Mouse;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a mouse input.\n     * @method create\n     * @param {HTMLElement} element\n     * @return {mouse} A new mouse\n     */\n    Mouse.create = function(element) {\n        var mouse = {};\n\n        if (!element) {\n            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');\n        }\n        \n        mouse.element = element || document.body;\n        mouse.absolute = { x: 0, y: 0 };\n        mouse.position = { x: 0, y: 0 };\n        mouse.mousedownPosition = { x: 0, y: 0 };\n        mouse.mouseupPosition = { x: 0, y: 0 };\n        mouse.offset = { x: 0, y: 0 };\n        mouse.scale = { x: 1, y: 1 };\n        mouse.wheelDelta = 0;\n        mouse.button = -1;\n        mouse.pixelRatio = parseInt(mouse.element.getAttribute('data-pixel-ratio'), 10) || 1;\n\n        mouse.sourceEvents = {\n            mousemove: null,\n            mousedown: null,\n            mouseup: null,\n            mousewheel: null\n        };\n        \n        mouse.mousemove = function(event) { \n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.sourceEvents.mousemove = event;\n        };\n        \n        mouse.mousedown = function(event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            } else {\n                mouse.button = event.button;\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mousedownPosition.x = mouse.position.x;\n            mouse.mousedownPosition.y = mouse.position.y;\n            mouse.sourceEvents.mousedown = event;\n        };\n        \n        mouse.mouseup = function(event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                event.preventDefault();\n            }\n            \n            mouse.button = -1;\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mouseupPosition.x = mouse.position.x;\n            mouse.mouseupPosition.y = mouse.position.y;\n            mouse.sourceEvents.mouseup = event;\n        };\n\n        mouse.mousewheel = function(event) {\n            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n            event.preventDefault();\n        };\n\n        Mouse.setElement(mouse, mouse.element);\n\n        return mouse;\n    };\n\n    /**\n     * Sets the element the mouse is bound to (and relative to).\n     * @method setElement\n     * @param {mouse} mouse\n     * @param {HTMLElement} element\n     */\n    Mouse.setElement = function(mouse, element) {\n        mouse.element = element;\n\n        element.addEventListener('mousemove', mouse.mousemove);\n        element.addEventListener('mousedown', mouse.mousedown);\n        element.addEventListener('mouseup', mouse.mouseup);\n        \n        element.addEventListener('mousewheel', mouse.mousewheel);\n        element.addEventListener('DOMMouseScroll', mouse.mousewheel);\n\n        element.addEventListener('touchmove', mouse.mousemove);\n        element.addEventListener('touchstart', mouse.mousedown);\n        element.addEventListener('touchend', mouse.mouseup);\n    };\n\n    /**\n     * Clears all captured source events.\n     * @method clearSourceEvents\n     * @param {mouse} mouse\n     */\n    Mouse.clearSourceEvents = function(mouse) {\n        mouse.sourceEvents.mousemove = null;\n        mouse.sourceEvents.mousedown = null;\n        mouse.sourceEvents.mouseup = null;\n        mouse.sourceEvents.mousewheel = null;\n        mouse.wheelDelta = 0;\n    };\n\n    /**\n     * Sets the mouse position offset.\n     * @method setOffset\n     * @param {mouse} mouse\n     * @param {vector} offset\n     */\n    Mouse.setOffset = function(mouse, offset) {\n        mouse.offset.x = offset.x;\n        mouse.offset.y = offset.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n\n    /**\n     * Sets the mouse position scale.\n     * @method setScale\n     * @param {mouse} mouse\n     * @param {vector} scale\n     */\n    Mouse.setScale = function(mouse, scale) {\n        mouse.scale.x = scale.x;\n        mouse.scale.y = scale.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n    \n    /**\n     * Gets the mouse position relative to an element given a screen pixel ratio.\n     * @method _getRelativeMousePosition\n     * @private\n     * @param {} event\n     * @param {} element\n     * @param {number} pixelRatio\n     * @return {}\n     */\n    Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {\n        var elementBounds = element.getBoundingClientRect(),\n            rootNode = (document.documentElement || document.body.parentNode || document.body),\n            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,\n            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,\n            touches = event.changedTouches,\n            x, y;\n        \n        if (touches) {\n            x = touches[0].pageX - elementBounds.left - scrollX;\n            y = touches[0].pageY - elementBounds.top - scrollY;\n        } else {\n            x = event.pageX - elementBounds.left - scrollX;\n            y = event.pageY - elementBounds.top - scrollY;\n        }\n\n        return { \n            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),\n            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)\n        };\n    };\n\n})();\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.\n*\n* @class Detector\n*/\n\n// TODO: speculative contacts\n\nvar Detector = {};\n\nmodule.exports = Detector;\n\nvar SAT = __webpack_require__(14);\nvar Pair = __webpack_require__(9);\nvar Bounds = __webpack_require__(1);\n\n(function() {\n\n    /**\n     * Finds all collisions given a list of pairs.\n     * @method collisions\n     * @param {pair[]} broadphasePairs\n     * @param {engine} engine\n     * @return {array} collisions\n     */\n    Detector.collisions = function(broadphasePairs, engine) {\n        var collisions = [],\n            pairsTable = engine.pairs.table;\n\n        for (var i = 0; i < broadphasePairs.length; i++) {\n            var bodyA = broadphasePairs[i][0], \n                bodyB = broadphasePairs[i][1];\n\n            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))\n                continue;\n            \n            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))\n                continue;\n\n            // mid phase\n            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {\n                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {\n                    var partA = bodyA.parts[j];\n\n                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {\n                        var partB = bodyB.parts[k];\n\n                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {\n                            // find a previous collision we could reuse\n                            var pairId = Pair.id(partA, partB),\n                                pair = pairsTable[pairId],\n                                previousCollision;\n\n                            if (pair && pair.isActive) {\n                                previousCollision = pair.collision;\n                            } else {\n                                previousCollision = null;\n                            }\n\n                            // narrow phase\n                            var collision = SAT.collides(partA, partB, previousCollision);\n\n                            if (collision.collided) {\n                                collisions.push(collision);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\n     * See `body.collisionFilter` for more information.\n     * @method canCollide\n     * @param {} filterA\n     * @param {} filterB\n     * @return {bool} `true` if collision can occur\n     */\n    Detector.canCollide = function(filterA, filterB) {\n        if (filterA.group === filterB.group && filterA.group !== 0)\n            return filterA.group > 0;\n\n        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n    };\n\n})();\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\n*\n* @class SAT\n*/\n\n// TODO: true circles and curves\n\nvar SAT = {};\n\nmodule.exports = SAT;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\n\n(function() {\n\n    /**\n     * Detect collision between two bodies using the Separating Axis Theorem.\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {collision} previousCollision\n     * @return {collision} collision\n     */\n    SAT.collides = function(bodyA, bodyB, previousCollision) {\n        var overlapAB,\n            overlapBA, \n            minOverlap,\n            collision,\n            canReusePrevCol = false;\n\n        if (previousCollision) {\n            // estimate total motion\n            var parentA = bodyA.parent,\n                parentB = bodyB.parent,\n                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed\n                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;\n\n            // we may be able to (partially) reuse collision result \n            // but only safe if collision was resting\n            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;\n\n            // reuse collision object\n            collision = previousCollision;\n        } else {\n            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };\n        }\n\n        if (previousCollision && canReusePrevCol) {\n            // if we can reuse the collision result\n            // we only need to test the previously found axis\n            var axisBodyA = collision.axisBody,\n                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,\n                axes = [axisBodyA.axes[previousCollision.axisNumber]];\n\n            minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);\n            collision.reused = true;\n\n            if (minOverlap.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n        } else {\n            // if we can't reuse a result, perform a full SAT test\n\n            overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);\n\n            if (overlapAB.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n\n            overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);\n\n            if (overlapBA.overlap <= 0) {\n                collision.collided = false;\n                return collision;\n            }\n\n            if (overlapAB.overlap < overlapBA.overlap) {\n                minOverlap = overlapAB;\n                collision.axisBody = bodyA;\n            } else {\n                minOverlap = overlapBA;\n                collision.axisBody = bodyB;\n            }\n\n            // important for reuse later\n            collision.axisNumber = minOverlap.axisNumber;\n        }\n\n        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n        collision.collided = true;\n        collision.depth = minOverlap.overlap;\n        collision.parentA = collision.bodyA.parent;\n        collision.parentB = collision.bodyB.parent;\n        \n        bodyA = collision.bodyA;\n        bodyB = collision.bodyB;\n\n        // ensure normal is facing away from bodyA\n        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {\n            collision.normal = {\n                x: minOverlap.axis.x,\n                y: minOverlap.axis.y\n            };\n        } else {\n            collision.normal = {\n                x: -minOverlap.axis.x,\n                y: -minOverlap.axis.y\n            };\n        }\n\n        collision.tangent = Vector.perp(collision.normal);\n\n        collision.penetration = collision.penetration || {};\n        collision.penetration.x = collision.normal.x * collision.depth;\n        collision.penetration.y = collision.normal.y * collision.depth; \n\n        // find support points, there is always either exactly one or two\n        var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal),\n            supports = [];\n\n        // find the supports from bodyB that are inside bodyA\n        if (Vertices.contains(bodyA.vertices, verticesB[0]))\n            supports.push(verticesB[0]);\n\n        if (Vertices.contains(bodyA.vertices, verticesB[1]))\n            supports.push(verticesB[1]);\n\n        // find the supports from bodyA that are inside bodyB\n        if (supports.length < 2) {\n            var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));\n                \n            if (Vertices.contains(bodyB.vertices, verticesA[0]))\n                supports.push(verticesA[0]);\n\n            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))\n                supports.push(verticesA[1]);\n        }\n\n        // account for the edge case of overlapping but no vertex containment\n        if (supports.length < 1)\n            supports = [verticesB[0]];\n        \n        collision.supports = supports;\n\n        return collision;\n    };\n\n    /**\n     * Find the overlap between two sets of vertices.\n     * @method _overlapAxes\n     * @private\n     * @param {} verticesA\n     * @param {} verticesB\n     * @param {} axes\n     * @return result\n     */\n    SAT._overlapAxes = function(verticesA, verticesB, axes) {\n        var projectionA = Vector._temp[0], \n            projectionB = Vector._temp[1],\n            result = { overlap: Number.MAX_VALUE },\n            overlap,\n            axis;\n\n        for (var i = 0; i < axes.length; i++) {\n            axis = axes[i];\n\n            SAT._projectToAxis(projectionA, verticesA, axis);\n            SAT._projectToAxis(projectionB, verticesB, axis);\n\n            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);\n\n            if (overlap <= 0) {\n                result.overlap = overlap;\n                return result;\n            }\n\n            if (overlap < result.overlap) {\n                result.overlap = overlap;\n                result.axis = axis;\n                result.axisNumber = i;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Projects vertices on an axis and returns an interval.\n     * @method _projectToAxis\n     * @private\n     * @param {} projection\n     * @param {} vertices\n     * @param {} axis\n     */\n    SAT._projectToAxis = function(projection, vertices, axis) {\n        var min = Vector.dot(vertices[0], axis),\n            max = min;\n\n        for (var i = 1; i < vertices.length; i += 1) {\n            var dot = Vector.dot(vertices[i], axis);\n\n            if (dot > max) { \n                max = dot; \n            } else if (dot < min) { \n                min = dot; \n            }\n        }\n\n        projection.min = min;\n        projection.max = max;\n    };\n    \n    /**\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\n     * @method _findSupports\n     * @private\n     * @param {} bodyA\n     * @param {} bodyB\n     * @param {} normal\n     * @return [vector]\n     */\n    SAT._findSupports = function(bodyA, bodyB, normal) {\n        var nearestDistance = Number.MAX_VALUE,\n            vertexToBody = Vector._temp[0],\n            vertices = bodyB.vertices,\n            bodyAPosition = bodyA.position,\n            distance,\n            vertex,\n            vertexA,\n            vertexB;\n\n        // find closest vertex on bodyB\n        for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            vertexToBody.x = vertex.x - bodyAPosition.x;\n            vertexToBody.y = vertex.y - bodyAPosition.y;\n            distance = -Vector.dot(normal, vertexToBody);\n\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                vertexA = vertex;\n            }\n        }\n\n        // find next closest vertex using the two connected to it\n        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;\n        vertex = vertices[prevIndex];\n        vertexToBody.x = vertex.x - bodyAPosition.x;\n        vertexToBody.y = vertex.y - bodyAPosition.y;\n        nearestDistance = -Vector.dot(normal, vertexToBody);\n        vertexB = vertex;\n\n        var nextIndex = (vertexA.index + 1) % vertices.length;\n        vertex = vertices[nextIndex];\n        vertexToBody.x = vertex.x - bodyAPosition.x;\n        vertexToBody.y = vertex.y - bodyAPosition.y;\n        distance = -Vector.dot(normal, vertexToBody);\n        if (distance < nearestDistance) {\n            vertexB = vertex;\n        }\n\n        return [vertexA, vertexB];\n    };\n\n})();\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\n*\n* @class Plugin\n*/\n\nvar Plugin = {};\n\nmodule.exports = Plugin;\n\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    Plugin._registry = {};\n\n    /**\n     * Registers a plugin object so it can be resolved later by name.\n     * @method register\n     * @param plugin {} The plugin to register.\n     * @return {object} The plugin.\n     */\n    Plugin.register = function(plugin) {\n        if (!Plugin.isPlugin(plugin)) {\n            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');\n        }\n\n        if (plugin.name in Plugin._registry) {\n            var registered = Plugin._registry[plugin.name],\n                pluginVersion = Plugin.versionParse(plugin.version).number,\n                registeredVersion = Plugin.versionParse(registered.version).number;\n\n            if (pluginVersion > registeredVersion) {\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));\n                Plugin._registry[plugin.name] = plugin;\n            } else if (pluginVersion < registeredVersion) {\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));\n            } else if (plugin !== registered) {\n                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');\n            }\n        } else {\n            Plugin._registry[plugin.name] = plugin;\n        }\n\n        return plugin;\n    };\n\n    /**\n     * Resolves a dependency to a plugin object from the registry if it exists. \n     * The `dependency` may contain a version, but only the name matters when resolving.\n     * @method resolve\n     * @param dependency {string} The dependency.\n     * @return {object} The plugin if resolved, otherwise `undefined`.\n     */\n    Plugin.resolve = function(dependency) {\n        return Plugin._registry[Plugin.dependencyParse(dependency).name];\n    };\n\n    /**\n     * Returns a pretty printed plugin name and version.\n     * @method toString\n     * @param plugin {} The plugin.\n     * @return {string} Pretty printed plugin name and version.\n     */\n    Plugin.toString = function(plugin) {\n        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');\n    };\n\n    /**\n     * Returns `true` if the object meets the minimum standard to be considered a plugin.\n     * This means it must define the following properties:\n     * - `name`\n     * - `version`\n     * - `install`\n     * @method isPlugin\n     * @param obj {} The obj to test.\n     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\n     */\n    Plugin.isPlugin = function(obj) {\n        return obj && obj.name && obj.version && obj.install;\n    };\n\n    /**\n     * Returns `true` if a plugin with the given `name` been installed on `module`.\n     * @method isUsed\n     * @param module {} The module.\n     * @param name {string} The plugin name.\n     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\n     */\n    Plugin.isUsed = function(module, name) {\n        return module.used.indexOf(name) > -1;\n    };\n\n    /**\n     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\n     * If `plugin.for` is not specified then it is assumed to be applicable.\n     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\n     * @method isFor\n     * @param plugin {} The plugin.\n     * @param module {} The module.\n     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\n     */\n    Plugin.isFor = function(plugin, module) {\n        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);\n        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));\n    };\n\n    /**\n     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\n     * For installing plugins on `Matter` see the convenience function `Matter.use`.\n     * Plugins may be specified either by their name or a reference to the plugin object.\n     * Plugins themselves may specify further dependencies, but each plugin is installed only once.\n     * Order is important, a topological sort is performed to find the best resulting order of installation.\n     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\n     * This function logs the resulting status of each dependency in the console, along with any warnings.\n     * - A green tick  indicates a dependency was resolved and installed.\n     * - An orange diamond  indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\n     * - A red cross  indicates a dependency could not be resolved.\n     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\n     * @method use\n     * @param module {} The module install plugins on.\n     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\n     */\n    Plugin.use = function(module, plugins) {\n        module.uses = (module.uses || []).concat(plugins || []);\n\n        if (module.uses.length === 0) {\n            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');\n            return;\n        }\n\n        var dependencies = Plugin.dependencies(module),\n            sortedDependencies = Common.topologicalSort(dependencies),\n            status = [];\n\n        for (var i = 0; i < sortedDependencies.length; i += 1) {\n            if (sortedDependencies[i] === module.name) {\n                continue;\n            }\n\n            var plugin = Plugin.resolve(sortedDependencies[i]);\n\n            if (!plugin) {\n                status.push(' ' + sortedDependencies[i]);\n                continue;\n            }\n\n            if (Plugin.isUsed(module, plugin.name)) {\n                continue;\n            }\n\n            if (!Plugin.isFor(plugin, module)) {\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');\n                plugin._warned = true;\n            }\n\n            if (plugin.install) {\n                plugin.install(module);\n            } else {\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');\n                plugin._warned = true;\n            }\n\n            if (plugin._warned) {\n                status.push(' ' + Plugin.toString(plugin));\n                delete plugin._warned;\n            } else {\n                status.push(' ' + Plugin.toString(plugin));\n            }\n\n            module.used.push(plugin.name);\n        }\n\n        if (status.length > 0) {\n            Common.info(status.join('  '));\n        }\n    };\n\n    /**\n     * Recursively finds all of a module's dependencies and returns a flat dependency graph.\n     * @method dependencies\n     * @param module {} The module.\n     * @return {object} A dependency graph.\n     */\n    Plugin.dependencies = function(module, tracked) {\n        var parsedBase = Plugin.dependencyParse(module),\n            name = parsedBase.name;\n\n        tracked = tracked || {};\n\n        if (name in tracked) {\n            return;\n        }\n\n        module = Plugin.resolve(module) || module;\n\n        tracked[name] = Common.map(module.uses || [], function(dependency) {\n            if (Plugin.isPlugin(dependency)) {\n                Plugin.register(dependency);\n            }\n\n            var parsed = Plugin.dependencyParse(dependency),\n                resolved = Plugin.resolve(dependency);\n\n            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {\n                Common.warn(\n                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',\n                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'\n                );\n\n                resolved._warned = true;\n                module._warned = true;\n            } else if (!resolved) {\n                Common.warn(\n                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',\n                    Plugin.toString(parsedBase), 'could not be resolved.'\n                );\n\n                module._warned = true;\n            }\n\n            return parsed.name;\n        });\n\n        for (var i = 0; i < tracked[name].length; i += 1) {\n            Plugin.dependencies(tracked[name][i], tracked);\n        }\n\n        return tracked;\n    };\n\n    /**\n     * Parses a dependency string into its components.\n     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * This function can also handle dependencies that are already resolved (e.g. a module object).\n     * @method dependencyParse\n     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\n     * @return {object} The dependency parsed into its components.\n     */\n    Plugin.dependencyParse = function(dependency) {\n        if (Common.isString(dependency)) {\n            var pattern = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-]+)?))?$/;\n\n            if (!pattern.test(dependency)) {\n                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');\n            }\n\n            return {\n                name: dependency.split('@')[0],\n                range: dependency.split('@')[1] || '*'\n            };\n        }\n\n        return {\n            name: dependency.name,\n            range: dependency.range || dependency.version\n        };\n    };\n\n    /**\n     * Parses a version string into its components.  \n     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\n     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\n     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\n     * Only the following range types are supported:\n     * - Tilde ranges e.g. `~1.2.3`\n     * - Caret ranges e.g. `^1.2.3`\n     * - Greater than ranges e.g. `>1.2.3`\n     * - Greater than or equal ranges e.g. `>=1.2.3`\n     * - Exact version e.g. `1.2.3`\n     * - Any version `*`\n     * @method versionParse\n     * @param range {string} The version string.\n     * @return {object} The version range parsed into its components.\n     */\n    Plugin.versionParse = function(range) {\n        var pattern = /^(\\*)|(\\^|~|>=|>)?\\s*((\\d+)\\.(\\d+)\\.(\\d+))(-[0-9A-Za-z-]+)?$/;\n\n        if (!pattern.test(range)) {\n            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');\n        }\n\n        var parts = pattern.exec(range);\n        var major = Number(parts[4]);\n        var minor = Number(parts[5]);\n        var patch = Number(parts[6]);\n\n        return {\n            isRange: Boolean(parts[1] || parts[2]),\n            version: parts[3],\n            range: range,\n            operator: parts[1] || parts[2] || '',\n            major: major,\n            minor: minor,\n            patch: patch,\n            parts: [major, minor, patch],\n            prerelease: parts[7],\n            number: major * 1e8 + minor * 1e4 + patch\n        };\n    };\n\n    /**\n     * Returns `true` if `version` satisfies the given `range`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\n     * @method versionSatisfies\n     * @param version {string} The version string.\n     * @param range {string} The range string.\n     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\n     */\n    Plugin.versionSatisfies = function(version, range) {\n        range = range || '*';\n\n        var r = Plugin.versionParse(range),\n            v = Plugin.versionParse(version);\n\n        if (r.isRange) {\n            if (r.operator === '*' || version === '*') {\n                return true;\n            }\n\n            if (r.operator === '>') {\n                return v.number > r.number;\n            }\n\n            if (r.operator === '>=') {\n                return v.number >= r.number;\n            }\n\n            if (r.operator === '~') {\n                return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;\n            }\n\n            if (r.operator === '^') {\n                if (r.major > 0) {\n                    return v.major === r.major && v.number >= r.number;\n                }\n\n                if (r.minor > 0) {\n                    return v.minor === r.minor && v.patch >= r.patch;\n                }\n\n                return v.patch === r.patch;\n            }\n        }\n\n        return version === range || version === '*';\n    };\n\n})();\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Render` module is a simple canvas based renderer for visualising instances of `Matter.Engine`.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.\n*\n* @class Render\n*/\n\nvar Render = {};\n\nmodule.exports = Render;\n\nvar Common = __webpack_require__(0);\nvar Composite = __webpack_require__(5);\nvar Bounds = __webpack_require__(1);\nvar Events = __webpack_require__(4);\nvar Vector = __webpack_require__(2);\nvar Mouse = __webpack_require__(12);\n\n(function() {\n\n    var _requestAnimationFrame,\n        _cancelAnimationFrame;\n\n    if (typeof window !== 'undefined') {\n        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\n                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\n                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };\n\n        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame\n                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n    }\n\n    Render._goodFps = 30;\n    Render._goodDelta = 1000 / 60;\n\n    /**\n     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {render} A new renderer\n     */\n    Render.create = function(options) {\n        var defaults = {\n            controller: Render,\n            engine: null,\n            element: null,\n            canvas: null,\n            mouse: null,\n            frameRequestId: null,\n            timing: {\n                historySize: 60,\n                delta: 0,\n                deltaHistory: [],\n                lastTime: 0,\n                lastTimestamp: 0,\n                lastElapsed: 0,\n                timestampElapsed: 0,\n                timestampElapsedHistory: [],\n                engineDeltaHistory: [],\n                engineElapsedHistory: [],\n                elapsedHistory: []\n            },\n            options: {\n                width: 800,\n                height: 600,\n                pixelRatio: 1,\n                background: '#14151f',\n                wireframeBackground: '#14151f',\n                hasBounds: !!options.bounds,\n                enabled: true,\n                wireframes: true,\n                showSleeping: true,\n                showDebug: false,\n                showStats: false,\n                showPerformance: false,\n                showBroadphase: false,\n                showBounds: false,\n                showVelocity: false,\n                showCollisions: false,\n                showSeparations: false,\n                showAxes: false,\n                showPositions: false,\n                showAngleIndicator: false,\n                showIds: false,\n                showVertexNumbers: false,\n                showConvexHulls: false,\n                showInternalEdges: false,\n                showMousePosition: false\n            }\n        };\n\n        var render = Common.extend(defaults, options);\n\n        if (render.canvas) {\n            render.canvas.width = render.options.width || render.canvas.width;\n            render.canvas.height = render.options.height || render.canvas.height;\n        }\n\n        render.mouse = options.mouse;\n        render.engine = options.engine;\n        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);\n        render.context = render.canvas.getContext('2d');\n        render.textures = {};\n\n        render.bounds = render.bounds || {\n            min: {\n                x: 0,\n                y: 0\n            },\n            max: {\n                x: render.canvas.width,\n                y: render.canvas.height\n            }\n        };\n\n        if (render.options.pixelRatio !== 1) {\n            Render.setPixelRatio(render, render.options.pixelRatio);\n        }\n\n        if (Common.isElement(render.element)) {\n            render.element.appendChild(render.canvas);\n        } else if (!render.canvas.parentNode) {\n            Common.log('Render.create: options.element was undefined, render.canvas was created but not appended', 'warn');\n        }\n\n        return render;\n    };\n\n    /**\n     * Continuously updates the render canvas on the `requestAnimationFrame` event.\n     * @method run\n     * @param {render} render\n     */\n    Render.run = function(render) {\n        (function loop(time){\n            render.frameRequestId = _requestAnimationFrame(loop);\n            \n            _updateTiming(render, time);\n\n            Render.world(render, time);\n\n            if (render.options.showStats || render.options.showDebug) {\n                Render.stats(render, render.context, time);\n            }\n\n            if (render.options.showPerformance || render.options.showDebug) {\n                Render.performance(render, render.context, time);\n            }\n        })();\n    };\n\n    /**\n     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.\n     * @method stop\n     * @param {render} render\n     */\n    Render.stop = function(render) {\n        _cancelAnimationFrame(render.frameRequestId);\n    };\n\n    /**\n     * Sets the pixel ratio of the renderer and updates the canvas.\n     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.\n     * @method setPixelRatio\n     * @param {render} render\n     * @param {number} pixelRatio\n     */\n    Render.setPixelRatio = function(render, pixelRatio) {\n        var options = render.options,\n            canvas = render.canvas;\n\n        if (pixelRatio === 'auto') {\n            pixelRatio = _getPixelRatio(canvas);\n        }\n\n        options.pixelRatio = pixelRatio;\n        canvas.setAttribute('data-pixel-ratio', pixelRatio);\n        canvas.width = options.width * pixelRatio;\n        canvas.height = options.height * pixelRatio;\n        canvas.style.width = options.width + 'px';\n        canvas.style.height = options.height + 'px';\n    };\n\n    /**\n     * Positions and sizes the viewport around the given object bounds.\n     * Objects must have at least one of the following properties:\n     * - `object.bounds`\n     * - `object.position`\n     * - `object.min` and `object.max`\n     * - `object.x` and `object.y`\n     * @method lookAt\n     * @param {render} render\n     * @param {object[]} objects\n     * @param {vector} [padding]\n     * @param {bool} [center=true]\n     */\n    Render.lookAt = function(render, objects, padding, center) {\n        center = typeof center !== 'undefined' ? center : true;\n        objects = Common.isArray(objects) ? objects : [objects];\n        padding = padding || {\n            x: 0,\n            y: 0\n        };\n\n        // find bounds of all objects\n        var bounds = {\n            min: { x: Infinity, y: Infinity },\n            max: { x: -Infinity, y: -Infinity }\n        };\n\n        for (var i = 0; i < objects.length; i += 1) {\n            var object = objects[i],\n                min = object.bounds ? object.bounds.min : (object.min || object.position || object),\n                max = object.bounds ? object.bounds.max : (object.max || object.position || object);\n\n            if (min && max) {\n                if (min.x < bounds.min.x)\n                    bounds.min.x = min.x;\n\n                if (max.x > bounds.max.x)\n                    bounds.max.x = max.x;\n\n                if (min.y < bounds.min.y)\n                    bounds.min.y = min.y;\n\n                if (max.y > bounds.max.y)\n                    bounds.max.y = max.y;\n            }\n        }\n\n        // find ratios\n        var width = (bounds.max.x - bounds.min.x) + 2 * padding.x,\n            height = (bounds.max.y - bounds.min.y) + 2 * padding.y,\n            viewHeight = render.canvas.height,\n            viewWidth = render.canvas.width,\n            outerRatio = viewWidth / viewHeight,\n            innerRatio = width / height,\n            scaleX = 1,\n            scaleY = 1;\n\n        // find scale factor\n        if (innerRatio > outerRatio) {\n            scaleY = innerRatio / outerRatio;\n        } else {\n            scaleX = outerRatio / innerRatio;\n        }\n\n        // enable bounds\n        render.options.hasBounds = true;\n\n        // position and size\n        render.bounds.min.x = bounds.min.x;\n        render.bounds.max.x = bounds.min.x + width * scaleX;\n        render.bounds.min.y = bounds.min.y;\n        render.bounds.max.y = bounds.min.y + height * scaleY;\n\n        // center\n        if (center) {\n            render.bounds.min.x += width * 0.5 - (width * scaleX) * 0.5;\n            render.bounds.max.x += width * 0.5 - (width * scaleX) * 0.5;\n            render.bounds.min.y += height * 0.5 - (height * scaleY) * 0.5;\n            render.bounds.max.y += height * 0.5 - (height * scaleY) * 0.5;\n        }\n\n        // padding\n        render.bounds.min.x -= padding.x;\n        render.bounds.max.x -= padding.x;\n        render.bounds.min.y -= padding.y;\n        render.bounds.max.y -= padding.y;\n\n        // update mouse\n        if (render.mouse) {\n            Mouse.setScale(render.mouse, {\n                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,\n                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height\n            });\n\n            Mouse.setOffset(render.mouse, render.bounds.min);\n        }\n    };\n\n    /**\n     * Applies viewport transforms based on `render.bounds` to a render context.\n     * @method startViewTransform\n     * @param {render} render\n     */\n    Render.startViewTransform = function(render) {\n        var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n            boundsHeight = render.bounds.max.y - render.bounds.min.y,\n            boundsScaleX = boundsWidth / render.options.width,\n            boundsScaleY = boundsHeight / render.options.height;\n\n        render.context.setTransform(\n            render.options.pixelRatio / boundsScaleX, 0, 0, \n            render.options.pixelRatio / boundsScaleY, 0, 0\n        );\n        \n        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);\n    };\n\n    /**\n     * Resets all transforms on the render context.\n     * @method endViewTransform\n     * @param {render} render\n     */\n    Render.endViewTransform = function(render) {\n        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n    };\n\n    /**\n     * Renders the given `engine`'s `Matter.World` object.\n     * This is the entry point for all rendering and should be called every time the scene changes.\n     * @method world\n     * @param {render} render\n     */\n    Render.world = function(render, time) {\n        var startTime = Common.now(),\n            engine = render.engine,\n            world = engine.world,\n            canvas = render.canvas,\n            context = render.context,\n            options = render.options,\n            timing = render.timing;\n\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world),\n            background = options.wireframes ? options.wireframeBackground : options.background,\n            bodies = [],\n            constraints = [],\n            i;\n\n        var event = {\n            timestamp: engine.timing.timestamp\n        };\n\n        Events.trigger(render, 'beforeRender', event);\n\n        // apply background if it has changed\n        if (render.currentBackground !== background)\n            _applyBackground(render, background);\n\n        // clear the canvas with a transparent fill, to allow the canvas background to show\n        context.globalCompositeOperation = 'source-in';\n        context.fillStyle = \"transparent\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        context.globalCompositeOperation = 'source-over';\n\n        // handle bounds\n        if (options.hasBounds) {\n            // filter out bodies that are not in view\n            for (i = 0; i < allBodies.length; i++) {\n                var body = allBodies[i];\n                if (Bounds.overlaps(body.bounds, render.bounds))\n                    bodies.push(body);\n            }\n\n            // filter out constraints that are not in view\n            for (i = 0; i < allConstraints.length; i++) {\n                var constraint = allConstraints[i],\n                    bodyA = constraint.bodyA,\n                    bodyB = constraint.bodyB,\n                    pointAWorld = constraint.pointA,\n                    pointBWorld = constraint.pointB;\n\n                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n\n                if (!pointAWorld || !pointBWorld)\n                    continue;\n\n                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))\n                    constraints.push(constraint);\n            }\n\n            // transform the view\n            Render.startViewTransform(render);\n\n            // update mouse\n            if (render.mouse) {\n                Mouse.setScale(render.mouse, {\n                    x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,\n                    y: (render.bounds.max.y - render.bounds.min.y) / render.options.height\n                });\n\n                Mouse.setOffset(render.mouse, render.bounds.min);\n            }\n        } else {\n            constraints = allConstraints;\n            bodies = allBodies;\n\n            if (render.options.pixelRatio !== 1) {\n                render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n            }\n        }\n\n        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {\n            // fully featured rendering of bodies\n            Render.bodies(render, bodies, context);\n        } else {\n            if (options.showConvexHulls)\n                Render.bodyConvexHulls(render, bodies, context);\n\n            // optimised method for wireframes only\n            Render.bodyWireframes(render, bodies, context);\n        }\n\n        if (options.showBounds)\n            Render.bodyBounds(render, bodies, context);\n\n        if (options.showAxes || options.showAngleIndicator)\n            Render.bodyAxes(render, bodies, context);\n\n        if (options.showPositions)\n            Render.bodyPositions(render, bodies, context);\n\n        if (options.showVelocity)\n            Render.bodyVelocity(render, bodies, context);\n\n        if (options.showIds)\n            Render.bodyIds(render, bodies, context);\n\n        if (options.showSeparations)\n            Render.separations(render, engine.pairs.list, context);\n\n        if (options.showCollisions)\n            Render.collisions(render, engine.pairs.list, context);\n\n        if (options.showVertexNumbers)\n            Render.vertexNumbers(render, bodies, context);\n\n        if (options.showMousePosition)\n            Render.mousePosition(render, render.mouse, context);\n\n        Render.constraints(constraints, context);\n\n        if (options.showBroadphase)\n            Render.grid(render, engine.grid, context);\n\n        if (options.hasBounds) {\n            // revert view transforms\n            Render.endViewTransform(render);\n        }\n\n        Events.trigger(render, 'afterRender', event);\n\n        // log the time elapsed computing this update\n        timing.lastElapsed = Common.now() - startTime;\n    };\n\n    /**\n     * Renders statistics about the engine and world useful for debugging.\n     * @private\n     * @method stats\n     * @param {render} render\n     * @param {RenderingContext} context\n     * @param {Number} time\n     */\n    Render.stats = function(render, context, time) {\n        var engine = render.engine,\n            world = engine.world,\n            bodies = Composite.allBodies(world),\n            parts = 0,\n            width = 55,\n            height = 44,\n            x = 0,\n            y = 0;\n        \n        // count parts\n        for (var i = 0; i < bodies.length; i += 1) {\n            parts += bodies[i].parts.length;\n        }\n\n        // sections\n        var sections = {\n            'Part': parts,\n            'Body': bodies.length,\n            'Cons': Composite.allConstraints(world).length,\n            'Comp': Composite.allComposites(world).length,\n            'Pair': engine.pairs.list.length\n        };\n\n        // background\n        context.fillStyle = '#0e0f19';\n        context.fillRect(x, y, width * 5.5, height);\n\n        context.font = '12px Arial';\n        context.textBaseline = 'top';\n        context.textAlign = 'right';\n\n        // sections\n        for (var key in sections) {\n            var section = sections[key];\n            // label\n            context.fillStyle = '#aaa';\n            context.fillText(key, x + width, y + 8);\n\n            // value\n            context.fillStyle = '#eee';\n            context.fillText(section, x + width, y + 26);\n\n            x += width;\n        }\n    };\n\n    /**\n     * Renders engine and render performance information.\n     * @private\n     * @method performance\n     * @param {render} render\n     * @param {RenderingContext} context\n     */\n    Render.performance = function(render, context) {\n        var engine = render.engine,\n            timing = render.timing,\n            deltaHistory = timing.deltaHistory,\n            elapsedHistory = timing.elapsedHistory,\n            timestampElapsedHistory = timing.timestampElapsedHistory,\n            engineDeltaHistory = timing.engineDeltaHistory,\n            engineElapsedHistory = timing.engineElapsedHistory,\n            lastEngineDelta = engine.timing.lastDelta;\n        \n        var deltaMean = _mean(deltaHistory),\n            elapsedMean = _mean(elapsedHistory),\n            engineDeltaMean = _mean(engineDeltaHistory),\n            engineElapsedMean = _mean(engineElapsedHistory),\n            timestampElapsedMean = _mean(timestampElapsedHistory),\n            rateMean = (timestampElapsedMean / deltaMean) || 0,\n            fps = (1000 / deltaMean) || 0;\n\n        var graphHeight = 4,\n            gap = 12,\n            width = 60,\n            height = 34,\n            x = 10,\n            y = 69;\n\n        // background\n        context.fillStyle = '#0e0f19';\n        context.fillRect(0, 50, gap * 4 + width * 5 + 22, height);\n\n        // show FPS\n        Render.status(\n            context, x, y, width, graphHeight, deltaHistory.length, \n            Math.round(fps) + ' fps', \n            fps / Render._goodFps,\n            function(i) { return (deltaHistory[i] / deltaMean) - 1; }\n        );\n\n        // show engine delta\n        Render.status(\n            context, x + gap + width, y, width, graphHeight, engineDeltaHistory.length,\n            lastEngineDelta.toFixed(2) + ' dt', \n            Render._goodDelta / lastEngineDelta,\n            function(i) { return (engineDeltaHistory[i] / engineDeltaMean) - 1; }\n        );\n\n        // show engine update time\n        Render.status(\n            context, x + (gap + width) * 2, y, width, graphHeight, engineElapsedHistory.length,\n            engineElapsedMean.toFixed(2) + ' ut', \n            1 - (engineElapsedMean / Render._goodFps),\n            function(i) { return (engineElapsedHistory[i] / engineElapsedMean) - 1; }\n        );\n\n        // show render time\n        Render.status(\n            context, x + (gap + width) * 3, y, width, graphHeight, elapsedHistory.length,\n            elapsedMean.toFixed(2) + ' rt', \n            1 - (elapsedMean / Render._goodFps),\n            function(i) { return (elapsedHistory[i] / elapsedMean) - 1; }\n        );\n\n        // show effective speed\n        Render.status(\n            context, x + (gap + width) * 4, y, width, graphHeight, timestampElapsedHistory.length, \n            rateMean.toFixed(2) + ' x', \n            rateMean * rateMean * rateMean,\n            function(i) { return (((timestampElapsedHistory[i] / deltaHistory[i]) / rateMean) || 0) - 1; }\n        );\n    };\n\n    /**\n     * Renders a label, indicator and a chart.\n     * @private\n     * @method status\n     * @param {RenderingContext} context\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} count\n     * @param {string} label\n     * @param {string} indicator\n     * @param {function} plotY\n     */\n    Render.status = function(context, x, y, width, height, count, label, indicator, plotY) {\n        // background\n        context.strokeStyle = '#888';\n        context.fillStyle = '#444';\n        context.lineWidth = 1;\n        context.fillRect(x, y + 7, width, 1);\n\n        // chart\n        context.beginPath();\n        context.moveTo(x, y + 7 - height * Common.clamp(0.4 * plotY(0), -2, 2));\n        for (var i = 0; i < width; i += 1) {\n            context.lineTo(x + i, y + 7 - (i < count ? height * Common.clamp(0.4 * plotY(i), -2, 2) : 0));\n        }\n        context.stroke();\n\n        // indicator\n        context.fillStyle = 'hsl(' + Common.clamp(25 + 95 * indicator, 0, 120) + ',100%,60%)';\n        context.fillRect(x, y - 7, 4, 4);\n\n        // label\n        context.font = '12px Arial';\n        context.textBaseline = 'middle';\n        context.textAlign = 'right';\n        context.fillStyle = '#eee';\n        context.fillText(label, x + width, y - 5);\n    };\n\n    /**\n     * Description\n     * @private\n     * @method constraints\n     * @param {constraint[]} constraints\n     * @param {RenderingContext} context\n     */\n    Render.constraints = function(constraints, context) {\n        var c = context;\n\n        for (var i = 0; i < constraints.length; i++) {\n            var constraint = constraints[i];\n\n            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)\n                continue;\n\n            var bodyA = constraint.bodyA,\n                bodyB = constraint.bodyB,\n                start,\n                end;\n\n            if (bodyA) {\n                start = Vector.add(bodyA.position, constraint.pointA);\n            } else {\n                start = constraint.pointA;\n            }\n\n            if (constraint.render.type === 'pin') {\n                c.beginPath();\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                c.closePath();\n            } else {\n                if (bodyB) {\n                    end = Vector.add(bodyB.position, constraint.pointB);\n                } else {\n                    end = constraint.pointB;\n                }\n\n                c.beginPath();\n                c.moveTo(start.x, start.y);\n\n                if (constraint.render.type === 'spring') {\n                    var delta = Vector.sub(end, start),\n                        normal = Vector.perp(Vector.normalise(delta)),\n                        coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)),\n                        offset;\n\n                    for (var j = 1; j < coils; j += 1) {\n                        offset = j % 2 === 0 ? 1 : -1;\n\n                        c.lineTo(\n                            start.x + delta.x * (j / coils) + normal.x * offset * 4,\n                            start.y + delta.y * (j / coils) + normal.y * offset * 4\n                        );\n                    }\n                }\n\n                c.lineTo(end.x, end.y);\n            }\n\n            if (constraint.render.lineWidth) {\n                c.lineWidth = constraint.render.lineWidth;\n                c.strokeStyle = constraint.render.strokeStyle;\n                c.stroke();\n            }\n\n            if (constraint.render.anchors) {\n                c.fillStyle = constraint.render.strokeStyle;\n                c.beginPath();\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                c.arc(end.x, end.y, 3, 0, 2 * Math.PI);\n                c.closePath();\n                c.fill();\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method bodies\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodies = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            showInternalEdges = options.showInternalEdges || !options.wireframes,\n            body,\n            part,\n            i,\n            k;\n\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n\n                if (!part.render.visible)\n                    continue;\n\n                if (options.showSleeping && body.isSleeping) {\n                    c.globalAlpha = 0.5 * part.render.opacity;\n                } else if (part.render.opacity !== 1) {\n                    c.globalAlpha = part.render.opacity;\n                }\n\n                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {\n                    // part sprite\n                    var sprite = part.render.sprite,\n                        texture = _getTexture(render, sprite.texture);\n\n                    c.translate(part.position.x, part.position.y);\n                    c.rotate(part.angle);\n\n                    c.drawImage(\n                        texture,\n                        texture.width * -sprite.xOffset * sprite.xScale,\n                        texture.height * -sprite.yOffset * sprite.yScale,\n                        texture.width * sprite.xScale,\n                        texture.height * sprite.yScale\n                    );\n\n                    // revert translation, hopefully faster than save / restore\n                    c.rotate(-part.angle);\n                    c.translate(-part.position.x, -part.position.y);\n                } else {\n                    // part polygon\n                    if (part.circleRadius) {\n                        c.beginPath();\n                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\n                    } else {\n                        c.beginPath();\n                        c.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n                        for (var j = 1; j < part.vertices.length; j++) {\n                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                                c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                            } else {\n                                c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                            }\n\n                            if (part.vertices[j].isInternal && !showInternalEdges) {\n                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                            }\n                        }\n\n                        c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                        c.closePath();\n                    }\n\n                    if (!options.wireframes) {\n                        c.fillStyle = part.render.fillStyle;\n\n                        if (part.render.lineWidth) {\n                            c.lineWidth = part.render.lineWidth;\n                            c.strokeStyle = part.render.strokeStyle;\n                            c.stroke();\n                        }\n\n                        c.fill();\n                    } else {\n                        c.lineWidth = 1;\n                        c.strokeStyle = '#bbb';\n                        c.stroke();\n                    }\n                }\n\n                c.globalAlpha = 1;\n            }\n        }\n    };\n\n    /**\n     * Optimised method for drawing body wireframes in one pass\n     * @private\n     * @method bodyWireframes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyWireframes = function(render, bodies, context) {\n        var c = context,\n            showInternalEdges = render.options.showInternalEdges,\n            body,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        // render all bodies\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n\n                c.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n                for (j = 1; j < part.vertices.length; j++) {\n                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                        c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                    } else {\n                        c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                    }\n\n                    if (part.vertices[j].isInternal && !showInternalEdges) {\n                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                    }\n                }\n\n                c.lineTo(part.vertices[0].x, part.vertices[0].y);\n            }\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = '#bbb';\n        c.stroke();\n    };\n\n    /**\n     * Optimised method for drawing body convex hull wireframes in one pass\n     * @private\n     * @method bodyConvexHulls\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyConvexHulls = function(render, bodies, context) {\n        var c = context,\n            body,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        // render convex hulls\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible || body.parts.length === 1)\n                continue;\n\n            c.moveTo(body.vertices[0].x, body.vertices[0].y);\n\n            for (j = 1; j < body.vertices.length; j++) {\n                c.lineTo(body.vertices[j].x, body.vertices[j].y);\n            }\n\n            c.lineTo(body.vertices[0].x, body.vertices[0].y);\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = 'rgba(255,255,255,0.2)';\n        c.stroke();\n    };\n\n    /**\n     * Renders body vertex numbers.\n     * @private\n     * @method vertexNumbers\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.vertexNumbers = function(render, bodies, context) {\n        var c = context,\n            i,\n            j,\n            k;\n\n        for (i = 0; i < bodies.length; i++) {\n            var parts = bodies[i].parts;\n            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {\n                var part = parts[k];\n                for (j = 0; j < part.vertices.length; j++) {\n                    c.fillStyle = 'rgba(255,255,255,0.2)';\n                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);\n                }\n            }\n        }\n    };\n\n    /**\n     * Renders mouse position.\n     * @private\n     * @method mousePosition\n     * @param {render} render\n     * @param {mouse} mouse\n     * @param {RenderingContext} context\n     */\n    Render.mousePosition = function(render, mouse, context) {\n        var c = context;\n        c.fillStyle = 'rgba(255,255,255,0.8)';\n        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);\n    };\n\n    /**\n     * Draws body bounds\n     * @private\n     * @method bodyBounds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyBounds = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.render.visible) {\n                var parts = bodies[i].parts;\n                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    var part = parts[j];\n                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);\n                }\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,255,255,0.08)';\n        } else {\n            c.strokeStyle = 'rgba(0,0,0,0.1)';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Draws body angle indicators and axes\n     * @private\n     * @method bodyAxes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyAxes = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                parts = body.parts;\n\n            if (!body.render.visible)\n                continue;\n\n            if (options.showAxes) {\n                // render all axes\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    part = parts[j];\n                    for (k = 0; k < part.axes.length; k++) {\n                        var axis = part.axes[k];\n                        c.moveTo(part.position.x, part.position.y);\n                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);\n                    }\n                }\n            } else {\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    part = parts[j];\n                    for (k = 0; k < part.axes.length; k++) {\n                        // render a single axis indicator\n                        c.moveTo(part.position.x, part.position.y);\n                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2,\n                            (part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2);\n                    }\n                }\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'indianred';\n            c.lineWidth = 1;\n        } else {\n            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n            c.globalCompositeOperation = 'overlay';\n            c.lineWidth = 2;\n        }\n\n        c.stroke();\n        c.globalCompositeOperation = 'source-over';\n    };\n\n    /**\n     * Draws body positions\n     * @private\n     * @method bodyPositions\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyPositions = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            body,\n            part,\n            i,\n            k;\n\n        c.beginPath();\n\n        // render current positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'indianred';\n        } else {\n            c.fillStyle = 'rgba(0,0,0,0.5)';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render previous positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (body.render.visible) {\n                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        c.fillStyle = 'rgba(255,165,0,0.8)';\n        c.fill();\n    };\n\n    /**\n     * Draws body velocity\n     * @private\n     * @method bodyVelocity\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyVelocity = function(render, bodies, context) {\n        var c = context;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            c.moveTo(body.position.x, body.position.y);\n            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);\n        }\n\n        c.lineWidth = 3;\n        c.strokeStyle = 'cornflowerblue';\n        c.stroke();\n    };\n\n    /**\n     * Draws body ids\n     * @private\n     * @method bodyIds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyIds = function(render, bodies, context) {\n        var c = context,\n            i,\n            j;\n\n        for (i = 0; i < bodies.length; i++) {\n            if (!bodies[i].render.visible)\n                continue;\n\n            var parts = bodies[i].parts;\n            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                var part = parts[j];\n                c.font = \"12px Arial\";\n                c.fillStyle = 'rgba(255,255,255,0.5)';\n                c.fillText(part.id, part.position.x + 10, part.position.y - 10);\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method collisions\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.collisions = function(render, pairs, context) {\n        var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render collision positions\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            for (j = 0; j < pair.activeContacts.length; j++) {\n                var contact = pair.activeContacts[j],\n                    vertex = contact.vertex;\n                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'rgba(255,255,255,0.7)';\n        } else {\n            c.fillStyle = 'orange';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render collision normals\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n\n            if (pair.activeContacts.length > 0) {\n                var normalPosX = pair.activeContacts[0].vertex.x,\n                    normalPosY = pair.activeContacts[0].vertex.y;\n\n                if (pair.activeContacts.length === 2) {\n                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;\n                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;\n                }\n\n                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {\n                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\n                } else {\n                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);\n                }\n\n                c.lineTo(normalPosX, normalPosY);\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.7)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method separations\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.separations = function(render, pairs, context) {\n        var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render separations\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.bodyA;\n            bodyB = collision.bodyB;\n\n            var k = 1;\n\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyB.isStatic) k = 0;\n\n            c.moveTo(bodyB.position.x, bodyB.position.y);\n            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);\n\n            k = 1;\n\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyA.isStatic) k = 0;\n\n            c.moveTo(bodyA.position.x, bodyA.position.y);\n            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.5)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method grid\n     * @param {render} render\n     * @param {grid} grid\n     * @param {RenderingContext} context\n     */\n    Render.grid = function(render, grid, context) {\n        var c = context,\n            options = render.options;\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,180,0,0.1)';\n        } else {\n            c.strokeStyle = 'rgba(255,180,0,0.5)';\n        }\n\n        c.beginPath();\n\n        var bucketKeys = Common.keys(grid.buckets);\n\n        for (var i = 0; i < bucketKeys.length; i++) {\n            var bucketId = bucketKeys[i];\n\n            if (grid.buckets[bucketId].length < 2)\n                continue;\n\n            var region = bucketId.split(/C|R/);\n            c.rect(0.5 + parseInt(region[1], 10) * grid.bucketWidth,\n                0.5 + parseInt(region[2], 10) * grid.bucketHeight,\n                grid.bucketWidth,\n                grid.bucketHeight);\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method inspector\n     * @param {inspector} inspector\n     * @param {RenderingContext} context\n     */\n    Render.inspector = function(inspector, context) {\n        var engine = inspector.engine,\n            selected = inspector.selected,\n            render = inspector.render,\n            options = render.options,\n            bounds;\n\n        if (options.hasBounds) {\n            var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n                boundsHeight = render.bounds.max.y - render.bounds.min.y,\n                boundsScaleX = boundsWidth / render.options.width,\n                boundsScaleY = boundsHeight / render.options.height;\n\n            context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n            context.translate(-render.bounds.min.x, -render.bounds.min.y);\n        }\n\n        for (var i = 0; i < selected.length; i++) {\n            var item = selected[i].data;\n\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.9)';\n            context.setLineDash([1,2]);\n\n            switch (item.type) {\n\n            case 'body':\n\n                // render body selections\n                bounds = item.bounds;\n                context.beginPath();\n                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3),\n                    Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            case 'constraint':\n\n                // render constraint selections\n                var point = item.pointA;\n                if (item.bodyA)\n                    point = item.pointB;\n                context.beginPath();\n                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            }\n\n            context.setLineDash([]);\n            context.translate(-0.5, -0.5);\n        }\n\n        // render selection region\n        if (inspector.selectStart !== null) {\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.6)';\n            context.fillStyle = 'rgba(255,165,0,0.1)';\n            bounds = inspector.selectBounds;\n            context.beginPath();\n            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y),\n                Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));\n            context.closePath();\n            context.stroke();\n            context.fill();\n            context.translate(-0.5, -0.5);\n        }\n\n        if (options.hasBounds)\n            context.setTransform(1, 0, 0, 1, 0, 0);\n    };\n\n    /**\n     * Updates render timing.\n     * @method _updateTiming\n     * @private\n     * @param {render} render\n     * @param {number} time\n     */\n    var _updateTiming = function(render, time) {\n        var engine = render.engine,\n            timing = render.timing,\n            historySize = timing.historySize,\n            timestamp = engine.timing.timestamp;\n\n        timing.delta = time - timing.lastTime || Render._goodDelta;\n        timing.lastTime = time;\n\n        timing.timestampElapsed = timestamp - timing.lastTimestamp || 0;\n        timing.lastTimestamp = timestamp;\n\n        timing.deltaHistory.unshift(timing.delta);\n        timing.deltaHistory.length = Math.min(timing.deltaHistory.length, historySize);\n\n        timing.engineDeltaHistory.unshift(engine.timing.lastDelta);\n        timing.engineDeltaHistory.length = Math.min(timing.engineDeltaHistory.length, historySize);\n\n        timing.timestampElapsedHistory.unshift(timing.timestampElapsed);\n        timing.timestampElapsedHistory.length = Math.min(timing.timestampElapsedHistory.length, historySize);\n\n        timing.engineElapsedHistory.unshift(engine.timing.lastElapsed);\n        timing.engineElapsedHistory.length = Math.min(timing.engineElapsedHistory.length, historySize);\n\n        timing.elapsedHistory.unshift(timing.lastElapsed);\n        timing.elapsedHistory.length = Math.min(timing.elapsedHistory.length, historySize);\n    };\n\n    /**\n     * Returns the mean value of the given numbers.\n     * @method _mean\n     * @private\n     * @param {Number[]} values\n     * @return {Number} the mean of given values\n     */\n    var _mean = function(values) {\n        var result = 0;\n        for (var i = 0; i < values.length; i += 1) {\n            result += values[i];\n        }\n        return (result / values.length) || 0;\n    };\n\n    /**\n     * @method _createCanvas\n     * @private\n     * @param {} width\n     * @param {} height\n     * @return canvas\n     */\n    var _createCanvas = function(width, height) {\n        var canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        canvas.oncontextmenu = function() { return false; };\n        canvas.onselectstart = function() { return false; };\n        return canvas;\n    };\n\n    /**\n     * Gets the pixel ratio of the canvas.\n     * @method _getPixelRatio\n     * @private\n     * @param {HTMLElement} canvas\n     * @return {Number} pixel ratio\n     */\n    var _getPixelRatio = function(canvas) {\n        var context = canvas.getContext('2d'),\n            devicePixelRatio = window.devicePixelRatio || 1,\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio\n                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio\n                                      || context.backingStorePixelRatio || 1;\n\n        return devicePixelRatio / backingStorePixelRatio;\n    };\n\n    /**\n     * Gets the requested texture (an Image) via its path\n     * @method _getTexture\n     * @private\n     * @param {render} render\n     * @param {string} imagePath\n     * @return {Image} texture\n     */\n    var _getTexture = function(render, imagePath) {\n        var image = render.textures[imagePath];\n\n        if (image)\n            return image;\n\n        image = render.textures[imagePath] = new Image();\n        image.src = imagePath;\n\n        return image;\n    };\n\n    /**\n     * Applies the background to the canvas using CSS.\n     * @method applyBackground\n     * @private\n     * @param {render} render\n     * @param {string} background\n     */\n    var _applyBackground = function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired before rendering\n    *\n    * @event beforeRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after rendering\n    *\n    * @event afterRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A back-reference to the `Matter.Render` module.\n     *\n     * @property controller\n     * @type render\n     */\n\n    /**\n     * A reference to the `Matter.Engine` instance to be used.\n     *\n     * @property engine\n     * @type engine\n     */\n\n    /**\n     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)\n     *\n     * @property element\n     * @type HTMLElement\n     * @default null\n     */\n\n    /**\n     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     * @default null\n     */\n\n    /**\n     * A `Bounds` object that specifies the drawing view region.\n     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).\n     * This allows for creating views that can pan or zoom around the scene.\n     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.\n     *\n     * @property bounds\n     * @type bounds\n     */\n\n    /**\n     * The 2d rendering context from the `render.canvas` element.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n\n    /**\n     * The sprite texture cache.\n     *\n     * @property textures\n     * @type {}\n     */\n\n    /**\n     * The mouse to render if `render.options.showMousePosition` is enabled.\n     *\n     * @property mouse\n     * @type mouse\n     * @default null\n     */\n\n    /**\n     * The configuration options of the renderer.\n     *\n     * @property options\n     * @type {}\n     */\n\n    /**\n     * The target width in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.width\n     * @type number\n     * @default 800\n     */\n\n    /**\n     * The target height in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.height\n     * @type number\n     * @default 600\n     */\n\n    /**\n     * The [pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio) to use when rendering.\n     *\n     * @property options.pixelRatio\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A CSS background color string to use when `render.options.wireframes` is disabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.background\n     * @type string\n     * @default '#14151f'\n     */\n\n    /**\n     * A CSS background color string to use when `render.options.wireframes` is enabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.wireframeBackground\n     * @type string\n     * @default '#14151f'\n     */\n\n    /**\n     * A flag that specifies if `render.bounds` should be used when rendering.\n     *\n     * @property options.hasBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable all debug information overlays together.  \n     * This includes and has priority over the values of:\n     *\n     * - `render.options.showStats`\n     * - `render.options.showPerformance`\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the engine stats info overlay.  \n     * From left to right, the values shown are:\n     *\n     * - body parts total\n     * - body total\n     * - constraints total\n     * - composites total\n     * - collision pairs total\n     *\n     * @property options.showStats\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable performance charts.  \n     * From left to right, the values shown are:\n     *\n     * - average render frequency (e.g. 60 fps)\n     * - exact engine delta time used for last update (e.g. 16.66ms)\n     * - average engine execution duration (e.g. 5.00ms)\n     * - average render execution duration (e.g. 0.40ms)\n     * - average effective play speed (e.g. '1.00x' is 'real-time')\n     *\n     * Each value is recorded over a fixed sample of past frames (60 frames).\n     *\n     * A chart shown below each value indicates the variance from the average over the sample.\n     * The more stable or fixed the value is the flatter the chart will appear.\n     *\n     * @property options.showPerformance\n     * @type boolean\n     * @default false\n     */\n    \n    /**\n     * A flag to enable or disable rendering entirely.\n     *\n     * @property options.enabled\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to toggle wireframe rendering otherwise solid fill rendering is used.\n     *\n     * @property options.wireframes\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A flag to enable or disable sleeping bodies indicators.\n     *\n     * @property options.showSleeping\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A flag to enable or disable the debug information overlay.\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the collision broadphase debug overlay.\n     *\n     * @property options.showBroadphase\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body bounds debug overlay.\n     *\n     * @property options.showBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body velocity debug overlay.\n     *\n     * @property options.showVelocity\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body collisions debug overlay.\n     *\n     * @property options.showCollisions\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the collision resolver separations debug overlay.\n     *\n     * @property options.showSeparations\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body axes debug overlay.\n     *\n     * @property options.showAxes\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body positions debug overlay.\n     *\n     * @property options.showPositions\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body angle debug overlay.\n     *\n     * @property options.showAngleIndicator\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body and part ids debug overlay.\n     *\n     * @property options.showIds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body vertex numbers debug overlay.\n     *\n     * @property options.showVertexNumbers\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body convex hulls debug overlay.\n     *\n     * @property options.showConvexHulls\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body internal edges debug overlay.\n     *\n     * @property options.showInternalEdges\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the mouse position debug overlay.\n     *\n     * @property options.showMousePosition\n     * @type boolean\n     * @default false\n     */\n\n})();\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.\n*\n* @class Contact\n*/\n\nvar Contact = {};\n\nmodule.exports = Contact;\n\n(function() {\n\n    /**\n     * Creates a new contact.\n     * @method create\n     * @param {vertex} vertex\n     * @return {contact} A new contact\n     */\n    Contact.create = function(vertex) {\n        return {\n            id: Contact.id(vertex),\n            vertex: vertex,\n            normalImpulse: 0,\n            tangentImpulse: 0\n        };\n    };\n    \n    /**\n     * Generates a contact id.\n     * @method id\n     * @param {vertex} vertex\n     * @return {string} Unique contactID\n     */\n    Contact.id = function(vertex) {\n        return vertex.body.id + '_' + vertex.index;\n    };\n\n})();\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\n* An engine is a controller that manages updating the simulation of the world.\n* See `Matter.Runner` for an optional game loop utility.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Engine\n*/\n\nvar Engine = {};\n\nmodule.exports = Engine;\n\nvar Sleeping = __webpack_require__(7);\nvar Resolver = __webpack_require__(19);\nvar Detector = __webpack_require__(13);\nvar Pairs = __webpack_require__(20);\nvar Grid = __webpack_require__(21);\nvar Events = __webpack_require__(4);\nvar Composite = __webpack_require__(5);\nvar Constraint = __webpack_require__(8);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(6);\n\n(function() {\n\n    /**\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {engine} engine\n     */\n    Engine.create = function(options) {\n        options = options || {};\n\n        var defaults = {\n            positionIterations: 6,\n            velocityIterations: 4,\n            constraintIterations: 2,\n            enableSleeping: false,\n            events: [],\n            plugin: {},\n            grid: null,\n            gravity: {\n                x: 0,\n                y: 1,\n                scale: 0.001\n            },\n            timing: {\n                timestamp: 0,\n                timeScale: 1,\n                lastDelta: 0,\n                lastElapsed: 0\n            }\n        };\n\n        var engine = Common.extend(defaults, options);\n\n        engine.world = options.world || Composite.create({ label: 'World' });\n        engine.grid = Grid.create(options.grid || options.broadphase);\n        engine.pairs = Pairs.create();\n\n        // temporary back compatibility\n        engine.world.gravity = engine.gravity;\n        engine.broadphase = engine.grid;\n        engine.metrics = {};\n        \n        return engine;\n    };\n\n    /**\n     * Moves the simulation forward in time by `delta` ms.\n     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.\n     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.\n     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.\n     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).\n     * See the paper on <a href=\"http://lonesock.net/article/verlet.html\">Time Corrected Verlet</a> for more information.\n     *\n     * Triggers `beforeUpdate` and `afterUpdate` events.\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\n     * @method update\n     * @param {engine} engine\n     * @param {number} [delta=16.666]\n     * @param {number} [correction=1]\n     */\n    Engine.update = function(engine, delta, correction) {\n        var startTime = Common.now();\n\n        delta = delta || 1000 / 60;\n        correction = correction || 1;\n\n        var world = engine.world,\n            timing = engine.timing,\n            grid = engine.grid,\n            gridPairs = [],\n            i;\n\n        // increment timestamp\n        timing.timestamp += delta * timing.timeScale;\n        timing.lastDelta = delta * timing.timeScale;\n\n        // create an event object\n        var event = {\n            timestamp: timing.timestamp\n        };\n\n        Events.trigger(engine, 'beforeUpdate', event);\n\n        // get lists of all bodies and constraints, no matter what composites they are in\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world);\n\n        // if sleeping enabled, call the sleeping controller\n        if (engine.enableSleeping)\n            Sleeping.update(allBodies, timing.timeScale);\n\n        // applies gravity to all bodies\n        Engine._bodiesApplyGravity(allBodies, engine.gravity);\n\n        // update all body position and rotation by integration\n        Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);\n\n        // update all constraints (first pass)\n        Constraint.preSolveAll(allBodies);\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, timing.timeScale);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // broadphase pass: find potential collision pairs\n\n        // if world is dirty, we must flush the whole grid\n        if (world.isModified)\n            Grid.clear(grid);\n\n        // update the grid buckets based on current bodies\n        Grid.update(grid, allBodies, engine, world.isModified);\n        gridPairs = grid.pairsList;\n\n        // clear all composite modified flags\n        if (world.isModified) {\n            Composite.setModified(world, false, false, true);\n        }\n\n        // narrowphase pass: find actual collisions, then create or update collision pairs\n        var collisions = Detector.collisions(gridPairs, engine);\n\n        // update collision pairs\n        var pairs = engine.pairs,\n            timestamp = timing.timestamp;\n        Pairs.update(pairs, collisions, timestamp);\n        Pairs.removeOld(pairs, timestamp);\n\n        // wake up bodies involved in collisions\n        if (engine.enableSleeping)\n            Sleeping.afterCollisions(pairs.list, timing.timeScale);\n\n        // trigger collision events\n        if (pairs.collisionStart.length > 0)\n            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });\n\n        // iteratively resolve position between collisions\n        Resolver.preSolvePosition(pairs.list);\n        for (i = 0; i < engine.positionIterations; i++) {\n            Resolver.solvePosition(pairs.list, timing.timeScale);\n        }\n        Resolver.postSolvePosition(allBodies);\n\n        // update all constraints (second pass)\n        Constraint.preSolveAll(allBodies);\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, timing.timeScale);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // iteratively resolve velocity between collisions\n        Resolver.preSolveVelocity(pairs.list);\n        for (i = 0; i < engine.velocityIterations; i++) {\n            Resolver.solveVelocity(pairs.list, timing.timeScale);\n        }\n\n        // trigger collision events\n        if (pairs.collisionActive.length > 0)\n            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });\n\n        if (pairs.collisionEnd.length > 0)\n            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });\n\n        // clear force buffers\n        Engine._bodiesClearForces(allBodies);\n\n        Events.trigger(engine, 'afterUpdate', event);\n\n        // log the time elapsed computing this update\n        engine.timing.lastElapsed = Common.now() - startTime;\n\n        return engine;\n    };\n    \n    /**\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\n     * @method merge\n     * @param {engine} engineA\n     * @param {engine} engineB\n     */\n    Engine.merge = function(engineA, engineB) {\n        Common.extend(engineA, engineB);\n        \n        if (engineB.world) {\n            engineA.world = engineB.world;\n\n            Engine.clear(engineA);\n\n            var bodies = Composite.allBodies(engineA.world);\n\n            for (var i = 0; i < bodies.length; i++) {\n                var body = bodies[i];\n                Sleeping.set(body, false);\n                body.id = Common.nextId();\n            }\n        }\n    };\n\n    /**\n     * Clears the engine including the world, pairs and broadphase.\n     * @method clear\n     * @param {engine} engine\n     */\n    Engine.clear = function(engine) {\n        var world = engine.world,\n            bodies = Composite.allBodies(world);\n\n        Pairs.clear(engine.pairs);\n        Grid.clear(engine.grid);\n        Grid.update(engine.grid, bodies, engine, true);\n    };\n\n    /**\n     * Zeroes the `body.force` and `body.torque` force buffers.\n     * @method _bodiesClearForces\n     * @private\n     * @param {body[]} bodies\n     */\n    Engine._bodiesClearForces = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            // reset force buffers\n            body.force.x = 0;\n            body.force.y = 0;\n            body.torque = 0;\n        }\n    };\n\n    /**\n     * Applys a mass dependant force to all given bodies.\n     * @method _bodiesApplyGravity\n     * @private\n     * @param {body[]} bodies\n     * @param {vector} gravity\n     */\n    Engine._bodiesApplyGravity = function(bodies, gravity) {\n        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;\n\n        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {\n            return;\n        }\n        \n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            // apply gravity\n            body.force.y += body.mass * gravity.y * gravityScale;\n            body.force.x += body.mass * gravity.x * gravityScale;\n        }\n    };\n\n    /**\n     * Applys `Body.update` to all given `bodies`.\n     * @method _bodiesUpdate\n     * @private\n     * @param {body[]} bodies\n     * @param {number} deltaTime \n     * The amount of time elapsed between updates\n     * @param {number} timeScale\n     * @param {number} correction \n     * The Verlet correction factor (deltaTime / lastDeltaTime)\n     * @param {bounds} worldBounds\n     */\n    Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            Body.update(body, deltaTime, timeScale, correction);\n        }\n    };\n\n    /**\n     * A deprecated alias for `Runner.run`, use `Matter.Runner.run(engine)` instead and see `Matter.Runner` for more information.\n     * @deprecated use Matter.Runner.run(engine) instead\n     * @method run\n     * @param {engine} engine\n     */\n\n    /**\n    * Fired just before an update\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update and all collision events\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\n    *\n    * @event collisionStart\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\n    *\n    * @event collisionActive\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\n    *\n    * @event collisionEnd\n    * @param {} event An event object\n    * @param {} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` that specifies the number of position iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property positionIterations\n     * @type number\n     * @default 6\n     */\n\n    /**\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property velocityIterations\n     * @type number\n     * @default 4\n     */\n\n    /**\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     * The default value of `2` is usually very adequate.\n     *\n     * @property constraintIterations\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\n     *\n     * @property enableSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * An `Object` containing properties regarding the timing systems of the engine. \n     *\n     * @property timing\n     * @type object\n     */\n\n    /**\n     * A `Number` that specifies the global scaling factor of time for all bodies.\n     * A value of `0` freezes the simulation.\n     * A value of `0.1` gives a slow-motion effect.\n     * A value of `1.2` gives a speed-up effect.\n     *\n     * @property timing.timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \n     * It is incremented on every `Engine.update` by the given `delta` argument. \n     *\n     * @property timing.timestamp\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that represents the total execution time elapsed during the last `Engine.update` in milliseconds.\n     * It is updated by timing from the start of the last `Engine.update` call until it ends.\n     *\n     * This value will also include the total execution time of all event handlers directly or indirectly triggered by the engine update.\n     *\n     * @property timing.lastElapsed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that represents the `delta` value used in the last engine update.\n     *\n     * @property timing.lastDelta\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Matter.Grid` instance.\n     *\n     * @property grid\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * Replaced by and now alias for `engine.grid`.\n     *\n     * @deprecated use `engine.grid`\n     * @property broadphase\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * The root `Matter.Composite` instance that will contain all bodies, constraints and other composites to be simulated by this engine.\n     *\n     * @property world\n     * @type composite\n     * @default a Matter.Composite instance\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * The gravity to apply on all bodies in `engine.world`.\n     *\n     * @property gravity\n     * @type object\n     */\n\n    /**\n     * The gravity x component.\n     *\n     * @property gravity.x\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * The gravity y component.\n     *\n     * @property gravity.y\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * The gravity scale factor.\n     *\n     * @property gravity.scale\n     * @type object\n     * @default 0.001\n     */\n\n})();\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\n*\n* @class Resolver\n*/\n\nvar Resolver = {};\n\nmodule.exports = Resolver;\n\nvar Vertices = __webpack_require__(3);\nvar Vector = __webpack_require__(2);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\n\n(function() {\n\n    Resolver._restingThresh = 4;\n    Resolver._restingThreshTangent = 6;\n    Resolver._positionDampen = 0.9;\n    Resolver._positionWarming = 0.8;\n    Resolver._frictionNormalMultiplier = 5;\n\n    /**\n     * Prepare pairs for position solving.\n     * @method preSolvePosition\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolvePosition = function(pairs) {\n        var i,\n            pair,\n            activeCount;\n\n        // find total contacts on each body\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive)\n                continue;\n            \n            activeCount = pair.activeContacts.length;\n            pair.collision.parentA.totalContacts += activeCount;\n            pair.collision.parentB.totalContacts += activeCount;\n        }\n    };\n\n    /**\n     * Find a solution for pair positions.\n     * @method solvePosition\n     * @param {pair[]} pairs\n     * @param {number} timeScale\n     */\n    Resolver.solvePosition = function(pairs, timeScale) {\n        var i,\n            pair,\n            collision,\n            bodyA,\n            bodyB,\n            normal,\n            bodyBtoA,\n            contactShare,\n            positionImpulse,\n            contactCount = {},\n            tempA = Vector._temp[0],\n            tempB = Vector._temp[1],\n            tempC = Vector._temp[2],\n            tempD = Vector._temp[3];\n\n        // find impulses required to resolve penetration\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n\n            // get current separation between body edges involved in collision\n            bodyBtoA = Vector.sub(Vector.add(bodyB.positionImpulse, bodyB.position, tempA), \n                Vector.add(bodyA.positionImpulse, \n                    Vector.sub(bodyB.position, collision.penetration, tempB), tempC), tempD);\n\n            pair.separation = Vector.dot(normal, bodyBtoA);\n        }\n        \n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n            positionImpulse = (pair.separation - pair.slop) * timeScale;\n\n            if (bodyA.isStatic || bodyB.isStatic)\n                positionImpulse *= 2;\n            \n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                contactShare = Resolver._positionDampen / bodyA.totalContacts;\n                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;\n                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;\n            }\n\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                contactShare = Resolver._positionDampen / bodyB.totalContacts;\n                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;\n                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;\n            }\n        }\n    };\n\n    /**\n     * Apply position resolution.\n     * @method postSolvePosition\n     * @param {body[]} bodies\n     */\n    Resolver.postSolvePosition = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            // reset contact count\n            body.totalContacts = 0;\n\n            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {\n                // update body geometry\n                for (var j = 0; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n                    Vertices.translate(part.vertices, body.positionImpulse);\n                    Bounds.update(part.bounds, part.vertices, body.velocity);\n                    part.position.x += body.positionImpulse.x;\n                    part.position.y += body.positionImpulse.y;\n                }\n\n                // move the body without changing velocity\n                body.positionPrev.x += body.positionImpulse.x;\n                body.positionPrev.y += body.positionImpulse.y;\n\n                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {\n                    // reset cached impulse if the body has velocity along it\n                    body.positionImpulse.x = 0;\n                    body.positionImpulse.y = 0;\n                } else {\n                    // warm the next iteration\n                    body.positionImpulse.x *= Resolver._positionWarming;\n                    body.positionImpulse.y *= Resolver._positionWarming;\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepare pairs for velocity solving.\n     * @method preSolveVelocity\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolveVelocity = function(pairs) {\n        var i,\n            j,\n            pair,\n            contacts,\n            collision,\n            bodyA,\n            bodyB,\n            normal,\n            tangent,\n            contact,\n            contactVertex,\n            normalImpulse,\n            tangentImpulse,\n            offset,\n            impulse = Vector._temp[0],\n            tempA = Vector._temp[1];\n        \n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            contacts = pair.activeContacts;\n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n            tangent = collision.tangent;\n\n            // resolve each contact\n            for (j = 0; j < contacts.length; j++) {\n                contact = contacts[j];\n                contactVertex = contact.vertex;\n                normalImpulse = contact.normalImpulse;\n                tangentImpulse = contact.tangentImpulse;\n\n                if (normalImpulse !== 0 || tangentImpulse !== 0) {\n                    // total impulse from contact\n                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\n                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\n                    \n                    // apply impulse from contact\n                    if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                        offset = Vector.sub(contactVertex, bodyA.position, tempA);\n                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;\n                    }\n\n                    if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                        offset = Vector.sub(contactVertex, bodyB.position, tempA);\n                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Find a solution for pair velocities.\n     * @method solveVelocity\n     * @param {pair[]} pairs\n     * @param {number} timeScale\n     */\n    Resolver.solveVelocity = function(pairs, timeScale) {\n        var timeScaleSquared = timeScale * timeScale,\n            impulse = Vector._temp[0],\n            tempA = Vector._temp[1],\n            tempB = Vector._temp[2],\n            tempC = Vector._temp[3],\n            tempD = Vector._temp[4],\n            tempE = Vector._temp[5];\n        \n        for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            var collision = pair.collision,\n                bodyA = collision.parentA,\n                bodyB = collision.parentB,\n                normal = collision.normal,\n                tangent = collision.tangent,\n                contacts = pair.activeContacts,\n                contactShare = 1 / contacts.length;\n\n            // update body velocities\n            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;\n            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;\n            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;\n            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\n\n            // resolve each contact\n            for (var j = 0; j < contacts.length; j++) {\n                var contact = contacts[j],\n                    contactVertex = contact.vertex,\n                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),\n                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),\n                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),\n                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), \n                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),\n                    normalVelocity = Vector.dot(normal, relativeVelocity);\n\n                var tangentVelocity = Vector.dot(tangent, relativeVelocity),\n                    tangentSpeed = Math.abs(tangentVelocity),\n                    tangentVelocityDirection = Common.sign(tangentVelocity);\n\n                // raw impulses\n                var normalImpulse = (1 + pair.restitution) * normalVelocity,\n                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;\n\n                // coulomb friction\n                var tangentImpulse = tangentVelocity,\n                    maxFriction = Infinity;\n\n                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {\n                    maxFriction = tangentSpeed;\n                    tangentImpulse = Common.clamp(\n                        pair.friction * tangentVelocityDirection * timeScaleSquared,\n                        -maxFriction, maxFriction\n                    );\n                }\n\n                // modify impulses accounting for mass, inertia and offset\n                var oAcN = Vector.cross(offsetA, normal),\n                    oBcN = Vector.cross(offsetB, normal),\n                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);\n\n                normalImpulse *= share;\n                tangentImpulse *= share;\n\n                // handle high velocity and resting collisions separately\n                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {\n                    // high normal velocity so clear cached contact normal impulse\n                    contact.normalImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n                    // impulse constraint tends to 0\n                    var contactNormalImpulse = contact.normalImpulse;\n                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);\n                    normalImpulse = contact.normalImpulse - contactNormalImpulse;\n                }\n\n                // handle high velocity and resting collisions separately\n                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {\n                    // high tangent velocity so clear cached contact tangent impulse\n                    contact.tangentImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n                    // tangent impulse tends to -tangentSpeed or +tangentSpeed\n                    var contactTangentImpulse = contact.tangentImpulse;\n                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);\n                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n                }\n\n                // total impulse from contact\n                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);\n                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);\n                \n                // apply impulse from contact\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;\n                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;\n                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;\n                }\n\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;\n                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;\n                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;\n                }\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\n*\n* @class Pairs\n*/\n\nvar Pairs = {};\n\nmodule.exports = Pairs;\n\nvar Pair = __webpack_require__(9);\nvar Common = __webpack_require__(0);\n\n(function() {\n    \n    Pairs._pairMaxIdleLife = 1000;\n\n    /**\n     * Creates a new pairs structure.\n     * @method create\n     * @param {object} options\n     * @return {pairs} A new pairs structure\n     */\n    Pairs.create = function(options) {\n        return Common.extend({ \n            table: {},\n            list: [],\n            collisionStart: [],\n            collisionActive: [],\n            collisionEnd: []\n        }, options);\n    };\n\n    /**\n     * Updates pairs given a list of collisions.\n     * @method update\n     * @param {object} pairs\n     * @param {collision[]} collisions\n     * @param {number} timestamp\n     */\n    Pairs.update = function(pairs, collisions, timestamp) {\n        var pairsList = pairs.list,\n            pairsTable = pairs.table,\n            collisionStart = pairs.collisionStart,\n            collisionEnd = pairs.collisionEnd,\n            collisionActive = pairs.collisionActive,\n            collision,\n            pairId,\n            pair,\n            i;\n\n        // clear collision state arrays, but maintain old reference\n        collisionStart.length = 0;\n        collisionEnd.length = 0;\n        collisionActive.length = 0;\n\n        for (i = 0; i < pairsList.length; i++) {\n            pairsList[i].confirmedActive = false;\n        }\n\n        for (i = 0; i < collisions.length; i++) {\n            collision = collisions[i];\n\n            if (collision.collided) {\n                pairId = Pair.id(collision.bodyA, collision.bodyB);\n\n                pair = pairsTable[pairId];\n                \n                if (pair) {\n                    // pair already exists (but may or may not be active)\n                    if (pair.isActive) {\n                        // pair exists and is active\n                        collisionActive.push(pair);\n                    } else {\n                        // pair exists but was inactive, so a collision has just started again\n                        collisionStart.push(pair);\n                    }\n\n                    // update the pair\n                    Pair.update(pair, collision, timestamp);\n                    pair.confirmedActive = true;\n                } else {\n                    // pair did not exist, create a new pair\n                    pair = Pair.create(collision, timestamp);\n                    pairsTable[pairId] = pair;\n\n                    // push the new pair\n                    collisionStart.push(pair);\n                    pairsList.push(pair);\n                }\n            }\n        }\n\n        // deactivate previously active pairs that are now inactive\n        for (i = 0; i < pairsList.length; i++) {\n            pair = pairsList[i];\n            if (pair.isActive && !pair.confirmedActive) {\n                Pair.setActive(pair, false, timestamp);\n                collisionEnd.push(pair);\n            }\n        }\n    };\n    \n    /**\n     * Finds and removes pairs that have been inactive for a set amount of time.\n     * @method removeOld\n     * @param {object} pairs\n     * @param {number} timestamp\n     */\n    Pairs.removeOld = function(pairs, timestamp) {\n        var pairsList = pairs.list,\n            pairsTable = pairs.table,\n            indexesToRemove = [],\n            pair,\n            collision,\n            pairIndex,\n            i;\n\n        for (i = 0; i < pairsList.length; i++) {\n            pair = pairsList[i];\n            collision = pair.collision;\n            \n            // never remove sleeping pairs\n            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {\n                pair.timeUpdated = timestamp;\n                continue;\n            }\n\n            // if pair is inactive for too long, mark it to be removed\n            if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {\n                indexesToRemove.push(i);\n            }\n        }\n\n        // remove marked pairs\n        for (i = 0; i < indexesToRemove.length; i++) {\n            pairIndex = indexesToRemove[i] - i;\n            pair = pairsList[pairIndex];\n            delete pairsTable[pair.id];\n            pairsList.splice(pairIndex, 1);\n        }\n    };\n\n    /**\n     * Clears the given pairs structure.\n     * @method clear\n     * @param {pairs} pairs\n     * @return {pairs} pairs\n     */\n    Pairs.clear = function(pairs) {\n        pairs.table = {};\n        pairs.list.length = 0;\n        pairs.collisionStart.length = 0;\n        pairs.collisionActive.length = 0;\n        pairs.collisionEnd.length = 0;\n        return pairs;\n    };\n\n})();\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\n*\n* @class Grid\n*/\n\nvar Grid = {};\n\nmodule.exports = Grid;\n\nvar Pair = __webpack_require__(9);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Creates a new grid.\n     * @method create\n     * @param {} options\n     * @return {grid} A new grid\n     */\n    Grid.create = function(options) {\n        var defaults = {\n            buckets: {},\n            pairs: {},\n            pairsList: [],\n            bucketWidth: 48,\n            bucketHeight: 48\n        };\n\n        return Common.extend(defaults, options);\n    };\n\n    /**\n     * The width of a single grid bucket.\n     *\n     * @property bucketWidth\n     * @type number\n     * @default 48\n     */\n\n    /**\n     * The height of a single grid bucket.\n     *\n     * @property bucketHeight\n     * @type number\n     * @default 48\n     */\n\n    /**\n     * Updates the grid.\n     * @method update\n     * @param {grid} grid\n     * @param {body[]} bodies\n     * @param {engine} engine\n     * @param {boolean} forceUpdate\n     */\n    Grid.update = function(grid, bodies, engine, forceUpdate) {\n        var i, col, row,\n            world = engine.world,\n            buckets = grid.buckets,\n            bucket,\n            bucketId,\n            gridChanged = false;\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isSleeping && !forceUpdate)\n                continue;\n\n            // temporary back compatibility bounds check\n            if (world.bounds && (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x\n                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y))\n                continue;\n\n            var newRegion = Grid._getRegion(grid, body);\n\n            // if the body has changed grid region\n            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n\n                if (!body.region || forceUpdate)\n                    body.region = newRegion;\n\n                var union = Grid._regionUnion(newRegion, body.region);\n\n                // update grid buckets affected by region change\n                // iterate over the union of both regions\n                for (col = union.startCol; col <= union.endCol; col++) {\n                    for (row = union.startRow; row <= union.endRow; row++) {\n                        bucketId = Grid._getBucketId(col, row);\n                        bucket = buckets[bucketId];\n\n                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol\n                                                && row >= newRegion.startRow && row <= newRegion.endRow);\n\n                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol\n                                                && row >= body.region.startRow && row <= body.region.endRow);\n\n                        // remove from old region buckets\n                        if (!isInsideNewRegion && isInsideOldRegion) {\n                            if (isInsideOldRegion) {\n                                if (bucket)\n                                    Grid._bucketRemoveBody(grid, bucket, body);\n                            }\n                        }\n\n                        // add to new region buckets\n                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {\n                            if (!bucket)\n                                bucket = Grid._createBucket(buckets, bucketId);\n                            Grid._bucketAddBody(grid, bucket, body);\n                        }\n                    }\n                }\n\n                // set the new region\n                body.region = newRegion;\n\n                // flag changes so we can update pairs\n                gridChanged = true;\n            }\n        }\n\n        // update pairs list only if pairs changed (i.e. a body changed region)\n        if (gridChanged)\n            grid.pairsList = Grid._createActivePairsList(grid);\n    };\n\n    /**\n     * Clears the grid.\n     * @method clear\n     * @param {grid} grid\n     */\n    Grid.clear = function(grid) {\n        grid.buckets = {};\n        grid.pairs = {};\n        grid.pairsList = [];\n    };\n\n    /**\n     * Finds the union of two regions.\n     * @method _regionUnion\n     * @private\n     * @param {} regionA\n     * @param {} regionB\n     * @return {} region\n     */\n    Grid._regionUnion = function(regionA, regionB) {\n        var startCol = Math.min(regionA.startCol, regionB.startCol),\n            endCol = Math.max(regionA.endCol, regionB.endCol),\n            startRow = Math.min(regionA.startRow, regionB.startRow),\n            endRow = Math.max(regionA.endRow, regionB.endRow);\n\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Gets the region a given body falls in for a given grid.\n     * @method _getRegion\n     * @private\n     * @param {} grid\n     * @param {} body\n     * @return {} region\n     */\n    Grid._getRegion = function(grid, body) {\n        var bounds = body.bounds,\n            startCol = Math.floor(bounds.min.x / grid.bucketWidth),\n            endCol = Math.floor(bounds.max.x / grid.bucketWidth),\n            startRow = Math.floor(bounds.min.y / grid.bucketHeight),\n            endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Creates a region.\n     * @method _createRegion\n     * @private\n     * @param {} startCol\n     * @param {} endCol\n     * @param {} startRow\n     * @param {} endRow\n     * @return {} region\n     */\n    Grid._createRegion = function(startCol, endCol, startRow, endRow) {\n        return { \n            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\n            startCol: startCol, \n            endCol: endCol, \n            startRow: startRow, \n            endRow: endRow \n        };\n    };\n\n    /**\n     * Gets the bucket id at the given position.\n     * @method _getBucketId\n     * @private\n     * @param {} column\n     * @param {} row\n     * @return {string} bucket id\n     */\n    Grid._getBucketId = function(column, row) {\n        return 'C' + column + 'R' + row;\n    };\n\n    /**\n     * Creates a bucket.\n     * @method _createBucket\n     * @private\n     * @param {} buckets\n     * @param {} bucketId\n     * @return {} bucket\n     */\n    Grid._createBucket = function(buckets, bucketId) {\n        var bucket = buckets[bucketId] = [];\n        return bucket;\n    };\n\n    /**\n     * Adds a body to a bucket.\n     * @method _bucketAddBody\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    Grid._bucketAddBody = function(grid, bucket, body) {\n        // add new pairs\n        for (var i = 0; i < bucket.length; i++) {\n            var bodyB = bucket[i];\n\n            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))\n                continue;\n\n            // keep track of the number of buckets the pair exists in\n            // important for Grid.update to work\n            var pairId = Pair.id(body, bodyB),\n                pair = grid.pairs[pairId];\n\n            if (pair) {\n                pair[2] += 1;\n            } else {\n                grid.pairs[pairId] = [body, bodyB, 1];\n            }\n        }\n\n        // add to bodies (after pairs, otherwise pairs with self)\n        bucket.push(body);\n    };\n\n    /**\n     * Removes a body from a bucket.\n     * @method _bucketRemoveBody\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    Grid._bucketRemoveBody = function(grid, bucket, body) {\n        // remove from bucket\n        bucket.splice(Common.indexOf(bucket, body), 1);\n\n        // update pair counts\n        for (var i = 0; i < bucket.length; i++) {\n            // keep track of the number of buckets the pair exists in\n            // important for _createActivePairsList to work\n            var bodyB = bucket[i],\n                pairId = Pair.id(body, bodyB),\n                pair = grid.pairs[pairId];\n\n            if (pair)\n                pair[2] -= 1;\n        }\n    };\n\n    /**\n     * Generates a list of the active pairs in the grid.\n     * @method _createActivePairsList\n     * @private\n     * @param {} grid\n     * @return [] pairs\n     */\n    Grid._createActivePairsList = function(grid) {\n        var pairKeys,\n            pair,\n            pairs = [];\n\n        // grid.pairs is used as a hashmap\n        pairKeys = Common.keys(grid.pairs);\n\n        // iterate over grid.pairs\n        for (var k = 0; k < pairKeys.length; k++) {\n            pair = grid.pairs[pairKeys[k]];\n\n            // if pair exists in at least one bucket\n            // it is a pair that needs further collision testing so push it\n            if (pair[2] > 0) {\n                pairs.push(pair);\n            } else {\n                delete grid.pairs[pairKeys[k]];\n            }\n        }\n\n        return pairs;\n    };\n    \n})();\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Matter = module.exports = __webpack_require__(23);\r\n\r\nMatter.Axes = __webpack_require__(10);\r\nMatter.Bodies = __webpack_require__(11);\r\nMatter.Body = __webpack_require__(6);\r\nMatter.Bounds = __webpack_require__(1);\r\nMatter.Common = __webpack_require__(0);\r\nMatter.Composite = __webpack_require__(5);\r\nMatter.Composites = __webpack_require__(24);\r\nMatter.Constraint = __webpack_require__(8);\r\nMatter.Contact = __webpack_require__(17);\r\nMatter.Detector = __webpack_require__(13);\r\nMatter.Engine = __webpack_require__(18);\r\nMatter.Events = __webpack_require__(4);\r\nMatter.Grid = __webpack_require__(21);\r\nMatter.Mouse = __webpack_require__(12);\r\nMatter.MouseConstraint = __webpack_require__(25);\r\nMatter.Pair = __webpack_require__(9);\r\nMatter.Pairs = __webpack_require__(20);\r\nMatter.Plugin = __webpack_require__(15);\r\nMatter.Query = __webpack_require__(26);\r\nMatter.Render = __webpack_require__(16);\r\nMatter.Resolver = __webpack_require__(19);\r\nMatter.Runner = __webpack_require__(27);\r\nMatter.SAT = __webpack_require__(14);\r\nMatter.Sleeping = __webpack_require__(7);\r\nMatter.Svg = __webpack_require__(28);\r\nMatter.Vector = __webpack_require__(2);\r\nMatter.Vertices = __webpack_require__(3);\r\nMatter.World = __webpack_require__(29);\r\n\r\n// temporary back compatibility\r\nMatter.Engine.run = Matter.Runner.run;\r\nMatter.Common.deprecated(Matter.Engine, 'run', 'Engine.run  use Matter.Runner.run(engine) instead');\r\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\r\n* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n*\r\n* @class Matter\r\n*/\r\n\r\nvar Matter = {};\r\n\r\nmodule.exports = Matter;\r\n\r\nvar Plugin = __webpack_require__(15);\r\nvar Common = __webpack_require__(0);\r\n\r\n(function() {\r\n\r\n    /**\r\n     * The library name.\r\n     * @property name\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.name = 'matter-js';\r\n\r\n    /**\r\n     * The library version.\r\n     * @property version\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.version =  true ? \"0.17.1\" : undefined;\r\n\r\n    /**\r\n     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n     * @property uses\r\n     * @type {Array}\r\n     */\r\n    Matter.uses = [];\r\n\r\n    /**\r\n     * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n     * @property used\r\n     * @readOnly\r\n     * @type {Array}\r\n     */\r\n    Matter.used = [];\r\n\r\n    /**\r\n     * Installs the given plugins on the `Matter` namespace.\r\n     * This is a short-hand for `Plugin.use`, see it for more information.\r\n     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n     * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n     */\r\n    Matter.use = function() {\r\n        Plugin.use(Matter, Array.prototype.slice.call(arguments));\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method before\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.before = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathBefore(Matter, path, func);\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method after\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.after = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathAfter(Matter, path, func);\r\n    };\r\n\r\n})();\r\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Composites` module contains factory methods for creating composite bodies\n* with commonly used configurations (such as stacks and chains).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composites\n*/\n\nvar Composites = {};\n\nmodule.exports = Composites;\n\nvar Composite = __webpack_require__(5);\nvar Constraint = __webpack_require__(8);\nvar Common = __webpack_require__(0);\nvar Body = __webpack_require__(6);\nvar Bodies = __webpack_require__(11);\nvar deprecated = Common.deprecated;\n\n(function() {\n\n    /**\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method stack\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n        var stack = Composite.create({ label: 'Stack' }),\n            x = xx,\n            y = yy,\n            lastBody,\n            i = 0;\n\n        for (var row = 0; row < rows; row++) {\n            var maxHeight = 0;\n            \n            for (var column = 0; column < columns; column++) {\n                var body = callback(x, y, column, row, lastBody, i);\n                    \n                if (body) {\n                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,\n                        bodyWidth = body.bounds.max.x - body.bounds.min.x; \n\n                    if (bodyHeight > maxHeight)\n                        maxHeight = bodyHeight;\n                    \n                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });\n\n                    x = body.bounds.max.x + columnGap;\n\n                    Composite.addBody(stack, body);\n                    \n                    lastBody = body;\n                    i += 1;\n                } else {\n                    x += columnGap;\n                }\n            }\n            \n            y += maxHeight + rowGap;\n            x = xx;\n        }\n\n        return stack;\n    };\n    \n    /**\n     * Chains all bodies in the given composite together using constraints.\n     * @method chain\n     * @param {composite} composite\n     * @param {number} xOffsetA\n     * @param {number} yOffsetA\n     * @param {number} xOffsetB\n     * @param {number} yOffsetB\n     * @param {object} options\n     * @return {composite} A new composite containing objects chained together with constraints\n     */\n    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n        var bodies = composite.bodies;\n        \n        for (var i = 1; i < bodies.length; i++) {\n            var bodyA = bodies[i - 1],\n                bodyB = bodies[i],\n                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\n                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, \n                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\n                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n        \n            var defaults = {\n                bodyA: bodyA,\n                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },\n                bodyB: bodyB,\n                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }\n            };\n            \n            var constraint = Common.extend(defaults, options);\n        \n            Composite.addConstraint(composite, Constraint.create(constraint));\n        }\n\n        composite.label += ' Chain';\n        \n        return composite;\n    };\n\n    /**\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\n     * @method mesh\n     * @param {composite} composite\n     * @param {number} columns\n     * @param {number} rows\n     * @param {boolean} crossBrace\n     * @param {object} options\n     * @return {composite} The composite containing objects meshed together with constraints\n     */\n    Composites.mesh = function(composite, columns, rows, crossBrace, options) {\n        var bodies = composite.bodies,\n            row,\n            col,\n            bodyA,\n            bodyB,\n            bodyC;\n        \n        for (row = 0; row < rows; row++) {\n            for (col = 1; col < columns; col++) {\n                bodyA = bodies[(col - 1) + (row * columns)];\n                bodyB = bodies[col + (row * columns)];\n                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n            }\n\n            if (row > 0) {\n                for (col = 0; col < columns; col++) {\n                    bodyA = bodies[col + ((row - 1) * columns)];\n                    bodyB = bodies[col + (row * columns)];\n                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n\n                    if (crossBrace && col > 0) {\n                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n\n                    if (crossBrace && col < columns - 1) {\n                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n                }\n            }\n        }\n\n        composite.label += ' Mesh';\n        \n        return composite;\n    };\n    \n    /**\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method pyramid\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {\n            var actualRows = Math.min(rows, Math.ceil(columns / 2)),\n                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n            \n            if (row > actualRows)\n                return;\n            \n            // reverse row order\n            row = actualRows - row;\n            \n            var start = row,\n                end = columns - 1 - row;\n\n            if (column < start || column > end)\n                return;\n            \n            // retroactively fix the first body's position, since width was unknown\n            if (i === 1) {\n                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });\n            }\n\n            var xOffset = lastBody ? column * lastBodyWidth : 0;\n            \n            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\n        });\n    };\n\n    /**\n     * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to newtonsCradle example\n     * @method newtonsCradle\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} number\n     * @param {number} size\n     * @param {number} length\n     * @return {composite} A new composite newtonsCradle body\n     */\n    Composites.newtonsCradle = function(xx, yy, number, size, length) {\n        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });\n\n        for (var i = 0; i < number; i++) {\n            var separation = 1.9,\n                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, \n                    { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),\n                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });\n\n            Composite.addBody(newtonsCradle, circle);\n            Composite.addConstraint(newtonsCradle, constraint);\n        }\n\n        return newtonsCradle;\n    };\n\n    deprecated(Composites, 'newtonsCradle', 'Composites.newtonsCradle  moved to newtonsCradle example');\n    \n    /**\n     * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to car example\n     * @method car\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} width\n     * @param {number} height\n     * @param {number} wheelSize\n     * @return {composite} A new composite car body\n     */\n    Composites.car = function(xx, yy, width, height, wheelSize) {\n        var group = Body.nextGroup(true),\n            wheelBase = 20,\n            wheelAOffset = -width * 0.5 + wheelBase,\n            wheelBOffset = width * 0.5 - wheelBase,\n            wheelYOffset = 0;\n    \n        var car = Composite.create({ label: 'Car' }),\n            body = Bodies.rectangle(xx, yy, width, height, { \n                collisionFilter: {\n                    group: group\n                },\n                chamfer: {\n                    radius: height * 0.5\n                },\n                density: 0.0002\n            });\n    \n        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { \n            collisionFilter: {\n                group: group\n            },\n            friction: 0.8\n        });\n                    \n        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { \n            collisionFilter: {\n                group: group\n            },\n            friction: 0.8\n        });\n                    \n        var axelA = Constraint.create({\n            bodyB: body,\n            pointB: { x: wheelAOffset, y: wheelYOffset },\n            bodyA: wheelA,\n            stiffness: 1,\n            length: 0\n        });\n                        \n        var axelB = Constraint.create({\n            bodyB: body,\n            pointB: { x: wheelBOffset, y: wheelYOffset },\n            bodyA: wheelB,\n            stiffness: 1,\n            length: 0\n        });\n        \n        Composite.addBody(car, body);\n        Composite.addBody(car, wheelA);\n        Composite.addBody(car, wheelB);\n        Composite.addConstraint(car, axelA);\n        Composite.addConstraint(car, axelB);\n\n        return car;\n    };\n\n    deprecated(Composites, 'car', 'Composites.car  moved to car example');\n\n    /**\n     * This has now moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)\n     * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js), follow those instead as this function is deprecated here.\n     * @deprecated moved to softBody and cloth examples\n     * @method softBody\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {boolean} crossBrace\n     * @param {number} particleRadius\n     * @param {} particleOptions\n     * @param {} constraintOptions\n     * @return {composite} A new composite softBody\n     */\n    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);\n        constraintOptions = Common.extend({ stiffness: 0.2, render: { type: 'line', anchors: false } }, constraintOptions);\n\n        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {\n            return Bodies.circle(x, y, particleRadius, particleOptions);\n        });\n\n        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n\n        softBody.label = 'Soft Body';\n\n        return softBody;\n    };\n\n    deprecated(Composites, 'softBody', 'Composites.softBody  moved to softBody and cloth examples');\n})();\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.\n* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class MouseConstraint\n*/\n\nvar MouseConstraint = {};\n\nmodule.exports = MouseConstraint;\n\nvar Vertices = __webpack_require__(3);\nvar Sleeping = __webpack_require__(7);\nvar Mouse = __webpack_require__(12);\nvar Events = __webpack_require__(4);\nvar Detector = __webpack_require__(13);\nvar Constraint = __webpack_require__(8);\nvar Composite = __webpack_require__(5);\nvar Common = __webpack_require__(0);\nvar Bounds = __webpack_require__(1);\n\n(function() {\n\n    /**\n     * Creates a new mouse constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {engine} engine\n     * @param {} options\n     * @return {MouseConstraint} A new MouseConstraint\n     */\n    MouseConstraint.create = function(engine, options) {\n        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);\n\n        if (!mouse) {\n            if (engine && engine.render && engine.render.canvas) {\n                mouse = Mouse.create(engine.render.canvas);\n            } else if (options && options.element) {\n                mouse = Mouse.create(options.element);\n            } else {\n                mouse = Mouse.create();\n                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');\n            }\n        }\n\n        var constraint = Constraint.create({ \n            label: 'Mouse Constraint',\n            pointA: mouse.position,\n            pointB: { x: 0, y: 0 },\n            length: 0.01, \n            stiffness: 0.1,\n            angularStiffness: 1,\n            render: {\n                strokeStyle: '#90EE90',\n                lineWidth: 3\n            }\n        });\n\n        var defaults = {\n            type: 'mouseConstraint',\n            mouse: mouse,\n            element: null,\n            body: null,\n            constraint: constraint,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            }\n        };\n\n        var mouseConstraint = Common.extend(defaults, options);\n\n        Events.on(engine, 'beforeUpdate', function() {\n            var allBodies = Composite.allBodies(engine.world);\n            MouseConstraint.update(mouseConstraint, allBodies);\n            MouseConstraint._triggerEvents(mouseConstraint);\n        });\n\n        return mouseConstraint;\n    };\n\n    /**\n     * Updates the given mouse constraint.\n     * @private\n     * @method update\n     * @param {MouseConstraint} mouseConstraint\n     * @param {body[]} bodies\n     */\n    MouseConstraint.update = function(mouseConstraint, bodies) {\n        var mouse = mouseConstraint.mouse,\n            constraint = mouseConstraint.constraint,\n            body = mouseConstraint.body;\n\n        if (mouse.button === 0) {\n            if (!constraint.bodyB) {\n                for (var i = 0; i < bodies.length; i++) {\n                    body = bodies[i];\n                    if (Bounds.contains(body.bounds, mouse.position) \n                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {\n                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {\n                            var part = body.parts[j];\n                            if (Vertices.contains(part.vertices, mouse.position)) {\n                                constraint.pointA = mouse.position;\n                                constraint.bodyB = mouseConstraint.body = body;\n                                constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };\n                                constraint.angleB = body.angle;\n\n                                Sleeping.set(body, false);\n                                Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });\n\n                                break;\n                            }\n                        }\n                    }\n                }\n            } else {\n                Sleeping.set(constraint.bodyB, false);\n                constraint.pointA = mouse.position;\n            }\n        } else {\n            constraint.bodyB = mouseConstraint.body = null;\n            constraint.pointB = null;\n\n            if (body)\n                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });\n        }\n    };\n\n    /**\n     * Triggers mouse constraint events.\n     * @method _triggerEvents\n     * @private\n     * @param {mouse} mouseConstraint\n     */\n    MouseConstraint._triggerEvents = function(mouseConstraint) {\n        var mouse = mouseConstraint.mouse,\n            mouseEvents = mouse.sourceEvents;\n\n        if (mouseEvents.mousemove)\n            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });\n\n        if (mouseEvents.mousedown)\n            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });\n\n        if (mouseEvents.mouseup)\n            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });\n\n        // reset the mouse state ready for the next step\n        Mouse.clearSourceEvents(mouse);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when the mouse has moved (or a touch moves) during the last step\n    *\n    * @event mousemove\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is down (or a touch has started) during the last step\n    *\n    * @event mousedown\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is up (or a touch has ended) during the last step\n    *\n    * @event mouseup\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user starts dragging a body\n    *\n    * @event startdrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user ends dragging a body\n    *\n    * @event enddrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body that has stopped being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */\n\n    /**\n     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.\n     *\n     * @property mouse\n     * @type mouse\n     * @default mouse\n     */\n\n    /**\n     * The `Body` that is currently being moved by the user, or `null` if no body.\n     *\n     * @property body\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The `Constraint` object that is used to move the body during interaction.\n     *\n     * @property constraint\n     * @type constraint\n     */\n\n    /**\n     * An `Object` that specifies the collision filter properties.\n     * The collision filter allows the user to define which types of body this mouse constraint can interact with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n})();\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Query` module contains methods for performing collision queries.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Query\n*/\n\nvar Query = {};\n\nmodule.exports = Query;\n\nvar Vector = __webpack_require__(2);\nvar SAT = __webpack_require__(14);\nvar Bounds = __webpack_require__(1);\nvar Bodies = __webpack_require__(11);\nvar Vertices = __webpack_require__(3);\n\n(function() {\n\n    /**\n     * Returns a list of collisions between `body` and `bodies`.\n     * @method collides\n     * @param {body} body\n     * @param {body[]} bodies\n     * @return {object[]} Collisions\n     */\n    Query.collides = function(body, bodies) {\n        var collisions = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var bodyA = bodies[i];\n            \n            if (Bounds.overlaps(bodyA.bounds, body.bounds)) {\n                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {\n                    var part = bodyA.parts[j];\n\n                    if (Bounds.overlaps(part.bounds, body.bounds)) {\n                        var collision = SAT.collides(part, body);\n\n                        if (collision.collided) {\n                            collisions.push(collision);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\n     * @method ray\n     * @param {body[]} bodies\n     * @param {vector} startPoint\n     * @param {vector} endPoint\n     * @param {number} [rayWidth]\n     * @return {object[]} Collisions\n     */\n    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\n        rayWidth = rayWidth || 1e-100;\n\n        var rayAngle = Vector.angle(startPoint, endPoint),\n            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\n            rayX = (endPoint.x + startPoint.x) * 0.5,\n            rayY = (endPoint.y + startPoint.y) * 0.5,\n            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),\n            collisions = Query.collides(ray, bodies);\n\n        for (var i = 0; i < collisions.length; i += 1) {\n            var collision = collisions[i];\n            collision.body = collision.bodyB = collision.bodyA;            \n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\n     * @method region\n     * @param {body[]} bodies\n     * @param {bounds} bounds\n     * @param {bool} [outside=false]\n     * @return {body[]} The bodies matching the query\n     */\n    Query.region = function(bodies, bounds, outside) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                overlaps = Bounds.overlaps(body.bounds, bounds);\n            if ((overlaps && !outside) || (!overlaps && outside))\n                result.push(body);\n        }\n\n        return result;\n    };\n\n    /**\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\n     * @method point\n     * @param {body[]} bodies\n     * @param {vector} point\n     * @return {body[]} The bodies matching the query\n     */\n    Query.point = function(bodies, point) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n            \n            if (Bounds.contains(body.bounds, point)) {\n                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n\n                    if (Bounds.contains(part.bounds, point)\n                        && Vertices.contains(part.vertices, point)) {\n                        result.push(body);\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n})();\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Runner` module is an optional utility which provides a game loop, \n* that handles continuously updating a `Matter.Engine` for you within a browser.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.\n* Instead just call `Engine.update(engine, delta)` in your own loop.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Runner\n*/\n\nvar Runner = {};\n\nmodule.exports = Runner;\n\nvar Events = __webpack_require__(4);\nvar Engine = __webpack_require__(18);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    var _requestAnimationFrame,\n        _cancelAnimationFrame;\n\n    if (typeof window !== 'undefined') {\n        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\n                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;\n   \n        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame \n                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n    }\n\n    if (!_requestAnimationFrame) {\n        var _frameTimeout;\n\n        _requestAnimationFrame = function(callback){ \n            _frameTimeout = setTimeout(function() { \n                callback(Common.now()); \n            }, 1000 / 60);\n        };\n\n        _cancelAnimationFrame = function() {\n            clearTimeout(_frameTimeout);\n        };\n    }\n\n    /**\n     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * @method create\n     * @param {} options\n     */\n    Runner.create = function(options) {\n        var defaults = {\n            fps: 60,\n            correction: 1,\n            deltaSampleSize: 60,\n            counterTimestamp: 0,\n            frameCounter: 0,\n            deltaHistory: [],\n            timePrev: null,\n            timeScalePrev: 1,\n            frameRequestId: null,\n            isFixed: false,\n            enabled: true\n        };\n\n        var runner = Common.extend(defaults, options);\n\n        runner.delta = runner.delta || 1000 / runner.fps;\n        runner.deltaMin = runner.deltaMin || 1000 / runner.fps;\n        runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);\n        runner.fps = 1000 / runner.delta;\n\n        return runner;\n    };\n\n    /**\n     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.\n     * @method run\n     * @param {engine} engine\n     */\n    Runner.run = function(runner, engine) {\n        // create runner if engine is first argument\n        if (typeof runner.positionIterations !== 'undefined') {\n            engine = runner;\n            runner = Runner.create();\n        }\n\n        (function render(time){\n            runner.frameRequestId = _requestAnimationFrame(render);\n\n            if (time && runner.enabled) {\n                Runner.tick(runner, engine, time);\n            }\n        })();\n\n        return runner;\n    };\n\n    /**\n     * A game loop utility that updates the engine and renderer by one step (a 'tick').\n     * Features delta smoothing, time correction and fixed or dynamic timing.\n     * Consider just `Engine.update(engine, delta)` if you're using your own loop.\n     * @method tick\n     * @param {runner} runner\n     * @param {engine} engine\n     * @param {number} time\n     */\n    Runner.tick = function(runner, engine, time) {\n        var timing = engine.timing,\n            correction = 1,\n            delta;\n\n        // create an event object\n        var event = {\n            timestamp: timing.timestamp\n        };\n\n        Events.trigger(runner, 'beforeTick', event);\n\n        if (runner.isFixed) {\n            // fixed timestep\n            delta = runner.delta;\n        } else {\n            // dynamic timestep based on wall clock between calls\n            delta = (time - runner.timePrev) || runner.delta;\n            runner.timePrev = time;\n\n            // optimistically filter delta over a few frames, to improve stability\n            runner.deltaHistory.push(delta);\n            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);\n            delta = Math.min.apply(null, runner.deltaHistory);\n            \n            // limit delta\n            delta = delta < runner.deltaMin ? runner.deltaMin : delta;\n            delta = delta > runner.deltaMax ? runner.deltaMax : delta;\n\n            // correction for delta\n            correction = delta / runner.delta;\n\n            // update engine timing object\n            runner.delta = delta;\n        }\n\n        // time correction for time scaling\n        if (runner.timeScalePrev !== 0)\n            correction *= timing.timeScale / runner.timeScalePrev;\n\n        if (timing.timeScale === 0)\n            correction = 0;\n\n        runner.timeScalePrev = timing.timeScale;\n        runner.correction = correction;\n\n        // fps counter\n        runner.frameCounter += 1;\n        if (time - runner.counterTimestamp >= 1000) {\n            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);\n            runner.counterTimestamp = time;\n            runner.frameCounter = 0;\n        }\n\n        Events.trigger(runner, 'tick', event);\n\n        // update\n        Events.trigger(runner, 'beforeUpdate', event);\n        Engine.update(engine, delta, correction);\n        Events.trigger(runner, 'afterUpdate', event);\n\n        Events.trigger(runner, 'afterTick', event);\n    };\n\n    /**\n     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.\n     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.\n     * @method stop\n     * @param {runner} runner\n     */\n    Runner.stop = function(runner) {\n        _cancelAnimationFrame(runner.frameRequestId);\n    };\n\n    /**\n     * Alias for `Runner.run`.\n     * @method start\n     * @param {runner} runner\n     * @param {engine} engine\n     */\n    Runner.start = function(runner, engine) {\n        Runner.run(runner, engine);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired at the start of a tick, before any updates to the engine or timing\n    *\n    * @event beforeTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine timing updated, but just before update\n    *\n    * @event tick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired at the end of a tick, after engine update and after rendering\n    *\n    * @event afterTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired before update\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after update\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A flag that specifies whether the runner is running or not.\n     *\n     * @property enabled\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).\n     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).\n     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).\n     *\n     * @property isFixed\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A `Number` that specifies the time step between updates in milliseconds.\n     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.\n     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.\n     *\n     * @property delta\n     * @type number\n     * @default 1000 / 60\n     */\n\n})();\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\n*\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Svg\n*/\n\nvar Svg = {};\n\nmodule.exports = Svg;\n\nvar Bounds = __webpack_require__(1);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * Converts an SVG path into an array of vector points.\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\n     * See `Bodies.fromVertices` which provides support for this.\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\n     * You must load the `pathseg.js` polyfill on newer browsers.\n     * @method pathToVertices\n     * @param {SVGPathElement} path\n     * @param {Number} [sampleLength=15]\n     * @return {Vector[]} points\n     */\n    Svg.pathToVertices = function(path, sampleLength) {\n        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\n            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\n        }\n\n        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n        var i, il, total, point, segment, segments, \n            segmentsQueue, lastSegment, \n            lastPoint, segmentIndex, points = [],\n            lx, ly, length = 0, x = 0, y = 0;\n\n        sampleLength = sampleLength || 15;\n\n        var addPoint = function(px, py, pathSegType) {\n            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\n\n            // when the last point doesn't equal the current point add the current point\n            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n                if (lastPoint && isRelative) {\n                    lx = lastPoint.x;\n                    ly = lastPoint.y;\n                } else {\n                    lx = 0;\n                    ly = 0;\n                }\n\n                var point = {\n                    x: lx + px,\n                    y: ly + py\n                };\n\n                // set last point\n                if (isRelative || !lastPoint) {\n                    lastPoint = point;\n                }\n\n                points.push(point);\n\n                x = lx + px;\n                y = ly + py;\n            }\n        };\n\n        var addSegmentPoint = function(segment) {\n            var segType = segment.pathSegTypeAsLetter.toUpperCase();\n\n            // skip path ends\n            if (segType === 'Z') \n                return;\n\n            // map segment to x and y\n            switch (segType) {\n\n            case 'M':\n            case 'L':\n            case 'T':\n            case 'C':\n            case 'S':\n            case 'Q':\n                x = segment.x;\n                y = segment.y;\n                break;\n            case 'H':\n                x = segment.x;\n                break;\n            case 'V':\n                y = segment.y;\n                break;\n            }\n\n            addPoint(x, y, segment.pathSegType);\n        };\n\n        // ensure path is absolute\n        Svg._svgPathToAbsolute(path);\n\n        // get total length\n        total = path.getTotalLength();\n\n        // queue segments\n        segments = [];\n        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)\n            segments.push(path.pathSegList.getItem(i));\n\n        segmentsQueue = segments.concat();\n\n        // sample through path\n        while (length < total) {\n            // get segment at position\n            segmentIndex = path.getPathSegAtLength(length);\n            segment = segments[segmentIndex];\n\n            // new segment\n            if (segment != lastSegment) {\n                while (segmentsQueue.length && segmentsQueue[0] != segment)\n                    addSegmentPoint(segmentsQueue.shift());\n\n                lastSegment = segment;\n            }\n\n            // add points in between when curving\n            // TODO: adaptive sampling\n            switch (segment.pathSegTypeAsLetter.toUpperCase()) {\n\n            case 'C':\n            case 'T':\n            case 'S':\n            case 'Q':\n            case 'A':\n                point = path.getPointAtLength(length);\n                addPoint(point.x, point.y, 0);\n                break;\n\n            }\n\n            // increment by sample value\n            length += sampleLength;\n        }\n\n        // add remaining segments not passed by sampling\n        for (i = 0, il = segmentsQueue.length; i < il; ++i)\n            addSegmentPoint(segmentsQueue[i]);\n\n        return points;\n    };\n\n    Svg._svgPathToAbsolute = function(path) {\n        // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n        // Copyright (c) Gavin Kistner\n        // http://phrogz.net/js/_ReuseLicense.txt\n        // Modifications: tidy formatting and naming\n        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,\n            x = 0, y = 0, len = segs.numberOfItems;\n\n        for (var i = 0; i < len; ++i) {\n            var seg = segs.getItem(i),\n                segType = seg.pathSegTypeAsLetter;\n\n            if (/[MLHVCSQTA]/.test(segType)) {\n                if ('x' in seg) x = seg.x;\n                if ('y' in seg) y = seg.y;\n            } else {\n                if ('x1' in seg) x1 = x + seg.x1;\n                if ('x2' in seg) x2 = x + seg.x2;\n                if ('y1' in seg) y1 = y + seg.y1;\n                if ('y2' in seg) y2 = y + seg.y2;\n                if ('x' in seg) x += seg.x;\n                if ('y' in seg) y += seg.y;\n\n                switch (segType) {\n\n                case 'm':\n                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n                    break;\n                case 'l':\n                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n                    break;\n                case 'h':\n                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n                    break;\n                case 'v':\n                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n                    break;\n                case 'c':\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n                    break;\n                case 's':\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n                    break;\n                case 'q':\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n                    break;\n                case 't':\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n                    break;\n                case 'a':\n                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n                    break;\n                case 'z':\n                case 'Z':\n                    x = x0;\n                    y = y0;\n                    break;\n\n                }\n            }\n\n            if (segType == 'M' || segType == 'm') {\n                x0 = x;\n                y0 = y;\n            }\n        }\n    };\n\n})();\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n* This module has now been replaced by `Matter.Composite`.\n*\n* All usage should be migrated to the equivalent functions found on `Matter.Composite`.\n* For example `World.add(world, body)` now becomes `Composite.add(world, body)`.\n*\n* The property `world.gravity` has been moved to `engine.gravity`.\n*\n* For back-compatibility purposes this module will remain as a direct alias to `Matter.Composite` in the short term during migration.\n* Eventually this alias module will be marked as deprecated and then later removed in a future release.\n*\n* @class World\n*/\n\nvar World = {};\n\nmodule.exports = World;\n\nvar Composite = __webpack_require__(5);\nvar Common = __webpack_require__(0);\n\n(function() {\n\n    /**\n     * See above, aliases for back compatibility only\n     */\n    World.create = Composite.create;\n    World.add = Composite.add;\n    World.remove = Composite.remove;\n    World.clear = Composite.clear;\n    World.addComposite = Composite.addComposite;\n    World.addBody = Composite.addBody;\n    World.addConstraint = Composite.addConstraint;\n\n})();\n\n\n/***/ })\n/******/ ]);\n});","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\n\nexports.encode = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\n\nexports.decode = function(qs){\n  var qry = {};\n  var pairs = qs.split('&');\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n};\n","/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n    var src = str,\n        b = str.indexOf('['),\n        e = str.indexOf(']');\n\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n\n    var m = re.exec(str || ''),\n        uri = {},\n        i = 14;\n\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n\n    return uri;\n};\n\nfunction pathNames(obj, path) {\n    var regx = /\\/{2,9}/g,\n        names = path.replace(regx, \"/\").split(\"/\");\n\n    if (path.substr(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.substr(path.length - 1, 1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n\n    return names;\n}\n\nfunction queryKey(uri, query) {\n    var data = {};\n\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n\n    return data;\n}\n","import Matter from \"matter-js\";\r\nimport { Gameface } from \"../src/client/gameface\";\r\nimport { Render } from \"../src/client/render\";\r\nimport { Input } from \"../src/shared/input\";\r\n\r\nconst gameface = new Gameface(document.getElementById('game'));\r\ngameface.start();\r\n\r\nwindow['gameface'] = gameface;\r\nwindow['Render'] = Render;\r\nwindow['Input'] = Input;\r\n\r\ncreateMatterRender();\r\n\r\nfunction createMatterRender() {\r\n    const width = 800;\r\n    const height = 600;\r\n    const s = 2;\r\n    \r\n    // renderer\r\n    const engine = gameface.game.worlds[0].matter.engine!;\r\n    const render = Matter.Render.create({\r\n        element: document.body,\r\n        engine: engine,\r\n        bounds: {\r\n            min: { \r\n                x: -width/2 * s, \r\n                y: -height/2 * s\r\n            },\r\n            max: { \r\n                x: width/2 * s,\r\n                y: height/2 * s\r\n            }\r\n         },\r\n         options: {\r\n             hasBounds: true,\r\n             width: width,\r\n             height: height,\r\n             showAngleIndicator: true\r\n         }\r\n    });\r\n    Matter.Render.run(render);\r\n    \r\n    \r\n    \r\n    // mouse constraint\r\n    const matterWorld = gameface.game.worlds[0].matter.world!;\r\n    \r\n    const constraint: any = {\r\n        stiffness: 0.2,\r\n        render: {\r\n            visible: false\r\n        }\r\n    };\r\n    const mouse = Matter.Mouse.create(render.canvas);\r\n    const mouseConstraint = Matter.MouseConstraint.create(engine, {\r\n        mouse: mouse,\r\n        constraint: constraint\r\n    });\r\n    Matter.Composite.add(matterWorld, mouseConstraint);\r\n}\r\n\r\n","import * as pc from \"playcanvas\";\r\nimport { Input } from \"../shared/input\";\r\nimport { Gameface } from \"./gameface\";\r\nimport { Render } from \"./render\";\r\n\r\nexport class Camera {\r\n    public static height: number = 1000;\r\n    public static followPlayer: boolean = true;\r\n    public static get positon() { return this._position; }\r\n\r\n    public static testMode: boolean = false;\r\n\r\n    private static _position = new pc.Vec3();\r\n    \r\n    public static init() {\r\n        window[\"Camera\"] = Camera;\r\n    }\r\n\r\n    public static update(dt: number) {\r\n        this._position.z = this.height;\r\n\r\n        Render.camera?.setPosition(this._position.x * 0.01, this._position.z * 0.01, this._position.y * 0.01);\r\n\r\n        this.processTestMode();\r\n    }\r\n\r\n    private static processTestMode() {\r\n        if(this.testMode) {\r\n\r\n            //Input.mousePosition\r\n\r\n            const player = Gameface.Instance.player;\r\n\r\n            if(!player) return;\r\n\r\n            const position = player.transform.getPosition();\r\n\r\n            //Render.camera.setPosition(0, this.height * 0.01, 0);\r\n            //Render.camera.lookAt(this._position.x * 0.01, this._position.z * 0.01, this._position.y * 0.01)\r\n            Render.camera.setPosition(0, 20, 0)\r\n            Render.camera.lookAt(position.x * 0.01, 0, position.y * 0.01)\r\n\r\n        }\r\n    }\r\n\r\n    public static setPosition(x: number, y: number) {\r\n        this._position.x = x;\r\n        this._position.y = y;\r\n    }\r\n}","import * as pc from 'playcanvas';\r\nimport { Camera } from './camera';\r\nimport { Entity } from '../shared/entity/entity';\r\nimport { Game } from '../shared/game';\r\nimport { Input } from '../shared/input';\r\nimport { Network } from './network';\r\nimport { Render } from './render';\r\nimport { TextScript } from './playcanvas/scripts/textScript';\r\nimport { WorldSyncType } from '../shared/world';\r\nimport { EntityPlayer } from '../shared/entity/entityPlayer';\r\nimport { SyncComponent, SyncType } from '../shared/component/syncComponent';\r\n\r\nexport class Gameface {\r\n    public static Instance: Gameface;\r\n\r\n    public player?: Entity;\r\n    public controllingEntityId: string = \"\";\r\n\r\n    public get game() { return this._game; }\r\n    public get network() { return this._network; }\r\n    public get app() { return this._app; }\r\n\r\n    private _game: Game;\r\n    private _app: pc.Application;\r\n    private _network: Network;\r\n\r\n    private _canvas;\r\n\r\n    constructor(canvas) {\r\n        this._canvas = canvas;\r\n        this._game = new Game();\r\n        this._network = new Network();\r\n        \r\n        Gameface.Instance = this;\r\n    }\r\n\r\n    public start() {\r\n        this.initPlaycanvas();\r\n\r\n        this.network.init();\r\n\r\n        Camera.init();\r\n        Render.init(this._app);\r\n        Input.init(this._app);\r\n\r\n        this.game.start();\r\n\r\n        const isMultiplayer = true;\r\n\r\n        const world = this.game.createWorld('world');\r\n        if(isMultiplayer) world.syncType = WorldSyncType.CLIENT;\r\n        world.init();\r\n\r\n        Render.world = world;\r\n\r\n        \r\n\r\n        if(isMultiplayer) {\r\n            this.network.connect();\r\n            this.network.sendJoinServer('idk');\r\n        } else {\r\n            world.generateWorld();\r\n\r\n            const entity = world.spawnEntity(EntityPlayer);\r\n            this.setPlayer(entity);\r\n        }\r\n    }\r\n   \r\n    public update(dt: number) {\r\n        //this.game.update(dt);\r\n        this.network.update(dt);\r\n\r\n        this.checkControllingEntity();\r\n\r\n        Camera.update(dt);\r\n    }\r\n\r\n    public render(dt: number) {\r\n        Render.render(dt);\r\n    }\r\n\r\n\r\n    private initPlaycanvas() {\r\n        const canvas = this._canvas;\r\n        const app = this._app = new pc.Application(canvas, {\r\n            mouse: new pc.Mouse(canvas),\r\n            touch: new pc.TouchDevice(canvas),\r\n            keyboard: new pc.Keyboard(document.body)\r\n        });\r\n\r\n        pc.registerScript(TextScript, 'textScript', app);\r\n\r\n        \r\n        app.resizeCanvas(800, 600);\r\n        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);\r\n        app.setCanvasResolution(pc.RESOLUTION_AUTO);\r\n\r\n        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);\r\n\r\n        app.on('update', (dt: number) => this.update(dt));\r\n        app.on('update', (dt: number) => this.render(dt));\r\n        app.start();\r\n\r\n        window.addEventListener('resize', function(event) {\r\n            app.resizeCanvas()\r\n        }, true);\r\n\r\n\r\n        //--\r\n\r\n        /*\r\n        const text = new pc.Entity('text');\r\n        app.root.addChild(text);\r\n        const textScript = (text.addComponent('script') as pc.ScriptComponent).create('textScript') as TextScript;\r\n\r\n        console.log(textScript)\r\n        */\r\n    }\r\n\r\n    public setPlayer(entity: Entity) {\r\n        this.player = entity;\r\n        //this.player.getComponent(InputHandlerComponent)!.enabled = true;\r\n        //this.player.getComponent(SyncComponent)!.syncType = SyncType.DONT_SYNC;\r\n\r\n        console.warn(\"SETPLAYER\")\r\n    }\r\n\r\n    public checkControllingEntity() {\r\n       \r\n    }\r\n}\r\n","\r\nimport { io, Socket } from \"socket.io-client\";\r\nimport { Entity } from \"../shared/entity/entity\";\r\nimport { Gameface } from \"./gameface\";\r\nimport { IPacketData_ComponentEvent, IPacketData_ControlEntity, IPacketData_DestroyEntity, IPacketData_EntityData, IPacketData_JoinServer, IPacketData_SpawnEntity, Packet, PacketType } from \"../shared/packet\";\r\nimport { EntityChar } from \"../shared/entity/entityChar\";\r\nimport { ITransformComponent_Data } from \"../shared/component/transformComponent\";\r\nimport { SyncComponent } from \"../shared/component/syncComponent\";\r\n\r\n\r\n\r\nexport class Network {\r\n    public sendPacketInterval: number = 80;\r\n\r\n    private _socket: Socket;\r\n    private _sendPacketTime: number = 0;\r\n\r\n    public get address() {\r\n        if(location.host.includes('localhost')) return `${location.protocol}//${location.host}/`;\r\n        return `https://dmdassc-game.glitch.me/`;\r\n    }\r\n\r\n    public init() {\r\n        this._socket = io(this.address, {\r\n            //path: '/socket',\r\n            autoConnect: false,\r\n            reconnection: false\r\n        });\r\n\r\n        this._socket.on(\"p\", (packetType: PacketType, data: any) => {\r\n            const packet: Packet = {\r\n                type: packetType,\r\n                data: data\r\n            }\r\n\r\n            this.onReceivePacket(packet);\r\n        })\r\n\r\n        console.log(`[network] Address: (${this.address})`)\r\n    }\r\n\r\n    public connect() {\r\n        this._socket.connect();\r\n    }\r\n\r\n    public sendJoinServer(id: string) {\r\n        this.sendPacket<IPacketData_JoinServer>(PacketType.JOIN_SERVER, {id: id});\r\n    }\r\n\r\n    public update(dt: number) {\r\n        this._sendPacketTime += dt;\r\n        if(this._sendPacketTime >= this.sendPacketInterval / 1000) {\r\n            this._sendPacketTime = 0;\r\n\r\n            const player = Gameface.Instance.player;\r\n            if(player) this.sendPlayerData(player);\r\n        }\r\n    }\r\n\r\n    public sendPlayerData(entity: Entity) {\r\n\r\n        //const data = entity.data.getChangedData();\r\n\r\n        //console.log(data)\r\n\r\n        //entity.data.clearChangedData();\r\n\r\n        //this.sendPacket<IPacketData_EntityData>(PacketType.ENTITY_DATA, {id: entity.id, data: data})\r\n\r\n        /*\r\n        const components: Component[] = [entity.transform];\r\n        if(entity.hasComponent(InputHandlerComponent)) components.push(entity.getComponent(InputHandlerComponent));\r\n        const packet = FormatPacket.entityData(entity, components);\r\n        this.sendPacket(packet);\r\n        */\r\n    }\r\n\r\n    public sendPacket<T>(type: PacketType, packetData: T) {\r\n        const packet: Packet = {\r\n            type: type,\r\n            data: packetData\r\n        }\r\n        this._socket.emit('p', packet);\r\n    }\r\n\r\n    public onReceivePacket(packet: Packet) {\r\n        if(packet.type == PacketType.ENTITY_DATA) {\r\n            const packetData: IPacketData_EntityData = packet.data;\r\n\r\n            const id: string = packetData.id;\r\n\r\n            //console.log(id);\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n            let entity = world.getEntity(id);\r\n            \r\n            if(!entity) {\r\n                entity = new EntityChar(world);\r\n                entity.setId(id);\r\n                entity.addComponent(new SyncComponent());\r\n                world.addEntity(entity);\r\n            }\r\n            \r\n            entity.mergeData(packetData.d);\r\n        }\r\n\r\n        if(packet.type == PacketType.SPAWN_ENTITY) {\r\n            const packetData: IPacketData_SpawnEntity = packet.data;\r\n            \r\n            const entityId = packetData.id;\r\n            const entityType = packetData.type;\r\n\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            let entity = world.getEntity(entityId);\r\n\r\n            if(entity) return;\r\n\r\n            const c = world.game.entityFactory.getEntityByIndex(entityType);\r\n            \r\n            entity = new c(world);\r\n            entity.setId(entityId);\r\n        \r\n            const syncComponent = entity.addComponent(new SyncComponent());\r\n\r\n            entity.initData()\r\n            entity.mergeData(packetData.data);\r\n\r\n            world.addEntity(entity);\r\n\r\n            syncComponent.forceLerp();\r\n\r\n\r\n            console.log(\"spawn entity\", packetData)\r\n        }\r\n\r\n        /*\r\n        if(packet.type == PacketType.SPAWN_ENTITY) {\r\n            const packetData: IPacketData_SpawnEntity = packet.data;\r\n            \r\n            const entityId = packetData.id;\r\n            const entityType = packetData.type;\r\n\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) return;\r\n\r\n            const entity = world.spawnEntity(world.game.entityFactory.getEntityByIndex(entityType), {id: entityId, dontAdd: true});\r\n            const syncComponent = entity.addComponent(new SyncComponent());\r\n\r\n            entity.initData()\r\n            entity.mergeEntityData(packetData.data);\r\n\r\n            world.addEntity(entity);\r\n\r\n            syncComponent.forceLerp();\r\n\r\n            //FormatPacket.unserializeEntityData(entity, packet);\r\n            \r\n            console.log(\"spsawn entity\", packetData)\r\n        }\r\n\r\n        if(packet.type == PacketType.ENTITY_DATA) {\r\n            const packetData: IPacketData_SpawnEntity = packet.data;\r\n            \r\n            const world = Gameface.Instance.game.worlds[0];\r\n            const entity = world.getEntity(packetData.id);\r\n\r\n            if(!entity) return;\r\n\r\n            entity.mergeEntityData(packetData.data);\r\n\r\n\r\n            //console.log(packet)\r\n\r\n            //console.log(\"got data\");\r\n        }\r\n\r\n        if(packet.type == PacketType.CONTROL_ENTITY) {\r\n            const packetData: IPacketData_ControlEntity = packet.data;\r\n            \r\n\r\n            Gameface.Instance.controllingEntityId = packetData.id;\r\n            Gameface.Instance.checkControllingEntity();\r\n        }\r\n\r\n        if(packet.type == PacketType.DESTROY_ENTITY) {\r\n            const packetData: IPacketData_DestroyEntity = packet.data;\r\n            const entityId = packetData.id;\r\n            \r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) {\r\n                world.removeEntity(world.getEntity(entityId)!);\r\n            }\r\n        }\r\n\r\n        if(packet.type == PacketType.COMPONENT_EVENT) {\r\n            console.log(\"received component event packet\")\r\n\r\n            const packetData: IPacketData_ComponentEvent = packet.data;\r\n\r\n            const player = Gameface.Instance.player!;\r\n\r\n            const world = player.world;\r\n            const entity = world.getEntity(packetData.entity)!;\r\n\r\n            const component = entity.getComponent(world.game.entityFactory.getComponentByIndex(packetData.component));\r\n            //console.log(component)\r\n\r\n            component.onReceiveComponentEvent(packetData.event, packetData.data);\r\n\r\n        }\r\n\r\n        */\r\n       \r\n        //const packetType: PacketType = packet.readShort();\r\n        \r\n        /*\r\n        if(packetType == PacketType.COMPONENT_DATA) {\r\n            const entityId: string = packet.readString();\r\n            const cindex: number = packet.readShort();\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) {\r\n                const entity = world.getEntity(entityId)!;\r\n                entity.components.forEach(c => {\r\n                    try {\r\n                        if(cindex == world.game.entityFactory.getIndexOfComponent(c)) {\r\n                            c.unserialize(packet);\r\n                        }\r\n                    } catch (error) {}\r\n                });\r\n            }\r\n\r\n        }\r\n        */\r\n\r\n        /*\r\n        if(packetType == PacketType.ENTITY_DATA) {\r\n            const entityId = packet.readString();\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n            const entity = world.getEntity(entityId);\r\n            \r\n            if(entity) {\r\n                FormatPacket.unserializeEntityData(entity, packet);\r\n            }\r\n        }\r\n\r\n        if(packetType == PacketType.SPAWN_ENTITY) {\r\n            const entityId: string = packet.readString();\r\n            const entityType: number = packet.readShort();\r\n            \r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) return;\r\n\r\n            const entity = world.spawnEntity(world.game.entityFactory.getEntityByIndex(entityType), {id: entityId});\r\n            entity.addComponent(new SyncComponent());\r\n\r\n            FormatPacket.unserializeEntityData(entity, packet);\r\n            \r\n            console.log(\"spsawn entity\")\r\n        }\r\n\r\n        if(packetType == PacketType.DESTROY_ENTITY) {\r\n            const entityId: string = packet.readString();\r\n\r\n            const world = Gameface.Instance.game.worlds[0];\r\n\r\n            if(world.hasEntity(entityId)) {\r\n                world.removeEntity(world.getEntity(entityId)!);\r\n            }\r\n        }\r\n\r\n        \r\n        */\r\n    }\r\n}","import * as pc from \"playcanvas\";\r\n\r\nexport class TextScript extends pc.ScriptType {\r\n\r\n    public text: string = \"WorldText\";\r\n    public fontsize: number = 20;\r\n\r\n    public canvas: HTMLCanvasElement;\r\n    public context: CanvasRenderingContext2D;\r\n    public texture: pc.Texture;\r\n\r\n    public height: number = 20;\r\n\r\n    public initialize = () => {\r\n        this.fire('initialize');\r\n\r\n        // Create a canvas to do the text rendering\r\n        this.canvas = document.createElement('canvas');\r\n        this.context = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n        this.texture = new pc.Texture(this.app.graphicsDevice, {\r\n            format: pc.PIXELFORMAT_R8_G8_B8_A8\r\n        });\r\n        this.texture.setSource(this.canvas);\r\n        \r\n        this.texture.minFilter = pc.FILTER_LINEAR_MIPMAP_LINEAR;\r\n        this.texture.magFilter = pc.FILTER_LINEAR;\r\n\r\n        \r\n        this.texture.addressU = pc.ADDRESS_CLAMP_TO_EDGE;\r\n        this.texture.addressV = pc.ADDRESS_CLAMP_TO_EDGE;\r\n\r\n        const material = new pc.StandardMaterial();\r\n        this.entity.addComponent(\"render\", {\r\n            material: material,\r\n            type: \"plane\",\r\n        });\r\n\r\n        this.entity.render!.castShadows = false;\r\n        this.entity.render!.receiveShadows = false;\r\n\r\n        //material.emissiveMap = this.texture;\r\n\r\n        material.opacityMap = this.texture;\r\n        material.diffuseMap = this.texture;\r\n        material.blendType = pc.BLEND_NORMAL;\r\n        //material.depthTest = false;\r\n        material.update();\r\n\r\n        this.setTextureSize(512, this.height)\r\n        this.updateText();\r\n        \r\n    }\r\n\r\n    private setTextureSize(x: number, y: number) {\r\n        this.canvas.width = x;\r\n        this.canvas.height = y;\r\n        this.entity.setLocalScale(x * 0.01, 1, y * 0.01)\r\n    }\r\n\r\n    private setText(text: string) {\r\n        this.applyFont()\r\n\r\n        const ctx = this.context;\r\n        const width = ctx.measureText(text).width;\r\n\r\n        this.setTextureSize(width, this.height)\r\n\r\n        var w = ctx.canvas.width;\r\n        var h = ctx.canvas.height;\r\n\r\n        //ctx.fillStyle = \"#000000\";\r\n        ctx.clearRect(0, 0, w, h);\r\n        //ctx.fillRect(0, 0, w, h);\r\n\r\n        this.applyFont()\r\n        ctx.fillText(text, w / 2, h / 2);\r\n\r\n        this.texture.upload();\r\n    }\r\n\r\n    private applyFont() {\r\n        var ctx = this.context;\r\n        ctx.font = 'bold '+String(this.fontsize)+'px Verdana';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillStyle = 'black';\r\n    }\r\n\r\n    private updateText() {\r\n        this.setText(this.text);\r\n\r\n        setInterval(() => {\r\n            //this.text = `${Math.random()}`\r\n\r\n            //this.setText(this.text);\r\n        }, 200)\r\n    }\r\n\r\n    public postInitialize = () => {\r\n      \r\n\r\n        this.fire('postInitialize');\r\n    }\r\n\r\n\r\n    \r\n    public update = (dt) => {\r\n        this.fire('update', dt);\r\n    }\r\n\r\n    public postUpdate = (dt) => {\r\n        this.fire('postUpdate', dt);\r\n\r\n        //var pos = PlayCanvas.camera.getPosition();\r\n\r\n        //this.entity.setPosition(pos.x, 0, pos.z)\r\n\r\n        //this.text = `${this.app.}`;\r\n        //this.updateText();\r\n    }\r\n\r\n    public swap = () => {\r\n        this.fire('swap');\r\n    }\r\n}\r\n\r\n//TestScript.attributes.add('height', {type: 'number', default: 5});\r\n//TestScript.attributes.add('followEntity', {type: 'entity'});","import * as pc from 'playcanvas'\r\nimport { Entity } from '../shared/entity/entity';\r\nimport { World } from \"../shared/world\";\r\nimport { UI } from './ui/ui';\r\n\r\nexport class Render {\r\n    public static app: pc.Application;\r\n    public static world?: World;\r\n    public static camera: pc.Entity;\r\n    public static sunLight: pc.Entity;\r\n\r\n    private static _renderingEntities: Entity[] = [];\r\n\r\n    public static init(app: pc.Application) {\r\n        this.app = app;\r\n\r\n        this.setupLocalClientScene();\r\n    }\r\n\r\n    public static render(dt: number) {\r\n        this.renderWorld(dt);\r\n    }\r\n\r\n    private static renderWorld(dt: number) {\r\n        const world = this.world;\r\n        const app = this.app;\r\n\r\n        if(!world) return;\r\n\r\n\r\n        for (const entity of world.entities) {\r\n\r\n            \r\n            if(!this._renderingEntities.includes(entity)) {\r\n                this._renderingEntities.push(entity);\r\n\r\n                entity.createPcEntity();\r\n\r\n                console.log(\"[render] add pcEntity\");\r\n\r\n                app.root.addChild(entity.pcEntity);\r\n\r\n                //console.log(entity.pcEntityRoot.children)\r\n                //console.log(\"found\", entity.pcEntityRoot.findByName('CenterDebug'))\r\n\r\n                if(!entity.pcEntityRoot.findByName('CenterDebug')) {\r\n                    const material = new pc.StandardMaterial();\r\n                    material.diffuse = new pc.Color(0, 1, 0);\r\n                    material.update();\r\n\r\n                    const centerPcEntity = new pc.Entity('CenterDebug');\r\n                    centerPcEntity.addComponent(\"render\", {\r\n                        material: material,\r\n                        type: \"box\",\r\n                    });\r\n                    centerPcEntity.render!.castShadows = false;\r\n                    centerPcEntity.setLocalScale(new pc.Vec3(0.1, 0.1, 0.1));\r\n                    entity.pcEntityRoot.addChild(centerPcEntity);\r\n\r\n                    //console.log('CenterDebug', entity)\r\n                }\r\n\r\n               \r\n\r\n                /*\r\n                can't create new pc.Entity every time it streams in..\r\n                */\r\n                \r\n            }\r\n\r\n            \r\n            const transform = entity.transform;\r\n            const position = transform.getPosition();\r\n            entity.pcEntity.setPosition(position.x * 0.01, 0, position.y * 0.01);\r\n            entity.pcEntityRoot.setEulerAngles(0, pc.math.RAD_TO_DEG * -transform.data.angle, 0);\r\n            \r\n            \r\n        }\r\n        \r\n        for (const entity of this._renderingEntities) {\r\n            if(!world.entities.includes(entity)) \r\n            {\r\n                this._renderingEntities.splice(this._renderingEntities.indexOf(entity), 1);\r\n\r\n                console.log(\"[render] remove pcEntity\");\r\n                app.root.removeChild(entity.pcEntity);\r\n            }\r\n        }\r\n\r\n        for (const entity of this._renderingEntities) {\r\n            entity.render(dt);\r\n        }\r\n        \r\n        for (const entity of this._renderingEntities) {\r\n            entity.postrender(dt);\r\n        }\r\n    }\r\n\r\n    public static setupLocalClientScene() {\r\n        const app = this.app;\r\n        const camera = this.camera = new pc.Entity('camera');\r\n        camera.addComponent('camera', {\r\n            clearColor: new pc.Color(0.1, 0.1, 0.1)\r\n        });\r\n        app.root.addChild(camera);\r\n        camera.setPosition(0, 20, 0);\r\n        //camera.lookAt(0, 0, 0);\r\n        camera.setEulerAngles(-90, 0, 0);\r\n        (camera.addComponent('script') as pc.ScriptComponent).create('cameraFollow');\r\n        \r\n        \r\n        UI.init(app);\r\n\r\n        //app.scene.ambientLight.set(0, 0, 0)\r\n\r\n        //\r\n\r\n        /*\r\n        \r\n        const light = this.sunLight = new pc.Entity('light');\r\n        light.addComponent('light');\r\n        app.root.addChild(light);\r\n        //light.setEulerAngles(30, 30, 0);\r\n        light.setEulerAngles(30, 30, 0);\r\n\r\n\r\n        \r\n        light.light!.color = new pc.Color(1, 1, 1);\r\n        light.light!.castShadows = true;\r\n        light.light!.shadowType = 3;\r\n        light.light!.shadowDistance = 40\r\n        light.light!.intensity = 0.05\r\n\r\n        \r\n        console.log('light', light);\r\n\r\n        window['light'] = light;\r\n        */\r\n        \r\n\r\n        //\r\n\r\n\r\n        /*\r\n        const text = new pc.Entity('text');\r\n        app.root.addChild(text);\r\n        (text.addComponent('script') as pc.ScriptComponent).create('textScript');\r\n        */\r\n   \r\n        this.test();\r\n    }\r\n\r\n    private static test() {\r\n        const app = this.app;\r\n\r\n        const light = new pc.Entity('light');\r\n        const lightComponent = light.addComponent('light') as pc.LightComponent;\r\n        light.setPosition(2, 2, 0)\r\n        app.root.addChild(light);\r\n\r\n        lightComponent.type = \"point\"\r\n        lightComponent.color = new pc.Color(1, 1, 1);\r\n        lightComponent.range = 10;\r\n        lightComponent.intensity = 1;\r\n        lightComponent.shadowBias = 0.2\r\n        \r\n        lightComponent.castShadows = true;\r\n\r\n        window['testlight'] = lightComponent\r\n        //lightComponent.shadowType = 3;\r\n        //lightComponent.shadowDistance = 40\r\n\r\n        /*\r\n        temp1.range = 3\r\n        temp1.entity.setPosition(0, 0.5, 0)\r\n        temp1.intensity = 32\r\n        */\r\n\r\n        console.warn(lightComponent)\r\n        //lightComponent.shape = pc.LIGHTSHAPE_SPHERE;\r\n    }\r\n\r\n    public static loadAsset(url: string, callback: (asset: pc.Asset) => void) {\r\n        const imageUrl = url;\r\n        const app = Render.app;\r\n        \r\n        app.loader.getHandler(\"texture\")['crossOrigin'] = \"anonymous\";\r\n        \r\n        const asset = new pc.Asset(\"myTexture\", \"texture\", {url: imageUrl});\r\n\r\n        asset.on(\"error\", function (message) {\r\n            console.log(message);\r\n        });\r\n\r\n        asset.on(\"load\", function (asset) {\r\n            callback(asset); \r\n        });\r\n\r\n        app.assets.add(asset);\r\n        app.assets.load(asset);\r\n        return asset;\r\n    }\r\n\r\n    public static createGunFlash(x: number, y: number) {\r\n        const app = this.app;\r\n\r\n        if(!app) return;\r\n\r\n        const light = new pc.Entity('light');\r\n        const lightComponent = light.addComponent('light') as pc.LightComponent;\r\n        light.setPosition(x * 0.01, 0.2, y * 0.01)\r\n        app.root.addChild(light);\r\n\r\n        lightComponent.type = \"point\"\r\n        lightComponent.color = new pc.Color(1, 1, 0);\r\n        lightComponent.range = 1;\r\n        lightComponent.intensity = 1\r\n\r\n        setTimeout(() => {\r\n            light.destroy();\r\n            app.root.removeChild(light);\r\n        }, 60);\r\n    }\r\n}","import * as pc from 'playcanvas'\r\nimport { Render } from '../render';\r\n\r\nexport class UIText {\r\n    public get entity() { return this._entity; }\r\n\r\n    private _entity: pc.Entity;\r\n\r\n    constructor(x: number, y: number, text: string, fontAsset) {\r\n        const entity = new pc.Entity('ui-text');\r\n        entity.addComponent(\"element\", {\r\n            //anchor: new pc.Vec4(0.5, 0.5, 0.5, 0.5), // centered anchor\r\n            fontAsset: fontAsset,\r\n            fontSize: 10,\r\n            //pivot: new pc.Vec2(0.5, 0.5),            // centered pivot\r\n            text: text,\r\n            type: pc.ELEMENTTYPE_TEXT\r\n        });\r\n\r\n        this._entity = entity;\r\n    }\r\n\r\n    public setPosition(x: number, y: number) {\r\n        this.entity.setLocalPosition(x, y, 0);\r\n    }\r\n}\r\n\r\nexport class UI {\r\n    public static get screen() { return this._screen; }\r\n\r\n    private static _fontAsset: any;\r\n    private static _screen: pc.ScreenComponent;\r\n\r\n    public static init(app: pc.Application) {\r\n        const screenEntity = new pc.Entity('ui-screen');\r\n        this._screen = screenEntity.addComponent('screen', {\r\n            screenSpace: true, // for 2d screen\r\n            scaleMode: pc.SCALEMODE_BLEND,\r\n            scaleBlend: 0.5,\r\n        }) as pc.ScreenComponent;\r\n        app.root.addChild(screenEntity);\r\n\r\n        this.addImage();\r\n        const uitext = this.addText(0, 0, 'text');\r\n        //uitext.entity.setPosition(0, -1, 0)\r\n\r\n        window['UI'] = UI;\r\n    }\r\n\r\n    public static addText(x: number, y: number, text: string) {\r\n        const uiText = new UIText(x, y, text, this.getFontAsset());\r\n        uiText.setPosition(x, y);\r\n\r\n        this._screen.entity.addChild(uiText.entity);\r\n\r\n        return uiText;\r\n    }\r\n\r\n    public static addImage() {\r\n        const element = new pc.Entity('the element');\r\n        element.addComponent(\"element\", {\r\n            type: pc.ELEMENTTYPE_IMAGE\r\n        });\r\n\r\n        this._screen.entity.addChild(element);\r\n    }\r\n\r\n    public static getFontAsset() {\r\n        const app = Render.app;\r\n\r\n        if(this._fontAsset != undefined) return this._fontAsset;\r\n\r\n        this._fontAsset = new pc.Asset('arial.json', \"font\", { url: \"/assets/fonts/arial.json\" });\r\n        this._fontAsset.on('load', function () {\r\n            console.log(\"font loaded\")\r\n        });\r\n\r\n        app.assets.add(this._fontAsset);\r\n        app.assets.load(this._fontAsset);\r\n\r\n\r\n        return this._fontAsset;\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { Component } from \"./component\";\r\n\r\nenum BodyType {\r\n    RECTANGLE,\r\n    CIRCLE\r\n}\r\n\r\nclass BodyPart {\r\n    public key: string\r\n    public type: BodyType\r\n    public x: number\r\n    public y: number\r\n\r\n    public width: number = 0\r\n    public height: number = 0\r\n\r\n    public radius: number = 0\r\n\r\n    public sensor: boolean = false;\r\n\r\n    public body?: Matter.Body\r\n\r\n    constructor(key: string, x: number, y: number, type: BodyType) {\r\n        this.key = key\r\n        this.x = x\r\n        this.y = y\r\n        this.type = type\r\n    }\r\n}\r\n\r\n\r\nexport class CollisionComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 980;\r\n\r\n    public options: Matter.IChamferableBodyDefinition = {mass: 20, friction: 0.001, frictionAir: 0.3 };\r\n\r\n    public get body() { return this._body; }\r\n\r\n    private _body: Matter.Body;\r\n    private _bodyParts = new Map<string, BodyPart>();\r\n\r\n    public applyForce(x: number, y: number) {\r\n        const body = this.body;\r\n\r\n        if(!body) return;\r\n\r\n        const position = body.position;\r\n\r\n        Matter.Body.applyForce(body, position, {x: x, y: y});\r\n    }\r\n\r\n    public init() {\r\n        super.init();\r\n\r\n        this.createBody();\r\n    }\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n\r\n        const body = this.body;\r\n\r\n        if(body) {\r\n            this.entity.transform.data.x = body.position.x;\r\n            this.entity.transform.data.y = body.position.y;\r\n            this.entity.transform.data.velX = body.velocity.x;\r\n            this.entity.transform.data.velY = body.velocity.y;\r\n            this.entity.transform.data.angle = body.angle;\r\n        }\r\n    }\r\n\r\n    public preupdate(dt: number) {\r\n        super.preupdate(dt);\r\n        \r\n        const body = this.body;\r\n\r\n        if(body) {\r\n            Matter.Body.setPosition(body, {\r\n                x: this.entity.transform.data.x,\r\n                y: this.entity.transform.data.y\r\n            });\r\n            Matter.Body.setVelocity(body,  {\r\n                x: this.entity.transform.data.velX,\r\n                y: this.entity.transform.data.velY\r\n            });\r\n            Matter.Body.setAngle(body, this.entity.transform.data.angle);\r\n        }\r\n\r\n    }\r\n\r\n    public postupdate(dt: number) {\r\n        super.postupdate(dt);\r\n    }\r\n\r\n    private createBody() {\r\n\r\n        const matterWorld = this.entity.world.matter.world!;\r\n        const options = Object.assign({}, this.options);\r\n        const parts: Matter.Body[] = [];\r\n\r\n\r\n        for (const bodyPart of this._bodyParts.values()) {\r\n            \r\n            options.isSensor = bodyPart.sensor;\r\n            if(bodyPart.type == BodyType.RECTANGLE) bodyPart.body = Matter.Bodies.rectangle(bodyPart.x, bodyPart.y, bodyPart.width, bodyPart.height, options)\r\n            if(bodyPart.type == BodyType.CIRCLE) bodyPart.body = Matter.Bodies.circle(bodyPart.x, bodyPart.y, bodyPart.radius, options)\r\n\r\n            parts.push(bodyPart.body!)\r\n        }\r\n\r\n        options.isSensor = false;\r\n        options.parts = parts\r\n        \r\n        const body = Matter.Body.create(options);\r\n\r\n        Matter.Body.setCentre(body, {x: 0, y: 0});\r\n\r\n        Matter.Composite.add(matterWorld, body);\r\n      \r\n        this._body = body;\r\n    }\r\n\r\n    public getBodyPart(key: string) {\r\n        return this._bodyParts.get(key);\r\n    }\r\n\r\n    public addRectangle(key: string, x: number, y: number, width: number, height: number, sensor: boolean = false): BodyPart {\r\n        var bodyPart = new BodyPart(key, x, y, BodyType.RECTANGLE)\r\n\r\n        bodyPart.width = width\r\n        bodyPart.height = height\r\n        bodyPart.sensor = sensor;\r\n\r\n        this._bodyParts.set(key, bodyPart)\r\n\r\n        return bodyPart\r\n    }\r\n\r\n    public addCircle(key: string, x: number, y: number, radius: number): BodyPart {\r\n        var bodyPart = new BodyPart(key, x, y, BodyType.CIRCLE)\r\n\r\n        bodyPart.radius = radius\r\n  \r\n        this._bodyParts.set(key, bodyPart)\r\n\r\n        return bodyPart\r\n    }\r\n}","import { Client } from \"../../server/client\";\r\nimport { Entity } from \"../entity/entity\";\r\nimport { WorldEvent } from \"../worldEvent\";\r\n\r\nexport class Component {\r\n    public data: any;\r\n    \r\n    public entity: Entity;\r\n    public priority: number = 0;\r\n    \r\n    private _index: number | null = null;\r\n    private _a: boolean = false;\r\n\r\n    public init() {\r\n        //console.log(`[${this.constructor.name}] init`);\r\n    }\r\n    public initData() {\r\n        //console.log(`[${this.constructor.name}] init`);\r\n    }\r\n    public destroy() {\r\n        //console.log(`[${this.constructor.name}] destroy`);\r\n    }\r\n    public preupdate(dt: number) {}\r\n    public update(dt: number) {\r\n        if(!this._a) {\r\n            this._a = true;\r\n            //console.log(`[${this.constructor.name}] update`);\r\n        }\r\n    }\r\n    public postupdate(dt: number) {}\r\n\r\n    public render(dt: number) {}\r\n    public postrender(dt: number) {}\r\n\r\n    public sendComponentEvent(event: string, data, fromClient?: Client) {\r\n        this.entity.world.events.emit(WorldEvent.COMPONENT_EVENT, this, event, false, data, fromClient);\r\n    }\r\n\r\n    public broadcastComponentEvent(event: string, data, fromClient?: Client) {\r\n        this.entity.world.events.emit(WorldEvent.COMPONENT_EVENT, this, event, true, data, fromClient);\r\n    }\r\n\r\n    public onReceiveComponentEvent(event: string, data, fromClient?: Client) {}\r\n\r\n    public getIndex() {\r\n        if(this._index == null) {\r\n            this._index = this.entity.world.game.entityFactory.getIndexOfComponent(this);\r\n        }\r\n        return this._index;\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Render } from '../../client/render';\r\nimport { UI, UIText } from '../../client/ui/ui';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { WorldSyncType } from '../world';\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\nimport { SyncType } from './syncComponent';\r\n\r\nexport class DebugComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 0;\r\n\r\n    private _uitext?: UIText;\r\n\r\n    private _textLines = new Map<string, string>();\r\n\r\n    public initData(): void {\r\n    \r\n    }\r\n    \r\n    public init() {\r\n        super.init();\r\n\r\n        this.setLineText('default', this.entity.constructor.name);\r\n    }\r\n\r\n    public setLineText(line: string, text: string) {\r\n        this._textLines.set(line, text);\r\n    }\r\n\r\n    public render(dt: number): void {\r\n\r\n        if(!Render.app) return;\r\n\r\n        if(!this._uitext) {\r\n\r\n            this._uitext = UI.addText(0, 0, '');\r\n            this._uitext.entity.element.fontSize = 8;\r\n        }\r\n\r\n\r\n        //const position = this.entity.transform.getPosition();\r\n\r\n        var worldPos = this.entity.pcEntity.getPosition();\r\n        var screenPos = new pc.Vec3();\r\n        \r\n        // get screen space co-ord\r\n        Render.camera.camera.worldToScreen(worldPos, screenPos);\r\n\r\n        var pixelRatio = Render.app.graphicsDevice.maxPixelRatio;\r\n        screenPos.x *= pixelRatio;\r\n        screenPos.y *= pixelRatio;\r\n\r\n        // convert to screen component co-ordinates\r\n        var screenEntity = UI.screen.entity;\r\n        var scale = screenEntity.screen.scale;\r\n\r\n        var device = Render.app.graphicsDevice;\r\n\r\n        this._uitext.entity.setLocalPosition(screenPos.x / scale, (device.height - screenPos.y) / scale, 0);  \r\n\r\n        let str = ``;\r\n\r\n        for (const pair of this._textLines) {\r\n            str += `${pair[1]}\\n`;\r\n        }\r\n        \r\n        this._uitext.entity.element.text = str;\r\n    }\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\n\r\nexport class NPCBehaviourComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 0;\r\n\r\n    private _targetPosition = new pc.Vec2(300, 300);\r\n    private _newPositionTime = 0;\r\n\r\n    public init() {\r\n        super.init();\r\n    }\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n\r\n        this.processNewPosition(dt);\r\n        this.processMovement(dt);\r\n    }\r\n\r\n    private processNewPosition(dt: number) {\r\n        this._newPositionTime -= dt;\r\n        if(this._newPositionTime <= 0) {\r\n            this._newPositionTime = Math.random()*5;\r\n\r\n            const range = 1300;\r\n\r\n            this._targetPosition.x = Math.random()*range-(range/2);\r\n            this._targetPosition.y = Math.random()*range-(range/2);\r\n        }\r\n    }\r\n\r\n    private processMovement(dt: number) {\r\n\r\n        const input = {\r\n            horizontal: 0,\r\n            vertical: 0\r\n        };\r\n\r\n        const position = this.entity.transform.getPosition();\r\n\r\n        if(position.x < this._targetPosition.x) {\r\n            input.horizontal = 1;\r\n        } else {\r\n            input.horizontal = -1;\r\n        }\r\n\r\n        if(position.y < this._targetPosition.y) {\r\n            input.vertical = 1;\r\n        } else {\r\n            input.vertical = -1;\r\n        }\r\n\r\n        if(position.distance(this._targetPosition) < 30) {\r\n            input.vertical = 0;\r\n            input.horizontal = 0;\r\n        }\r\n\r\n\r\n        this.entity.transform.applyForce(input.horizontal * 2 * dt, input.vertical * 2 * dt);\r\n        //this.entity.transform.setVelocity(3, 0);\r\n        //this.entity.transform.setPosition(position.x + input.horizontal, position.y + input.vertical);\r\n    }\r\n   \r\n    public postupdate(dt: number) {\r\n        super.postupdate(dt);\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { WorldSyncType } from '../world';\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\nimport { DebugComponent } from './debugComponent';\r\nimport { SyncType } from './syncComponent';\r\n\r\nexport interface IPlayerComponent_Data {\r\n    name: string\r\n    color: number\r\n}\r\n\r\nexport class PlayerComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 0;\r\n\r\n    public data: IPlayerComponent_Data = {\r\n        name: 'no name',\r\n        color: 0\r\n    }\r\n\r\n    public initData(): void {\r\n        if(this.entity.world.syncType != WorldSyncType.CLIENT) {\r\n            setInterval(() => {\r\n                this.data.color++\r\n            }, 1000)\r\n        }\r\n    }\r\n    \r\n    public init() {\r\n        super.init();\r\n\r\n        \r\n    }\r\n\r\n\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n\r\n        this.entity.getComponent(DebugComponent)?.setLineText('playername', `${this.data.name}, ${this.data.color}`)\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\n\r\nexport enum SyncType {\r\n    DONT_SYNC,\r\n    CLIENT_SYNC,\r\n    SERVER_SYNC\r\n}\r\n\r\nexport class SyncComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 1010;\r\n    \r\n    public syncType: SyncType = SyncType.CLIENT_SYNC;\r\n    public positionLerp: number = 0.05;\r\n\r\n    private _targetPosition = new pc.Vec2();\r\n    private _targetVelocity = new pc.Vec2();\r\n    private _targetAngle = 0;\r\n    private _lastUpdated: number = 0;\r\n\r\n    public init() {\r\n        super.init();\r\n    }\r\n\r\n    public processSync() {\r\n\r\n        if(this.syncType == SyncType.DONT_SYNC) return;\r\n\r\n        const now = Date.now();\r\n\r\n        let tl = 800;\r\n        let lerpFactor = (1 - (Math.min(tl, now - this._lastUpdated) / tl))\r\n\r\n        //lerpFactor = 1;\r\n\r\n\r\n        //if(now - this._lastUpdated > (this.entity.syncInterval == 0 ? 500 : 1)) return;\r\n\r\n        \r\n        const transform = this.entity.transform;\r\n\r\n        const position = transform.getPosition();\r\n\r\n        let posLerp = this.positionLerp;\r\n        const distance = this._targetPosition.distance(position);\r\n        if(distance > 60) {\r\n            posLerp = 1;\r\n        }\r\n\r\n        const x = pc.math.lerp(position.x, this._targetPosition.x, posLerp * lerpFactor);\r\n        const y = pc.math.lerp(position.y, this._targetPosition.y, posLerp * lerpFactor);\r\n\r\n        let angle = pc.math.lerpAngle(transform.getAngle(), this._targetAngle, 0.7 * lerpFactor);\r\n        if(Math.abs(angle - this._targetAngle) >= Math.PI/4) angle = this._targetAngle;\r\n\r\n        const velocity = transform.getVelocity();\r\n\r\n        const velX = pc.math.lerp(velocity.x, this._targetVelocity.x, 0.8 );\r\n        const velY = pc.math.lerp(velocity.y, this._targetVelocity.y, 0.8 );\r\n\r\n        \r\n        transform.setPosition(x, y);\r\n        transform.setAngle(angle);\r\n        transform.setVelocity(velX, velY);\r\n\r\n        //console.log(velX, velY)\r\n        //transform.setAngularVelocity(0);\r\n    }\r\n\r\n    public preupdate(dt: number) {\r\n        super.preupdate(dt);\r\n\r\n        this.processSync();\r\n    }\r\n\r\n    public setPosition(x: number, y: number) {\r\n        this._lastUpdated = Date.now();\r\n        this._targetPosition.set(x, y);\r\n    }\r\n\r\n    public setAngle(angle: number) {\r\n        this._lastUpdated = Date.now();\r\n        this._targetAngle = angle;\r\n    }\r\n\r\n    public setVelocity(x: number, y: number) {\r\n        this._lastUpdated = Date.now();\r\n        this._targetVelocity.set(x, y);\r\n    }\r\n\r\n    public forceLerp() {\r\n        const transform = this.entity.transform;\r\n\r\n        transform.setPosition(this._targetPosition.x, this._targetPosition.y);\r\n        transform.setAngle(this._targetAngle);\r\n        transform.setVelocity(this._targetVelocity.x, this._targetVelocity.y);\r\n    }\r\n}","import Matter from 'matter-js';\r\nimport * as pc from 'playcanvas';\r\nimport { Entity } from \"../entity/entity\";\r\nimport { CollisionComponent } from './collisionComponent';\r\nimport { Component } from \"./component\";\r\n\r\nexport interface ITransformComponent_Data {\r\n    x: number\r\n    y: number\r\n    velX: number\r\n    velY: number\r\n    angle: number\r\n    aimAngle: number\r\n}\r\n\r\nexport class TransformComponent extends Component {\r\n    public entity: Entity;\r\n    public priority: number = 1000;\r\n\r\n    private _collisionComponent?: CollisionComponent;\r\n\r\n    public data: ITransformComponent_Data = {\r\n        angle: 0,\r\n        aimAngle: 0,\r\n        x: 0,\r\n        y: 0,\r\n        velX: 0,\r\n        velY: 0\r\n    }\r\n    \r\n    public getAngle() {\r\n        return this.data.angle;\r\n    }\r\n\r\n    public setAngle(angle: number) {\r\n        this.data.angle = angle;\r\n    }\r\n\r\n    public getAimAngle() {\r\n        return this.data.angle;\r\n    }\r\n\r\n    public setAimAngle(angle: number) {\r\n        this.data.aimAngle = angle;\r\n    }\r\n\r\n    public getPosition() {\r\n        return new pc.Vec2(this.data.x, this.data.y);\r\n    }\r\n    \r\n    public setPosition(x: number, y: number) {\r\n        this.data.x = x;\r\n        this.data.y = y;\r\n    }\r\n\r\n    public getVelocity() {\r\n        return new pc.Vec2(this.data.velX, this.data.velY);\r\n    }\r\n\r\n    public setVelocity(x: number, y: number) {\r\n        this.data.velX = x;\r\n        this.data.velY = y;\r\n    }\r\n    \r\n    public applyForce(x: number, y: number) {\r\n        this._collisionComponent?.applyForce(x, y);\r\n    }\r\n\r\n    public init() {\r\n        super.init();\r\n\r\n        this._collisionComponent = this.entity.getComponent(CollisionComponent);\r\n    }\r\n\r\n    public preupdate(dt: number) {\r\n        super.preupdate(dt);\r\n    }\r\n\r\n    public update(dt: number) {\r\n        super.update(dt);\r\n    }\r\n\r\n    public postupdate(dt: number) {\r\n        super.postupdate(dt);\r\n    }\r\n}","import { Component } from \"./component/component\";\r\nimport { Entity } from \"./entity/entity\";\r\n\r\nexport class EntityFactory {\r\n\r\n    private _allComponents: { new(...args: any[]): Component }[] = [];\r\n    private _allEntities: { new(...args: any[]): Entity }[] = [];\r\n\r\n\r\n    public registerEntity<T extends Entity>(constr: { new(...args: any[]): T }) {\r\n        this._allEntities.push(constr);\r\n    }\r\n\r\n    public registerComponent<T extends Component>(constr: { new(...args: any[]): T }) {\r\n        this._allComponents.push(constr);\r\n    }\r\n\r\n    public getIndexOfComponent<T extends Component>(c: T) {\r\n        let i = 0;\r\n        for (const constr of this._allComponents) {\r\n            if(constr.name == c.constructor.name) return i;\r\n            i++;\r\n        }\r\n        throw \"Component \" + c.constructor.name + \" not found\";\r\n    }\r\n\r\n    public getEntityByIndex(index: number) {\r\n        return this._allEntities[index];\r\n    }\r\n\r\n    public getComponentByIndex(index: number) {\r\n        return this._allComponents[index];\r\n    }\r\n\r\n    public getIndexOfEntity<T extends Entity>(c: T) {\r\n        let i = 0;\r\n        for (const constr of this._allEntities.values()) {\r\n            if(constr.name == c.constructor.name) return i;\r\n            i++;\r\n        }\r\n        throw \"Entity \" + c.constructor.name + \" not found\";\r\n    }\r\n}","import * as pc from 'playcanvas';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { Component } from '../component/component';\r\nimport { SyncComponent } from '../component/syncComponent';\r\nimport { ITransformComponent_Data, TransformComponent } from '../component/transformComponent';\r\nimport { World } from '../world';\r\n\r\nexport class DataWatcher {\r\n\r\n    private _data: any = {};\r\n    //private _changedData: any = {};\r\n\r\n    public setData(data: any) {\r\n\r\n        //console.log(\"\\n_data:\", JSON.stringify(this._data))\r\n        //console.log(\"new data:\", JSON.stringify(data))\r\n\r\n        const changedData = this.testObj(data, this._data);\r\n        //console.log(\"changedData:\", JSON.stringify(changedData))\r\n\r\n        //this._data = Object.assign({}, data);\r\n        this._data = JSON.parse(JSON.stringify(data));\r\n\r\n        return changedData;\r\n    }\r\n\r\n    public testObj(o: any, compare: any) {\r\n        //console.log(\"test obj\", JSON.stringify(o))\r\n\r\n        let result: any = undefined;\r\n   \r\n        const setResult = (key: string, value: any) => {\r\n            if(result == undefined) result = {}; \r\n\r\n            result[key] = value;\r\n        }\r\n\r\n        for (const k in o) {\r\n\r\n            //console.log(\"--\", k)\r\n\r\n\r\n            \r\n            if(o[k] instanceof Object) {\r\n                \r\n\r\n                const resultObj = this.testObj(o[k], compare[k]);\r\n\r\n                if(resultObj != undefined) {\r\n                    setResult(k, resultObj)\r\n                }\r\n            } else {\r\n\r\n                if(compare == undefined) {\r\n                    //console.log(\"compare not defined\")\r\n\r\n                    setResult(k, o[k]);\r\n                } else {\r\n\r\n                    if(compare[k] != o[k]) {\r\n\r\n                        setResult(k, o[k])\r\n\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nexport class Entity {\r\n    public destroyed: boolean = false;\r\n    \r\n    public dataWatcher: DataWatcher = new DataWatcher();\r\n    \r\n    public canSync: boolean = true;\r\n\r\n    public get id() { return this._id; }\r\n    public get world() { return this._world; }\r\n    public get components() { return this._components; }\r\n    public get transform() { return this._transform; }\r\n    public get pcEntity() { return this._pcEntity!; }\r\n    public get pcEntityRoot() { return this.pcEntity.findByName('Root')!; }\r\n    \r\n    /*\r\n    public get pcEntity() {\r\n        if(!this._pcEntity) {\r\n            this._pcEntity = new pc.Entity('Entity');\r\n            this._pcEntity.addChild(new pc.Entity('Root'))\r\n        }\r\n        return this._pcEntity;\r\n    }\r\n    */\r\n    \r\n\r\n    private _index: number | null = null;\r\n    private _pcEntity?: pc.Entity;\r\n    private _id: string = uuidv4();\r\n    private _world: World;\r\n    private _components: Component[] = [];\r\n    private _transform: TransformComponent;\r\n    private _hasInitalized: boolean = false;\r\n    private _hasInitalizedData: boolean = false;\r\n\r\n    constructor(world: World, pcEntity?: pc.Entity) {\r\n        this._world = world;\r\n        if(pcEntity) this._pcEntity = pcEntity;\r\n        this._transform = this.addComponent(new TransformComponent());\r\n    }\r\n\r\n    public getFullData() {\r\n        let fullData: any = undefined;\r\n\r\n        for (const component of this.components) {\r\n            const data = component.data;\r\n\r\n            if(data == undefined) continue;\r\n\r\n            if(fullData == undefined) fullData = {};\r\n\r\n            fullData[component.getIndex()] = data;\r\n\r\n        }\r\n        return fullData;\r\n    }\r\n\r\n    public mergeData(data: any) {\r\n        if(data == undefined) return;\r\n\r\n        //\r\n        const transformData = data[this.transform.getIndex()];\r\n\r\n        if(transformData != undefined) {\r\n            const transform = this.transform;\r\n\r\n            const angle = transform.getAngle();\r\n            const toSyncAngle = transformData.angle != undefined ? transformData.angle : angle;\r\n    \r\n            const position = transform.getPosition();\r\n            const toSyncPosition = {\r\n                x: transformData.x != undefined ? transformData.x : position.x,\r\n                y: transformData.y != undefined ? transformData.y : position.y\r\n            }\r\n\r\n            const velocity = transform.getVelocity();\r\n            const toSyncVelocity = {\r\n                x: transformData.velX != undefined ? transformData.velX : velocity.x,\r\n                y: transformData.velY != undefined ? transformData.velY : velocity.y\r\n            }\r\n    \r\n            Object.assign(transform.data, transformData);\r\n\r\n            delete data[transform.getIndex()];\r\n\r\n            const syncComponent = this.getComponent(SyncComponent);\r\n    \r\n            if(syncComponent) {\r\n                transform.setPosition(position.x, position.y);\r\n                transform.setVelocity(velocity.x, velocity.y);\r\n                transform.setAngle(angle);\r\n                \r\n                syncComponent.setPosition(toSyncPosition.x, toSyncPosition.y);\r\n                syncComponent.setVelocity(toSyncVelocity.x, toSyncVelocity.y);\r\n                syncComponent.setAngle(toSyncAngle);\r\n            }\r\n        }\r\n\r\n        //\r\n\r\n        for (const component of this._components) {\r\n            const cdata = data[component.getIndex()];\r\n            if(cdata == undefined) continue;\r\n            Object.assign(component.data, cdata);\r\n        }\r\n\r\n\r\n\r\n     \r\n        \r\n        \r\n    }\r\n\r\n    public setId(id: string) {\r\n        this._id = id;\r\n    }\r\n\r\n    public addComponent<C extends Component>(c: C) {\r\n        c.entity = this;\r\n        this._components.push(c);\r\n\r\n        this._components = this._components.sort((a, b) => b.priority - a.priority)\r\n\r\n        if(this._hasInitalized) c.init();\r\n        return c;\r\n    }\r\n\r\n    public createPcEntity() {\r\n        if(!this._pcEntity) {\r\n            this._pcEntity = new pc.Entity('Entity');\r\n            this._pcEntity.addChild(new pc.Entity('Root'))\r\n        }\r\n    }\r\n\r\n    /*\r\n    public hasComponent<C extends Component>(constr: { new(...args: any[]): C }) {\r\n        for (const component of this._components) if (component instanceof constr) return true;\r\n        return false;\r\n    }\r\n    */\r\n\r\n    public getComponent<C extends Component>(constr: { new(...args: any[]): C }) {\r\n        for (const component of this._components) if (component instanceof constr) return component as C;\r\n        return \r\n    }\r\n\r\n    public initData() {\r\n        if(this._hasInitalizedData) return;\r\n\r\n        for (const component of this._components) component.initData();\r\n        this._hasInitalizedData = true;\r\n    }\r\n\r\n    public init() {\r\n        this.initData();\r\n        for (const component of this._components) component.init();\r\n        this._hasInitalized = true;\r\n    }\r\n\r\n    public preupdate(dt: number) {\r\n        for (const component of this._components) component.preupdate(dt);\r\n    }\r\n\r\n    public update(dt: number) {\r\n        for (const component of this._components) component.update(dt);\r\n    }\r\n\r\n    public postupdate(dt: number) {\r\n        for (const component of this._components) component.postupdate(dt);\r\n    }\r\n\r\n    public render(dt: number) {\r\n        for (const component of this._components) component.render(dt);\r\n    }\r\n\r\n    public postrender(dt: number) {\r\n        for (const component of this._components) component.postrender(dt);\r\n    }\r\n\r\n    public destroy() {\r\n        if(this.destroyed) return;\r\n        this.destroyed = true;\r\n\r\n        for (const component of this._components) component.destroy();\r\n    }\r\n\r\n    public getIndex() {\r\n        \r\n        if(this._index == null) {\r\n            this._index = this.world.game.entityFactory.getIndexOfEntity(this);\r\n        }\r\n        return this._index;\r\n    }\r\n}","import { CollisionComponent } from \"../component/collisionComponent\";\r\nimport { DebugComponent } from \"../component/debugComponent\";\r\nimport { PlayerComponent } from \"../component/playerComponent\";\r\nimport { World } from \"../world\";\r\nimport { Entity } from \"./entity\";\r\n\r\nexport class EntityChar extends Entity {\r\n    constructor(world: World) {\r\n        super(world);\r\n\r\n        this.addComponent(new PlayerComponent());\r\n        this.addComponent(new DebugComponent());\r\n        //this.addComponent(new InputHandlerComponent());\r\n\r\n        //const sprite = this.addComponent(new SpriteComponent());\r\n        //sprite.add('default', 'assets/player.png', 3, 80, 80);\r\n\r\n        const collision = this.addComponent(new CollisionComponent());\r\n        //collision.options.frictionAir = 0.2;\r\n        collision.addCircle('default', 0, 0, 30);\r\n    }\r\n}","import { CollisionComponent } from \"../component/collisionComponent\";\r\nimport { DebugComponent } from \"../component/debugComponent\";\r\nimport { PlayerComponent } from \"../component/playerComponent\";\r\nimport { World } from \"../world\";\r\nimport { Entity } from \"./entity\";\r\n\r\nexport class EntityObject extends Entity {\r\n    constructor(world: World) {\r\n        super(world);\r\n\r\n        this.addComponent(new DebugComponent());\r\n        \r\n\r\n        const collision = this.addComponent(new CollisionComponent());\r\n        //collision.options.frictionAir = 0.2;\r\n        collision.addRectangle('default', 0, 0, 50, 50);\r\n    }\r\n}","import { PlayerComponent } from \"../component/playerComponent\";\r\nimport { World } from \"../world\";\r\nimport { EntityChar } from \"./entityChar\";\r\n\r\nexport class EntityPlayer extends EntityChar {\r\n    constructor(world: World) {\r\n        super(world);\r\n    }\r\n}","export class EventEmitter {\r\n    private _events = new Map<string, ((...args: any) => void)[]>();\r\n\r\n    public on(event: string, fn: (...args: any) => void) {\r\n        console.log(`added listener for ${event}`);\r\n\r\n        if(!this._events.has(event)) {\r\n            this._events.set(event, []);\r\n        }\r\n\r\n        this._events.get(event)!.push(fn);\r\n\r\n        //console.log(this._events)\r\n    }   \r\n\r\n    public emit(event: string, ...args) {\r\n        //console.log(event, args)\r\n\r\n        if(!this._events.has(event)) return;\r\n\r\n        for (const fn of this._events.get(event)!) {\r\n            fn.apply(null, args);\r\n        }\r\n\r\n    }\r\n}","import { TransformComponent } from \"./component/transformComponent\";\r\nimport { EntityFactory } from \"./entityFactory\";\r\nimport { World } from \"./world\";\r\nimport { InventoryManager } from \"./inventoryManager\";\r\nimport { EntityChar } from \"./entity/entityChar\";\r\nimport { EntityPlayer } from \"./entity/entityPlayer\";\r\nimport { CollisionComponent } from \"./component/collisionComponent\";\r\nimport { PlayerComponent } from \"./component/playerComponent\";\r\nimport { NPCBehaviourComponent } from \"./component/npcBehaviourComponent\";\r\nimport { EntityObject } from \"./entity/entityObject\";\r\nimport { SyncComponent } from \"./component/syncComponent\";\r\nimport { DebugComponent } from \"./component/debugComponent\";\r\n\r\nexport class Game {\r\n    public get worlds() { return Array.from(this._worlds.values()); }\r\n    public get entityFactory() { return this._entityFactory; }\r\n\r\n    private _worlds = new Map<string, World>();\r\n    private _entityFactory: EntityFactory;\r\n    private _inventoryManager: InventoryManager;\r\n\r\n    public updateInterval: number = 16;\r\n    public fixTime: number = 0.94;\r\n\r\n    constructor() {\r\n        this._entityFactory = new EntityFactory();\r\n\r\n        this._entityFactory.registerComponent(TransformComponent);\r\n        this._entityFactory.registerComponent(CollisionComponent);\r\n        this._entityFactory.registerComponent(PlayerComponent);\r\n        this._entityFactory.registerComponent(NPCBehaviourComponent);\r\n        this._entityFactory.registerComponent(SyncComponent);\r\n        this._entityFactory.registerComponent(DebugComponent);\r\n\r\n\r\n        this._entityFactory.registerEntity(EntityChar);\r\n        this._entityFactory.registerEntity(EntityPlayer);\r\n        this._entityFactory.registerEntity(EntityObject);\r\n\r\n        this._inventoryManager = new InventoryManager();\r\n\r\n        const inventory = this._inventoryManager.createInventory('test');\r\n        inventory.createTab(3, 3);\r\n\r\n        let f: number = -1;\r\n\r\n        let lastTick = 0;\r\n        setInterval(() => {\r\n            let now = Date.now();\r\n\r\n           \r\n\r\n            if(now - lastTick >= this.updateInterval) {\r\n                //console.log()\r\n\r\n                let dt = (now - (lastTick == 0 ? now : lastTick)) / 1000;\r\n                lastTick = now;\r\n\r\n                /*\r\n                if(f == -1) {\r\n                    f = 1;\r\n                    console.log(dt)\r\n                }\r\n                */\r\n    \r\n                if(dt != 0) this.update(dt);\r\n            }\r\n\r\n           \r\n\r\n\r\n            //this.update(dt);\r\n        })\r\n    }\r\n\r\n    public start() {\r\n        console.log(`[game] start`);\r\n    }\r\n\r\n    public update(dt: number) {\r\n        //console.log(`[game] update ${dt}`);\r\n\r\n        \r\n        for (const world of this.worlds) {\r\n            world.tick(dt);   \r\n        }\r\n        \r\n    }\r\n\r\n    public createWorld(name: string) {\r\n        console.log(`[game] create world '${name}'`);\r\n\r\n        const world = new World(this);\r\n        this._worlds.set(name, world);\r\n        return world;\r\n    }\r\n}","import * as pc from 'playcanvas'\r\n\r\nexport class Input {\r\n    public static get mousePosition() { return this._mousePosition; }\r\n    public static get mouseDown() { return this._mouseDown; }\r\n\r\n    private static _keys = new Map<number, boolean>();\r\n    private static _mousePosition = new pc.Vec2(0, 0);\r\n    private static _mouseDown: boolean = false;\r\n\r\n    public static init(app: pc.Application) {\r\n        console.log(\"[input] init\");\r\n\r\n        app.keyboard.on(pc.EVENT_KEYDOWN, this.onKeyDown, this);\r\n        app.keyboard.on(pc.EVENT_KEYUP, this.onKeyUp, this);\r\n\r\n        app.mouse.on(pc.EVENT_MOUSEMOVE, this.onMouseMove, this);\r\n        app.mouse.on(pc.EVENT_MOUSEDOWN, this.onMouseDown, this);\r\n        app.mouse.on(pc.EVENT_MOUSEUP, this.onMouseUp, this);\r\n\r\n    }\r\n\r\n    private static updateMousePosition(event: MouseEvent) {\r\n        this._mousePosition.set(event.x, event.y)\r\n    }\r\n\r\n    private static onMouseMove(event: MouseEvent) {\r\n        this.updateMousePosition(event);\r\n    }\r\n\r\n    private static onMouseDown(event: MouseEvent) {\r\n        this._mouseDown = true;\r\n        this.updateMousePosition(event);\r\n    }\r\n\r\n    private static onMouseUp(event: MouseEvent) {\r\n        this._mouseDown = false;\r\n        this.updateMousePosition(event);\r\n    }\r\n\r\n    public static update(dt: number) {\r\n\r\n    }\r\n\r\n    public static getKeyDown(key: number | string) {\r\n        const keyCodes: number[] = []\r\n\r\n        if(typeof key == 'string') {\r\n            keyCodes.push(key.toLowerCase().charCodeAt(0))\r\n            keyCodes.push(key.toUpperCase().charCodeAt(0))\r\n        } else {\r\n            keyCodes.push(key)\r\n        }\r\n\r\n        for (const keyCode of keyCodes) {\r\n            const state = this._keys.get(keyCode) === true;\r\n            if(state) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private static onKeyDown(e: KeyboardEvent) {\r\n        const keyCode = parseInt(e.key);\r\n        this._keys.set(keyCode, true);\r\n    }\r\n\r\n    private static onKeyUp(e: KeyboardEvent) {\r\n        const keyCode = parseInt(e.key);\r\n        this._keys.set(keyCode, false);\r\n    }\r\n    \r\n}","import { v4 as uuidv4 } from 'uuid';\r\n\r\nexport class Item {\r\n    public get id() { return this._id; }\r\n\r\n    private _id: string = uuidv4();\r\n}\r\n\r\nexport class Tab {\r\n\r\n}\r\n\r\nexport class Inventory {\r\n\r\n    private _tabs: Tab[] = [];\r\n\r\n\r\n    constructor() {\r\n        \r\n    }\r\n\r\n    public createTab(slotsX: number, slotsY: number) {\r\n\r\n    }\r\n\r\n}\r\n\r\nexport class InventoryManager {\r\n\r\n    public createInventory(id: string) {\r\n        const inventory = new Inventory();\r\n        return inventory;\r\n    }\r\n\r\n\r\n}","//import ByteBuffer from \"bytebuffer\";\r\n\r\nexport enum PacketType {\r\n    ENTITY_DATA,\r\n    JOIN_SERVER,\r\n    SPAWN_ENTITY,\r\n    DESTROY_ENTITY,\r\n    CONTROL_ENTITY,\r\n    WEAPON_SHOT,\r\n    COMPONENT_EVENT\r\n}\r\n\r\nexport interface IPacketData_ComponentEvent {\r\n    entity: string\r\n    component: number\r\n    event: string\r\n    data: any\r\n}\r\n\r\nexport interface IPacketData_JoinServer {\r\n    id: string\r\n}\r\n\r\nexport interface IPacketData_ControlEntity {\r\n    id: string\r\n}\r\n\r\nexport interface IPacketData_SpawnEntity {\r\n    id: string\r\n    type: number\r\n    data: any\r\n}\r\n\r\nexport interface IPacketData_DestroyEntity {\r\n    id: string\r\n}\r\n\r\nexport interface IPacketData_EntityData {\r\n    id: string\r\n    d: any\r\n}\r\n\r\nexport interface Packet {\r\n    type: PacketType\r\n    data: any\r\n}\r\n\r\n/*\r\nexport class Packet {\r\n    public buffer = new ByteBuffer();\r\n    public index: string[] = [];\r\n\r\n    public writeShort(value: number) {\r\n        this.buffer.writeShort(value);\r\n        this.index.push(\"short\");\r\n    }\r\n\r\n    public writeString(value: string) {\r\n        this.buffer.writeShort(value.length);\r\n        this.buffer.writeString(value);\r\n        this.index.push(\"short - len\");\r\n        this.index.push(\"string\");\r\n    }\r\n\r\n    public writeFloat(value: number) {\r\n        this.buffer.writeFloat(value);\r\n        this.index.push(\"float\");\r\n    }\r\n\r\n    public writeDouble(value: number) {\r\n        this.buffer.writeDouble(value);\r\n        this.index.push(\"double\");\r\n    }\r\n\r\n    public readType() {\r\n        return this.buffer.readShort() as PacketType;\r\n    }\r\n\r\n    public readShort() {\r\n        return this.buffer.readShort();\r\n    }\r\n\r\n    public readFloat() {\r\n        return this.buffer.readFloat();\r\n    }\r\n\r\n    public readDouble() {\r\n        return this.buffer.readDouble();\r\n    }\r\n\r\n    public readString() {\r\n        const len = this.readShort();\r\n        return this.buffer.readUTF8String(len);\r\n    }\r\n}\r\n*/","import Matter from \"matter-js\";\r\nimport * as pc from \"playcanvas\";\r\nimport { Component } from \"./component/component\";\r\nimport { Entity } from \"./entity/entity\";\r\nimport { Game } from \"./game\";\r\nimport { EventEmitter } from \"./eventEmitter\";\r\nimport { WorldEvent } from \"./worldEvent\";\r\nimport { Gameface } from \"../client/gameface\";\r\nimport { IPacketData_ComponentEvent, PacketType } from \"./packet\";\r\nimport { Client } from \"../server/client\";\r\nimport { EntityPlayer } from \"./entity/entityPlayer\";\r\nimport { EntityChar } from \"./entity/entityChar\";\r\nimport { NPCBehaviourComponent } from \"./component/npcBehaviourComponent\";\r\nimport { PlayerComponent } from \"./component/playerComponent\";\r\nimport { EntityObject } from \"./entity/entityObject\";\r\n\r\nlet testu = 0;\r\nlet testd = 0;\r\n\r\ninterface IWorldMatter {\r\n    engine?: Matter.Engine\r\n    world?: Matter.World\r\n    runner?: Matter.Runner\r\n}\r\n\r\nexport enum WorldSyncType {\r\n    SINGLEPLAYER,\r\n    CLIENT,\r\n    HOST\r\n}\r\n\r\nexport class World {\r\n    public events: EventEmitter = new EventEmitter();\r\n\r\n    public syncType: WorldSyncType = WorldSyncType.SINGLEPLAYER;\r\n    \r\n    public matter: IWorldMatter = {}\r\n    public get entities() { return this._entities };\r\n    public get game() { return this._game; };\r\n    \r\n    private _entities: Entity[] = [];\r\n    private _game: Game;\r\n\r\n    constructor(game: Game) {\r\n        this._game = game;\r\n        \r\n        this.events.on(WorldEvent.COMPONENT_EVENT, (component: Component, event: string, broadcast: boolean, data: any, fromClient?: Client) => {\r\n            //console.log(`[world] Component event: ${event} (${fromClient ? \"has client\" : \"no client\"})`)\r\n\r\n            if(this.syncType == WorldSyncType.CLIENT) {\r\n\r\n                const packetData: IPacketData_ComponentEvent = {\r\n                    entity: component.entity.id,\r\n                    component: this.game.entityFactory.getIndexOfComponent(component),\r\n                    event: event,\r\n                    data: data\r\n                }\r\n                \r\n                Gameface.Instance.network.sendPacket(PacketType.COMPONENT_EVENT, packetData);\r\n\r\n                \r\n                console.log(\"sent to server\")\r\n\r\n            } else {\r\n\r\n                if(fromClient) {\r\n\r\n                    const packetData: IPacketData_ComponentEvent = {\r\n                        entity: component.entity.id,\r\n                        component: this.game.entityFactory.getIndexOfComponent(component),\r\n                        event: event,\r\n                        data: data\r\n                    }\r\n                    \r\n                    fromClient.sendPacket(PacketType.COMPONENT_EVENT, packetData);\r\n                }\r\n\r\n                component.onReceiveComponentEvent.apply(component, [event, data, fromClient]);\r\n            }\r\n        })\r\n    }\r\n\r\n    public init() {\r\n        console.log(`[world] init`);\r\n\r\n        try {\r\n            window['world'] = this;\r\n        } catch(e) {\r\n\r\n        }\r\n\r\n        this.initMatterWorld();\r\n\r\n        /*\r\n        var bb = new ByteBuffer();\r\n        bb.writeString(\"ayo\");\r\n        bb.flip();\r\n\r\n        console.log(bb.toBuffer())\r\n\r\n        console.log(bb.readString(2)+\" from ByteBuffer.js\");\r\n        */\r\n    }\r\n\r\n    public tick(dt: number) {\r\n        this.preupdate(dt)\r\n\r\n        //console.log(\"u..\")\r\n        Matter.Engine.update(this.matter.engine!, 16.666666666666668, this.game.fixTime);\r\n        //console.log(\"finish\")\r\n\r\n           //console.log(\"dt:\", dt * 1000, \"or\", this.matter.engine!.timing.lastDelta, \"coor\",(dt * 1000)/32)\r\n        //console.log( dt * 1000, this.game.fixTime)\r\n\r\n        this.update(dt);\r\n\r\n        this.postupdate(dt);\r\n    }\r\n\r\n    private testAttach(dt: number) {\r\n        \r\n    }\r\n\r\n\r\n    public preupdate(dt: number) {\r\n        //  this.testAttach(dt);\r\n\r\n        for(const entity of this.entities) {\r\n          entity.preupdate(dt)\r\n        }\r\n    }\r\n\r\n\r\n    public update(dt: number) {\r\n        testu++;\r\n        testd = this.matter.engine!.timing.lastDelta;\r\n\r\n        this.testAttach(dt);\r\n\r\n        for(const entity of this.entities) {\r\n          entity.update(dt)\r\n        }\r\n    }\r\n\r\n    public postupdate(dt: number) {\r\n        //this.testAttach(dt);\r\n        for(const entity of this.entities) {\r\n          entity.postupdate(dt)\r\n        }\r\n    }\r\n\r\n    private initMatterWorld() {\r\n        const engine = this.matter.engine = Matter.Engine.create();\r\n        engine.gravity.x = 0;\r\n        engine.gravity.y = 0;\r\n\r\n        const world = this.matter.world = engine.world;\r\n        \r\n        /*\r\n        const runner = this.matter.runner = Matter.Runner.create();\r\n        \r\n        Matter.Runner.run(runner, engine);\r\n        \r\n        Matter.Events.on(runner, \"beforeUpdate\", () => {\r\n            this.preupdate(engine.timing.lastDelta * 0.001);\r\n        })\r\n\r\n        Matter.Events.on(runner, \"afterUpdate\", () => {\r\n            this.update(engine.timing.lastDelta * 0.001);\r\n            this.postupdate(engine.timing.lastDelta * 0.001);\r\n        })\r\n        */\r\n       \r\n        setInterval(() => {\r\n            console.log(`${testu} updates, dt=${testd}, ${this.entities.length} entities (interv ${this.game.updateInterval}) (fixd ${this.game.fixTime})`);\r\n            testu = 0;\r\n        }, 1000)\r\n    }\r\n\r\n    private spawnEntities() {\r\n        \r\n        for (let i = 0; i < 10; i++) {\r\n            this.spawnObject()\r\n        }\r\n\r\n        for (let i = 0; i < 40; i++) {\r\n            this.spawnNpc(Math.random()*100-50, Math.random()*100-50)\r\n        }\r\n\r\n    }\r\n\r\n    public spawnObject() {\r\n        const npc = this.spawnEntity(EntityObject);\r\n    \r\n    }\r\n\r\n    public spawnPlayer() {\r\n        const player = this.spawnEntity(EntityPlayer);\r\n    }\r\n\r\n    public spawnNpc(x: number, y: number) {\r\n        let px = x != undefined ? x : 0;\r\n        let py = y != undefined ? y : 0;\r\n\r\n        const npc = this.spawnEntity(EntityChar);\r\n        npc.transform.setPosition(px, py)\r\n        npc.addComponent(new NPCBehaviourComponent());\r\n\r\n        //npc.transform.data.velX = 10;\r\n\r\n        setInterval(() => {\r\n\r\n            /*\r\n            if(npc.transform.data.velX < 3) {\r\n                npc.transform.setPosition(0, 0)\r\n                npc.transform.data.velX = 10;\r\n            }\r\n            */\r\n\r\n        }, 100)\r\n\r\n        //npc.addComponent(new NPCBehaviourComponent());\r\n        return npc;\r\n    }\r\n\r\n    public generateWorld() {\r\n        console.log(`[world] generate world`);\r\n\r\n        this.spawnEntities();\r\n    }\r\n\r\n    \r\n    \r\n    public spawnEntity(c: typeof Entity) {\r\n        const entity = new c(this);\r\n\r\n        return this.addEntity(entity);\r\n    }\r\n\r\n    public addEntity(entity: Entity) {\r\n        //console.log(`[world] add entity ${entity.constructor.name}`);\r\n        \r\n        this._entities.push(entity);\r\n        entity.init();\r\n        return entity;\r\n    }\r\n\r\n    public getEntity(id: string) {\r\n        for (const entity of this.entities) {\r\n            if(entity.id == id) return entity;\r\n        }\r\n    }\r\n}","export enum WorldEvent {\r\n    COMPONENT_EVENT = \"COMPONENT_EVENT\"\r\n}","export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as NIL } from './nil.js';\nexport { default as version } from './version.js';\nexport { default as validate } from './validate.js';\nexport { default as stringify } from './stringify.js';\nexport { default as parse } from './parse.js';","/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;","export default '00000000-0000-0000-0000-000000000000';","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify(b);\n}\n\nexport default v1;","import v35 from './v35.js';\nimport md5 from './md5.js';\nvar v3 = v35('v3', 0x30, md5);\nexport default v3;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n\nfunction version(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nexport default version;","'use strict';\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n  , length = 64\n  , map = {}\n  , seed = 0\n  , i = 0\n  , prev;\n\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n  var now = encode(+new Date());\n\n  if (now !== prev) return seed = 0, prev = now;\n  return now +'.'+ encode(seed++);\n}\n\n//\n// Map each character to its index.\n//\nfor (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\nyeast.encode = encode;\nyeast.decode = decode;\nmodule.exports = yeast;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.installTimerFunctions = exports.transports = exports.Transport = exports.protocol = exports.Socket = void 0;\nconst socket_js_1 = require(\"./socket.js\");\nObject.defineProperty(exports, \"Socket\", { enumerable: true, get: function () { return socket_js_1.Socket; } });\nexports.protocol = socket_js_1.Socket.protocol;\nvar transport_js_1 = require(\"./transport.js\");\nObject.defineProperty(exports, \"Transport\", { enumerable: true, get: function () { return transport_js_1.Transport; } });\nvar index_js_1 = require(\"./transports/index.js\");\nObject.defineProperty(exports, \"transports\", { enumerable: true, get: function () { return index_js_1.transports; } });\nvar util_js_1 = require(\"./util.js\");\nObject.defineProperty(exports, \"installTimerFunctions\", { enumerable: true, get: function () { return util_js_1.installTimerFunctions; } });\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst index_js_1 = require(\"./transports/index.js\");\nconst util_js_1 = require(\"./util.js\");\nconst parseqs_1 = __importDefault(require(\"parseqs\"));\nconst parseuri_1 = __importDefault(require(\"parseuri\"));\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine.io-client:socket\"); // debug()\nclass Socket extends component_emitter_1.Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri or options\n     * @param {Object} opts - options\n     * @api public\n     */\n    constructor(uri, opts = {}) {\n        super();\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = (0, parseuri_1.default)(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = (0, parseuri_1.default)(opts.host).host;\n        }\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\"polling\", \"websocket\"];\n        this.readyState = \"\";\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024\n            },\n            transportOptions: {},\n            closeOnBeforeunload: true\n        }, opts);\n        this.opts.path = this.opts.path.replace(/\\/$/, \"\") + \"/\";\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = parseqs_1.default.decode(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                addEventListener(\"beforeunload\", () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                }, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\");\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} transport name\n     * @return {Transport}\n     * @api private\n     */\n    createTransport(name) {\n        debug('creating transport \"%s\"', name);\n        const query = clone(this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = engine_io_parser_1.protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port\n        });\n        debug(\"options: %j\", opts);\n        return new index_js_1.transports[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @api private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            debug(\"error while creating transport: %s\", e);\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @api private\n     */\n    setTransport(transport) {\n        debug(\"setting transport %s\", transport.name);\n        if (this.transport) {\n            debug(\"clearing existing transport %s\", this.transport.name);\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", () => {\n            this.onClose(\"transport close\");\n        });\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} transport name\n     * @api private\n     */\n    probe(name) {\n        debug('probing transport \"%s\"', name);\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            debug('probe transport \"%s\" opened', name);\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", msg => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    debug('probe transport \"%s\" pong', name);\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    debug('pausing current transport \"%s\"', this.transport.name);\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        debug(\"changing transport and sending upgrade packet\");\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    debug('probe transport \"%s\" failed', name);\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = err => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            debug('probe transport \"%s\" failed because of error: %s', name, err);\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        transport.open();\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @api private\n     */\n    onOpen() {\n        debug(\"socket open\");\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState &&\n            this.opts.upgrade &&\n            this.transport.pause) {\n            debug(\"starting upgrade probes\");\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @api private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n            debug('packet received with socket readyState \"%s\"', this.readyState);\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @api private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @api private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @api private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @api private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            debug(\"flushing %d packets in socket\", this.writeBuffer.length);\n            this.transport.send(this.writeBuffer);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = this.writeBuffer.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} message.\n     * @param {Function} callback function.\n     * @param {Object} options.\n     * @return {Socket} for chaining.\n     * @api public\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @api private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     *\n     * @api public\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            debug(\"socket closing - telling transport to close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @api private\n     */\n    onError(err) {\n        debug(\"socket error %j\", err);\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @api private\n     */\n    onClose(reason, desc) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            debug('socket close with reason: \"%s\"', reason);\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, desc);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} server upgrades\n     * @api private\n     *\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nexports.Socket = Socket;\nSocket.protocol = engine_io_parser_1.protocol;\nfunction clone(obj) {\n    const o = {};\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            o[i] = obj[i];\n        }\n    }\n    return o;\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transport = void 0;\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst util_js_1 = require(\"./util.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = (0, debug_1.default)(\"engine.io-client:transport\"); // debug()\nclass Transport extends component_emitter_1.Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} options.\n     * @api private\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.readyState = \"\";\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} str\n     * @return {Transport} for chaining\n     * @api protected\n     */\n    onError(msg, desc) {\n        const err = new Error(msg);\n        // @ts-ignore\n        err.type = \"TransportError\";\n        // @ts-ignore\n        err.description = desc;\n        super.emit(\"error\", err);\n        return this;\n    }\n    /**\n     * Opens the transport.\n     *\n     * @api public\n     */\n    open() {\n        if (\"closed\" === this.readyState || \"\" === this.readyState) {\n            this.readyState = \"opening\";\n            this.doOpen();\n        }\n        return this;\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api public\n     */\n    close() {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     * @api public\n     */\n    send(packets) {\n        if (\"open\" === this.readyState) {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n            debug(\"transport is not open, discarding packets\");\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @api protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emit(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @api protected\n     */\n    onData(data) {\n        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @api protected\n     */\n    onPacket(packet) {\n        super.emit(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @api protected\n     */\n    onClose() {\n        this.readyState = \"closed\";\n        super.emit(\"close\");\n    }\n}\nexports.Transport = Transport;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transports = void 0;\nconst polling_xhr_js_1 = require(\"./polling-xhr.js\");\nconst websocket_js_1 = require(\"./websocket.js\");\nexports.transports = {\n    websocket: websocket_js_1.WS,\n    polling: polling_xhr_js_1.XHR\n};\n","\"use strict\";\n/* global attachEvent */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Request = exports.XHR = void 0;\nconst xmlhttprequest_js_1 = __importDefault(require(\"./xmlhttprequest.js\"));\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst globalThis_js_1 = __importDefault(require(\"../globalThis.js\"));\nconst util_js_1 = require(\"../util.js\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst polling_js_1 = require(\"./polling.js\");\nconst debug = (0, debug_1.default)(\"engine.io-client:polling-xhr\"); // debug()\n/**\n * Empty function\n */\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new xmlhttprequest_js_1.default({\n        xdomain: false\n    });\n    return null != xhr.responseType;\n})();\nclass XHR extends polling_js_1.Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @api public\n     */\n    constructor(opts) {\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n            this.xs = opts.secure !== isSSL;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @api private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @api private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", err => {\n            this.onError(\"xhr post error\", err);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @api private\n     */\n    doPoll() {\n        debug(\"xhr poll\");\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", err => {\n            this.onError(\"xhr poll error\", err);\n        });\n        this.pollXhr = req;\n    }\n}\nexports.XHR = XHR;\nclass Request extends component_emitter_1.Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @api public\n     */\n    constructor(uri, opts) {\n        super();\n        (0, util_js_1.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.async = false !== opts.async;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @api private\n     */\n    create() {\n        const opts = (0, util_js_1.pick)(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        opts.xscheme = !!this.opts.xs;\n        const xhr = (this.xhr = new xmlhttprequest_js_1.default(opts));\n        try {\n            debug(\"xhr open %s: %s\", this.method, this.uri);\n            xhr.open(this.method, this.uri, this.async);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            debug(\"xhr data %s\", this.data);\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon successful response.\n     *\n     * @api private\n     */\n    onSuccess() {\n        this.emit(\"success\");\n        this.cleanup();\n    }\n    /**\n     * Called if we have data.\n     *\n     * @api private\n     */\n    onData(data) {\n        this.emit(\"data\", data);\n        this.onSuccess();\n    }\n    /**\n     * Called upon error.\n     *\n     * @api private\n     */\n    onError(err) {\n        this.emit(\"error\", err);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @api private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @api private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.onData(data);\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @api public\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nexports.Request = Request;\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis_js_1.default ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polling = void 0;\nconst transport_js_1 = require(\"../transport.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst yeast_1 = __importDefault(require(\"yeast\"));\nconst parseqs_1 = __importDefault(require(\"parseqs\"));\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine.io-client:polling\"); // debug()\nclass Polling extends transport_js_1.Transport {\n    constructor() {\n        super(...arguments);\n        this.polling = false;\n    }\n    /**\n     * Transport name.\n     */\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @api private\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} callback upon buffers are flushed and transport is paused\n     * @api private\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            debug(\"paused\");\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                debug(\"we are currently polling - waiting to pause\");\n                total++;\n                this.once(\"pollComplete\", function () {\n                    debug(\"pre-pause polling complete\");\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                debug(\"we are currently writing - waiting to pause\");\n                total++;\n                this.once(\"drain\", function () {\n                    debug(\"pre-pause writing complete\");\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @api public\n     */\n    poll() {\n        debug(\"polling\");\n        this.polling = true;\n        this.doPoll();\n        this.emit(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @api private\n     */\n    onData(data) {\n        debug(\"polling got data %s\", data);\n        const callback = packet => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose();\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emit(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n            else {\n                debug('ignoring poll - transport state \"%s\"', this.readyState);\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @api private\n     */\n    doClose() {\n        const close = () => {\n            debug(\"writing close packet\");\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            debug(\"transport open - closing\");\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            debug(\"transport not open - deferring close\");\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} data packets\n     * @param {Function} drain callback\n     * @api private\n     */\n    write(packets) {\n        this.writable = false;\n        (0, engine_io_parser_1.encodePayload)(packets, data => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emit(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @api private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        let port = \"\";\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0, yeast_1.default)();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                (\"http\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        const encodedQuery = parseqs_1.default.encode(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n}\nexports.Polling = Polling;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultBinaryType = exports.usingBrowserWebSocket = exports.WebSocket = exports.nextTick = void 0;\nconst globalThis_js_1 = __importDefault(require(\"../globalThis.js\"));\nexports.nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return cb => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nexports.WebSocket = globalThis_js_1.default.WebSocket || globalThis_js_1.default.MozWebSocket;\nexports.usingBrowserWebSocket = true;\nexports.defaultBinaryType = \"arraybuffer\";\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WS = void 0;\nconst transport_js_1 = require(\"../transport.js\");\nconst parseqs_1 = __importDefault(require(\"parseqs\"));\nconst yeast_1 = __importDefault(require(\"yeast\"));\nconst util_js_1 = require(\"../util.js\");\nconst websocket_constructor_js_1 = require(\"./websocket-constructor.js\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine.io-client:websocket\"); // debug()\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends transport_js_1.Transport {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @api {Object} connection options\n     * @api public\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Transport name.\n     *\n     * @api public\n     */\n    get name() {\n        return \"websocket\";\n    }\n    /**\n     * Opens socket.\n     *\n     * @api private\n     */\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : (0, util_js_1.pick)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative\n                    ? protocols\n                        ? new websocket_constructor_js_1.WebSocket(uri, protocols)\n                        : new websocket_constructor_js_1.WebSocket(uri)\n                    : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emit(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType || websocket_constructor_js_1.defaultBinaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @api private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = this.onClose.bind(this);\n        this.ws.onmessage = ev => this.onData(ev.data);\n        this.ws.onerror = e => this.onError(\"websocket error\", e);\n    }\n    /**\n     * Writes data to socket.\n     *\n     * @param {Array} array of packets.\n     * @api private\n     */\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, data => {\n                // always create a new object (GH-437)\n                const opts = {};\n                if (!websocket_constructor_js_1.usingBrowserWebSocket) {\n                    if (packet.options) {\n                        opts.compress = packet.options.compress;\n                    }\n                    if (this.opts.perMessageDeflate) {\n                        const len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                            opts.compress = false;\n                        }\n                    }\n                }\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (websocket_constructor_js_1.usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                    else {\n                        this.ws.send(data, opts);\n                    }\n                }\n                catch (e) {\n                    debug(\"websocket closed before onclose event\");\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    (0, websocket_constructor_js_1.nextTick)(() => {\n                        this.writable = true;\n                        this.emit(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    /**\n     * Closes socket.\n     *\n     * @api private\n     */\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @api private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        let port = \"\";\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0, yeast_1.default)();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        const encodedQuery = parseqs_1.default.encode(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @api public\n     */\n    check() {\n        return (!!websocket_constructor_js_1.WebSocket &&\n            !(\"__initialize\" in websocket_constructor_js_1.WebSocket && this.name === WS.prototype.name));\n    }\n}\nexports.WS = WS;\n","\"use strict\";\n// browser shim for xmlhttprequest module\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst has_cors_1 = __importDefault(require(\"has-cors\"));\nconst globalThis_js_1 = __importDefault(require(\"../globalThis.js\"));\nfunction default_1(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || has_cors_1.default)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis_js_1.default[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\nexports.default = default_1;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.installTimerFunctions = exports.pick = void 0;\nconst globalThis_js_1 = __importDefault(require(\"./globalThis.js\"));\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\nexports.pick = pick;\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.default);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.default);\n    }\n    else {\n        obj.setTimeoutFn = setTimeout.bind(globalThis_js_1.default);\n        obj.clearTimeoutFn = clearTimeout.bind(globalThis_js_1.default);\n    }\n}\nexports.installTimerFunctions = installTimerFunctions;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\nexports.PACKET_TYPES = PACKET_TYPES;\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nexports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;\nObject.keys(PACKET_TYPES).forEach(key => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\nexports.ERROR_PACKET = ERROR_PACKET;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commons_js_1 = require(\"./commons.js\");\nconst base64_arraybuffer_1 = require(\"base64-arraybuffer\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return commons_js_1.ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: commons_js_1.PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: commons_js_1.PACKET_TYPES_REVERSE[type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = (0, base64_arraybuffer_1.decode)(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            return data instanceof ArrayBuffer ? new Blob([data]) : data;\n        case \"arraybuffer\":\n        default:\n            return data; // assuming the data is already an ArrayBuffer\n    }\n};\nexports.default = decodePacket;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commons_js_1 = require(\"./commons.js\");\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = obj => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(commons_js_1.PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + content);\n    };\n    return fileReader.readAsDataURL(data);\n};\nexports.default = encodePacket;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;\nconst encodePacket_js_1 = require(\"./encodePacket.js\");\nexports.encodePacket = encodePacket_js_1.default;\nconst decodePacket_js_1 = require(\"./decodePacket.js\");\nexports.decodePacket = decodePacket_js_1.default;\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        (0, encodePacket_js_1.default)(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nexports.encodePayload = encodePayload;\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = (0, decodePacket_js_1.default)(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nexports.decodePayload = decodePayload;\nexports.protocol = 4;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports.connect = exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;\nconst url_js_1 = require(\"./url.js\");\nconst manager_js_1 = require(\"./manager.js\");\nObject.defineProperty(exports, \"Manager\", { enumerable: true, get: function () { return manager_js_1.Manager; } });\nconst socket_js_1 = require(\"./socket.js\");\nObject.defineProperty(exports, \"Socket\", { enumerable: true, get: function () { return socket_js_1.Socket; } });\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client\"); // debug()\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url_js_1.url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        debug(\"ignoring socket cache for %s\", source);\n        io = new manager_js_1.Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            debug(\"new io instance for %s\", source);\n            cache[id] = new manager_js_1.Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\nexports.io = lookup;\nexports.connect = lookup;\nexports.default = lookup;\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager: manager_js_1.Manager,\n    Socket: socket_js_1.Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nvar socket_io_parser_1 = require(\"socket.io-parser\");\nObject.defineProperty(exports, \"protocol\", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });\n\nmodule.exports = lookup;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Manager = void 0;\nconst engine_io_client_1 = require(\"engine.io-client\");\nconst socket_js_1 = require(\"./socket.js\");\nconst parser = __importStar(require(\"socket.io-parser\"));\nconst on_js_1 = require(\"./on.js\");\nconst backo2_1 = __importDefault(require(\"backo2\"));\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:manager\"); // debug()\nclass Manager extends component_emitter_1.Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        engine_io_client_1.installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new backo2_1.default({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        debug(\"readyState %s\", this._readyState);\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        debug(\"opening %s\", this.uri);\n        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on_js_1.on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = on_js_1.on(socket, \"error\", (err) => {\n            debug(\"error\");\n            self.cleanup();\n            self._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            debug(\"connect attempt will timeout after %d\", timeout);\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                debug(\"connect attempt timed out after %d\", timeout);\n                openSubDestroy();\n                socket.close();\n                // @ts-ignore\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"open\");\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on_js_1.on(socket, \"ping\", this.onping.bind(this)), on_js_1.on(socket, \"data\", this.ondata.bind(this)), on_js_1.on(socket, \"error\", this.onerror.bind(this)), on_js_1.on(socket, \"close\", this.onclose.bind(this)), on_js_1.on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        this.decoder.add(data);\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        this.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        debug(\"error\", err);\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new socket_js_1.Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                debug(\"socket %s is still active, skipping close\", nsp);\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        debug(\"writing packet %j\", packet);\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        debug(\"cleanup\");\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        debug(\"disconnect\");\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        if (\"opening\" === this._readyState) {\n            // `onclose` will not fire because\n            // an open event never happened\n            this.cleanup();\n        }\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason) {\n        debug(\"onclose\");\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            debug(\"reconnect failed\");\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            debug(\"will wait %dms before reconnect attempt\", delay);\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                debug(\"attempting reconnect\");\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        debug(\"reconnect attempt error\");\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        debug(\"reconnect success\");\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\nexports.Manager = Manager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.on = void 0;\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\nexports.on = on;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst on_js_1 = require(\"./on.js\");\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:socket\"); // debug()\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\nclass Socket extends component_emitter_1.Emitter {\n    /**\n     * `Socket` constructor.\n     *\n     * @public\n     */\n    constructor(io, nsp, opts) {\n        super();\n        this.connected = false;\n        this.disconnected = true;\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on_js_1.on(io, \"open\", this.onopen.bind(this)),\n            on_js_1.on(io, \"packet\", this.onpacket.bind(this)),\n            on_js_1.on(io, \"error\", this.onerror.bind(this)),\n            on_js_1.on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @public\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for connect()\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * @return self\n     * @public\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @return self\n     * @public\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            debug(\"emitting packet with ack id %d\", this.ids);\n            this.acks[this.ids] = args.pop();\n            packet.id = this.ids++;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n            debug(\"discard packet as the transport is not currently writable\");\n        }\n        else if (this.connected) {\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"transport is open - connecting\");\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });\n            });\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });\n        }\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @private\n     */\n    onclose(reason) {\n        debug(\"close (%s)\", reason);\n        this.connected = false;\n        this.disconnected = true;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    const id = packet.data.sid;\n                    this.onconnect(id);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser_1.PacketType.CONNECT_ERROR:\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            debug(\"sending ack %j\", args);\n            self.packet({\n                type: socket_io_parser_1.PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id) {\n        debug(\"socket connected with id %s\", id);\n        this.id = id;\n        this.connected = true;\n        this.disconnected = false;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => this.packet(packet));\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"server disconnect (%s)\", this.nsp);\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually.\n     *\n     * @return self\n     * @public\n     */\n    disconnect() {\n        if (this.connected) {\n            debug(\"performing disconnect (%s)\", this.nsp);\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for disconnect()\n     *\n     * @return self\n     * @public\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     * @public\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @returns self\n     * @public\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @param listener\n     * @public\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     * @public\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @param listener\n     * @public\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     *\n     * @public\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n}\nexports.Socket = Socket;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.url = void 0;\nconst parseuri_1 = __importDefault(require(\"parseuri\"));\nconst debug_1 = __importDefault(require(\"debug\")); // debug()\nconst debug = debug_1.default(\"socket.io-client:url\"); // debug()\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            debug(\"protocol-less url %s\", uri);\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        debug(\"parse %s\", uri);\n        obj = parseuri_1.default(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\nexports.url = url;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reconstructPacket = exports.deconstructPacket = void 0;\nconst is_binary_js_1 = require(\"./is-binary.js\");\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nexports.deconstructPacket = deconstructPacket;\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (is_binary_js_1.isBinary(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    packet.attachments = undefined; // no longer useful\n    return packet;\n}\nexports.reconstructPacket = reconstructPacket;\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder) {\n        return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;\nconst component_emitter_1 = require(\"@socket.io/component-emitter\");\nconst binary_js_1 = require(\"./binary.js\");\nconst is_binary_js_1 = require(\"./is-binary.js\");\nconst debug_1 = require(\"debug\"); // debug()\nconst debug = debug_1.default(\"socket.io-parser\"); // debug()\n/**\n * Protocol version.\n *\n * @public\n */\nexports.protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType = exports.PacketType || (exports.PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        debug(\"encoding packet %j\", obj);\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (is_binary_js_1.hasBinary(obj)) {\n                obj.type =\n                    obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK;\n                return this.encodeAsBinary(obj);\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data);\n        }\n        debug(\"encoded %j as %s\", obj, str);\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = binary_js_1.deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\nexports.Encoder = Encoder;\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends component_emitter_1.Emitter {\n    constructor() {\n        super();\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            packet = this.decodeString(obj);\n            if (packet.type === PacketType.BINARY_EVENT ||\n                packet.type === PacketType.BINARY_ACK) {\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (is_binary_js_1.isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        debug(\"decoded %s as %j\", str, p);\n        return p;\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return typeof payload === \"object\";\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || typeof payload === \"object\";\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return Array.isArray(payload) && payload.length > 0;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n        }\n    }\n}\nexports.Decoder = Decoder;\nfunction tryParse(str) {\n    try {\n        return JSON.parse(str);\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = binary_js_1.reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasBinary = exports.isBinary = void 0;\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nexports.isBinary = isBinary;\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.hasBinary = hasBinary;\n","/**\n * @license\n * PlayCanvas Engine v1.52.1 revision 0f56653b1\n * Copyright 2011-2022 PlayCanvas Ltd. All rights reserved.\n */\nif (!Array.prototype.fill) {\n\tObject.defineProperty(Array.prototype, 'fill', {\n\t\tvalue: function (value) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow new TypeError('this is null or not defined');\n\t\t\t}\n\n\t\t\tvar O = Object(this);\n\t\t\tvar len = O.length >>> 0;\n\t\t\tvar start = arguments[1];\n\t\t\tvar relativeStart = start >> 0;\n\t\t\tvar k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\t\t\tvar end = arguments[2];\n\t\t\tvar relativeEnd = end === undefined ? len : end >> 0;\n\t\t\tvar finalValue = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n\t\t\twhile (k < finalValue) {\n\t\t\t\tO[k] = value;\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\treturn O;\n\t\t}\n\t});\n}\n\nif (!Array.prototype.find) {\n\tObject.defineProperty(Array.prototype, 'find', {\n\t\tvalue: function (predicate) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError('\"this\" is null or not defined');\n\t\t\t}\n\n\t\t\tvar o = Object(this);\n\t\t\tvar len = o.length >>> 0;\n\n\t\t\tif (typeof predicate !== 'function') {\n\t\t\t\tthrow TypeError('predicate must be a function');\n\t\t\t}\n\n\t\t\tvar thisArg = arguments[1];\n\t\t\tvar k = 0;\n\n\t\t\twhile (k < len) {\n\t\t\t\tvar kValue = o[k];\n\n\t\t\t\tif (predicate.call(thisArg, kValue, k, o)) {\n\t\t\t\t\treturn kValue;\n\t\t\t\t}\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t},\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n}\n\nif (!Array.prototype.findIndex) {\n\tObject.defineProperty(Array.prototype, 'findIndex', {\n\t\tvalue: function (predicate) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow new TypeError('\"this\" is null or not defined');\n\t\t\t}\n\n\t\t\tvar o = Object(this);\n\t\t\tvar len = o.length >>> 0;\n\n\t\t\tif (typeof predicate !== 'function') {\n\t\t\t\tthrow new TypeError('predicate must be a function');\n\t\t\t}\n\n\t\t\tvar thisArg = arguments[1];\n\t\t\tvar k = 0;\n\n\t\t\twhile (k < len) {\n\t\t\t\tvar kValue = o[k];\n\n\t\t\t\tif (predicate.call(thisArg, kValue, k, o)) {\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t},\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n}\n\nMath.log2 = Math.log2 || function (x) {\n\treturn Math.log(x) * Math.LOG2E;\n};\n\nif (!Math.sign) {\n\tMath.sign = function (x) {\n\t\treturn (x > 0) - (x < 0) || +x;\n\t};\n}\n\nif (Number.isFinite === undefined) Number.isFinite = function (value) {\n\treturn typeof value === 'number' && isFinite(value);\n};\n\nif (typeof Object.assign != 'function') {\n\tObject.defineProperty(Object, \"assign\", {\n\t\tvalue: function assign(target, varArgs) {\n\n\t\t\tif (target == null) {\n\t\t\t\tthrow new TypeError('Cannot convert undefined or null to object');\n\t\t\t}\n\n\t\t\tvar to = Object(target);\n\n\t\t\tfor (var index = 1; index < arguments.length; index++) {\n\t\t\t\tvar nextSource = arguments[index];\n\n\t\t\t\tif (nextSource != null) {\n\t\t\t\t\tfor (var nextKey in nextSource) {\n\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t\t\t\t\t\t\tto[nextKey] = nextSource[nextKey];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn to;\n\t\t},\n\t\twritable: true,\n\t\tconfigurable: true\n\t});\n}\n\n(function () {\n\tif (typeof navigator === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\tnavigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;\n\n\tvar pointerlockchange = function pointerlockchange() {\n\t\tvar e = document.createEvent('CustomEvent');\n\t\te.initCustomEvent('pointerlockchange', true, false, null);\n\t\tdocument.dispatchEvent(e);\n\t};\n\n\tvar pointerlockerror = function pointerlockerror() {\n\t\tvar e = document.createEvent('CustomEvent');\n\t\te.initCustomEvent('pointerlockerror', true, false, null);\n\t\tdocument.dispatchEvent(e);\n\t};\n\n\tdocument.addEventListener('webkitpointerlockchange', pointerlockchange, false);\n\tdocument.addEventListener('webkitpointerlocklost', pointerlockchange, false);\n\tdocument.addEventListener('mozpointerlockchange', pointerlockchange, false);\n\tdocument.addEventListener('mozpointerlocklost', pointerlockchange, false);\n\tdocument.addEventListener('webkitpointerlockerror', pointerlockerror, false);\n\tdocument.addEventListener('mozpointerlockerror', pointerlockerror, false);\n\n\tif (Element.prototype.mozRequestPointerLock) {\n\t\tElement.prototype.requestPointerLock = function () {\n\t\t\tthis.mozRequestPointerLock();\n\t\t};\n\t} else {\n\t\tElement.prototype.requestPointerLock = Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;\n\t}\n\n\tif (!Element.prototype.requestPointerLock && navigator.pointer) {\n\t\tElement.prototype.requestPointerLock = function () {\n\t\t\tvar el = this;\n\t\t\tdocument.pointerLockElement = el;\n\t\t\tnavigator.pointer.lock(el, pointerlockchange, pointerlockerror);\n\t\t};\n\t}\n\n\tdocument.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;\n\n\tif (!document.exitPointerLock) {\n\t\tdocument.exitPointerLock = function () {\n\t\t\tif (navigator.pointer) {\n\t\t\t\tdocument.pointerLockElement = null;\n\t\t\t\tnavigator.pointer.unlock();\n\t\t\t}\n\t\t};\n\t}\n})();\n\n(function () {\n\tif (typeof window === 'undefined') return;\n\tvar lastTime = 0;\n\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\n\tfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n\t\twindow.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n\t\twindow.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n\t}\n\n\tif (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n\t\tvar currTime = new Date().getTime();\n\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\tvar id = window.setTimeout(function () {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\t\tlastTime = currTime + timeToCall;\n\t\treturn id;\n\t};\n\tif (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n\t\tclearTimeout(id);\n\t};\n})();\n\nif (!String.prototype.endsWith) {\n\tString.prototype.endsWith = function (search, this_len) {\n\t\tif (this_len === undefined || this_len > this.length) {\n\t\t\tthis_len = this.length;\n\t\t}\n\n\t\treturn this.substring(this_len - search.length, this_len) === search;\n\t};\n}\n\nif (!String.prototype.includes) {\n\tString.prototype.includes = function (search, start) {\n\n\t\tif (typeof start !== 'number') {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif (start + search.length > this.length) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn this.indexOf(search, start) !== -1;\n\t\t}\n\t};\n}\n\nif (!String.prototype.startsWith) {\n\tString.prototype.startsWith = function (search, pos) {\n\t\treturn this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n\t};\n}\n\nif (!Int8Array.prototype.fill) {\n\tInt8Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Uint8Array.prototype.fill) {\n\tUint8Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Uint8ClampedArray.prototype.fill) {\n\tUint8ClampedArray.prototype.fill = Array.prototype.fill;\n}\n\nif (!Int16Array.prototype.fill) {\n\tInt16Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Uint16Array.prototype.fill) {\n\tUint16Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Int32Array.prototype.fill) {\n\tInt32Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Uint32Array.prototype.fill) {\n\tUint32Array.prototype.fill = Array.prototype.fill;\n}\n\nif (!Float32Array.prototype.fill) {\n\tFloat32Array.prototype.fill = Array.prototype.fill;\n}\n\nvar glErrorShadow = {};\n\nfunction error(msg) {\n\tif (window.console && window.console.error) {\n\t\twindow.console.error(msg);\n\t}\n}\n\nfunction log$1(msg) {\n\tif (window.console && window.console.log) {\n\t\twindow.console.log(msg);\n\t}\n}\n\nfunction synthesizeGLError(err, opt_msg) {\n\tglErrorShadow[err] = true;\n\n\tif (opt_msg !== undefined) {\n\t\terror(opt_msg);\n\t}\n}\n\nfunction wrapGLError(gl) {\n\tvar f = gl.getError;\n\n\tgl.getError = function () {\n\t\tvar err;\n\n\t\tdo {\n\t\t\terr = f.apply(gl);\n\n\t\t\tif (err != gl.NO_ERROR) {\n\t\t\t\tglErrorShadow[err] = true;\n\t\t\t}\n\t\t} while (err != gl.NO_ERROR);\n\n\t\tfor (var err in glErrorShadow) {\n\t\t\tif (glErrorShadow[err]) {\n\t\t\t\tdelete glErrorShadow[err];\n\t\t\t\treturn parseInt(err);\n\t\t\t}\n\t\t}\n\n\t\treturn gl.NO_ERROR;\n\t};\n}\n\nvar WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {\n\tvar gl = ext.gl;\n\tthis.ext = ext;\n\tthis.isAlive = true;\n\tthis.hasBeenBound = false;\n\tthis.elementArrayBuffer = null;\n\tthis.attribs = new Array(ext.maxVertexAttribs);\n\n\tfor (var n = 0; n < this.attribs.length; n++) {\n\t\tvar attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);\n\t\tthis.attribs[n] = attrib;\n\t}\n\n\tthis.maxAttrib = 0;\n};\n\nWebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {\n\tthis.enabled = false;\n\tthis.buffer = null;\n\tthis.size = 4;\n\tthis.type = gl.FLOAT;\n\tthis.normalized = false;\n\tthis.stride = 16;\n\tthis.offset = 0;\n\tthis.cached = \"\";\n\tthis.recache();\n};\n\nWebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {\n\tthis.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(\":\");\n};\n\nvar OESVertexArrayObject = function OESVertexArrayObject(gl) {\n\tvar self = this;\n\tthis.gl = gl;\n\twrapGLError(gl);\n\tvar original = this.original = {\n\t\tgetParameter: gl.getParameter,\n\t\tenableVertexAttribArray: gl.enableVertexAttribArray,\n\t\tdisableVertexAttribArray: gl.disableVertexAttribArray,\n\t\tbindBuffer: gl.bindBuffer,\n\t\tgetVertexAttrib: gl.getVertexAttrib,\n\t\tvertexAttribPointer: gl.vertexAttribPointer\n\t};\n\n\tgl.getParameter = function getParameter(pname) {\n\t\tif (pname == self.VERTEX_ARRAY_BINDING_OES) {\n\t\t\tif (self.currentVertexArrayObject == self.defaultVertexArrayObject) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn self.currentVertexArrayObject;\n\t\t\t}\n\t\t}\n\n\t\treturn original.getParameter.apply(this, arguments);\n\t};\n\n\tgl.enableVertexAttribArray = function enableVertexAttribArray(index) {\n\t\tvar vao = self.currentVertexArrayObject;\n\t\tvao.maxAttrib = Math.max(vao.maxAttrib, index);\n\t\tvar attrib = vao.attribs[index];\n\t\tattrib.enabled = true;\n\t\treturn original.enableVertexAttribArray.apply(this, arguments);\n\t};\n\n\tgl.disableVertexAttribArray = function disableVertexAttribArray(index) {\n\t\tvar vao = self.currentVertexArrayObject;\n\t\tvao.maxAttrib = Math.max(vao.maxAttrib, index);\n\t\tvar attrib = vao.attribs[index];\n\t\tattrib.enabled = false;\n\t\treturn original.disableVertexAttribArray.apply(this, arguments);\n\t};\n\n\tgl.bindBuffer = function bindBuffer(target, buffer) {\n\t\tswitch (target) {\n\t\t\tcase gl.ARRAY_BUFFER:\n\t\t\t\tself.currentArrayBuffer = buffer;\n\t\t\t\tbreak;\n\n\t\t\tcase gl.ELEMENT_ARRAY_BUFFER:\n\t\t\t\tself.currentVertexArrayObject.elementArrayBuffer = buffer;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn original.bindBuffer.apply(this, arguments);\n\t};\n\n\tgl.getVertexAttrib = function getVertexAttrib(index, pname) {\n\t\tvar vao = self.currentVertexArrayObject;\n\t\tvar attrib = vao.attribs[index];\n\n\t\tswitch (pname) {\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:\n\t\t\t\treturn attrib.buffer;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_ENABLED:\n\t\t\t\treturn attrib.enabled;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_SIZE:\n\t\t\t\treturn attrib.size;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_STRIDE:\n\t\t\t\treturn attrib.stride;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_TYPE:\n\t\t\t\treturn attrib.type;\n\n\t\t\tcase gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:\n\t\t\t\treturn attrib.normalized;\n\n\t\t\tdefault:\n\t\t\t\treturn original.getVertexAttrib.apply(this, arguments);\n\t\t}\n\t};\n\n\tgl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {\n\t\tvar vao = self.currentVertexArrayObject;\n\t\tvao.maxAttrib = Math.max(vao.maxAttrib, indx);\n\t\tvar attrib = vao.attribs[indx];\n\t\tattrib.buffer = self.currentArrayBuffer;\n\t\tattrib.size = size;\n\t\tattrib.type = type;\n\t\tattrib.normalized = normalized;\n\t\tattrib.stride = stride;\n\t\tattrib.offset = offset;\n\t\tattrib.recache();\n\t\treturn original.vertexAttribPointer.apply(this, arguments);\n\t};\n\n\tif (gl.instrumentExtension) {\n\t\tgl.instrumentExtension(this, \"OES_vertex_array_object\");\n\t}\n\n\tgl.canvas.addEventListener('webglcontextrestored', function () {\n\t\tlog$1(\"OESVertexArrayObject emulation library context restored\");\n\t\tself.reset_();\n\t}, true);\n\tthis.reset_();\n};\n\nOESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;\n\nOESVertexArrayObject.prototype.reset_ = function reset_() {\n\tvar contextWasLost = this.vertexArrayObjects !== undefined;\n\n\tif (contextWasLost) {\n\t\tfor (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {\n\t\t\tthis.vertexArrayObjects.isAlive = false;\n\t\t}\n\t}\n\n\tvar gl = this.gl;\n\tthis.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\tthis.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);\n\tthis.currentVertexArrayObject = null;\n\tthis.currentArrayBuffer = null;\n\tthis.vertexArrayObjects = [this.defaultVertexArrayObject];\n\tthis.bindVertexArrayOES(null);\n};\n\nOESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {\n\tvar arrayObject = new WebGLVertexArrayObjectOES(this);\n\tthis.vertexArrayObjects.push(arrayObject);\n\treturn arrayObject;\n};\n\nOESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {\n\tarrayObject.isAlive = false;\n\tthis.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);\n\n\tif (this.currentVertexArrayObject == arrayObject) {\n\t\tthis.bindVertexArrayOES(null);\n\t}\n};\n\nOESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {\n\tif (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {\n\t\tif (arrayObject.hasBeenBound && arrayObject.ext == this) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nOESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {\n\tvar gl = this.gl;\n\n\tif (arrayObject && !arrayObject.isAlive) {\n\t\tsynthesizeGLError(gl.INVALID_OPERATION, \"bindVertexArrayOES: attempt to bind deleted arrayObject\");\n\t\treturn;\n\t}\n\n\tvar original = this.original;\n\tvar oldVAO = this.currentVertexArrayObject;\n\tthis.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;\n\tthis.currentVertexArrayObject.hasBeenBound = true;\n\tvar newVAO = this.currentVertexArrayObject;\n\n\tif (oldVAO == newVAO) {\n\t\treturn;\n\t}\n\n\tif (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {\n\t\toriginal.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);\n\t}\n\n\tvar currentBinding = this.currentArrayBuffer;\n\tvar maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);\n\n\tfor (var n = 0; n <= maxAttrib; n++) {\n\t\tvar attrib = newVAO.attribs[n];\n\t\tvar oldAttrib = oldVAO ? oldVAO.attribs[n] : null;\n\n\t\tif (!oldVAO || attrib.enabled != oldAttrib.enabled) {\n\t\t\tif (attrib.enabled) {\n\t\t\t\toriginal.enableVertexAttribArray.call(gl, n);\n\t\t\t} else {\n\t\t\t\toriginal.disableVertexAttribArray.call(gl, n);\n\t\t\t}\n\t\t}\n\n\t\tif (attrib.enabled) {\n\t\t\tvar bufferChanged = false;\n\n\t\t\tif (!oldVAO || attrib.buffer != oldAttrib.buffer) {\n\t\t\t\tif (currentBinding != attrib.buffer) {\n\t\t\t\t\toriginal.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);\n\t\t\t\t\tcurrentBinding = attrib.buffer;\n\t\t\t\t}\n\n\t\t\t\tbufferChanged = true;\n\t\t\t}\n\n\t\t\tif (bufferChanged || attrib.cached != oldAttrib.cached) {\n\t\t\t\toriginal.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.currentArrayBuffer != currentBinding) {\n\t\toriginal.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);\n\t}\n};\n\nconst setupVertexArrayObject = function setupVertexArrayObject(gl) {\n\tif (gl.getSupportedExtensions) {\n\t\tvar exts = gl.getSupportedExtensions();\n\n\t\tif (exts.indexOf(\"OES_vertex_array_object\") != -1) {\n\t\t\treturn;\n\t\t}\n\t} else if (gl.getExtension) {\n\t\tvar vao = gl.getExtension(\"OES_vertex_array_object\");\n\n\t\tif (vao) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (gl.getSupportedExtensions) {\n\t\tvar original_getSupportedExtensions = gl.getSupportedExtensions;\n\n\t\tgl.getSupportedExtensions = function getSupportedExtensions() {\n\t\t\tvar list = original_getSupportedExtensions.call(this) || [];\n\t\t\tlist.push(\"OES_vertex_array_object\");\n\t\t\treturn list;\n\t\t};\n\t}\n\n\tvar original_getExtension = gl.getExtension;\n\n\tgl.getExtension = function getExtension(name) {\n\t\tif (name == \"OES_vertex_array_object\") {\n\t\t\tif (!gl.__OESVertexArrayObject) {\n\t\t\t\tgl.__OESVertexArrayObject = new OESVertexArrayObject(gl);\n\t\t\t}\n\n\t\t\treturn gl.__OESVertexArrayObject;\n\t\t}\n\n\t\tif (original_getExtension) {\n\t\t\treturn original_getExtension.call(this, name);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t};\n};\n\nconst version = \"1.52.1\";\nconst revision = \"0f56653b1\";\nconst config = {};\nconst common = {};\nconst apps = {};\nconst data = {};\n\nconst _typeLookup = function () {\n\tconst result = {};\n\tconst names = [\"Array\", \"Object\", \"Function\", \"Date\", \"RegExp\", \"Float32Array\"];\n\n\tfor (let i = 0; i < names.length; i++) result[\"[object \" + names[i] + \"]\"] = names[i].toLowerCase();\n\n\treturn result;\n}();\n\nfunction type(obj) {\n\tif (obj === null) {\n\t\treturn \"null\";\n\t}\n\n\tconst type = typeof obj;\n\n\tif (type === \"undefined\" || type === \"number\" || type === \"string\" || type === \"boolean\") {\n\t\treturn type;\n\t}\n\n\treturn _typeLookup[Object.prototype.toString.call(obj)];\n}\n\nfunction extend(target, ex) {\n\tfor (const prop in ex) {\n\t\tconst copy = ex[prop];\n\n\t\tif (type(copy) === \"object\") {\n\t\t\ttarget[prop] = extend({}, copy);\n\t\t} else if (type(copy) === \"array\") {\n\t\t\ttarget[prop] = extend([], copy);\n\t\t} else {\n\t\t\ttarget[prop] = copy;\n\t\t}\n\t}\n\n\treturn target;\n}\n\nfunction isDefined(o) {\n\tlet a;\n\treturn o !== a;\n}\n\nclass EventHandler {\n\tconstructor() {\n\t\tthis._callbacks = {};\n\t\tthis._callbackActive = {};\n\t}\n\n\tinitEventHandler() {\n\t\tthis._callbacks = {};\n\t\tthis._callbackActive = {};\n\t}\n\n\t_addCallback(name, callback, scope, once = false) {\n\t\tif (!name || typeof name !== 'string' || !callback) return;\n\t\tif (!this._callbacks[name]) this._callbacks[name] = [];\n\t\tif (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n\n\t\tthis._callbacks[name].push({\n\t\t\tcallback: callback,\n\t\t\tscope: scope || this,\n\t\t\tonce: once\n\t\t});\n\t}\n\n\ton(name, callback, scope) {\n\t\tthis._addCallback(name, callback, scope, false);\n\n\t\treturn this;\n\t}\n\n\toff(name, callback, scope) {\n\t\tif (name) {\n\t\t\tif (this._callbackActive[name] && this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n\t\t} else {\n\t\t\tfor (const key in this._callbackActive) {\n\t\t\t\tif (!this._callbacks[key]) continue;\n\t\t\t\tif (this._callbacks[key] !== this._callbackActive[key]) continue;\n\t\t\t\tthis._callbackActive[key] = this._callbackActive[key].slice();\n\t\t\t}\n\t\t}\n\n\t\tif (!name) {\n\t\t\tthis._callbacks = {};\n\t\t} else if (!callback) {\n\t\t\tif (this._callbacks[name]) this._callbacks[name] = [];\n\t\t} else {\n\t\t\tconst events = this._callbacks[name];\n\t\t\tif (!events) return this;\n\t\t\tlet count = events.length;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tif (events[i].callback !== callback) continue;\n\t\t\t\tif (scope && events[i].scope !== scope) continue;\n\t\t\t\tevents[i--] = events[--count];\n\t\t\t}\n\n\t\t\tevents.length = count;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n\t\tif (!name || !this._callbacks[name]) return this;\n\t\tlet callbacks;\n\n\t\tif (!this._callbackActive[name]) {\n\t\t\tthis._callbackActive[name] = this._callbacks[name];\n\t\t} else {\n\t\t\tif (this._callbackActive[name] === this._callbacks[name]) this._callbackActive[name] = this._callbackActive[name].slice();\n\t\t\tcallbacks = this._callbacks[name].slice();\n\t\t}\n\n\t\tfor (let i = 0; (callbacks || this._callbackActive[name]) && i < (callbacks || this._callbackActive[name]).length; i++) {\n\t\t\tconst evt = (callbacks || this._callbackActive[name])[i];\n\t\t\tevt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n\n\t\t\tif (evt.once) {\n\t\t\t\tconst existingCallback = this._callbacks[name];\n\t\t\t\tconst ind = existingCallback ? existingCallback.indexOf(evt) : -1;\n\n\t\t\t\tif (ind !== -1) {\n\t\t\t\t\tif (this._callbackActive[name] === existingCallback) this._callbackActive[name] = this._callbackActive[name].slice();\n\n\t\t\t\t\tthis._callbacks[name].splice(ind, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!callbacks) this._callbackActive[name] = null;\n\t\treturn this;\n\t}\n\n\tonce(name, callback, scope) {\n\t\tthis._addCallback(name, callback, scope, true);\n\n\t\treturn this;\n\t}\n\n\thasEvent(name) {\n\t\treturn this._callbacks[name] && this._callbacks[name].length !== 0 || false;\n\t}\n\n}\n\nconst events = {\n\tattach: function (target) {\n\t\tconst ev = events;\n\t\ttarget._addCallback = ev._addCallback;\n\t\ttarget.on = ev.on;\n\t\ttarget.off = ev.off;\n\t\ttarget.fire = ev.fire;\n\t\ttarget.once = ev.once;\n\t\ttarget.hasEvent = ev.hasEvent;\n\t\ttarget._callbacks = {};\n\t\ttarget._callbackActive = {};\n\t\treturn target;\n\t},\n\t_addCallback: EventHandler.prototype._addCallback,\n\ton: EventHandler.prototype.on,\n\toff: EventHandler.prototype.off,\n\tfire: EventHandler.prototype.fire,\n\tonce: EventHandler.prototype.once,\n\thasEvent: EventHandler.prototype.hasEvent\n};\n\nconst guid = {\n\tcreate: function () {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t\t\tconst r = Math.random() * 16 | 0;\n\t\t\tconst v = c === 'x' ? r : r & 0x3 | 0x8;\n\t\t\treturn v.toString(16);\n\t\t});\n\t}\n};\n\nconst path = {\n\tdelimiter: \"/\",\n\tjoin: function () {\n\t\tconst num = arguments.length;\n\t\tlet result = arguments[0];\n\n\t\tfor (let index = 0; index < num - 1; ++index) {\n\t\t\tconst one = arguments[index];\n\t\t\tconst two = arguments[index + 1];\n\n\t\t\tif (!isDefined(one) || !isDefined(two)) {\n\t\t\t\tthrow new Error(\"undefined argument to pc.path.join\");\n\t\t\t}\n\n\t\t\tif (two[0] === path.delimiter) {\n\t\t\t\tresult = two;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {\n\t\t\t\tresult += path.delimiter + two;\n\t\t\t} else {\n\t\t\t\tresult += two;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\tnormalize: function (pathname) {\n\t\tconst lead = pathname.startsWith(path.delimiter);\n\t\tconst trail = pathname.endsWith(path.delimiter);\n\t\tconst parts = pathname.split('/');\n\t\tlet result = '';\n\t\tlet cleaned = [];\n\n\t\tfor (let i = 0; i < parts.length; i++) {\n\t\t\tif (parts[i] === '') continue;\n\t\t\tif (parts[i] === '.') continue;\n\n\t\t\tif (parts[i] === '..' && cleaned.length > 0) {\n\t\t\t\tcleaned = cleaned.slice(0, cleaned.length - 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (i > 0) cleaned.push(path.delimiter);\n\t\t\tcleaned.push(parts[i]);\n\t\t}\n\n\t\tresult = cleaned.join('');\n\n\t\tif (!lead && result[0] === path.delimiter) {\n\t\t\tresult = result.slice(1);\n\t\t}\n\n\t\tif (trail && result[result.length - 1] !== path.delimiter) {\n\t\t\tresult += path.delimiter;\n\t\t}\n\n\t\treturn result;\n\t},\n\tsplit: function (pathname) {\n\t\tconst parts = pathname.split(path.delimiter);\n\t\tconst tail = parts.slice(parts.length - 1)[0];\n\t\tconst head = parts.slice(0, parts.length - 1).join(path.delimiter);\n\t\treturn [head, tail];\n\t},\n\tgetBasename: function (pathname) {\n\t\treturn path.split(pathname)[1];\n\t},\n\tgetDirectory: function (pathname) {\n\t\tconst parts = pathname.split(path.delimiter);\n\t\treturn parts.slice(0, parts.length - 1).join(path.delimiter);\n\t},\n\tgetExtension: function (pathname) {\n\t\tconst ext = pathname.split('?')[0].split('.').pop();\n\n\t\tif (ext !== pathname) {\n\t\t\treturn \".\" + ext;\n\t\t}\n\n\t\treturn \"\";\n\t},\n\tisRelativePath: function (pathname) {\n\t\treturn pathname.charAt(0) !== \"/\" && pathname.match(/:\\/\\//) === null;\n\t},\n\textractPath: function (pathname) {\n\t\tlet result = \"\";\n\t\tconst parts = pathname.split(\"/\");\n\t\tlet i = 0;\n\n\t\tif (parts.length > 1) {\n\t\t\tif (path.isRelativePath(pathname)) {\n\t\t\t\tif (parts[0] === \".\") {\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += i === 0 ? parts[i] : \"/\" + parts[i];\n\t\t\t\t\t}\n\t\t\t\t} else if (parts[0] === \"..\") {\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += i === 0 ? parts[i] : \"/\" + parts[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult = \".\";\n\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += \"/\" + parts[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\tresult += i === 0 ? parts[i] : \"/\" + parts[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nlet desktop = false;\nlet mobile = false;\nlet windows = false;\nlet xbox = false;\nlet android = false;\nlet ios = false;\nlet touch = false;\nlet gamepads = false;\nlet workers = false;\nlet passiveEvents = false;\n\nif (typeof navigator !== 'undefined') {\n\tconst ua = navigator.userAgent;\n\tif (/(windows|mac os|linux|cros)/i.test(ua)) desktop = true;\n\tif (/xbox/i.test(ua)) xbox = true;\n\n\tif (/(windows phone|iemobile|wpdesktop)/i.test(ua)) {\n\t\tdesktop = false;\n\t\tmobile = true;\n\t\twindows = true;\n\t} else if (/android/i.test(ua)) {\n\t\tdesktop = false;\n\t\tmobile = true;\n\t\tandroid = true;\n\t} else if (/ip([ao]d|hone)/i.test(ua)) {\n\t\tdesktop = false;\n\t\tmobile = true;\n\t\tios = true;\n\t}\n\n\tif (typeof window !== 'undefined') {\n\t\ttouch = 'ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0;\n\t}\n\n\tgamepads = 'getGamepads' in navigator;\n\tworkers = typeof Worker !== 'undefined';\n\n\ttry {\n\t\tconst opts = Object.defineProperty({}, 'passive', {\n\t\t\tget: function () {\n\t\t\t\tpassiveEvents = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener(\"testpassive\", null, opts);\n\t\twindow.removeEventListener(\"testpassive\", null, opts);\n\t} catch (e) {}\n}\n\nconst environment = typeof window !== 'undefined' ? 'browser' : 'node';\nconst platform = {\n\tenvironment: environment,\n\tglobal: environment === 'browser' ? window : global,\n\tbrowser: environment === 'browser',\n\tdesktop: desktop,\n\tmobile: mobile,\n\tios: ios,\n\tandroid: android,\n\twindows: windows,\n\txbox: xbox,\n\tgamepads: gamepads,\n\ttouch: touch,\n\tworkers: workers,\n\tpassiveEvents: passiveEvents\n};\n\nconst ASCII_LOWERCASE = \"abcdefghijklmnopqrstuvwxyz\";\nconst ASCII_UPPERCASE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;\nconst HIGH_SURROGATE_BEGIN = 0xD800;\nconst HIGH_SURROGATE_END = 0xDBFF;\nconst LOW_SURROGATE_BEGIN = 0xDC00;\nconst LOW_SURROGATE_END = 0xDFFF;\nconst ZERO_WIDTH_JOINER = 0x200D;\nconst REGIONAL_INDICATOR_BEGIN = 0x1F1E6;\nconst REGIONAL_INDICATOR_END = 0x1F1FF;\nconst FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;\nconst FITZPATRICK_MODIFIER_END = 0x1F3FF;\nconst DIACRITICAL_MARKS_BEGIN = 0x20D0;\nconst DIACRITICAL_MARKS_END = 0x20FF;\nconst VARIATION_MODIFIER_BEGIN = 0xFE00;\nconst VARIATION_MODIFIER_END = 0xFE0F;\n\nfunction getCodePointData(string, i = 0) {\n\tconst size = string.length;\n\n\tif (i < 0 || i >= size) {\n\t\treturn null;\n\t}\n\n\tconst first = string.charCodeAt(i);\n\n\tif (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {\n\t\tconst second = string.charCodeAt(i + 1);\n\n\t\tif (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {\n\t\t\treturn {\n\t\t\t\tcode: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,\n\t\t\t\tlong: true\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\tcode: first,\n\t\tlong: false\n\t};\n}\n\nfunction isCodeBetween(string, begin, end) {\n\tif (!string) return false;\n\tconst codeData = getCodePointData(string);\n\n\tif (codeData) {\n\t\tconst code = codeData.code;\n\t\treturn code >= begin && code <= end;\n\t}\n\n\treturn false;\n}\n\nfunction numCharsToTakeForNextSymbol(string, index) {\n\tif (index === string.length - 1) {\n\t\treturn 1;\n\t}\n\n\tif (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {\n\t\tconst first = string.substring(index, index + 2);\n\t\tconst second = string.substring(index + 2, index + 4);\n\n\t\tif (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {\n\t\t\treturn 4;\n\t\t}\n\n\t\tif (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 2;\n\t}\n\n\tif (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\treturn 2;\n\t}\n\n\treturn 1;\n}\n\nconst string = {\n\tASCII_LOWERCASE: ASCII_LOWERCASE,\n\tASCII_UPPERCASE: ASCII_UPPERCASE,\n\tASCII_LETTERS: ASCII_LETTERS,\n\tformat: function (s) {\n\t\tfor (let i = 1; i < arguments.length; i++) {\n\t\t\ts = s.replace('{' + (i - 1) + '}', arguments[i]);\n\t\t}\n\n\t\treturn s;\n\t},\n\ttoBool: function (s, strict = false) {\n\t\tif (s === 'true') {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (strict) {\n\t\t\tif (s === 'false') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthrow new TypeError('Not a boolean string');\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetCodePoint: function (string, i) {\n\t\tconst codePointData = getCodePointData(string, i);\n\t\treturn codePointData && codePointData.code;\n\t},\n\tgetCodePoints: function (string) {\n\t\tif (typeof string !== 'string') {\n\t\t\tthrow new TypeError('Not a string');\n\t\t}\n\n\t\tlet i = 0;\n\t\tconst arr = [];\n\t\tlet codePoint;\n\n\t\twhile (!!(codePoint = getCodePointData(string, i))) {\n\t\t\tarr.push(codePoint.code);\n\t\t\ti += codePoint.long ? 2 : 1;\n\t\t}\n\n\t\treturn arr;\n\t},\n\tgetSymbols: function (string) {\n\t\tif (typeof string !== 'string') {\n\t\t\tthrow new TypeError('Not a string');\n\t\t}\n\n\t\tlet index = 0;\n\t\tconst length = string.length;\n\t\tconst output = [];\n\t\tlet take = 0;\n\t\tlet ch;\n\n\t\twhile (index < length) {\n\t\t\ttake += numCharsToTakeForNextSymbol(string, index + take);\n\t\t\tch = string[index + take];\n\n\t\t\tif (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {\n\t\t\t\tch = string[index + take++];\n\t\t\t}\n\n\t\t\tif (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\t\t\tch = string[index + take++];\n\t\t\t}\n\n\t\t\tif (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {\n\t\t\t\tch = string[index + take++];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst char = string.substring(index, index + take);\n\t\t\toutput.push(char);\n\t\t\tindex += take;\n\t\t\ttake = 0;\n\t\t}\n\n\t\treturn output;\n\t},\n\tfromCodePoint: function () {\n\t\tconst chars = [];\n\t\tlet current;\n\t\tlet codePoint;\n\t\tlet units;\n\n\t\tfor (let i = 0; i < arguments.length; ++i) {\n\t\t\tcurrent = Number(arguments[i]);\n\t\t\tcodePoint = current - 0x10000;\n\t\t\tunits = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];\n\t\t\tchars.push(String.fromCharCode.apply(null, units));\n\t\t}\n\n\t\treturn chars.join('');\n\t}\n};\n\nclass IndexedList {\n\tconstructor() {\n\t\tthis._list = [];\n\t\tthis._index = {};\n\t}\n\n\tpush(key, item) {\n\t\tif (this._index[key]) {\n\t\t\tthrow Error(\"Key already in index \" + key);\n\t\t}\n\n\t\tconst location = this._list.push(item) - 1;\n\t\tthis._index[key] = location;\n\t}\n\n\thas(key) {\n\t\treturn this._index[key] !== undefined;\n\t}\n\n\tget(key) {\n\t\tconst location = this._index[key];\n\n\t\tif (location !== undefined) {\n\t\t\treturn this._list[location];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tremove(key) {\n\t\tconst location = this._index[key];\n\n\t\tif (location !== undefined) {\n\t\t\tthis._list.splice(location, 1);\n\n\t\t\tdelete this._index[key];\n\n\t\t\tfor (key in this._index) {\n\t\t\t\tconst idx = this._index[key];\n\n\t\t\t\tif (idx > location) {\n\t\t\t\t\tthis._index[key] = idx - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlist() {\n\t\treturn this._list;\n\t}\n\n\tclear() {\n\t\tthis._list.length = 0;\n\n\t\tfor (const prop in this._index) {\n\t\t\tdelete this._index[prop];\n\t\t}\n\t}\n\n}\n\nclass ReadStream {\n\tconstructor(arraybuffer) {\n\t\tthis.arraybuffer = arraybuffer;\n\t\tthis.dataView = new DataView(arraybuffer);\n\t\tthis.offset = 0;\n\t\tthis.stack = [];\n\t}\n\n\tget remainingBytes() {\n\t\treturn this.dataView.byteLength - this.offset;\n\t}\n\n\treset(offset = 0) {\n\t\tthis.offset = offset;\n\t}\n\n\tskip(bytes) {\n\t\tthis.offset += bytes;\n\t}\n\n\talign(bytes) {\n\t\tthis.offset = this.offset + bytes - 1 & ~(bytes - 1);\n\t}\n\n\t_inc(amount) {\n\t\tthis.offset += amount;\n\t\treturn this.offset - amount;\n\t}\n\n\treadChar() {\n\t\treturn String.fromCharCode(this.dataView.getUint8(this.offset++));\n\t}\n\n\treadChars(numChars) {\n\t\tlet result = '';\n\n\t\tfor (let i = 0; i < numChars; ++i) {\n\t\t\tresult += this.readChar();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\treadU8() {\n\t\treturn this.dataView.getUint8(this.offset++);\n\t}\n\n\treadU16() {\n\t\treturn this.dataView.getUint16(this._inc(2), true);\n\t}\n\n\treadU32() {\n\t\treturn this.dataView.getUint32(this._inc(4), true);\n\t}\n\n\treadU64() {\n\t\treturn this.readU32() + 2 ** 32 * this.readU32();\n\t}\n\n\treadU32be() {\n\t\treturn this.dataView.getUint32(this._inc(4), false);\n\t}\n\n\treadArray(result) {\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = this.readU8();\n\t\t}\n\t}\n\n\treadLine() {\n\t\tconst view = this.dataView;\n\t\tlet result = \"\";\n\n\t\twhile (true) {\n\t\t\tif (this.offset >= view.byteLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst c = String.fromCharCode(this.readU8());\n\n\t\t\tif (c === '\\n') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult += c;\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\nclass SortedLoopArray {\n\tconstructor(args) {\n\t\tthis.items = [];\n\t\tthis.length = 0;\n\t\tthis.loopIndex = -1;\n\t\tthis._sortBy = args.sortBy;\n\t\tthis._sortHandler = this._doSort.bind(this);\n\t}\n\n\t_binarySearch(item) {\n\t\tlet left = 0;\n\t\tlet right = this.items.length - 1;\n\t\tconst search = item[this._sortBy];\n\t\tlet middle;\n\t\tlet current;\n\n\t\twhile (left <= right) {\n\t\t\tmiddle = Math.floor((left + right) / 2);\n\t\t\tcurrent = this.items[middle][this._sortBy];\n\n\t\t\tif (current <= search) {\n\t\t\t\tleft = middle + 1;\n\t\t\t} else if (current > search) {\n\t\t\t\tright = middle - 1;\n\t\t\t}\n\t\t}\n\n\t\treturn left;\n\t}\n\n\t_doSort(a, b) {\n\t\tconst sortBy = this._sortBy;\n\t\treturn a[sortBy] - b[sortBy];\n\t}\n\n\tinsert(item) {\n\t\tconst index = this._binarySearch(item);\n\n\t\tthis.items.splice(index, 0, item);\n\t\tthis.length++;\n\n\t\tif (this.loopIndex >= index) {\n\t\t\tthis.loopIndex++;\n\t\t}\n\t}\n\n\tappend(item) {\n\t\tthis.items.push(item);\n\t\tthis.length++;\n\t}\n\n\tremove(item) {\n\t\tconst idx = this.items.indexOf(item);\n\t\tif (idx < 0) return;\n\t\tthis.items.splice(idx, 1);\n\t\tthis.length--;\n\n\t\tif (this.loopIndex >= idx) {\n\t\t\tthis.loopIndex--;\n\t\t}\n\t}\n\n\tsort() {\n\t\tconst current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;\n\t\tthis.items.sort(this._sortHandler);\n\n\t\tif (current !== null) {\n\t\t\tthis.loopIndex = this.items.indexOf(current);\n\t\t}\n\t}\n\n}\n\nclass Tags extends EventHandler {\n\tconstructor(parent) {\n\t\tsuper();\n\t\tthis._index = {};\n\t\tthis._list = [];\n\t\tthis._parent = parent;\n\t}\n\n\tadd() {\n\t\tlet changed = false;\n\n\t\tconst tags = this._processArguments(arguments, true);\n\n\t\tif (!tags.length) return changed;\n\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (this._index[tags[i]]) continue;\n\t\t\tchanged = true;\n\t\t\tthis._index[tags[i]] = true;\n\n\t\t\tthis._list.push(tags[i]);\n\n\t\t\tthis.fire('add', tags[i], this._parent);\n\t\t}\n\n\t\tif (changed) this.fire('change', this._parent);\n\t\treturn changed;\n\t}\n\n\tremove() {\n\t\tlet changed = false;\n\t\tif (!this._list.length) return changed;\n\n\t\tconst tags = this._processArguments(arguments, true);\n\n\t\tif (!tags.length) return changed;\n\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (!this._index[tags[i]]) continue;\n\t\t\tchanged = true;\n\t\t\tdelete this._index[tags[i]];\n\n\t\t\tthis._list.splice(this._list.indexOf(tags[i]), 1);\n\n\t\t\tthis.fire('remove', tags[i], this._parent);\n\t\t}\n\n\t\tif (changed) this.fire('change', this._parent);\n\t\treturn changed;\n\t}\n\n\tclear() {\n\t\tif (!this._list.length) return;\n\n\t\tconst tags = this._list.slice(0);\n\n\t\tthis._list = [];\n\t\tthis._index = {};\n\n\t\tfor (let i = 0; i < tags.length; i++) this.fire('remove', tags[i], this._parent);\n\n\t\tthis.fire('change', this._parent);\n\t}\n\n\thas() {\n\t\tif (!this._list.length) return false;\n\t\treturn this._has(this._processArguments(arguments));\n\t}\n\n\t_has(tags) {\n\t\tif (!this._list.length || !tags.length) return false;\n\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (tags[i].length === 1) {\n\t\t\t\tif (this._index[tags[i][0]]) return true;\n\t\t\t} else {\n\t\t\t\tlet multiple = true;\n\n\t\t\t\tfor (let t = 0; t < tags[i].length; t++) {\n\t\t\t\t\tif (this._index[tags[i][t]]) continue;\n\t\t\t\t\tmultiple = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (multiple) return true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlist() {\n\t\treturn this._list.slice(0);\n\t}\n\n\t_processArguments(args, flat) {\n\t\tconst tags = [];\n\t\tlet tmp = [];\n\t\tif (!args || !args.length) return tags;\n\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tif (args[i] instanceof Array) {\n\t\t\t\tif (!flat) tmp = [];\n\n\t\t\t\tfor (let t = 0; t < args[i].length; t++) {\n\t\t\t\t\tif (typeof args[i][t] !== 'string') continue;\n\n\t\t\t\t\tif (flat) {\n\t\t\t\t\t\ttags.push(args[i][t]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp.push(args[i][t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!flat && tmp.length) tags.push(tmp);\n\t\t\t} else if (typeof args[i] === 'string') {\n\t\t\t\tif (flat) {\n\t\t\t\t\ttags.push(args[i]);\n\t\t\t\t} else {\n\t\t\t\t\ttags.push([args[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tags;\n\t}\n\n\tget size() {\n\t\treturn this._list.length;\n\t}\n\n}\n\nconst now = typeof window !== 'undefined' && window.performance && window.performance.now && window.performance.timing ? function () {\n\treturn window.performance.now();\n} : Date.now;\n\nclass Timer {\n\tconstructor() {\n\t\tthis._isRunning = false;\n\t\tthis._a = 0;\n\t\tthis._b = 0;\n\t}\n\n\tstart() {\n\t\tthis._isRunning = true;\n\t\tthis._a = now();\n\t}\n\n\tstop() {\n\t\tthis._isRunning = false;\n\t\tthis._b = now();\n\t}\n\n\tgetMilliseconds() {\n\t\treturn this._b - this._a;\n\t}\n\n}\n\nfunction createURI(options) {\n\tlet s = \"\";\n\n\tif ((options.authority || options.scheme) && (options.host || options.hostpath)) {\n\t\tthrow new Error(\"Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option\");\n\t}\n\n\tif (options.host && options.hostpath) {\n\t\tthrow new Error(\"Can't have 'host' and 'hostpath' option\");\n\t}\n\n\tif (options.path && options.hostpath) {\n\t\tthrow new Error(\"Can't have 'path' and 'hostpath' option\");\n\t}\n\n\tif (options.scheme) {\n\t\ts += options.scheme + \":\";\n\t}\n\n\tif (options.authority) {\n\t\ts += \"//\" + options.authority;\n\t}\n\n\tif (options.host) {\n\t\ts += options.host;\n\t}\n\n\tif (options.path) {\n\t\ts += options.path;\n\t}\n\n\tif (options.hostpath) {\n\t\ts += options.hostpath;\n\t}\n\n\tif (options.query) {\n\t\ts += \"?\" + options.query;\n\t}\n\n\tif (options.fragment) {\n\t\ts += \"#\" + options.fragment;\n\t}\n\n\treturn s;\n}\n\nconst re = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\nclass URI {\n\tconstructor(uri) {\n\t\tconst result = uri.match(re);\n\t\tthis.scheme = result[2];\n\t\tthis.authority = result[4];\n\t\tthis.path = result[5];\n\t\tthis.query = result[7];\n\t\tthis.fragment = result[9];\n\t}\n\n\ttoString() {\n\t\tlet s = \"\";\n\n\t\tif (this.scheme) {\n\t\t\ts += this.scheme + \":\";\n\t\t}\n\n\t\tif (this.authority) {\n\t\t\ts += \"//\" + this.authority;\n\t\t}\n\n\t\ts += this.path;\n\n\t\tif (this.query) {\n\t\t\ts += \"?\" + this.query;\n\t\t}\n\n\t\tif (this.fragment) {\n\t\t\ts += \"#\" + this.fragment;\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tgetQuery() {\n\t\tconst result = {};\n\n\t\tif (this.query) {\n\t\t\tconst queryParams = decodeURIComponent(this.query).split(\"&\");\n\n\t\t\tfor (const queryParam of queryParams) {\n\t\t\t\tconst pair = queryParam.split(\"=\");\n\t\t\t\tresult[pair[0]] = pair[1];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tsetQuery(params) {\n\t\tlet q = \"\";\n\n\t\tfor (const key in params) {\n\t\t\tif (params.hasOwnProperty(key)) {\n\t\t\t\tif (q !== \"\") {\n\t\t\t\t\tq += \"&\";\n\t\t\t\t}\n\n\t\t\t\tq += encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]);\n\t\t\t}\n\t\t}\n\n\t\tthis.query = q;\n\t}\n\n}\n\nconst math = {\n\tDEG_TO_RAD: Math.PI / 180,\n\tRAD_TO_DEG: 180 / Math.PI,\n\tclamp: function (value, min, max) {\n\t\tif (value >= max) return max;\n\t\tif (value <= min) return min;\n\t\treturn value;\n\t},\n\tintToBytes24: function (i) {\n\t\tconst r = i >> 16 & 0xff;\n\t\tconst g = i >> 8 & 0xff;\n\t\tconst b = i & 0xff;\n\t\treturn [r, g, b];\n\t},\n\tintToBytes32: function (i) {\n\t\tconst r = i >> 24 & 0xff;\n\t\tconst g = i >> 16 & 0xff;\n\t\tconst b = i >> 8 & 0xff;\n\t\tconst a = i & 0xff;\n\t\treturn [r, g, b, a];\n\t},\n\tbytesToInt24: function (r, g, b) {\n\t\tif (r.length) {\n\t\t\tb = r[2];\n\t\t\tg = r[1];\n\t\t\tr = r[0];\n\t\t}\n\n\t\treturn r << 16 | g << 8 | b;\n\t},\n\tbytesToInt32: function (r, g, b, a) {\n\t\tif (r.length) {\n\t\t\ta = r[3];\n\t\t\tb = r[2];\n\t\t\tg = r[1];\n\t\t\tr = r[0];\n\t\t}\n\n\t\treturn (r << 24 | g << 16 | b << 8 | a) >>> 0;\n\t},\n\tlerp: function (a, b, alpha) {\n\t\treturn a + (b - a) * math.clamp(alpha, 0, 1);\n\t},\n\tlerpAngle: function (a, b, alpha) {\n\t\tif (b - a > 180) {\n\t\t\tb -= 360;\n\t\t}\n\n\t\tif (b - a < -180) {\n\t\t\tb += 360;\n\t\t}\n\n\t\treturn math.lerp(a, b, math.clamp(alpha, 0, 1));\n\t},\n\tpowerOfTwo: function (x) {\n\t\treturn x !== 0 && !(x & x - 1);\n\t},\n\tnextPowerOfTwo: function (val) {\n\t\tval--;\n\t\tval |= val >> 1;\n\t\tval |= val >> 2;\n\t\tval |= val >> 4;\n\t\tval |= val >> 8;\n\t\tval |= val >> 16;\n\t\tval++;\n\t\treturn val;\n\t},\n\trandom: function (min, max) {\n\t\tconst diff = max - min;\n\t\treturn Math.random() * diff + min;\n\t},\n\tsmoothstep: function (min, max, x) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * (3 - 2 * x);\n\t},\n\tsmootherstep: function (min, max, x) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * x * (x * (x * 6 - 15) + 10);\n\t},\n\troundUp: function (numToRound, multiple) {\n\t\tif (multiple === 0) return numToRound;\n\t\treturn Math.ceil(numToRound / multiple) * multiple;\n\t},\n\tbetween: function (num, a, b, inclusive) {\n\t\tconst min = Math.min(a, b);\n\t\tconst max = Math.max(a, b);\n\t\treturn inclusive ? num >= min && num <= max : num > min && num < max;\n\t}\n};\n\nclass Http {\n\tget(url, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\treturn this.request(\"GET\", url, options, callback);\n\t}\n\n\tpost(url, data, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\toptions.postdata = data;\n\t\treturn this.request(\"POST\", url, options, callback);\n\t}\n\n\tput(url, data, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\toptions.postdata = data;\n\t\treturn this.request(\"PUT\", url, options, callback);\n\t}\n\n\tdel(url, options, callback) {\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\treturn this.request(\"DELETE\", url, options, callback);\n\t}\n\n\trequest(method, url, options, callback) {\n\t\tlet uri, query, postdata;\n\t\tlet errored = false;\n\n\t\tif (typeof options === \"function\") {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\n\t\tif (options.retry) {\n\t\t\toptions = Object.assign({\n\t\t\t\tretries: 0,\n\t\t\t\tmaxRetries: 5\n\t\t\t}, options);\n\t\t}\n\n\t\toptions.callback = callback;\n\n\t\tif (options.async == null) {\n\t\t\toptions.async = true;\n\t\t}\n\n\t\tif (options.headers == null) {\n\t\t\toptions.headers = {};\n\t\t}\n\n\t\tif (options.postdata != null) {\n\t\t\tif (options.postdata instanceof Document) {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t} else if (options.postdata instanceof FormData) {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t} else if (options.postdata instanceof Object) {\n\t\t\t\tlet contentType = options.headers[\"Content-Type\"];\n\n\t\t\t\tif (contentType === undefined) {\n\t\t\t\t\toptions.headers[\"Content-Type\"] = Http.ContentType.FORM_URLENCODED;\n\t\t\t\t\tcontentType = options.headers[\"Content-Type\"];\n\t\t\t\t}\n\n\t\t\t\tswitch (contentType) {\n\t\t\t\t\tcase Http.ContentType.FORM_URLENCODED:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpostdata = \"\";\n\t\t\t\t\t\t\tlet bFirstItem = true;\n\n\t\t\t\t\t\t\tfor (const key in options.postdata) {\n\t\t\t\t\t\t\t\tif (options.postdata.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t\tif (bFirstItem) {\n\t\t\t\t\t\t\t\t\t\tbFirstItem = false;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpostdata += \"&\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst encodedKey = encodeURIComponent(key);\n\t\t\t\t\t\t\t\t\tconst encodedValue = encodeURIComponent(options.postdata[key]);\n\t\t\t\t\t\t\t\t\tpostdata += `${encodedKey}=${encodedValue}`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase Http.ContentType.JSON:\n\t\t\t\t\t\tif (contentType == null) {\n\t\t\t\t\t\t\toptions.headers[\"Content-Type\"] = Http.ContentType.JSON;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpostdata = JSON.stringify(options.postdata);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t}\n\t\t}\n\n\t\tif (options.cache === false) {\n\t\t\tconst timestamp = now();\n\t\t\turi = new URI(url);\n\n\t\t\tif (!uri.query) {\n\t\t\t\turi.query = \"ts=\" + timestamp;\n\t\t\t} else {\n\t\t\t\turi.query = uri.query + \"&ts=\" + timestamp;\n\t\t\t}\n\n\t\t\turl = uri.toString();\n\t\t}\n\n\t\tif (options.query) {\n\t\t\turi = new URI(url);\n\t\t\tquery = extend(uri.getQuery(), options.query);\n\t\t\turi.setQuery(query);\n\t\t\turl = uri.toString();\n\t\t}\n\n\t\tconst xhr = new XMLHttpRequest();\n\t\txhr.open(method, url, options.async);\n\t\txhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;\n\t\txhr.responseType = options.responseType || this._guessResponseType(url);\n\n\t\tfor (const header in options.headers) {\n\t\t\tif (options.headers.hasOwnProperty(header)) {\n\t\t\t\txhr.setRequestHeader(header, options.headers[header]);\n\t\t\t}\n\t\t}\n\n\t\txhr.onreadystatechange = () => {\n\t\t\tthis._onReadyStateChange(method, url, options, xhr);\n\t\t};\n\n\t\txhr.onerror = () => {\n\t\t\tthis._onError(method, url, options, xhr);\n\n\t\t\terrored = true;\n\t\t};\n\n\t\ttry {\n\t\t\txhr.send(postdata);\n\t\t} catch (e) {\n\t\t\tif (!errored) {\n\t\t\t\toptions.error(xhr.status, xhr, e);\n\t\t\t}\n\t\t}\n\n\t\treturn xhr;\n\t}\n\n\t_guessResponseType(url) {\n\t\tconst uri = new URI(url);\n\t\tconst ext = path.getExtension(uri.path);\n\n\t\tif (Http.binaryExtensions.indexOf(ext) >= 0) {\n\t\t\treturn Http.ResponseType.ARRAY_BUFFER;\n\t\t}\n\n\t\tif (ext === \".xml\") {\n\t\t\treturn Http.ResponseType.DOCUMENT;\n\t\t}\n\n\t\treturn Http.ResponseType.TEXT;\n\t}\n\n\t_isBinaryContentType(contentType) {\n\t\tconst binTypes = [Http.ContentType.MP4, Http.ContentType.WAV, Http.ContentType.OGG, Http.ContentType.MP3, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.BASIS, Http.ContentType.GLB];\n\n\t\tif (binTypes.indexOf(contentType) >= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_onReadyStateChange(method, url, options, xhr) {\n\t\tif (xhr.readyState === 4) {\n\t\t\tswitch (xhr.status) {\n\t\t\t\tcase 0:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {\n\t\t\t\t\t\t\tthis._onSuccess(method, url, options, xhr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._onError(method, url, options, xhr);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase 200:\n\t\t\t\tcase 201:\n\t\t\t\tcase 206:\n\t\t\t\tcase 304:\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._onSuccess(method, url, options, xhr);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._onError(method, url, options, xhr);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSuccess(method, url, options, xhr) {\n\t\tlet response;\n\t\tlet contentType;\n\t\tconst header = xhr.getResponseHeader(\"Content-Type\");\n\n\t\tif (header) {\n\t\t\tconst parts = header.split(\";\");\n\t\t\tcontentType = parts[0].trim();\n\t\t}\n\n\t\ttry {\n\t\t\tif (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith(\".json\")) {\n\t\t\t\tresponse = JSON.parse(xhr.responseText);\n\t\t\t} else if (this._isBinaryContentType(contentType)) {\n\t\t\t\tresponse = xhr.response;\n\t\t\t} else {\n\t\t\t\tif (xhr.responseType === Http.ResponseType.ARRAY_BUFFER) {\n\t\t\t\t\tresponse = xhr.response;\n\t\t\t\t} else if (xhr.responseType === Http.ResponseType.BLOB || xhr.responseType === Http.ResponseType.JSON) {\n\t\t\t\t\tresponse = xhr.response;\n\t\t\t\t} else {\n\t\t\t\t\tif (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {\n\t\t\t\t\t\tresponse = xhr.responseXML;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse = xhr.responseText;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.callback(null, response);\n\t\t} catch (err) {\n\t\t\toptions.callback(err);\n\t\t}\n\t}\n\n\t_onError(method, url, options, xhr) {\n\t\tif (options.retrying) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.retry && options.retries < options.maxRetries) {\n\t\t\toptions.retries++;\n\t\t\toptions.retrying = true;\n\t\t\tconst retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);\n\t\t\tconsole.log(`${method}: ${url} - Error ${xhr.status}. Retrying in ${retryDelay} ms`);\n\t\t\tsetTimeout(() => {\n\t\t\t\toptions.retrying = false;\n\t\t\t\tthis.request(method, url, options, options.callback);\n\t\t\t}, retryDelay);\n\t\t} else {\n\t\t\toptions.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);\n\t\t}\n\t}\n\n}\n\nHttp.ContentType = {\n\tFORM_URLENCODED: \"application/x-www-form-urlencoded\",\n\tGIF: \"image/gif\",\n\tJPEG: \"image/jpeg\",\n\tDDS: \"image/dds\",\n\tJSON: \"application/json\",\n\tPNG: \"image/png\",\n\tTEXT: \"text/plain\",\n\tXML: \"application/xml\",\n\tWAV: \"audio/x-wav\",\n\tOGG: \"audio/ogg\",\n\tMP3: \"audio/mpeg\",\n\tMP4: \"audio/mp4\",\n\tAAC: \"audio/aac\",\n\tBIN: \"application/octet-stream\",\n\tBASIS: \"image/basis\",\n\tGLB: \"model/gltf-binary\"\n};\nHttp.ResponseType = {\n\tTEXT: 'text',\n\tARRAY_BUFFER: 'arraybuffer',\n\tBLOB: 'blob',\n\tDOCUMENT: 'document',\n\tJSON: 'json'\n};\nHttp.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb'];\nHttp.retryDelay = 100;\nconst http = new Http();\n\nconst CURVE_LINEAR = 0;\nconst CURVE_SMOOTHSTEP = 1;\nconst CURVE_CATMULL = 2;\nconst CURVE_CARDINAL = 3;\nconst CURVE_SPLINE = 4;\nconst CURVE_STEP = 5;\n\nclass Color {\n\tconstructor(r = 0, g = 0, b = 0, a = 1) {\n\t\tconst length = r.length;\n\n\t\tif (length === 3 || length === 4) {\n\t\t\tthis.r = r[0];\n\t\t\tthis.g = r[1];\n\t\t\tthis.b = r[2];\n\t\t\tthis.a = r[3] !== undefined ? r[3] : 1;\n\t\t} else {\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\t\tthis.a = a;\n\t\t}\n\t}\n\n\tclone() {\n\t\treturn new Color(this.r, this.g, this.b, this.a);\n\t}\n\n\tcopy(rhs) {\n\t\tthis.r = rhs.r;\n\t\tthis.g = rhs.g;\n\t\tthis.b = rhs.b;\n\t\tthis.a = rhs.a;\n\t\treturn this;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;\n\t}\n\n\tset(r, g, b, a = 1) {\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\t\tthis.a = a;\n\t\treturn this;\n\t}\n\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.r = lhs.r + alpha * (rhs.r - lhs.r);\n\t\tthis.g = lhs.g + alpha * (rhs.g - lhs.g);\n\t\tthis.b = lhs.b + alpha * (rhs.b - lhs.b);\n\t\tthis.a = lhs.a + alpha * (rhs.a - lhs.a);\n\t\treturn this;\n\t}\n\n\tfromString(hex) {\n\t\tconst i = parseInt(hex.replace('#', '0x'), 16);\n\t\tlet bytes;\n\n\t\tif (hex.length > 7) {\n\t\t\tbytes = math.intToBytes32(i);\n\t\t} else {\n\t\t\tbytes = math.intToBytes24(i);\n\t\t\tbytes[3] = 255;\n\t\t}\n\n\t\tthis.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);\n\t\treturn this;\n\t}\n\n\ttoString(alpha) {\n\t\tlet s = \"#\" + ((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);\n\n\t\tif (alpha === true) {\n\t\t\tconst a = Math.round(this.a * 255).toString(16);\n\n\t\t\tif (this.a < 16 / 255) {\n\t\t\t\ts += '0' + a;\n\t\t\t} else {\n\t\t\t\ts += a;\n\t\t\t}\n\t\t}\n\n\t\treturn s;\n\t}\n\n}\n\nColor.BLACK = Object.freeze(new Color(0, 0, 0, 1));\nColor.BLUE = Object.freeze(new Color(0, 0, 1, 1));\nColor.CYAN = Object.freeze(new Color(0, 1, 1, 1));\nColor.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));\nColor.GREEN = Object.freeze(new Color(0, 1, 0, 1));\nColor.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));\nColor.RED = Object.freeze(new Color(1, 0, 0, 1));\nColor.WHITE = Object.freeze(new Color(1, 1, 1, 1));\nColor.YELLOW = Object.freeze(new Color(1, 1, 0, 1));\n\nclass CurveEvaluator {\n\tconstructor(curve, time = 0) {\n\t\tthis._curve = curve;\n\t\tthis._left = -Infinity;\n\t\tthis._right = Infinity;\n\t\tthis._recip = 0;\n\t\tthis._p0 = 0;\n\t\tthis._p1 = 0;\n\t\tthis._m0 = 0;\n\t\tthis._m1 = 0;\n\n\t\tthis._reset(time);\n\t}\n\n\tevaluate(time, forceReset = false) {\n\t\tif (forceReset || time < this._left || time >= this._right) {\n\t\t\tthis._reset(time);\n\t\t}\n\n\t\tlet result;\n\t\tconst type = this._curve.type;\n\n\t\tif (type === CURVE_STEP) {\n\t\t\tresult = this._p0;\n\t\t} else {\n\t\t\tconst t = this._recip === 0 ? 0 : (time - this._left) * this._recip;\n\n\t\t\tif (type === CURVE_LINEAR) {\n\t\t\t\tresult = math.lerp(this._p0, this._p1, t);\n\t\t\t} else if (type === CURVE_SMOOTHSTEP) {\n\t\t\t\tresult = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));\n\t\t\t} else {\n\t\t\t\tresult = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_reset(time) {\n\t\tconst keys = this._curve.keys;\n\t\tconst len = keys.length;\n\n\t\tif (!len) {\n\t\t\tthis._left = -Infinity;\n\t\t\tthis._right = Infinity;\n\t\t\tthis._recip = 0;\n\t\t\tthis._p0 = this._p1 = this._m0 = this._m1 = 0;\n\t\t} else {\n\t\t\tif (time < keys[0][0]) {\n\t\t\t\tthis._left = -Infinity;\n\t\t\t\tthis._right = keys[0][0];\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = keys[0][1];\n\t\t\t\tthis._m0 = this._m1 = 0;\n\t\t\t} else if (time >= keys[len - 1][0]) {\n\t\t\t\tthis._left = keys[len - 1][0];\n\t\t\t\tthis._right = Infinity;\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = keys[len - 1][1];\n\t\t\t\tthis._m0 = this._m1 = 0;\n\t\t\t} else {\n\t\t\t\tlet index = 0;\n\n\t\t\t\twhile (time >= keys[index + 1][0]) {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\tthis._left = keys[index][0];\n\t\t\t\tthis._right = keys[index + 1][0];\n\t\t\t\tconst diff = 1.0 / (this._right - this._left);\n\t\t\t\tthis._recip = isFinite(diff) ? diff : 0;\n\t\t\t\tthis._p0 = keys[index][1];\n\t\t\t\tthis._p1 = keys[index + 1][1];\n\n\t\t\t\tif (this._isHermite()) {\n\t\t\t\t\tthis._calcTangents(keys, index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_isHermite() {\n\t\treturn this._curve.type === CURVE_CATMULL || this._curve.type === CURVE_CARDINAL || this._curve.type === CURVE_SPLINE;\n\t}\n\n\t_calcTangents(keys, index) {\n\t\tlet a;\n\t\tconst b = keys[index];\n\t\tconst c = keys[index + 1];\n\t\tlet d;\n\n\t\tif (index === 0) {\n\t\t\ta = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];\n\t\t} else {\n\t\t\ta = keys[index - 1];\n\t\t}\n\n\t\tif (index === keys.length - 2) {\n\t\t\td = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];\n\t\t} else {\n\t\t\td = keys[index + 2];\n\t\t}\n\n\t\tif (this._curve.type === CURVE_SPLINE) {\n\t\t\tconst s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);\n\t\t\tconst s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);\n\t\t\tthis._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);\n\t\t\tthis._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);\n\t\t} else {\n\t\t\tconst s1 = (c[0] - b[0]) / (b[0] - a[0]);\n\t\t\tconst s2 = (c[0] - b[0]) / (d[0] - c[0]);\n\t\t\tconst a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);\n\t\t\tconst d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);\n\t\t\tconst tension = this._curve.type === CURVE_CATMULL ? 0.5 : this._curve.tension;\n\t\t\tthis._m0 = tension * (c[1] - a_);\n\t\t\tthis._m1 = tension * (d_ - b[1]);\n\t\t}\n\t}\n\n\t_evaluateHermite(p0, p1, m0, m1, t) {\n\t\tconst t2 = t * t;\n\t\tconst twot = t + t;\n\t\tconst omt = 1 - t;\n\t\tconst omt2 = omt * omt;\n\t\treturn p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));\n\t}\n\n}\n\nclass Curve {\n\tconstructor(data) {\n\t\tthis.keys = [];\n\t\tthis.type = CURVE_SMOOTHSTEP;\n\t\tthis.tension = 0.5;\n\t\tthis._eval = new CurveEvaluator(this);\n\n\t\tif (data) {\n\t\t\tfor (let i = 0; i < data.length - 1; i += 2) {\n\t\t\t\tthis.keys.push([data[i], data[i + 1]]);\n\t\t\t}\n\t\t}\n\n\t\tthis.sort();\n\t}\n\n\tget length() {\n\t\treturn this.keys.length;\n\t}\n\n\tadd(time, value) {\n\t\tconst keys = this.keys;\n\t\tconst len = keys.length;\n\t\tlet i = 0;\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (keys[i][0] > time) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst key = [time, value];\n\t\tthis.keys.splice(i, 0, key);\n\t\treturn key;\n\t}\n\n\tget(index) {\n\t\treturn this.keys[index];\n\t}\n\n\tsort() {\n\t\tthis.keys.sort(function (a, b) {\n\t\t\treturn a[0] - b[0];\n\t\t});\n\t}\n\n\tvalue(time) {\n\t\treturn this._eval.evaluate(time, true);\n\t}\n\n\tclosest(time) {\n\t\tconst keys = this.keys;\n\t\tconst length = keys.length;\n\t\tlet min = 2;\n\t\tlet result = null;\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst diff = Math.abs(time - keys[i][0]);\n\n\t\t\tif (min >= diff) {\n\t\t\t\tmin = diff;\n\t\t\t\tresult = keys[i];\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tclone() {\n\t\tconst result = new Curve();\n\t\tresult.keys = extend(result.keys, this.keys);\n\t\tresult.type = this.type;\n\t\tresult.tension = this.tension;\n\t\treturn result;\n\t}\n\n\tquantize(precision) {\n\t\tprecision = Math.max(precision, 2);\n\t\tconst values = new Float32Array(precision);\n\t\tconst step = 1.0 / (precision - 1);\n\t\tvalues[0] = this._eval.evaluate(0, true);\n\n\t\tfor (let i = 1; i < precision; i++) {\n\t\t\tvalues[i] = this._eval.evaluate(step * i);\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tquantizeClamped(precision, min, max) {\n\t\tconst result = this.quantize(precision);\n\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = Math.min(max, Math.max(min, result[i]));\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\nclass CurveSet {\n\tconstructor() {\n\t\tthis.curves = [];\n\t\tthis._type = CURVE_SMOOTHSTEP;\n\n\t\tif (arguments.length > 1) {\n\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\tthis.curves.push(new Curve(arguments[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tif (arguments.length === 0) {\n\t\t\t\tthis.curves.push(new Curve());\n\t\t\t} else {\n\t\t\t\tconst arg = arguments[0];\n\n\t\t\t\tif (typeof arg === 'number') {\n\t\t\t\t\tfor (let i = 0; i < arg; i++) {\n\t\t\t\t\t\tthis.curves.push(new Curve());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0; i < arg.length; i++) {\n\t\t\t\t\t\tthis.curves.push(new Curve(arg[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget length() {\n\t\treturn this.curves.length;\n\t}\n\n\tset type(value) {\n\t\tthis._type = value;\n\n\t\tfor (let i = 0; i < this.curves.length; i++) {\n\t\t\tthis.curves[i].type = value;\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget(index) {\n\t\treturn this.curves[index];\n\t}\n\n\tvalue(time, result = []) {\n\t\tconst length = this.curves.length;\n\t\tresult.length = length;\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult[i] = this.curves[i].value(time);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tclone() {\n\t\tconst result = new CurveSet();\n\t\tresult.curves = [];\n\n\t\tfor (let i = 0; i < this.curves.length; i++) {\n\t\t\tresult.curves.push(this.curves[i].clone());\n\t\t}\n\n\t\tresult._type = this._type;\n\t\treturn result;\n\t}\n\n\tquantize(precision) {\n\t\tprecision = Math.max(precision, 2);\n\t\tconst numCurves = this.curves.length;\n\t\tconst values = new Float32Array(precision * numCurves);\n\t\tconst step = 1.0 / (precision - 1);\n\n\t\tfor (let c = 0; c < numCurves; c++) {\n\t\t\tconst ev = new CurveEvaluator(this.curves[c]);\n\n\t\t\tfor (let i = 0; i < precision; i++) {\n\t\t\t\tvalues[i * numCurves + c] = ev.evaluate(step * i);\n\t\t\t}\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tquantizeClamped(precision, min, max) {\n\t\tconst result = this.quantize(precision);\n\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = Math.min(max, Math.max(min, result[i]));\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\nclass Vec3 {\n\tconstructor(x = 0, y = 0, z = 0) {\n\t\tif (x.length === 3) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\t}\n\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\tthis.z += rhs.z;\n\t\treturn this;\n\t}\n\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\tthis.z = lhs.z + rhs.z;\n\t\treturn this;\n\t}\n\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\tthis.z += scalar;\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\treturn new Vec3(this.x, this.y, this.z);\n\t}\n\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\treturn this;\n\t}\n\n\tcross(lhs, rhs) {\n\t\tconst lx = lhs.x;\n\t\tconst ly = lhs.y;\n\t\tconst lz = lhs.z;\n\t\tconst rx = rhs.x;\n\t\tconst ry = rhs.y;\n\t\tconst rz = rhs.z;\n\t\tthis.x = ly * rz - ry * lz;\n\t\tthis.y = lz * rx - rz * lx;\n\t\tthis.z = lx * ry - rx * ly;\n\t\treturn this;\n\t}\n\n\tdistance(rhs) {\n\t\tconst x = this.x - rhs.x;\n\t\tconst y = this.y - rhs.y;\n\t\tconst z = this.z - rhs.z;\n\t\treturn Math.sqrt(x * x + y * y + z * z);\n\t}\n\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\tthis.z /= rhs.z;\n\t\treturn this;\n\t}\n\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\tthis.z = lhs.z / rhs.z;\n\t\treturn this;\n\t}\n\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\tthis.z /= scalar;\n\t\treturn this;\n\t}\n\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;\n\t}\n\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\t}\n\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t}\n\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\tthis.z = lhs.z + alpha * (rhs.z - lhs.z);\n\t\treturn this;\n\t}\n\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\tthis.z *= rhs.z;\n\t\treturn this;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\tthis.z = lhs.z * rhs.z;\n\t\treturn this;\n\t}\n\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\treturn this;\n\t}\n\n\tnormalize() {\n\t\tconst lengthSq = this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x *= invLength;\n\t\t\tthis.y *= invLength;\n\t\t\tthis.z *= invLength;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfloor() {\n\t\tthis.x = Math.floor(this.x);\n\t\tthis.y = Math.floor(this.y);\n\t\tthis.z = Math.floor(this.z);\n\t\treturn this;\n\t}\n\n\tceil() {\n\t\tthis.x = Math.ceil(this.x);\n\t\tthis.y = Math.ceil(this.y);\n\t\tthis.z = Math.ceil(this.z);\n\t\treturn this;\n\t}\n\n\tround() {\n\t\tthis.x = Math.round(this.x);\n\t\tthis.y = Math.round(this.y);\n\t\tthis.z = Math.round(this.z);\n\t\treturn this;\n\t}\n\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\tif (rhs.z < this.z) this.z = rhs.z;\n\t\treturn this;\n\t}\n\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\tif (rhs.z > this.z) this.z = rhs.z;\n\t\treturn this;\n\t}\n\n\tproject(rhs) {\n\t\tconst a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n\t\tconst b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;\n\t\tconst s = a_dot_b / b_dot_b;\n\t\tthis.x = rhs.x * s;\n\t\tthis.y = rhs.y * s;\n\t\tthis.z = rhs.z * s;\n\t\treturn this;\n\t}\n\n\tset(x, y, z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\treturn this;\n\t}\n\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\tthis.z -= rhs.z;\n\t\treturn this;\n\t}\n\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\tthis.z = lhs.z - rhs.z;\n\t\treturn this;\n\t}\n\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\tthis.z -= scalar;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}]`;\n\t}\n\n}\n\nVec3.ZERO = Object.freeze(new Vec3(0, 0, 0));\nVec3.ONE = Object.freeze(new Vec3(1, 1, 1));\nVec3.UP = Object.freeze(new Vec3(0, 1, 0));\nVec3.DOWN = Object.freeze(new Vec3(0, -1, 0));\nVec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));\nVec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));\nVec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));\nVec3.BACK = Object.freeze(new Vec3(0, 0, 1));\n\nclass Mat3 {\n\tconstructor() {\n\t\tconst data = new Float32Array(9);\n\t\tdata[0] = data[4] = data[8] = 1;\n\t\tthis.data = data;\n\t}\n\n\tclone() {\n\t\treturn new Mat3().copy(this);\n\t}\n\n\tcopy(rhs) {\n\t\tconst src = rhs.data;\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\treturn this;\n\t}\n\n\tset(src) {\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\treturn this;\n\t}\n\n\tequals(rhs) {\n\t\tconst l = this.data;\n\t\tconst r = rhs.data;\n\t\treturn l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];\n\t}\n\n\tisIdentity() {\n\t\tconst m = this.data;\n\t\treturn m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;\n\t}\n\n\tsetIdentity() {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 1;\n\t\tm[5] = 0;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 1;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tlet t = '[';\n\n\t\tfor (let i = 0; i < 9; i++) {\n\t\t\tt += this.data[i];\n\t\t\tt += i !== 8 ? ', ' : '';\n\t\t}\n\n\t\tt += ']';\n\t\treturn t;\n\t}\n\n\ttranspose() {\n\t\tconst m = this.data;\n\t\tlet tmp;\n\t\ttmp = m[1];\n\t\tm[1] = m[3];\n\t\tm[3] = tmp;\n\t\ttmp = m[2];\n\t\tm[2] = m[6];\n\t\tm[6] = tmp;\n\t\ttmp = m[5];\n\t\tm[5] = m[7];\n\t\tm[7] = tmp;\n\t\treturn this;\n\t}\n\n\tsetFromMat4(m) {\n\t\tconst src = m.data;\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[4];\n\t\tdst[4] = src[5];\n\t\tdst[5] = src[6];\n\t\tdst[6] = src[8];\n\t\tdst[7] = src[9];\n\t\tdst[8] = src[10];\n\t\treturn this;\n\t}\n\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst x = vec.x;\n\t\tconst y = vec.y;\n\t\tconst z = vec.z;\n\t\tres.x = x * m[0] + y * m[3] + z * m[6];\n\t\tres.y = x * m[1] + y * m[4] + z * m[7];\n\t\tres.z = x * m[2] + y * m[5] + z * m[8];\n\t\treturn res;\n\t}\n\n}\n\nMat3.IDENTITY = Object.freeze(new Mat3());\nMat3.ZERO = Object.freeze(new Mat3().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));\n\nclass Vec2 {\n\tconstructor(x = 0, y = 0) {\n\t\tif (x.length === 2) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\treturn this;\n\t}\n\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\treturn this;\n\t}\n\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\treturn new Vec2(this.x, this.y);\n\t}\n\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\treturn this;\n\t}\n\n\tcross(rhs) {\n\t\treturn this.x * rhs.y - this.y * rhs.x;\n\t}\n\n\tdistance(rhs) {\n\t\tconst x = this.x - rhs.x;\n\t\tconst y = this.y - rhs.y;\n\t\treturn Math.sqrt(x * x + y * y);\n\t}\n\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\treturn this;\n\t}\n\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\treturn this;\n\t}\n\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\treturn this;\n\t}\n\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y;\n\t}\n\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t}\n\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y;\n\t}\n\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\treturn this;\n\t}\n\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\treturn this;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\treturn this;\n\t}\n\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\treturn this;\n\t}\n\n\tnormalize() {\n\t\tconst lengthSq = this.x * this.x + this.y * this.y;\n\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x *= invLength;\n\t\t\tthis.y *= invLength;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfloor() {\n\t\tthis.x = Math.floor(this.x);\n\t\tthis.y = Math.floor(this.y);\n\t\treturn this;\n\t}\n\n\tceil() {\n\t\tthis.x = Math.ceil(this.x);\n\t\tthis.y = Math.ceil(this.y);\n\t\treturn this;\n\t}\n\n\tround() {\n\t\tthis.x = Math.round(this.x);\n\t\tthis.y = Math.round(this.y);\n\t\treturn this;\n\t}\n\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\treturn this;\n\t}\n\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\treturn this;\n\t}\n\n\tset(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\treturn this;\n\t}\n\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\treturn this;\n\t}\n\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}]`;\n\t}\n\n\tstatic angleRad(lhs, rhs) {\n\t\treturn Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);\n\t}\n\n}\n\nVec2.ZERO = Object.freeze(new Vec2(0, 0));\nVec2.ONE = Object.freeze(new Vec2(1, 1));\nVec2.UP = Object.freeze(new Vec2(0, 1));\nVec2.DOWN = Object.freeze(new Vec2(0, -1));\nVec2.RIGHT = Object.freeze(new Vec2(1, 0));\nVec2.LEFT = Object.freeze(new Vec2(-1, 0));\n\nclass Vec4 {\n\tconstructor(x = 0, y = 0, z = 0, w = 0) {\n\t\tif (x.length === 4) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t\tthis.w = x[3];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\tthis.z += rhs.z;\n\t\tthis.w += rhs.w;\n\t\treturn this;\n\t}\n\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\tthis.z = lhs.z + rhs.z;\n\t\tthis.w = lhs.w + rhs.w;\n\t\treturn this;\n\t}\n\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\tthis.z += scalar;\n\t\tthis.w += scalar;\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\treturn new Vec4(this.x, this.y, this.z, this.w);\n\t}\n\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\tthis.w = rhs.w;\n\t\treturn this;\n\t}\n\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\tthis.z /= rhs.z;\n\t\tthis.w /= rhs.w;\n\t\treturn this;\n\t}\n\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\tthis.z = lhs.z / rhs.z;\n\t\tthis.w = lhs.w / rhs.w;\n\t\treturn this;\n\t}\n\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\tthis.z /= scalar;\n\t\tthis.w /= scalar;\n\t\treturn this;\n\t}\n\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n\t}\n\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t}\n\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t}\n\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\tthis.z = lhs.z + alpha * (rhs.z - lhs.z);\n\t\tthis.w = lhs.w + alpha * (rhs.w - lhs.w);\n\t\treturn this;\n\t}\n\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\tthis.z *= rhs.z;\n\t\tthis.w *= rhs.w;\n\t\treturn this;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\tthis.z = lhs.z * rhs.z;\n\t\tthis.w = lhs.w * rhs.w;\n\t\treturn this;\n\t}\n\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\t\treturn this;\n\t}\n\n\tnormalize() {\n\t\tconst lengthSq = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x *= invLength;\n\t\t\tthis.y *= invLength;\n\t\t\tthis.z *= invLength;\n\t\t\tthis.w *= invLength;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tfloor() {\n\t\tthis.x = Math.floor(this.x);\n\t\tthis.y = Math.floor(this.y);\n\t\tthis.z = Math.floor(this.z);\n\t\tthis.w = Math.floor(this.w);\n\t\treturn this;\n\t}\n\n\tceil() {\n\t\tthis.x = Math.ceil(this.x);\n\t\tthis.y = Math.ceil(this.y);\n\t\tthis.z = Math.ceil(this.z);\n\t\tthis.w = Math.ceil(this.w);\n\t\treturn this;\n\t}\n\n\tround() {\n\t\tthis.x = Math.round(this.x);\n\t\tthis.y = Math.round(this.y);\n\t\tthis.z = Math.round(this.z);\n\t\tthis.w = Math.round(this.w);\n\t\treturn this;\n\t}\n\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\tif (rhs.z < this.z) this.z = rhs.z;\n\t\tif (rhs.w < this.w) this.w = rhs.w;\n\t\treturn this;\n\t}\n\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\tif (rhs.z > this.z) this.z = rhs.z;\n\t\tif (rhs.w > this.w) this.w = rhs.w;\n\t\treturn this;\n\t}\n\n\tset(x, y, z, w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\tthis.z -= rhs.z;\n\t\tthis.w -= rhs.w;\n\t\treturn this;\n\t}\n\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\tthis.z = lhs.z - rhs.z;\n\t\tthis.w = lhs.w - rhs.w;\n\t\treturn this;\n\t}\n\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\tthis.z -= scalar;\n\t\tthis.w -= scalar;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n\t}\n\n}\n\nVec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));\nVec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));\n\nconst _halfSize$1 = new Vec2();\n\nconst x = new Vec3();\nconst y = new Vec3();\nconst z = new Vec3();\nconst scale = new Vec3();\n\nclass Mat4 {\n\tconstructor() {\n\t\tconst data = new Float32Array(16);\n\t\tdata[0] = data[5] = data[10] = data[15] = 1;\n\t\tthis.data = data;\n\t}\n\n\tstatic _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {\n\t\tif (fovIsHorizontal) {\n\t\t\thalfSize.x = znear * Math.tan(fov * Math.PI / 360);\n\t\t\thalfSize.y = halfSize.x / aspect;\n\t\t} else {\n\t\t\thalfSize.y = znear * Math.tan(fov * Math.PI / 360);\n\t\t\thalfSize.x = halfSize.y * aspect;\n\t\t}\n\t}\n\n\tadd2(lhs, rhs) {\n\t\tconst a = lhs.data,\n\t\t\t\t\tb = rhs.data,\n\t\t\t\t\tr = this.data;\n\t\tr[0] = a[0] + b[0];\n\t\tr[1] = a[1] + b[1];\n\t\tr[2] = a[2] + b[2];\n\t\tr[3] = a[3] + b[3];\n\t\tr[4] = a[4] + b[4];\n\t\tr[5] = a[5] + b[5];\n\t\tr[6] = a[6] + b[6];\n\t\tr[7] = a[7] + b[7];\n\t\tr[8] = a[8] + b[8];\n\t\tr[9] = a[9] + b[9];\n\t\tr[10] = a[10] + b[10];\n\t\tr[11] = a[11] + b[11];\n\t\tr[12] = a[12] + b[12];\n\t\tr[13] = a[13] + b[13];\n\t\tr[14] = a[14] + b[14];\n\t\tr[15] = a[15] + b[15];\n\t\treturn this;\n\t}\n\n\tadd(rhs) {\n\t\treturn this.add2(this, rhs);\n\t}\n\n\tclone() {\n\t\treturn new Mat4().copy(this);\n\t}\n\n\tcopy(rhs) {\n\t\tconst src = rhs.data,\n\t\t\t\t\tdst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\tdst[9] = src[9];\n\t\tdst[10] = src[10];\n\t\tdst[11] = src[11];\n\t\tdst[12] = src[12];\n\t\tdst[13] = src[13];\n\t\tdst[14] = src[14];\n\t\tdst[15] = src[15];\n\t\treturn this;\n\t}\n\n\tequals(rhs) {\n\t\tconst l = this.data,\n\t\t\t\t\tr = rhs.data;\n\t\treturn l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];\n\t}\n\n\tisIdentity() {\n\t\tconst m = this.data;\n\t\treturn m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tconst a = lhs.data;\n\t\tconst b = rhs.data;\n\t\tconst r = this.data;\n\t\tconst a00 = a[0];\n\t\tconst a01 = a[1];\n\t\tconst a02 = a[2];\n\t\tconst a03 = a[3];\n\t\tconst a10 = a[4];\n\t\tconst a11 = a[5];\n\t\tconst a12 = a[6];\n\t\tconst a13 = a[7];\n\t\tconst a20 = a[8];\n\t\tconst a21 = a[9];\n\t\tconst a22 = a[10];\n\t\tconst a23 = a[11];\n\t\tconst a30 = a[12];\n\t\tconst a31 = a[13];\n\t\tconst a32 = a[14];\n\t\tconst a33 = a[15];\n\t\tlet b0, b1, b2, b3;\n\t\tb0 = b[0];\n\t\tb1 = b[1];\n\t\tb2 = b[2];\n\t\tb3 = b[3];\n\t\tr[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[4];\n\t\tb1 = b[5];\n\t\tb2 = b[6];\n\t\tb3 = b[7];\n\t\tr[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[8];\n\t\tb1 = b[9];\n\t\tb2 = b[10];\n\t\tb3 = b[11];\n\t\tr[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[12];\n\t\tb1 = b[13];\n\t\tb2 = b[14];\n\t\tb3 = b[15];\n\t\tr[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\treturn this;\n\t}\n\n\tmulAffine2(lhs, rhs) {\n\t\tconst a = lhs.data;\n\t\tconst b = rhs.data;\n\t\tconst r = this.data;\n\t\tconst a00 = a[0];\n\t\tconst a01 = a[1];\n\t\tconst a02 = a[2];\n\t\tconst a10 = a[4];\n\t\tconst a11 = a[5];\n\t\tconst a12 = a[6];\n\t\tconst a20 = a[8];\n\t\tconst a21 = a[9];\n\t\tconst a22 = a[10];\n\t\tconst a30 = a[12];\n\t\tconst a31 = a[13];\n\t\tconst a32 = a[14];\n\t\tlet b0, b1, b2;\n\t\tb0 = b[0];\n\t\tb1 = b[1];\n\t\tb2 = b[2];\n\t\tr[0] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[1] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[2] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[3] = 0;\n\t\tb0 = b[4];\n\t\tb1 = b[5];\n\t\tb2 = b[6];\n\t\tr[4] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[5] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[6] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[7] = 0;\n\t\tb0 = b[8];\n\t\tb1 = b[9];\n\t\tb2 = b[10];\n\t\tr[8] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[9] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[10] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[11] = 0;\n\t\tb0 = b[12];\n\t\tb1 = b[13];\n\t\tb2 = b[14];\n\t\tr[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;\n\t\tr[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;\n\t\tr[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\n\tmul(rhs) {\n\t\treturn this.mul2(this, rhs);\n\t}\n\n\ttransformPoint(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst x = vec.x;\n\t\tconst y = vec.y;\n\t\tconst z = vec.z;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8] + m[12];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9] + m[13];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10] + m[14];\n\t\treturn res;\n\t}\n\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst x = vec.x;\n\t\tconst y = vec.y;\n\t\tconst z = vec.z;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10];\n\t\treturn res;\n\t}\n\n\ttransformVec4(vec, res = new Vec4()) {\n\t\tconst m = this.data;\n\t\tconst x = vec.x;\n\t\tconst y = vec.y;\n\t\tconst z = vec.z;\n\t\tconst w = vec.w;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];\n\t\tres.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];\n\t\treturn res;\n\t}\n\n\tsetLookAt(position, target, up) {\n\t\tz.sub2(position, target).normalize();\n\t\ty.copy(up).normalize();\n\t\tx.cross(y, z).normalize();\n\t\ty.cross(z, x);\n\t\tconst r = this.data;\n\t\tr[0] = x.x;\n\t\tr[1] = x.y;\n\t\tr[2] = x.z;\n\t\tr[3] = 0;\n\t\tr[4] = y.x;\n\t\tr[5] = y.y;\n\t\tr[6] = y.z;\n\t\tr[7] = 0;\n\t\tr[8] = z.x;\n\t\tr[9] = z.y;\n\t\tr[10] = z.z;\n\t\tr[11] = 0;\n\t\tr[12] = position.x;\n\t\tr[13] = position.y;\n\t\tr[14] = position.z;\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetFrustum(left, right, bottom, top, znear, zfar) {\n\t\tconst temp1 = 2 * znear;\n\t\tconst temp2 = right - left;\n\t\tconst temp3 = top - bottom;\n\t\tconst temp4 = zfar - znear;\n\t\tconst r = this.data;\n\t\tr[0] = temp1 / temp2;\n\t\tr[1] = 0;\n\t\tr[2] = 0;\n\t\tr[3] = 0;\n\t\tr[4] = 0;\n\t\tr[5] = temp1 / temp3;\n\t\tr[6] = 0;\n\t\tr[7] = 0;\n\t\tr[8] = (right + left) / temp2;\n\t\tr[9] = (top + bottom) / temp3;\n\t\tr[10] = (-zfar - znear) / temp4;\n\t\tr[11] = -1;\n\t\tr[12] = 0;\n\t\tr[13] = 0;\n\t\tr[14] = -temp1 * zfar / temp4;\n\t\tr[15] = 0;\n\t\treturn this;\n\t}\n\n\tsetPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {\n\t\tMat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);\n\n\t\treturn this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);\n\t}\n\n\tsetOrtho(left, right, bottom, top, near, far) {\n\t\tconst r = this.data;\n\t\tr[0] = 2 / (right - left);\n\t\tr[1] = 0;\n\t\tr[2] = 0;\n\t\tr[3] = 0;\n\t\tr[4] = 0;\n\t\tr[5] = 2 / (top - bottom);\n\t\tr[6] = 0;\n\t\tr[7] = 0;\n\t\tr[8] = 0;\n\t\tr[9] = 0;\n\t\tr[10] = -2 / (far - near);\n\t\tr[11] = 0;\n\t\tr[12] = -(right + left) / (right - left);\n\t\tr[13] = -(top + bottom) / (top - bottom);\n\t\tr[14] = -(far + near) / (far - near);\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetFromAxisAngle(axis, angle) {\n\t\tangle *= math.DEG_TO_RAD;\n\t\tconst x = axis.x;\n\t\tconst y = axis.y;\n\t\tconst z = axis.z;\n\t\tconst c = Math.cos(angle);\n\t\tconst s = Math.sin(angle);\n\t\tconst t = 1 - c;\n\t\tconst tx = t * x;\n\t\tconst ty = t * y;\n\t\tconst m = this.data;\n\t\tm[0] = tx * x + c;\n\t\tm[1] = tx * y + s * z;\n\t\tm[2] = tx * z - s * y;\n\t\tm[3] = 0;\n\t\tm[4] = tx * y - s * z;\n\t\tm[5] = ty * y + c;\n\t\tm[6] = ty * z + s * x;\n\t\tm[7] = 0;\n\t\tm[8] = tx * z + s * y;\n\t\tm[9] = ty * z - x * s;\n\t\tm[10] = t * z * z + c;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetTranslate(x, y, z) {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = 1;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 1;\n\t\tm[11] = 0;\n\t\tm[12] = x;\n\t\tm[13] = y;\n\t\tm[14] = z;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetScale(x, y, z) {\n\t\tconst m = this.data;\n\t\tm[0] = x;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = y;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = z;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetViewport(x, y, width, height) {\n\t\tconst m = this.data;\n\t\tm[0] = width * 0.5;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = height * 0.5;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 0.5;\n\t\tm[11] = 0;\n\t\tm[12] = x + width * 0.5;\n\t\tm[13] = y + height * 0.5;\n\t\tm[14] = 0.5;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tinvert() {\n\t\tconst m = this.data;\n\t\tconst a00 = m[0];\n\t\tconst a01 = m[1];\n\t\tconst a02 = m[2];\n\t\tconst a03 = m[3];\n\t\tconst a10 = m[4];\n\t\tconst a11 = m[5];\n\t\tconst a12 = m[6];\n\t\tconst a13 = m[7];\n\t\tconst a20 = m[8];\n\t\tconst a21 = m[9];\n\t\tconst a22 = m[10];\n\t\tconst a23 = m[11];\n\t\tconst a30 = m[12];\n\t\tconst a31 = m[13];\n\t\tconst a32 = m[14];\n\t\tconst a33 = m[15];\n\t\tconst b00 = a00 * a11 - a01 * a10;\n\t\tconst b01 = a00 * a12 - a02 * a10;\n\t\tconst b02 = a00 * a13 - a03 * a10;\n\t\tconst b03 = a01 * a12 - a02 * a11;\n\t\tconst b04 = a01 * a13 - a03 * a11;\n\t\tconst b05 = a02 * a13 - a03 * a12;\n\t\tconst b06 = a20 * a31 - a21 * a30;\n\t\tconst b07 = a20 * a32 - a22 * a30;\n\t\tconst b08 = a20 * a33 - a23 * a30;\n\t\tconst b09 = a21 * a32 - a22 * a31;\n\t\tconst b10 = a21 * a33 - a23 * a31;\n\t\tconst b11 = a22 * a33 - a23 * a32;\n\t\tconst det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n\t\tif (det === 0) {\n\t\t\tthis.setIdentity();\n\t\t} else {\n\t\t\tconst invDet = 1 / det;\n\t\t\tm[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n\t\t\tm[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n\t\t\tm[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n\t\t\tm[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n\t\t\tm[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n\t\t\tm[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n\t\t\tm[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n\t\t\tm[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n\t\t\tm[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n\t\t\tm[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n\t\t\tm[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n\t\t\tm[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n\t\t\tm[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n\t\t\tm[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n\t\t\tm[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n\t\t\tm[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tset(src) {\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\tdst[9] = src[9];\n\t\tdst[10] = src[10];\n\t\tdst[11] = src[11];\n\t\tdst[12] = src[12];\n\t\tdst[13] = src[13];\n\t\tdst[14] = src[14];\n\t\tdst[15] = src[15];\n\t\treturn this;\n\t}\n\n\tsetIdentity() {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = 1;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 1;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tsetTRS(t, r, s) {\n\t\tconst qx = r.x;\n\t\tconst qy = r.y;\n\t\tconst qz = r.z;\n\t\tconst qw = r.w;\n\t\tconst sx = s.x;\n\t\tconst sy = s.y;\n\t\tconst sz = s.z;\n\t\tconst x2 = qx + qx;\n\t\tconst y2 = qy + qy;\n\t\tconst z2 = qz + qz;\n\t\tconst xx = qx * x2;\n\t\tconst xy = qx * y2;\n\t\tconst xz = qx * z2;\n\t\tconst yy = qy * y2;\n\t\tconst yz = qy * z2;\n\t\tconst zz = qz * z2;\n\t\tconst wx = qw * x2;\n\t\tconst wy = qw * y2;\n\t\tconst wz = qw * z2;\n\t\tconst m = this.data;\n\t\tm[0] = (1 - (yy + zz)) * sx;\n\t\tm[1] = (xy + wz) * sx;\n\t\tm[2] = (xz - wy) * sx;\n\t\tm[3] = 0;\n\t\tm[4] = (xy - wz) * sy;\n\t\tm[5] = (1 - (xx + zz)) * sy;\n\t\tm[6] = (yz + wx) * sy;\n\t\tm[7] = 0;\n\t\tm[8] = (xz + wy) * sz;\n\t\tm[9] = (yz - wx) * sz;\n\t\tm[10] = (1 - (xx + yy)) * sz;\n\t\tm[11] = 0;\n\t\tm[12] = t.x;\n\t\tm[13] = t.y;\n\t\tm[14] = t.z;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\ttranspose() {\n\t\tlet tmp;\n\t\tconst m = this.data;\n\t\ttmp = m[1];\n\t\tm[1] = m[4];\n\t\tm[4] = tmp;\n\t\ttmp = m[2];\n\t\tm[2] = m[8];\n\t\tm[8] = tmp;\n\t\ttmp = m[3];\n\t\tm[3] = m[12];\n\t\tm[12] = tmp;\n\t\ttmp = m[6];\n\t\tm[6] = m[9];\n\t\tm[9] = tmp;\n\t\ttmp = m[7];\n\t\tm[7] = m[13];\n\t\tm[13] = tmp;\n\t\ttmp = m[11];\n\t\tm[11] = m[14];\n\t\tm[14] = tmp;\n\t\treturn this;\n\t}\n\n\tinvertTo3x3(res) {\n\t\tconst m = this.data;\n\t\tconst r = res.data;\n\t\tconst m0 = m[0];\n\t\tconst m1 = m[1];\n\t\tconst m2 = m[2];\n\t\tconst m4 = m[4];\n\t\tconst m5 = m[5];\n\t\tconst m6 = m[6];\n\t\tconst m8 = m[8];\n\t\tconst m9 = m[9];\n\t\tconst m10 = m[10];\n\t\tconst a11 = m10 * m5 - m6 * m9;\n\t\tconst a21 = -m10 * m1 + m2 * m9;\n\t\tconst a31 = m6 * m1 - m2 * m5;\n\t\tconst a12 = -m10 * m4 + m6 * m8;\n\t\tconst a22 = m10 * m0 - m2 * m8;\n\t\tconst a32 = -m6 * m0 + m2 * m4;\n\t\tconst a13 = m9 * m4 - m5 * m8;\n\t\tconst a23 = -m9 * m0 + m1 * m8;\n\t\tconst a33 = m5 * m0 - m1 * m4;\n\t\tconst det = m0 * a11 + m1 * a12 + m2 * a13;\n\n\t\tif (det === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst idet = 1 / det;\n\t\tr[0] = idet * a11;\n\t\tr[1] = idet * a21;\n\t\tr[2] = idet * a31;\n\t\tr[3] = idet * a12;\n\t\tr[4] = idet * a22;\n\t\tr[5] = idet * a32;\n\t\tr[6] = idet * a13;\n\t\tr[7] = idet * a23;\n\t\tr[8] = idet * a33;\n\t\treturn this;\n\t}\n\n\tgetTranslation(t = new Vec3()) {\n\t\treturn t.set(this.data[12], this.data[13], this.data[14]);\n\t}\n\n\tgetX(x = new Vec3()) {\n\t\treturn x.set(this.data[0], this.data[1], this.data[2]);\n\t}\n\n\tgetY(y = new Vec3()) {\n\t\treturn y.set(this.data[4], this.data[5], this.data[6]);\n\t}\n\n\tgetZ(z = new Vec3()) {\n\t\treturn z.set(this.data[8], this.data[9], this.data[10]);\n\t}\n\n\tgetScale(scale = new Vec3()) {\n\t\tthis.getX(x);\n\t\tthis.getY(y);\n\t\tthis.getZ(z);\n\t\tscale.set(x.length(), y.length(), z.length());\n\t\treturn scale;\n\t}\n\n\tsetFromEulerAngles(ex, ey, ez) {\n\t\tex *= math.DEG_TO_RAD;\n\t\tey *= math.DEG_TO_RAD;\n\t\tez *= math.DEG_TO_RAD;\n\t\tconst s1 = Math.sin(-ex);\n\t\tconst c1 = Math.cos(-ex);\n\t\tconst s2 = Math.sin(-ey);\n\t\tconst c2 = Math.cos(-ey);\n\t\tconst s3 = Math.sin(-ez);\n\t\tconst c3 = Math.cos(-ez);\n\t\tconst m = this.data;\n\t\tm[0] = c2 * c3;\n\t\tm[1] = -c2 * s3;\n\t\tm[2] = s2;\n\t\tm[3] = 0;\n\t\tm[4] = c1 * s3 + c3 * s1 * s2;\n\t\tm[5] = c1 * c3 - s1 * s2 * s3;\n\t\tm[6] = -c2 * s1;\n\t\tm[7] = 0;\n\t\tm[8] = s1 * s3 - c1 * c3 * s2;\n\t\tm[9] = c3 * s1 + c1 * s2 * s3;\n\t\tm[10] = c1 * c2;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\n\tgetEulerAngles(eulers = new Vec3()) {\n\t\tthis.getScale(scale);\n\t\tconst sx = scale.x;\n\t\tconst sy = scale.y;\n\t\tconst sz = scale.z;\n\t\tif (sx === 0 || sy === 0 || sz === 0) return eulers.set(0, 0, 0);\n\t\tconst m = this.data;\n\t\tconst y = Math.asin(-m[2] / sx);\n\t\tconst halfPi = Math.PI * 0.5;\n\t\tlet x, z;\n\n\t\tif (y < halfPi) {\n\t\t\tif (y > -halfPi) {\n\t\t\t\tx = Math.atan2(m[6] / sy, m[10] / sz);\n\t\t\t\tz = Math.atan2(m[1] / sx, m[0] / sx);\n\t\t\t} else {\n\t\t\t\tz = 0;\n\t\t\t\tx = -Math.atan2(m[4] / sy, m[5] / sy);\n\t\t\t}\n\t\t} else {\n\t\t\tz = 0;\n\t\t\tx = Math.atan2(m[4] / sy, m[5] / sy);\n\t\t}\n\n\t\treturn eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);\n\t}\n\n\ttoString() {\n\t\tlet t = '[';\n\n\t\tfor (let i = 0; i < 16; i += 1) {\n\t\t\tt += this.data[i];\n\t\t\tt += i !== 15 ? ', ' : '';\n\t\t}\n\n\t\tt += ']';\n\t\treturn t;\n\t}\n\n}\n\nMat4.IDENTITY = Object.freeze(new Mat4());\nMat4.ZERO = Object.freeze(new Mat4().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));\n\nclass Quat {\n\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\tif (x.length === 4) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t\tthis.w = x[3];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tclone() {\n\t\treturn new Quat(this.x, this.y, this.z, this.w);\n\t}\n\n\tconjugate() {\n\t\tthis.x *= -1;\n\t\tthis.y *= -1;\n\t\tthis.z *= -1;\n\t\treturn this;\n\t}\n\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\tthis.w = rhs.w;\n\t\treturn this;\n\t}\n\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n\t}\n\n\tgetAxisAngle(axis) {\n\t\tlet rad = Math.acos(this.w) * 2;\n\t\tconst s = Math.sin(rad / 2);\n\n\t\tif (s !== 0) {\n\t\t\taxis.x = this.x / s;\n\t\t\taxis.y = this.y / s;\n\t\t\taxis.z = this.z / s;\n\n\t\t\tif (axis.x < 0 || axis.y < 0 || axis.z < 0) {\n\t\t\t\taxis.x *= -1;\n\t\t\t\taxis.y *= -1;\n\t\t\t\taxis.z *= -1;\n\t\t\t\trad *= -1;\n\t\t\t}\n\t\t} else {\n\t\t\taxis.x = 1;\n\t\t\taxis.y = 0;\n\t\t\taxis.z = 0;\n\t\t}\n\n\t\treturn rad * math.RAD_TO_DEG;\n\t}\n\n\tgetEulerAngles(eulers = new Vec3()) {\n\t\tlet x, y, z;\n\t\tconst qx = this.x;\n\t\tconst qy = this.y;\n\t\tconst qz = this.z;\n\t\tconst qw = this.w;\n\t\tconst a2 = 2 * (qw * qy - qx * qz);\n\n\t\tif (a2 <= -0.99999) {\n\t\t\tx = 2 * Math.atan2(qx, qw);\n\t\t\ty = -Math.PI / 2;\n\t\t\tz = 0;\n\t\t} else if (a2 >= 0.99999) {\n\t\t\tx = 2 * Math.atan2(qx, qw);\n\t\t\ty = Math.PI / 2;\n\t\t\tz = 0;\n\t\t} else {\n\t\t\tx = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));\n\t\t\ty = Math.asin(a2);\n\t\t\tz = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));\n\t\t}\n\n\t\treturn eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);\n\t}\n\n\tinvert() {\n\t\treturn this.conjugate().normalize();\n\t}\n\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t}\n\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t}\n\n\tmul(rhs) {\n\t\tconst q1x = this.x;\n\t\tconst q1y = this.y;\n\t\tconst q1z = this.z;\n\t\tconst q1w = this.w;\n\t\tconst q2x = rhs.x;\n\t\tconst q2y = rhs.y;\n\t\tconst q2z = rhs.z;\n\t\tconst q2w = rhs.w;\n\t\tthis.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n\t\tthis.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n\t\tthis.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n\t\tthis.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n\t\treturn this;\n\t}\n\n\tmul2(lhs, rhs) {\n\t\tconst q1x = lhs.x;\n\t\tconst q1y = lhs.y;\n\t\tconst q1z = lhs.z;\n\t\tconst q1w = lhs.w;\n\t\tconst q2x = rhs.x;\n\t\tconst q2y = rhs.y;\n\t\tconst q2z = rhs.z;\n\t\tconst q2w = rhs.w;\n\t\tthis.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n\t\tthis.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n\t\tthis.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n\t\tthis.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n\t\treturn this;\n\t}\n\n\tnormalize() {\n\t\tlet len = this.length();\n\n\t\tif (len === 0) {\n\t\t\tthis.x = this.y = this.z = 0;\n\t\t\tthis.w = 1;\n\t\t} else {\n\t\t\tlen = 1 / len;\n\t\t\tthis.x *= len;\n\t\t\tthis.y *= len;\n\t\t\tthis.z *= len;\n\t\t\tthis.w *= len;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tset(x, y, z, w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\n\tsetFromAxisAngle(axis, angle) {\n\t\tangle *= 0.5 * math.DEG_TO_RAD;\n\t\tconst sa = Math.sin(angle);\n\t\tconst ca = Math.cos(angle);\n\t\tthis.x = sa * axis.x;\n\t\tthis.y = sa * axis.y;\n\t\tthis.z = sa * axis.z;\n\t\tthis.w = ca;\n\t\treturn this;\n\t}\n\n\tsetFromEulerAngles(ex, ey, ez) {\n\t\tconst halfToRad = 0.5 * math.DEG_TO_RAD;\n\t\tex *= halfToRad;\n\t\tey *= halfToRad;\n\t\tez *= halfToRad;\n\t\tconst sx = Math.sin(ex);\n\t\tconst cx = Math.cos(ex);\n\t\tconst sy = Math.sin(ey);\n\t\tconst cy = Math.cos(ey);\n\t\tconst sz = Math.sin(ez);\n\t\tconst cz = Math.cos(ez);\n\t\tthis.x = sx * cy * cz - cx * sy * sz;\n\t\tthis.y = cx * sy * cz + sx * cy * sz;\n\t\tthis.z = cx * cy * sz - sx * sy * cz;\n\t\tthis.w = cx * cy * cz + sx * sy * sz;\n\t\treturn this;\n\t}\n\n\tsetFromMat4(m) {\n\t\tlet m00, m01, m02, m10, m11, m12, m20, m21, m22, s, rs, lx, ly, lz;\n\t\tm = m.data;\n\t\tm00 = m[0];\n\t\tm01 = m[1];\n\t\tm02 = m[2];\n\t\tm10 = m[4];\n\t\tm11 = m[5];\n\t\tm12 = m[6];\n\t\tm20 = m[8];\n\t\tm21 = m[9];\n\t\tm22 = m[10];\n\t\tlx = m00 * m00 + m01 * m01 + m02 * m02;\n\t\tif (lx === 0) return this;\n\t\tlx = 1 / Math.sqrt(lx);\n\t\tly = m10 * m10 + m11 * m11 + m12 * m12;\n\t\tif (ly === 0) return this;\n\t\tly = 1 / Math.sqrt(ly);\n\t\tlz = m20 * m20 + m21 * m21 + m22 * m22;\n\t\tif (lz === 0) return this;\n\t\tlz = 1 / Math.sqrt(lz);\n\t\tm00 *= lx;\n\t\tm01 *= lx;\n\t\tm02 *= lx;\n\t\tm10 *= ly;\n\t\tm11 *= ly;\n\t\tm12 *= ly;\n\t\tm20 *= lz;\n\t\tm21 *= lz;\n\t\tm22 *= lz;\n\t\tconst tr = m00 + m11 + m22;\n\n\t\tif (tr >= 0) {\n\t\t\ts = Math.sqrt(tr + 1);\n\t\t\tthis.w = s * 0.5;\n\t\t\ts = 0.5 / s;\n\t\t\tthis.x = (m12 - m21) * s;\n\t\t\tthis.y = (m20 - m02) * s;\n\t\t\tthis.z = (m01 - m10) * s;\n\t\t} else {\n\t\t\tif (m00 > m11) {\n\t\t\t\tif (m00 > m22) {\n\t\t\t\t\trs = m00 - (m11 + m22) + 1;\n\t\t\t\t\trs = Math.sqrt(rs);\n\t\t\t\t\tthis.x = rs * 0.5;\n\t\t\t\t\trs = 0.5 / rs;\n\t\t\t\t\tthis.w = (m12 - m21) * rs;\n\t\t\t\t\tthis.y = (m01 + m10) * rs;\n\t\t\t\t\tthis.z = (m02 + m20) * rs;\n\t\t\t\t} else {\n\t\t\t\t\trs = m22 - (m00 + m11) + 1;\n\t\t\t\t\trs = Math.sqrt(rs);\n\t\t\t\t\tthis.z = rs * 0.5;\n\t\t\t\t\trs = 0.5 / rs;\n\t\t\t\t\tthis.w = (m01 - m10) * rs;\n\t\t\t\t\tthis.x = (m20 + m02) * rs;\n\t\t\t\t\tthis.y = (m21 + m12) * rs;\n\t\t\t\t}\n\t\t\t} else if (m11 > m22) {\n\t\t\t\trs = m11 - (m22 + m00) + 1;\n\t\t\t\trs = Math.sqrt(rs);\n\t\t\t\tthis.y = rs * 0.5;\n\t\t\t\trs = 0.5 / rs;\n\t\t\t\tthis.w = (m20 - m02) * rs;\n\t\t\t\tthis.z = (m12 + m21) * rs;\n\t\t\t\tthis.x = (m10 + m01) * rs;\n\t\t\t} else {\n\t\t\t\trs = m22 - (m00 + m11) + 1;\n\t\t\t\trs = Math.sqrt(rs);\n\t\t\t\tthis.z = rs * 0.5;\n\t\t\t\trs = 0.5 / rs;\n\t\t\t\tthis.w = (m01 - m10) * rs;\n\t\t\t\tthis.x = (m20 + m02) * rs;\n\t\t\t\tthis.y = (m21 + m12) * rs;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tslerp(lhs, rhs, alpha) {\n\t\tconst lx = lhs.x;\n\t\tconst ly = lhs.y;\n\t\tconst lz = lhs.z;\n\t\tconst lw = lhs.w;\n\t\tlet rx = rhs.x;\n\t\tlet ry = rhs.y;\n\t\tlet rz = rhs.z;\n\t\tlet rw = rhs.w;\n\t\tlet cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;\n\n\t\tif (cosHalfTheta < 0) {\n\t\t\trw = -rw;\n\t\t\trx = -rx;\n\t\t\try = -ry;\n\t\t\trz = -rz;\n\t\t\tcosHalfTheta = -cosHalfTheta;\n\t\t}\n\n\t\tif (Math.abs(cosHalfTheta) >= 1) {\n\t\t\tthis.w = lw;\n\t\t\tthis.x = lx;\n\t\t\tthis.y = ly;\n\t\t\tthis.z = lz;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst halfTheta = Math.acos(cosHalfTheta);\n\t\tconst sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);\n\n\t\tif (Math.abs(sinHalfTheta) < 0.001) {\n\t\t\tthis.w = lw * 0.5 + rw * 0.5;\n\t\t\tthis.x = lx * 0.5 + rx * 0.5;\n\t\t\tthis.y = ly * 0.5 + ry * 0.5;\n\t\t\tthis.z = lz * 0.5 + rz * 0.5;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;\n\t\tconst ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;\n\t\tthis.w = lw * ratioA + rw * ratioB;\n\t\tthis.x = lx * ratioA + rx * ratioB;\n\t\tthis.y = ly * ratioA + ry * ratioB;\n\t\tthis.z = lz * ratioA + rz * ratioB;\n\t\treturn this;\n\t}\n\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst x = vec.x,\n\t\t\t\t\ty = vec.y,\n\t\t\t\t\tz = vec.z;\n\t\tconst qx = this.x,\n\t\t\t\t\tqy = this.y,\n\t\t\t\t\tqz = this.z,\n\t\t\t\t\tqw = this.w;\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = -qx * x - qy * y - qz * z;\n\t\tres.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\tres.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\tres.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\t\treturn res;\n\t}\n\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n\t}\n\n}\n\nQuat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));\nQuat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));\n\nconst tmpVecA$2 = new Vec3();\nconst tmpVecB$1 = new Vec3();\nconst tmpVecC = new Vec3();\nconst tmpVecD = new Vec3();\nconst tmpVecE = new Vec3();\n\nclass BoundingBox {\n\tconstructor(center = new Vec3(), halfExtents = new Vec3(0.5, 0.5, 0.5)) {\n\t\tthis.center = center;\n\t\tthis.halfExtents = halfExtents;\n\t\tthis._min = new Vec3();\n\t\tthis._max = new Vec3();\n\t}\n\n\tadd(other) {\n\t\tconst tc = this.center;\n\t\tconst tcx = tc.x;\n\t\tconst tcy = tc.y;\n\t\tconst tcz = tc.z;\n\t\tconst th = this.halfExtents;\n\t\tconst thx = th.x;\n\t\tconst thy = th.y;\n\t\tconst thz = th.z;\n\t\tlet tminx = tcx - thx;\n\t\tlet tmaxx = tcx + thx;\n\t\tlet tminy = tcy - thy;\n\t\tlet tmaxy = tcy + thy;\n\t\tlet tminz = tcz - thz;\n\t\tlet tmaxz = tcz + thz;\n\t\tconst oc = other.center;\n\t\tconst ocx = oc.x;\n\t\tconst ocy = oc.y;\n\t\tconst ocz = oc.z;\n\t\tconst oh = other.halfExtents;\n\t\tconst ohx = oh.x;\n\t\tconst ohy = oh.y;\n\t\tconst ohz = oh.z;\n\t\tconst ominx = ocx - ohx;\n\t\tconst omaxx = ocx + ohx;\n\t\tconst ominy = ocy - ohy;\n\t\tconst omaxy = ocy + ohy;\n\t\tconst ominz = ocz - ohz;\n\t\tconst omaxz = ocz + ohz;\n\t\tif (ominx < tminx) tminx = ominx;\n\t\tif (omaxx > tmaxx) tmaxx = omaxx;\n\t\tif (ominy < tminy) tminy = ominy;\n\t\tif (omaxy > tmaxy) tmaxy = omaxy;\n\t\tif (ominz < tminz) tminz = ominz;\n\t\tif (omaxz > tmaxz) tmaxz = omaxz;\n\t\ttc.x = (tminx + tmaxx) * 0.5;\n\t\ttc.y = (tminy + tmaxy) * 0.5;\n\t\ttc.z = (tminz + tmaxz) * 0.5;\n\t\tth.x = (tmaxx - tminx) * 0.5;\n\t\tth.y = (tmaxy - tminy) * 0.5;\n\t\tth.z = (tmaxz - tminz) * 0.5;\n\t}\n\n\tcopy(src) {\n\t\tthis.center.copy(src.center);\n\t\tthis.halfExtents.copy(src.halfExtents);\n\t}\n\n\tclone() {\n\t\treturn new BoundingBox(this.center.clone(), this.halfExtents.clone());\n\t}\n\n\tintersects(other) {\n\t\tconst aMax = this.getMax();\n\t\tconst aMin = this.getMin();\n\t\tconst bMax = other.getMax();\n\t\tconst bMin = other.getMin();\n\t\treturn aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;\n\t}\n\n\t_intersectsRay(ray, point) {\n\t\tconst tMin = tmpVecA$2.copy(this.getMin()).sub(ray.origin);\n\t\tconst tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);\n\t\tconst dir = ray.direction;\n\n\t\tif (dir.x === 0) {\n\t\t\ttMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.x /= dir.x;\n\t\t\ttMax.x /= dir.x;\n\t\t}\n\n\t\tif (dir.y === 0) {\n\t\t\ttMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.y /= dir.y;\n\t\t\ttMax.y /= dir.y;\n\t\t}\n\n\t\tif (dir.z === 0) {\n\t\t\ttMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.z /= dir.z;\n\t\t\ttMax.z /= dir.z;\n\t\t}\n\n\t\tconst realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));\n\t\tconst realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));\n\t\tconst minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);\n\t\tconst maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);\n\t\tconst intersects = minMax >= maxMin && maxMin >= 0;\n\t\tif (intersects) point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);\n\t\treturn intersects;\n\t}\n\n\t_fastIntersectsRay(ray) {\n\t\tconst diff = tmpVecA$2;\n\t\tconst cross = tmpVecB$1;\n\t\tconst prod = tmpVecC;\n\t\tconst absDiff = tmpVecD;\n\t\tconst absDir = tmpVecE;\n\t\tconst rayDir = ray.direction;\n\t\tdiff.sub2(ray.origin, this.center);\n\t\tabsDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));\n\t\tprod.mul2(diff, rayDir);\n\t\tif (absDiff.x > this.halfExtents.x && prod.x >= 0) return false;\n\t\tif (absDiff.y > this.halfExtents.y && prod.y >= 0) return false;\n\t\tif (absDiff.z > this.halfExtents.z && prod.z >= 0) return false;\n\t\tabsDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));\n\t\tcross.cross(rayDir, diff);\n\t\tcross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));\n\t\tif (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) return false;\n\t\tif (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) return false;\n\t\tif (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) return false;\n\t\treturn true;\n\t}\n\n\tintersectsRay(ray, point) {\n\t\tif (point) {\n\t\t\treturn this._intersectsRay(ray, point);\n\t\t}\n\n\t\treturn this._fastIntersectsRay(ray);\n\t}\n\n\tsetMinMax(min, max) {\n\t\tthis.center.add2(max, min).mulScalar(0.5);\n\t\tthis.halfExtents.sub2(max, min).mulScalar(0.5);\n\t}\n\n\tgetMin() {\n\t\treturn this._min.copy(this.center).sub(this.halfExtents);\n\t}\n\n\tgetMax() {\n\t\treturn this._max.copy(this.center).add(this.halfExtents);\n\t}\n\n\tcontainsPoint(point) {\n\t\tconst min = this.getMin();\n\t\tconst max = this.getMax();\n\n\t\tif (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tsetFromTransformedAabb(aabb, m, ignoreScale = false) {\n\t\tconst ac = aabb.center;\n\t\tconst ar = aabb.halfExtents;\n\t\tconst d = m.data;\n\t\tlet mx0 = d[0];\n\t\tlet mx1 = d[4];\n\t\tlet mx2 = d[8];\n\t\tlet my0 = d[1];\n\t\tlet my1 = d[5];\n\t\tlet my2 = d[9];\n\t\tlet mz0 = d[2];\n\t\tlet mz1 = d[6];\n\t\tlet mz2 = d[10];\n\n\t\tif (ignoreScale) {\n\t\t\tlet lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;\n\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmx0 *= invLength;\n\t\t\t\tmx1 *= invLength;\n\t\t\t\tmx2 *= invLength;\n\t\t\t}\n\n\t\t\tlengthSq = my0 * my0 + my1 * my1 + my2 * my2;\n\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmy0 *= invLength;\n\t\t\t\tmy1 *= invLength;\n\t\t\t\tmy2 *= invLength;\n\t\t\t}\n\n\t\t\tlengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;\n\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmz0 *= invLength;\n\t\t\t\tmz1 *= invLength;\n\t\t\t\tmz2 *= invLength;\n\t\t\t}\n\t\t}\n\n\t\tthis.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);\n\t\tthis.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);\n\t}\n\n\tcompute(vertices, numVerts) {\n\t\tnumVerts = numVerts === undefined ? vertices.length / 3 : numVerts;\n\n\t\tif (numVerts > 0) {\n\t\t\tconst min = tmpVecA$2.set(vertices[0], vertices[1], vertices[2]);\n\t\t\tconst max = tmpVecB$1.set(vertices[0], vertices[1], vertices[2]);\n\n\t\t\tfor (let i = 1; i < numVerts; i++) {\n\t\t\t\tconst x = vertices[i * 3 + 0];\n\t\t\t\tconst y = vertices[i * 3 + 1];\n\t\t\t\tconst z = vertices[i * 3 + 2];\n\t\t\t\tif (x < min.x) min.x = x;\n\t\t\t\tif (y < min.y) min.y = y;\n\t\t\t\tif (z < min.z) min.z = z;\n\t\t\t\tif (x > max.x) max.x = x;\n\t\t\t\tif (y > max.y) max.y = y;\n\t\t\t\tif (z > max.z) max.z = z;\n\t\t\t}\n\n\t\t\tthis.setMinMax(min, max);\n\t\t}\n\t}\n\n\tintersectsBoundingSphere(sphere) {\n\t\tconst sq = this._distanceToBoundingSphereSq(sphere);\n\n\t\tif (sq <= sphere.radius * sphere.radius) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_distanceToBoundingSphereSq(sphere) {\n\t\tconst boxMin = this.getMin();\n\t\tconst boxMax = this.getMax();\n\t\tlet sq = 0;\n\t\tconst axis = ['x', 'y', 'z'];\n\n\t\tfor (let i = 0; i < 3; ++i) {\n\t\t\tlet out = 0;\n\t\t\tconst pn = sphere.center[axis[i]];\n\t\t\tconst bMin = boxMin[axis[i]];\n\t\t\tconst bMax = boxMax[axis[i]];\n\t\t\tlet val = 0;\n\n\t\t\tif (pn < bMin) {\n\t\t\t\tval = bMin - pn;\n\t\t\t\tout += val * val;\n\t\t\t}\n\n\t\t\tif (pn > bMax) {\n\t\t\t\tval = pn - bMax;\n\t\t\t\tout += val * val;\n\t\t\t}\n\n\t\t\tsq += out;\n\t\t}\n\n\t\treturn sq;\n\t}\n\n\t_expand(expandMin, expandMax) {\n\t\ttmpVecA$2.add2(this.getMin(), expandMin);\n\t\ttmpVecB$1.add2(this.getMax(), expandMax);\n\t\tthis.setMinMax(tmpVecA$2, tmpVecB$1);\n\t}\n\n}\n\nconst tmpVecA$1 = new Vec3();\nconst tmpVecB = new Vec3();\n\nclass BoundingSphere {\n\tconstructor(center = new Vec3(), radius = 0.5) {\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t}\n\n\tcontainsPoint(point) {\n\t\tconst lenSq = tmpVecA$1.sub2(point, this.center).lengthSq();\n\t\tconst r = this.radius;\n\t\treturn lenSq < r * r;\n\t}\n\n\tintersectsRay(ray, point) {\n\t\tconst m = tmpVecA$1.copy(ray.origin).sub(this.center);\n\t\tconst b = m.dot(tmpVecB.copy(ray.direction).normalize());\n\t\tconst c = m.dot(m) - this.radius * this.radius;\n\t\tif (c > 0 && b > 0) return false;\n\t\tconst discr = b * b - c;\n\t\tif (discr < 0) return false;\n\t\tconst t = Math.abs(-b - Math.sqrt(discr));\n\t\tif (point) point.copy(ray.direction).mulScalar(t).add(ray.origin);\n\t\treturn true;\n\t}\n\n\tintersectsBoundingSphere(sphere) {\n\t\ttmpVecA$1.sub2(sphere.center, this.center);\n\t\tconst totalRadius = sphere.radius + this.radius;\n\n\t\tif (tmpVecA$1.lengthSq() <= totalRadius * totalRadius) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nconst BLEND_SUBTRACTIVE = 0;\nconst BLEND_ADDITIVE = 1;\nconst BLEND_NORMAL = 2;\nconst BLEND_NONE = 3;\nconst BLEND_PREMULTIPLIED = 4;\nconst BLEND_MULTIPLICATIVE = 5;\nconst BLEND_ADDITIVEALPHA = 6;\nconst BLEND_MULTIPLICATIVE2X = 7;\nconst BLEND_SCREEN = 8;\nconst BLEND_MIN = 9;\nconst BLEND_MAX = 10;\nconst FOG_NONE = 'none';\nconst FOG_LINEAR = 'linear';\nconst FOG_EXP = 'exp';\nconst FOG_EXP2 = 'exp2';\nconst FRESNEL_NONE = 0;\nconst FRESNEL_SCHLICK = 2;\nconst LAYER_HUD = 0;\nconst LAYER_GIZMO = 1;\nconst LAYER_FX = 2;\nconst LAYER_WORLD = 15;\nconst LAYERID_WORLD = 0;\nconst LAYERID_DEPTH = 1;\nconst LAYERID_SKYBOX = 2;\nconst LAYERID_IMMEDIATE = 3;\nconst LAYERID_UI = 4;\nconst LIGHTTYPE_DIRECTIONAL = 0;\nconst LIGHTTYPE_OMNI = 1;\nconst LIGHTTYPE_POINT = LIGHTTYPE_OMNI;\nconst LIGHTTYPE_SPOT = 2;\nconst LIGHTSHAPE_PUNCTUAL = 0;\nconst LIGHTSHAPE_RECT = 1;\nconst LIGHTSHAPE_DISK = 2;\nconst LIGHTSHAPE_SPHERE = 3;\nconst LIGHTFALLOFF_LINEAR = 0;\nconst LIGHTFALLOFF_INVERSESQUARED = 1;\nconst SHADOW_PCF3 = 0;\nconst SHADOW_DEPTH = 0;\nconst SHADOW_VSM8 = 1;\nconst SHADOW_VSM16 = 2;\nconst SHADOW_VSM32 = 3;\nconst SHADOW_PCF5 = 4;\nconst SHADOW_PCF1 = 5;\nconst SHADOW_COUNT = 6;\nconst shadowTypeToString = {};\nshadowTypeToString[SHADOW_PCF3] = \"PCF3\";\nshadowTypeToString[SHADOW_VSM8] = \"VSM8\";\nshadowTypeToString[SHADOW_VSM16] = \"VSM16\";\nshadowTypeToString[SHADOW_VSM32] = \"VSM32\";\nshadowTypeToString[SHADOW_PCF5] = \"PCF5\";\nshadowTypeToString[SHADOW_PCF1] = \"PCF1\";\nconst BLUR_BOX = 0;\nconst BLUR_GAUSSIAN = 1;\nconst PARTICLESORT_NONE = 0;\nconst PARTICLESORT_DISTANCE = 1;\nconst PARTICLESORT_NEWER_FIRST = 2;\nconst PARTICLESORT_OLDER_FIRST = 3;\nconst PARTICLEMODE_GPU = 0;\nconst PARTICLEMODE_CPU = 1;\nconst EMITTERSHAPE_BOX = 0;\nconst EMITTERSHAPE_SPHERE = 1;\nconst PARTICLEORIENTATION_SCREEN = 0;\nconst PARTICLEORIENTATION_WORLD = 1;\nconst PARTICLEORIENTATION_EMITTER = 2;\nconst PROJECTION_PERSPECTIVE = 0;\nconst PROJECTION_ORTHOGRAPHIC = 1;\nconst RENDERSTYLE_SOLID = 0;\nconst RENDERSTYLE_WIREFRAME = 1;\nconst RENDERSTYLE_POINTS = 2;\nconst CUBEPROJ_NONE = 0;\nconst CUBEPROJ_BOX = 1;\nconst SPECULAR_PHONG = 0;\nconst SPECULAR_BLINN = 1;\nconst DETAILMODE_MUL = 'mul';\nconst DETAILMODE_ADD = 'add';\nconst DETAILMODE_SCREEN = 'screen';\nconst DETAILMODE_OVERLAY = 'overlay';\nconst DETAILMODE_MIN = 'min';\nconst DETAILMODE_MAX = 'max';\nconst GAMMA_NONE = 0;\nconst GAMMA_SRGB = 1;\nconst GAMMA_SRGBFAST = 2;\nconst GAMMA_SRGBHDR = 3;\nconst TONEMAP_LINEAR = 0;\nconst TONEMAP_FILMIC = 1;\nconst TONEMAP_HEJL = 2;\nconst TONEMAP_ACES = 3;\nconst TONEMAP_ACES2 = 4;\nconst SPECOCC_NONE = 0;\nconst SPECOCC_AO = 1;\nconst SPECOCC_GLOSSDEPENDENT = 2;\nconst SHADERDEF_NOSHADOW = 1;\nconst SHADERDEF_SKIN = 2;\nconst SHADERDEF_UV0 = 4;\nconst SHADERDEF_UV1 = 8;\nconst SHADERDEF_VCOLOR = 16;\nconst SHADERDEF_INSTANCING = 32;\nconst SHADERDEF_LM = 64;\nconst SHADERDEF_DIRLM = 128;\nconst SHADERDEF_SCREENSPACE = 256;\nconst SHADERDEF_TANGENTS = 512;\nconst SHADERDEF_MORPH_POSITION = 1024;\nconst SHADERDEF_MORPH_NORMAL = 2048;\nconst SHADERDEF_MORPH_TEXTURE_BASED = 4096;\nconst SHADERDEF_LMAMBIENT = 8192;\nconst LINEBATCH_WORLD = 0;\nconst LINEBATCH_OVERLAY = 1;\nconst LINEBATCH_GIZMO = 2;\nconst SHADOWUPDATE_NONE = 0;\nconst SHADOWUPDATE_THISFRAME = 1;\nconst SHADOWUPDATE_REALTIME = 2;\nconst SORTKEY_FORWARD = 0;\nconst SORTKEY_DEPTH = 1;\nconst MASK_AFFECT_DYNAMIC = 1;\nconst MASK_AFFECT_LIGHTMAPPED = 2;\nconst MASK_BAKE = 4;\nconst SHADER_FORWARD = 0;\nconst SHADER_FORWARDHDR = 1;\nconst SHADER_DEPTH = 2;\nconst SHADER_SHADOW = 3;\nconst SHADER_PICK = 18;\nconst SPRITE_RENDERMODE_SIMPLE = 0;\nconst SPRITE_RENDERMODE_SLICED = 1;\nconst SPRITE_RENDERMODE_TILED = 2;\nconst BAKE_COLOR = 0;\nconst BAKE_COLORDIR = 1;\nconst VIEW_CENTER = 0;\nconst VIEW_LEFT = 1;\nconst VIEW_RIGHT = 2;\nconst SORTMODE_NONE = 0;\nconst SORTMODE_MANUAL = 1;\nconst SORTMODE_MATERIALMESH = 2;\nconst SORTMODE_BACK2FRONT = 3;\nconst SORTMODE_FRONT2BACK = 4;\nconst SORTMODE_CUSTOM = 5;\nconst COMPUPDATED_INSTANCES = 1;\nconst COMPUPDATED_LIGHTS = 2;\nconst COMPUPDATED_CAMERAS = 4;\nconst COMPUPDATED_BLEND = 8;\nconst ASPECT_AUTO = 0;\nconst ASPECT_MANUAL = 1;\nconst ORIENTATION_HORIZONTAL = 0;\nconst ORIENTATION_VERTICAL = 1;\n\nconst _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\nclass Frustum {\n\tconstructor() {\n\t\tthis.planes = [];\n\n\t\tfor (let i = 0; i < 6; i++) this.planes[i] = [];\n\t}\n\n\tsetFromMat4(matrix) {\n\t\tconst vpm = matrix.data;\n\t\tlet plane;\n\t\tconst planes = this.planes;\n\t\tplane = planes[0];\n\t\tplane[0] = vpm[3] - vpm[0];\n\t\tplane[1] = vpm[7] - vpm[4];\n\t\tplane[2] = vpm[11] - vpm[8];\n\t\tplane[3] = vpm[15] - vpm[12];\n\t\tlet t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[1];\n\t\tplane[0] = vpm[3] + vpm[0];\n\t\tplane[1] = vpm[7] + vpm[4];\n\t\tplane[2] = vpm[11] + vpm[8];\n\t\tplane[3] = vpm[15] + vpm[12];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[2];\n\t\tplane[0] = vpm[3] + vpm[1];\n\t\tplane[1] = vpm[7] + vpm[5];\n\t\tplane[2] = vpm[11] + vpm[9];\n\t\tplane[3] = vpm[15] + vpm[13];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[3];\n\t\tplane[0] = vpm[3] - vpm[1];\n\t\tplane[1] = vpm[7] - vpm[5];\n\t\tplane[2] = vpm[11] - vpm[9];\n\t\tplane[3] = vpm[15] - vpm[13];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[4];\n\t\tplane[0] = vpm[3] - vpm[2];\n\t\tplane[1] = vpm[7] - vpm[6];\n\t\tplane[2] = vpm[11] - vpm[10];\n\t\tplane[3] = vpm[15] - vpm[14];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[5];\n\t\tplane[0] = vpm[3] + vpm[2];\n\t\tplane[1] = vpm[7] + vpm[6];\n\t\tplane[2] = vpm[11] + vpm[10];\n\t\tplane[3] = vpm[15] + vpm[14];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t}\n\n\tcontainsPoint(point) {\n\t\tlet p, plane;\n\n\t\tfor (p = 0; p < 6; p++) {\n\t\t\tplane = this.planes[p];\n\n\t\t\tif (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tcontainsSphere(sphere) {\n\t\tlet c = 0;\n\t\tlet d;\n\t\tlet p;\n\t\tconst sr = sphere.radius;\n\t\tconst sc = sphere.center;\n\t\tconst scx = sc.x;\n\t\tconst scy = sc.y;\n\t\tconst scz = sc.z;\n\t\tconst planes = this.planes;\n\t\tlet plane;\n\n\t\tfor (p = 0; p < 6; p++) {\n\t\t\tplane = planes[p];\n\t\t\td = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];\n\t\t\tif (d <= -sr) return 0;\n\t\t\tif (d > sr) c++;\n\t\t}\n\n\t\treturn c === 6 ? 2 : 1;\n\t}\n\n\tstatic getPoints(camera, near, far) {\n\t\tnear = near || camera._nearClip;\n\t\tfar = far || camera._farClip;\n\t\tconst fov = camera._fov * Math.PI / 180.0;\n\t\tlet y = camera._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : camera._orthoHeight;\n\t\tlet x = y * camera._aspectRatio;\n\t\tconst points = _frustumPoints;\n\t\tpoints[0].x = x;\n\t\tpoints[0].y = -y;\n\t\tpoints[0].z = -near;\n\t\tpoints[1].x = x;\n\t\tpoints[1].y = y;\n\t\tpoints[1].z = -near;\n\t\tpoints[2].x = -x;\n\t\tpoints[2].y = y;\n\t\tpoints[2].z = -near;\n\t\tpoints[3].x = -x;\n\t\tpoints[3].y = -y;\n\t\tpoints[3].z = -near;\n\n\t\tif (camera._projection === PROJECTION_PERSPECTIVE) {\n\t\t\ty = Math.tan(fov / 2.0) * far;\n\t\t\tx = y * camera._aspectRatio;\n\t\t}\n\n\t\tpoints[4].x = x;\n\t\tpoints[4].y = -y;\n\t\tpoints[4].z = -far;\n\t\tpoints[5].x = x;\n\t\tpoints[5].y = y;\n\t\tpoints[5].z = -far;\n\t\tpoints[6].x = -x;\n\t\tpoints[6].y = y;\n\t\tpoints[6].z = -far;\n\t\tpoints[7].x = -x;\n\t\tpoints[7].y = -y;\n\t\tpoints[7].z = -far;\n\t\treturn points;\n\t}\n\n}\n\nclass Ray {\n\tconstructor(origin = new Vec3(), direction = new Vec3(0, 0, -1)) {\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\t}\n\n\tset(origin, direction) {\n\t\tthis.origin.copy(origin);\n\t\tthis.direction.copy(direction);\n\t\treturn this;\n\t}\n\n}\n\nconst tmpRay = new Ray();\nconst tmpVec3$2 = new Vec3();\nconst tmpSphere = new BoundingSphere();\nconst tmpMat4$1 = new Mat4();\n\nclass OrientedBox {\n\tconstructor(worldTransform = new Mat4(), halfExtents = new Vec3(0.5, 0.5, 0.5)) {\n\t\tthis.halfExtents = halfExtents;\n\t\tthis._modelTransform = worldTransform.clone().invert();\n\t\tthis._worldTransform = worldTransform.clone();\n\t\tthis._aabb = new BoundingBox(new Vec3(), this.halfExtents);\n\t}\n\n\tset worldTransform(value) {\n\t\tthis._worldTransform.copy(value);\n\n\t\tthis._modelTransform.copy(value).invert();\n\t}\n\n\tget worldTransform() {\n\t\treturn this._worldTransform;\n\t}\n\n\tintersectsRay(ray, point) {\n\t\tthis._modelTransform.transformPoint(ray.origin, tmpRay.origin);\n\n\t\tthis._modelTransform.transformVector(ray.direction, tmpRay.direction);\n\n\t\tif (point) {\n\t\t\tconst result = this._aabb._intersectsRay(tmpRay, point);\n\n\t\t\ttmpMat4$1.copy(this._modelTransform).invert().transformPoint(point, point);\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this._aabb._fastIntersectsRay(tmpRay);\n\t}\n\n\tcontainsPoint(point) {\n\t\tthis._modelTransform.transformPoint(point, tmpVec3$2);\n\n\t\treturn this._aabb.containsPoint(tmpVec3$2);\n\t}\n\n\tintersectsBoundingSphere(sphere) {\n\t\tthis._modelTransform.transformPoint(sphere.center, tmpSphere.center);\n\n\t\ttmpSphere.radius = sphere.radius;\n\n\t\tif (this._aabb.intersectsBoundingSphere(tmpSphere)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nconst tmpVecA = new Vec3();\n\nclass Plane {\n\tconstructor(point = new Vec3(), normal = new Vec3(0, 0, 1)) {\n\t\tthis.normal = normal;\n\t\tthis.point = point;\n\t}\n\n\tintersectsLine(start, end, point) {\n\t\tconst d = -this.normal.dot(this.point);\n\t\tconst d0 = this.normal.dot(start) + d;\n\t\tconst d1 = this.normal.dot(end) + d;\n\t\tconst t = d0 / (d0 - d1);\n\t\tconst intersects = t >= 0 && t <= 1;\n\t\tif (intersects && point) point.lerp(start, end, t);\n\t\treturn intersects;\n\t}\n\n\tintersectsRay(ray, point) {\n\t\tconst pointToOrigin = tmpVecA.sub2(this.point, ray.origin);\n\t\tconst t = this.normal.dot(pointToOrigin) / this.normal.dot(ray.direction);\n\t\tconst intersects = t >= 0;\n\t\tif (intersects && point) point.copy(ray.direction).mulScalar(t).add(ray.origin);\n\t\treturn intersects;\n\t}\n\n}\n\nconst ADDRESS_REPEAT = 0;\nconst ADDRESS_CLAMP_TO_EDGE = 1;\nconst ADDRESS_MIRRORED_REPEAT = 2;\nconst BLENDMODE_ZERO = 0;\nconst BLENDMODE_ONE = 1;\nconst BLENDMODE_SRC_COLOR = 2;\nconst BLENDMODE_ONE_MINUS_SRC_COLOR = 3;\nconst BLENDMODE_DST_COLOR = 4;\nconst BLENDMODE_ONE_MINUS_DST_COLOR = 5;\nconst BLENDMODE_SRC_ALPHA = 6;\nconst BLENDMODE_SRC_ALPHA_SATURATE = 7;\nconst BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;\nconst BLENDMODE_DST_ALPHA = 9;\nconst BLENDMODE_ONE_MINUS_DST_ALPHA = 10;\nconst BLENDEQUATION_ADD = 0;\nconst BLENDEQUATION_SUBTRACT = 1;\nconst BLENDEQUATION_REVERSE_SUBTRACT = 2;\nconst BLENDEQUATION_MIN = 3;\nconst BLENDEQUATION_MAX = 4;\nconst BUFFER_STATIC = 0;\nconst BUFFER_DYNAMIC = 1;\nconst BUFFER_STREAM = 2;\nconst BUFFER_GPUDYNAMIC = 3;\nconst CLEARFLAG_COLOR = 1;\nconst CLEARFLAG_DEPTH = 2;\nconst CLEARFLAG_STENCIL = 4;\nconst CUBEFACE_POSX = 0;\nconst CUBEFACE_NEGX = 1;\nconst CUBEFACE_POSY = 2;\nconst CUBEFACE_NEGY = 3;\nconst CUBEFACE_POSZ = 4;\nconst CUBEFACE_NEGZ = 5;\nconst CULLFACE_NONE = 0;\nconst CULLFACE_BACK = 1;\nconst CULLFACE_FRONT = 2;\nconst CULLFACE_FRONTANDBACK = 3;\nconst FILTER_NEAREST = 0;\nconst FILTER_LINEAR = 1;\nconst FILTER_NEAREST_MIPMAP_NEAREST = 2;\nconst FILTER_NEAREST_MIPMAP_LINEAR = 3;\nconst FILTER_LINEAR_MIPMAP_NEAREST = 4;\nconst FILTER_LINEAR_MIPMAP_LINEAR = 5;\nconst FUNC_NEVER = 0;\nconst FUNC_LESS = 1;\nconst FUNC_EQUAL = 2;\nconst FUNC_LESSEQUAL = 3;\nconst FUNC_GREATER = 4;\nconst FUNC_NOTEQUAL = 5;\nconst FUNC_GREATEREQUAL = 6;\nconst FUNC_ALWAYS = 7;\nconst INDEXFORMAT_UINT8 = 0;\nconst INDEXFORMAT_UINT16 = 1;\nconst INDEXFORMAT_UINT32 = 2;\nconst PIXELFORMAT_A8 = 0;\nconst PIXELFORMAT_L8 = 1;\nconst PIXELFORMAT_L8_A8 = 2;\nconst PIXELFORMAT_R5_G6_B5 = 3;\nconst PIXELFORMAT_R5_G5_B5_A1 = 4;\nconst PIXELFORMAT_R4_G4_B4_A4 = 5;\nconst PIXELFORMAT_R8_G8_B8 = 6;\nconst PIXELFORMAT_R8_G8_B8_A8 = 7;\nconst PIXELFORMAT_DXT1 = 8;\nconst PIXELFORMAT_DXT3 = 9;\nconst PIXELFORMAT_DXT5 = 10;\nconst PIXELFORMAT_RGB16F = 11;\nconst PIXELFORMAT_RGBA16F = 12;\nconst PIXELFORMAT_RGB32F = 13;\nconst PIXELFORMAT_RGBA32F = 14;\nconst PIXELFORMAT_R32F = 15;\nconst PIXELFORMAT_DEPTH = 16;\nconst PIXELFORMAT_DEPTHSTENCIL = 17;\nconst PIXELFORMAT_111110F = 18;\nconst PIXELFORMAT_SRGB = 19;\nconst PIXELFORMAT_SRGBA = 20;\nconst PIXELFORMAT_ETC1 = 21;\nconst PIXELFORMAT_ETC2_RGB = 22;\nconst PIXELFORMAT_ETC2_RGBA = 23;\nconst PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;\nconst PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;\nconst PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;\nconst PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;\nconst PIXELFORMAT_ASTC_4x4 = 28;\nconst PIXELFORMAT_ATC_RGB = 29;\nconst PIXELFORMAT_ATC_RGBA = 30;\nconst PRIMITIVE_POINTS = 0;\nconst PRIMITIVE_LINES = 1;\nconst PRIMITIVE_LINELOOP = 2;\nconst PRIMITIVE_LINESTRIP = 3;\nconst PRIMITIVE_TRIANGLES = 4;\nconst PRIMITIVE_TRISTRIP = 5;\nconst PRIMITIVE_TRIFAN = 6;\nconst SEMANTIC_POSITION = \"POSITION\";\nconst SEMANTIC_NORMAL = \"NORMAL\";\nconst SEMANTIC_TANGENT = \"TANGENT\";\nconst SEMANTIC_BLENDWEIGHT = \"BLENDWEIGHT\";\nconst SEMANTIC_BLENDINDICES = \"BLENDINDICES\";\nconst SEMANTIC_COLOR = \"COLOR\";\nconst SEMANTIC_TEXCOORD = \"TEXCOORD\";\nconst SEMANTIC_TEXCOORD0 = \"TEXCOORD0\";\nconst SEMANTIC_TEXCOORD1 = \"TEXCOORD1\";\nconst SEMANTIC_TEXCOORD2 = \"TEXCOORD2\";\nconst SEMANTIC_TEXCOORD3 = \"TEXCOORD3\";\nconst SEMANTIC_TEXCOORD4 = \"TEXCOORD4\";\nconst SEMANTIC_TEXCOORD5 = \"TEXCOORD5\";\nconst SEMANTIC_TEXCOORD6 = \"TEXCOORD6\";\nconst SEMANTIC_TEXCOORD7 = \"TEXCOORD7\";\nconst SEMANTIC_ATTR = \"ATTR\";\nconst SEMANTIC_ATTR0 = \"ATTR0\";\nconst SEMANTIC_ATTR1 = \"ATTR1\";\nconst SEMANTIC_ATTR2 = \"ATTR2\";\nconst SEMANTIC_ATTR3 = \"ATTR3\";\nconst SEMANTIC_ATTR4 = \"ATTR4\";\nconst SEMANTIC_ATTR5 = \"ATTR5\";\nconst SEMANTIC_ATTR6 = \"ATTR6\";\nconst SEMANTIC_ATTR7 = \"ATTR7\";\nconst SEMANTIC_ATTR8 = \"ATTR8\";\nconst SEMANTIC_ATTR9 = \"ATTR9\";\nconst SEMANTIC_ATTR10 = \"ATTR10\";\nconst SEMANTIC_ATTR11 = \"ATTR11\";\nconst SEMANTIC_ATTR12 = \"ATTR12\";\nconst SEMANTIC_ATTR13 = \"ATTR13\";\nconst SEMANTIC_ATTR14 = \"ATTR14\";\nconst SEMANTIC_ATTR15 = \"ATTR15\";\nconst SHADERTAG_MATERIAL = 1;\nconst STENCILOP_KEEP = 0;\nconst STENCILOP_ZERO = 1;\nconst STENCILOP_REPLACE = 2;\nconst STENCILOP_INCREMENT = 3;\nconst STENCILOP_INCREMENTWRAP = 4;\nconst STENCILOP_DECREMENT = 5;\nconst STENCILOP_DECREMENTWRAP = 6;\nconst STENCILOP_INVERT = 7;\nconst TEXTURELOCK_READ = 1;\nconst TEXTURELOCK_WRITE = 2;\nconst TEXTURETYPE_DEFAULT = 'default';\nconst TEXTURETYPE_RGBM = 'rgbm';\nconst TEXTURETYPE_RGBE = 'rgbe';\nconst TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';\nconst TEXHINT_NONE = 0;\nconst TEXHINT_SHADOWMAP = 1;\nconst TEXHINT_ASSET = 2;\nconst TEXHINT_LIGHTMAP = 3;\nconst TEXTUREPROJECTION_NONE = \"none\";\nconst TEXTUREPROJECTION_CUBE = \"cube\";\nconst TEXTUREPROJECTION_EQUIRECT = \"equirect\";\nconst TEXTUREPROJECTION_OCTAHEDRAL = \"octahedral\";\nconst TYPE_INT8 = 0;\nconst TYPE_UINT8 = 1;\nconst TYPE_INT16 = 2;\nconst TYPE_UINT16 = 3;\nconst TYPE_INT32 = 4;\nconst TYPE_UINT32 = 5;\nconst TYPE_FLOAT32 = 6;\nconst UNIFORMTYPE_BOOL = 0;\nconst UNIFORMTYPE_INT = 1;\nconst UNIFORMTYPE_FLOAT = 2;\nconst UNIFORMTYPE_VEC2 = 3;\nconst UNIFORMTYPE_VEC3 = 4;\nconst UNIFORMTYPE_VEC4 = 5;\nconst UNIFORMTYPE_IVEC2 = 6;\nconst UNIFORMTYPE_IVEC3 = 7;\nconst UNIFORMTYPE_IVEC4 = 8;\nconst UNIFORMTYPE_BVEC2 = 9;\nconst UNIFORMTYPE_BVEC3 = 10;\nconst UNIFORMTYPE_BVEC4 = 11;\nconst UNIFORMTYPE_MAT2 = 12;\nconst UNIFORMTYPE_MAT3 = 13;\nconst UNIFORMTYPE_MAT4 = 14;\nconst UNIFORMTYPE_TEXTURE2D = 15;\nconst UNIFORMTYPE_TEXTURECUBE = 16;\nconst UNIFORMTYPE_FLOATARRAY = 17;\nconst UNIFORMTYPE_TEXTURE2D_SHADOW = 18;\nconst UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;\nconst UNIFORMTYPE_TEXTURE3D = 20;\nconst UNIFORMTYPE_VEC2ARRAY = 21;\nconst UNIFORMTYPE_VEC3ARRAY = 22;\nconst UNIFORMTYPE_VEC4ARRAY = 23;\nconst typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array];\nconst typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4];\nconst typedArrayToType = {\n\t\"Int8Array\": TYPE_INT8,\n\t\"Uint8Array\": TYPE_UINT8,\n\t\"Int16Array\": TYPE_INT16,\n\t\"Uint16Array\": TYPE_UINT16,\n\t\"Int32Array\": TYPE_INT32,\n\t\"Uint32Array\": TYPE_UINT32,\n\t\"Float32Array\": TYPE_FLOAT32\n};\nconst typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];\nconst typedArrayIndexFormatsByteSize = [1, 2, 4];\nconst semanticToLocation = {};\nsemanticToLocation[SEMANTIC_POSITION] = 0;\nsemanticToLocation[SEMANTIC_NORMAL] = 1;\nsemanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;\nsemanticToLocation[SEMANTIC_BLENDINDICES] = 3;\nsemanticToLocation[SEMANTIC_COLOR] = 4;\nsemanticToLocation[SEMANTIC_TEXCOORD0] = 5;\nsemanticToLocation[SEMANTIC_TEXCOORD1] = 6;\nsemanticToLocation[SEMANTIC_TEXCOORD2] = 7;\nsemanticToLocation[SEMANTIC_TEXCOORD3] = 8;\nsemanticToLocation[SEMANTIC_TEXCOORD4] = 9;\nsemanticToLocation[SEMANTIC_TEXCOORD5] = 10;\nsemanticToLocation[SEMANTIC_TEXCOORD6] = 11;\nsemanticToLocation[SEMANTIC_TEXCOORD7] = 12;\nsemanticToLocation[SEMANTIC_TANGENT] = 13;\nsemanticToLocation[SEMANTIC_ATTR0] = 0;\nsemanticToLocation[SEMANTIC_ATTR1] = 1;\nsemanticToLocation[SEMANTIC_ATTR2] = 2;\nsemanticToLocation[SEMANTIC_ATTR3] = 3;\nsemanticToLocation[SEMANTIC_ATTR4] = 4;\nsemanticToLocation[SEMANTIC_ATTR5] = 5;\nsemanticToLocation[SEMANTIC_ATTR6] = 6;\nsemanticToLocation[SEMANTIC_ATTR7] = 7;\nsemanticToLocation[SEMANTIC_ATTR8] = 8;\nsemanticToLocation[SEMANTIC_ATTR9] = 9;\nsemanticToLocation[SEMANTIC_ATTR10] = 10;\nsemanticToLocation[SEMANTIC_ATTR11] = 11;\nsemanticToLocation[SEMANTIC_ATTR12] = 12;\nsemanticToLocation[SEMANTIC_ATTR13] = 13;\nsemanticToLocation[SEMANTIC_ATTR14] = 14;\nsemanticToLocation[SEMANTIC_ATTR15] = 15;\n\nlet id$3 = 0;\n\nclass VertexBuffer {\n\tconstructor(graphicsDevice, format, numVertices, usage = BUFFER_STATIC, initialData) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.format = format;\n\t\tthis.numVertices = numVertices;\n\t\tthis.usage = usage;\n\t\tthis.id = id$3++;\n\t\tthis._vao = null;\n\t\tthis.instancing = false;\n\t\tthis.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;\n\t\tgraphicsDevice._vram.vb += this.numBytes;\n\n\t\tif (initialData) {\n\t\t\tthis.setData(initialData);\n\t\t} else {\n\t\t\tthis.storage = new ArrayBuffer(this.numBytes);\n\t\t}\n\n\t\tthis.device.buffers.push(this);\n\t}\n\n\tdestroy() {\n\t\tconst device = this.device;\n\t\tconst idx = device.buffers.indexOf(this);\n\n\t\tif (idx !== -1) {\n\t\t\tdevice.buffers.splice(idx, 1);\n\t\t}\n\n\t\tif (this.bufferId) {\n\t\t\tconst gl = device.gl;\n\t\t\tdevice.boundVao = null;\n\t\t\tgl.bindVertexArray(null);\n\t\t\tgl.deleteBuffer(this.bufferId);\n\t\t\tdevice._vram.vb -= this.storage.byteLength;\n\t\t\tthis.bufferId = null;\n\t\t}\n\t}\n\n\tloseContext() {\n\t\tthis.bufferId = undefined;\n\t\tthis._vao = null;\n\t}\n\n\tgetFormat() {\n\t\treturn this.format;\n\t}\n\n\tgetUsage() {\n\t\treturn this.usage;\n\t}\n\n\tgetNumVertices() {\n\t\treturn this.numVertices;\n\t}\n\n\tlock() {\n\t\treturn this.storage;\n\t}\n\n\tunlock() {\n\t\tconst gl = this.device.gl;\n\n\t\tif (!this.bufferId) {\n\t\t\tthis.bufferId = gl.createBuffer();\n\t\t}\n\n\t\tlet glUsage;\n\n\t\tswitch (this.usage) {\n\t\t\tcase BUFFER_STATIC:\n\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_DYNAMIC:\n\t\t\t\tglUsage = gl.DYNAMIC_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_STREAM:\n\t\t\t\tglUsage = gl.STREAM_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_GPUDYNAMIC:\n\t\t\t\tif (this.device.webgl2) {\n\t\t\t\t\tglUsage = gl.DYNAMIC_COPY;\n\t\t\t\t} else {\n\t\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.bufferId);\n\t\tgl.bufferData(gl.ARRAY_BUFFER, this.storage, glUsage);\n\t}\n\n\tsetData(data) {\n\t\tif (data.byteLength !== this.numBytes) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.storage = data;\n\t\tthis.unlock();\n\t\treturn true;\n\t}\n\n}\n\nfunction hashCode(str) {\n\tlet hash = 0;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\thash = (hash << 5) - hash + str.charCodeAt(i);\n\t\thash |= 0;\n\t}\n\n\treturn hash;\n}\n\nclass VertexFormat {\n\tconstructor(graphicsDevice, description, vertexCount) {\n\t\tthis.elements = [];\n\t\tthis.hasUv0 = false;\n\t\tthis.hasUv1 = false;\n\t\tthis.hasColor = false;\n\t\tthis.hasTangents = false;\n\t\tthis.verticesByteSize = 0;\n\t\tthis.vertexCount = vertexCount;\n\t\tthis.interleaved = vertexCount === undefined;\n\t\tthis.size = description.reduce((total, desc) => {\n\t\t\treturn total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;\n\t\t}, 0);\n\t\tlet offset = 0,\n\t\t\t\telementSize;\n\n\t\tfor (let i = 0, len = description.length; i < len; i++) {\n\t\t\tconst elementDesc = description[i];\n\t\t\telementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];\n\n\t\t\tif (vertexCount) {\n\t\t\t\toffset = math.roundUp(offset, elementSize);\n\t\t\t}\n\n\t\t\tconst element = {\n\t\t\t\tname: elementDesc.semantic,\n\t\t\t\toffset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,\n\t\t\t\tstride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,\n\t\t\t\tdataType: elementDesc.type,\n\t\t\t\tnumComponents: elementDesc.components,\n\t\t\t\tnormalize: elementDesc.normalize === undefined ? false : elementDesc.normalize,\n\t\t\t\tsize: elementSize\n\t\t\t};\n\t\t\tthis.elements.push(element);\n\n\t\t\tif (vertexCount) {\n\t\t\t\toffset += elementSize * vertexCount;\n\t\t\t} else {\n\t\t\t\toffset += Math.ceil(elementSize / 4) * 4;\n\t\t\t}\n\n\t\t\tif (elementDesc.semantic === SEMANTIC_TEXCOORD0) {\n\t\t\t\tthis.hasUv0 = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {\n\t\t\t\tthis.hasUv1 = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_COLOR) {\n\t\t\t\tthis.hasColor = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_TANGENT) {\n\t\t\t\tthis.hasTangents = true;\n\t\t\t}\n\t\t}\n\n\t\tif (vertexCount) {\n\t\t\tthis.verticesByteSize = offset;\n\t\t}\n\n\t\tthis.update();\n\t}\n\n\tstatic init(graphicsDevice) {\n\t\tconst formatDesc = [{\n\t\t\tsemantic: SEMANTIC_ATTR12,\n\t\t\tcomponents: 4,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_ATTR13,\n\t\t\tcomponents: 4,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_ATTR14,\n\t\t\tcomponents: 4,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_ATTR15,\n\t\t\tcomponents: 4,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}];\n\t\tVertexFormat._defaultInstancingFormat = new VertexFormat(graphicsDevice, formatDesc);\n\t}\n\n\tstatic get defaultInstancingFormat() {\n\t\treturn VertexFormat._defaultInstancingFormat;\n\t}\n\n\tupdate() {\n\t\tthis._evaluateHash();\n\t}\n\n\t_evaluateHash() {\n\t\tlet stringElementBatch;\n\t\tconst stringElementsBatch = [];\n\t\tlet stringElementRender;\n\t\tconst stringElementsRender = [];\n\t\tconst len = this.elements.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst element = this.elements[i];\n\t\t\tstringElementBatch = element.name;\n\t\t\tstringElementBatch += element.dataType;\n\t\t\tstringElementBatch += element.numComponents;\n\t\t\tstringElementBatch += element.normalize;\n\t\t\tstringElementsBatch.push(stringElementBatch);\n\t\t\tstringElementRender = stringElementBatch;\n\t\t\tstringElementRender += element.offset;\n\t\t\tstringElementRender += element.stride;\n\t\t\tstringElementRender += element.size;\n\t\t\tstringElementsRender.push(stringElementRender);\n\t\t}\n\n\t\tstringElementsBatch.sort();\n\t\tthis.batchingHash = hashCode(stringElementsBatch.join());\n\t\tthis.renderingingHash = hashCode(stringElementsRender.join());\n\t}\n\n}\n\nVertexFormat._defaultInstancingFormat = null;\n\nlet _postEffectQuadVB = null;\nconst _postEffectQuadDraw = {\n\ttype: PRIMITIVE_TRISTRIP,\n\tbase: 0,\n\tcount: 4,\n\tindexed: false\n};\n\nfunction drawQuadWithShader(device, target, shader, rect, scissorRect, useBlend = false) {\n\tif (_postEffectQuadVB === null) {\n\t\tconst vertexFormat = new VertexFormat(device, [{\n\t\t\tsemantic: SEMANTIC_POSITION,\n\t\t\tcomponents: 2,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}]);\n\t\tconst positions = new Float32Array(8);\n\t\tpositions.set([-1, -1, 1, -1, -1, 1, 1, 1]);\n\t\t_postEffectQuadVB = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, positions);\n\t}\n\n\tconst oldRt = device.renderTarget;\n\tdevice.setRenderTarget(target);\n\tdevice.updateBegin();\n\tlet x, y, w, h;\n\tlet sx, sy, sw, sh;\n\n\tif (!rect) {\n\t\tw = target ? target.width : device.width;\n\t\th = target ? target.height : device.height;\n\t\tx = 0;\n\t\ty = 0;\n\t} else {\n\t\tx = rect.x;\n\t\ty = rect.y;\n\t\tw = rect.z;\n\t\th = rect.w;\n\t}\n\n\tif (!scissorRect) {\n\t\tsx = x;\n\t\tsy = y;\n\t\tsw = w;\n\t\tsh = h;\n\t} else {\n\t\tsx = scissorRect.x;\n\t\tsy = scissorRect.y;\n\t\tsw = scissorRect.z;\n\t\tsh = scissorRect.w;\n\t}\n\n\tconst oldVx = device.vx;\n\tconst oldVy = device.vy;\n\tconst oldVw = device.vw;\n\tconst oldVh = device.vh;\n\tdevice.setViewport(x, y, w, h);\n\tconst oldSx = device.sx;\n\tconst oldSy = device.sy;\n\tconst oldSw = device.sw;\n\tconst oldSh = device.sh;\n\tdevice.setScissor(sx, sy, sw, sh);\n\tconst oldDepthTest = device.getDepthTest();\n\tconst oldDepthWrite = device.getDepthWrite();\n\tconst oldCullMode = device.getCullMode();\n\tconst oldWR = device.writeRed;\n\tconst oldWG = device.writeGreen;\n\tconst oldWB = device.writeBlue;\n\tconst oldWA = device.writeAlpha;\n\tdevice.setDepthTest(false);\n\tdevice.setDepthWrite(false);\n\tdevice.setCullMode(CULLFACE_NONE);\n\tdevice.setColorWrite(true, true, true, true);\n\tif (!useBlend) device.setBlending(false);\n\tdevice.setVertexBuffer(_postEffectQuadVB, 0);\n\tdevice.setShader(shader);\n\tdevice.draw(_postEffectQuadDraw);\n\tdevice.setDepthTest(oldDepthTest);\n\tdevice.setDepthWrite(oldDepthWrite);\n\tdevice.setCullMode(oldCullMode);\n\tdevice.setColorWrite(oldWR, oldWG, oldWB, oldWA);\n\tdevice.updateEnd();\n\tdevice.setRenderTarget(oldRt);\n\tdevice.updateBegin();\n\tdevice.setViewport(oldVx, oldVy, oldVw, oldVh);\n\tdevice.setScissor(oldSx, oldSy, oldSw, oldSh);\n}\n\nfunction destroyPostEffectQuad() {\n\tif (_postEffectQuadVB) {\n\t\t_postEffectQuadVB.destroy();\n\n\t\t_postEffectQuadVB = null;\n\t}\n}\n\nfunction drawTexture(device, texture, target, shader, rect, scissorRect, useBlend = false) {\n\tshader = shader || device.getCopyShader();\n\tdevice.constantTexSource.setValue(texture);\n\tdrawQuadWithShader(device, target, shader, rect, scissorRect, useBlend);\n}\n\nclass Shader {\n\tconstructor(graphicsDevice, definition) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.definition = definition;\n\t\tthis.init();\n\t\tthis.device.createShader(this);\n\t}\n\n\tinit() {\n\t\tthis.attributes = [];\n\t\tthis.uniforms = [];\n\t\tthis.samplers = [];\n\t\tthis.ready = false;\n\t\tthis.failed = false;\n\t}\n\n\tdestroy() {\n\t\tthis.device.destroyShader(this);\n\t}\n\n\tloseContext() {\n\t\tthis.init();\n\t}\n\n}\n\nvar alphaTestPS = \"uniform float alpha_ref;\\nvoid alphaTest(float a) {\\n\\tif (a < alpha_ref) discard;\\n}\\n\";\n\nvar ambientConstantPS = \"void addAmbient() {\\n\\tdDiffuseLight += light_globalAmbient;\\n}\\n\";\n\nvar ambientEnvPS = \"#ifndef ENV_ATLAS\\n#define ENV_ATLAS\\nuniform sampler2D texture_envAtlas;\\n#endif\\nvoid addAmbient() {\\n\\tvec3 dir = cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0);\\n\\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\\n\\tvec4 raw = texture2D(texture_envAtlas, uv);\\n\\tvec3 linear = $DECODE(raw);\\n\\tdDiffuseLight += processEnvironment(linear);\\n}\\n\";\n\nvar ambientSHPS = \"uniform vec3 ambientSH[9];\\nvoid addAmbient() {\\n\\tvec3 n = cubeMapRotate(dNormalW);\\n\\tvec3 color =\\n\\t\\tambientSH[0] +\\n\\t\\tambientSH[1] * n.x +\\n\\t\\tambientSH[2] * n.y +\\n\\t\\tambientSH[3] * n.z +\\n\\t\\tambientSH[4] * n.x * n.z +\\n\\t\\tambientSH[5] * n.z * n.y +\\n\\t\\tambientSH[6] * n.y * n.x +\\n\\t\\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\\n\\t\\tambientSH[8] * (n.x * n.x - n.y * n.y);\\n\\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\\n}\\n\";\n\nvar aoPS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_aoMap;\\n#endif\\nvoid applyAO() {\\n\\tdAo = 1.0;\\n\\t#ifdef MAPTEXTURE\\n\\tdAo *= texture2D(texture_aoMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdAo *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tdDiffuseLight *= dAo;\\n}\\n\";\n\nvar aoSpecOccPS = \"uniform float material_occludeSpecularIntensity;\\nvoid occludeSpecular() {\\n\\tfloat specPow = exp2(dGlossiness * 11.0);\\n\\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\\n\\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\\n\\tdSpecularLight *= specOcc;\\n\\tdReflection *= specOcc;\\n}\\n\";\n\nvar aoSpecOccConstPS = \"void occludeSpecular() {\\n\\tfloat specPow = exp2(dGlossiness * 11.0);\\n\\tfloat specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);\\n\\tdSpecularLight *= specOcc;\\n\\tdReflection *= specOcc;\\n}\\n\";\n\nvar aoSpecOccConstSimplePS = \"void occludeSpecular() {\\n\\tfloat specOcc = dAo;\\n\\tdSpecularLight *= specOcc;\\n\\tdReflection *= specOcc;\\n}\\n\";\n\nvar aoSpecOccSimplePS = \"uniform float material_occludeSpecularIntensity;\\nvoid occludeSpecular() {\\n\\tfloat specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);\\n\\tdSpecularLight *= specOcc;\\n\\tdReflection *= specOcc;\\n}\\n\";\n\nvar bakeDirLmEndPS = \"\\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\\n\\tif (bakeDir > 0.5) {\\n\\t\\tif (dAtten > 0.00001) {\\n\\t\\t\\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\\n\\t\\t\\tdAtten = saturate(dAtten);\\n\\t\\t\\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\\n\\t\\t\\tgl_FragColor.a = dirLm.w + dAtten;\\n\\t\\t\\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\\n\\t\\t} else {\\n\\t\\t\\tgl_FragColor = dirLm;\\n\\t\\t}\\n\\t} else {\\n\\t\\tgl_FragColor.rgb = dirLm.xyz;\\n\\t\\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\\n\\t}\\n\";\n\nvar bakeLmEndPS = \"\\tgl_FragColor.rgb = dDiffuseLight;\\n\\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\\n\\tgl_FragColor.rgb /= 8.0;\\n\\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\\n\\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\\n\\tgl_FragColor.rgb /= gl_FragColor.a;\\n\";\n\nvar basePS = \"uniform vec3 view_position;\\nuniform vec3 light_globalAmbient;\\nfloat square(float x) {\\n\\treturn x*x;\\n}\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec3 saturate(vec3 x) {\\n\\treturn clamp(x, vec3(0.0), vec3(1.0));\\n}\\n\";\n\nvar baseVS = \"attribute vec3 vertex_position;\\nattribute vec3 vertex_normal;\\nattribute vec4 vertex_tangent;\\nattribute vec2 vertex_texCoord0;\\nattribute vec2 vertex_texCoord1;\\nattribute vec4 vertex_color;\\nuniform mat4 matrix_viewProjection;\\nuniform mat4 matrix_model;\\nuniform mat3 matrix_normal;\\nvec3 dPositionW;\\nmat4 dModelMatrix;\\nmat3 dNormalMatrix;\\n\";\n\nvar baseNineSlicedPS = \"#define NINESLICED\\nvarying vec2 vMask;\\nvarying vec2 vTiledUv;\\nuniform mediump vec4 innerOffset;\\nuniform mediump vec2 outerScale;\\nuniform mediump vec4 atlasRect;\\nvec2 nineSlicedUv;\\n\";\n\nvar baseNineSlicedVS = \"#define NINESLICED\\nvarying vec2 vMask;\\nvarying vec2 vTiledUv;\\nuniform mediump vec4 innerOffset;\\nuniform mediump vec2 outerScale;\\nuniform mediump vec4 atlasRect;\\n\";\n\nvar baseNineSlicedTiledPS = \"#define NINESLICED\\n#define NINESLICETILED\\nvarying vec2 vMask;\\nvarying vec2 vTiledUv;\\nuniform mediump vec4 innerOffset;\\nuniform mediump vec2 outerScale;\\nuniform mediump vec4 atlasRect;\\nvec2 nineSlicedUv;\\n\";\n\nvar biasConstPS = \"#define SHADOWBIAS\\nfloat getShadowBias(float resolution, float maxBias) {\\n\\treturn maxBias;\\n}\\n\";\n\nvar blurVSMPS = \"varying vec2 vUv0;\\nuniform sampler2D source;\\nuniform vec2 pixelOffset;\\n#ifdef GAUSS\\nuniform float weight[SAMPLES];\\n#endif\\n#ifdef PACKED\\nfloat decodeFloatRG(vec2 rg) {\\n\\treturn rg.y*(1.0/255.0) + rg.x;\\n}\\nvec2 encodeFloatRG( float v ) {\\n\\tvec2 enc = vec2(1.0, 255.0) * v;\\n\\tenc = fract(enc);\\n\\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\\n\\treturn enc;\\n}\\n#endif\\nvoid main(void) {\\n\\tvec3 moments = vec3(0.0);\\n\\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\\n\\tfor (int i=0; i<SAMPLES; i++) {\\n\\t\\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\\n\\t\\t#ifdef PACKED\\n\\t\\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\\n\\t\\t#endif\\n\\t\\t#ifdef GAUSS\\n\\t\\tmoments += c.xyz * weight[i];\\n\\t\\t#else\\n\\t\\tmoments += c.xyz;\\n\\t\\t#endif\\n\\t}\\n\\t#ifndef GAUSS\\n\\tmoments /= float(SAMPLES);\\n\\t#endif\\n\\t#ifdef PACKED\\n\\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\\n\\t#else\\n\\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\\n\\t#endif\\n}\\n\";\n\nvar clearCoatPS = \"#ifdef MAPFLOAT\\nuniform float material_clearCoat;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_clearCoatMap;\\n#endif\\nvoid getClearCoat() {\\n\\tccSpecularity = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tccSpecularity *= material_clearCoat;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tccSpecularity *= texture2D(texture_clearCoatMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tccSpecularity *= saturate(vVertexColor.$VC);\\n\\t#endif\\n}\\n\";\n\nvar clearCoatGlossPS = \"#ifdef MAPFLOAT\\nuniform float material_clearCoatGlossiness;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_clearCoatGlossMap;\\n#endif\\nvoid getClearCoatGlossiness() {\\n\\tccGlossiness = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tccGlossiness *= material_clearCoatGlossiness;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tccGlossiness *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tccGlossiness += 0.0000001;\\n}\\n\";\n\nvar clearCoatNormalPS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_clearCoatNormalMap;\\nuniform float material_clearCoatBumpiness;\\n#endif\\nvoid getClearCoatNormal() {\\n\\t#ifdef MAPTEXTURE\\n\\tvec3 normalMap = unpackNormal(texture2D(texture_clearCoatNormalMap, $UV));\\n\\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness));\\n\\tccNormalW = dTBN * normalMap;\\n\\t#else\\n\\tccNormalW = normalize(dVertexNormalW);\\n\\t#endif\\n\\tccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));\\n}\\n\";\n\nvar clusteredLightUtilsPS = \"vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\\n{\\n\\tvec3 vAbs = abs(dir);\\n\\tfloat ma;\\n\\tvec2 uv;\\n\\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\\n\\t\\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\\n\\t\\tma = 0.5 / vAbs.z;\\n\\t\\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\\n\\t\\ttileOffset.x = 2.0;\\n\\t\\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\\n\\t} else if(vAbs.y >= vAbs.x) {\\n\\t\\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\\n\\t\\tma = 0.5 / vAbs.y;\\n\\t\\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\\n\\t\\ttileOffset.x = 1.0;\\n\\t\\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\\n\\t} else {\\n\\t\\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\\n\\t\\tma = 0.5 / vAbs.x;\\n\\t\\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\\n\\t\\ttileOffset.x = 0.0;\\n\\t\\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\\n\\t}\\n\\treturn uv * ma + 0.5;\\n}\\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\\n\\tfloat faceIndex;\\n\\tvec2 tileOffset;\\n\\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\\n\\tfloat atlasFaceSize = omniAtlasViewport.z;\\n\\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\\n\\tfloat offset = shadowEdgePixels / tileSize;\\n\\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\\n\\tuv *= atlasFaceSize;\\n\\tuv += tileOffset * atlasFaceSize;\\n\\tuv += omniAtlasViewport.xy;\\n\\treturn uv;\\n}\\n\";\n\nvar clusteredLightCookiesPS = \"vec3 _getCookieClustered(sampler2D tex, vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\\n\\tvec4 pixel = mix(vec4(1.0), texture2D(tex, uv), intensity);\\n\\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\\n}\\nvec3 getCookie2DClustered(sampler2D tex, mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\\n\\tvec4 projPos = transform * vec4(worldPosition, 1.0);\\n\\treturn _getCookieClustered(tex, projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\\n}\\nvec3 getCookieCubeClustered(sampler2D tex, vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\\n\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\treturn _getCookieClustered(tex, uv, intensity, isRgb, cookieChannel);\\n}\\n\";\n\nvar clusteredLightShadowsPS = \"#ifdef GL2\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\tfloat getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\treturn texture(shadowMap, vec3(uv, shadowZ));\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\\n\\tfloat getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\tdShadowCoord = vec3(uv, shadowZ);\\n\\t\\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\tdShadowCoord = vec3(uv, shadowZ);\\n\\t\\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\\n\\t}\\n\\t#endif\\n#else\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\tfloat getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat depth = unpackFloat(texture2D(shadowMap, uv));\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\treturn depth > shadowZ ? 1.0 : 0.0;\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\tfloat shadowTextureResolution = shadowParams.x;\\n\\t\\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\\n\\t\\tfloat shadowZ = length(dir) * shadowParams.w + shadowParams.z;\\n\\t\\tdShadowCoord = vec3(uv, shadowZ);\\n\\t\\treturn getShadowPCF3x3(shadowMap, shadowParams.xyz);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {\\n\\t\\treturn getShadowOmniClusteredPCF3(shadowMap, shadowParams, omniAtlasViewport, shadowEdgePixels, dir);\\n\\t}\\n\\t#endif\\n#endif\\n#ifdef GL2\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\tfloat getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\t\\treturn texture(shadowMap, dShadowCoord);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\\n\\tfloat getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\t\\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\t\\treturn getShadowPCF5x5(shadowMap, shadowParams.xyz);\\n\\t}\\n\\t#endif\\n#else\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\tfloat getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {\\n\\t\\tfloat depth = unpackFloat(texture2D(shadowMap, dShadowCoord.xy));\\n\\t\\treturn depth > dShadowCoord.z ? 1.0 : 0.0;\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF3) || defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {\\n\\t\\treturn getShadowSpotPCF3x3(shadowMap, shadowParams);\\n\\t}\\n\\t#endif\\n\\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\tfloat getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {\\n\\t\\treturn getShadowSpotClusteredPCF3(shadowMap, shadowParams);\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\nvar clusteredLightPS = \"uniform sampler2D clusterWorldTexture;\\nuniform sampler2D lightsTexture8;\\nuniform highp sampler2D lightsTextureFloat;\\n#ifdef CLUSTER_SHADOWS\\n\\t#ifdef GL2\\n\\t\\tuniform sampler2DShadow shadowAtlasTexture;\\n\\t#else\\n\\t\\tuniform sampler2D shadowAtlasTexture;\\n\\t#endif\\n#endif\\n#ifdef CLUSTER_COOKIES\\n\\tuniform sampler2D cookieAtlasTexture;\\n#endif\\nuniform float clusterPixelsPerCell;\\nuniform vec3 clusterCellsCountByBoundsSize;\\nuniform vec4 lightsTextureInvSize;\\nuniform vec3 clusterTextureSize;\\nuniform vec3 clusterBoundsMin;\\nuniform vec3 clusterBoundsDelta;\\nuniform vec3 clusterCellsDot;\\nuniform vec3 clusterCellsMax;\\nuniform vec2 clusterCompressionLimit0;\\nuniform vec2 shadowAtlasParams;\\nfloat LTCLightValuesEvaluated = 0.0;\\nstruct ClusterLightData {\\n\\tfloat lightV;\\n\\tfloat type;\\n\\tfloat shape;\\n\\tvec3 halfWidth;\\n\\tvec3 halfHeight;\\n\\tfloat falloffMode;\\n\\tfloat castShadows;\\n\\tfloat shadowBias;\\n\\tfloat shadowNormalBias;\\n\\tvec3 position;\\n\\tvec3 direction;\\n\\tfloat range;\\n\\tfloat innerConeAngleCos;\\n\\tfloat outerConeAngleCos;\\n\\tvec3 color;\\n\\tvec3 omniAtlasViewport;\\n\\tfloat cookie;\\n\\tfloat cookieRgb;\\n\\tfloat cookieIntensity;\\n\\tvec4 cookieChannelMask;\\n\\tfloat mask;\\n};\\nmat4 lightProjectionMatrix;\\n#define isClusteredLightCastShadow(light) ( light.castShadows > 0.5 )\\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\\n#define isClusteredLightSpot(light) ( light.type > 0.5 )\\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\\n\\t#define acceptLightMask(light) ( light.mask < 0.75)\\n#else\\n\\t#define acceptLightMask(light) ( light.mask > 0.25)\\n#endif\\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\\n\\treturn vec4(\\n\\t\\tbytes2floatRange4(d0, -2.0, 2.0),\\n\\t\\tbytes2floatRange4(d1, -2.0, 2.0),\\n\\t\\tbytes2floatRange4(d2, -2.0, 2.0),\\n\\t\\tbytes2floatRange4(d3, -2.0, 2.0)\\n\\t);\\n}\\n#ifdef SUPPORTS_TEXLOD\\n\\t#define textureData(texture, uv) texture2DLodEXT(texture, uv, 0.0)\\n#else\\n\\t#define textureData(texture, uv) texture2D(texture, uv)\\n#endif\\nvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\\n\\treturn textureData(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV));\\n}\\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\\n\\treturn textureData(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV));\\n}\\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\\n\\tclusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\\n\\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\\n\\tclusterLightData.type = lightInfo.x;\\n\\tclusterLightData.shape = lightInfo.y;\\n\\tclusterLightData.falloffMode = lightInfo.z;\\n\\tclusterLightData.castShadows = lightInfo.w;\\n\\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\\n\\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\\n\\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\\n\\tclusterLightData.cookie = colorB.z;\\n\\tclusterLightData.mask = colorB.w;\\n\\t#ifdef CLUSTER_TEXTURE_FLOAT\\n\\t\\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\\n\\t\\tclusterLightData.position = lightPosRange.xyz;\\n\\t\\tclusterLightData.range = lightPosRange.w;\\n\\t\\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\\n\\t\\tclusterLightData.direction = lightDir_Unused.xyz;\\n\\t#else\\n\\t\\tvec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\\n\\t\\tvec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\\n\\t\\tvec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\\n\\t\\tclusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\\n\\t\\tvec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\\n\\t\\tclusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\\n\\t\\tvec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\\n\\t\\tvec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\\n\\t\\tvec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\\n\\t\\tclusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\\n\\t#endif\\n}\\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\\n\\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\\n\\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\\n\\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\\n}\\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\\n\\t#ifdef CLUSTER_TEXTURE_FLOAT\\n\\t\\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\\n\\t#else\\n\\t\\tvec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\\n\\t\\tvec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\\n\\t\\tclusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\\n\\t#endif\\n}\\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\\n\\t#ifdef CLUSTER_TEXTURE_FLOAT\\n\\t\\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\\n\\t\\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\\n\\t#else\\n\\t\\tvec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\\n\\t\\tvec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\\n\\t\\tvec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\\n\\t\\tclusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\\n\\t\\tvec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\\n\\t\\tvec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\\n\\t\\tvec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\\n\\t\\tclusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\\n\\t#endif\\n}\\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\\n\\t#ifdef CLUSTER_TEXTURE_FLOAT\\n\\t\\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\\n\\t\\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\\n\\t\\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\\n\\t\\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\\n\\t#else\\n\\t\\tvec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\\n\\t\\tvec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\\n\\t\\tvec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\\n\\t\\tvec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\\n\\t\\tvec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\\n\\t\\tvec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\\n\\t\\tvec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\\n\\t\\tvec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\\n\\t\\tvec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\\n\\t\\tvec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\\n\\t\\tvec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\\n\\t\\tvec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\\n\\t\\tvec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\\n\\t\\tvec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\\n\\t\\tvec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\\n\\t\\tvec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\\n\\t\\tvec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\\n\\t\\tvec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\\n\\t\\tvec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\\n\\t\\tvec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\\n\\t#endif\\n\\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\\n}\\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\\n\\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\\n\\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\\n\\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\\n}\\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\\n\\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\\n\\tclusterLightData.cookieIntensity = cookieA.x;\\n\\tclusterLightData.cookieRgb = cookieA.y;\\n\\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\\n}\\nvoid evaluateLight(ClusterLightData light) {\\n\\tdAtten3 = vec3(1.0);\\n\\tgetLightDirPoint(light.position);\\n\\t#ifdef CLUSTER_AREALIGHTS\\n\\tif (isClusteredLightArea(light)) {\\n\\t\\tdecodeClusterLightAreaData(light);\\n\\t\\tif (LTCLightValuesEvaluated < 0.5) {\\n\\t\\t\\tLTCLightValuesEvaluated = 1.0;\\n\\t\\t\\tcalcLTCLightValues();\\n\\t\\t}\\n\\t\\tif (isClusteredLightRect(light)) {\\n\\t\\t\\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\\n\\t\\t} else if (isClusteredLightDisk(light)) {\\n\\t\\t\\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\\n\\t\\t} else {\\n\\t\\t\\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\\n\\t\\t}\\n\\t\\tdAtten = getFalloffWindow(light.range);\\n\\t} else\\n\\t#endif\\n\\t{\\n\\t\\tif (isClusteredLightFalloffLinear(light))\\n\\t\\t\\tdAtten = getFalloffLinear(light.range);\\n\\t\\telse\\n\\t\\t\\tdAtten = getFalloffInvSquared(light.range);\\n\\t}\\n\\tif (dAtten > 0.00001) {\\n\\t\\t#ifdef CLUSTER_AREALIGHTS\\n\\t\\tif (isClusteredLightArea(light)) {\\n\\t\\t\\tif (isClusteredLightRect(light)) {\\n\\t\\t\\t\\tdAttenD = getRectLightDiffuse() * 16.0;\\n\\t\\t\\t} else if (isClusteredLightDisk(light)) {\\n\\t\\t\\t\\tdAttenD = getDiskLightDiffuse() * 16.0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdAttenD = getSphereLightDiffuse() * 16.0;\\n\\t\\t\\t}\\n\\t\\t} else\\n\\t\\t#endif\\n\\t\\t{\\n\\t\\t\\tdAtten *= getLightDiffuse();\\n\\t\\t}\\n\\t\\tif (isClusteredLightSpot(light)) {\\n\\t\\t\\tdecodeClusterLightSpot(light);\\n\\t\\t\\tdAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);\\n\\t\\t}\\n\\t\\t#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\\n\\t\\tif (dAtten > 0.00001) {\\n\\t\\t\\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\\n\\t\\t\\t\\tif (isClusteredLightSpot(light)) {\\n\\t\\t\\t\\t\\tdecodeClusterLightProjectionMatrixData(light);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdecodeClusterLightOmniAtlasViewport(light);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfloat shadowTextureResolution = shadowAtlasParams.x;\\n\\t\\t\\t\\tfloat shadowEdgePixels = shadowAtlasParams.y;\\n\\t\\t\\t\\t#ifdef CLUSTER_COOKIES\\n\\t\\t\\t\\tif (isClusteredLightCookie(light)) {\\n\\t\\t\\t\\t\\tdecodeClusterLightCookieData(light);\\n\\t\\t\\t\\t\\tif (isClusteredLightSpot(light)) {\\n\\t\\t\\t\\t\\t\\tdAtten3 = getCookie2DClustered(cookieAtlasTexture, lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tdAtten3 = getCookieCubeClustered(cookieAtlasTexture, dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#ifdef CLUSTER_SHADOWS\\n\\t\\t\\t\\tif (isClusteredLightCastShadow(light)) {\\n\\t\\t\\t\\t\\tdecodeClusterLightShadowData(light);\\n\\t\\t\\t\\t\\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\\n\\t\\t\\t\\t\\tif (isClusteredLightSpot(light)) {\\n\\t\\t\\t\\t\\t\\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);\\n\\t\\t\\t\\t\\t\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);\\n\\t\\t\\t\\t\\t\\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);\\n\\t\\t\\t\\t\\t\\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);\\n\\t\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnormalOffsetPointShadow(shadowParams);\\n\\t\\t\\t\\t\\t\\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\\n\\t\\t\\t\\t\\t\\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\\n\\t\\t\\t\\t\\t\\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\\n\\t\\t\\t\\t\\t\\t\\tdAtten *= getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);\\n\\t\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t#endif\\n\\t\\t#ifdef CLUSTER_AREALIGHTS\\n\\t\\tif (isClusteredLightArea(light)) {\\n\\t\\t\\t{\\n\\t\\t\\t\\tvec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;\\n\\t\\t\\t\\t#if defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\\n\\t\\t\\t\\t\\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tdDiffuseLight += areaDiffuse;\\n\\t\\t\\t}\\n\\t\\t\\t#ifdef CLUSTER_SPECULAR\\n\\t\\t\\t\\tfloat areaLightSpecular;\\n\\t\\t\\t\\tif (isClusteredLightRect(light)) {\\n\\t\\t\\t\\t\\tareaLightSpecular = getRectLightSpecular();\\n\\t\\t\\t\\t} else if (isClusteredLightDisk(light)) {\\n\\t\\t\\t\\t\\tareaLightSpecular = getDiskLightSpecular();\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tareaLightSpecular = getSphereLightSpecular();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;\\n\\t\\t\\t\\t#ifdef CLUSTER_CLEAR_COAT\\n\\t\\t\\t\\t\\tfloat areaLightSpecularCC;\\n\\t\\t\\t\\t\\tif (isClusteredLightRect(light)) {\\n\\t\\t\\t\\t\\t\\tareaLightSpecularCC = getRectLightSpecularCC();\\n\\t\\t\\t\\t\\t} else if (isClusteredLightDisk(light)) {\\n\\t\\t\\t\\t\\t\\tareaLightSpecularCC = getDiskLightSpecularCC();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tareaLightSpecularCC = getSphereLightSpecularCC();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color\t* dAtten3;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t#endif\\n\\t\\t} else\\n\\t\\t#endif\\n\\t\\t{\\n\\t\\t\\t{\\n\\t\\t\\t\\tvec3 punctualDiffuse = dAtten * light.color * dAtten3;\\n\\t\\t\\t\\t#if defined(CLUSTER_AREALIGHTS) && defined(CLUSTER_SPECULAR) && defined(CLUSTER_CONSERVE_ENERGY)\\n\\t\\t\\t\\t\\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tdDiffuseLight += punctualDiffuse;\\n\\t\\t\\t}\\n\\t\\t\\t#ifdef CLUSTER_SPECULAR\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvec3 punctualSpecular = getLightSpecular() * dAtten * light.color * dAtten3;\\n\\t\\t\\t\\t\\t#if defined(CLUSTER_AREALIGHTS)\\n\\t\\t\\t\\t\\t\\tpunctualSpecular *= dSpecularity;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\tdSpecularLight += punctualSpecular;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t#ifdef CLUSTER_CLEAR_COAT\\n\\t\\t\\t\\t\\tvec3 punctualCC = getLightSpecularCC() * dAtten * light.color * dAtten3;\\n\\t\\t\\t\\t\\t#if defined(CLUSTER_AREALIGHTS)\\n\\t\\t\\t\\t\\t\\tpunctualCC *= ccSpecularity;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\\tccSpecularLight += punctualCC;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t}\\n}\\nvoid evaluateClusterLight(float lightIndex) {\\n\\tClusterLightData clusterLightData;\\n\\tdecodeClusterLightCore(clusterLightData, lightIndex);\\n\\tif (acceptLightMask(clusterLightData))\\n\\t\\tevaluateLight(clusterLightData);\\n}\\nvoid addClusteredLights() {\\n\\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\\n\\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\\n\\t\\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\\n\\t\\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\\n\\t\\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\\n\\t\\tclusterV = (clusterV + 0.5) * clusterTextureSize.z;\\n\\t\\tconst float maxLightCells = 256.0 / 4.0;\\n\\t\\tfor (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\\n\\t\\t\\tvec4 lightIndices = textureData(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV));\\n\\t\\t\\tvec4 indices = lightIndices * 255.0;\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\n\\t\\t\\t\\tif (indices.x <= 0.0)\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\tevaluateClusterLight(indices.x);\\n\\t\\t\\t\\tindices = indices.yzwx;\\n\\t\\t\\t}\\n\\t\\t\\tif (lightCellIndex > clusterPixelsPerCell) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\";\n\nvar combineClearCoatPS = \"vec3 combineColorCC() {\\n\\treturn combineColor()+(ccSpecularLight*ccSpecularity+ccReflection.rgb*ccSpecularity*ccReflection.a);\\n}\\n\";\n\nvar combineDiffusePS = \"vec3 combineColor() {\\n\\treturn dAlbedo * dDiffuseLight;\\n}\\n\";\n\nvar combineDiffuseSpecularPS = \"vec3 combineColor() {\\n\\treturn mix(dAlbedo * dDiffuseLight, dSpecularLight + dReflection.rgb * dReflection.a, dSpecularity);\\n}\\n\";\n\nvar combineDiffuseSpecularNoConservePS = \"vec3 combineColor() {\\n\\treturn dAlbedo * dDiffuseLight + (dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity;\\n}\\n\";\n\nvar combineDiffuseSpecularNoReflPS = \"vec3 combineColor() {\\n\\treturn dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity;\\n}\\n\";\n\nvar combineDiffuseSpecularNoReflSeparateAmbientPS = \"uniform vec3 material_ambient;\\nvec3 combineColor() {\\n\\treturn (dDiffuseLight - light_globalAmbient) * dAlbedo + dSpecularLight * dSpecularity + material_ambient * light_globalAmbient;\\n}\\n\";\n\nvar combineDiffuseSpecularOldPS = \"vec3 combineColor() {\\n\\treturn mix(dAlbedo * dDiffuseLight + dSpecularLight * dSpecularity, dReflection.rgb, dReflection.a);\\n}\\n\";\n\nvar cookiePS = \"vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\\n\\tvec4 projPos = transform * vec4(vPositionW, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\\n}\\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\\n\\tvec4 projPos = transform * vec4(vPositionW, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\\n\\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\\n}\\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\\n\\tvec4 projPos = transform * vec4(vPositionW, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\tprojPos.xy += cookieOffset;\\n\\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\\n\\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\\n}\\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\\n\\tvec4 projPos = transform * vec4(vPositionW, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\tprojPos.xy += cookieOffset;\\n\\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\\n\\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\\n\\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\\n}\\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\\n\\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\\n}\\n\";\n\nvar cubeMapProjectBoxPS = \"uniform vec3 envBoxMin, envBoxMax;\\nvec3 cubeMapProject(vec3 nrdir) {\\n\\tnrdir = cubeMapRotate(nrdir);\\n\\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\\n\\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\\n\\tvec3 rbminmax;\\n\\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\\n\\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\\n\\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\\n\\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\\n\\tvec3 posonbox = vPositionW + nrdir * fa;\\n\\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\\n\\treturn normalize(posonbox - envBoxPos);\\n}\\n\";\n\nvar cubeMapProjectNonePS = \"vec3 cubeMapProject(vec3 dir) {\\n\\treturn cubeMapRotate(dir);\\n}\\n\";\n\nvar cubeMapRotatePS = \"#ifdef CUBEMAP_ROTATION\\nuniform mat3 cubeMapRotationMatrix;\\n#endif\\nvec3 cubeMapRotate(vec3 refDir) {\\n#ifdef CUBEMAP_ROTATION\\n\\treturn refDir * cubeMapRotationMatrix;\\n#else\\n\\treturn refDir;\\n#endif\\n}\\n\";\n\nvar decodePS = \"vec3 decodeLinear(vec4 raw) {\\n\\treturn raw.rgb;\\n}\\nvec3 decodeGamma(vec4 raw) {\\n\\treturn pow(raw.xyz, vec3(2.2));\\n}\\nvec3 decodeRGBM(vec4 raw) {\\n\\tvec3 color = (8.0 * raw.a) * raw.rgb;\\n\\treturn color * color;\\n}\\nvec3 decodeRGBE(vec4 raw) {\\n\\tif (raw.a == 0.0) {\\n\\t\\treturn vec3(0.0, 0.0, 0.0);\\n\\t} else {\\n\\t\\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\\n\\t}\\n}\\nconst float PI = 3.141592653589793;\\nvec2 toSpherical(vec3 dir) {\\n\\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\\n}\\nvec2 toSphericalUv(vec3 dir) {\\n\\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\\n\\treturn vec2(uv.x, 1.0 - uv.y);\\n}\\nconst float atlasSize = 512.0;\\nconst float seamSize = 1.0 / atlasSize;\\nvec2 mapUv(vec2 uv, vec4 rect) {\\n\\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\\n\\t\\t\\t\\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\\n}\\nvec2 mapRoughnessUv(vec2 uv, float level) {\\n\\tfloat t = 1.0 / exp2(level);\\n\\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\\n}\\nvec2 mapMip(vec2 uv, float level) {\\n\\tfloat t = 1.0 / exp2(level);\\n\\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\\n}\\n\";\n\nvar detailModesPS = \"vec3 detailMode_mul(vec3 c1, vec3 c2) {\\n\\treturn c1 * c2;\\n}\\nvec3 detailMode_add(vec3 c1, vec3 c2) {\\n\\treturn c1 + c2;\\n}\\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\\n\\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\\n}\\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\\n\\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\\n}\\nvec3 detailMode_min(vec3 c1, vec3 c2) {\\n\\treturn min(c1, c2);\\n}\\nvec3 detailMode_max(vec3 c1, vec3 c2) {\\n\\treturn max(c1, c2);\\n}\\n\";\n\nvar diffusePS = \"#ifdef MAPCOLOR\\nuniform vec3 material_diffuse;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_diffuseMap;\\n#endif\\nvoid getAlbedo() {\\n\\tdAlbedo = vec3(1.0);\\n\\t#ifdef MAPCOLOR\\n\\tdAlbedo *= material_diffuse.rgb;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tdAlbedo *= gammaCorrectInput(addAlbedoDetail(texture2D(texture_diffuseMap, $UV).$CH));\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\\n\\t#endif\\n}\\n\";\n\nvar diffuseDetailMapPS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_diffuseDetailMap;\\n#endif\\nvec3 addAlbedoDetail(vec3 albedo) {\\n\\t#ifdef MAPTEXTURE\\n\\tvec3 albedoDetail = vec3(texture2D(texture_diffuseDetailMap, $UV).$CH);\\n\\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\\n\\t#else\\n\\treturn albedo;\\n\\t#endif\\n}\\n\";\n\nvar dilatePS = \"#define SHADER_NAME Dilate\\nvarying vec2 vUv0;\\nuniform sampler2D source;\\nuniform vec2 pixelOffset;\\nvoid main(void) {\\n\\tvec4 c = texture2D(source, vUv0);\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));\\n\\tc = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);\\n\\tgl_FragColor = c;\\n}\\n\";\n\nvar bilateralDeNoisePS = \"#define SHADER_NAME BilateralDeNoise\\nfloat normpdf3(in vec3 v, in float sigma) {\\n\\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\\n}\\nvec3 decodeRGBM(vec4 rgbm) {\\n\\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\\n\\treturn color * color;\\n}\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec4 encodeRGBM(vec3 color) {\\n\\tvec4 encoded;\\n\\tencoded.rgb = pow(color.rgb, vec3(0.5));\\n\\tencoded.rgb *= 1.0 / 8.0;\\n\\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\\n\\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\\n\\tencoded.rgb /= encoded.a;\\n\\treturn encoded;\\n}\\n#define MSIZE 15\\nvarying vec2 vUv0;\\nuniform sampler2D source;\\nuniform vec2 pixelOffset;\\nuniform vec2 sigmas;\\nuniform float bZnorm;\\nuniform float kernel[MSIZE];\\nvoid main(void) {\\n\\tvec4 pixelRgbm = texture2D(source, vUv0);\\n\\tif (pixelRgbm.a <= 0.0) {\\n\\t\\tgl_FragColor = pixelRgbm;\\n\\t\\treturn ;\\n\\t}\\n\\tfloat sigma = sigmas.x;\\n\\tfloat bSigma = sigmas.y;\\n\\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\\n\\tvec3 accumulatedHdr = vec3(0.0);\\n\\tfloat accumulatedFactor = 0.0;\\n\\tconst int kSize = (MSIZE-1)/2;\\n\\tfor (int i = -kSize; i <= kSize; ++i) {\\n\\t\\tfor (int j = -kSize; j <= kSize; ++j) {\\n\\t\\t\\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\\n\\t\\t\\tvec4 rgbm = texture2D(source, coord);\\n\\t\\t\\tif (rgbm.a > 0.0) {\\n\\t\\t\\t\\tvec3 hdr = decodeRGBM(rgbm);\\n\\t\\t\\t\\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\\n\\t\\t\\t\\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\\n\\t\\t\\t\\taccumulatedHdr += factor * hdr;\\n\\t\\t\\t\\taccumulatedFactor += factor;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\\n}\\n\";\n\nvar emissivePS = \"#ifdef MAPCOLOR\\nuniform vec3 material_emissive;\\n#endif\\n#ifdef MAPFLOAT\\nuniform float material_emissiveIntensity;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_emissiveMap;\\n#endif\\nvec3 getEmission() {\\n\\tvec3 emission = vec3(1.0);\\n\\t#ifdef MAPFLOAT\\n\\temission *= material_emissiveIntensity;\\n\\t#endif\\n\\t#ifdef MAPCOLOR\\n\\temission *= material_emissive;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\temission *= $texture2DSAMPLE(texture_emissiveMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\temission *= gammaCorrectInput(saturate(vVertexColor.$VC));\\n\\t#endif\\n\\treturn emission;\\n}\\n\";\n\nvar endPS = \"\\t#ifdef CLEARCOAT\\n\\tgl_FragColor.rgb = combineColorCC();\\n\\t#else\\n\\tgl_FragColor.rgb = combineColor();\\n\\t#endif\\n\\tgl_FragColor.rgb += getEmission();\\n\\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\\n\\t#ifndef HDR\\n\\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\\n\\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\\n\\t#endif\\n\";\n\nvar endVS = \"\\n\";\n\nvar envConstPS = \"vec3 processEnvironment(vec3 color) {\\n\\treturn color;\\n}\\n\";\n\nvar envMultiplyPS = \"uniform float skyboxIntensity;\\nvec3 processEnvironment(vec3 color) {\\n\\treturn color * skyboxIntensity;\\n}\\n\";\n\nvar extensionPS = \"\\n\";\n\nvar extensionVS = \"\\n\";\n\nvar falloffInvSquaredPS = \"float getFalloffWindow(float lightRadius) {\\n\\tfloat sqrDist = dot(dLightDirW, dLightDirW);\\n\\tfloat invRadius = 1.0 / lightRadius;\\n\\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\\n}\\nfloat getFalloffInvSquared(float lightRadius) {\\n\\tfloat sqrDist = dot(dLightDirW, dLightDirW);\\n\\tfloat falloff = 1.0 / (sqrDist + 1.0);\\n\\tfloat invRadius = 1.0 / lightRadius;\\n\\tfalloff *= 16.0;\\n\\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\\n\\treturn falloff;\\n}\\n\";\n\nvar falloffLinearPS = \"float getFalloffLinear(float lightRadius) {\\n\\tfloat d = length(dLightDirW);\\n\\treturn max(((lightRadius - d) / lightRadius), 0.0);\\n}\\n\";\n\nvar fixCubemapSeamsNonePS = \"vec3 fixSeams(vec3 vec, float mipmapIndex) {\\n\\treturn vec;\\n}\\nvec3 fixSeams(vec3 vec) {\\n\\treturn vec;\\n}\\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\\n\\treturn vec;\\n}\\nvec3 calcSeam(vec3 vec) {\\n\\treturn vec3(0);\\n}\\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\\n\\treturn vec;\\n}\\n\";\n\nvar fixCubemapSeamsStretchPS = \"vec3 fixSeams(vec3 vec, float mipmapIndex) {\\n\\tvec3 avec = abs(vec);\\n\\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\\n\\tfloat M = max(max(avec.x, avec.y), avec.z);\\n\\tif (avec.x != M) vec.x *= scale;\\n\\tif (avec.y != M) vec.y *= scale;\\n\\tif (avec.z != M) vec.z *= scale;\\n\\treturn vec;\\n}\\nvec3 fixSeams(vec3 vec) {\\n\\tvec3 avec = abs(vec);\\n\\tfloat scale = 1.0 - 1.0 / 128.0;\\n\\tfloat M = max(max(avec.x, avec.y), avec.z);\\n\\tif (avec.x != M) vec.x *= scale;\\n\\tif (avec.y != M) vec.y *= scale;\\n\\tif (avec.z != M) vec.z *= scale;\\n\\treturn vec;\\n}\\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\\n\\tvec3 avec = abs(vec);\\n\\tfloat scale = invRecMipSize;\\n\\tfloat M = max(max(avec.x, avec.y), avec.z);\\n\\tif (avec.x != M) vec.x *= scale;\\n\\tif (avec.y != M) vec.y *= scale;\\n\\tif (avec.z != M) vec.z *= scale;\\n\\treturn vec;\\n}\\nvec3 calcSeam(vec3 vec) {\\n\\tvec3 avec = abs(vec);\\n\\tfloat M = max(avec.x, max(avec.y, avec.z));\\n\\treturn vec3(avec.x != M ? 1.0 : 0.0,\\n\\t\\t\\t\\tavec.y != M ? 1.0 : 0.0,\\n\\t\\t\\t\\tavec.z != M ? 1.0 : 0.0);\\n}\\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\\n\\treturn vec * (seam * -scale + vec3(1.0));\\n}\\n\";\n\nvar floatUnpackingPS = \"float bytes2float2(vec2 data) {\\n\\treturn dot(data, vec2(1.0, 1.0 / 255.0));\\n}\\nfloat bytes2float3(vec3 data) {\\n\\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\\n}\\nfloat bytes2float4(vec4 data) {\\n\\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\\n}\\nfloat bytes2floatRange2(vec2 data, float min, float max) {\\n\\treturn mix(min, max, bytes2float2(data));\\n}\\nfloat bytes2floatRange3(vec3 data, float min, float max) {\\n\\treturn mix(min, max, bytes2float3(data));\\n}\\nfloat bytes2floatRange4(vec4 data, float min, float max) {\\n\\treturn mix(min, max, bytes2float4(data));\\n}\\nfloat mantissaExponent2Float(vec4 pack)\\n{\\n\\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\\n\\tfloat exponent = floor(pack.w * 255.0 - 127.0);\\n\\treturn value * exp2(exponent);\\n}\\n\";\n\nvar fogExpPS = \"uniform vec3 fog_color;\\nuniform float fog_density;\\nfloat dBlendModeFogFactor = 1.0;\\nvec3 addFog(vec3 color) {\\n\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\tfloat fogFactor = exp(-depth * fog_density);\\n\\tfogFactor = clamp(fogFactor, 0.0, 1.0);\\n\\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\\n}\\n\";\n\nvar fogExp2PS = \"uniform vec3 fog_color;\\nuniform float fog_density;\\nfloat dBlendModeFogFactor = 1.0;\\nvec3 addFog(vec3 color) {\\n\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\\n\\tfogFactor = clamp(fogFactor, 0.0, 1.0);\\n\\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\\n}\\n\";\n\nvar fogLinearPS = \"uniform vec3 fog_color;\\nuniform float fog_start;\\nuniform float fog_end;\\nfloat dBlendModeFogFactor = 1.0;\\nvec3 addFog(vec3 color) {\\n\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\\n\\tfogFactor = clamp(fogFactor, 0.0, 1.0);\\n\\tfogFactor = gammaCorrectInput(fogFactor);\\n\\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\\n}\\n\";\n\nvar fogNonePS = \"float dBlendModeFogFactor = 1.0;\\nvec3 addFog(vec3 color) {\\n\\treturn color;\\n}\\n\";\n\nvar fresnelSchlickPS = \"uniform float material_fresnelFactor;\\nvoid getFresnel() {\\n\\tfloat fresnel = 1.0 - max(dot(dNormalW, dViewDirW), 0.0);\\n\\tfloat fresnel2 = fresnel * fresnel;\\n\\tfresnel *= fresnel2 * fresnel2;\\n\\tfresnel *= dGlossiness * dGlossiness;\\n\\tdSpecularity = dSpecularity + (1.0 - dSpecularity) * fresnel;\\n\\t#ifdef CLEARCOAT\\n\\tfresnel = 1.0 - max(dot(ccNormalW, dViewDirW), 0.0);\\n\\tfresnel2 = fresnel * fresnel;\\n\\tfresnel *= fresnel2 * fresnel2;\\n\\tfresnel *= ccGlossiness * ccGlossiness;\\n\\tccSpecularity = ccSpecularity + (1.0 - ccSpecularity) * fresnel;\\n\\t#endif\\n}\\n\";\n\nvar fullscreenQuadPS = \"varying vec2 vUv0;\\nuniform sampler2D source;\\nvoid main(void) {\\n\\tgl_FragColor = texture2D(source, vUv0);\\n}\\n\";\n\nvar fullscreenQuadVS = \"attribute vec2 vertex_position;\\nvarying vec2 vUv0;\\nvoid main(void)\\n{\\n\\tgl_Position = vec4(vertex_position, 0.5, 1.0);\\n\\tvUv0 = vertex_position.xy*0.5+0.5;\\n}\\n\";\n\nvar gamma1_0PS = \"vec4 texture2DSRGB(sampler2D tex, vec2 uv) {\\n\\treturn texture2D(tex, uv);\\n}\\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\\n\\treturn texture2D(tex, uv, bias);\\n}\\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\\n\\treturn textureCube(tex, uvw);\\n}\\nvec3 gammaCorrectOutput(vec3 color) {\\n\\treturn color;\\n}\\nvec3 gammaCorrectInput(vec3 color) {\\n\\treturn color;\\n}\\nfloat gammaCorrectInput(float color) {\\n\\treturn color;\\n}\\nvec4 gammaCorrectInput(vec4 color) {\\n\\treturn color;\\n}\\n\";\n\nvar gamma2_2PS = \"vec3 gammaCorrectInput(vec3 color) {\\n\\treturn pow(color, vec3(2.2));\\n}\\nfloat gammaCorrectInput(float color) {\\n\\treturn pow(color, 2.2);\\n}\\nvec4 gammaCorrectInput(vec4 color) {\\n\\treturn vec4(pow(color.rgb, vec3(2.2)), color.a);\\n}\\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\\n\\tvec4 rgba = texture2D(tex, uv);\\n\\trgba.rgb = gammaCorrectInput(rgba.rgb);\\n\\treturn rgba;\\n}\\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\\n\\tvec4 rgba = texture2D(tex, uv, bias);\\n\\trgba.rgb = gammaCorrectInput(rgba.rgb);\\n\\treturn rgba;\\n}\\nvec4 textureCubeSRGB(samplerCube tex, vec3 uvw) {\\n\\tvec4 rgba = textureCube(tex, uvw);\\n\\trgba.rgb = gammaCorrectInput(rgba.rgb);\\n\\treturn rgba;\\n}\\nvec3 gammaCorrectOutput(vec3 color) {\\n\\t#ifdef HDR\\n\\treturn color;\\n\\t#else\\n\\tcolor += vec3(0.0000001);\\n\\treturn pow(color, vec3(0.45));\\n\\t#endif\\n}\\n\";\n\nvar gles3PS = \"#define varying in\\nout highp vec4 pc_fragColor;\\n#define gl_FragColor pc_fragColor\\n#define texture2D texture\\n#define textureCube texture\\n#define texture2DProj textureProj\\n#define texture2DLodEXT textureLod\\n#define texture2DProjLodEXT textureProjLod\\n#define textureCubeLodEXT textureLod\\n#define texture2DGradEXT textureGrad\\n#define texture2DProjGradEXT textureProjGrad\\n#define textureCubeGradEXT textureGrad\\n#define GL2\\n#define SUPPORTS_TEXLOD\\n\";\n\nvar gles3VS = \"#define attribute in\\n#define varying out\\n#define texture2D texture\\n#define GL2\\n#define VERTEXSHADER\\n\";\n\nvar glossPS = \"#ifdef MAPFLOAT\\nuniform float material_shininess;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_glossMap;\\n#endif\\nvoid getGlossiness() {\\n\\tdGlossiness = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tdGlossiness *= material_shininess;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdGlossiness *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tdGlossiness += 0.0000001;\\n}\\n\";\n\nvar instancingVS = \"attribute vec4 instance_line1;\\nattribute vec4 instance_line2;\\nattribute vec4 instance_line3;\\nattribute vec4 instance_line4;\\n\";\n\nvar lightDiffuseLambertPS = \"float getLightDiffuse() {\\n\\treturn max(dot(dNormalW, -dLightDirNormW), 0.0);\\n}\\n\";\n\nvar lightDirPointPS = \"void getLightDirPoint(vec3 lightPosW) {\\n\\tdLightDirW = vPositionW - lightPosW;\\n\\tdLightDirNormW = normalize(dLightDirW);\\n\\tdLightPosW = lightPosW;\\n}\\n\";\n\nvar lightmapDirPS = \"uniform sampler2D texture_lightMap;\\nuniform sampler2D texture_dirLightMap;\\nvoid addLightMap() {\\n\\tvec3 color = $texture2DSAMPLE(texture_lightMap, $UV).$CH;\\n\\tvec3 dir = texture2D(texture_dirLightMap, $UV).xyz;\\n\\tif (dot(dir, vec3(1.0)) < 0.00001) {\\n\\t\\tdDiffuseLight += color;\\n\\t} else {\\n\\t\\tdLightDirNormW = normalize(dir * 2.0 - vec3(1.0));\\n\\t\\tfloat vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));\\n\\t\\tfloat flight = saturate(dot(dLightDirNormW, -dNormalW));\\n\\t\\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\\n\\t\\tdDiffuseLight += color * nlight * 2.0;\\n\\t}\\n\\tdSpecularLight += color * getLightSpecular();\\n}\\n\";\n\nvar lightmapSinglePS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_lightMap;\\n#endif\\nvoid addLightMap() {\\n\\tvec3 lm = vec3(1.0);\\n\\t#ifdef MAPTEXTURE\\n\\tlm *= $texture2DSAMPLE(texture_lightMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tlm *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tdDiffuseLight += lm;\\n}\\n\";\n\nvar lightmapSingleVertPS = \"void addLightMap() {\\n\\tdDiffuseLight += saturate(vVertexColor.$CH);\\n}\\n\";\n\nvar lightSpecularAnisoGGXPS = \"float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\\n\\tfloat PI = 3.141592653589793;\\n\\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\\n\\tfloat anisotropy = material_anisotropy * roughness;\\n\\tfloat at = max((roughness + anisotropy), roughness / 4.0);\\n\\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\\n\\tvec3 h = normalize(normalize(-dLightDirNormW) + normalize(dViewDirW));\\n\\tfloat NoH = dot(tNormalW, h);\\n\\tfloat ToH = dot(dTBN[0], h);\\n\\tfloat BoH = dot(dTBN[1], h);\\n\\tfloat a2 = at * ab;\\n\\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\\n\\tfloat v2 = dot(v, v);\\n\\tfloat w2 = a2 / v2;\\n\\tfloat D = a2 * w2 * w2 * (1.0 / PI);\\n\\tfloat ToV = dot(dTBN[0], dViewDirW);\\n\\tfloat BoV = dot(dTBN[1], dViewDirW);\\n\\tfloat ToL = dot(dTBN[0], -dLightDirNormW);\\n\\tfloat BoL = dot(dTBN[1], -dLightDirNormW);\\n\\tfloat NoV = dot(tNormalW, dViewDirW);\\n\\tfloat NoL = dot(tNormalW, -dLightDirNormW);\\n\\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\\n\\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\\n\\tfloat G = 0.5 / (lambdaV + lambdaL);\\n\\treturn D * G;\\n}\\nfloat getLightSpecular() {\\n\\treturn calcLightSpecular(dGlossiness, dNormalW);\\n}\\nfloat getLightSpecularCC() {\\n\\treturn calcLightSpecular(ccGlossiness, ccNormalW);\\n}\\n\";\n\nvar lightSpecularBlinnPS = \"float calcLightSpecular(float tGlossiness, vec3 tNormalW) {\\n\\tvec3 h = normalize( -dLightDirNormW + dViewDirW );\\n\\tfloat nh = max( dot( h, tNormalW ), 0.0 );\\n\\tfloat specPow = exp2(tGlossiness * 11.0);\\n\\tspecPow = antiAliasGlossiness(specPow);\\n\\tspecPow = max(specPow, 0.0001);\\n\\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\\n}\\nfloat getLightSpecular() {\\n\\treturn calcLightSpecular(dGlossiness, dNormalW);\\n}\\nfloat getLightSpecularCC() {\\n\\treturn calcLightSpecular(ccGlossiness, ccNormalW);\\n}\\n\";\n\nvar lightSpecularPhongPS = \"float calcLightSpecular(float tGlossiness, vec3 tReflDirW) {\\n\\tfloat specPow = tGlossiness;\\n\\tspecPow = antiAliasGlossiness(specPow);\\n\\treturn pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);\\n}\\nfloat getLightSpecular() {\\n\\treturn calcLightSpecular(dGlossiness, dReflDirW);\\n}\\nfloat getLightSpecularCC() {\\n\\treturn calcLightSpecular(ccGlossiness, ccReflDirW);\\n}\\n\";\n\nvar ltc = \"mat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nstruct Coords {\\n\\tvec3 coord0;\\n\\tvec3 coord1;\\n\\tvec3 coord2;\\n\\tvec3 coord3;\\n};\\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\\n\\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\\n\\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 =\tfactor * cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn result;\\n}\\nCoords dLTCCoords;\\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\\n\\tCoords coords;\\n\\tcoords.coord0 = lightPos + halfWidth - halfHeight;\\n\\tcoords.coord1 = lightPos - halfWidth - halfHeight;\\n\\tcoords.coord2 = lightPos - halfWidth + halfHeight;\\n\\tcoords.coord3 = lightPos + halfWidth + halfHeight;\\n\\treturn coords;\\n}\\nfloat dSphereRadius;\\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\\n\\tdSphereRadius = max(length(halfWidth), length(halfHeight));\\n\\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\\n\\tvec3 w = normalize(cross(f, halfHeight));\\n\\tvec3 h = normalize(cross(f, w));\\n\\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\\n}\\nvec2 dLTCUV;\\n#ifdef CLEARCOAT\\nvec2 ccLTCUV;\\n#endif\\nvec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)\\n{\\n\\tfloat roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);\\n\\treturn LTC_Uv( tNormalW, dViewDirW, roughness );\\n}\\nvec3 dLTCSpecFres;\\n#ifdef CLEARCOAT\\nvec3 ccLTCSpecFres;\\n#endif\\nvec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)\\n{\\n\\tvec4 t2 = texture2D( areaLightsLutTex2, uv );\\n\\t#ifdef AREA_R8_G8_B8_A8_LUTS\\n\\tt2 *= vec4(0.693103,1,1,1);\\n\\tt2 += vec4(0.306897,0,0,0);\\n\\t#endif\\n\\treturn tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;\\n}\\nvoid calcLTCLightValues()\\n{\\n\\tdLTCUV = getLTCLightUV(dGlossiness, dNormalW);\\n\\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularityNoFres);\\n#ifdef CLEARCOAT\\n\\tccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);\\n\\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularityNoFres));\\n#endif\\n}\\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\\n{\\n\\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\\n}\\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\\n{\\n\\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\\n}\\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\\n{\\n\\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\\n}\\nvec3 SolveCubic(vec4 Coefficient)\\n{\\n\\tfloat pi = 3.14159;\\n\\tCoefficient.xyz /= Coefficient.w;\\n\\tCoefficient.yz /= 3.0;\\n\\tfloat A = Coefficient.w;\\n\\tfloat B = Coefficient.z;\\n\\tfloat C = Coefficient.y;\\n\\tfloat D = Coefficient.x;\\n\\tvec3 Delta = vec3(\\n\\t\\t-Coefficient.z * Coefficient.z + Coefficient.y,\\n\\t\\t-Coefficient.y * Coefficient.z + Coefficient.x,\\n\\t\\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\\n\\t);\\n\\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\\n\\tvec3 RootsA, RootsD;\\n\\tvec2 xlc, xsc;\\n\\t{\\n\\t\\tfloat A_a = 1.0;\\n\\t\\tfloat C_a = Delta.x;\\n\\t\\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\\n\\t\\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\\n\\t\\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\\n\\t\\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\\n\\t\\tfloat xl;\\n\\t\\tif ((x_1a + x_3a) > 2.0 * B)\\n\\t\\t\\txl = x_1a;\\n\\t\\telse\\n\\t\\t\\txl = x_3a;\\n\\t\\txlc = vec2(xl - B, A);\\n\\t}\\n\\t{\\n\\t\\tfloat A_d = D;\\n\\t\\tfloat C_d = Delta.z;\\n\\t\\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\\n\\t\\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\\n\\t\\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\\n\\t\\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\\n\\t\\tfloat xs;\\n\\t\\tif (x_1d + x_3d < 2.0 * C)\\n\\t\\t\\txs = x_1d;\\n\\t\\telse\\n\\t\\t\\txs = x_3d;\\n\\t\\txsc = vec2(-D, xs + C);\\n\\t}\\n\\tfloat E =\txlc.y * xsc.y;\\n\\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\\n\\tfloat G =\txlc.x * xsc.x;\\n\\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\\n\\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\\n\\tif (Root.x < Root.y && Root.x < Root.z)\\n\\t\\tRoot.xyz = Root.yxz;\\n\\telse if (Root.z < Root.x && Root.z < Root.y)\\n\\t\\tRoot.xyz = Root.xzy;\\n\\treturn Root;\\n}\\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\\n{\\n\\tvec3 T1, T2;\\n\\tT1 = normalize(V - N * dot(V, N));\\n\\tT2 = cross(N, T1);\\n\\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 L_[ 3 ];\\n\\tL_[ 0 ] = R * ( points.coord0 - P );\\n\\tL_[ 1 ] = R * ( points.coord1 - P );\\n\\tL_[ 2 ] = R * ( points.coord2 - P );\\n\\tvec3 Lo_i = vec3(0);\\n\\tvec3 C\t= 0.5 * (L_[0] + L_[2]);\\n\\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\\n\\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\\n\\tC\t= Minv * C;\\n\\tV1 = Minv * V1;\\n\\tV2 = Minv * V2;\\n\\tfloat a, b;\\n\\tfloat d11 = dot(V1, V1);\\n\\tfloat d22 = dot(V2, V2);\\n\\tfloat d12 = dot(V1, V2);\\n\\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\\n\\t{\\n\\t\\tfloat tr = d11 + d22;\\n\\t\\tfloat det = -d12 * d12 + d11 * d22;\\n\\t\\tdet = sqrt(det);\\n\\t\\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\\n\\t\\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\\n\\t\\tfloat e_max = (u + v) * (u + v);\\n\\t\\tfloat e_min = (u - v) * (u - v);\\n\\t\\tvec3 V1_, V2_;\\n\\t\\tif (d11 > d22)\\n\\t\\t{\\n\\t\\t\\tV1_ = d12 * V1 + (e_max - d11) * V2;\\n\\t\\t\\tV2_ = d12 * V1 + (e_min - d11) * V2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tV1_ = d12*V2 + (e_max - d22)*V1;\\n\\t\\t\\tV2_ = d12*V2 + (e_min - d22)*V1;\\n\\t\\t}\\n\\t\\ta = 1.0 / e_max;\\n\\t\\tb = 1.0 / e_min;\\n\\t\\tV1 = normalize(V1_);\\n\\t\\tV2 = normalize(V2_);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\ta = 1.0 / dot(V1, V1);\\n\\t\\tb = 1.0 / dot(V2, V2);\\n\\t\\tV1 *= sqrt(a);\\n\\t\\tV2 *= sqrt(b);\\n\\t}\\n\\tvec3 V3 = cross(V1, V2);\\n\\tif (dot(C, V3) < 0.0)\\n\\t\\tV3 *= -1.0;\\n\\tfloat L\t= dot(V3, C);\\n\\tfloat x0 = dot(V1, C) / L;\\n\\tfloat y0 = dot(V2, C) / L;\\n\\tfloat E1 = inversesqrt(a);\\n\\tfloat E2 = inversesqrt(b);\\n\\ta *= L * L;\\n\\tb *= L * L;\\n\\tfloat c0 = a * b;\\n\\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\\n\\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\\n\\tfloat c3 = 1.0;\\n\\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\\n\\tfloat e1 = roots.x;\\n\\tfloat e2 = roots.y;\\n\\tfloat e3 = roots.z;\\n\\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\\n\\tmat3 rotate = mat3(V1, V2, V3);\\n\\tavgDir = rotate * avgDir;\\n\\tavgDir = normalize(avgDir);\\n\\tfloat L1 = sqrt(-e2 / e3);\\n\\tfloat L2 = sqrt(-e2 / e1);\\n\\tfloat formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\\n\\tuv = uv*LUT_SCALE + LUT_BIAS;\\n\\tfloat scale = texture2D( areaLightsLutTex2, uv ).w;\\n\\treturn formFactor*scale;\\n}\\nfloat getRectLightDiffuse() {\\n\\treturn LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\\n}\\nfloat getDiskLightDiffuse() {\\n\\treturn LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );\\n}\\nfloat getSphereLightDiffuse() {\\n\\tfloat falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);\\n\\treturn getLightDiffuse()*falloff;\\n}\\nmat3 getLTCLightInvMat(vec2 uv)\\n{\\n\\tvec4 t1 = texture2D( areaLightsLutTex1, uv );\\n\\t#ifdef AREA_R8_G8_B8_A8_LUTS\\n\\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\\n\\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\\n\\t#endif\\n\\treturn mat3(\\n\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\tvec3(\\t0, 1,\\t0 ),\\n\\t\\tvec3( t1.z, 0, t1.w )\\n\\t);\\n}\\nfloat calcRectLightSpecular(vec3 tNormalW, vec2 uv) {\\n\\tmat3 mInv = getLTCLightInvMat(uv);\\n\\treturn LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\\n}\\nfloat getRectLightSpecular() {\\n\\treturn calcRectLightSpecular(dNormalW, dLTCUV);\\n}\\n#ifdef CLEARCOAT\\nfloat getRectLightSpecularCC() {\\n\\treturn calcRectLightSpecular(ccNormalW, ccLTCUV);\\n}\\n#endif\\nfloat calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {\\n\\tmat3 mInv = getLTCLightInvMat(uv);\\n\\treturn LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );\\n}\\nfloat getDiskLightSpecular() {\\n\\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\\n}\\n#ifdef CLEARCOAT\\nfloat getDiskLightSpecularCC() {\\n\\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\\n}\\n#endif\\nfloat getSphereLightSpecular() {\\n\\treturn calcDiskLightSpecular(dNormalW, dLTCUV);\\n}\\n#ifdef CLEARCOAT\\nfloat getSphereLightSpecularCC() {\\n\\treturn calcDiskLightSpecular(ccNormalW, ccLTCUV);\\n}\\n#endif\\n\";\n\nvar metalnessPS = \"void processMetalness(float metalness) {\\n\\tconst float dielectricF0 = 0.04;\\n\\tdSpecularity = mix(vec3(dielectricF0), dAlbedo, metalness);\\n\\tdAlbedo *= 1.0 - metalness;\\n}\\n#ifdef MAPFLOAT\\nuniform float material_metalness;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_metalnessMap;\\n#endif\\nvoid getSpecularity() {\\n\\tfloat metalness = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tmetalness *= material_metalness;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tmetalness *= texture2D(texture_metalnessMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tmetalness *= saturate(vVertexColor.$VC);\\n\\t#endif\\n\\tprocessMetalness(metalness);\\n}\\n\";\n\nvar msdfPS = \"uniform sampler2D texture_msdfMap;\\n#ifdef GL_OES_standard_derivatives\\n#define USE_FWIDTH\\n#endif\\n#ifdef GL2\\n#define USE_FWIDTH\\n#endif\\nfloat median(float r, float g, float b) {\\n\\treturn max(min(r, g), min(max(r, g), b));\\n}\\nfloat map (float min, float max, float v) {\\n\\treturn (v - min) / (max - min);\\n}\\nuniform float font_sdfIntensity;\\nuniform float font_pxrange;\\nuniform float font_textureWidth;\\nuniform vec4 outline_color;\\nuniform float outline_thickness;\\nuniform vec4 shadow_color;\\nuniform vec2 shadow_offset;\\nvec4 applyMsdf(vec4 color) {\\n\\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\\n\\tvec2 uvShdw = vUv0 - shadow_offset;\\n\\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\\n\\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\\n\\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\\n\\tfloat smoothingMax = 0.2;\\n\\t#ifdef USE_FWIDTH\\n\\tvec2 w = fwidth(vUv0);\\n\\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\\n\\t#else\\n\\tfloat font_size = 16.0;\\n\\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\\n\\t#endif\\n\\tfloat mapMin = 0.05;\\n\\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\\n\\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\\n\\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\\n\\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\\n\\tfloat center = 0.5;\\n\\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\\n\\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\\n\\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\\n\\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\\n\\ttcolor = mix(tcolor, color, inside);\\n\\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\\n\\ttcolor = mix(scolor, tcolor, outline);\\n\\treturn tcolor;\\n}\\n\";\n\nvar normalVS = \"#ifdef MORPHING_TEXTURE_BASED_NORMAL\\nuniform highp sampler2D morphNormalTex;\\n#endif\\nvec3 getNormal() {\\n\\t#ifdef SKIN\\n\\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\\n\\t#elif defined(INSTANCING)\\n\\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\\n\\t#else\\n\\tdNormalMatrix = matrix_normal;\\n\\t#endif\\n\\tvec3 tempNormal = vertex_normal;\\n\\t#ifdef MORPHING\\n\\t#ifdef MORPHING_NRM03\\n\\ttempNormal += morph_weights_a[0] * morph_nrm0;\\n\\ttempNormal += morph_weights_a[1] * morph_nrm1;\\n\\ttempNormal += morph_weights_a[2] * morph_nrm2;\\n\\ttempNormal += morph_weights_a[3] * morph_nrm3;\\n\\t#endif\\n\\t#ifdef MORPHING_NRM47\\n\\ttempNormal += morph_weights_b[0] * morph_nrm4;\\n\\ttempNormal += morph_weights_b[1] * morph_nrm5;\\n\\ttempNormal += morph_weights_b[2] * morph_nrm6;\\n\\ttempNormal += morph_weights_b[3] * morph_nrm7;\\n\\t#endif\\n\\t#endif\\n\\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\\n\\tvec2 morphUV = getTextureMorphCoords();\\n\\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\\n\\ttempNormal += morphNormal;\\n\\t#endif\\n\\treturn normalize(dNormalMatrix * tempNormal);\\n}\\n\";\n\nvar normalDetailMapPS = \"#ifdef MAPTEXTURE\\nuniform sampler2D texture_normalDetailMap;\\nuniform float material_normalDetailMapBumpiness;\\nvec3 blendNormals(vec3 n1, vec3 n2) {\\n\\tn1 += vec3(0, 0, 1);\\n\\tn2 *= vec3(-1, -1, 1);\\n\\treturn normalize(n1*dot(n1, n2)/n1.z - n2);\\n}\\n#endif\\nvec3 addNormalDetail(vec3 normalMap) {\\n\\t#ifdef MAPTEXTURE\\n\\tvec3 normalDetailMap = unpackNormal(texture2D(texture_normalDetailMap, $UV));\\n\\tnormalDetailMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness));\\n\\treturn blendNormals(normalMap, normalDetailMap);\\n\\t#else\\n\\treturn normalMap;\\n\\t#endif\\n}\\n\";\n\nvar normalInstancedVS = \"vec3 getNormal() {\\n\\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\\n\\treturn normalize(dNormalMatrix * vertex_normal);\\n}\\n\";\n\nvar normalMapPS = \"uniform sampler2D texture_normalMap;\\nuniform float material_bumpiness;\\nvoid getNormal() {\\n\\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\\n\\tnormalMap = normalize(mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness));\\n\\tdNormalMap = addNormalDetail(normalMap);\\n\\tdNormalW = dTBN * dNormalMap;\\n}\\n\";\n\nvar normalMapFastPS = \"uniform sampler2D texture_normalMap;\\nvoid getNormal() {\\n\\tvec3 normalMap = unpackNormal(texture2D(texture_normalMap, $UV));\\n\\tdNormalMap = addNormalDetail(normalMap);\\n\\tdNormalW = dTBN * dNormalMap;\\n}\\n\";\n\nvar normalSkinnedVS = \"vec3 getNormal() {\\n\\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\\n\\treturn normalize(dNormalMatrix * vertex_normal);\\n}\\n\";\n\nvar normalVertexPS = \"void getNormal() {\\n\\tdNormalW = normalize(dVertexNormalW);\\n}\\n\";\n\nvar normalXYPS = \"vec3 unpackNormal(vec4 nmap) {\\n\\tvec3 normal;\\n\\tnormal.xy = nmap.wy * 2.0 - 1.0;\\n\\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\\n\\treturn normal;\\n}\\n\";\n\nvar normalXYZPS = \"vec3 unpackNormal(vec4 nmap) {\\n\\treturn nmap.xyz * 2.0 - 1.0;\\n}\\n\";\n\nvar opacityPS = \"#ifdef MAPFLOAT\\nuniform float material_opacity;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_opacityMap;\\n#endif\\nvoid getOpacity() {\\n\\tdAlpha = 1.0;\\n\\t#ifdef MAPFLOAT\\n\\tdAlpha *= material_opacity;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tdAlpha *= texture2D(texture_opacityMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\\n\\t#endif\\n}\\n\";\n\nvar outputAlphaPS = \"gl_FragColor.a = dAlpha;\\n\";\n\nvar outputAlphaOpaquePS = \"gl_FragColor.a = 1.0;\\n\";\n\nvar outputAlphaPremulPS = \"gl_FragColor.rgb *= dAlpha;\\ngl_FragColor.a = dAlpha;\\n\";\n\nvar outputCubemapPS = \"varying vec2 vUv0;\\nuniform samplerCube source;\\nuniform vec4 params;\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec4 encodeRGBM(vec4 color) {\\n\\tcolor.rgb = pow(color.rgb, vec3(0.5));\\n\\tcolor.rgb *= 1.0 / 8.0;\\n\\tcolor.a = saturate( max( max( color.r, color.g ), max( color.b, 1.0 / 255.0 ) ) );\\n\\tcolor.a = ceil(color.a * 255.0) / 255.0;\\n\\tcolor.rgb /= color.a;\\n\\treturn color;\\n}\\nvoid main(void) {\\n\\tvec2 st = vUv0 * 2.0 - 1.0;\\n\\tfloat face = params.x;\\n\\tvec3 vec;\\n\\tif (face==0.0) {\\n\\t\\tvec = vec3(1, -st.y, -st.x);\\n\\t} else if (face==1.0) {\\n\\t\\tvec = vec3(-1, -st.y, st.x);\\n\\t} else if (face==2.0) {\\n\\t\\tvec = vec3(st.x, 1, st.y);\\n\\t} else if (face==3.0) {\\n\\t\\tvec = vec3(st.x, -1, -st.y);\\n\\t} else if (face==4.0) {\\n\\t\\tvec = vec3(st.x, -st.y, 1);\\n\\t} else {\\n\\t\\tvec = vec3(-st.x, -st.y, -1);\\n\\t}\\n\\tgl_FragColor = textureCube(source, vec);\\n\\tif (params.w >= 2.0) gl_FragColor = encodeRGBM(gl_FragColor);\\n}\\n\";\n\nvar outputTex2DPS = \"varying vec2 vUv0;\\nuniform sampler2D source;\\nvoid main(void) {\\n\\tgl_FragColor = texture2D(source, vUv0);\\n}\\n\";\n\nvar packDepthPS = \"vec4 packFloat(float depth) {\\n\\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\\n\\tconst vec4 bit_mask\t= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\\n\\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\\n\\tres -= res.xxyz * bit_mask;\\n\\treturn res;\\n}\\n\";\n\nvar packDepthMaskPS = \"vec4 packFloat(float depth) {\\n\\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\\n\\tconst vec4 bit_mask\t= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\\n\\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\\n\\tres.x = 0.0;\\n\\tres -= res.xxyz * bit_mask;\\n\\treturn res;\\n}\\n\";\n\nvar parallaxPS = \"uniform sampler2D texture_heightMap;\\nuniform float material_heightMapFactor;\\nvoid getParallax() {\\n\\tfloat parallaxScale = material_heightMapFactor;\\n\\tfloat height = texture2D(texture_heightMap, $UV).$CH;\\n\\theight = height * parallaxScale - parallaxScale*0.5;\\n\\tvec3 viewDirT = dViewDirW * dTBN;\\n\\tviewDirT.z += 0.42;\\n\\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\\n}\\n\";\n\nvar particlePS = \"varying vec4 texCoordsAlphaLife;\\nuniform sampler2D colorMap;\\nuniform sampler2D colorParam;\\nuniform float graphSampleSize;\\nuniform float graphNumSamples;\\n#ifndef CAMERAPLANES\\n#define CAMERAPLANES\\nuniform vec4 camera_params;\\n#endif\\nuniform float softening;\\nuniform float colorMult;\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\n#ifndef UNPACKFLOAT\\n#define UNPACKFLOAT\\nfloat unpackFloat(vec4 rgbaDepth) {\\n\\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\\n\\tfloat depth = dot(rgbaDepth, bitShift);\\n\\treturn depth;\\n}\\n#endif\\nvoid main(void) {\\n\\tvec4 tex\t= texture2DSRGB(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\\n\\tvec4 ramp = texture2DSRGB(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\\n\\tramp.rgb *= colorMult;\\n\\tramp.a += texCoordsAlphaLife.z;\\n\\tvec3 rgb = tex.rgb * ramp.rgb;\\n\\tfloat a\t= tex.a * ramp.a;\\n\";\n\nvar particleVS = \"vec3 unpack3NFloats(float src) {\\n\\tfloat r = fract(src);\\n\\tfloat g = fract(src * 256.0);\\n\\tfloat b = fract(src * 65536.0);\\n\\treturn vec3(r, g, b);\\n}\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {\\n\\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\\n}\\nvec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\\n\\tvec4 a = texture2D(tex,tc);\\n\\tvec4 b = texture2D(tex,tc + graphSampleSize);\\n\\tfloat c = fract(tc.x*graphNumSamples);\\n\\tvec3 unpackedA = unpack3NFloats(a.w);\\n\\tvec3 unpackedB = unpack3NFloats(b.w);\\n\\tw = mix(unpackedA, unpackedB, c);\\n\\treturn mix(a, b, c);\\n}\\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\\n\\tfloat c = cos(pRotation);\\n\\tfloat s = sin(pRotation);\\n\\tmat2 m = mat2(c, -s, s, c);\\n\\trotMatrix = m;\\n\\treturn m * quadXY;\\n}\\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\\n\\t#ifdef SCREEN_SPACE\\n\\t\\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\\n\\t#else\\n\\t\\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\\n\\t#endif\\n\\treturn pos;\\n}\\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\\n\\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\\n\\treturn pos;\\n}\\nvec2 safeNormalize(vec2 v) {\\n\\tfloat l = length(v);\\n\\treturn (l > 1e-06) ? v / l : v;\\n}\\nvoid main(void) {\\n\\tvec3 meshLocalPos = particle_vertexData.xyz;\\n\\tfloat id = floor(particle_vertexData.w);\\n\\tfloat rndFactor = fract(sin(id + 1.0 + seed));\\n\\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\\n\\tfloat uv = id / numParticlesPot;\\n\\treadInput(uv);\\n#ifdef LOCAL_SPACE\\n\\tinVel = mat3(matrix_model) * inVel;\\n#endif\\n\\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\\n\\tfloat particleLifetime = lifetime;\\n\\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\\n\\tvec2 quadXY = meshLocalPos.xy;\\n\\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\\n\\tvec3 paramDiv;\\n\\tvec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\\n\\tfloat scale = params.y;\\n\\tfloat scaleDiv = paramDiv.x;\\n\\tfloat alphaDiv = paramDiv.z;\\n\\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\\n#ifndef USE_MESH\\n\\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\\n#else\\n\\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\\n#endif\\n\\tvec3 particlePos = inPos;\\n\\tvec3 particlePosMoved = vec3(0.0);\\n\\tmat2 rotMatrix;\\n\";\n\nvar particleAnimFrameClampVS = \"\\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\\n\";\n\nvar particleAnimFrameLoopVS = \"\\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\\n\";\n\nvar particleAnimTexVS = \"\\tfloat animationIndex;\\n\\tif (animTexIndexParams.y == 1.0) {\\n\\t\\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\\n\\t} else {\\n\\t\\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\\n\\t}\\n\\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\\n\\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\\n\\tatlasX = fract(atlasX);\\n\\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\\n\\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\\n\";\n\nvar particleInputFloatPS = \"void readInput(float uv) {\\n\\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\\n\\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\\n\\tinPos = tex.xyz;\\n\\tinVel = tex2.xyz;\\n\\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\\n\\tinShow = tex.w >= 0.0;\\n\\tinLife = tex2.w;\\n}\\n\";\n\nvar particleInputRgba8PS = \"#define PI2 6.283185307179586\\nuniform vec3 inBoundsSize;\\nuniform vec3 inBoundsCenter;\\nuniform float maxVel;\\nfloat decodeFloatRG(vec2 rg) {\\n\\treturn rg.y*(1.0/255.0) + rg.x;\\n}\\nfloat decodeFloatRGBA( vec4 rgba ) {\\n\treturn dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\\n}\\nvoid readInput(float uv) {\\n\\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\\n\\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\\n\\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\\n\\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\\n\\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\\n\\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\\n\\tinVel = tex2.xyz;\\n\\tinVel = (inVel - vec3(0.5)) * maxVel;\\n\\tinAngle = decodeFloatRG(tex1.ba) * PI2;\\n\\tinShow = tex2.a > 0.5;\\n\\tinLife = decodeFloatRGBA(tex3);\\n\\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\\n\\tfloat maxPosLife = lifetime+1.0;\\n\\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\\n}\\n\";\n\nvar particleOutputFloatPS = \"void writeOutput() {\\n\\tif (gl_FragCoord.y<1.0) {\\n\\t\\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\\n\\t} else {\\n\\t\\tgl_FragColor = vec4(outVel, outLife);\\n\\t}\\n}\\n\";\n\nvar particleOutputRgba8PS = \"uniform vec3 outBoundsMul;\\nuniform vec3 outBoundsAdd;\\nvec2 encodeFloatRG( float v ) {\\n\\tvec2 enc = vec2(1.0, 255.0) * v;\\n\\tenc = fract(enc);\\n\\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\\n\\treturn enc;\\n}\\nvec4 encodeFloatRGBA( float v ) {\\n\\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\\n\\tenc = fract(enc);\\n\\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\\n\\treturn enc;\\n}\\nvoid writeOutput() {\\n\\toutPos = outPos * outBoundsMul + outBoundsAdd;\\n\\toutAngle = fract(outAngle / PI2);\\n\\toutVel = (outVel / maxVel) + vec3(0.5);\\n\\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\\n\\tfloat maxPosLife = lifetime+1.0;\\n\\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\\n\\tif (gl_FragCoord.y < 1.0) {\\n\\t\\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\\n\\t} else if (gl_FragCoord.y < 2.0) {\\n\\t\\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\\n\\t} else if (gl_FragCoord.y < 3.0) {\\n\\t\\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\\n\\t} else {\\n\\t\\tgl_FragColor = encodeFloatRGBA(outLife);\\n\\t}\\n}\\n\";\n\nvar particleUpdaterAABBPS = \"uniform mat3 spawnBounds;\\nuniform vec3 spawnPosInnerRatio;\\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\\n\\tvec3 pos = inBounds - vec3(0.5);\\n\\tvec3 posAbs = abs(pos);\\n\\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\\n\\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\\n\\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\\n\\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\\n\\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\\n#ifndef LOCAL_SPACE\\n\\treturn emitterPos + spawnBounds * pos;\\n#else\\n\\treturn spawnBounds * pos;\\n#endif\\n}\\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\\n\\tlocalVelocity -= vec3(0, 0, initialVelocity);\\n}\\n\";\n\nvar particleUpdaterEndPS = \"\\twriteOutput();\\n}\\n\";\n\nvar particleUpdaterInitPS = \"varying vec2 vUv0;\\nuniform highp sampler2D particleTexIN;\\nuniform highp sampler2D internalTex0;\\nuniform highp sampler2D internalTex1;\\nuniform highp sampler2D internalTex2;\\nuniform highp sampler2D internalTex3;\\nuniform mat3 emitterMatrix, emitterMatrixInv;\\nuniform vec3 emitterScale;\\nuniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;\\nuniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;\\nuniform float startAngle, startAngle2;\\nuniform float initialVelocity;\\nuniform float graphSampleSize;\\nuniform float graphNumSamples;\\nvec3 inPos;\\nvec3 inVel;\\nfloat inAngle;\\nbool inShow;\\nfloat inLife;\\nfloat visMode;\\nvec3 outPos;\\nvec3 outVel;\\nfloat outAngle;\\nbool outShow;\\nfloat outLife;\\n\";\n\nvar particleUpdaterNoRespawnPS = \"\\tif (outLife >= lifetime) {\\n\\t\\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\\n\\t\\tvisMode = -1.0;\\n\\t}\\n\";\n\nvar particleUpdaterOnStopPS = \"\\tvisMode = outLife < 0.0? -1.0: visMode;\\n\";\n\nvar particleUpdaterRespawnPS = \"\\tif (outLife >= lifetime) {\\n\\t\\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\\n\\t\\tvisMode = 1.0;\\n\\t}\\n\\tvisMode = outLife < 0.0? 1.0: visMode;\\n\";\n\nvar particleUpdaterSpherePS = \"uniform float spawnBoundsSphere;\\nuniform float spawnBoundsSphereInnerRatio;\\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\\n\\tfloat rnd4 = fract(rndFactor * 1000.0);\\n\\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\\n\\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\\n#ifndef LOCAL_SPACE\\n\\treturn emitterPos + norm * r * spawnBoundsSphere;\\n#else\\n\\treturn norm * r * spawnBoundsSphere;\\n#endif\\n}\\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\\n\\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\\n}\\n\";\n\nvar particleUpdaterStartPS = \"float saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec3 unpack3NFloats(float src) {\\n\\tfloat r = fract(src);\\n\\tfloat g = fract(src * 256.0);\\n\\tfloat b = fract(src * 65536.0);\\n\\treturn vec3(r, g, b);\\n}\\nvec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {\\n\\tvec4 a = texture2D(tex, tc);\\n\\tvec4 b = texture2D(tex, tc + graphSampleSize);\\n\\tfloat c = fract(tc.x * graphNumSamples);\\n\\tvec3 unpackedA = unpack3NFloats(a.w);\\n\\tvec3 unpackedB = unpack3NFloats(b.w);\\n\\tw = mix(unpackedA, unpackedB, c);\\n\\treturn mix(a.xyz, b.xyz, c);\\n}\\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\\nvec4 hash41(float p) {\\n\\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\\n\\tp4 += dot(p4, p4.wzxy+19.19);\\n\\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\\n}\\nvoid main(void) {\\n\\tif (gl_FragCoord.x > numParticles) discard;\\n\\treadInput(vUv0.x);\\n\\tvisMode = inShow? 1.0 : -1.0;\\n\\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\\n\\tfloat particleRate = rate + rateDiv * rndFactor.x;\\n\\toutLife = inLife + delta;\\n\\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\\n\\tvec3 localVelocityDiv;\\n\\tvec3 velocityDiv;\\n\\tvec3 paramDiv;\\n\\tvec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);\\n\\tvec3 velocity =\\t\ttex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);\\n\\tvec3 params =\\t\\ttex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);\\n\\tfloat rotSpeed = params.x;\\n\\tfloat rotSpeedDiv = paramDiv.y;\\n\\tvec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);\\n\\tfloat radialSpeed = radialParams.x;\\n\\tfloat radialSpeedDiv = radialParams.y;\\n\\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\\n\\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\\n\\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\\n#ifndef LOCAL_SPACE\\n\\tvec3 radialVel = inPos - emitterPos;\\n#else\\n\\tvec3 radialVel = inPos;\\n#endif\\n\\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\\n\\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\\n\\tlocalVelocity +=\\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\\n\\tvelocity +=\\t\\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\\n\\trotSpeed +=\\t\\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\\n\\taddInitialVelocity(localVelocity, rndFactor.xyz);\\n#ifndef LOCAL_SPACE\\n\\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\\n#else\\n\\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\\n#endif\\n\\toutPos = inPos + outVel * delta;\\n\\toutAngle = inAngle + rotSpeed * delta;\\n\";\n\nvar particle_billboardVS = \"\\tquadXY = rotate(quadXY, inAngle, rotMatrix);\\n\\tvec3 localPos = billboard(particlePos, quadXY);\\n\";\n\nvar particle_blendAddPS = \"\\tdBlendModeFogFactor = 0.0;\\n\\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\\n\\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\\n\";\n\nvar particle_blendMultiplyPS = \"\\trgb = mix(vec3(1.0), rgb, vec3(a));\\n\\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\\n\";\n\nvar particle_blendNormalPS = \"\\tif (a < 0.01) discard;\\n\";\n\nvar particle_cpuVS = \"attribute vec4 particle_vertexData;\\nattribute vec4 particle_vertexData2;\\nattribute vec4 particle_vertexData3;\\nattribute float particle_vertexData4;\\n#ifndef USE_MESH\\n#define VDATA5TYPE vec2\\n#else\\n#define VDATA5TYPE vec4\\n#endif\\nattribute VDATA5TYPE particle_vertexData5;\\nuniform mat4 matrix_viewProjection;\\nuniform mat4 matrix_model;\\n#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nuniform mat3 matrix_normal;\\nuniform mat4 matrix_viewInverse;\\nuniform float numParticles;\\nuniform float lifetime;\\nuniform float stretch;\\nuniform float seed;\\nuniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;\\nuniform sampler2D texLifeAndSourcePosOUT;\\nuniform highp sampler2D internalTex0;\\nuniform highp sampler2D internalTex1;\\nuniform highp sampler2D internalTex2;\\nuniform vec3 emitterPos;\\nvarying vec4 texCoordsAlphaLife;\\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\\n{\\n\\tfloat c = cos(pRotation);\\n\\tfloat s = sin(pRotation);\\n\\tmat2 m = mat2(c, -s, s, c);\\n\\trotMatrix = m;\\n\\treturn m * quadXY;\\n}\\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\\n{\\n\\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\\n\\treturn pos;\\n}\\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\\n{\\n\\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\\n\\treturn pos;\\n}\\nvoid main(void)\\n{\\n\\tvec3 particlePos = particle_vertexData.xyz;\\n\\tvec3 inPos = particlePos;\\n\\tvec3 vertPos = particle_vertexData3.xyz;\\n\\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\\n\\tfloat id = floor(particle_vertexData4);\\n\\tfloat rndFactor = fract(sin(id + 1.0 + seed));\\n\\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\\n#ifdef LOCAL_SPACE\\n\\tinVel = mat3(matrix_model) * inVel;\\n#endif\\n\\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\\n\\tvec2 quadXY = vertPos.xy;\\n#ifdef USE_MESH\\n\\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\\n#else\\n\\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\\n#endif\\n\\tmat2 rotMatrix;\\n\\tfloat inAngle = particle_vertexData2.x;\\n\\tvec3 particlePosMoved = vec3(0.0);\\n\\tvec3 meshLocalPos = particle_vertexData3.xyz;\\n\";\n\nvar particle_cpu_endVS = \"\\tlocalPos *= particle_vertexData2.y * emitterScale;\\n\\tlocalPos += particlePos;\\n\\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\\n\";\n\nvar particle_customFaceVS = \"\\tquadXY = rotate(quadXY, inAngle, rotMatrix);\\n\\tvec3 localPos = customFace(particlePos, quadXY);\\n\";\n\nvar particle_endPS = \"\\trgb = addFog(rgb);\\n\\trgb = toneMap(rgb);\\n\\trgb = gammaCorrectOutput(rgb);\\n\\tgl_FragColor = vec4(rgb, a);\\n}\\n\";\n\nvar particle_endVS = \"\\tlocalPos *= scale * emitterScale;\\n\\tlocalPos += particlePos;\\n\\t#ifdef SCREEN_SPACE\\n\\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\\n\\t#else\\n\\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\\n\\t#endif\\n\";\n\nvar particle_halflambertPS = \"\\tvec3 negNormal = normal*0.5+0.5;\\n\\tvec3 posNormal = -normal*0.5+0.5;\\n\\tnegNormal *= negNormal;\\n\\tposNormal *= posNormal;\\n\";\n\nvar particle_initVS = \"attribute vec4 particle_vertexData;\\n#ifdef USE_MESH\\nattribute vec2 particle_uv;\\n#endif\\nuniform mat4 matrix_viewProjection;\\nuniform mat4 matrix_model;\\nuniform mat3 matrix_normal;\\nuniform mat4 matrix_viewInverse;\\n#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nuniform float numParticles, numParticlesPot;\\nuniform float graphSampleSize;\\nuniform float graphNumSamples;\\nuniform float stretch;\\nuniform vec3 wrapBounds;\\nuniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;\\nuniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;\\nuniform sampler2D particleTexOUT, particleTexIN;\\nuniform highp sampler2D internalTex0;\\nuniform highp sampler2D internalTex1;\\nuniform highp sampler2D internalTex2;\\n#ifndef CAMERAPLANES\\n#define CAMERAPLANES\\nuniform vec4 camera_params;\\n#endif\\nvarying vec4 texCoordsAlphaLife;\\nvec3 inPos;\\nvec3 inVel;\\nfloat inAngle;\\nbool inShow;\\nfloat inLife;\\n\";\n\nvar particle_lambertPS = \"\\tvec3 negNormal = max(normal, vec3(0.0));\\n\\tvec3 posNormal = max(-normal, vec3(0.0));\\n\";\n\nvar particle_lightingPS = \"\\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\\n\\t\\t\\t\\t\\t\\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\\n\\t\\t\\t\\t\\t\\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\\n\\trgb *= light;\\n\";\n\nvar particle_localShiftVS = \"\\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\\n\";\n\nvar particle_meshVS = \"\\tvec3 localPos = meshLocalPos;\\n\\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\\n\\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\\n\\tbillboard(particlePos, quadXY);\\n\";\n\nvar particle_normalVS = \"\\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\\n\";\n\nvar particle_normalMapPS = \"\\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\\n\\tvec3 normal = ParticleMat * normalMap;\\n\";\n\nvar particle_pointAlongVS = \"\\tinAngle = atan(velocityV.x, velocityV.y);\\n\";\n\nvar particle_softPS = \"\\tfloat depth = getLinearScreenDepth();\\n\\tfloat particleDepth = vDepth;\\n\\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\\n\\ta *= depthDiff;\\n\";\n\nvar particle_softVS = \"\\tvDepth = getLinearDepth(localPos);\\n\";\n\nvar particle_stretchVS = \"\\tvec3 moveDir = inVel * stretch;\\n\\tvec3 posPrev = particlePos - moveDir;\\n\\tposPrev += particlePosMoved;\\n\\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\\n\\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\\n\\tparticlePos = mix(particlePos, posPrev, interpolation);\\n\";\n\nvar particle_TBNVS = \"\\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\\n\\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\\n\";\n\nvar particle_wrapVS = \"\\tvec3 origParticlePos = particlePos;\\n\\tparticlePos -= matrix_model[3].xyz;\\n\\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\\n\\tparticlePos += matrix_model[3].xyz;\\n\\tparticlePosMoved = particlePos - origParticlePos;\\n\";\n\nvar precisionTestPS = \"void main(void) {\\n\\tgl_FragColor = vec4(2147483648.0);\\n}\\n\";\n\nvar precisionTest2PS = \"uniform sampler2D source;\\nvec4 packFloat(float depth) {\\n\\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\\n\\tconst vec4 bit_mask\t= vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\\n\\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\\n\\tres -= res.xxyz * bit_mask;\\n\\treturn res;\\n}\\nvoid main(void) {\\n\\tfloat c = texture2D(source, vec2(0.0)).r;\\n\\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\\n\\tgl_FragColor = packFloat(diff);\\n}\\n\";\n\nvar reflDirPS = \"void getReflDir() {\\n\\tdReflDirW = normalize(-reflect(dViewDirW, dNormalW));\\n}\\n\";\n\nvar reflDirAnisoPS = \"void getReflDir() {\\n\\tfloat roughness = sqrt(1.0 - min(dGlossiness, 1.0));\\n\\tfloat anisotropy = material_anisotropy * roughness;\\n\\tvec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];\\n\\tvec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);\\n\\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\\n\\tvec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));\\n\\tdReflDirW = reflect(-dViewDirW, bentNormal);\\n}\\n\";\n\nvar reflectionCCPS = \"#ifdef CLEARCOAT\\nuniform float material_clearCoatReflectivity;\\nvoid addReflectionCC() {\\n\\tccReflection += vec4(calcReflection(ccReflDirW, ccGlossiness), material_clearCoatReflectivity);\\n}\\n#endif\\n\";\n\nvar reflectionCubePS = \"uniform samplerCube texture_cubeMap;\\nuniform float material_reflectivity;\\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\\n\\tvec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));\\n\\tlookupVec.x *= -1.0;\\n\\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\\n}\\nvoid addReflection() {\\n\\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\\n}\\n\";\n\nvar reflectionEnvPS = \"#ifndef ENV_ATLAS\\n#define ENV_ATLAS\\nuniform sampler2D texture_envAtlas;\\n#endif\\nuniform float material_reflectivity;\\nfloat shinyMipLevel(vec2 uv) {\\n\\tvec2 dx = dFdx(uv);\\n\\tvec2 dy = dFdy(uv);\\n\\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\\n\\tvec2 dx2 = dFdx(uv2);\\n\\tvec2 dy2 = dFdy(uv2);\\n\\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\\n\\treturn clamp(0.5 * log2(maxd) - 1.0, 0.0, 6.0);\\n}\\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\\n\\tvec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);\\n\\tvec2 uv = toSphericalUv(dir);\\n\\tfloat level = saturate(1.0 - tGlossiness) * 5.0;\\n\\tfloat ilevel = floor(level);\\n\\tfloat level2 = shinyMipLevel(uv * atlasSize);\\n\\tfloat ilevel2 = floor(level2);\\n\\tvec2 uv0, uv1;\\n\\tfloat weight;\\n\\tif (ilevel == 0.0) {\\n\\t\\tuv0 = mapMip(uv, ilevel2);\\n\\t\\tuv1 = mapMip(uv, ilevel2 + 1.0);\\n\\t\\tweight = level2 - ilevel2;\\n\\t} else {\\n\\t\\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\\n\\t\\tweight = 0.0;\\n\\t}\\n\\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\\n\\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\\n\\tvec3 linear0 = mix(linearA, linearB, weight);\\n\\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\\n\\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\\n}\\nvoid addReflection() {\\n\\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\\n}\\n\";\n\nvar reflectionSpherePS = \"#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nuniform sampler2D texture_sphereMap;\\nuniform float material_reflectivity;\\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\\n\\tvec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;\\n\\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\\n\\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\\n\\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\\n}\\nvoid addReflection() {\\n\\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\\n}\\n\";\n\nvar reflectionSphereLowPS = \"uniform sampler2D texture_sphereMap;\\nuniform float material_reflectivity;\\nvec3 calcReflection(vec3 tReflDirW, float tGlossiness) {\\n\\tvec3 reflDirV = vNormalV;\\n\\tvec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;\\n\\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\\n}\\nvoid addReflection() {\\n\\tdReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);\\n}\\n\";\n\nvar refractionPS = \"uniform float material_refraction, material_refractionIndex;\\nvec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {\\n\\tfloat vn = dot(viewVec, Normal);\\n\\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\\n\\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;\\n\\treturn refrVec;\\n}\\nvoid addRefraction() {\\n\\tvec3 tmp = dReflDirW;\\n\\tvec4 tmp2 = dReflection;\\n\\tdReflection = vec4(0.0);\\n\\tdReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);\\n\\taddReflection();\\n\\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, material_refraction);\\n\\tdReflDirW = tmp;\\n\\tdReflection = tmp2;\\n}\\n\";\n\nvar reprojectPS = \"varying vec2 vUv0;\\nuniform sampler2D sourceTex;\\nuniform samplerCube sourceCube;\\nuniform sampler2D samplesTex;\\nuniform vec2 samplesTexInverseSize;\\nuniform vec4 params;\\nuniform vec2 params2;\\nfloat targetFace() { return params.x; }\\nfloat specularPower() { return params.y; }\\nfloat sourceCubeSeamScale() { return params.z; }\\nfloat targetCubeSeamScale() { return params.w; }\\nfloat targetTotalPixels() { return params2.x; }\\nfloat sourceTotalPixels() { return params2.y; }\\nfloat PI = 3.141592653589793;\\nfloat saturate(float x) {\\n\\treturn clamp(x, 0.0, 1.0);\\n}\\nvec3 decodeLinear(vec4 source) {\\n\\treturn source.rgb;\\n}\\nvec4 encodeLinear(vec3 source) {\\n\\treturn vec4(source, 1.0);\\n}\\nvec3 decodeGamma(vec4 source) {\\n\\treturn pow(source.xyz, vec3(2.2));\\n}\\nvec4 encodeGamma(vec3 source) {\\n\\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\\n}\\nvec3 decodeRGBM(vec4 rgbm) {\\n\\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\\n\\treturn color * color;\\n}\\nvec4 encodeRGBM(vec3 source) {\\n\\tvec4 result;\\n\\tresult.rgb = pow(source.rgb, vec3(0.5));\\n\\tresult.rgb *= 1.0 / 8.0;\\n\\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\\n\\tresult.a = ceil(result.a * 255.0) / 255.0;\\n\\tresult.rgb /= result.a;\\n\\treturn result;\\n}\\nvec3 decodeRGBE(vec4 source) {\\n\\tif (source.a == 0.0) {\\n\\t\\treturn vec3(0.0, 0.0, 0.0);\\n\\t} else {\\n\\t\\treturn source.xyz * pow(2.0, source.w * 255.0 - 128.0);\\n\\t}\\n}\\nvec4 encodeRGBE(vec3 source) {\\n\\tfloat maxVal = max(source.x, max(source.y, source.z));\\n\\tif (maxVal < 1e-32) {\\n\\t\\treturn vec4(0, 0, 0, 0);\\n\\t} else {\\n\\t\\tfloat e = ceil(log2(maxVal));\\n\\t\\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\\n\\t}\\n}\\nvec3 modifySeams(vec3 dir, float scale) {\\n\\tvec3 adir = abs(dir);\\n\\tfloat M = max(max(adir.x, adir.y), adir.z);\\n\\treturn dir / M * vec3(\\n\\t\\tadir.x == M ? 1.0 : scale,\\n\\t\\tadir.y == M ? 1.0 : scale,\\n\\t\\tadir.z == M ? 1.0 : scale\\n\\t);\\n}\\nvec2 toSpherical(vec3 dir) {\\n\\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\\n}\\nvec3 fromSpherical(vec2 uv) {\\n\\treturn vec3(cos(uv.y) * sin(uv.x),\\n\\t\\t\\t\\tsin(uv.y),\\n\\t\\t\\t\\tcos(uv.y) * cos(uv.x));\\n}\\nvec3 getDirectionEquirect() {\\n\\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\\n}\\nvec4 sampleEquirect(vec2 sph) {\\n\\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\\n\\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\\n}\\nvec4 sampleEquirect(vec3 dir) {\\n\\treturn sampleEquirect(toSpherical(dir));\\n}\\nvec4 sampleCubemap(vec3 dir) {\\n\\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\\n}\\nvec4 sampleCubemap(vec2 sph) {\\n\\treturn sampleCubemap(fromSpherical(sph));\\n}\\nvec4 sampleEquirect(vec2 sph, float mipLevel) {\\n\\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\\n#ifdef SUPPORTS_TEXLOD\\n\\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\\n#else\\n\\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\\n#endif\\n}\\nvec4 sampleEquirect(vec3 dir, float mipLevel) {\\n\\treturn sampleEquirect(toSpherical(dir), mipLevel);\\n}\\nvec4 sampleCubemap(vec3 dir, float mipLevel) {\\n#ifdef SUPPORTS_TEXLOD\\n\\treturn textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\\n#else\\n\\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()));\\n#endif\\n}\\nvec4 sampleCubemap(vec2 sph, float mipLevel) {\\n\\treturn sampleCubemap(fromSpherical(sph), mipLevel);\\n}\\nfloat signNotZero(float k){\\n\\treturn(k >= 0.0) ? 1.0 : -1.0;\\n}\\nvec2 signNotZero(vec2 v) {\\n\\treturn vec2(signNotZero(v.x), signNotZero(v.y));\\n}\\nvec3 octDecode(vec2 o) {\\n\\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\\n\\tif (v.y < 0.0) {\\n\\t\\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\\n\\t}\\n\\treturn normalize(v);\\n}\\nvec3 getDirectionOctahedral() {\\n\\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\\n}\\nvec2 octEncode(in vec3 v) {\\n\\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\\n\\tvec2 result = v.xz * (1.0 / l1norm);\\n\\tif (v.y < 0.0) {\\n\\t\\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\\n\\t}\\n\\treturn result;\\n}\\nvec4 sampleOctahedral(vec3 dir) {\\n\\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\\n\\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\\n}\\nvec4 sampleOctahedral(vec2 sph) {\\n\\treturn sampleOctahedral(fromSpherical(sph));\\n}\\nvec4 sampleOctahedral(vec3 dir, float mipLevel) {\\n\\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\\n#ifdef SUPPORTS_TEXLOD\\n\\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\\n#else\\n\\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\\n#endif\\n}\\nvec4 sampleOctahedral(vec2 sph, float mipLevel) {\\n\\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\\n}\\nvec3 getDirectionCubemap() {\\n\\tvec2 st = vUv0 * 2.0 - 1.0;\\n\\tfloat face = targetFace();\\n\\tvec3 vec;\\n\\tif (face == 0.0) {\\n\\t\\tvec = vec3(1, -st.y, -st.x);\\n\\t} else if (face == 1.0) {\\n\\t\\tvec = vec3(-1, -st.y, st.x);\\n\\t} else if (face == 2.0) {\\n\\t\\tvec = vec3(st.x, 1, st.y);\\n\\t} else if (face == 3.0) {\\n\\t\\tvec = vec3(st.x, -1, -st.y);\\n\\t} else if (face == 4.0) {\\n\\t\\tvec = vec3(st.x, -st.y, 1);\\n\\t} else {\\n\\t\\tvec = vec3(-st.x, -st.y, -1);\\n\\t}\\n\\treturn normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\\n}\\nmat3 matrixFromVector(vec3 n) {\\n\\tfloat a = 1.0 / (1.0 + n.z);\\n\\tfloat b = -n.x * n.y * a;\\n\\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\\n\\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\\n\\treturn mat3(b1, b2, n);\\n}\\nmat3 matrixFromVectorSlow(vec3 n) {\\n\\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\\n\\tvec3 x = normalize(cross(up, n));\\n\\tvec3 y = cross(n, x);\\n\\treturn mat3(x, y, n);\\n}\\nvec4 reproject() {\\n\\tif (NUM_SAMPLES <= 1) {\\n\\t\\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\\n\\t} else {\\n\\t\\tvec2 sph = toSpherical(TARGET_FUNC());\\n\\t\\tvec2 sphu = dFdx(sph);\\n\\t\\tvec2 sphv = dFdy(sph);\\n\\t\\tconst float NUM_SAMPLES_SQRT = sqrt(float(NUM_SAMPLES));\\n\\t\\tvec3 result = vec3(0.0);\\n\\t\\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\\n\\t\\t\\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\\n\\t\\t\\t\\tresult += DECODE_FUNC(SOURCE_FUNC(sph +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\tsphu * (u / NUM_SAMPLES_SQRT - 0.5) +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\tsphv * (v / NUM_SAMPLES_SQRT - 0.5)));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\\n\\t}\\n}\\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\\nvoid unpackSample(int i, out vec3 L, out float mipLevel) {\\n\\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\\n\\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\\n\\tvec4 raw;\\n\\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\\n\\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\\n\\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\\n\\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\\n\\tL.xyz = raw.xyz * 2.0 - 1.0;\\n\\tmipLevel = raw.w * 8.0;\\n}\\nvec4 prefilterSamples() {\\n\\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\\n\\tvec3 L;\\n\\tfloat mipLevel;\\n\\tvec3 result = vec3(0.0);\\n\\tfloat totalWeight = 0.0;\\n\\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\\n\\t\\tunpackSample(i, L, mipLevel);\\n\\t\\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\\n\\t\\ttotalWeight += L.z;\\n\\t}\\n\\treturn ENCODE_FUNC(result / totalWeight);\\n}\\nvec4 prefilterSamplesUnweighted() {\\n\\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\\n\\tvec3 L;\\n\\tfloat mipLevel;\\n\\tvec3 result = vec3(0.0);\\n\\tfloat totalWeight = 0.0;\\n\\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\\n\\t\\tunpackSample(i, L, mipLevel);\\n\\t\\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\\n\\t}\\n\\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\\n}\\nvoid main(void) {\\n\\tgl_FragColor = PROCESS_FUNC();\\n}\\n\";\n\nvar rgbmPS = \"vec3 texture2DRGBM(sampler2D tex, vec2 uv) {\\n\\treturn decodeRGBM(texture2D(tex, uv));\\n}\\nvec3 textureCubeRGBM(samplerCube tex, vec3 uvw) {\\n\\treturn decodeRGBM(textureCube(tex, uvw));\\n}\\n\";\n\nvar screenDepthPS = \"uniform highp sampler2D uDepthMap;\\n#ifndef SCREENSIZE\\n#define SCREENSIZE\\nuniform vec4 uScreenSize;\\n#endif\\n#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\n#ifndef CAMERAPLANES\\n#define CAMERAPLANES\\nuniform vec4 camera_params;\\n#endif\\n#ifdef GL2\\nfloat linearizeDepth(float z) {\\n\\tz = z * 2.0 - 1.0;\\n\\treturn 1.0 / (camera_params.z * z + camera_params.w);\\n}\\n#else\\n#ifndef UNPACKFLOAT\\n#define UNPACKFLOAT\\nfloat unpackFloat(vec4 rgbaDepth) {\\n\\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\\n\\treturn dot(rgbaDepth, bitShift);\\n}\\n#endif\\n#endif\\nfloat getLinearScreenDepth(vec2 uv) {\\n\\t#ifdef GL2\\n\\treturn linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y;\\n\\t#else\\n\\treturn unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y;\\n\\t#endif\\n}\\n#ifndef VERTEXSHADER\\nfloat getLinearScreenDepth() {\\n\\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\\n\\treturn getLinearScreenDepth(uv);\\n}\\n#endif\\nfloat getLinearDepth(vec3 pos) {\\n\\treturn -(matrix_view * vec4(pos, 1.0)).z;\\n}\\n\";\n\nvar shadowCascadesPS = \"const float maxCascades = 4.0;\\nmat4 cascadeShadowMat;\\nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\\n\\tfloat depth = 1.0 / gl_FragCoord.w;\\n\\tfloat cascadeIndex = 0.0;\\n\\tfor (float i = 0.0; i < maxCascades; i++) {\\n\\t\\tif (depth < shadowCascadeDistances[int(i)]) {\\n\\t\\t\\tcascadeIndex = i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\\n\\t#ifdef GL2\\n\\t\\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\\n\\t#else\\n\\t\\tif (cascadeIndex == 0.0) {\\n\\t\\t\\tcascadeShadowMat = shadowMatrixPalette[0];\\n\\t\\t}\\n\\t\\telse if (cascadeIndex == 1.0) {\\n\\t\\t\\tcascadeShadowMat = shadowMatrixPalette[1];\\n\\t\\t}\\n\\t\\telse if (cascadeIndex == 2.0) {\\n\\t\\t\\tcascadeShadowMat = shadowMatrixPalette[2];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tcascadeShadowMat = shadowMatrixPalette[3];\\n\\t\\t}\\n\\t#endif\\n}\\nvoid fadeShadow(float shadowCascadeDistances[4]) {\\n\\tfloat depth = 1.0 / gl_FragCoord.w;\\n\\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\\n\\t\\tdShadowCoord.z = -9999999.0;\\n\\t}\\n}\\n\";\n\nvar shadowCommonPS = \"void normalOffsetPointShadow(vec4 shadowParams) {\\n\\tfloat distScale = length(dLightDirW);\\n\\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\\n\\tvec3 dir = wPos - dLightPosW;\\n\\tdLightDirW = dir;\\n}\\n\";\n\nvar shadowCoordPS = \"void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {\\n\\tdShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;\\n\\tdShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;\\n\\t#ifdef SHADOWBIAS\\n\\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\\n\\t#endif\\n}\\nvoid _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\\n\\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\\n\\tprojPos.xy /= projPos.w;\\n\\tdShadowCoord.xy = projPos.xy;\\n\\tdShadowCoord.z = length(dLightDirW) * shadowParams.w;\\n\\t#ifdef SHADOWBIAS\\n\\tdShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);\\n\\t#endif\\n}\\nvoid getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {\\n\\t_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);\\n}\\nvoid getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {\\n\\t_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);\\n}\\nvoid getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\\n\\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\\n\\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\\n\\t_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);\\n}\\nvoid getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {\\n\\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0);\\n\\t_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);\\n}\\n\";\n\nvar shadowCoordPerspZbufferPS = \"void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\\n\\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\\n\\tprojPos.xyz /= projPos.w;\\n\\tdShadowCoord = projPos.xyz;\\n}\\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {\\n\\tfloat distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW));\\n\\tvec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;\\n\\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\\n}\\nvoid getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {\\n\\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);\\n}\\n\";\n\nvar shadowEVSMPS = \"float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\\n\\tvec3 moments = texture2D(tex, texCoords).xyz;\\n\\treturn calculateEVSM(moments, Z, vsmBias, exponent);\\n}\\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\\n\\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\\n}\\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\\n\\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\\n}\\n\";\n\nvar shadowEVSMnPS = \"float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\\n\\tfloat pixelSize = 1.0 / resolution;\\n\\ttexCoords -= vec2(pixelSize);\\n\\tvec3 s00 = texture2D(tex, texCoords).xyz;\\n\\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\\n\\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\\n\\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\\n\\tvec2 fr = fract(texCoords * resolution);\\n\\tvec3 h0 = mix(s00, s10, fr.x);\\n\\tvec3 h1 = mix(s01, s11, fr.x);\\n\\tvec3 moments = mix(h0, h1, fr.y);\\n\\treturn calculateEVSM(moments, Z, vsmBias, exponent);\\n}\\nfloat getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {\\n\\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);\\n}\\nfloat getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {\\n\\treturn VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\\n}\\n\";\n\nvar shadowStandardPS = \"vec3 lessThan2(vec3 a, vec3 b) {\\n\\treturn clamp((b - a)*1000.0, 0.0, 1.0);\\n}\\n#ifndef UNPACKFLOAT\\n#define UNPACKFLOAT\\nfloat unpackFloat(vec4 rgbaDepth) {\\n\\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\\n\\treturn dot(rgbaDepth, bitShift);\\n}\\n#endif\\n#ifdef GL2\\nfloat _getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\\n\\tfloat z = dShadowCoord.z;\\n\\tvec2 uv = dShadowCoord.xy * shadowParams.x;\\n\\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\\n\\tvec2 base_uv = floor(uv + 0.5);\\n\\tfloat s = (uv.x + 0.5 - base_uv.x);\\n\\tfloat t = (uv.y + 0.5 - base_uv.y);\\n\\tbase_uv -= vec2(0.5);\\n\\tbase_uv *= shadowMapSizeInv;\\n\\tfloat sum = 0.0;\\n\\tfloat uw0 = (3.0 - 2.0 * s);\\n\\tfloat uw1 = (1.0 + 2.0 * s);\\n\\tfloat u0 = (2.0 - s) / uw0 - 1.0;\\n\\tfloat u1 = s / uw1 + 1.0;\\n\\tfloat vw0 = (3.0 - 2.0 * t);\\n\\tfloat vw1 = (1.0 + 2.0 * t);\\n\\tfloat v0 = (2.0 - t) / vw0 - 1.0;\\n\\tfloat v1 = t / vw1 + 1.0;\\n\\tu0 = u0 * shadowMapSizeInv + base_uv.x;\\n\\tv0 = v0 * shadowMapSizeInv + base_uv.y;\\n\\tu1 = u1 * shadowMapSizeInv + base_uv.x;\\n\\tv1 = v1 * shadowMapSizeInv + base_uv.y;\\n\\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\\n\\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\\n\\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\\n\\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\\n\\tsum *= 1.0f / 16.0;\\n\\treturn sum;\\n}\\nfloat getShadowPCF3x3(sampler2DShadow shadowMap, vec3 shadowParams) {\\n\\treturn _getShadowPCF3x3(shadowMap, shadowParams);\\n}\\nfloat getShadowSpotPCF3x3(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\\n}\\n#else\\nfloat _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {\\n\\tmat3 shadowKernel;\\n\\tvec3 shadowCoord = dShadowCoord;\\n\\tvec3 shadowZ = vec3(shadowCoord.z);\\n\\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\\n\\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\\n\\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\\n\\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\\n\\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\\n\\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\\n\\tvec4 shadowValues;\\n\\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\\n\\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\\n\\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\\n\\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\\n\\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\\n}\\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\\n\\tvec3 shadowCoord = dShadowCoord;\\n\\tfloat xoffset = 1.0 / shadowParams.x;\\n\\tfloat dx0 = -xoffset;\\n\\tfloat dx1 = xoffset;\\n\\tmat3 depthKernel;\\n\\tdepthKernel[0][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\\n\\tdepthKernel[0][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\\n\\tdepthKernel[0][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\\n\\tdepthKernel[1][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\\n\\tdepthKernel[1][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy));\\n\\tdepthKernel[1][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\\n\\tdepthKernel[2][0] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\\n\\tdepthKernel[2][1] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\\n\\tdepthKernel[2][2] = unpackFloat(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\\n\\treturn _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);\\n}\\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {\\n\\treturn _getShadowPCF3x3(shadowMap, shadowParams);\\n}\\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {\\n\\treturn _getShadowPCF3x3(shadowMap, shadowParams.xyz);\\n}\\n#endif\\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\\n\\tvec3 tc = normalize(dir);\\n\\tvec3 tcAbs = abs(tc);\\n\\tvec4 dirX = vec4(1,0,0, tc.x);\\n\\tvec4 dirY = vec4(0,1,0, tc.y);\\n\\tfloat majorAxisLength = tc.z;\\n\\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\\n\\t\\tdirX = vec4(0,0,1, tc.z);\\n\\t\\tdirY = vec4(0,1,0, tc.y);\\n\\t\\tmajorAxisLength = tc.x;\\n\\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\\n\\t\\tdirX = vec4(1,0,0, tc.x);\\n\\t\\tdirY = vec4(0,0,1, tc.z);\\n\\t\\tmajorAxisLength = tc.y;\\n\\t}\\n\\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\\n\\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\\n\\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\\n\\tvec3 dx0 = -xoffset;\\n\\tvec3 dy0 = -yoffset;\\n\\tvec3 dx1 = xoffset;\\n\\tvec3 dy1 = yoffset;\\n\\tmat3 shadowKernel;\\n\\tmat3 depthKernel;\\n\\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\\n\\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\\n\\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\\n\\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\\n\\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\\n\\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\\n\\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\\n\\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\\n\\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\\n\\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\\n\\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\\n\\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\\n\\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\\n\\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\\n\\tvec2 fractionalCoord = fract( uv * shadowParams.x );\\n\\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\\n\\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\\n\\tvec4 shadowValues;\\n\\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\\n\\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\\n\\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\\n\\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\\n\\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\\n}\\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {\\n\\treturn _getShadowPoint(shadowMap, shadowParams, dLightDirW);\\n}\\n\";\n\nvar shadowStandardGL2PS = \"float _getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\\n\\tfloat z = dShadowCoord.z;\\n\\tvec2 uv = dShadowCoord.xy * shadowParams.x;\\n\\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\\n\\tvec2 base_uv = floor(uv + 0.5);\\n\\tfloat s = (uv.x + 0.5 - base_uv.x);\\n\\tfloat t = (uv.y + 0.5 - base_uv.y);\\n\\tbase_uv -= vec2(0.5);\\n\\tbase_uv *= shadowMapSizeInv;\\n\\tfloat uw0 = (4.0 - 3.0 * s);\\n\\tfloat uw1 = 7.0;\\n\\tfloat uw2 = (1.0 + 3.0 * s);\\n\\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\\n\\tfloat u1 = (3.0 + s) / uw1;\\n\\tfloat u2 = s / uw2 + 2.0;\\n\\tfloat vw0 = (4.0 - 3.0 * t);\\n\\tfloat vw1 = 7.0;\\n\\tfloat vw2 = (1.0 + 3.0 * t);\\n\\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\\n\\tfloat v1 = (3.0 + t) / vw1;\\n\\tfloat v2 = t / vw2 + 2.0;\\n\\tfloat sum = 0.0;\\n\\tu0 = u0 * shadowMapSizeInv + base_uv.x;\\n\\tv0 = v0 * shadowMapSizeInv + base_uv.y;\\n\\tu1 = u1 * shadowMapSizeInv + base_uv.x;\\n\\tv1 = v1 * shadowMapSizeInv + base_uv.y;\\n\\tu2 = u2 * shadowMapSizeInv + base_uv.x;\\n\\tv2 = v2 * shadowMapSizeInv + base_uv.y;\\n\\tsum += uw0 * vw0 * texture(shadowMap, vec3(u0, v0, z));\\n\\tsum += uw1 * vw0 * texture(shadowMap, vec3(u1, v0, z));\\n\\tsum += uw2 * vw0 * texture(shadowMap, vec3(u2, v0, z));\\n\\tsum += uw0 * vw1 * texture(shadowMap, vec3(u0, v1, z));\\n\\tsum += uw1 * vw1 * texture(shadowMap, vec3(u1, v1, z));\\n\\tsum += uw2 * vw1 * texture(shadowMap, vec3(u2, v1, z));\\n\\tsum += uw0 * vw2 * texture(shadowMap, vec3(u0, v2, z));\\n\\tsum += uw1 * vw2 * texture(shadowMap, vec3(u1, v2, z));\\n\\tsum += uw2 * vw2 * texture(shadowMap, vec3(u2, v2, z));\\n\\tsum *= 1.0f / 144.0;\\n\\tsum = gammaCorrectInput(sum);\\n\\tsum = saturate(sum);\\n\\treturn sum;\\n}\\nfloat getShadowPCF5x5(sampler2DShadow shadowMap, vec3 shadowParams) {\\n\\treturn _getShadowPCF5x5(shadowMap, shadowParams);\\n}\\nfloat getShadowSpotPCF5x5(sampler2DShadow shadowMap, vec4 shadowParams) {\\n\\treturn _getShadowPCF5x5(shadowMap, shadowParams.xyz);\\n}\\n\";\n\nvar shadowVSM8PS = \"float calculateVSM8(vec3 moments, float Z, float vsmBias) {\\n\\tfloat VSMBias = vsmBias;\\n\\tfloat depthScale = VSMBias * Z;\\n\\tfloat minVariance1 = depthScale * depthScale;\\n\\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\\n}\\nfloat decodeFloatRG(vec2 rg) {\\n\\treturn rg.y*(1.0/255.0) + rg.x;\\n}\\nfloat VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\\n\\tvec4 c = texture2D(tex, texCoords);\\n\\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\\n\\treturn calculateVSM8(moments, Z, vsmBias);\\n}\\nfloat getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {\\n\\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);\\n}\\nfloat getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {\\n\\treturn VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\\n}\\n\";\n\nvar shadowVSM_commonPS = \"float linstep(float a, float b, float v) {\\n\\treturn saturate((v - a) / (b - a));\\n}\\nfloat reduceLightBleeding(float pMax, float amount) {\\n\t return linstep(amount, 1.0, pMax);\\n}\\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\\n\\tfloat variance = moments.y - (moments.x * moments.x);\\n\\tvariance = max(variance, minVariance);\\n\\tfloat d = mean - moments.x;\\n\\tfloat pMax = variance / (variance + (d * d));\\n\\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\\n\\treturn (mean <= moments.x ? 1.0 : pMax);\\n}\\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\\n\\tZ = 2.0 * Z - 1.0;\\n\\tfloat warpedDepth = exp(exponent * Z);\\n\\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\\n\\tfloat VSMBias = vsmBias;\\n\\tfloat depthScale = VSMBias * exponent * warpedDepth;\\n\\tfloat minVariance1 = depthScale * depthScale;\\n\\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\\n}\\n\";\n\nvar skinBatchConstVS = \"attribute float vertex_boneIndices;\\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\\nmat4 getBoneMatrix(const in float i) {\\n\\tvec4 v1 = matrix_pose[int(3.0 * i)];\\n\\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\\n\\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\\n\\treturn mat4(\\n\\t\\tv1.x, v2.x, v3.x, 0,\\n\\t\\tv1.y, v2.y, v3.y, 0,\\n\\t\\tv1.z, v2.z, v3.z, 0,\\n\\t\\tv1.w, v2.w, v3.w, 1\\n\\t);\\n}\\n\";\n\nvar skinBatchTexVS = \"attribute float vertex_boneIndices;\\nuniform highp sampler2D texture_poseMap;\\nuniform vec4 texture_poseMapSize;\\nmat4 getBoneMatrix(const in float i) {\\n\\tfloat j = i * 3.0;\\n\\tfloat dx = texture_poseMapSize.z;\\n\\tfloat dy = texture_poseMapSize.w;\\n\\tfloat y = floor(j * dx);\\n\\tfloat x = j - (y * texture_poseMapSize.x);\\n\\ty = dy * (y + 0.5);\\n\\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\\n\\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\\n\\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\\n\\treturn mat4(\\n\\t\\tv1.x, v2.x, v3.x, 0,\\n\\t\\tv1.y, v2.y, v3.y, 0,\\n\\t\\tv1.z, v2.z, v3.z, 0,\\n\\t\\tv1.w, v2.w, v3.w, 1\\n\\t);\\n}\\n\";\n\nvar skinConstVS = \"attribute vec4 vertex_boneWeights;\\nattribute vec4 vertex_boneIndices;\\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\\n\\tv1 = matrix_pose[int(3.0 * i)];\\n\\tv2 = matrix_pose[int(3.0 * i + 1.0)];\\n\\tv3 = matrix_pose[int(3.0 * i + 2.0)];\\n}\\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\\n\\tvec4 a1, a2, a3;\\n\\tgetBoneMatrix(indices.x, a1, a2, a3);\\n\\tvec4 b1, b2, b3;\\n\\tgetBoneMatrix(indices.y, b1, b2, b3);\\n\\tvec4 c1, c2, c3;\\n\\tgetBoneMatrix(indices.z, c1, c2, c3);\\n\\tvec4 d1, d2, d3;\\n\\tgetBoneMatrix(indices.w, d1, d2, d3);\\n\\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\\n\\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\\n\\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\\n\\tfloat one = dot(weights, vec4(1.0));\\n\\treturn mat4(\\n\\t\\tv1.x, v2.x, v3.x, 0,\\n\\t\\tv1.y, v2.y, v3.y, 0,\\n\\t\\tv1.z, v2.z, v3.z, 0,\\n\\t\\tv1.w, v2.w, v3.w, one\\n\\t);\\n}\\n\";\n\nvar skinTexVS = \"attribute vec4 vertex_boneWeights;\\nattribute vec4 vertex_boneIndices;\\nuniform highp sampler2D texture_poseMap;\\nuniform vec4 texture_poseMapSize;\\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\\n\\tfloat j = i * 3.0;\\n\\tfloat dx = texture_poseMapSize.z;\\n\\tfloat dy = texture_poseMapSize.w;\\n\\tfloat y = floor(j * dx);\\n\\tfloat x = j - (y * texture_poseMapSize.x);\\n\\ty = dy * (y + 0.5);\\n\\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\\n\\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\\n\\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\\n}\\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\\n\\tvec4 a1, a2, a3;\\n\\tgetBoneMatrix(indices.x, a1, a2, a3);\\n\\tvec4 b1, b2, b3;\\n\\tgetBoneMatrix(indices.y, b1, b2, b3);\\n\\tvec4 c1, c2, c3;\\n\\tgetBoneMatrix(indices.z, c1, c2, c3);\\n\\tvec4 d1, d2, d3;\\n\\tgetBoneMatrix(indices.w, d1, d2, d3);\\n\\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\\n\\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\\n\\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\\n\\tfloat one = dot(weights, vec4(1.0));\\n\\treturn mat4(\\n\\t\\tv1.x, v2.x, v3.x, 0,\\n\\t\\tv1.y, v2.y, v3.y, 0,\\n\\t\\tv1.z, v2.z, v3.z, 0,\\n\\t\\tv1.w, v2.w, v3.w, one\\n\\t);\\n}\\n\";\n\nvar skyboxEnvPS = \"varying vec3 vViewDir;\\nuniform sampler2D texture_envAtlas;\\nuniform float mipLevel;\\nvoid main(void) {\\n\\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\\n\\tvec2 uv = toSphericalUv(normalize(dir));\\n\\tvec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\\n\\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\\n}\\n\";\n\nvar skyboxHDRPS = \"varying vec3 vViewDir;\\nuniform samplerCube texture_cubeMap;\\nvoid main(void) {\\n\\tvec3 dir=vViewDir;\\n\\tdir.x *= -1.0;\\n\\tvec3 color = processEnvironment($textureCubeSAMPLE(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)).rgb);\\n\\tcolor = toneMap(color);\\n\\tcolor = gammaCorrectOutput(color);\\n\\tgl_FragColor = vec4(color, 1.0);\\n}\\n\";\n\nvar skyboxVS = \"attribute vec3 aPosition;\\n#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nuniform mat4 matrix_projectionSkybox;\\nuniform mat3 cubeMapRotationMatrix;\\nvarying vec3 vViewDir;\\nvoid main(void) {\\n\\tmat4 view = matrix_view;\\n\\tview[3][0] = view[3][1] = view[3][2] = 0.0;\\n\\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\\n\\tgl_Position.z = gl_Position.w - 0.00001;\\n\\tvViewDir = aPosition * cubeMapRotationMatrix;\\n}\\n\";\n\nvar specularPS = \"#ifdef MAPCOLOR\\nuniform vec3 material_specular;\\n#endif\\n#ifdef MAPTEXTURE\\nuniform sampler2D texture_specularMap;\\n#endif\\nvoid getSpecularity() {\\n\\tdSpecularity = vec3(1.0);\\n\\t#ifdef MAPCOLOR\\n\\tdSpecularity *= material_specular;\\n\\t#endif\\n\\t#ifdef MAPTEXTURE\\n\\tdSpecularity *= texture2D(texture_specularMap, $UV).$CH;\\n\\t#endif\\n\\t#ifdef MAPVERTEX\\n\\tdSpecularity *= saturate(vVertexColor.$VC);\\n\\t#endif\\n}\\n\";\n\nvar specularAaNonePS = \"float antiAliasGlossiness(float power) {\\n\\treturn power;\\n}\\n\";\n\nvar specularAaToksvigPS = \"float antiAliasGlossiness(float power) {\\n\\tfloat rlen = 1.0 / saturate(length(dNormalMap));\\n\\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\\n\\treturn power * mix(1.0, toksvig, material_bumpiness);\\n}\\n\";\n\nvar specularAaToksvigFastPS = \"float antiAliasGlossiness(float power) {\\n\\tfloat rlen = 1.0 / saturate(length(dNormalMap));\\n\\tfloat toksvig = 1.0 / (1.0 + power * (rlen - 1.0));\\n\\treturn power * toksvig;\\n}\\n\";\n\nvar spotPS = \"float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {\\n\\tfloat cosAngle = dot(dLightDirNormW, lightSpotDirW);\\n\\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\\n}\\n\";\n\nvar startPS = \"void main(void) {\\n\\tdDiffuseLight = vec3(0);\\n\\tdSpecularLight = vec3(0);\\n\\tdReflection = vec4(0);\\n\\tdSpecularity = vec3(0);\\n\\t#ifdef CLEARCOAT\\n\\tccSpecularLight = vec3(0);\\n\\tccReflection = vec4(0);\\n\\t#endif\\n\";\n\nvar startVS = \"void main(void) {\\n\\tgl_Position = getPosition();\\n\";\n\nvar startNineSlicedPS = \"\\tnineSlicedUv = vUv0;\\n\\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\\n\";\n\nvar startNineSlicedTiledPS = \"\\tvec2 tileMask = step(vMask, vec2(0.99999));\\n\\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\\n\\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\\n\\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\\n\\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\\n\\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\\n\\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\\n\";\n\nvar storeEVSMPS = \"float exponent = VSM_EXPONENT;\\ndepth = 2.0 * depth - 1.0;\\ndepth =\texp(exponent * depth);\\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\\n\";\n\nvar tangentBinormalVS = \"vec3 getTangent() {\\n\\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\\n}\\nvec3 getBinormal() {\\n\\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\\n}\\nvec3 getObjectSpaceUp() {\\n\\treturn normalize(dNormalMatrix * vec3(0, 1, 0));\\n}\\n\";\n\nvar TBNPS = \"void getTBN() {\\n\\tdTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));\\n}\\n\";\n\nvar TBNderivativePS = \"uniform float tbnBasis;\\nvoid getTBN() {\\n\\tvec2 uv = $UV;\\n\\tvec3 dp1 = dFdx( vPositionW );\\n\\tvec3 dp2 = dFdy( vPositionW );\\n\\tvec2 duv1 = dFdx( uv );\\n\\tvec2 duv2 = dFdy( uv );\\n\\tvec3 dp2perp = cross( dp2, dVertexNormalW );\\n\\tvec3 dp1perp = cross( dVertexNormalW, dp1 );\\n\\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\\n\\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\\n\\tfloat denom = max( dot(T,T), dot(B,B) );\\n\\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\\n\\tdTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );\\n}\\n\";\n\nvar TBNfastPS = \"void getTBN() {\\n\\tdTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);\\n}\\n\";\n\nvar TBNObjectSpacePS = \"void getTBN() {\\n\\tvec3 B = cross(dVertexNormalW, vObjectSpaceUpW);\\n\\tvec3 T = cross(dVertexNormalW, B);\\n\\tif (dot(B,B)==0.0)\\n\\t{\\n\\t\\tfloat major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);\\n\\t\\tif (dVertexNormalW.x==major)\\n\\t\\t{\\n\\t\\t\\tB=cross(dVertexNormalW, vec3(0,1,0));\\n\\t\\t\\tT=cross(dVertexNormalW, B);\\n\\t\\t}\\n\\t\\telse if (dVertexNormalW.y==major)\\n\\t\\t{\\n\\t\\t\\tB=cross(dVertexNormalW, vec3(0,0,1));\\n\\t\\t\\tT=cross(dVertexNormalW, B);\\n\\t\\t}\\n\\t\\telse if (dVertexNormalW.z==major)\\n\\t\\t{\\n\\t\\t\\tB=cross(dVertexNormalW, vec3(1,0,0));\\n\\t\\t\\tT=cross(dVertexNormalW, B);\\n\\t\\t}\\n\\t}\\n\\tdTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));\\n}\\n\";\n\nvar tonemappingAcesPS = \"uniform float exposure;\\nvec3 toneMap(vec3 color) {\\n\\tfloat tA = 2.51;\\n\\tfloat tB = 0.03;\\n\\tfloat tC = 2.43;\\n\\tfloat tD = 0.59;\\n\\tfloat tE = 0.14;\\n\\tvec3 x = color * exposure;\\n\\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\\n}\\n\";\n\nvar tonemappingAces2PS = \"uniform float exposure;\\nconst mat3 ACESInputMat = mat3(\\n\\t0.59719, 0.35458, 0.04823,\\n\\t0.07600, 0.90834, 0.01566,\\n\\t0.02840, 0.13383, 0.83777\\n);\\nconst mat3 ACESOutputMat = mat3(\\n\\t 1.60475, -0.53108, -0.07367,\\n\\t-0.10208,\t1.10813, -0.00605,\\n\\t-0.00327, -0.07276,\t1.07602\\n);\\nvec3 RRTAndODTFit(vec3 v) {\\n\\tvec3 a = v * (v + 0.0245786) - 0.000090537;\\n\\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 toneMap(vec3 color) {\\n\\tcolor *= exposure;\\n\\tcolor = color * ACESInputMat;\\n\\tcolor = RRTAndODTFit(color);\\n\\tcolor = color * ACESOutputMat;\\n\\tcolor = clamp(color, 0.0, 1.0);\\n\\treturn color;\\n}\\n\";\n\nvar tonemappingFilmicPS = \"const float A =\t0.15;\\nconst float B =\t0.50;\\nconst float C =\t0.10;\\nconst float D =\t0.20;\\nconst float E =\t0.02;\\nconst float F =\t0.30;\\nconst float W =\t11.2;\\nuniform float exposure;\\nvec3 uncharted2Tonemap(vec3 x) {\\n\t return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\\n}\\nvec3 toneMap(vec3 color) {\\n\\tcolor = uncharted2Tonemap(color * exposure);\\n\\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\\n\\tcolor = color * whiteScale;\\n\\treturn color;\\n}\\n\";\n\nvar tonemappingHejlPS = \"uniform float exposure;\\nvec3 toneMap(vec3 color) {\\n\\tcolor *= exposure;\\n\\tconst float\tA = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\\n\\tconst float Scl = 1.25;\\n\\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\\n\\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\\n}\\n\";\n\nvar tonemappingLinearPS = \"uniform float exposure;\\nvec3 toneMap(vec3 color) {\\n\\treturn color * exposure;\\n}\\n\";\n\nvar tonemappingNonePS = \"vec3 toneMap(vec3 color) {\\n\\treturn color;\\n}\\n\";\n\nvar transformVS = \"#ifdef PIXELSNAP\\nuniform vec4 uScreenSize;\\n#endif\\n#ifdef MORPHING\\nuniform vec4 morph_weights_a;\\nuniform vec4 morph_weights_b;\\n#endif\\n#ifdef MORPHING_TEXTURE_BASED\\nuniform vec4 morph_tex_params;\\nvec2 getTextureMorphCoords() {\\n\\tfloat vertexId = morph_vertex_id;\\n\\tvec2 textureSize = morph_tex_params.xy;\\n\\tvec2 invTextureSize = morph_tex_params.zw;\\n\\tfloat morphGridV = floor(vertexId * invTextureSize.x);\\n\\tfloat morphGridU = vertexId - (morphGridV * textureSize.x);\\n\\treturn (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);\\n}\\n#endif\\n#ifdef MORPHING_TEXTURE_BASED_POSITION\\nuniform highp sampler2D morphPositionTex;\\n#endif\\nmat4 getModelMatrix() {\\n\\t#ifdef DYNAMICBATCH\\n\\treturn getBoneMatrix(vertex_boneIndices);\\n\\t#elif defined(SKIN)\\n\\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\\n\\t#elif defined(INSTANCING)\\n\\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\\n\\t#else\\n\\treturn matrix_model;\\n\\t#endif\\n}\\nvec4 getPosition() {\\n\\tdModelMatrix = getModelMatrix();\\n\\tvec3 localPos = vertex_position;\\n\\t#ifdef NINESLICED\\n\\tlocalPos.xz *= outerScale;\\n\\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\\n\\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\\n\\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\\n\\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\\n\\tlocalPos.xz *= -0.5;\\n\\tlocalPos = localPos.xzy;\\n\\t#endif\\n\\t#ifdef MORPHING\\n\\t#ifdef MORPHING_POS03\\n\\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\\n\\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\\n\\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\\n\\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\\n\\t#endif\\n\\t#ifdef MORPHING_POS47\\n\\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\\n\\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\\n\\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\\n\\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\\n\\t#endif\\n\\t#endif\\n\\t#ifdef MORPHING_TEXTURE_BASED_POSITION\\n\\tvec2 morphUV = getTextureMorphCoords();\\n\\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\\n\\tlocalPos += morphPos;\\n\\t#endif\\n\\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\\n\\t#ifdef SCREENSPACE\\n\\tposW.zw = vec2(0.0, 1.0);\\n\\t#endif\\n\\tdPositionW = posW.xyz;\\n\\tvec4 screenPos;\\n\\t#ifdef UV1LAYOUT\\n\\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\\n\\t#else\\n\\t#ifdef SCREENSPACE\\n\\tscreenPos = posW;\\n\\t#else\\n\\tscreenPos = matrix_viewProjection * posW;\\n\\t#endif\\n\\t#ifdef PIXELSNAP\\n\\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\\n\\tscreenPos.xy *= uScreenSize.xy;\\n\\tscreenPos.xy = floor(screenPos.xy);\\n\\tscreenPos.xy *= uScreenSize.zw;\\n\\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\\n\\t#endif\\n\\t#endif\\n\\treturn screenPos;\\n}\\nvec3 getWorldPosition() {\\n\\treturn dPositionW;\\n}\\n\";\n\nvar transformDeclVS = \"attribute vec3 vertex_position;\\nuniform mat4 matrix_model;\\nuniform mat4 matrix_viewProjection;\\nvec3 dPositionW;\\nmat4 dModelMatrix;\\n\";\n\nvar uv0VS = \"#ifdef NINESLICED\\nvec2 getUv0() {\\n\\tvec2 uv = vertex_position.xz;\\n\\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\\n\\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\\n\\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\\n\\tuv = uv * -0.5 + 0.5;\\n\\tuv = uv * atlasRect.zw + atlasRect.xy;\\n\\tvMask = vertex_texCoord0.xy;\\n\\treturn uv;\\n}\\n#else\\nvec2 getUv0() {\\n\\treturn vertex_texCoord0;\\n}\\n#endif\\n\";\n\nvar uv1VS = \"vec2 getUv1() {\\n\\treturn vertex_texCoord1;\\n}\\n\";\n\nvar viewDirPS = \"void getViewDir() {\\n\\tdViewDirW = normalize(view_position - vPositionW);\\n}\\n\";\n\nvar viewNormalVS = \"#ifndef VIEWMATRIX\\n#define VIEWMATRIX\\nuniform mat4 matrix_view;\\n#endif\\nvec3 getViewNormal() {\\n\\treturn mat3(matrix_view) * vNormalW;\\n}\\n\";\n\nconst shaderChunks = {\n\talphaTestPS,\n\tambientConstantPS,\n\tambientEnvPS,\n\tambientSHPS,\n\taoPS,\n\taoSpecOccPS,\n\taoSpecOccConstPS,\n\taoSpecOccConstSimplePS,\n\taoSpecOccSimplePS,\n\tbakeDirLmEndPS,\n\tbakeLmEndPS,\n\tbasePS,\n\tbaseVS,\n\tbaseNineSlicedPS,\n\tbaseNineSlicedVS,\n\tbaseNineSlicedTiledPS,\n\tbiasConstPS,\n\tblurVSMPS,\n\tclearCoatPS,\n\tclearCoatGlossPS,\n\tclearCoatNormalPS,\n\tclusteredLightCookiesPS,\n\tclusteredLightShadowsPS,\n\tclusteredLightUtilsPS,\n\tclusteredLightPS,\n\tcombineClearCoatPS,\n\tcombineDiffusePS,\n\tcombineDiffuseSpecularPS,\n\tcombineDiffuseSpecularNoConservePS,\n\tcombineDiffuseSpecularNoReflPS,\n\tcombineDiffuseSpecularNoReflSeparateAmbientPS,\n\tcombineDiffuseSpecularOldPS,\n\tcookiePS,\n\tcubeMapProjectBoxPS,\n\tcubeMapProjectNonePS,\n\tcubeMapRotatePS,\n\tdetailModesPS,\n\tdiffusePS,\n\tdiffuseDetailMapPS,\n\tdilatePS,\n\tbilateralDeNoisePS,\n\tdecodePS,\n\temissivePS,\n\tendPS,\n\tendVS,\n\tenvConstPS,\n\tenvMultiplyPS,\n\textensionPS,\n\textensionVS,\n\tfalloffInvSquaredPS,\n\tfalloffLinearPS,\n\tfixCubemapSeamsNonePS,\n\tfixCubemapSeamsStretchPS,\n\tfloatUnpackingPS,\n\tfogExpPS,\n\tfogExp2PS,\n\tfogLinearPS,\n\tfogNonePS,\n\tfresnelSchlickPS,\n\tfullscreenQuadPS,\n\tfullscreenQuadVS,\n\tgamma1_0PS,\n\tgamma2_2PS,\n\tgles3PS,\n\tgles3VS,\n\tglossPS,\n\tinstancingVS,\n\tlightDiffuseLambertPS,\n\tlightDirPointPS,\n\tlightmapDirPS,\n\tlightmapSinglePS,\n\tlightmapSingleVertPS,\n\tlightSpecularAnisoGGXPS,\n\tlightSpecularBlinnPS,\n\tlightSpecularPhongPS,\n\tltc,\n\tmetalnessPS,\n\tmsdfPS,\n\tnormalVS,\n\tnormalDetailMapPS,\n\tnormalInstancedVS,\n\tnormalMapPS,\n\tnormalMapFastPS,\n\tnormalSkinnedVS,\n\tnormalVertexPS,\n\tnormalXYPS,\n\tnormalXYZPS,\n\topacityPS,\n\toutputAlphaPS,\n\toutputAlphaOpaquePS,\n\toutputAlphaPremulPS,\n\toutputCubemapPS,\n\toutputTex2DPS,\n\tpackDepthPS,\n\tpackDepthMaskPS,\n\tparallaxPS,\n\tparticlePS,\n\tparticleVS,\n\tparticleAnimFrameClampVS,\n\tparticleAnimFrameLoopVS,\n\tparticleAnimTexVS,\n\tparticleInputFloatPS,\n\tparticleInputRgba8PS,\n\tparticleOutputFloatPS,\n\tparticleOutputRgba8PS,\n\tparticleUpdaterAABBPS,\n\tparticleUpdaterEndPS,\n\tparticleUpdaterInitPS,\n\tparticleUpdaterNoRespawnPS,\n\tparticleUpdaterOnStopPS,\n\tparticleUpdaterRespawnPS,\n\tparticleUpdaterSpherePS,\n\tparticleUpdaterStartPS,\n\tparticle_billboardVS,\n\tparticle_blendAddPS,\n\tparticle_blendMultiplyPS,\n\tparticle_blendNormalPS,\n\tparticle_cpuVS,\n\tparticle_cpu_endVS,\n\tparticle_customFaceVS,\n\tparticle_endPS,\n\tparticle_endVS,\n\tparticle_halflambertPS,\n\tparticle_initVS,\n\tparticle_lambertPS,\n\tparticle_lightingPS,\n\tparticle_localShiftVS,\n\tparticle_meshVS,\n\tparticle_normalVS,\n\tparticle_normalMapPS,\n\tparticle_pointAlongVS,\n\tparticle_softPS,\n\tparticle_softVS,\n\tparticle_stretchVS,\n\tparticle_TBNVS,\n\tparticle_wrapVS,\n\tprecisionTestPS,\n\tprecisionTest2PS,\n\treflDirPS,\n\treflDirAnisoPS,\n\treflectionCCPS,\n\treflectionCubePS,\n\treflectionEnvPS,\n\treflectionSpherePS,\n\treflectionSphereLowPS,\n\trefractionPS,\n\treprojectPS,\n\trgbmPS,\n\tscreenDepthPS,\n\tshadowCascadesPS,\n\tshadowCommonPS,\n\tshadowCoordPS,\n\tshadowCoordPerspZbufferPS,\n\tshadowEVSMPS,\n\tshadowEVSMnPS,\n\tshadowStandardPS,\n\tshadowStandardGL2PS,\n\tshadowVSM8PS,\n\tshadowVSM_commonPS,\n\tskinBatchConstVS,\n\tskinBatchTexVS,\n\tskinConstVS,\n\tskinTexVS,\n\tskyboxEnvPS,\n\tskyboxHDRPS,\n\tskyboxVS,\n\tspecularPS,\n\tspecularAaNonePS,\n\tspecularAaToksvigPS,\n\tspecularAaToksvigFastPS,\n\tspotPS,\n\tstartPS,\n\tstartVS,\n\tstartNineSlicedPS,\n\tstartNineSlicedTiledPS,\n\tstoreEVSMPS,\n\ttangentBinormalVS,\n\tTBNPS,\n\tTBNderivativePS,\n\tTBNfastPS,\n\tTBNObjectSpacePS,\n\ttonemappingAcesPS,\n\ttonemappingAces2PS,\n\ttonemappingFilmicPS,\n\ttonemappingHejlPS,\n\ttonemappingLinearPS,\n\ttonemappingNonePS,\n\ttransformVS,\n\ttransformDeclVS,\n\tuv0VS,\n\tuv1VS,\n\tviewDirPS,\n\tviewNormalVS\n};\n\nfunction gammaCode(value, chunks) {\n\tif (!chunks) chunks = shaderChunks;\n\n\tif (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {\n\t\treturn chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;\n\t} else if (value === GAMMA_SRGBHDR) {\n\t\treturn \"#define HDR\\n\" + (chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS);\n\t}\n\n\treturn chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;\n}\n\nfunction tonemapCode(value, chunks) {\n\tif (!chunks) chunks = shaderChunks;\n\n\tif (value === TONEMAP_FILMIC) {\n\t\treturn chunks.tonemappingFilmicPS ? chunks.tonemappingFilmicPS : shaderChunks.tonemappingFilmicPS;\n\t} else if (value === TONEMAP_LINEAR) {\n\t\treturn chunks.tonemappingLinearPS ? chunks.tonemappingLinearPS : shaderChunks.tonemappingLinearPS;\n\t} else if (value === TONEMAP_HEJL) {\n\t\treturn chunks.tonemappingHejlPS ? chunks.tonemappingHejlPS : shaderChunks.tonemappingHejlPS;\n\t} else if (value === TONEMAP_ACES) {\n\t\treturn chunks.tonemappingAcesPS ? chunks.tonemappingAcesPS : shaderChunks.tonemappingAcesPS;\n\t} else if (value === TONEMAP_ACES2) {\n\t\treturn chunks.tonemappingAces2PS ? chunks.tonemappingAces2PS : shaderChunks.tonemappingAces2PS;\n\t}\n\n\treturn chunks.tonemapingNonePS ? chunks.tonemapingNonePS : shaderChunks.tonemappingNonePS;\n}\n\nfunction fogCode(value, chunks) {\n\tif (!chunks) chunks = shaderChunks;\n\n\tif (value === 'linear') {\n\t\treturn chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;\n\t} else if (value === 'exp') {\n\t\treturn chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;\n\t} else if (value === 'exp2') {\n\t\treturn chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;\n\t}\n\n\treturn chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;\n}\n\nfunction skinCode(device, chunks) {\n\tif (!chunks) chunks = shaderChunks;\n\n\tif (device.supportsBoneTextures) {\n\t\treturn chunks.skinTexVS;\n\t}\n\n\treturn \"#define BONE_LIMIT \" + device.getBoneLimit() + \"\\n\" + chunks.skinConstVS;\n}\n\nfunction precisionCode(device) {\n\tlet pcode = 'precision ' + device.precision + ' float;\\n';\n\n\tif (device.webgl2) {\n\t\tpcode += '#ifdef GL2\\nprecision ' + device.precision + ' sampler2DShadow;\\n#endif\\n';\n\t}\n\n\treturn pcode;\n}\n\nfunction versionCode(device) {\n\treturn device.webgl2 ? \"#version 300 es\\n\" : \"\";\n}\n\nfunction dummyFragmentCode() {\n\treturn \"void main(void) {gl_FragColor = vec4(0.0);}\";\n}\n\nfunction begin() {\n\treturn 'void main(void)\\n{\\n';\n}\n\nfunction end() {\n\treturn '}\\n';\n}\n\nconst attrib2Semantic = {\n\tvertex_position: SEMANTIC_POSITION,\n\tvertex_normal: SEMANTIC_NORMAL,\n\tvertex_tangent: SEMANTIC_TANGENT,\n\tvertex_texCoord0: SEMANTIC_TEXCOORD0,\n\tvertex_texCoord1: SEMANTIC_TEXCOORD1,\n\tvertex_texCoord2: SEMANTIC_TEXCOORD2,\n\tvertex_texCoord3: SEMANTIC_TEXCOORD3,\n\tvertex_texCoord4: SEMANTIC_TEXCOORD4,\n\tvertex_texCoord5: SEMANTIC_TEXCOORD5,\n\tvertex_texCoord6: SEMANTIC_TEXCOORD6,\n\tvertex_texCoord7: SEMANTIC_TEXCOORD7,\n\tvertex_color: SEMANTIC_COLOR,\n\tvertex_boneIndices: SEMANTIC_BLENDINDICES,\n\tvertex_boneWeights: SEMANTIC_BLENDWEIGHT\n};\n\nfunction collectAttribs(vsCode) {\n\tconst attribs = {};\n\tlet attrs = 0;\n\tlet found = vsCode.indexOf(\"attribute\");\n\n\twhile (found >= 0) {\n\t\tif (found > 0 && vsCode[found - 1] === \"/\") break;\n\t\tconst endOfLine = vsCode.indexOf(';', found);\n\t\tconst startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);\n\t\tconst attribName = vsCode.substr(startOfAttribName + 1, endOfLine - (startOfAttribName + 1));\n\t\tconst semantic = attrib2Semantic[attribName];\n\n\t\tif (semantic !== undefined) {\n\t\t\tattribs[attribName] = semantic;\n\t\t} else {\n\t\t\tattribs[attribName] = \"ATTR\" + attrs;\n\t\t\tattrs++;\n\t\t}\n\n\t\tfound = vsCode.indexOf(\"attribute\", found + 1);\n\t}\n\n\treturn attribs;\n}\n\nfunction createShader(device, vsName, psName, useTransformFeedback = false) {\n\tlet vsCode = shaderChunks[vsName];\n\tlet psCode = precisionCode(device) + \"\\n\" + shaderChunks[psName];\n\tconst attribs = collectAttribs(vsCode);\n\n\tif (device.webgl2) {\n\t\tvsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;\n\t\tpsCode = versionCode(device) + shaderChunks.gles3PS + psCode;\n\t}\n\n\treturn new Shader(device, {\n\t\tattributes: attribs,\n\t\tvshader: vsCode,\n\t\tfshader: psCode,\n\t\tuseTransformFeedback: useTransformFeedback\n\t});\n}\n\nfunction createShaderFromCode(device, vsCode, psCode, uName, useTransformFeedback = false, psPreamble = \"\") {\n\tconst shaderCache = device.programLib._cache;\n\tconst cached = shaderCache[uName];\n\tif (cached !== undefined) return cached;\n\tpsCode = precisionCode(device) + \"\\n\" + (psCode || dummyFragmentCode());\n\tconst attribs = collectAttribs(vsCode);\n\n\tif (device.webgl2) {\n\t\tvsCode = versionCode(device) + shaderChunks.gles3VS + vsCode;\n\t\tpsCode = versionCode(device) + shaderChunks.gles3PS + psCode;\n\t}\n\n\tshaderCache[uName] = new Shader(device, {\n\t\tattributes: attribs,\n\t\tvshader: vsCode,\n\t\tfshader: psPreamble + psCode,\n\t\tuseTransformFeedback: useTransformFeedback\n\t});\n\treturn shaderCache[uName];\n}\n\nshaderChunks.collectAttribs = collectAttribs;\nshaderChunks.createShader = createShader;\nshaderChunks.createShaderFromCode = createShaderFromCode;\n\nconst basic = {\n\tgenerateKey: function (options) {\n\t\tlet key = 'basic';\n\t\tif (options.fog) key += '_fog';\n\t\tif (options.alphaTest) key += '_atst';\n\t\tif (options.vertexColors) key += '_vcol';\n\t\tif (options.diffuseMap) key += '_diff';\n\t\tif (options.skin) key += '_skin';\n\t\tif (options.screenSpace) key += '_ss';\n\t\tif (options.useInstancing) key += '_inst';\n\t\tif (options.useMorphPosition) key += '_morphp';\n\t\tif (options.useMorphNormal) key += '_morphn';\n\t\tif (options.useMorphTextureBased) key += '_morpht';\n\t\tkey += '_' + options.pass;\n\t\treturn key;\n\t},\n\tcreateShaderDefinition: function (device, options) {\n\t\tconst attributes = {\n\t\t\tvertex_position: SEMANTIC_POSITION\n\t\t};\n\n\t\tif (options.skin) {\n\t\t\tattributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;\n\t\t\tattributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;\n\t\t}\n\n\t\tif (options.vertexColors) {\n\t\t\tattributes.vertex_color = SEMANTIC_COLOR;\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tattributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;\n\t\t}\n\n\t\tlet code = '';\n\t\tcode += shaderChunks.transformDeclVS;\n\n\t\tif (options.skin) {\n\t\t\tcode += skinCode(device);\n\t\t\tcode += shaderChunks.transformSkinnedVS;\n\t\t} else {\n\t\t\tcode += shaderChunks.transformVS;\n\t\t}\n\n\t\tif (options.vertexColors) {\n\t\t\tcode += 'attribute vec4 vertex_color;\\n';\n\t\t\tcode += 'varying vec4 vColor;\\n';\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tcode += 'attribute vec2 vertex_texCoord0;\\n';\n\t\t\tcode += 'varying vec2 vUv0;\\n';\n\t\t}\n\n\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += '#ifndef VIEWMATRIX\\n';\n\t\t\tcode += '#define VIEWMATRIX\\n';\n\t\t\tcode += 'uniform mat4 matrix_view;\\n';\n\t\t\tcode += '#endif\\n';\n\t\t\tcode += '#ifndef CAMERAPLANES\\n';\n\t\t\tcode += '#define CAMERAPLANES\\n';\n\t\t\tcode += 'uniform vec4 camera_params;\\n\\n';\n\t\t\tcode += '#endif\\n';\n\t\t}\n\n\t\tcode += begin();\n\t\tcode += \"\t gl_Position = getPosition();\\n\";\n\n\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\tcode += \"\t\tvDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\\n\";\n\t\t}\n\n\t\tif (options.vertexColors) {\n\t\t\tcode += '\t\tvColor = vertex_color;\\n';\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tcode += '\t\tvUv0 = vertex_texCoord0;\\n';\n\t\t}\n\n\t\tcode += end();\n\t\tconst vshader = code;\n\t\tcode = precisionCode(device);\n\n\t\tif (options.vertexColors) {\n\t\t\tcode += 'varying vec4 vColor;\\n';\n\t\t} else {\n\t\t\tcode += 'uniform vec4 uColor;\\n';\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tcode += 'varying vec2 vUv0;\\n';\n\t\t\tcode += 'uniform sampler2D texture_diffuseMap;\\n';\n\t\t}\n\n\t\tif (options.fog) {\n\t\t\tcode += fogCode(options.fog);\n\t\t}\n\n\t\tif (options.alphatest) {\n\t\t\tcode += shaderChunks.alphaTestPS;\n\t\t}\n\n\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += shaderChunks.packDepthPS;\n\t\t}\n\n\t\tcode += begin();\n\n\t\tif (options.vertexColors) {\n\t\t\tcode += '\t\tgl_FragColor = vColor;\\n';\n\t\t} else {\n\t\t\tcode += '\t\tgl_FragColor = uColor;\\n';\n\t\t}\n\n\t\tif (options.diffuseMap) {\n\t\t\tcode += '\t\tgl_FragColor *= texture2D(texture_diffuseMap, vUv0);\\n';\n\t\t}\n\n\t\tif (options.alphatest) {\n\t\t\tcode += \"\t alphaTest(gl_FragColor.a);\\n\";\n\t\t}\n\n\t\tif (options.pass !== SHADER_PICK) {\n\t\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\t\tcode += \"\t\tgl_FragColor = packFloat(vDepth);\\n\";\n\t\t\t} else {\n\t\t\t\tif (options.fog) {\n\t\t\t\t\tcode += \"\t glFragColor.rgb = addFog(gl_FragColor.rgb);\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcode += end();\n\t\tconst fshader = code;\n\t\treturn {\n\t\t\tattributes: attributes,\n\t\t\tvshader: vshader,\n\t\t\tfshader: fshader\n\t\t};\n\t}\n};\n\nconst particle = {\n\tgenerateKey: function (options) {\n\t\tlet key = \"particle\";\n\n\t\tfor (const prop in options) {\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\tkey += options[prop];\n\t\t\t}\n\t\t}\n\n\t\treturn key;\n\t},\n\t_animTex: function (options) {\n\t\tlet vshader = \"\";\n\t\tvshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;\n\t\tvshader += shaderChunks.particleAnimTexVS;\n\t\treturn vshader;\n\t},\n\tcreateShaderDefinition: function (device, options) {\n\t\tlet vshader = \"\";\n\t\tlet fshader = precisionCode(device) + \"\\n\";\n\t\tfshader += '#define PARTICLE\\n';\n\n\t\tif (device.webgl2) {\n\t\t\tvshader += \"#define GL2\\n\";\n\t\t\tfshader += \"#define GL2\\n\";\n\t\t}\n\n\t\tvshader += \"#define VERTEXSHADER\\n\";\n\t\tif (options.mesh) vshader += \"#define USE_MESH\\n\";\n\t\tif (options.localSpace) vshader += \"#define LOCAL_SPACE\\n\";\n\t\tif (options.screenSpace) vshader += \"#define SCREEN_SPACE\\n\";\n\t\tif (options.animTex) vshader += \"\\nuniform vec2 animTexTilesParams;\\n\";\n\t\tif (options.animTex) vshader += \"\\nuniform vec4 animTexParams;\\n\";\n\t\tif (options.animTex) vshader += \"\\nuniform vec2 animTexIndexParams;\\n\";\n\t\tif (options.normal === 2) vshader += \"\\nvarying mat3 ParticleMat;\\n\";\n\t\tif (options.normal === 1) vshader += \"\\nvarying vec3 Normal;\\n\";\n\t\tif (options.soft) vshader += \"\\nvarying float vDepth;\\n\";\n\t\tconst faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;\n\n\t\tif (!options.useCpu) {\n\t\t\tvshader += shaderChunks.particle_initVS;\n\t\t\tvshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.screenDepthPS;\n\t\t\tvshader += shaderChunks.particleVS;\n\t\t\tif (options.localSpace) vshader += shaderChunks.particle_localShiftVS;\n\t\t\tif (options.animTex) vshader += this._animTex(options);\n\t\t\tif (options.wrap) vshader += shaderChunks.particle_wrapVS;\n\t\t\tif (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;\n\t\t\tvshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;\n\t\t\tif (options.normal === 1) vshader += shaderChunks.particle_normalVS;\n\t\t\tif (options.normal === 2) vshader += shaderChunks.particle_TBNVS;\n\t\t\tif (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;\n\t\t\tvshader += shaderChunks.particle_endVS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.particle_softVS;\n\t\t} else {\n\t\t\tif (options.soft > 0) vshader += shaderChunks.screenDepthPS;\n\t\t\tvshader += shaderChunks.particle_cpuVS;\n\t\t\tif (options.localSpace) vshader += shaderChunks.particle_localShiftVS;\n\t\t\tif (options.animTex) vshader += this._animTex(options);\n\t\t\tif (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;\n\t\t\tvshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;\n\t\t\tif (options.normal === 1) vshader += shaderChunks.particle_normalVS;\n\t\t\tif (options.normal === 2) vshader += shaderChunks.particle_TBNVS;\n\t\t\tif (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;\n\t\t\tvshader += shaderChunks.particle_cpu_endVS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.particle_softVS;\n\t\t}\n\n\t\tvshader += \"}\\n\";\n\n\t\tif (options.normal > 0) {\n\t\t\tif (options.normal === 1) {\n\t\t\t\tfshader += \"\\nvarying vec3 Normal;\\n\";\n\t\t\t} else if (options.normal === 2) {\n\t\t\t\tfshader += \"\\nvarying mat3 ParticleMat;\\n\";\n\t\t\t}\n\n\t\t\tfshader += \"\\nuniform vec3 lightCube[6];\\n\";\n\t\t}\n\n\t\tif (options.soft) fshader += \"\\nvarying float vDepth;\\n\";\n\t\tif (options.normal === 0 && options.fog === \"none\") options.srgb = false;\n\t\tfshader += gammaCode(options.gamma);\n\t\tfshader += tonemapCode(options.toneMap);\n\n\t\tif (options.fog === 'linear') {\n\t\t\tfshader += shaderChunks.fogLinearPS;\n\t\t} else if (options.fog === 'exp') {\n\t\t\tfshader += shaderChunks.fogExpPS;\n\t\t} else if (options.fog === 'exp2') {\n\t\t\tfshader += shaderChunks.fogExp2PS;\n\t\t} else {\n\t\t\tfshader += shaderChunks.fogNonePS;\n\t\t}\n\n\t\tif (options.normal === 2) fshader += \"\\nuniform sampler2D normalMap;\\n\";\n\t\tif (options.soft > 0) fshader += shaderChunks.screenDepthPS;\n\t\tfshader += shaderChunks.particlePS;\n\t\tif (options.soft > 0) fshader += shaderChunks.particle_softPS;\n\t\tif (options.normal === 1) fshader += \"\\nvec3 normal = Normal;\\n\";\n\t\tif (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;\n\t\tif (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;\n\t\tif (options.normal > 0) fshader += shaderChunks.particle_lightingPS;\n\n\t\tif (options.blend === BLEND_NORMAL) {\n\t\t\tfshader += shaderChunks.particle_blendNormalPS;\n\t\t} else if (options.blend === BLEND_ADDITIVE) {\n\t\t\tfshader += shaderChunks.particle_blendAddPS;\n\t\t} else if (options.blend === BLEND_MULTIPLICATIVE) {\n\t\t\tfshader += shaderChunks.particle_blendMultiplyPS;\n\t\t}\n\n\t\tfshader += shaderChunks.particle_endPS;\n\t\tconst attributes = collectAttribs(vshader);\n\t\treturn {\n\t\t\tattributes: attributes,\n\t\t\tvshader: vshader,\n\t\t\tfshader: fshader\n\t\t};\n\t}\n};\n\nconst skybox = {\n\tgenerateKey: function (options) {\n\t\treturn options.type === 'cubemap' ? `skybox-${options.type}-${options.rgbm}-${options.hdr}-${options.fixSeams}-${options.toneMapping}-${options.gamma}-${options.useIntensity}-${options.mip}` : `skybox-${options.type}-${options.encoding}-${options.useIntensity}-${options.gamma}-${options.toneMapping}`;\n\t},\n\tcreateShaderDefinition: function (device, options) {\n\t\tlet fshader;\n\n\t\tif (options.type === 'cubemap') {\n\t\t\tconst mip2size = [128, 64, 16, 8, 4, 2];\n\t\t\tfshader = precisionCode(device);\n\t\t\tfshader += options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS;\n\t\t\tfshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;\n\t\t\tfshader += gammaCode(options.gamma);\n\t\t\tfshader += tonemapCode(options.toneMapping);\n\t\t\tfshader += shaderChunks.decodePS;\n\t\t\tfshader += shaderChunks.rgbmPS;\n\t\t\tfshader += shaderChunks.skyboxHDRPS.replace(/\\$textureCubeSAMPLE/g, options.rgbm ? \"textureCubeRGBM\" : options.hdr ? \"textureCube\" : \"textureCubeSRGB\").replace(/\\$FIXCONST/g, 1 - 1 / mip2size[options.mip] + \"\");\n\t\t} else {\n\t\t\tconst decodeTable = {\n\t\t\t\t'rgbm': 'decodeRGBM',\n\t\t\t\t'rgbe': 'decodeRGBE',\n\t\t\t\t'linear': 'decodeLinear'\n\t\t\t};\n\t\t\tfshader = precisionCode(device);\n\t\t\tfshader += options.useIntensity ? shaderChunks.envMultiplyPS : shaderChunks.envConstPS;\n\t\t\tfshader += gammaCode(options.gamma);\n\t\t\tfshader += tonemapCode(options.toneMapping);\n\t\t\tfshader += shaderChunks.decodePS;\n\t\t\tfshader += shaderChunks.skyboxEnvPS.replace(/\\$DECODE/g, decodeTable[options.encoding] || \"decodeGamma\");\n\t\t}\n\n\t\treturn {\n\t\t\tattributes: {\n\t\t\t\taPosition: SEMANTIC_POSITION\n\t\t\t},\n\t\t\tvshader: shaderChunks.skyboxVS,\n\t\t\tfshader: fshader\n\t\t};\n\t}\n};\n\nconst oneDiv255 = 1 / 255;\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n\nclass FloatPacking {\n\tstatic float2Half(value) {\n\t\tfloatView[0] = value;\n\t\tconst x = int32View[0];\n\t\tlet bits = x >> 16 & 0x8000;\n\t\tlet m = x >> 12 & 0x07ff;\n\t\tconst e = x >> 23 & 0xff;\n\n\t\tif (e < 103) {\n\t\t\treturn bits;\n\t\t}\n\n\t\tif (e > 142) {\n\t\t\tbits |= 0x7c00;\n\t\t\tbits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n\t\t\treturn bits;\n\t\t}\n\n\t\tif (e < 113) {\n\t\t\tm |= 0x0800;\n\t\t\tbits |= (m >> 114 - e) + (m >> 113 - e & 1);\n\t\t\treturn bits;\n\t\t}\n\n\t\tbits |= e - 112 << 10 | m >> 1;\n\t\tbits += m & 1;\n\t\treturn bits;\n\t}\n\n\tstatic float2Bytes(value, array, offset, numBytes) {\n\t\tconst enc1 = 255.0 * value % 1;\n\t\tarray[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);\n\n\t\tif (numBytes > 1) {\n\t\t\tconst enc2 = 65025.0 * value % 1;\n\t\t\tarray[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);\n\n\t\t\tif (numBytes > 2) {\n\t\t\t\tconst enc3 = 16581375.0 * value % 1;\n\t\t\t\tarray[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);\n\n\t\t\t\tif (numBytes > 3) {\n\t\t\t\t\tarray[offset + 3] = Math.round(enc3 * 255);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic float2BytesRange(value, array, offset, min, max, numBytes) {\n\t\tvalue = math.clamp((value - min) / (max - min), 0, 1);\n\t\tFloatPacking.float2Bytes(value, array, offset, numBytes);\n\t}\n\n\tstatic float2MantissaExponent(value, array, offset, numBytes) {\n\t\tconst exponent = Math.floor(Math.log2(Math.abs(value))) + 1;\n\t\tvalue /= Math.pow(2, exponent);\n\t\tFloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);\n\t\tarray[offset + numBytes - 1] = Math.round(exponent + 127);\n\t}\n\n}\n\nlet _pixelSizeTable = null;\nlet _blockSizeTable = null;\n\nclass Texture {\n\tconstructor(graphicsDevice, options) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.name = null;\n\t\tthis._width = 4;\n\t\tthis._height = 4;\n\t\tthis._depth = 1;\n\t\tthis._format = PIXELFORMAT_R8_G8_B8_A8;\n\t\tthis.type = TEXTURETYPE_DEFAULT;\n\t\tthis.projection = TEXTUREPROJECTION_NONE;\n\t\tthis._cubemap = false;\n\t\tthis._volume = false;\n\t\tthis.fixCubemapSeams = false;\n\t\tthis._flipY = false;\n\t\tthis._premultiplyAlpha = false;\n\t\tthis._isRenderTarget = false;\n\t\tthis._mipmaps = true;\n\t\tthis._minFilter = FILTER_LINEAR_MIPMAP_LINEAR;\n\t\tthis._magFilter = FILTER_LINEAR;\n\t\tthis._anisotropy = 1;\n\t\tthis._addressU = ADDRESS_REPEAT;\n\t\tthis._addressV = ADDRESS_REPEAT;\n\t\tthis._addressW = ADDRESS_REPEAT;\n\t\tthis._compareOnRead = false;\n\t\tthis._compareFunc = FUNC_LESS;\n\n\t\tif (options !== undefined) {\n\t\t\tif (options.name !== undefined) {\n\t\t\t\tthis.name = options.name;\n\t\t\t}\n\n\t\t\tthis._width = options.width !== undefined ? options.width : this._width;\n\t\t\tthis._height = options.height !== undefined ? options.height : this._height;\n\t\t\tthis._format = options.format !== undefined ? options.format : this._format;\n\n\t\t\tif (options.hasOwnProperty('type')) {\n\t\t\t\tthis.type = options.type;\n\t\t\t} else if (options.hasOwnProperty('rgbm')) {\n\t\t\t\tthis.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t\t} else if (options.hasOwnProperty('swizzleGGGR')) {\n\t\t\t\tthis.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;\n\t\t\t}\n\n\t\t\tif (options.mipmaps !== undefined) {\n\t\t\t\tthis._mipmaps = options.mipmaps;\n\t\t\t} else {\n\t\t\t\tthis._mipmaps = options.autoMipmap !== undefined ? options.autoMipmap : this._mipmaps;\n\t\t\t}\n\n\t\t\tthis._levels = options.levels;\n\t\t\tthis._cubemap = options.cubemap !== undefined ? options.cubemap : this._cubemap;\n\t\t\tthis.fixCubemapSeams = options.fixCubemapSeams !== undefined ? options.fixCubemapSeams : this.fixCubemapSeams;\n\n\t\t\tif (this._cubemap) {\n\t\t\t\tthis.projection = TEXTUREPROJECTION_CUBE;\n\t\t\t} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {\n\t\t\t\tthis.projection = options.projection;\n\t\t\t}\n\n\t\t\tthis._minFilter = options.minFilter !== undefined ? options.minFilter : this._minFilter;\n\t\t\tthis._magFilter = options.magFilter !== undefined ? options.magFilter : this._magFilter;\n\t\t\tthis._anisotropy = options.anisotropy !== undefined ? options.anisotropy : this._anisotropy;\n\t\t\tthis._addressU = options.addressU !== undefined ? options.addressU : this._addressU;\n\t\t\tthis._addressV = options.addressV !== undefined ? options.addressV : this._addressV;\n\t\t\tthis._compareOnRead = options.compareOnRead !== undefined ? options.compareOnRead : this._compareOnRead;\n\t\t\tthis._compareFunc = options._compareFunc !== undefined ? options._compareFunc : this._compareFunc;\n\t\t\tthis._flipY = options.flipY !== undefined ? options.flipY : this._flipY;\n\t\t\tthis._premultiplyAlpha = options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : this._premultiplyAlpha;\n\n\t\t\tif (graphicsDevice.webgl2) {\n\t\t\t\tthis._depth = options.depth !== undefined ? options.depth : this._depth;\n\t\t\t\tthis._volume = options.volume !== undefined ? options.volume : this._volume;\n\t\t\t\tthis._addressW = options.addressW !== undefined ? options.addressW : this._addressW;\n\t\t\t}\n\t\t}\n\n\t\tthis._compressed = this._format === PIXELFORMAT_DXT1 || this._format === PIXELFORMAT_DXT3 || this._format === PIXELFORMAT_DXT5 || this._format >= PIXELFORMAT_ETC1;\n\t\tthis._invalid = false;\n\t\tthis._lockedLevel = -1;\n\n\t\tif (!this._levels) {\n\t\t\tthis._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];\n\t\t}\n\n\t\tthis.dirtyAll();\n\t\tthis._gpuSize = 0;\n\t}\n\n\tset minFilter(v) {\n\t\tif (this._minFilter !== v) {\n\t\t\tthis._minFilter = v;\n\t\t\tthis._parameterFlags |= 1;\n\t\t}\n\t}\n\n\tget minFilter() {\n\t\treturn this._minFilter;\n\t}\n\n\tset magFilter(v) {\n\t\tif (this._magFilter !== v) {\n\t\t\tthis._magFilter = v;\n\t\t\tthis._parameterFlags |= 2;\n\t\t}\n\t}\n\n\tget magFilter() {\n\t\treturn this._magFilter;\n\t}\n\n\tset addressU(v) {\n\t\tif (this._addressU !== v) {\n\t\t\tthis._addressU = v;\n\t\t\tthis._parameterFlags |= 4;\n\t\t}\n\t}\n\n\tget addressU() {\n\t\treturn this._addressU;\n\t}\n\n\tset addressV(v) {\n\t\tif (this._addressV !== v) {\n\t\t\tthis._addressV = v;\n\t\t\tthis._parameterFlags |= 8;\n\t\t}\n\t}\n\n\tget addressV() {\n\t\treturn this._addressV;\n\t}\n\n\tset addressW(addressW) {\n\t\tif (!this.device.webgl2) return;\n\n\t\tif (!this._volume) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (addressW !== this._addressW) {\n\t\t\tthis._addressW = addressW;\n\t\t\tthis._parameterFlags |= 16;\n\t\t}\n\t}\n\n\tget addressW() {\n\t\treturn this._addressW;\n\t}\n\n\tset compareOnRead(v) {\n\t\tif (this._compareOnRead !== v) {\n\t\t\tthis._compareOnRead = v;\n\t\t\tthis._parameterFlags |= 32;\n\t\t}\n\t}\n\n\tget compareOnRead() {\n\t\treturn this._compareOnRead;\n\t}\n\n\tset compareFunc(v) {\n\t\tif (this._compareFunc !== v) {\n\t\t\tthis._compareFunc = v;\n\t\t\tthis._parameterFlags |= 64;\n\t\t}\n\t}\n\n\tget compareFunc() {\n\t\treturn this._compareFunc;\n\t}\n\n\tset anisotropy(v) {\n\t\tif (this._anisotropy !== v) {\n\t\t\tthis._anisotropy = v;\n\t\t\tthis._parameterFlags |= 128;\n\t\t}\n\t}\n\n\tget anisotropy() {\n\t\treturn this._anisotropy;\n\t}\n\n\tset autoMipmap(v) {\n\t\tthis._mipmaps = v;\n\t}\n\n\tget autoMipmap() {\n\t\treturn this._mipmaps;\n\t}\n\n\tset mipmaps(v) {\n\t\tif (this._mipmaps !== v) {\n\t\t\tthis._mipmaps = v;\n\t\t\tif (v) this._needsMipmapsUpload = true;\n\t\t}\n\t}\n\n\tget mipmaps() {\n\t\treturn this._mipmaps;\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\tget depth() {\n\t\treturn this._depth;\n\t}\n\n\tget format() {\n\t\treturn this._format;\n\t}\n\n\tget cubemap() {\n\t\treturn this._cubemap;\n\t}\n\n\tget gpuSize() {\n\t\tconst mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);\n\t\treturn Texture.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);\n\t}\n\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\n\tset flipY(flipY) {\n\t\tif (this._flipY !== flipY) {\n\t\t\tthis._flipY = flipY;\n\t\t\tthis._needsUpload = true;\n\t\t}\n\t}\n\n\tget flipY() {\n\t\treturn this._flipY;\n\t}\n\n\tset premultiplyAlpha(premultiplyAlpha) {\n\t\tif (this._premultiplyAlpha !== premultiplyAlpha) {\n\t\t\tthis._premultiplyAlpha = premultiplyAlpha;\n\t\t\tthis._needsUpload = true;\n\t\t}\n\t}\n\n\tget premultiplyAlpha() {\n\t\treturn this._premultiplyAlpha;\n\t}\n\n\tget pot() {\n\t\treturn math.powerOfTwo(this._width) && math.powerOfTwo(this._height);\n\t}\n\n\tget encoding() {\n\t\tif (this.type === TEXTURETYPE_RGBM) {\n\t\t\treturn 'rgbm';\n\t\t}\n\n\t\tif (this.type === TEXTURETYPE_RGBE) {\n\t\t\treturn 'rgbe';\n\t\t}\n\n\t\tif (this.format === PIXELFORMAT_RGBA16F || this.format === PIXELFORMAT_RGBA32F) {\n\t\t\treturn 'linear';\n\t\t}\n\n\t\treturn 'srgb';\n\t}\n\n\tstatic calcGpuSize(width, height, depth, format, mipmaps, cubemap) {\n\t\tif (!_pixelSizeTable) {\n\t\t\t_pixelSizeTable = [];\n\t\t\t_pixelSizeTable[PIXELFORMAT_A8] = 1;\n\t\t\t_pixelSizeTable[PIXELFORMAT_L8] = 1;\n\t\t\t_pixelSizeTable[PIXELFORMAT_L8_A8] = 2;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R5_G6_B5] = 2;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R5_G5_B5_A1] = 2;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R4_G4_B4_A4] = 2;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R8_G8_B8] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R8_G8_B8_A8] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_RGB16F] = 8;\n\t\t\t_pixelSizeTable[PIXELFORMAT_RGBA16F] = 8;\n\t\t\t_pixelSizeTable[PIXELFORMAT_RGB32F] = 16;\n\t\t\t_pixelSizeTable[PIXELFORMAT_RGBA32F] = 16;\n\t\t\t_pixelSizeTable[PIXELFORMAT_R32F] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_DEPTH] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_DEPTHSTENCIL] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_111110F] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_SRGB] = 4;\n\t\t\t_pixelSizeTable[PIXELFORMAT_SRGBA] = 4;\n\t\t}\n\n\t\tif (!_blockSizeTable) {\n\t\t\t_blockSizeTable = [];\n\t\t\t_blockSizeTable[PIXELFORMAT_ETC1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_ETC2_RGB] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGB_1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_PVRTC_2BPP_RGBA_1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGB_1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_PVRTC_4BPP_RGBA_1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_DXT1] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_ATC_RGB] = 8;\n\t\t\t_blockSizeTable[PIXELFORMAT_ETC2_RGBA] = 16;\n\t\t\t_blockSizeTable[PIXELFORMAT_DXT3] = 16;\n\t\t\t_blockSizeTable[PIXELFORMAT_DXT5] = 16;\n\t\t\t_blockSizeTable[PIXELFORMAT_ASTC_4x4] = 16;\n\t\t\t_blockSizeTable[PIXELFORMAT_ATC_RGBA] = 16;\n\t\t}\n\n\t\tconst pixelSize = _pixelSizeTable.hasOwnProperty(format) ? _pixelSizeTable[format] : 0;\n\t\tconst blockSize = _blockSizeTable.hasOwnProperty(format) ? _blockSizeTable[format] : 0;\n\t\tlet result = 0;\n\n\t\twhile (1) {\n\t\t\tif (pixelSize > 0) {\n\t\t\t\tresult += width * height * depth * pixelSize;\n\t\t\t} else {\n\t\t\t\tlet blockWidth = Math.floor((width + 3) / 4);\n\t\t\t\tconst blockHeight = Math.floor((height + 3) / 4);\n\t\t\t\tconst blockDepth = Math.floor((depth + 3) / 4);\n\n\t\t\t\tif (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {\n\t\t\t\t\tblockWidth = Math.max(Math.floor(blockWidth / 2), 1);\n\t\t\t\t}\n\n\t\t\t\tresult += blockWidth * blockHeight * blockDepth * blockSize;\n\t\t\t}\n\n\t\t\tif (!mipmaps || width === 1 && height === 1 && depth === 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twidth = Math.max(Math.floor(width / 2), 1);\n\t\t\theight = Math.max(Math.floor(height / 2), 1);\n\t\t\tdepth = Math.max(Math.floor(depth / 2), 1);\n\t\t}\n\n\t\treturn result * (cubemap ? 6 : 1);\n\t}\n\n\tdestroy() {\n\t\tif (this.device) {\n\t\t\tthis.device.destroyTexture(this);\n\t\t}\n\n\t\tthis.device = null;\n\t\tthis._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];\n\t}\n\n\tdirtyAll() {\n\t\tthis._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];\n\t\tthis._needsUpload = true;\n\t\tthis._needsMipmapsUpload = this._mipmaps;\n\t\tthis._mipmapsUploaded = false;\n\t\tthis._parameterFlags = 255;\n\t}\n\n\tlock(options = {}) {\n\t\tif (options.level === undefined) {\n\t\t\toptions.level = 0;\n\t\t}\n\n\t\tif (options.face === undefined) {\n\t\t\toptions.face = 0;\n\t\t}\n\n\t\tif (options.mode === undefined) {\n\t\t\toptions.mode = TEXTURELOCK_WRITE;\n\t\t}\n\n\t\tthis._lockedLevel = options.level;\n\n\t\tif (this._levels[options.level] === null) {\n\t\t\tswitch (this._format) {\n\t\t\t\tcase PIXELFORMAT_A8:\n\t\t\t\tcase PIXELFORMAT_L8:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(this._width * this._height * this._depth);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_L8_A8:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_R5_G6_B5:\n\t\t\t\tcase PIXELFORMAT_R5_G5_B5_A1:\n\t\t\t\tcase PIXELFORMAT_R4_G4_B4_A4:\n\t\t\t\t\tthis._levels[options.level] = new Uint16Array(this._width * this._height * this._depth);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_R8_G8_B8:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_R8_G8_B8_A8:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(this._width * this._height * this._depth * 4);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_DXT1:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_DXT3:\n\t\t\t\tcase PIXELFORMAT_DXT5:\n\t\t\t\t\tthis._levels[options.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_RGB16F:\n\t\t\t\t\tthis._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_RGB32F:\n\t\t\t\t\tthis._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\t\t\tthis._levels[options.level] = new Uint16Array(this._width * this._height * this._depth * 4);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\t\t\tthis._levels[options.level] = new Float32Array(this._width * this._height * this._depth * 4);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this._levels[options.level];\n\t}\n\n\tsetSource(source, mipLevel = 0) {\n\t\tlet invalid = false;\n\t\tlet width, height;\n\n\t\tif (this._cubemap) {\n\t\t\tif (source[0]) {\n\t\t\t\twidth = source[0].width || 0;\n\t\t\t\theight = source[0].height || 0;\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tconst face = source[i];\n\n\t\t\t\t\tif (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {\n\t\t\t\t\t\tinvalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\n\t\t\tif (!invalid) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tif (this._levels[mipLevel][i] !== source[i]) this._levelsUpdated[mipLevel][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this.device._isBrowserInterface(source)) invalid = true;\n\n\t\t\tif (!invalid) {\n\t\t\t\tif (source !== this._levels[mipLevel]) this._levelsUpdated[mipLevel] = true;\n\t\t\t\twidth = source.width;\n\t\t\t\theight = source.height;\n\t\t\t}\n\t\t}\n\n\t\tif (invalid) {\n\t\t\tthis._width = 4;\n\t\t\tthis._height = 4;\n\n\t\t\tif (this._cubemap) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tthis._levels[mipLevel][i] = null;\n\t\t\t\t\tthis._levelsUpdated[mipLevel][i] = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._levels[mipLevel] = null;\n\t\t\t\tthis._levelsUpdated[mipLevel] = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mipLevel === 0) {\n\t\t\t\tthis._width = width;\n\t\t\t\tthis._height = height;\n\t\t\t}\n\n\t\t\tthis._levels[mipLevel] = source;\n\t\t}\n\n\t\tif (this._invalid !== invalid || !invalid) {\n\t\t\tthis._invalid = invalid;\n\t\t\tthis.upload();\n\t\t}\n\t}\n\n\tgetSource(mipLevel = 0) {\n\t\treturn this._levels[mipLevel];\n\t}\n\n\tunlock() {\n\t\tif (this._lockedLevel === -1) ;\n\n\t\tthis.upload();\n\t\tthis._lockedLevel = -1;\n\t}\n\n\tupload() {\n\t\tthis._needsUpload = true;\n\t\tthis._needsMipmapsUpload = this._mipmaps;\n\t}\n\n\tgetDds() {\n\t\tlet fsize = 128;\n\t\tlet idx = 0;\n\n\t\twhile (this._levels[idx]) {\n\t\t\tif (!this.cubemap) {\n\t\t\t\tconst mipSize = this._levels[idx].length;\n\n\t\t\t\tif (!mipSize) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfsize += mipSize;\n\t\t\t} else {\n\t\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\t\tif (!this._levels[idx][face]) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mipSize = this._levels[idx][face].length;\n\n\t\t\t\t\tif (!mipSize) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tfsize += mipSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfsize += this._levels[idx].length;\n\t\t\tidx++;\n\t\t}\n\n\t\tconst buff = new ArrayBuffer(fsize);\n\t\tconst header = new Uint32Array(buff, 0, 128 / 4);\n\t\tconst DDS_MAGIC = 542327876;\n\t\tconst DDS_HEADER_SIZE = 124;\n\t\tconst DDS_FLAGS_REQUIRED = 0x01 | 0x02 | 0x04 | 0x1000 | 0x80000;\n\t\tconst DDS_FLAGS_MIPMAP = 0x20000;\n\t\tconst DDS_PIXELFORMAT_SIZE = 32;\n\t\tconst DDS_PIXELFLAGS_RGBA8 = 0x01 | 0x40;\n\t\tconst DDS_CAPS_REQUIRED = 0x1000;\n\t\tconst DDS_CAPS_MIPMAP = 0x400000;\n\t\tconst DDS_CAPS_COMPLEX = 0x8;\n\t\tconst DDS_CAPS2_CUBEMAP = 0x200 | 0x400 | 0x800 | 0x1000 | 0x2000 | 0x4000 | 0x8000;\n\t\tlet flags = DDS_FLAGS_REQUIRED;\n\t\tif (this._levels.length > 1) flags |= DDS_FLAGS_MIPMAP;\n\t\tlet caps = DDS_CAPS_REQUIRED;\n\t\tif (this._levels.length > 1) caps |= DDS_CAPS_MIPMAP;\n\t\tif (this._levels.length > 1 || this.cubemap) caps |= DDS_CAPS_COMPLEX;\n\t\tconst caps2 = this.cubemap ? DDS_CAPS2_CUBEMAP : 0;\n\t\theader[0] = DDS_MAGIC;\n\t\theader[1] = DDS_HEADER_SIZE;\n\t\theader[2] = flags;\n\t\theader[3] = this.height;\n\t\theader[4] = this.width;\n\t\theader[5] = this.width * this.height * 4;\n\t\theader[6] = 0;\n\t\theader[7] = this._levels.length;\n\n\t\tfor (let i = 0; i < 11; i++) {\n\t\t\theader[8 + i] = 0;\n\t\t}\n\n\t\theader[19] = DDS_PIXELFORMAT_SIZE;\n\t\theader[20] = DDS_PIXELFLAGS_RGBA8;\n\t\theader[21] = 0;\n\t\theader[22] = 32;\n\t\theader[23] = 0x00FF0000;\n\t\theader[24] = 0x0000FF00;\n\t\theader[25] = 0x000000FF;\n\t\theader[26] = 0xFF000000;\n\t\theader[27] = caps;\n\t\theader[28] = caps2;\n\t\theader[29] = 0;\n\t\theader[30] = 0;\n\t\theader[31] = 0;\n\t\tlet offset = 128;\n\n\t\tif (!this.cubemap) {\n\t\t\tfor (let i = 0; i < this._levels.length; i++) {\n\t\t\t\tconst level = this._levels[i];\n\t\t\t\tconst mip = new Uint8Array(buff, offset, level.length);\n\n\t\t\t\tfor (let j = 0; j < level.length; j++) {\n\t\t\t\t\tmip[j] = level[j];\n\t\t\t\t}\n\n\t\t\t\toffset += level.length;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\tfor (let i = 0; i < this._levels.length; i++) {\n\t\t\t\t\tconst level = this._levels[i][face];\n\t\t\t\t\tconst mip = new Uint8Array(buff, offset, level.length);\n\n\t\t\t\t\tfor (let j = 0; j < level.length; j++) {\n\t\t\t\t\t\tmip[j] = level[j];\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += level.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buff;\n\t}\n\n}\n\nconst _deviceCoord = new Vec3();\n\nconst _halfSize = new Vec3();\n\nconst _point = new Vec3();\n\nconst _invViewProjMat = new Mat4();\n\nclass Camera {\n\tconstructor() {\n\t\tthis._aspectRatio = 16 / 9;\n\t\tthis._aspectRatioMode = ASPECT_AUTO;\n\t\tthis._calculateProjection = null;\n\t\tthis._calculateTransform = null;\n\t\tthis._clearColor = new Color(0.75, 0.75, 0.75, 1);\n\t\tthis._clearColorBuffer = true;\n\t\tthis._clearDepth = 1;\n\t\tthis._clearDepthBuffer = true;\n\t\tthis._clearStencil = 0;\n\t\tthis._clearStencilBuffer = true;\n\t\tthis._cullingMask = 0xFFFFFFFF;\n\t\tthis._cullFaces = true;\n\t\tthis._farClip = 1000;\n\t\tthis._flipFaces = false;\n\t\tthis._fov = 45;\n\t\tthis._frustumCulling = true;\n\t\tthis._horizontalFov = false;\n\t\tthis._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];\n\t\tthis._nearClip = 0.1;\n\t\tthis._node = null;\n\t\tthis._orthoHeight = 10;\n\t\tthis._projection = PROJECTION_PERSPECTIVE;\n\t\tthis._rect = new Vec4(0, 0, 1, 1);\n\t\tthis._renderTarget = null;\n\t\tthis._scissorRect = new Vec4(0, 0, 1, 1);\n\t\tthis._scissorRectClear = false;\n\t\tthis._vrDisplay = null;\n\t\tthis._projMat = new Mat4();\n\t\tthis._projMatDirty = true;\n\t\tthis._projMatSkybox = new Mat4();\n\t\tthis._viewMat = new Mat4();\n\t\tthis._viewMatDirty = true;\n\t\tthis._viewProjMat = new Mat4();\n\t\tthis._viewProjMatDirty = true;\n\t\tthis.frustum = new Frustum();\n\t}\n\n\tset aspectRatio(newValue) {\n\t\tif (this._aspectRatio !== newValue) {\n\t\t\tthis._aspectRatio = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget aspectRatio() {\n\t\treturn this._aspectRatio;\n\t}\n\n\tset aspectRatioMode(newValue) {\n\t\tif (this._aspectRatioMode !== newValue) {\n\t\t\tthis._aspectRatioMode = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget aspectRatioMode() {\n\t\treturn this._aspectRatioMode;\n\t}\n\n\tset calculateProjection(newValue) {\n\t\tthis._calculateProjection = newValue;\n\t\tthis._projMatDirty = true;\n\t}\n\n\tget calculateProjection() {\n\t\treturn this._calculateProjection;\n\t}\n\n\tset calculateTransform(newValue) {\n\t\tthis._calculateTransform = newValue;\n\t}\n\n\tget calculateTransform() {\n\t\treturn this._calculateTransform;\n\t}\n\n\tset clearColor(newValue) {\n\t\tthis._clearColor.copy(newValue);\n\t}\n\n\tget clearColor() {\n\t\treturn this._clearColor;\n\t}\n\n\tset clearColorBuffer(newValue) {\n\t\tthis._clearColorBuffer = newValue;\n\t}\n\n\tget clearColorBuffer() {\n\t\treturn this._clearColorBuffer;\n\t}\n\n\tset clearDepth(newValue) {\n\t\tthis._clearDepth = newValue;\n\t}\n\n\tget clearDepth() {\n\t\treturn this._clearDepth;\n\t}\n\n\tset clearDepthBuffer(newValue) {\n\t\tthis._clearDepthBuffer = newValue;\n\t}\n\n\tget clearDepthBuffer() {\n\t\treturn this._clearDepthBuffer;\n\t}\n\n\tset clearStencil(newValue) {\n\t\tthis._clearStencil = newValue;\n\t}\n\n\tget clearStencil() {\n\t\treturn this._clearStencil;\n\t}\n\n\tset clearStencilBuffer(newValue) {\n\t\tthis._clearStencilBuffer = newValue;\n\t}\n\n\tget clearStencilBuffer() {\n\t\treturn this._clearStencilBuffer;\n\t}\n\n\tset cullingMask(newValue) {\n\t\tthis._cullingMask = newValue;\n\t}\n\n\tget cullingMask() {\n\t\treturn this._cullingMask;\n\t}\n\n\tset cullFaces(newValue) {\n\t\tthis._cullFaces = newValue;\n\t}\n\n\tget cullFaces() {\n\t\treturn this._cullFaces;\n\t}\n\n\tset farClip(newValue) {\n\t\tif (this._farClip !== newValue) {\n\t\t\tthis._farClip = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget farClip() {\n\t\treturn this._farClip;\n\t}\n\n\tset flipFaces(newValue) {\n\t\tthis._flipFaces = newValue;\n\t}\n\n\tget flipFaces() {\n\t\treturn this._flipFaces;\n\t}\n\n\tset fov(newValue) {\n\t\tif (this._fov !== newValue) {\n\t\t\tthis._fov = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget fov() {\n\t\treturn this._fov;\n\t}\n\n\tset frustumCulling(newValue) {\n\t\tthis._frustumCulling = newValue;\n\t}\n\n\tget frustumCulling() {\n\t\treturn this._frustumCulling;\n\t}\n\n\tset horizontalFov(newValue) {\n\t\tif (this._horizontalFov !== newValue) {\n\t\t\tthis._horizontalFov = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget horizontalFov() {\n\t\treturn this._horizontalFov;\n\t}\n\n\tset layers(newValue) {\n\t\tthis._layers = newValue.slice(0);\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset nearClip(newValue) {\n\t\tif (this._nearClip !== newValue) {\n\t\t\tthis._nearClip = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget nearClip() {\n\t\treturn this._nearClip;\n\t}\n\n\tset node(newValue) {\n\t\tthis._node = newValue;\n\t}\n\n\tget node() {\n\t\treturn this._node;\n\t}\n\n\tset orthoHeight(newValue) {\n\t\tif (this._orthoHeight !== newValue) {\n\t\t\tthis._orthoHeight = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget orthoHeight() {\n\t\treturn this._orthoHeight;\n\t}\n\n\tset projection(newValue) {\n\t\tif (this._projection !== newValue) {\n\t\t\tthis._projection = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\n\tget projection() {\n\t\treturn this._projection;\n\t}\n\n\tget projectionMatrix() {\n\t\tthis._evaluateProjectionMatrix();\n\n\t\treturn this._projMat;\n\t}\n\n\tset rect(newValue) {\n\t\tthis._rect.copy(newValue);\n\t}\n\n\tget rect() {\n\t\treturn this._rect;\n\t}\n\n\tset renderTarget(newValue) {\n\t\tthis._renderTarget = newValue;\n\t}\n\n\tget renderTarget() {\n\t\treturn this._renderTarget;\n\t}\n\n\tset scissorRect(newValue) {\n\t\tthis._scissorRect.copy(newValue);\n\t}\n\n\tget scissorRect() {\n\t\treturn this._scissorRect;\n\t}\n\n\tget viewMatrix() {\n\t\tif (this._viewMatDirty) {\n\t\t\tconst wtm = this._node.getWorldTransform();\n\n\t\t\tthis._viewMat.copy(wtm).invert();\n\n\t\t\tthis._viewMatDirty = false;\n\t\t}\n\n\t\treturn this._viewMat;\n\t}\n\n\tset vrDisplay(newValue) {\n\t\tthis._vrDisplay = newValue;\n\n\t\tif (newValue) {\n\t\t\tnewValue._camera = this;\n\t\t}\n\t}\n\n\tget vrDisplay() {\n\t\treturn this._vrDisplay;\n\t}\n\n\tclone() {\n\t\treturn new Camera().copy(this);\n\t}\n\n\tcopy(other) {\n\t\tthis.aspectRatio = other.aspectRatio;\n\t\tthis.aspectRatioMode = other.aspectRatioMode;\n\t\tthis.calculateProjection = other.calculateProjection;\n\t\tthis.calculateTransform = other.calculateTransform;\n\t\tthis.clearColor = other.clearColor;\n\t\tthis.clearColorBuffer = other.clearColorBuffer;\n\t\tthis.clearDepth = other.clearDepth;\n\t\tthis.clearDepthBuffer = other.clearDepthBuffer;\n\t\tthis.clearStencil = other.clearStencil;\n\t\tthis.clearStencilBuffer = other.clearStencilBuffer;\n\t\tthis.cullFaces = other.cullFaces;\n\t\tthis.cullingMask = other.cullingMask;\n\t\tthis.farClip = other.farClip;\n\t\tthis.flipFaces = other.flipFaces;\n\t\tthis.fov = other.fov;\n\t\tthis.frustumCulling = other.frustumCulling;\n\t\tthis.horizontalFov = other.horizontalFov;\n\t\tthis.layers = other.layers;\n\t\tthis.nearClip = other.nearClip;\n\t\tthis.orthoHeight = other.orthoHeight;\n\t\tthis.projection = other.projection;\n\t\tthis.rect = other.rect;\n\t\tthis.renderTarget = other.renderTarget;\n\t\tthis.scissorRect = other.scissorRect;\n\t\tthis.vrDisplay = other.vrDisplay;\n\t\treturn this;\n\t}\n\n\t_updateViewProjMat() {\n\t\tif (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {\n\t\t\tthis._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);\n\n\t\t\tthis._viewProjMatDirty = false;\n\t\t}\n\t}\n\n\tworldToScreen(worldCoord, cw, ch, screenCoord = new Vec3()) {\n\t\tthis._updateViewProjMat();\n\n\t\tthis._viewProjMat.transformPoint(worldCoord, screenCoord);\n\n\t\tconst vpm = this._viewProjMat.data;\n\t\tconst w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];\n\t\tscreenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;\n\t\tscreenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;\n\t\treturn screenCoord;\n\t}\n\n\tscreenToWorld(x, y, z, cw, ch, worldCoord = new Vec3()) {\n\t\tconst range = this._farClip - this._nearClip;\n\n\t\t_deviceCoord.set(x / cw, (ch - y) / ch, z / range);\n\n\t\t_deviceCoord.mulScalar(2);\n\n\t\t_deviceCoord.sub(Vec3.ONE);\n\n\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\tMat4._getPerspectiveHalfSize(_halfSize, this._fov, this._aspectRatio, this._nearClip, this._horizontalFov);\n\n\t\t\t_halfSize.x *= _deviceCoord.x;\n\t\t\t_halfSize.y *= _deviceCoord.y;\n\n\t\t\tconst invView = this._node.getWorldTransform();\n\n\t\t\t_halfSize.z = -this._nearClip;\n\t\t\tinvView.transformPoint(_halfSize, _point);\n\n\t\t\tconst cameraPos = this._node.getPosition();\n\n\t\t\tworldCoord.sub2(_point, cameraPos);\n\t\t\tworldCoord.normalize();\n\t\t\tworldCoord.mulScalar(z);\n\t\t\tworldCoord.add(cameraPos);\n\t\t} else {\n\t\t\tthis._updateViewProjMat();\n\n\t\t\t_invViewProjMat.copy(this._viewProjMat).invert();\n\n\t\t\t_invViewProjMat.transformPoint(_deviceCoord, worldCoord);\n\t\t}\n\n\t\treturn worldCoord;\n\t}\n\n\t_evaluateProjectionMatrix() {\n\t\tif (this._projMatDirty) {\n\t\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\t\tthis._projMat.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip, this._horizontalFov);\n\n\t\t\t\tthis._projMatSkybox.copy(this._projMat);\n\t\t\t} else {\n\t\t\t\tconst y = this._orthoHeight;\n\t\t\t\tconst x = y * this._aspectRatio;\n\n\t\t\t\tthis._projMat.setOrtho(-x, x, -y, y, this._nearClip, this._farClip);\n\n\t\t\t\tthis._projMatSkybox.setPerspective(this._fov, this._aspectRatio, this._nearClip, this._farClip);\n\t\t\t}\n\n\t\t\tthis._projMatDirty = false;\n\t\t}\n\t}\n\n\tgetProjectionMatrixSkybox() {\n\t\tthis._evaluateProjectionMatrix();\n\n\t\treturn this._projMatSkybox;\n\t}\n\n\tgetScreenSize(sphere) {\n\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\tconst distance = this._node.getPosition().distance(sphere.center);\n\n\t\t\tif (distance < sphere.radius) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tconst viewAngle = Math.asin(sphere.radius / distance);\n\t\t\tconst sphereViewHeight = Math.tan(viewAngle);\n\t\t\tconst screenViewHeight = Math.tan(this._fov / 2 * math.DEG_TO_RAD);\n\t\t\treturn Math.min(sphereViewHeight / screenViewHeight, 1);\n\t\t}\n\n\t\treturn math.clamp(sphere.radius / this._orthoHeight, 0, 1);\n\t}\n\n}\n\nconst scaleCompensatePosTransform = new Mat4();\nconst scaleCompensatePos = new Vec3();\nconst scaleCompensateRot = new Quat();\nconst scaleCompensateRot2 = new Quat();\nconst scaleCompensateScale = new Vec3();\nconst scaleCompensateScaleForParent = new Vec3();\nconst tmpMat4 = new Mat4();\nconst tmpQuat = new Quat();\nconst position$1 = new Vec3();\nconst invParentWtm$1 = new Mat4();\nconst rotation = new Quat();\nconst invParentRot = new Quat();\nconst matrix = new Mat4();\nconst target = new Vec3();\nconst up = new Vec3();\n\nclass GraphNode extends EventHandler {\n\tconstructor(name = 'Untitled') {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.tags = new Tags(this);\n\t\tthis._labels = {};\n\t\tthis.localPosition = new Vec3();\n\t\tthis.localRotation = new Quat();\n\t\tthis.localScale = new Vec3(1, 1, 1);\n\t\tthis.localEulerAngles = new Vec3();\n\t\tthis.position = new Vec3();\n\t\tthis.rotation = new Quat();\n\t\tthis.eulerAngles = new Vec3();\n\t\tthis._scale = null;\n\t\tthis.localTransform = new Mat4();\n\t\tthis._dirtyLocal = false;\n\t\tthis._aabbVer = 0;\n\t\tthis._frozen = false;\n\t\tthis.worldTransform = new Mat4();\n\t\tthis._dirtyWorld = false;\n\t\tthis.normalMatrix = new Mat3();\n\t\tthis._dirtyNormal = true;\n\t\tthis._right = null;\n\t\tthis._up = null;\n\t\tthis._forward = null;\n\t\tthis._parent = null;\n\t\tthis._children = [];\n\t\tthis._graphDepth = 0;\n\t\tthis._enabled = true;\n\t\tthis._enabledInHierarchy = false;\n\t\tthis.scaleCompensation = false;\n\t}\n\n\tget right() {\n\t\tif (!this._right) {\n\t\t\tthis._right = new Vec3();\n\t\t}\n\n\t\treturn this.getWorldTransform().getX(this._right).normalize();\n\t}\n\n\tget up() {\n\t\tif (!this._up) {\n\t\t\tthis._up = new Vec3();\n\t\t}\n\n\t\treturn this.getWorldTransform().getY(this._up).normalize();\n\t}\n\n\tget forward() {\n\t\tif (!this._forward) {\n\t\t\tthis._forward = new Vec3();\n\t\t}\n\n\t\treturn this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);\n\t}\n\n\tset enabled(enabled) {\n\t\tif (this._enabled !== enabled) {\n\t\t\tthis._enabled = enabled;\n\t\t\tif (!this._parent || this._parent.enabled) this._notifyHierarchyStateChanged(this, enabled);\n\t\t}\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled && this._enabledInHierarchy;\n\t}\n\n\tget parent() {\n\t\treturn this._parent;\n\t}\n\n\tget path() {\n\t\tlet node = this._parent;\n\n\t\tif (!node) {\n\t\t\treturn '';\n\t\t}\n\n\t\tlet result = this.name;\n\n\t\twhile (node && node._parent) {\n\t\t\tresult = `${node.name}/${result}`;\n\t\t\tnode = node._parent;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tget root() {\n\t\tlet result = this;\n\n\t\twhile (result._parent) {\n\t\t\tresult = result._parent;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tget children() {\n\t\treturn this._children;\n\t}\n\n\tget graphDepth() {\n\t\treturn this._graphDepth;\n\t}\n\n\t_notifyHierarchyStateChanged(node, enabled) {\n\t\tnode._onHierarchyStateChanged(enabled);\n\n\t\tconst c = node._children;\n\n\t\tfor (let i = 0, len = c.length; i < len; i++) {\n\t\t\tif (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);\n\t\t}\n\t}\n\n\t_onHierarchyStateChanged(enabled) {\n\t\tthis._enabledInHierarchy = enabled;\n\t\tif (enabled && !this._frozen) this._unfreezeParentToRoot();\n\t}\n\n\t_cloneInternal(clone) {\n\t\tclone.name = this.name;\n\t\tconst tags = this.tags._list;\n\t\tclone.tags.clear();\n\n\t\tfor (let i = 0; i < tags.length; i++) clone.tags.add(tags[i]);\n\n\t\tclone._labels = Object.assign({}, this._labels);\n\t\tclone.localPosition.copy(this.localPosition);\n\t\tclone.localRotation.copy(this.localRotation);\n\t\tclone.localScale.copy(this.localScale);\n\t\tclone.localEulerAngles.copy(this.localEulerAngles);\n\t\tclone.position.copy(this.position);\n\t\tclone.rotation.copy(this.rotation);\n\t\tclone.eulerAngles.copy(this.eulerAngles);\n\t\tclone.localTransform.copy(this.localTransform);\n\t\tclone._dirtyLocal = this._dirtyLocal;\n\t\tclone.worldTransform.copy(this.worldTransform);\n\t\tclone._dirtyWorld = this._dirtyWorld;\n\t\tclone._dirtyNormal = this._dirtyNormal;\n\t\tclone._aabbVer = this._aabbVer + 1;\n\t\tclone._enabled = this._enabled;\n\t\tclone.scaleCompensation = this.scaleCompensation;\n\t\tclone._enabledInHierarchy = false;\n\t}\n\n\tclone() {\n\t\tconst clone = new GraphNode();\n\n\t\tthis._cloneInternal(clone);\n\n\t\treturn clone;\n\t}\n\n\tcopy(source) {\n\t\tsource._cloneInternal(this);\n\n\t\treturn this;\n\t}\n\n\tfind(attr, value) {\n\t\tlet result,\n\t\t\t\tresults = [];\n\t\tconst len = this._children.length;\n\n\t\tif (attr instanceof Function) {\n\t\t\tconst fn = attr;\n\t\t\tresult = fn(this);\n\t\t\tif (result) results.push(this);\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst descendants = this._children[i].find(fn);\n\n\t\t\t\tif (descendants.length) results = results.concat(descendants);\n\t\t\t}\n\t\t} else {\n\t\t\tlet testValue;\n\n\t\t\tif (this[attr]) {\n\t\t\t\tif (this[attr] instanceof Function) {\n\t\t\t\t\ttestValue = this[attr]();\n\t\t\t\t} else {\n\t\t\t\t\ttestValue = this[attr];\n\t\t\t\t}\n\n\t\t\t\tif (testValue === value) results.push(this);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\tconst descendants = this._children[i].find(attr, value);\n\n\t\t\t\tif (descendants.length) results = results.concat(descendants);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tfindOne(attr, value) {\n\t\tconst len = this._children.length;\n\t\tlet result = null;\n\n\t\tif (attr instanceof Function) {\n\t\t\tconst fn = attr;\n\t\t\tresult = fn(this);\n\t\t\tif (result) return this;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tresult = this._children[i].findOne(fn);\n\t\t\t\tif (result) return result;\n\t\t\t}\n\t\t} else {\n\t\t\tlet testValue;\n\n\t\t\tif (this[attr]) {\n\t\t\t\tif (this[attr] instanceof Function) {\n\t\t\t\t\ttestValue = this[attr]();\n\t\t\t\t} else {\n\t\t\t\t\ttestValue = this[attr];\n\t\t\t\t}\n\n\t\t\t\tif (testValue === value) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tresult = this._children[i].findOne(attr, value);\n\t\t\t\tif (result !== null) return result;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfindByTag() {\n\t\tconst query = arguments;\n\t\tconst results = [];\n\n\t\tconst queryNode = (node, checkNode) => {\n\t\t\tif (checkNode && node.tags.has(...query)) {\n\t\t\t\tresults.push(node);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\t\tqueryNode(node._children[i], true);\n\t\t\t}\n\t\t};\n\n\t\tqueryNode(this, false);\n\t\treturn results;\n\t}\n\n\tfindByName(name) {\n\t\tif (this.name === name) return this;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst found = this._children[i].findByName(name);\n\n\t\t\tif (found !== null) return found;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfindByPath(path) {\n\t\tconst parts = Array.isArray(path) ? path : path.split('/');\n\t\tlet result = this;\n\n\t\tfor (let i = 0, imax = parts.length; i < imax; ++i) {\n\t\t\tresult = result.children.find(c => c.name === parts[i]);\n\n\t\t\tif (!result) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tforEach(callback, thisArg) {\n\t\tcallback.call(thisArg, this);\n\t\tconst children = this._children;\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tchildren[i].forEach(callback, thisArg);\n\t\t}\n\t}\n\n\tisDescendantOf(node) {\n\t\tlet parent = this._parent;\n\n\t\twhile (parent) {\n\t\t\tif (parent === node) return true;\n\t\t\tparent = parent._parent;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tisAncestorOf(node) {\n\t\treturn node.isDescendantOf(this);\n\t}\n\n\tgetEulerAngles() {\n\t\tthis.getWorldTransform().getEulerAngles(this.eulerAngles);\n\t\treturn this.eulerAngles;\n\t}\n\n\tgetLocalEulerAngles() {\n\t\tthis.localRotation.getEulerAngles(this.localEulerAngles);\n\t\treturn this.localEulerAngles;\n\t}\n\n\tgetLocalPosition() {\n\t\treturn this.localPosition;\n\t}\n\n\tgetLocalRotation() {\n\t\treturn this.localRotation;\n\t}\n\n\tgetLocalScale() {\n\t\treturn this.localScale;\n\t}\n\n\tgetLocalTransform() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\n\t\treturn this.localTransform;\n\t}\n\n\tgetPosition() {\n\t\tthis.getWorldTransform().getTranslation(this.position);\n\t\treturn this.position;\n\t}\n\n\tgetRotation() {\n\t\tthis.rotation.setFromMat4(this.getWorldTransform());\n\t\treturn this.rotation;\n\t}\n\n\tgetScale() {\n\t\tif (!this._scale) {\n\t\t\tthis._scale = new Vec3();\n\t\t}\n\n\t\treturn this.getWorldTransform().getScale(this._scale);\n\t}\n\n\tgetWorldTransform() {\n\t\tif (!this._dirtyLocal && !this._dirtyWorld) return this.worldTransform;\n\t\tif (this._parent) this._parent.getWorldTransform();\n\n\t\tthis._sync();\n\n\t\treturn this.worldTransform;\n\t}\n\n\treparent(parent, index) {\n\t\tconst current = this._parent;\n\t\tif (current) current.removeChild(this);\n\n\t\tif (parent) {\n\t\t\tif (index >= 0) {\n\t\t\t\tparent.insertChild(this, index);\n\t\t\t} else {\n\t\t\t\tparent.addChild(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetLocalEulerAngles(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localRotation.setFromEulerAngles(x.x, x.y, x.z);\n\t\t} else {\n\t\t\tthis.localRotation.setFromEulerAngles(x, y, z);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetLocalPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localPosition.copy(x);\n\t\t} else {\n\t\t\tthis.localPosition.set(x, y, z);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetLocalRotation(x, y, z, w) {\n\t\tif (x instanceof Quat) {\n\t\t\tthis.localRotation.copy(x);\n\t\t} else {\n\t\t\tthis.localRotation.set(x, y, z, w);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetLocalScale(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localScale.copy(x);\n\t\t} else {\n\t\t\tthis.localScale.set(x, y, z);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\t_dirtifyLocal() {\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = true;\n\t\t\tif (!this._dirtyWorld) this._dirtifyWorld();\n\t\t}\n\t}\n\n\t_unfreezeParentToRoot() {\n\t\tlet p = this._parent;\n\n\t\twhile (p) {\n\t\t\tp._frozen = false;\n\t\t\tp = p._parent;\n\t\t}\n\t}\n\n\t_dirtifyWorld() {\n\t\tif (!this._dirtyWorld) this._unfreezeParentToRoot();\n\n\t\tthis._dirtifyWorldInternal();\n\t}\n\n\t_dirtifyWorldInternal() {\n\t\tif (!this._dirtyWorld) {\n\t\t\tthis._frozen = false;\n\t\t\tthis._dirtyWorld = true;\n\n\t\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\t\tif (!this._children[i]._dirtyWorld) this._children[i]._dirtifyWorldInternal();\n\t\t\t}\n\t\t}\n\n\t\tthis._dirtyNormal = true;\n\t\tthis._aabbVer++;\n\t}\n\n\tsetPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition$1.copy(x);\n\t\t} else {\n\t\t\tposition$1.set(x, y, z);\n\t\t}\n\n\t\tif (this._parent === null) {\n\t\t\tthis.localPosition.copy(position$1);\n\t\t} else {\n\t\t\tinvParentWtm$1.copy(this._parent.getWorldTransform()).invert();\n\t\t\tinvParentWtm$1.transformPoint(position$1, this.localPosition);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetRotation(x, y, z, w) {\n\t\tif (x instanceof Quat) {\n\t\t\trotation.copy(x);\n\t\t} else {\n\t\t\trotation.set(x, y, z, w);\n\t\t}\n\n\t\tif (this._parent === null) {\n\t\t\tthis.localRotation.copy(rotation);\n\t\t} else {\n\t\t\tconst parentRot = this._parent.getRotation();\n\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\tthis.localRotation.copy(invParentRot).mul(rotation);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\tsetEulerAngles(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localRotation.setFromEulerAngles(x.x, x.y, x.z);\n\t\t} else {\n\t\t\tthis.localRotation.setFromEulerAngles(x, y, z);\n\t\t}\n\n\t\tif (this._parent !== null) {\n\t\t\tconst parentRot = this._parent.getRotation();\n\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\tthis.localRotation.mul2(invParentRot, this.localRotation);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\taddChild(node) {\n\t\tif (node._parent !== null) throw new Error(\"GraphNode is already parented\");\n\n\t\tthis._children.push(node);\n\n\t\tthis._onInsertChild(node);\n\t}\n\n\taddChildAndSaveTransform(node) {\n\t\tconst wPos = node.getPosition();\n\t\tconst wRot = node.getRotation();\n\t\tconst current = node._parent;\n\t\tif (current) current.removeChild(node);\n\t\tnode.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));\n\t\tnode.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));\n\n\t\tthis._children.push(node);\n\n\t\tthis._onInsertChild(node);\n\t}\n\n\tinsertChild(node, index) {\n\t\tif (node._parent !== null) throw new Error(\"GraphNode is already parented\");\n\n\t\tthis._children.splice(index, 0, node);\n\n\t\tthis._onInsertChild(node);\n\t}\n\n\t_fireOnHierarchy(name, nameHierarchy, parent) {\n\t\tthis.fire(name, parent);\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tthis._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);\n\t\t}\n\t}\n\n\t_onInsertChild(node) {\n\t\tnode._parent = this;\n\t\tconst enabledInHierarchy = node._enabled && this.enabled;\n\n\t\tif (node._enabledInHierarchy !== enabledInHierarchy) {\n\t\t\tnode._enabledInHierarchy = enabledInHierarchy;\n\n\t\t\tnode._notifyHierarchyStateChanged(node, enabledInHierarchy);\n\t\t}\n\n\t\tnode._updateGraphDepth();\n\n\t\tnode._dirtifyWorld();\n\n\t\tif (this._frozen) node._unfreezeParentToRoot();\n\n\t\tnode._fireOnHierarchy('insert', 'inserthierarchy', this);\n\n\t\tif (this.fire) this.fire('childinsert', node);\n\t}\n\n\t_updateGraphDepth() {\n\t\tthis._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;\n\n\t\tfor (let i = 0, len = this._children.length; i < len; i++) {\n\t\t\tthis._children[i]._updateGraphDepth();\n\t\t}\n\t}\n\n\tremoveChild(child) {\n\t\tconst index = this._children.indexOf(child);\n\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._children.splice(index, 1);\n\n\t\tchild._parent = null;\n\n\t\tchild._fireOnHierarchy('remove', 'removehierarchy', this);\n\n\t\tthis.fire('childremove', child);\n\t}\n\n\t_sync() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\n\t\tif (this._dirtyWorld) {\n\t\t\tif (this._parent === null) {\n\t\t\t\tthis.worldTransform.copy(this.localTransform);\n\t\t\t} else {\n\t\t\t\tif (this.scaleCompensation) {\n\t\t\t\t\tlet parentWorldScale;\n\t\t\t\t\tconst parent = this._parent;\n\t\t\t\t\tlet scale = this.localScale;\n\t\t\t\t\tlet parentToUseScaleFrom = parent;\n\n\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\twhile (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {\n\t\t\t\t\t\t\tparentToUseScaleFrom = parentToUseScaleFrom._parent;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\t\tparentToUseScaleFrom = parentToUseScaleFrom._parent;\n\n\t\t\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\t\t\tparentWorldScale = parentToUseScaleFrom.worldTransform.getScale();\n\t\t\t\t\t\t\t\tscaleCompensateScale.mul2(parentWorldScale, this.localScale);\n\t\t\t\t\t\t\t\tscale = scaleCompensateScale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tscaleCompensateRot2.setFromMat4(parent.worldTransform);\n\t\t\t\t\tscaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);\n\t\t\t\t\tlet tmatrix = parent.worldTransform;\n\n\t\t\t\t\tif (parent.scaleCompensation) {\n\t\t\t\t\t\tscaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());\n\t\t\t\t\t\tscaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);\n\t\t\t\t\t\ttmatrix = scaleCompensatePosTransform;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmatrix.transformPoint(this.localPosition, scaleCompensatePos);\n\t\t\t\t\tthis.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);\n\t\t\t\t} else {\n\t\t\t\t\tthis.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirtyWorld = false;\n\t\t}\n\t}\n\n\tsyncHierarchy() {\n\t\tif (!this._enabled) return;\n\t\tif (this._frozen) return;\n\t\tthis._frozen = true;\n\n\t\tif (this._dirtyLocal || this._dirtyWorld) {\n\t\t\tthis._sync();\n\t\t}\n\n\t\tconst children = this._children;\n\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tchildren[i].syncHierarchy();\n\t\t}\n\t}\n\n\tlookAt(x, y, z, ux = 0, uy = 1, uz = 0) {\n\t\tif (x instanceof Vec3) {\n\t\t\ttarget.copy(x);\n\n\t\t\tif (y instanceof Vec3) {\n\t\t\t\tup.copy(y);\n\t\t\t} else {\n\t\t\t\tup.copy(Vec3.UP);\n\t\t\t}\n\t\t} else if (z === undefined) {\n\t\t\treturn;\n\t\t} else {\n\t\t\ttarget.set(x, y, z);\n\t\t\tup.set(ux, uy, uz);\n\t\t}\n\n\t\tmatrix.setLookAt(this.getPosition(), target, up);\n\t\trotation.setFromMat4(matrix);\n\t\tthis.setRotation(rotation);\n\t}\n\n\ttranslate(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition$1.copy(x);\n\t\t} else {\n\t\t\tposition$1.set(x, y, z);\n\t\t}\n\n\t\tposition$1.add(this.getPosition());\n\t\tthis.setPosition(position$1);\n\t}\n\n\ttranslateLocal(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition$1.copy(x);\n\t\t} else {\n\t\t\tposition$1.set(x, y, z);\n\t\t}\n\n\t\tthis.localRotation.transformVector(position$1, position$1);\n\t\tthis.localPosition.add(position$1);\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\trotate(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\trotation.setFromEulerAngles(x.x, x.y, x.z);\n\t\t} else {\n\t\t\trotation.setFromEulerAngles(x, y, z);\n\t\t}\n\n\t\tif (this._parent === null) {\n\t\t\tthis.localRotation.mul2(rotation, this.localRotation);\n\t\t} else {\n\t\t\tconst rot = this.getRotation();\n\n\t\t\tconst parentRot = this._parent.getRotation();\n\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\trotation.mul2(invParentRot, rotation);\n\t\t\tthis.localRotation.mul2(rotation, rot);\n\t\t}\n\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\trotateLocal(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\trotation.setFromEulerAngles(x.x, x.y, x.z);\n\t\t} else {\n\t\t\trotation.setFromEulerAngles(x, y, z);\n\t\t}\n\n\t\tthis.localRotation.mul(rotation);\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n}\n\nconst _viewMat = new Mat4();\n\nconst _viewProjMat = new Mat4();\n\nconst _viewportMatrix = new Mat4();\n\nclass LightCamera {\n\tstatic create(name, lightType, face) {\n\t\tconst camera = new Camera();\n\t\tcamera.node = new GraphNode(name);\n\t\tcamera.aspectRatio = 1;\n\t\tcamera.aspectRatioMode = ASPECT_MANUAL;\n\t\tcamera._scissorRectClear = true;\n\n\t\tswitch (lightType) {\n\t\t\tcase LIGHTTYPE_OMNI:\n\t\t\t\tcamera.node.setRotation(LightCamera.pointLightRotations[face]);\n\t\t\t\tcamera.fov = 90;\n\t\t\t\tcamera.projection = PROJECTION_PERSPECTIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase LIGHTTYPE_SPOT:\n\t\t\t\tcamera.projection = PROJECTION_PERSPECTIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase LIGHTTYPE_DIRECTIONAL:\n\t\t\t\tcamera.projection = PROJECTION_ORTHOGRAPHIC;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn camera;\n\t}\n\n\tstatic evalSpotCookieMatrix(light) {\n\t\tlet cookieCamera = LightCamera._spotCookieCamera;\n\n\t\tif (!cookieCamera) {\n\t\t\tcookieCamera = LightCamera.create(\"SpotCookieCamera\", LIGHTTYPE_SPOT);\n\t\t\tLightCamera._spotCookieCamera = cookieCamera;\n\t\t}\n\n\t\tcookieCamera.fov = light._outerConeAngle * 2;\n\t\tconst cookieNode = cookieCamera._node;\n\t\tcookieNode.setPosition(light._node.getPosition());\n\t\tcookieNode.setRotation(light._node.getRotation());\n\t\tcookieNode.rotateLocal(-90, 0, 0);\n\n\t\t_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();\n\n\t\t_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);\n\n\t\tconst cookieMatrix = light.cookieMatrix;\n\t\tconst rectViewport = light.atlasViewport;\n\n\t\t_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);\n\n\t\tcookieMatrix.mul2(_viewportMatrix, _viewProjMat);\n\t\treturn cookieMatrix;\n\t}\n\n}\n\nLightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];\nLightCamera._spotCookieCamera = null;\n\nconst epsilon$1 = 0.000001;\nconst tempVec3$1 = new Vec3();\nconst tempAreaLightSizes = new Float32Array(6);\nconst areaHalfAxisWidth = new Vec3(-0.5, 0, 0);\nconst areaHalfAxisHeight = new Vec3(0, 0, 0.5);\nconst TextureIndex8 = {\n\tFLAGS: 0,\n\tCOLOR_A: 1,\n\tCOLOR_B: 2,\n\tSPOT_ANGLES: 3,\n\tSHADOW_BIAS: 4,\n\tCOOKIE_A: 5,\n\tCOOKIE_B: 6,\n\tCOUNT_ALWAYS: 7,\n\tPOSITION_X: 7,\n\tPOSITION_Y: 8,\n\tPOSITION_Z: 9,\n\tRANGE: 10,\n\tSPOT_DIRECTION_X: 11,\n\tSPOT_DIRECTION_Y: 12,\n\tSPOT_DIRECTION_Z: 13,\n\tPROJ_MAT_00: 14,\n\tATLAS_VIEWPORT_A: 14,\n\tPROJ_MAT_01: 15,\n\tATLAS_VIEWPORT_B: 15,\n\tPROJ_MAT_02: 16,\n\tPROJ_MAT_03: 17,\n\tPROJ_MAT_10: 18,\n\tPROJ_MAT_11: 19,\n\tPROJ_MAT_12: 20,\n\tPROJ_MAT_13: 21,\n\tPROJ_MAT_20: 22,\n\tPROJ_MAT_21: 23,\n\tPROJ_MAT_22: 24,\n\tPROJ_MAT_23: 25,\n\tPROJ_MAT_30: 26,\n\tPROJ_MAT_31: 27,\n\tPROJ_MAT_32: 28,\n\tPROJ_MAT_33: 29,\n\tAREA_DATA_WIDTH_X: 30,\n\tAREA_DATA_WIDTH_Y: 31,\n\tAREA_DATA_WIDTH_Z: 32,\n\tAREA_DATA_HEIGHT_X: 33,\n\tAREA_DATA_HEIGHT_Y: 34,\n\tAREA_DATA_HEIGHT_Z: 35,\n\tCOUNT: 36\n};\nconst TextureIndexFloat = {\n\tPOSITION_RANGE: 0,\n\tSPOT_DIRECTION: 1,\n\tPROJ_MAT_0: 2,\n\tATLAS_VIEWPORT: 2,\n\tPROJ_MAT_1: 3,\n\tPROJ_MAT_2: 4,\n\tPROJ_MAT_3: 5,\n\tAREA_DATA_WIDTH: 6,\n\tAREA_DATA_HEIGHT: 7,\n\tCOUNT: 8\n};\n\nclass LightsBuffer {\n\tstatic initShaderDefines() {\n\t\tconst clusterTextureFormat = LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT ? \"FLOAT\" : \"8BIT\";\n\t\tLightsBuffer.shaderDefines = `\n\t\t\t\t\t\t\\n#define CLUSTER_TEXTURE_${clusterTextureFormat}\n\t\t\t\t\t\t${LightsBuffer.buildShaderDefines(TextureIndex8, \"CLUSTER_TEXTURE_8_\")}\n\t\t\t\t\t\t${LightsBuffer.buildShaderDefines(TextureIndexFloat, \"CLUSTER_TEXTURE_F_\")}\n\t\t\t\t`;\n\t}\n\n\tstatic buildShaderDefines(object, prefix) {\n\t\tlet str = \"\";\n\t\tObject.keys(object).forEach(key => {\n\t\t\tstr += `\\n#define ${prefix}${key} ${object[key]}.5`;\n\t\t});\n\t\treturn str;\n\t}\n\n\tstatic init(device) {\n\t\tLightsBuffer.lightTextureFormat = device.extTextureFloat && device.maxTextures > 8 ? LightsBuffer.FORMAT_FLOAT : LightsBuffer.FORMAT_8BIT;\n\t\tLightsBuffer.initShaderDefines();\n\t}\n\n\tstatic createTexture(device, width, height, format, name) {\n\t\tconst tex = new Texture(device, {\n\t\t\tname: name,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmipmaps: false,\n\t\t\tformat: format,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tanisotropy: 1\n\t\t});\n\t\treturn tex;\n\t}\n\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.cookiesEnabled = false;\n\t\tthis.shadowsEnabled = false;\n\t\tthis.areaLightsEnabled = false;\n\t\tthis.maxLights = 255;\n\t\tlet pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;\n\t\tlet pixelsPerLightFloat = 0;\n\n\t\tif (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n\t\t\tpixelsPerLightFloat = TextureIndexFloat.COUNT;\n\t\t} else {\n\t\t\tpixelsPerLight8 = TextureIndex8.COUNT;\n\t\t}\n\n\t\tthis.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);\n\t\tthis.lightsTexture8 = LightsBuffer.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_R8_G8_B8_A8, \"LightsTexture8\");\n\t\tthis._lightsTexture8Id = this.device.scope.resolve(\"lightsTexture8\");\n\n\t\tif (pixelsPerLightFloat) {\n\t\t\tthis.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);\n\t\t\tthis.lightsTextureFloat = LightsBuffer.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, \"LightsTextureFloat\");\n\t\t\tthis._lightsTextureFloatId = this.device.scope.resolve(\"lightsTextureFloat\");\n\t\t} else {\n\t\t\tthis.lightsFloat = null;\n\t\t\tthis.lightsTextureFloat = null;\n\t\t\tthis._lightsTextureFloatId = undefined;\n\t\t}\n\n\t\tthis._lightsTextureInvSizeId = this.device.scope.resolve(\"lightsTextureInvSize\");\n\t\tthis._lightsTextureInvSizeData = new Float32Array(4);\n\t\tthis._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;\n\t\tthis._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;\n\t\tthis._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;\n\t\tthis._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;\n\t\tthis.invMaxColorValue = 0;\n\t\tthis.invMaxAttenuation = 0;\n\t\tthis.boundsMin = new Vec3();\n\t\tthis.boundsDelta = new Vec3();\n\t}\n\n\tdestroy() {\n\t\tif (this.lightsTexture8) {\n\t\t\tthis.lightsTexture8.destroy();\n\t\t\tthis.lightsTexture8 = null;\n\t\t}\n\n\t\tif (this.lightsTextureFloat) {\n\t\t\tthis.lightsTextureFloat.destroy();\n\t\t\tthis.lightsTextureFloat = null;\n\t\t}\n\t}\n\n\tsetCompressionRanges(maxAttenuation, maxColorValue) {\n\t\tthis.invMaxColorValue = 1 / maxColorValue;\n\t\tthis.invMaxAttenuation = 1 / maxAttenuation;\n\t}\n\n\tsetBounds(min, delta) {\n\t\tthis.boundsMin.copy(min);\n\t\tthis.boundsDelta.copy(delta);\n\t}\n\n\tuploadTextures() {\n\t\tif (this.lightsTextureFloat) {\n\t\t\tthis.lightsTextureFloat.lock().set(this.lightsFloat);\n\t\t\tthis.lightsTextureFloat.unlock();\n\t\t}\n\n\t\tthis.lightsTexture8.lock().set(this.lights8);\n\t\tthis.lightsTexture8.unlock();\n\t}\n\n\tupdateUniforms() {\n\t\tthis._lightsTexture8Id.setValue(this.lightsTexture8);\n\n\t\tif (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n\t\t\tthis._lightsTextureFloatId.setValue(this.lightsTextureFloat);\n\t\t}\n\n\t\tthis._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);\n\t}\n\n\tgetSpotDirection(direction, spot) {\n\t\tconst mat = spot._node.getWorldTransform();\n\n\t\tmat.getY(direction).mulScalar(-1);\n\t\tdirection.normalize();\n\t}\n\n\tgetLightAreaSizes(light) {\n\t\tconst mat = light._node.getWorldTransform();\n\n\t\tmat.transformVector(areaHalfAxisWidth, tempVec3$1);\n\t\ttempAreaLightSizes[0] = tempVec3$1.x;\n\t\ttempAreaLightSizes[1] = tempVec3$1.y;\n\t\ttempAreaLightSizes[2] = tempVec3$1.z;\n\t\tmat.transformVector(areaHalfAxisHeight, tempVec3$1);\n\t\ttempAreaLightSizes[3] = tempVec3$1.x;\n\t\ttempAreaLightSizes[4] = tempVec3$1.y;\n\t\ttempAreaLightSizes[5] = tempVec3$1.z;\n\t\treturn tempAreaLightSizes;\n\t}\n\n\taddLightDataFlags(data8, index, light, isSpot, castShadows) {\n\t\tdata8[index + 0] = isSpot ? 255 : 0;\n\t\tdata8[index + 1] = light._shape * 64;\n\t\tdata8[index + 2] = light._falloffMode * 255;\n\t\tdata8[index + 3] = castShadows ? 255 : 0;\n\t}\n\n\taddLightDataColor(data8, index, light, gammaCorrection, isCookie) {\n\t\tconst invMaxColorValue = this.invMaxColorValue;\n\t\tconst color = gammaCorrection ? light._linearFinalColor : light._finalColor;\n\t\tFloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);\n\t\tFloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);\n\t\tdata8[index + 6] = isCookie ? 255 : 0;\n\t\tconst isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);\n\t\tconst isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);\n\t\tdata8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;\n\t}\n\n\taddLightDataSpotAngles(data8, index, light) {\n\t\tFloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon$1) + 0.5, data8, index + 2, 2);\n\t}\n\n\taddLightDataShadowBias(data8, index, light) {\n\t\tconst lightRenderData = light.getRenderData(null, 0);\n\n\t\tconst biases = light._getUniformBiasValues(lightRenderData);\n\n\t\tFloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);\n\t\tFloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);\n\t}\n\n\taddLightDataPositionRange(data8, index, light, pos) {\n\t\tconst normPos = tempVec3$1.sub2(pos, this.boundsMin).div(this.boundsDelta);\n\t\tFloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);\n\t\tFloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);\n\t\tFloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);\n\t\tFloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);\n\t}\n\n\taddLightDataSpotDirection(data8, index, light) {\n\t\tthis.getSpotDirection(tempVec3$1, light);\n\t\tFloatPacking.float2Bytes(tempVec3$1.x * (0.5 - epsilon$1) + 0.5, data8, index + 0, 4);\n\t\tFloatPacking.float2Bytes(tempVec3$1.y * (0.5 - epsilon$1) + 0.5, data8, index + 4, 4);\n\t\tFloatPacking.float2Bytes(tempVec3$1.z * (0.5 - epsilon$1) + 0.5, data8, index + 8, 4);\n\t}\n\n\taddLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {\n\t\tconst matData = lightProjectionMatrix.data;\n\n\t\tfor (let m = 0; m < 12; m++) FloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);\n\n\t\tfor (let m = 12; m < 16; m++) {\n\t\t\tFloatPacking.float2MantissaExponent(matData[m], data8, index + 4 * m, 4);\n\t\t}\n\t}\n\n\taddLightDataCookies(data8, index, light) {\n\t\tconst isRgb = light._cookieChannel === \"rgb\";\n\t\tdata8[index + 0] = Math.floor(light.cookieIntensity * 255);\n\t\tdata8[index + 1] = isRgb ? 255 : 0;\n\n\t\tif (!isRgb) {\n\t\t\tconst channel = light._cookieChannel;\n\t\t\tdata8[index + 4] = channel === \"rrr\" ? 255 : 0;\n\t\t\tdata8[index + 5] = channel === \"ggg\" ? 255 : 0;\n\t\t\tdata8[index + 6] = channel === \"bbb\" ? 255 : 0;\n\t\t\tdata8[index + 7] = channel === \"aaa\" ? 255 : 0;\n\t\t}\n\t}\n\n\taddLightAtlasViewport(data8, index, atlasViewport) {\n\t\tFloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);\n\t\tFloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);\n\t}\n\n\taddLightAreaSizes(data8, index, light) {\n\t\tconst areaSizes = this.getLightAreaSizes(light);\n\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tFloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);\n\t\t}\n\t}\n\n\taddLightData(light, lightIndex, gammaCorrection) {\n\t\tconst isSpot = light._type === LIGHTTYPE_SPOT;\n\t\tconst hasAtlasViewport = light.atlasViewportAllocated;\n\t\tconst isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;\n\t\tconst isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;\n\t\tconst castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;\n\n\t\tconst pos = light._node.getPosition();\n\n\t\tlet lightProjectionMatrix = null;\n\t\tlet atlasViewport = null;\n\n\t\tif (isSpot) {\n\t\t\tif (castShadows) {\n\t\t\t\tconst lightRenderData = light.getRenderData(null, 0);\n\t\t\t\tlightProjectionMatrix = lightRenderData.shadowMatrix;\n\t\t\t} else if (isCookie) {\n\t\t\t\tlightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);\n\t\t\t}\n\t\t} else {\n\t\t\tif (castShadows || isCookie) {\n\t\t\t\tatlasViewport = light.atlasViewport;\n\t\t\t}\n\t\t}\n\n\t\tconst data8 = this.lights8;\n\t\tconst data8Start = lightIndex * this.lightsTexture8.width * 4;\n\t\tthis.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows);\n\t\tthis.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);\n\n\t\tif (isSpot) {\n\t\t\tthis.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);\n\t\t}\n\n\t\tif (light.castShadows) {\n\t\t\tthis.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);\n\t\t}\n\n\t\tif (isCookie) {\n\t\t\tthis.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);\n\t\t}\n\n\t\tif (LightsBuffer.lightTextureFormat === LightsBuffer.FORMAT_FLOAT) {\n\t\t\tconst dataFloat = this.lightsFloat;\n\t\t\tconst dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;\n\n\t\t\tif (isSpot) {\n\t\t\t\tthis.getSpotDirection(tempVec3$1, light);\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3$1.x;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3$1.y;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3$1.z;\n\t\t\t}\n\n\t\t\tif (lightProjectionMatrix) {\n\t\t\t\tconst matData = lightProjectionMatrix.data;\n\n\t\t\t\tfor (let m = 0; m < 16; m++) dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];\n\t\t\t}\n\n\t\t\tif (atlasViewport) {\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;\n\t\t\t}\n\n\t\t\tif (isArea) {\n\t\t\t\tconst areaSizes = this.getLightAreaSizes(light);\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];\n\t\t\t}\n\t\t} else {\n\t\t\tthis.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);\n\n\t\t\tif (isSpot) {\n\t\t\t\tthis.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);\n\t\t\t}\n\n\t\t\tif (lightProjectionMatrix) {\n\t\t\t\tthis.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);\n\t\t\t}\n\n\t\t\tif (atlasViewport) {\n\t\t\t\tthis.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);\n\t\t\t}\n\n\t\t\tif (isArea) {\n\t\t\t\tthis.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nLightsBuffer.FORMAT_FLOAT = 0;\nLightsBuffer.FORMAT_8BIT = 1;\nLightsBuffer.lightTextureFormat = LightsBuffer.FORMAT_8BIT;\nLightsBuffer.shaderDefines = \"\";\n\nconst _matTex2D = [];\nconst decodeTable = {\n\t'rgbm': 'decodeRGBM',\n\t'rgbe': 'decodeRGBE',\n\t'linear': 'decodeLinear'\n};\nconst standard = {\n\toptionsContext: {},\n\toptionsContextMin: {},\n\tgenerateKey: function (options) {\n\t\tconst buildPropertiesList = function buildPropertiesList(options) {\n\t\t\tconst props = [];\n\n\t\t\tfor (const prop in options) {\n\t\t\t\tif (options.hasOwnProperty(prop) && prop !== \"chunks\" && prop !== \"lights\") props.push(prop);\n\t\t\t}\n\n\t\t\treturn props.sort();\n\t\t};\n\n\t\tlet props;\n\n\t\tif (options === this.optionsContextMin) {\n\t\t\tif (!this.propsMin) this.propsMin = buildPropertiesList(options);\n\t\t\tprops = this.propsMin;\n\t\t} else if (options === this.optionsContext) {\n\t\t\tif (!this.props) this.props = buildPropertiesList(options);\n\t\t\tprops = this.props;\n\t\t} else {\n\t\t\tprops = buildPropertiesList(options);\n\t\t}\n\n\t\tlet key = \"standard\";\n\n\t\tfor (let i = 0; i < props.length; i++) {\n\t\t\tif (options[props[i]]) key += props[i] + options[props[i]];\n\t\t}\n\n\t\tif (options.chunks) {\n\t\t\tconst chunks = [];\n\n\t\t\tfor (const p in options.chunks) {\n\t\t\t\tif (options.chunks.hasOwnProperty(p)) {\n\t\t\t\t\tchunks.push(p + options.chunks[p]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunks.sort();\n\t\t\tkey += chunks;\n\t\t}\n\n\t\tif (options.lights) {\n\t\t\tconst isClustered = options.clusteredLightingEnabled;\n\n\t\t\tfor (let i = 0; i < options.lights.length; i++) {\n\t\t\t\tconst light = options.lights[i];\n\n\t\t\t\tif (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tkey += light.key;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn hashCode(key);\n\t},\n\t_correctChannel: function (p, chan) {\n\t\tif (_matTex2D[p] > 0) {\n\t\t\tif (_matTex2D[p] < chan.length) {\n\t\t\t\treturn chan.substring(0, _matTex2D[p]);\n\t\t\t} else if (_matTex2D[p] > chan.length) {\n\t\t\t\tlet str = chan;\n\t\t\t\tconst chr = str.charAt(str.length - 1);\n\t\t\t\tconst addLen = _matTex2D[p] - str.length;\n\n\t\t\t\tfor (let i = 0; i < addLen; i++) str += chr;\n\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t\treturn chan;\n\t\t}\n\t},\n\t_setMapTransform: function (codes, name, id, uv) {\n\t\tconst varName = `texture_${name}MapTransform`;\n\t\tconst checkId = id + uv * 100;\n\t\tcodes[0] += `uniform vec3 ${varName}0;\\n`;\n\t\tcodes[0] += `uniform vec3 ${varName}1;\\n`;\n\n\t\tif (!codes[3][checkId]) {\n\t\t\tcodes[1] += `varying vec2 vUV${uv}_${id};\\n`;\n\t\t\tcodes[2] += `\t vUV${uv}_${id} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));\\n`;\n\t\t\tcodes[3][checkId] = true;\n\t\t}\n\n\t\treturn codes;\n\t},\n\t_getUvSourceExpression: function (transformPropName, uVPropName, options) {\n\t\tconst transformId = options[transformPropName];\n\t\tconst uvChannel = options[uVPropName];\n\t\tconst isMainPass = options.pass === SHADER_FORWARD || options.pass === SHADER_FORWARDHDR;\n\t\tlet expression;\n\n\t\tif (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\texpression = \"nineSlicedUv\";\n\t\t} else if (isMainPass && options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\texpression = \"nineSlicedUv, -1000.0\";\n\t\t} else {\n\t\t\tif (transformId === 0) {\n\t\t\t\texpression = \"vUv\" + uvChannel;\n\t\t\t} else {\n\t\t\t\texpression = \"vUV\" + uvChannel + \"_\" + transformId;\n\t\t\t}\n\n\t\t\tif (options.heightMap && transformPropName !== \"heightMapTransform\") {\n\t\t\t\texpression += \" + dUvOffset\";\n\t\t\t}\n\t\t}\n\n\t\treturn expression;\n\t},\n\t_addMapDef: function (name, enabled) {\n\t\tlet s = \"\\n#undef \" + name + \"\\n\";\n\t\tif (enabled) s += \" #define \" + name + \"\\n\";\n\t\treturn s;\n\t},\n\t_addMapDefs: function (float, color, vertex, map) {\n\t\tlet s = \"\";\n\t\ts += this._addMapDef(\"MAPFLOAT\", float);\n\t\ts += this._addMapDef(\"MAPCOLOR\", color);\n\t\ts += this._addMapDef(\"MAPVERTEX\", vertex);\n\t\ts += this._addMapDef(\"MAPTEXTURE\", map);\n\t\treturn s;\n\t},\n\t_addMap: function (propName, chunkName, options, chunks, samplerFormat) {\n\t\tconst mapPropName = propName + \"Map\";\n\t\tconst uVPropName = mapPropName + \"Uv\";\n\t\tconst transformPropName = mapPropName + \"Transform\";\n\t\tconst channelPropName = mapPropName + \"Channel\";\n\t\tconst vertexColorChannelPropName = propName + \"VertexColorChannel\";\n\t\tconst tintPropName = propName + \"Tint\";\n\t\tconst vertexColorPropName = propName + \"VertexColor\";\n\t\tconst detailModePropName = propName + \"Mode\";\n\t\tconst tintOption = options[tintPropName];\n\t\tconst vertexColorOption = options[vertexColorPropName];\n\t\tconst textureOption = options[mapPropName];\n\t\tconst detailModeOption = options[detailModePropName];\n\t\tlet subCode = chunks[chunkName];\n\n\t\tif (textureOption) {\n\t\t\tconst uv = this._getUvSourceExpression(transformPropName, uVPropName, options);\n\n\t\t\tsubCode = subCode.replace(/\\$UV/g, uv).replace(/\\$CH/g, options[channelPropName]);\n\n\t\t\tif (samplerFormat !== undefined) {\n\t\t\t\tconst fmt = samplerFormat === 0 ? \"texture2DSRGB\" : samplerFormat === 1 ? \"texture2DRGBM\" : \"texture2D\";\n\t\t\t\tsubCode = subCode.replace(/\\$texture2DSAMPLE/g, fmt);\n\t\t\t}\n\t\t}\n\n\t\tif (vertexColorOption) {\n\t\t\tsubCode = subCode.replace(/\\$VC/g, options[vertexColorChannelPropName]);\n\t\t}\n\n\t\tif (detailModeOption) {\n\t\t\tsubCode = subCode.replace(/\\$DETAILMODE/g, detailModeOption);\n\t\t}\n\n\t\tconst isFloatTint = !!(tintOption & 1);\n\t\tconst isVecTint = !!(tintOption & 2);\n\t\tsubCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption) + subCode;\n\t\treturn subCode.replace(/\\$/g, \"\");\n\t},\n\t_directionalShadowMapProjection: function (light, shadowCoordArgs, shadowParamArg, lightIndex, coordsFunctioName) {\n\t\tlet code = \"\";\n\n\t\tif (light.numCascades > 1) {\n\t\t\tcode += `getShadowCascadeMatrix(light${lightIndex}_shadowMatrixPalette, light${lightIndex}_shadowCascadeDistances, light${lightIndex}_shadowCascadeCount);\\n`;\n\t\t\tshadowCoordArgs = `(cascadeShadowMat, ${shadowParamArg});\\n`;\n\t\t}\n\n\t\tcode += coordsFunctioName + shadowCoordArgs;\n\t\tcode += `fadeShadow(light${lightIndex}_shadowCascadeDistances);\\n`;\n\t\treturn code;\n\t},\n\t_nonPointShadowMapProjection: function (device, light, shadowMatArg, shadowParamArg, lightIndex) {\n\t\tconst shadowCoordArgs = `(${shadowMatArg}, ${shadowParamArg});\\n`;\n\n\t\tif (!light._normalOffsetBias || light._isVsm) {\n\t\t\tif (light._type === LIGHTTYPE_SPOT) {\n\t\t\t\tif (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {\n\t\t\t\t\treturn \"\t\t\t getShadowCoordPerspZbuffer\" + shadowCoordArgs;\n\t\t\t\t}\n\n\t\t\t\treturn \"\t\t\t getShadowCoordPersp\" + shadowCoordArgs;\n\t\t\t}\n\n\t\t\treturn this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, \"getShadowCoordOrtho\");\n\t\t}\n\n\t\tif (light._type === LIGHTTYPE_SPOT) {\n\t\t\tif (light._isPcf && (device.webgl2 || device.extStandardDerivatives)) {\n\t\t\t\treturn \"\t\t\t getShadowCoordPerspZbufferNormalOffset\" + shadowCoordArgs;\n\t\t\t}\n\n\t\t\treturn \"\t\t\t getShadowCoordPerspNormalOffset\" + shadowCoordArgs;\n\t\t}\n\n\t\treturn this._directionalShadowMapProjection(light, shadowCoordArgs, shadowParamArg, lightIndex, \"getShadowCoordOrthoNormalOffset\");\n\t},\n\t_addVaryingIfNeeded: function (code, type, name) {\n\t\treturn code.indexOf(name) >= 0 ? \"varying \" + type + \" \" + name + \";\\n\" : \"\";\n\t},\n\t_getLightSourceShapeString: function (shape) {\n\t\tswitch (shape) {\n\t\t\tcase LIGHTSHAPE_RECT:\n\t\t\t\treturn 'Rect';\n\n\t\t\tcase LIGHTSHAPE_DISK:\n\t\t\t\treturn 'Disk';\n\n\t\t\tcase LIGHTSHAPE_SPHERE:\n\t\t\t\treturn 'Sphere';\n\n\t\t\tdefault:\n\t\t\t\treturn '';\n\t\t}\n\t},\n\t_getPassDefineString: function (pass) {\n\t\tif (pass === SHADER_PICK) {\n\t\t\treturn '#define PICK_PASS\\n';\n\t\t} else if (pass === SHADER_DEPTH) {\n\t\t\treturn '#define DEPTH_PASS\\n';\n\t\t} else if (pass >= SHADER_SHADOW && pass <= 17) {\n\t\t\treturn '#define SHADOW_PASS\\n';\n\t\t}\n\n\t\treturn '';\n\t},\n\t_vsAddTransformCode: function (code, device, chunks, options) {\n\t\tcode += chunks.transformVS;\n\t\treturn code;\n\t},\n\t_vsAddBaseCode: function (code, device, chunks, options) {\n\t\tcode += chunks.baseVS;\n\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tcode += chunks.baseNineSlicedVS;\n\t\t}\n\n\t\treturn code;\n\t},\n\t_fsAddBaseCode: function (code, device, chunks, options) {\n\t\tcode += chunks.basePS;\n\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tcode += chunks.baseNineSlicedPS;\n\t\t} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tcode += chunks.baseNineSlicedTiledPS;\n\t\t}\n\n\t\treturn code;\n\t},\n\t_decodeFunc: function (textureFormat) {\n\t\treturn decodeTable[textureFormat] || 'decodeGamma';\n\t},\n\t_fsAddStartCode: function (code, device, chunks, options) {\n\t\tcode += chunks.startPS;\n\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tcode += chunks.startNineSlicedPS;\n\t\t} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tcode += chunks.startNineSlicedTiledPS;\n\t\t}\n\n\t\treturn code;\n\t},\n\t_buildShadowPassFragmentCode: function (code, device, chunks, options, varyings) {\n\t\tconst smode = options.pass - SHADER_SHADOW;\n\t\tconst numShadowModes = SHADOW_COUNT;\n\t\tconst lightType = Math.floor(smode / numShadowModes);\n\t\tconst shadowType = smode - lightType * numShadowModes;\n\n\t\tif (device.extStandardDerivatives && !device.webgl2) {\n\t\t\tcode += 'uniform vec2 polygonOffset;\\n';\n\t\t}\n\n\t\tif (shadowType === SHADOW_VSM32) {\n\t\t\tif (device.textureFloatHighPrecision) {\n\t\t\t\tcode += '#define VSM_EXPONENT 15.0\\n\\n';\n\t\t\t} else {\n\t\t\t\tcode += '#define VSM_EXPONENT 5.54\\n\\n';\n\t\t\t}\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\tcode += '#define VSM_EXPONENT 5.54\\n\\n';\n\t\t}\n\n\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tcode += 'uniform vec3 view_position;\\n';\n\t\t\tcode += 'uniform float light_radius;\\n';\n\t\t}\n\n\t\tcode += varyings;\n\n\t\tif (options.alphaTest) {\n\t\t\tcode += \"float dAlpha;\\n\";\n\t\t\tcode += this._addMap(\"opacity\", \"opacityPS\", options, chunks);\n\t\t\tcode += chunks.alphaTestPS;\n\t\t}\n\n\t\tif (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI)) {\n\t\t\tcode += chunks.packDepthPS;\n\t\t} else if (shadowType === SHADOW_VSM8) {\n\t\t\tcode += \"vec2 encodeFloatRG( float v ) {\\n\";\n\t\t\tcode += \"\t\tvec2 enc = vec2(1.0, 255.0) * v;\\n\";\n\t\t\tcode += \"\t\tenc = fract(enc);\\n\";\n\t\t\tcode += \"\t\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\\n\";\n\t\t\tcode += \"\t\treturn enc;\\n\";\n\t\t\tcode += \"}\\n\\n\";\n\t\t}\n\n\t\tcode += begin();\n\n\t\tif (options.alphaTest) {\n\t\t\tcode += \"\t getOpacity();\\n\";\n\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t}\n\n\t\tconst isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;\n\n\t\tif (lightType === LIGHTTYPE_OMNI || isVsm && lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tcode += \"\t float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\\n\";\n\t\t} else {\n\t\t\tcode += \"\t float depth = gl_FragCoord.z;\\n\";\n\t\t}\n\n\t\tif (shadowType === SHADOW_PCF3 && (!device.webgl2 || lightType === LIGHTTYPE_OMNI && !options.clusteredLightingEnabled)) {\n\t\t\tif (device.extStandardDerivatives && !device.webgl2) {\n\t\t\t\tcode += \"\t float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\\n\";\n\t\t\t\tcode += \"\t depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\\n\";\n\t\t\t\tcode += \"\t gl_FragColor = packFloat(depth);\\n\";\n\t\t\t} else {\n\t\t\t\tcode += \"\t gl_FragColor = packFloat(depth);\\n\";\n\t\t\t}\n\t\t} else if (shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5) {\n\t\t\tcode += \"\t gl_FragColor = vec4(1.0);\\n\";\n\n\t\t\tif (options.clusteredLightingEnabled && lightType === LIGHTTYPE_OMNI && device.webgl2) {\n\t\t\t\tcode += \"\t gl_FragDepth = depth;\\n\";\n\t\t\t}\n\t\t} else if (shadowType === SHADOW_VSM8) {\n\t\t\tcode += \"\t gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\\n\";\n\t\t} else {\n\t\t\tcode += chunks.storeEVSMPS;\n\t\t}\n\n\t\tcode += end();\n\t\treturn code;\n\t},\n\tcreateShaderDefinition: function (device, options) {\n\t\tlet lighting = options.lights.length > 0;\n\n\t\tif (options.dirLightMap) {\n\t\t\tlighting = true;\n\t\t}\n\n\t\tif (options.clusteredLightingEnabled) {\n\t\t\tlighting = true;\n\t\t}\n\n\t\tif (options.shadingModel === SPECULAR_PHONG) {\n\t\t\toptions.fresnelModel = 0;\n\t\t\toptions.specularAntialias = false;\n\t\t\toptions.ambientSH = false;\n\t\t} else {\n\t\t\toptions.fresnelModel = options.fresnelModel === 0 ? FRESNEL_SCHLICK : options.fresnelModel;\n\t\t}\n\n\t\tconst reflections = !!options.reflectionSource;\n\t\tif (!options.useSpecular) options.specularMap = options.glossMap = null;\n\t\tconst shadowPass = options.pass >= SHADER_SHADOW && options.pass <= 17;\n\t\tconst needsNormal = lighting || reflections || options.ambientSH || options.heightMap || options.enableGGXSpecular || options.clusteredLightingEnabled && !shadowPass || options.clearCoatNormalMap;\n\t\tthis.options = options;\n\t\tlet code = '';\n\t\tlet codeBody = '';\n\t\tlet varyings = \"\";\n\t\tlet chunks = shaderChunks;\n\t\tlet shadowCoordArgs;\n\t\tlet chunk;\n\t\tconst attributes = {\n\t\t\tvertex_position: SEMANTIC_POSITION\n\t\t};\n\n\t\tif (options.chunks) {\n\t\t\tconst customChunks = {};\n\n\t\t\tfor (const p in chunks) {\n\t\t\t\tif (chunks.hasOwnProperty(p)) {\n\t\t\t\t\tif (!options.chunks[p]) {\n\t\t\t\t\t\tcustomChunks[p] = chunks[p];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk = options.chunks[p];\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_normal\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_normal = SEMANTIC_NORMAL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_tangent\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_tangent = SEMANTIC_TANGENT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_texCoord0\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_texCoord1\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_texCoord1 = SEMANTIC_TEXCOORD1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_color\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_color = SEMANTIC_COLOR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_boneWeights\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.indexOf(\"vertex_boneIndices\") >= 0) {\n\t\t\t\t\t\t\tattributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcustomChunks[p] = chunk;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunks = customChunks;\n\t\t}\n\n\t\tcode += this._getPassDefineString(options.pass);\n\t\tcode = this._vsAddBaseCode(code, device, chunks, options);\n\t\tcodeBody += \"\t vPositionW\t\t= getWorldPosition();\\n\";\n\n\t\tif (options.pass === SHADER_DEPTH) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += '#ifndef VIEWMATRIX\\n';\n\t\t\tcode += '#define VIEWMATRIX\\n';\n\t\t\tcode += 'uniform mat4 matrix_view;\\n';\n\t\t\tcode += '#endif\\n';\n\t\t\tcode += '#ifndef CAMERAPLANES\\n';\n\t\t\tcode += '#define CAMERAPLANES\\n';\n\t\t\tcode += 'uniform vec4 camera_params;\\n\\n';\n\t\t\tcode += '#endif\\n';\n\t\t\tcodeBody += \"\t\tvDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\\n\";\n\t\t}\n\n\t\tif (options.useInstancing) {\n\t\t\tattributes.instance_line1 = SEMANTIC_ATTR12;\n\t\t\tattributes.instance_line2 = SEMANTIC_ATTR13;\n\t\t\tattributes.instance_line3 = SEMANTIC_ATTR14;\n\t\t\tattributes.instance_line4 = SEMANTIC_ATTR15;\n\t\t\tcode += chunks.instancingVS;\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tattributes.vertex_normal = SEMANTIC_NORMAL;\n\t\t\tcodeBody += \"\t vNormalW = getNormal();\\n\";\n\n\t\t\tif (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {\n\t\t\t\tcode += chunks.viewNormalVS;\n\t\t\t\tcodeBody += \"\t vNormalV\t\t= getViewNormal();\\n\";\n\t\t\t}\n\n\t\t\tif ((options.heightMap || options.normalMap || options.enableGGXSpecular) && options.hasTangents) {\n\t\t\t\tattributes.vertex_tangent = SEMANTIC_TANGENT;\n\t\t\t\tcode += chunks.tangentBinormalVS;\n\t\t\t\tcodeBody += \"\t vTangentW\t = getTangent();\\n\";\n\t\t\t\tcodeBody += \"\t vBinormalW\t= getBinormal();\\n\";\n\t\t\t} else if (options.enableGGXSpecular) {\n\t\t\t\tcode += chunks.tangentBinormalVS;\n\t\t\t\tcodeBody += \"\t vObjectSpaceUpW\t= getObjectSpaceUp();\\n\";\n\t\t\t}\n\t\t}\n\n\t\tconst useUv = [];\n\t\tconst useUnmodifiedUv = [];\n\t\tconst maxUvSets = 2;\n\n\t\tfor (const p in _matTex2D) {\n\t\t\tconst mname = p + \"Map\";\n\n\t\t\tif (options[p + \"VertexColor\"]) {\n\t\t\t\tconst cname = p + \"VertexColorChannel\";\n\t\t\t\toptions[cname] = this._correctChannel(p, options[cname]);\n\t\t\t}\n\n\t\t\tif (options[mname]) {\n\t\t\t\tconst cname = mname + \"Channel\";\n\t\t\t\tconst tname = mname + \"Transform\";\n\t\t\t\tconst uname = mname + \"Uv\";\n\t\t\t\toptions[uname] = Math.min(options[uname], maxUvSets - 1);\n\t\t\t\toptions[cname] = this._correctChannel(p, options[cname]);\n\t\t\t\tconst uvSet = options[uname];\n\t\t\t\tuseUv[uvSet] = true;\n\t\t\t\tuseUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];\n\t\t\t}\n\t\t}\n\n\t\tif (options.forceUv1) {\n\t\t\tuseUv[1] = true;\n\t\t\tuseUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;\n\t\t}\n\n\t\tfor (let i = 0; i < maxUvSets; i++) {\n\t\t\tif (useUv[i]) {\n\t\t\t\tattributes[\"vertex_texCoord\" + i] = \"TEXCOORD\" + i;\n\t\t\t\tcode += chunks[\"uv\" + i + \"VS\"];\n\t\t\t\tcodeBody += \"\t vec2 uv\" + i + \" = getUv\" + i + \"();\\n\";\n\t\t\t}\n\n\t\t\tif (useUnmodifiedUv[i]) {\n\t\t\t\tcodeBody += \"\t vUv\" + i + \" = uv\" + i + \";\\n\";\n\t\t\t}\n\t\t}\n\n\t\tconst codes = [code, varyings, codeBody, []];\n\n\t\tfor (const p in _matTex2D) {\n\t\t\tconst mname = p + \"Map\";\n\n\t\t\tif (options[mname]) {\n\t\t\t\tconst tname = mname + \"Transform\";\n\n\t\t\t\tif (options[tname]) {\n\t\t\t\t\tconst uname = mname + \"Uv\";\n\n\t\t\t\t\tthis._setMapTransform(codes, p, options[tname], options[uname]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcode = codes[0];\n\t\tvaryings = codes[1];\n\t\tcodeBody = codes[2];\n\n\t\tif (options.vertexColors) {\n\t\t\tattributes.vertex_color = SEMANTIC_COLOR;\n\t\t\tcodeBody += \"\t vVertexColor = vertex_color;\\n\";\n\t\t}\n\n\t\tif (options.useMorphPosition || options.useMorphNormal) {\n\t\t\tif (options.useMorphTextureBased) {\n\t\t\t\tcode += \"#define MORPHING_TEXTURE_BASED\\n\";\n\n\t\t\t\tif (options.useMorphPosition) {\n\t\t\t\t\tcode += \"#define MORPHING_TEXTURE_BASED_POSITION\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (options.useMorphNormal) {\n\t\t\t\t\tcode += \"#define MORPHING_TEXTURE_BASED_NORMAL\\n\";\n\t\t\t\t}\n\n\t\t\t\tattributes.morph_vertex_id = SEMANTIC_ATTR15;\n\t\t\t\tcode += \"attribute float morph_vertex_id;\\n\";\n\t\t\t} else {\n\t\t\t\tcode += \"#define MORPHING\\n\";\n\n\t\t\t\tif (options.useMorphPosition) {\n\t\t\t\t\tattributes.morph_pos0 = SEMANTIC_ATTR8;\n\t\t\t\t\tattributes.morph_pos1 = SEMANTIC_ATTR9;\n\t\t\t\t\tattributes.morph_pos2 = SEMANTIC_ATTR10;\n\t\t\t\t\tattributes.morph_pos3 = SEMANTIC_ATTR11;\n\t\t\t\t\tcode += \"#define MORPHING_POS03\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos0;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos1;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos2;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos3;\\n\";\n\t\t\t\t} else if (options.useMorphNormal) {\n\t\t\t\t\tattributes.morph_nrm0 = SEMANTIC_ATTR8;\n\t\t\t\t\tattributes.morph_nrm1 = SEMANTIC_ATTR9;\n\t\t\t\t\tattributes.morph_nrm2 = SEMANTIC_ATTR10;\n\t\t\t\t\tattributes.morph_nrm3 = SEMANTIC_ATTR11;\n\t\t\t\t\tcode += \"#define MORPHING_NRM03\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm0;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm1;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm2;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm3;\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (!options.useMorphNormal) {\n\t\t\t\t\tattributes.morph_pos4 = SEMANTIC_ATTR12;\n\t\t\t\t\tattributes.morph_pos5 = SEMANTIC_ATTR13;\n\t\t\t\t\tattributes.morph_pos6 = SEMANTIC_ATTR14;\n\t\t\t\t\tattributes.morph_pos7 = SEMANTIC_ATTR15;\n\t\t\t\t\tcode += \"#define MORPHING_POS47\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos4;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos5;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos6;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_pos7;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tattributes.morph_nrm4 = SEMANTIC_ATTR12;\n\t\t\t\t\tattributes.morph_nrm5 = SEMANTIC_ATTR13;\n\t\t\t\t\tattributes.morph_nrm6 = SEMANTIC_ATTR14;\n\t\t\t\t\tattributes.morph_nrm7 = SEMANTIC_ATTR15;\n\t\t\t\t\tcode += \"#define MORPHING_NRM47\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm4;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm5;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm6;\\n\";\n\t\t\t\t\tcode += \"attribute vec3 morph_nrm7;\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.skin) {\n\t\t\tattributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;\n\t\t\tattributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;\n\t\t\tcode += skinCode(device, chunks);\n\t\t\tcode += \"#define SKIN\\n\";\n\t\t} else if (options.useInstancing) {\n\t\t\tcode += \"#define INSTANCING\\n\";\n\t\t}\n\n\t\tif (options.screenSpace) {\n\t\t\tcode += \"#define SCREENSPACE\\n\";\n\t\t}\n\n\t\tif (options.pixelSnap) {\n\t\t\tcode += \"#define PIXELSNAP\\n\";\n\t\t}\n\n\t\tcode = this._vsAddTransformCode(code, device, chunks, options);\n\t\tif (needsNormal) code += chunks.normalVS;\n\t\tcode += \"\\n\";\n\t\tcode += chunks.startVS;\n\t\tcode += codeBody;\n\t\tcode += chunks.endVS;\n\t\tcode += \"}\";\n\t\tlet vshader = code;\n\t\tconst oldVars = varyings;\n\t\tvaryings = \"\";\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec4\", \"vVertexColor\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vPositionW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vNormalV\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vNormalW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vTangentW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vBinormalW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec3\", \"vObjectSpaceUpW\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec2\", \"vUv0\");\n\t\tvaryings += this._addVaryingIfNeeded(code, \"vec2\", \"vUv1\");\n\t\tvaryings += oldVars;\n\t\tvshader = varyings + vshader;\n\t\tlet startCode = \"\";\n\n\t\tif (device.webgl2) {\n\t\t\tstartCode = versionCode(device);\n\n\t\t\tif (chunks.extensionVS) {\n\t\t\t\tstartCode += chunks.extensionVS + \"\\n\";\n\t\t\t}\n\n\t\t\tvshader = startCode + chunks.gles3VS + vshader;\n\t\t} else {\n\t\t\tif (chunks.extensionVS) {\n\t\t\t\tstartCode = chunks.extensionVS + \"\\n\";\n\t\t\t}\n\n\t\t\tvshader = startCode + vshader;\n\t\t}\n\n\t\tif (options.forceFragmentPrecision && options.forceFragmentPrecision !== \"highp\" && options.forceFragmentPrecision !== \"mediump\" && options.forceFragmentPrecision !== \"lowp\") options.forceFragmentPrecision = null;\n\n\t\tif (options.forceFragmentPrecision) {\n\t\t\tif (options.forceFragmentPrecision === \"highp\" && device.maxPrecision !== \"highp\") options.forceFragmentPrecision = \"mediump\";\n\t\t\tif (options.forceFragmentPrecision === \"mediump\" && device.maxPrecision === \"lowp\") options.forceFragmentPrecision = \"lowp\";\n\t\t}\n\n\t\tlet fshader;\n\t\tcode = '';\n\n\t\tif (device.webgl2) {\n\t\t\tcode += versionCode(device);\n\t\t}\n\n\t\tif (!device.webgl2) {\n\t\t\tif (device.extStandardDerivatives) {\n\t\t\t\tcode += \"#extension GL_OES_standard_derivatives : enable\\n\";\n\t\t\t}\n\n\t\t\tif (device.extTextureLod) {\n\t\t\t\tcode += \"#extension GL_EXT_shader_texture_lod : enable\\n\";\n\t\t\t\tcode += \"#define SUPPORTS_TEXLOD\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif (chunks.extensionPS) {\n\t\t\tcode += chunks.extensionPS + \"\\n\";\n\t\t}\n\n\t\tif (device.webgl2) {\n\t\t\tcode += chunks.gles3PS;\n\t\t}\n\n\t\tcode += options.forceFragmentPrecision ? \"precision \" + options.forceFragmentPrecision + \" float;\\n\\n\" : precisionCode(device);\n\t\tcode += this._getPassDefineString(options.pass);\n\n\t\tif (options.pass === SHADER_PICK) {\n\t\t\tcode += \"uniform vec4 uColor;\\n\";\n\t\t\tcode += varyings;\n\n\t\t\tif (options.alphaTest) {\n\t\t\t\tcode += \"float dAlpha;\\n\";\n\t\t\t\tcode += this._addMap(\"opacity\", \"opacityPS\", options, chunks);\n\t\t\t\tcode += chunks.alphaTestPS;\n\t\t\t}\n\n\t\t\tcode += begin();\n\n\t\t\tif (options.alphaTest) {\n\t\t\t\tcode += \"\t getOpacity();\\n\";\n\t\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t\t}\n\n\t\t\tcode += \"\t\tgl_FragColor = uColor;\\n\";\n\t\t\tcode += end();\n\t\t\treturn {\n\t\t\t\tattributes: attributes,\n\t\t\t\tvshader: vshader,\n\t\t\t\tfshader: code\n\t\t\t};\n\t\t} else if (options.pass === SHADER_DEPTH) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += varyings;\n\t\t\tcode += chunks.packDepthPS;\n\n\t\t\tif (options.alphaTest) {\n\t\t\t\tcode += \"float dAlpha;\\n\";\n\t\t\t\tcode += this._addMap(\"opacity\", \"opacityPS\", options, chunks);\n\t\t\t\tcode += chunks.alphaTestPS;\n\t\t\t}\n\n\t\t\tcode += begin();\n\n\t\t\tif (options.alphaTest) {\n\t\t\t\tcode += \"\t getOpacity();\\n\";\n\t\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t\t}\n\n\t\t\tcode += \"\t\tgl_FragColor = packFloat(vDepth);\\n\";\n\t\t\tcode += end();\n\t\t\treturn {\n\t\t\t\tattributes: attributes,\n\t\t\t\tvshader: vshader,\n\t\t\t\tfshader: code\n\t\t\t};\n\t\t} else if (shadowPass) {\n\t\t\treturn {\n\t\t\t\tattributes: attributes,\n\t\t\t\tvshader: vshader,\n\t\t\t\tfshader: this._buildShadowPassFragmentCode(code, device, chunks, options, varyings)\n\t\t\t};\n\t\t}\n\n\t\tif (options.customFragmentShader) {\n\t\t\tfshader = code + options.customFragmentShader;\n\t\t\treturn {\n\t\t\t\tattributes: attributes,\n\t\t\t\tvshader: vshader,\n\t\t\t\tfshader: fshader,\n\t\t\t\ttag: SHADERTAG_MATERIAL\n\t\t\t};\n\t\t}\n\n\t\tcode += varyings;\n\t\tcode = this._fsAddBaseCode(code, device, chunks, options);\n\n\t\tif (options.detailModes) {\n\t\t\tcode += chunks.detailModesPS;\n\t\t}\n\n\t\tconst codeBegin = code;\n\t\tcode = \"\";\n\n\t\tif (options.clearCoat > 0) {\n\t\t\tcode += '#define CLEARCOAT\\n';\n\t\t\tcode += \"#define CLUSTER_CLEAR_COAT\\n\";\n\t\t}\n\n\t\tif (options.opacityFadesSpecular === false) {\n\t\t\tcode += 'uniform float material_alphaFade;\\n';\n\t\t}\n\n\t\tlet numShadowLights = 0;\n\t\tconst shadowTypeUsed = [];\n\t\tlet shadowedDirectionalLightUsed = false;\n\t\tlet useVsm = false;\n\t\tlet usePerspZbufferShadow = false;\n\t\tlet hasAreaLights = options.lights.some(function (light) {\n\t\t\treturn light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;\n\t\t});\n\n\t\tif (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {\n\t\t\thasAreaLights = true;\n\t\t}\n\n\t\tif (device.areaLightLutFormat === PIXELFORMAT_R8_G8_B8_A8) {\n\t\t\tcode += \"#define AREA_R8_G8_B8_A8_LUTS\\n\";\n\t\t\tcode += \"#define AREA_LUTS_PRECISION lowp\\n\";\n\t\t} else {\n\t\t\tcode += \"#define AREA_LUTS_PRECISION highp\\n\";\n\t\t}\n\n\t\tif (hasAreaLights || options.clusteredLightingEnabled) {\n\t\t\tcode += \"#define AREA_LIGHTS\\n\";\n\t\t\tcode += \"uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex1;\\n\";\n\t\t\tcode += \"uniform AREA_LUTS_PRECISION sampler2D areaLightsLutTex2;\\n\";\n\t\t}\n\n\t\tfor (let i = 0; i < options.lights.length; i++) {\n\t\t\tconst light = options.lights[i];\n\t\t\tconst lightType = light._type;\n\t\t\tif (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) continue;\n\t\t\tconst lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;\n\t\t\tcode += \"uniform vec3 light\" + i + \"_color;\\n\";\n\n\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tcode += \"uniform vec3 light\" + i + \"_direction;\\n\";\n\t\t\t} else {\n\t\t\t\tcode += \"uniform vec3 light\" + i + \"_position;\\n\";\n\t\t\t\tcode += \"uniform float light\" + i + \"_radius;\\n\";\n\n\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\tcode += \"uniform vec3 light\" + i + \"_direction;\\n\";\n\t\t\t\t\tcode += \"uniform float light\" + i + \"_innerConeAngle;\\n\";\n\t\t\t\t\tcode += \"uniform float light\" + i + \"_outerConeAngle;\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"uniform vec3 light\" + i + \"_position;\\n\";\n\t\t\t\t}\n\n\t\t\t\tcode += \"uniform vec3 light\" + i + \"_halfWidth;\\n\";\n\t\t\t\tcode += \"uniform vec3 light\" + i + \"_halfHeight;\\n\";\n\t\t\t}\n\n\t\t\tif (light.castShadows && !options.noShadow) {\n\t\t\t\tcode += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"uniform mat4 light\" + i + \"_shadowMatrixPalette[4];\\n\";\n\t\t\t\t\tcode += \"uniform float light\" + i + \"_shadowCascadeDistances[4];\\n\";\n\t\t\t\t\tcode += \"uniform float light\" + i + \"_shadowCascadeCount;\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"uniform vec4 light\" + i + \"_shadowParams;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tshadowedDirectionalLightUsed = true;\n\t\t\t\t\tcode += \"uniform vec3 light\" + i + \"_shadowParams;\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\tcode += \"uniform samplerCube light\" + i + \"_shadowMap;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tif (light._isPcf && device.webgl2) {\n\t\t\t\t\t\tcode += \"uniform sampler2DShadow light\" + i + \"_shadowMap;\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"uniform sampler2D light\" + i + \"_shadowMap;\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnumShadowLights++;\n\t\t\t\tshadowTypeUsed[light._shadowType] = true;\n\t\t\t\tif (light._isVsm) useVsm = true;\n\t\t\t\tif (light._isPcf && (device.webgl2 || device.extStandardDerivatives) && lightType === LIGHTTYPE_SPOT) usePerspZbufferShadow = true;\n\t\t\t}\n\n\t\t\tif (light._cookie) {\n\t\t\t\tif (light._cookie._cubemap) {\n\t\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\t\tcode += \"uniform samplerCube light\" + i + \"_cookie;\\n\";\n\t\t\t\t\t\tcode += \"uniform float light\" + i + \"_cookieIntensity;\\n\";\n\t\t\t\t\t\tif (!light.castShadows || options.noShadow) code += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\tcode += \"uniform sampler2D light\" + i + \"_cookie;\\n\";\n\t\t\t\t\t\tcode += \"uniform float light\" + i + \"_cookieIntensity;\\n\";\n\t\t\t\t\t\tif (!light.castShadows || options.noShadow) code += \"uniform mat4 light\" + i + \"_shadowMatrix;\\n\";\n\n\t\t\t\t\t\tif (light._cookieTransform) {\n\t\t\t\t\t\t\tcode += \"uniform vec4 light\" + i + \"_cookieMatrix;\\n\";\n\t\t\t\t\t\t\tcode += \"uniform vec2 light\" + i + \"_cookieOffset;\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcode += \"\\n\";\n\t\tlet tbn;\n\n\t\tif (!options.hasTangents && device.extStandardDerivatives) {\n\t\t\ttbn = chunks.TBNderivativePS;\n\t\t} else if (options.fastTbn) {\n\t\t\ttbn = chunks.TBNfastPS;\n\t\t} else {\n\t\t\ttbn = chunks.TBNPS;\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tif (options.normalMap || options.clearCoatNormalMap) {\n\t\t\t\tcode += options.packedNormal ? chunks.normalXYPS : chunks.normalXYZPS;\n\n\t\t\t\tif (!options.hasTangents) {\n\t\t\t\t\tconst baseName = options.normalMap ? \"normalMap\" : \"clearCoatNormalMap\";\n\n\t\t\t\t\tconst uv = this._getUvSourceExpression(`${baseName}Transform`, `${baseName}Uv`, options);\n\n\t\t\t\t\ttbn = tbn.replace(/\\$UV/g, uv);\n\t\t\t\t}\n\n\t\t\t\tcode += tbn;\n\t\t\t} else if (options.enableGGXSpecular && !options.heightMap) {\n\t\t\t\tcode += chunks.normalVertexPS;\n\t\t\t\tcode += chunks.TBNObjectSpacePS;\n\t\t\t}\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tif (options.normalMap) {\n\t\t\t\tif (options.normalDetail) {\n\t\t\t\t\tcode += this._addMap(\"normalDetail\", \"normalDetailMapPS\", options, chunks);\n\t\t\t\t}\n\n\t\t\t\tconst transformedNormalMapUv = this._getUvSourceExpression(\"normalMapTransform\", \"normalMapUv\", options);\n\n\t\t\t\tif (options.normalizeNormalMap) {\n\t\t\t\t\tcode += chunks.normalMapPS.replace(/\\$UV/g, transformedNormalMapUv);\n\t\t\t\t} else {\n\t\t\t\t\tcode += chunks.normalMapFastPS.replace(/\\$UV/g, transformedNormalMapUv);\n\t\t\t\t}\n\t\t\t} else if (!(options.enableGGXSpecular && !options.heightMap)) {\n\t\t\t\tcode += chunks.normalVertexPS;\n\t\t\t}\n\t\t}\n\n\t\tcode += gammaCode(options.gamma, chunks);\n\t\tcode += tonemapCode(options.toneMap, chunks);\n\t\tcode += fogCode(options.fog, chunks);\n\t\tcode += chunks.decodePS;\n\t\tif (options.useRgbm) code += chunks.rgbmPS;\n\n\t\tif (options.useCubeMapRotation) {\n\t\t\tcode += \"#define CUBEMAP_ROTATION\\n\";\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tcode += chunks.cubeMapRotatePS;\n\t\t\tcode += options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS;\n\t\t\tcode += options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS;\n\t\t}\n\n\t\tif (options.diffuseDetail) {\n\t\t\tcode += this._addMap(\"diffuseDetail\", \"diffuseDetailMapPS\", options, chunks);\n\t\t}\n\n\t\tcode += this._addMap(\"diffuse\", \"diffusePS\", options, chunks);\n\n\t\tif (options.blendType !== BLEND_NONE || options.alphaTest || options.alphaToCoverage) {\n\t\t\tcode += this._addMap(\"opacity\", \"opacityPS\", options, chunks);\n\t\t}\n\n\t\tcode += this._addMap(\"emissive\", \"emissivePS\", options, chunks, options.emissiveFormat);\n\n\t\tif (lighting && options.useSpecular || reflections) {\n\t\t\tif (options.specularAntialias && options.normalMap) {\n\t\t\t\tif (options.normalizeNormalMap && needsNormal) {\n\t\t\t\t\tcode += chunks.specularAaToksvigPS;\n\t\t\t\t} else {\n\t\t\t\t\tcode += chunks.specularAaToksvigFastPS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcode += chunks.specularAaNonePS;\n\t\t\t}\n\n\t\t\tconst specularPropName = options.useMetalness ? \"metalness\" : \"specular\";\n\t\t\tcode += this._addMap(specularPropName, specularPropName + \"PS\", options, chunks);\n\t\t\tcode += this._addMap(\"gloss\", \"glossPS\", options, chunks);\n\n\t\t\tif (options.fresnelModel === FRESNEL_SCHLICK) {\n\t\t\t\tcode += chunks.fresnelSchlickPS;\n\t\t\t}\n\t\t}\n\n\t\tif (options.clearCoat > 0) {\n\t\t\tcode += this._addMap(\"clearCoat\", \"clearCoatPS\", options, chunks);\n\t\t\tcode += this._addMap(\"clearCoatGloss\", \"clearCoatGlossPS\", options, chunks);\n\t\t\tcode += this._addMap(\"clearCoatNormal\", \"clearCoatNormalPS\", options, chunks);\n\t\t}\n\n\t\tif (options.heightMap) {\n\t\t\tif (!options.normalMap) {\n\t\t\t\tconst transformedHeightMapUv = this._getUvSourceExpression(\"heightMapTransform\", \"heightMapUv\", options);\n\n\t\t\t\tif (!options.hasTangents) tbn = tbn.replace(/\\$UV/g, transformedHeightMapUv);\n\t\t\t\tcode += tbn;\n\t\t\t}\n\n\t\t\tcode += this._addMap(\"height\", \"parallaxPS\", options, chunks);\n\t\t}\n\n\t\tconst useAo = options.aoMap || options.aoVertexColor;\n\n\t\tif (useAo) {\n\t\t\tcode += this._addMap(\"ao\", \"aoPS\", options, chunks);\n\n\t\t\tif (options.occludeSpecular) {\n\t\t\t\tif (options.occludeSpecular === SPECOCC_AO) {\n\t\t\t\t\tcode += options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS;\n\t\t\t\t} else {\n\t\t\t\t\tcode += options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.reflectionSource === 'envAtlas') {\n\t\t\tcode += chunks.reflectionEnvPS.replace(/\\$DECODE/g, this._decodeFunc(options.reflectionEncoding));\n\t\t} else if (options.reflectionSource === 'cubeMap') {\n\t\t\tcode += options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS;\n\t\t\tcode += chunks.reflectionCubePS.replace(/\\$DECODE/g, this._decodeFunc(options.reflectionEncoding));\n\t\t} else if (options.reflectionSource === 'sphereMap') {\n\t\t\tconst scode = device.fragmentUniformsCount > 16 ? chunks.reflectionSpherePS : chunks.reflectionSphereLowPS;\n\t\t\tcode += scode.replace(/\\$DECODE/g, this._decodeFunc(options.reflectionEncoding));\n\t\t}\n\n\t\tif (reflections) {\n\t\t\tif (options.clearCoat > 0) {\n\t\t\t\tcode += chunks.reflectionCCPS;\n\t\t\t}\n\n\t\t\tif (options.refraction) {\n\t\t\t\tcode += chunks.refractionPS;\n\t\t\t}\n\t\t}\n\n\t\tif (options.clusteredLightingEnabled) {\n\t\t\tcode += chunks.clusteredLightUtilsPS;\n\t\t\tcode += chunks.clusteredLightCookiesPS;\n\t\t\tshadowTypeUsed[SHADOW_PCF3] = true;\n\t\t\tshadowTypeUsed[SHADOW_PCF5] = true;\n\t\t\tusePerspZbufferShadow = true;\n\t\t}\n\n\t\tif (numShadowLights > 0 || options.clusteredLightingEnabled) {\n\t\t\tif (shadowedDirectionalLightUsed) {\n\t\t\t\tcode += chunks.shadowCascadesPS;\n\t\t\t}\n\n\t\t\tif (shadowTypeUsed[SHADOW_PCF3]) {\n\t\t\t\tcode += chunks.shadowStandardPS;\n\t\t\t}\n\n\t\t\tif (shadowTypeUsed[SHADOW_PCF5] && device.webgl2) {\n\t\t\t\tcode += chunks.shadowStandardGL2PS;\n\t\t\t}\n\n\t\t\tif (useVsm) {\n\t\t\t\tcode += chunks.shadowVSM_commonPS;\n\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM8]) {\n\t\t\t\t\tcode += chunks.shadowVSM8PS;\n\t\t\t\t}\n\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM16]) {\n\t\t\t\t\tcode += device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\\$/g, \"16\") : chunks.shadowEVSMnPS.replace(/\\$/g, \"16\");\n\t\t\t\t}\n\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM32]) {\n\t\t\t\t\tcode += device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\\$/g, \"32\") : chunks.shadowEVSMnPS.replace(/\\$/g, \"32\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(device.webgl2 || device.extStandardDerivatives)) {\n\t\t\t\tcode += chunks.biasConstPS;\n\t\t\t}\n\n\t\t\tcode += chunks.shadowCoordPS + chunks.shadowCommonPS;\n\t\t\tif (usePerspZbufferShadow) code += chunks.shadowCoordPerspZbufferPS;\n\t\t}\n\n\t\tif (options.enableGGXSpecular) code += \"uniform float material_anisotropy;\\n\";\n\n\t\tif (lighting) {\n\t\t\tcode += chunks.lightDiffuseLambertPS;\n\t\t\tif (hasAreaLights || options.clusteredLightingEnabled) code += chunks.ltc;\n\t\t}\n\n\t\tcode += '\\n';\n\t\tlet useOldAmbient = false;\n\n\t\tif (options.useSpecular) {\n\t\t\tcode += \"#define CLUSTER_SPECULAR\\n\";\n\n\t\t\tif (options.conserveEnergy) {\n\t\t\t\tcode += \"#define CLUSTER_CONSERVE_ENERGY\\n\";\n\t\t\t}\n\n\t\t\tif (lighting) {\n\t\t\t\tcode += options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS;\n\t\t\t}\n\n\t\t\tif (options.fresnelModel > 0) {\n\t\t\t\tif (options.conserveEnergy && !hasAreaLights) {\n\t\t\t\t\tcode += chunks.combineDiffuseSpecularPS;\n\t\t\t\t} else {\n\t\t\t\t\tcode += chunks.combineDiffuseSpecularNoConservePS;\n\t\t\t\t}\n\t\t\t} else if (reflections) {\n\t\t\t\tcode += chunks.combineDiffuseSpecularOldPS;\n\t\t\t} else {\n\t\t\t\tif (options.diffuseMap) {\n\t\t\t\t\tcode += chunks.combineDiffuseSpecularNoReflPS;\n\t\t\t\t} else {\n\t\t\t\t\tcode += chunks.combineDiffuseSpecularNoReflSeparateAmbientPS;\n\t\t\t\t\tuseOldAmbient = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcode += chunks.combineDiffusePS;\n\t\t}\n\n\t\tif (options.clearCoat > 0) {\n\t\t\tcode += chunks.combineClearCoatPS;\n\t\t}\n\n\t\tlet addAmbient = true;\n\n\t\tif (options.lightMap || options.lightVertexColor) {\n\t\t\tconst lightmapChunkPropName = options.dirLightMap && options.useSpecular ? 'lightmapDirPS' : 'lightmapSinglePS';\n\t\t\tcode += this._addMap(\"light\", lightmapChunkPropName, options, chunks, options.lightMapFormat);\n\t\t\taddAmbient = options.lightMapWithoutAmbient;\n\t\t}\n\n\t\tif (addAmbient) {\n\t\t\tif (options.ambientSource === 'ambientSH') {\n\t\t\t\tcode += chunks.ambientSHPS;\n\t\t\t} else if (options.ambientSource === 'envAtlas') {\n\t\t\t\tcode += chunks.ambientEnvPS.replace(/\\$DECODE/g, this._decodeFunc(options.ambientEncoding));\n\t\t\t} else {\n\t\t\t\tcode += chunks.ambientConstantPS;\n\t\t\t}\n\t\t}\n\n\t\tif (options.ambientTint && !useOldAmbient) {\n\t\t\tcode += \"uniform vec3 material_ambient;\\n\";\n\t\t}\n\n\t\tif (options.alphaTest) {\n\t\t\tcode += chunks.alphaTestPS;\n\t\t}\n\n\t\tif (options.msdf) {\n\t\t\tcode += chunks.msdfPS;\n\t\t}\n\n\t\tif (needsNormal) {\n\t\t\tcode += chunks.viewDirPS;\n\n\t\t\tif (options.useSpecular) {\n\t\t\t\tcode += options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS;\n\t\t\t}\n\t\t}\n\n\t\tlet hasPointLights = false;\n\t\tlet usesLinearFalloff = false;\n\t\tlet usesInvSquaredFalloff = false;\n\t\tlet usesSpot = false;\n\t\tlet usesCookie = false;\n\t\tlet usesCookieNow;\n\n\t\tif (options.clusteredLightingEnabled && lighting) {\n\t\t\tusesSpot = true;\n\t\t\thasPointLights = true;\n\t\t\tusesLinearFalloff = true;\n\t\t\tusesCookie = true;\n\t\t\tcode += chunks.floatUnpackingPS;\n\t\t\tif (options.lightMaskDynamic) code += \"\\n#define CLUSTER_MESH_DYNAMIC_LIGHTS\";\n\t\t\tif (options.clusteredLightingCookiesEnabled) code += \"\\n#define CLUSTER_COOKIES\";\n\n\t\t\tif (options.clusteredLightingShadowsEnabled && !options.noShadow) {\n\t\t\t\tcode += \"\\n#define CLUSTER_SHADOWS\";\n\t\t\t\tcode += \"\\n#define CLUSTER_SHADOW_TYPE_\" + shadowTypeToString[options.clusteredLightingShadowType];\n\t\t\t}\n\n\t\t\tif (options.clusteredLightingAreaLightsEnabled) code += \"\\n#define CLUSTER_AREALIGHTS\";\n\t\t\tcode += LightsBuffer.shaderDefines;\n\t\t\tcode += chunks.clusteredLightShadowsPS;\n\t\t\tcode += chunks.clusteredLightPS;\n\t\t}\n\n\t\tif (options.twoSidedLighting) code += \"uniform float twoSidedLightingNegScaleFactor;\\n\";\n\t\tcode = this._fsAddStartCode(code, device, chunks, options);\n\n\t\tif (needsNormal) {\n\t\t\tif (!options.hasTangents && device.extStandardDerivatives && !options.fastTbn) {\n\t\t\t\tif (options.twoSidedLighting) {\n\t\t\t\t\tcode += \"\t dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcode += \"\t dVertexNormalW = normalize(vNormalW);\\n\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (options.twoSidedLighting) {\n\t\t\t\t\tcode += \"\t dVertexNormalW = gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcode += \"\t dVertexNormalW = vNormalW;\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((options.heightMap || options.normalMap) && options.hasTangents) {\n\t\t\t\tif (options.twoSidedLighting) {\n\t\t\t\t\tcode += \"\t dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;\\n\";\n\t\t\t\t\tcode += \"\t dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcode += \"\t dTangentW = vTangentW;\\n\";\n\t\t\t\t\tcode += \"\t dBinormalW = vBinormalW;\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet opacityParallax = false;\n\n\t\tif (options.blendType === BLEND_NONE && !options.alphaTest && !options.alphaToCoverage) {\n\t\t\tcode += \"\t dAlpha = 1.0;\\n\";\n\t\t} else {\n\t\t\tif (options.heightMap && options.opacityMap) {\n\t\t\t\topacityParallax = true;\n\t\t\t} else {\n\t\t\t\tcode += \"\t getOpacity();\\n\";\n\n\t\t\t\tif (options.alphaTest) {\n\t\t\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet getGlossinessCalled = false;\n\n\t\tif (needsNormal) {\n\t\t\tcode += \"\t getViewDir();\\n\";\n\n\t\t\tif (options.heightMap || options.normalMap || options.clearCoatNormalMap || options.enableGGXSpecular) {\n\t\t\t\tcode += \"\t getTBN();\\n\";\n\t\t\t}\n\n\t\t\tif (options.heightMap) {\n\t\t\t\tcode += \"\t getParallax();\\n\";\n\t\t\t}\n\n\t\t\tif (opacityParallax) {\n\t\t\t\tcode += \"\t getOpacity();\\n\";\n\n\t\t\t\tif (options.alphaTest) {\n\t\t\t\t\tcode += \"\t alphaTest(dAlpha);\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcode += \"\t getNormal();\\n\";\n\n\t\t\tif (options.useSpecular) {\n\t\t\t\tif (lighting && options.enableGGXSpecular) {\n\t\t\t\t\tcode += \"\t getGlossiness();\\n\";\n\t\t\t\t\tgetGlossinessCalled = true;\n\t\t\t\t}\n\n\t\t\t\tcode += \"\t getReflDir();\\n\";\n\t\t\t}\n\t\t}\n\n\t\tcode += \"\t getAlbedo();\\n\";\n\n\t\tif (options.clearCoat > 0) {\n\t\t\tcode += \"\t getClearCoat();\\n\";\n\t\t\tcode += \"\t getClearCoatGlossiness();\\n\";\n\t\t\tcode += \"\t getClearCoatNormal();\\n\";\n\t\t}\n\n\t\tif (lighting && options.useSpecular || reflections) {\n\t\t\tcode += \"\t getSpecularity();\\n\";\n\t\t\tif (!getGlossinessCalled) code += \"\t getGlossiness();\\n\";\n\n\t\t\tif (hasAreaLights) {\n\t\t\t\tcode += \"\t #ifdef AREA_LIGHTS\\n\";\n\t\t\t\tcode += \"\t dSpecularityNoFres = dSpecularity;\\n\";\n\t\t\t\tcode += \"\t #ifdef CLEARCOAT\\n\";\n\t\t\t\tcode += \"\t ccSpecularityNoFres = ccSpecularity;\\n\";\n\t\t\t\tcode += \"\t #endif\\n\";\n\t\t\t\tcode += \"\t #endif\\n\";\n\t\t\t}\n\n\t\t\tif (options.fresnelModel > 0) code += \"\t getFresnel();\\n\";\n\t\t}\n\n\t\tif (addAmbient) {\n\t\t\tcode += \"\t addAmbient();\\n\";\n\n\t\t\tif (options.separateAmbient) {\n\t\t\t\tcode += `\n\t\t\t\t\t\t\t\t\t\tvec3 dAmbientLight = dDiffuseLight;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = vec3(0);\n\t\t\t\t\t\t\t\t`;\n\t\t\t}\n\t\t}\n\n\t\tif (options.ambientTint && !useOldAmbient) {\n\t\t\tcode += \"\t dDiffuseLight *= material_ambient;\\n\";\n\t\t}\n\n\t\tif (useAo && !options.occludeDirect) {\n\t\t\tcode += \"\t\tapplyAO();\\n\";\n\t\t}\n\n\t\tif (options.lightMap || options.lightVertexColor) {\n\t\t\tcode += \"\t addLightMap();\\n\";\n\t\t}\n\n\t\tif (lighting || reflections) {\n\t\t\tif (reflections) {\n\t\t\t\tif (options.clearCoat > 0) {\n\t\t\t\t\tcode += \"\t addReflectionCC();\\n\";\n\t\t\t\t}\n\n\t\t\t\tcode += \"\t addReflection();\\n\";\n\t\t\t}\n\n\t\t\tif (hasAreaLights) {\n\t\t\t\tcode += \"\t ccReflection.rgb *= ccSpecularity;\\n\";\n\t\t\t\tcode += \"\t dReflection.rgb *= dSpecularity;\\n\";\n\t\t\t\tcode += \"\t dSpecularLight *= dSpecularity;\\n\";\n\t\t\t\tcode += \"\t float roughness = max((1.0 - dGlossiness) * (1.0 - dGlossiness), 0.001);\\n\";\n\t\t\t\tcode += \"\t calcLTCLightValues();\\n\";\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < options.lights.length; i++) {\n\t\t\t\tconst light = options.lights[i];\n\t\t\t\tconst lightType = light._type;\n\n\t\t\t\tif (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tusesCookieNow = false;\n\t\t\t\tconst lightShape = hasAreaLights && light._shape ? light.shape : LIGHTSHAPE_PUNCTUAL;\n\t\t\t\tconst shapeString = hasAreaLights && light._shape ? this._getLightSourceShapeString(lightShape) : '';\n\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tcode += \"\t calc\" + shapeString + \"LightValues(light\" + i + \"_position, light\" + i + \"_halfWidth, light\" + i + \"_halfHeight);\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"\t dLightDirNormW = light\" + i + \"_direction;\\n\";\n\t\t\t\t\tcode += \"\t dAtten = 1.0;\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tif (light._cookie) {\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {\n\t\t\t\t\t\t\tusesCookie = true;\n\t\t\t\t\t\t\tusesCookieNow = true;\n\t\t\t\t\t\t} else if (lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {\n\t\t\t\t\t\t\tusesCookie = true;\n\t\t\t\t\t\t\tusesCookieNow = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcode += \"\t getLightDirPoint(light\" + i + \"_position);\\n\";\n\t\t\t\t\thasPointLights = true;\n\n\t\t\t\t\tif (usesCookieNow) {\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\t\tcode += \"\t dAtten3 = getCookie2D\" + (light._cookieFalloff ? \"\" : \"Clip\") + (light._cookieTransform ? \"Xform\" : \"\") + \"(light\" + i + \"_cookie, light\" + i + \"_shadowMatrix, light\" + i + \"_cookieIntensity\" + (light._cookieTransform ? \", light\" + i + \"_cookieMatrix, light\" + i + \"_cookieOffset\" : \"\") + \").\" + light._cookieChannel + \";\\n\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode += \"\t dAtten3 = getCookieCube(light\" + i + \"_cookie, light\" + i + \"_shadowMatrix, light\" + i + \"_cookieIntensity).\" + light._cookieChannel + \";\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lightShape === LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\t\tif (light._falloffMode === LIGHTFALLOFF_LINEAR) {\n\t\t\t\t\t\t\tcode += \"\t dAtten = getFalloffLinear(light\" + i + \"_radius);\\n\";\n\t\t\t\t\t\t\tusesLinearFalloff = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode += \"\t dAtten = getFalloffInvSquared(light\" + i + \"_radius);\\n\";\n\t\t\t\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"\t dAtten = getFalloffWindow(light\" + i + \"_radius);\\n\";\n\t\t\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tcode += \"\t if (dAtten > 0.00001) {\\n\";\n\n\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\tif (!(usesCookieNow && !light._cookieFalloff)) {\n\t\t\t\t\t\t\tcode += \"\t\t\t dAtten *= getSpotEffect(light\" + i + \"_direction, light\" + i + \"_innerConeAngle, light\" + i + \"_outerConeAngle);\\n\";\n\t\t\t\t\t\t\tusesSpot = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\t\tcode += \"\t\t\t dAttenD = getLightDiffuse();\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"\t\t\t dAttenD = get\" + shapeString + \"LightDiffuse() * 16.0;\\n\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcode += \"\t\t\t dAtten *= getLightDiffuse();\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (light.castShadows && !options.noShadow) {\n\t\t\t\t\tlet shadowReadMode = null;\n\t\t\t\t\tlet evsmExp;\n\n\t\t\t\t\tif (light._shadowType === SHADOW_VSM8) {\n\t\t\t\t\t\tshadowReadMode = \"VSM8\";\n\t\t\t\t\t\tevsmExp = \"0.0\";\n\t\t\t\t\t} else if (light._shadowType === SHADOW_VSM16) {\n\t\t\t\t\t\tshadowReadMode = \"VSM16\";\n\t\t\t\t\t\tevsmExp = \"5.54\";\n\t\t\t\t\t} else if (light._shadowType === SHADOW_VSM32) {\n\t\t\t\t\t\tshadowReadMode = \"VSM32\";\n\n\t\t\t\t\t\tif (device.textureFloatHighPrecision) {\n\t\t\t\t\t\t\tevsmExp = \"15.0\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tevsmExp = \"5.54\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (light._shadowType === SHADOW_PCF5) {\n\t\t\t\t\t\tshadowReadMode = \"PCF5x5\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshadowReadMode = \"PCF3x3\";\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shadowReadMode !== null) {\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\t\t\tshadowCoordArgs = \"(light\" + i + \"_shadowMap, light\" + i + \"_shadowParams);\\n\";\n\n\t\t\t\t\t\t\tif (light._normalOffsetBias) {\n\t\t\t\t\t\t\t\tcode += \"\t\t\t normalOffsetPointShadow(light\" + i + \"_shadowParams);\\n\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcode += \"\t\t\t dAtten *= getShadowPoint\" + shadowReadMode + shadowCoordArgs;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst shadowMatArg = `light${i}_shadowMatrix`;\n\t\t\t\t\t\t\tconst shadowParamArg = `light${i}_shadowParams`;\n\t\t\t\t\t\t\tcode += this._nonPointShadowMapProjection(device, options.lights[i], shadowMatArg, shadowParamArg, i);\n\t\t\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) shadowReadMode = \"Spot\" + shadowReadMode;\n\t\t\t\t\t\t\tcode += \"\t\t\t dAtten *= getShadow\" + shadowReadMode + \"(light\" + i + \"_shadowMap, light\" + i + \"_shadowParams\" + (light._isVsm ? \", \" + evsmExp : \"\") + \");\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tif (options.conserveEnergy && options.useSpecular) {\n\t\t\t\t\t\tcode += \"\t\t\t dDiffuseLight += mix((dAttenD * dAtten) * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \", vec3(0), dLTCSpecFres);\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"\t\t\t dDiffuseLight += (dAttenD * dAtten) * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasAreaLights && options.conserveEnergy && options.useSpecular) {\n\t\t\t\t\t\tcode += \"\t\t\t dDiffuseLight += mix(dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \", vec3(0), dSpecularity);\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcode += \"\t\t\t dDiffuseLight += dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tif (options.clearCoat > 0) code += \"\t\t\t ccSpecularLight += ccLTCSpecFres * get\" + shapeString + \"LightSpecularCC() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\tif (options.useSpecular) code += \"\t\t\t dSpecularLight += dLTCSpecFres * get\" + shapeString + \"LightSpecular() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tif (hasAreaLights) {\n\t\t\t\t\t\tif (options.clearCoat > 0) code += \"\t\t\t ccSpecularLight += ccSpecularity * getLightSpecularCC() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t\tif (options.useSpecular) code += \"\t\t\t dSpecularLight += dSpecularity * getLightSpecular() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (options.clearCoat > 0) code += \"\t\t\t ccSpecularLight += getLightSpecularCC() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t\tif (options.useSpecular) code += \"\t\t\t dSpecularLight += getLightSpecular() * dAtten * light\" + i + \"_color\" + (usesCookieNow ? \" * dAtten3\" : \"\") + \";\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcode += \"\t }\\n\";\n\t\t\t\t}\n\n\t\t\t\tcode += \"\\n\";\n\t\t\t}\n\n\t\t\tif (options.clusteredLightingEnabled && lighting) {\n\t\t\t\tusesLinearFalloff = true;\n\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\thasPointLights = true;\n\t\t\t\tcode += '\t addClusteredLights();\\n';\n\t\t\t}\n\n\t\t\tif (hasAreaLights) {\n\t\t\t\tif (options.clearCoat > 0) {\n\t\t\t\t\tcode += \"\t ccSpecularity = 1.0;\\n\";\n\t\t\t\t}\n\n\t\t\t\tif (options.useSpecular) {\n\t\t\t\t\tcode += \"\t dSpecularity = vec3(1);\\n\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (reflections && options.refraction) {\n\t\t\t\tcode += \"\t addRefraction();\\n\";\n\t\t\t}\n\t\t}\n\n\t\tcode += \"\\n\";\n\n\t\tif (useAo) {\n\t\t\tif (options.occludeDirect) {\n\t\t\t\tcode += \"\t\tapplyAO();\\n\";\n\t\t\t}\n\n\t\t\tif (options.occludeSpecular) {\n\t\t\t\tcode += \"\t\toccludeSpecular();\\n\";\n\t\t\t}\n\t\t}\n\n\t\tif (options.opacityFadesSpecular === false) {\n\t\t\tif (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {\n\t\t\t\tcode += \"float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a) * dSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\\n\";\n\t\t\t\tcode += \"#ifdef CLEARCOAT\\n specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccReflection.a * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));\\n#endif\\n\";\n\t\t\t\tcode += \"dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);\\n\";\n\t\t\t}\n\n\t\t\tcode += \"dAlpha *= material_alphaFade;\\n\";\n\t\t}\n\n\t\tcode += chunks.endPS;\n\n\t\tif (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {\n\t\t\tcode += chunks.outputAlphaPS;\n\t\t} else if (options.blendType === BLEND_PREMULTIPLIED) {\n\t\t\tcode += chunks.outputAlphaPremulPS;\n\t\t} else {\n\t\t\tcode += chunks.outputAlphaOpaquePS;\n\t\t}\n\n\t\tif (options.msdf) {\n\t\t\tcode += \"\t gl_FragColor = applyMsdf(gl_FragColor);\\n\";\n\t\t}\n\n\t\tcode += \"\\n\";\n\t\tcode += end();\n\n\t\tif (hasPointLights) {\n\t\t\tcode = chunks.lightDirPointPS + code;\n\t\t}\n\n\t\tif (usesLinearFalloff) {\n\t\t\tcode = chunks.falloffLinearPS + code;\n\t\t}\n\n\t\tif (usesInvSquaredFalloff) {\n\t\t\tcode = chunks.falloffInvSquaredPS + code;\n\t\t}\n\n\t\tif (usesSpot) {\n\t\t\tcode = chunks.spotPS + code;\n\t\t}\n\n\t\tif (usesCookie) {\n\t\t\tcode = chunks.cookiePS + code;\n\t\t}\n\n\t\tlet structCode = \"\";\n\t\tif (code.includes(\"dReflection\")) structCode += \"vec4 dReflection;\\n\";\n\t\tif (code.includes(\"dTBN\")) structCode += \"mat3 dTBN;\\n\";\n\t\tif (code.includes(\"dAlbedo\")) structCode += \"vec3 dAlbedo;\\n\";\n\t\tif (code.includes(\"dEmission\")) structCode += \"vec3 dEmission;\\n\";\n\t\tif (code.includes(\"dNormalW\")) structCode += \"vec3 dNormalW;\\n\";\n\t\tif (code.includes(\"dVertexNormalW\")) structCode += \"vec3 dVertexNormalW;\\n\";\n\t\tif (code.includes(\"dTangentW\")) structCode += \"vec3 dTangentW;\\n\";\n\t\tif (code.includes(\"dBinormalW\")) structCode += \"vec3 dBinormalW;\\n\";\n\t\tif (code.includes(\"dViewDirW\")) structCode += \"vec3 dViewDirW;\\n\";\n\t\tif (code.includes(\"dReflDirW\")) structCode += \"vec3 dReflDirW;\\n\";\n\t\tif (code.includes(\"dDiffuseLight\")) structCode += \"vec3 dDiffuseLight;\\n\";\n\t\tif (code.includes(\"dSpecularLight\")) structCode += \"vec3 dSpecularLight;\\n\";\n\t\tif (code.includes(\"dLightDirNormW\")) structCode += \"vec3 dLightDirNormW;\\n\";\n\t\tif (code.includes(\"dLightDirW\")) structCode += \"vec3 dLightDirW;\\n\";\n\t\tif (code.includes(\"dLightPosW\")) structCode += \"vec3 dLightPosW;\\n\";\n\t\tif (code.includes(\"dShadowCoord\")) structCode += \"vec3 dShadowCoord;\\n\";\n\t\tif (code.includes(\"dNormalMap\")) structCode += \"vec3 dNormalMap;\\n\";\n\t\tif (code.includes(\"dSpecularity\")) structCode += \"vec3 dSpecularity;\\n\";\n\t\tif (code.includes(\"dSpecularityNoFres\")) structCode += \"vec3 dSpecularityNoFres;\\n\";\n\t\tif (code.includes(\"dUvOffset\")) structCode += \"vec2 dUvOffset;\\n\";\n\t\tif (code.includes(\"dGlossiness\")) structCode += \"float dGlossiness;\\n\";\n\t\tif (code.includes(\"dAlpha\")) structCode += \"float dAlpha;\\n\";\n\t\tif (code.includes(\"dAtten\")) structCode += \"float dAtten;\\n\";\n\t\tif (code.includes(\"dAttenD\")) structCode += \"float dAttenD;\\n\";\n\t\tif (code.includes(\"dAtten3\")) structCode += \"vec3 dAtten3;\\n\";\n\t\tif (code.includes(\"dAo\")) structCode += \"float dAo;\\n\";\n\t\tif (code.includes(\"dMsdf\")) structCode += \"vec4 dMsdf;\\n\";\n\t\tif (code.includes(\"ccReflection\")) structCode += \"vec4 ccReflection;\\n\";\n\t\tif (code.includes(\"ccNormalW\")) structCode += \"vec3 ccNormalW;\\n\";\n\t\tif (code.includes(\"ccReflDirW\")) structCode += \"vec3 ccReflDirW;\\n\";\n\t\tif (code.includes(\"ccSpecularLight\")) structCode += \"vec3 ccSpecularLight;\\n\";\n\t\tif (code.includes(\"ccSpecularity\")) structCode += \"float ccSpecularity;\\n\";\n\t\tif (code.includes(\"ccSpecularityNoFres\")) structCode += \"float ccSpecularityNoFres;\\n\";\n\t\tif (code.includes(\"ccGlossiness\")) structCode += \"float ccGlossiness;\\n\";\n\t\tcode = codeBegin + structCode + code;\n\t\tfshader = code;\n\t\treturn {\n\t\t\tattributes: attributes,\n\t\t\tvshader: vshader,\n\t\t\tfshader: fshader,\n\t\t\ttag: SHADERTAG_MATERIAL\n\t\t};\n\t}\n};\n\nconst programlib = {\n\tbegin: begin,\n\tdummyFragmentCode: dummyFragmentCode,\n\tend: end,\n\tfogCode: fogCode,\n\tgammaCode: gammaCode,\n\tprecisionCode: precisionCode,\n\tskinCode: skinCode,\n\ttonemapCode: tonemapCode,\n\tversionCode: versionCode,\n\tbasic: basic,\n\tparticle: particle,\n\tskybox: skybox,\n\tstandard: standard\n};\n\nconst _goldenAngle = 2.399963229728653;\nconst random = {\n\tcirclePoint: function (point) {\n\t\tconst r = Math.sqrt(Math.random());\n\t\tconst theta = Math.random() * 2 * Math.PI;\n\t\tpoint.x = r * Math.cos(theta);\n\t\tpoint.y = r * Math.sin(theta);\n\t},\n\tcirclePointDeterministic: function (point, index, numPoints) {\n\t\tconst theta = index * _goldenAngle;\n\t\tconst r = Math.sqrt(index) / Math.sqrt(numPoints);\n\t\tpoint.x = r * Math.cos(theta);\n\t\tpoint.y = r * Math.sin(theta);\n\t},\n\tspherePointDeterministic: function (point, index, numPoints, start = 0, end = 1) {\n\t\tstart = 1 - 2 * start;\n\t\tend = 1 - 2 * end;\n\t\tconst y = math.lerp(start, end, index / numPoints);\n\t\tconst radius = Math.sqrt(1 - y * y);\n\t\tconst theta = _goldenAngle * index;\n\t\tpoint.x = Math.cos(theta) * radius;\n\t\tpoint.y = y;\n\t\tpoint.z = Math.sin(theta) * radius;\n\t},\n\tradicalInverse: function (i) {\n\t\tlet bits = (i << 16 | i >>> 16) >>> 0;\n\t\tbits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;\n\t\tbits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;\n\t\tbits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;\n\t\tbits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;\n\t\treturn bits * 2.3283064365386963e-10;\n\t}\n};\n\nconst getCoding = texture => {\n\tswitch (texture.type) {\n\t\tcase TEXTURETYPE_RGBM:\n\t\t\treturn \"RGBM\";\n\n\t\tcase TEXTURETYPE_RGBE:\n\t\t\treturn \"RGBE\";\n\n\t\tdefault:\n\t\t\tswitch (texture.format) {\n\t\t\t\tcase PIXELFORMAT_RGB16F:\n\t\t\t\tcase PIXELFORMAT_RGB32F:\n\t\t\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\t\t\treturn \"Linear\";\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"Gamma\";\n\t\t\t}\n\n\t}\n};\n\nconst getProjectionName = projection => {\n\tif (projection === TEXTUREPROJECTION_NONE) {\n\t\tprojection = TEXTUREPROJECTION_EQUIRECT;\n\t}\n\n\tswitch (projection) {\n\t\tcase TEXTUREPROJECTION_CUBE:\n\t\t\treturn \"Cubemap\";\n\n\t\tcase TEXTUREPROJECTION_EQUIRECT:\n\t\t\treturn \"Equirect\";\n\n\t\tcase TEXTUREPROJECTION_OCTAHEDRAL:\n\t\t\treturn \"Octahedral\";\n\t}\n};\n\nconst packFloat32ToRGBA8 = (value, array, offset) => {\n\tif (value <= 0) {\n\t\tarray[offset + 0] = 0;\n\t\tarray[offset + 1] = 0;\n\t\tarray[offset + 2] = 0;\n\t\tarray[offset + 3] = 0;\n\t} else if (value >= 1.0) {\n\t\tarray[offset + 0] = 255;\n\t\tarray[offset + 1] = 0;\n\t\tarray[offset + 2] = 0;\n\t\tarray[offset + 3] = 0;\n\t} else {\n\t\tlet encX = 1 * value % 1;\n\t\tlet encY = 255 * value % 1;\n\t\tlet encZ = 65025 * value % 1;\n\t\tconst encW = 16581375.0 * value % 1;\n\t\tencX -= encY / 255;\n\t\tencY -= encZ / 255;\n\t\tencZ -= encW / 255;\n\t\tarray[offset + 0] = Math.min(255, Math.floor(encX * 256));\n\t\tarray[offset + 1] = Math.min(255, Math.floor(encY * 256));\n\t\tarray[offset + 2] = Math.min(255, Math.floor(encZ * 256));\n\t\tarray[offset + 3] = Math.min(255, Math.floor(encW * 256));\n\t}\n};\n\nconst packSamples = samples => {\n\tconst numSamples = samples.length;\n\tconst w = Math.min(numSamples, 512);\n\tconst h = Math.ceil(numSamples / w);\n\tconst data = new Uint8Array(w * h * 4);\n\tlet off = 0;\n\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\tpackFloat32ToRGBA8(samples[i * 4 + 0] * 0.5 + 0.5, data, off + 0);\n\t\tpackFloat32ToRGBA8(samples[i * 4 + 1] * 0.5 + 0.5, data, off + 4);\n\t\tpackFloat32ToRGBA8(samples[i * 4 + 2] * 0.5 + 0.5, data, off + 8);\n\t\tpackFloat32ToRGBA8(samples[i * 4 + 3] / 8, data, off + 12);\n\t\toff += 16;\n\t}\n\n\treturn {\n\t\twidth: w,\n\t\theight: h,\n\t\tdata: data\n\t};\n};\n\nconst hemisphereSamplePhong = (dstVec, x, y, specularPower) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));\n\tconst sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\n\nconst hemisphereSampleLambert = (dstVec, x, y) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.sqrt(1 - x);\n\tconst sinTheta = Math.sqrt(x);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\n\nconst hemisphereSampleGGX = (dstVec, x, y, a) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));\n\tconst sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\n\nconst D_GGX = (NoH, linearRoughness) => {\n\tconst a = NoH * linearRoughness;\n\tconst k = linearRoughness / (1.0 - NoH * NoH + a * a);\n\treturn k * k * (1 / Math.PI);\n};\n\nconst generatePhongSamples = (numSamples, specularPower) => {\n\tconst H = new Vec3();\n\tconst result = [];\n\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\themisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);\n\t\tresult.push(H.x, H.y, H.z, 0);\n\t}\n\n\treturn result;\n};\n\nconst generateLambertSamples = (numSamples, sourceTotalPixels) => {\n\tconst pixelsPerSample = sourceTotalPixels / numSamples;\n\tconst H = new Vec3();\n\tconst result = [];\n\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\themisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));\n\t\tconst pdf = H.z / Math.PI;\n\t\tconst mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);\n\t\tresult.push(H.x, H.y, H.z, mipLevel);\n\t}\n\n\treturn result;\n};\n\nconst requiredSamplesGGX = {\n\t\"16\": {\n\t\t\"2\": 26,\n\t\t\"8\": 20,\n\t\t\"32\": 17,\n\t\t\"128\": 16,\n\t\t\"512\": 16\n\t},\n\t\"32\": {\n\t\t\"2\": 53,\n\t\t\"8\": 40,\n\t\t\"32\": 34,\n\t\t\"128\": 32,\n\t\t\"512\": 32\n\t},\n\t\"128\": {\n\t\t\"2\": 214,\n\t\t\"8\": 163,\n\t\t\"32\": 139,\n\t\t\"128\": 130,\n\t\t\"512\": 128\n\t},\n\t\"1024\": {\n\t\t\"2\": 1722,\n\t\t\"8\": 1310,\n\t\t\"32\": 1114,\n\t\t\"128\": 1041,\n\t\t\"512\": 1025\n\t}\n};\n\nconst getRequiredSamplesGGX = (numSamples, specularPower) => {\n\tconst table = requiredSamplesGGX[numSamples];\n\treturn table && table[specularPower] || numSamples;\n};\n\nconst generateGGXSamples = (numSamples, specularPower, sourceTotalPixels) => {\n\tconst pixelsPerSample = sourceTotalPixels / numSamples;\n\tconst roughness = 1 - Math.log2(specularPower) / 11.0;\n\tconst a = roughness * roughness;\n\tconst H = new Vec3();\n\tconst L = new Vec3();\n\tconst N = new Vec3(0, 0, 1);\n\tconst result = [];\n\tconst requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);\n\n\tfor (let i = 0; i < requiredSamples; ++i) {\n\t\themisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);\n\t\tconst NoH = H.z;\n\t\tL.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);\n\n\t\tif (L.z > 0) {\n\t\t\tconst pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;\n\t\t\tconst mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);\n\t\t\tresult.push(L.x, L.y, L.z, mipLevel);\n\t\t}\n\t}\n\n\twhile (result.length < numSamples * 4) {\n\t\tresult.push(0, 0, 0, 0);\n\t}\n\n\treturn result;\n};\n\nconst createSamplesTex = (device, name, samples) => {\n\tconst packedSamples = packSamples(samples);\n\treturn new Texture(device, {\n\t\tname: name,\n\t\twidth: packedSamples.width,\n\t\theight: packedSamples.height,\n\t\tmipmaps: false,\n\t\tminFilter: FILTER_NEAREST,\n\t\tmagFilter: FILTER_NEAREST,\n\t\tlevels: [packedSamples.data]\n\t});\n};\n\nclass SimpleCache {\n\tconstructor() {\n\t\tthis.map = new Map();\n\t}\n\n\tget(key, missFunc) {\n\t\tif (!this.map.has(key)) {\n\t\t\tconst result = missFunc();\n\t\t\tthis.map.set(key, result);\n\t\t\treturn result;\n\t\t}\n\n\t\treturn this.map.get(key);\n\t}\n\n\tclear() {\n\t\tthis.map.clear();\n\t}\n\n}\n\nclass DeviceCache {\n\tconstructor() {\n\t\tthis.cache = new SimpleCache();\n\t}\n\n\tget(device, key, missFunc) {\n\t\treturn this.cache.get(device, () => {\n\t\t\tconst cache = new SimpleCache();\n\t\t\tdevice.on('destroy', () => {\n\t\t\t\tcache.map.forEach((value, key) => {\n\t\t\t\t\tvalue.destroy();\n\t\t\t\t});\n\t\t\t\tthis.cache.map.delete(device);\n\t\t\t});\n\t\t\treturn cache;\n\t\t}).get(key, missFunc);\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t}\n\n}\n\nconst samplesCache = new SimpleCache();\nconst samplesTexCache = new DeviceCache();\n\nconst generateLambertSamplesTex = (device, numSamples, sourceTotalPixels) => {\n\tconst key = `lambert-samples-${numSamples}-${sourceTotalPixels}`;\n\treturn samplesTexCache.get(device, key, () => {\n\t\treturn createSamplesTex(device, key, samplesCache.get(key, () => {\n\t\t\treturn generateLambertSamples(numSamples, sourceTotalPixels);\n\t\t}));\n\t});\n};\n\nconst generatePhongSamplesTex = (device, numSamples, specularPower) => {\n\tconst key = `phong-samples-${numSamples}-${specularPower}`;\n\treturn samplesTexCache.get(device, key, () => {\n\t\treturn createSamplesTex(device, key, samplesCache.get(key, () => {\n\t\t\treturn generatePhongSamples(numSamples, specularPower);\n\t\t}));\n\t});\n};\n\nconst generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels) => {\n\tconst key = `ggx-samples-${numSamples}-${specularPower}-${sourceTotalPixels}`;\n\treturn samplesTexCache.get(device, key, () => {\n\t\treturn createSamplesTex(device, key, samplesCache.get(key, () => {\n\t\t\treturn generateGGXSamples(numSamples, specularPower, sourceTotalPixels);\n\t\t}));\n\t});\n};\n\nconst vsCode = `\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tvUv0 = (vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw;\n}\n`;\n\nfunction reprojectTexture(source, target, options = {}) {\n\tvar _options;\n\n\tif (source instanceof GraphicsDevice) {\n\t\tsource = arguments[1];\n\t\ttarget = arguments[2];\n\t\toptions = {};\n\n\t\tif (arguments[3] !== undefined) {\n\t\t\toptions.specularPower = arguments[3];\n\t\t}\n\n\t\tif (arguments[4] !== undefined) {\n\t\t\toptions.numSamples = arguments[4];\n\t\t}\n\t}\n\n\tconst funcNames = {\n\t\t'none': 'reproject',\n\t\t'lambert': 'prefilterSamplesUnweighted',\n\t\t'phong': 'prefilterSamplesUnweighted',\n\t\t'ggx': 'prefilterSamples'\n\t};\n\tconst specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;\n\tconst face = options.hasOwnProperty('face') ? options.face : null;\n\tconst distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';\n\tconst processFunc = funcNames[distribution] || 'reproject';\n\tconst decodeFunc = `decode${getCoding(source)}`;\n\tconst encodeFunc = `encode${getCoding(target)}`;\n\tconst sourceFunc = `sample${getProjectionName(source.projection)}`;\n\tconst targetFunc = `getDirection${getProjectionName(target.projection)}`;\n\tconst numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;\n\tconst shaderKey = `${processFunc}_${decodeFunc}_${encodeFunc}_${sourceFunc}_${targetFunc}_${numSamples}`;\n\tconst device = source.device;\n\tlet shader = device.programLib._cache[shaderKey];\n\n\tif (!shader) {\n\t\tconst defines = `#define PROCESS_FUNC ${processFunc}\\n` + `#define DECODE_FUNC ${decodeFunc}\\n` + `#define ENCODE_FUNC ${encodeFunc}\\n` + `#define SOURCE_FUNC ${sourceFunc}\\n` + `#define TARGET_FUNC ${targetFunc}\\n` + `#define NUM_SAMPLES ${numSamples}\\n` + (device.extTextureLod ? `#define SUPPORTS_TEXLOD\\n` : '');\n\t\tlet extensions = '';\n\n\t\tif (!device.webgl2) {\n\t\t\textensions = '#extension GL_OES_standard_derivatives: enable\\n';\n\n\t\t\tif (device.extTextureLod) {\n\t\t\t\textensions += '#extension GL_EXT_shader_texture_lod: enable\\n\\n';\n\t\t\t}\n\t\t}\n\n\t\tshader = createShaderFromCode(device, vsCode, `${defines}\\n${shaderChunks.reprojectPS}`, shaderKey, false, extensions);\n\t}\n\n\tconst constantSource = device.scope.resolve(source.cubemap ? \"sourceCube\" : \"sourceTex\");\n\tconstantSource.setValue(source);\n\tconst constantParams = device.scope.resolve(\"params\");\n\tconst constantParams2 = device.scope.resolve(\"params2\");\n\tconst uvModParam = device.scope.resolve(\"uvMod\");\n\n\tif ((_options = options) != null && _options.seamPixels) {\n\t\tconst p = options.seamPixels;\n\t\tconst w = options.rect ? options.rect.z : target.width;\n\t\tconst h = options.rect ? options.rect.w : target.height;\n\t\tconst innerWidth = w - p * 2;\n\t\tconst innerHeight = h - p * 2;\n\t\tuvModParam.setValue([(innerWidth + p * 2) / innerWidth, (innerHeight + p * 2) / innerHeight, -p / innerWidth, -p / innerHeight]);\n\t} else {\n\t\tuvModParam.setValue([1, 1, 0, 0]);\n\t}\n\n\tconst params = [0, specularPower, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];\n\tconst params2 = [target.width * target.height * (target.cubemap ? 6 : 1), source.width * source.height * (source.cubemap ? 6 : 1)];\n\n\tif (processFunc.startsWith('prefilterSamples')) {\n\t\tconst sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);\n\t\tconst samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);\n\t\tdevice.scope.resolve(\"samplesTex\").setValue(samplesTex);\n\t\tdevice.scope.resolve(\"samplesTexInverseSize\").setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);\n\t}\n\n\tfor (let f = 0; f < (target.cubemap ? 6 : 1); f++) {\n\t\tif (face === null || f === face) {\n\t\t\tvar _options2;\n\n\t\t\tconst renderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: target,\n\t\t\t\tface: f,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tparams[0] = f;\n\t\t\tconstantParams.setValue(params);\n\t\t\tconstantParams2.setValue(params2);\n\t\t\tdrawQuadWithShader(device, renderTarget, shader, (_options2 = options) == null ? void 0 : _options2.rect);\n\t\t\trenderTarget.destroy();\n\t\t}\n\t}\n}\n\nconst fixCubemapSeams = true;\n\nconst calcLevels = (width, height) => {\n\treturn 1 + Math.floor(Math.log2(Math.max(width, height)));\n};\n\nconst supportsFloat16 = device => {\n\treturn device.extTextureHalfFloat && device.textureHalfFloatRenderable;\n};\n\nconst supportsFloat32 = device => {\n\treturn device.extTextureFloat && device.textureFloatRenderable;\n};\n\nconst lightingSourcePixelFormat = device => {\n\treturn supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_R8_G8_B8_A8;\n};\n\nconst lightingPixelFormat = device => {\n\treturn PIXELFORMAT_R8_G8_B8_A8;\n};\n\nconst createCubemap = (device, size, format, mipmaps) => {\n\treturn new Texture(device, {\n\t\tname: `lighting-${size}`,\n\t\tcubemap: true,\n\t\twidth: size,\n\t\theight: size,\n\t\tformat: format,\n\t\ttype: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,\n\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\tfixCubemapSeams: fixCubemapSeams,\n\t\tmipmaps: !!mipmaps\n\t});\n};\n\nclass EnvLighting {\n\tstatic generateSkyboxCubemap(source, size) {\n\t\tconst device = source.device;\n\t\tconst result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_R8_G8_B8_A8, false);\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: 1024\n\t\t});\n\t\treturn result;\n\t}\n\n\tstatic generateLightingSource(source) {\n\t\tconst device = source.device;\n\t\tconst format = lightingSourcePixelFormat(device);\n\t\tconst result = new Texture(device, {\n\t\t\tname: `lighting-source`,\n\t\t\tcubemap: true,\n\t\t\twidth: 128,\n\t\t\theight: 128,\n\t\t\tformat: format,\n\t\t\ttype: format === PIXELFORMAT_R8_G8_B8_A8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tfixCubemapSeams: false,\n\t\t\tmipmaps: true\n\t\t});\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: source.mipmaps ? 1 : 1024\n\t\t});\n\t\treturn result;\n\t}\n\n\tstatic generateAtlas(source, options) {\n\t\tconst device = source.device;\n\t\tconst format = lightingPixelFormat();\n\t\tconst result = (options == null ? void 0 : options.target) || new Texture(device, {\n\t\t\twidth: 512,\n\t\t\theight: 512,\n\t\t\tformat: format,\n\t\t\ttype: TEXTURETYPE_RGBM ,\n\t\t\tprojection: TEXTUREPROJECTION_EQUIRECT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tmipmaps: false\n\t\t});\n\t\tconst rect = new Vec4(0, 0, 512, 256);\n\t\tconst levels = calcLevels(result.width, result.height);\n\n\t\tfor (let i = 0; i < levels; ++i) {\n\t\t\treprojectTexture(source, result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t\trect.x += rect.w;\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\n\t\trect.set(0, 256, 256, 128);\n\n\t\tfor (let i = 1; i < 7; ++i) {\n\t\t\treprojectTexture(source, result, {\n\t\t\t\tnumSamples: (options == null ? void 0 : options.numSamples) || 1024,\n\t\t\t\tdistribution: (options == null ? void 0 : options.distribution) || 'ggx',\n\t\t\t\tspecularPower: Math.max(1, 2048 >> i * 2),\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\n\t\trect.set(128, 256 + 128, 64, 32);\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: (options == null ? void 0 : options.numSamples) || 2048,\n\t\t\tdistribution: 'lambert',\n\t\t\trect: rect,\n\t\t\tseamPixels: 1\n\t\t});\n\t\treturn result;\n\t}\n\n\tstatic generatePrefilteredAtlas(sources, options) {\n\t\tconst device = sources[0].device;\n\t\tconst format = lightingPixelFormat();\n\t\tconst result = (options == null ? void 0 : options.target) || new Texture(device, {\n\t\t\twidth: 512,\n\t\t\theight: 512,\n\t\t\tformat: format,\n\t\t\ttype: TEXTURETYPE_RGBM ,\n\t\t\tprojection: TEXTUREPROJECTION_EQUIRECT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tmipmaps: false\n\t\t});\n\t\tconst rect = new Vec4(0, 0, 512, 256);\n\t\tconst levels = calcLevels(result.width, result.height);\n\n\t\tfor (let i = 0; i < levels; ++i) {\n\t\t\treprojectTexture(sources[0], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t\trect.x += rect.w;\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\n\t\trect.set(0, 256, 256, 128);\n\n\t\tfor (let i = 1; i < sources.length; ++i) {\n\t\t\treprojectTexture(sources[i], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\n\t\trect.set(128, 256 + 128, 64, 32);\n\n\t\tif (options != null && options.legacyAmbient) {\n\t\t\treprojectTexture(sources[5], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t} else {\n\t\t\treprojectTexture(sources[0], result, {\n\t\t\t\tnumSamples: (options == null ? void 0 : options.numSamples) || 2048,\n\t\t\t\tdistribution: 'lambert',\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: 1\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\nclass DefaultMaterial {\n\tstatic get(device) {\n\t\tconst material = this.cache.get(device);\n\t\treturn material;\n\t}\n\n\tstatic add(device, material) {\n\t\tthis.cache.set(device, material);\n\t}\n\n\tstatic remove(device) {\n\t\tthis.cache.delete(device);\n\t}\n\n}\n\nDefaultMaterial.cache = new Map();\n\nlet id$2 = 0;\n\nclass Material {\n\tconstructor() {\n\t\tthis.name = \"Untitled\";\n\t\tthis.id = id$2++;\n\t\tthis._shader = null;\n\t\tthis.variants = {};\n\t\tthis.parameters = {};\n\t\tthis.alphaTest = 0;\n\t\tthis.alphaToCoverage = false;\n\t\tthis.blend = false;\n\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\tthis.blendDst = BLENDMODE_ZERO;\n\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\tthis.separateAlphaBlend = false;\n\t\tthis.blendSrcAlpha = BLENDMODE_ONE;\n\t\tthis.blendDstAlpha = BLENDMODE_ZERO;\n\t\tthis.blendAlphaEquation = BLENDEQUATION_ADD;\n\t\tthis.cull = CULLFACE_BACK;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\t\tthis.stencilFront = null;\n\t\tthis.stencilBack = null;\n\t\tthis.depthBias = 0;\n\t\tthis.slopeDepthBias = 0;\n\t\tthis.redWrite = true;\n\t\tthis.greenWrite = true;\n\t\tthis.blueWrite = true;\n\t\tthis.alphaWrite = true;\n\t\tthis.meshInstances = [];\n\t\tthis._shaderVersion = 0;\n\t\tthis._scene = null;\n\t\tthis._dirtyBlend = false;\n\t\tthis.dirty = true;\n\t}\n\n\tset shader(shader) {\n\t\tthis._shader = shader;\n\t}\n\n\tget shader() {\n\t\treturn this._shader;\n\t}\n\n\tget transparent() {\n\t\treturn this.blend || this.blendSrc !== BLENDMODE_ONE || this.blendDst !== BLENDMODE_ZERO || this.blendEquation !== BLENDEQUATION_ADD;\n\t}\n\n\tset blendType(type) {\n\t\tconst prevBlend = this.blend;\n\n\t\tswitch (type) {\n\t\t\tcase BLEND_NONE:\n\t\t\t\tthis.blend = false;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ZERO;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_NORMAL:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_SRC_ALPHA;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_PREMULTIPLIED:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE_MINUS_SRC_ALPHA;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_ADDITIVE:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_ADDITIVEALPHA:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_SRC_ALPHA;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_MULTIPLICATIVE2X:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_DST_COLOR;\n\t\t\t\tthis.blendDst = BLENDMODE_SRC_COLOR;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_SCREEN:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE_MINUS_DST_COLOR;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_MULTIPLICATIVE:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_DST_COLOR;\n\t\t\t\tthis.blendDst = BLENDMODE_ZERO;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_MIN:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_MIN;\n\t\t\t\tbreak;\n\n\t\t\tcase BLEND_MAX:\n\t\t\t\tthis.blend = true;\n\t\t\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\t\t\tthis.blendDst = BLENDMODE_ONE;\n\t\t\t\tthis.blendEquation = BLENDEQUATION_MAX;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (prevBlend !== this.blend) {\n\t\t\tif (this._scene) {\n\t\t\t\tthis._scene.layers._dirtyBlend = true;\n\t\t\t} else {\n\t\t\t\tthis._dirtyBlend = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._updateMeshInstanceKeys();\n\t}\n\n\tget blendType() {\n\t\tif (!this.transparent) {\n\t\t\treturn BLEND_NONE;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_NORMAL;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_ADDITIVE;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_SRC_ALPHA && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_ADDITIVEALPHA;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_SRC_COLOR && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_MULTIPLICATIVE2X;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE_MINUS_DST_COLOR && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_SCREEN;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MIN) {\n\t\t\treturn BLEND_MIN;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE && this.blendEquation === BLENDEQUATION_MAX) {\n\t\t\treturn BLEND_MAX;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_DST_COLOR && this.blendDst === BLENDMODE_ZERO && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_MULTIPLICATIVE;\n\t\t} else if (this.blend && this.blendSrc === BLENDMODE_ONE && this.blendDst === BLENDMODE_ONE_MINUS_SRC_ALPHA && this.blendEquation === BLENDEQUATION_ADD) {\n\t\t\treturn BLEND_PREMULTIPLIED;\n\t\t}\n\n\t\treturn BLEND_NORMAL;\n\t}\n\n\tcopy(source) {\n\t\tthis.name = source.name;\n\t\tthis.shader = source.shader;\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.blend = source.blend;\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.separateAlphaBlend = source.separateAlphaBlend;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendAlphaEquation = source.blendAlphaEquation;\n\t\tthis.cull = source.cull;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\t\tthis.depthBias = source.depthBias;\n\t\tthis.slopeDepthBias = source.slopeDepthBias;\n\t\tif (source.stencilFront) this.stencilFront = source.stencilFront.clone();\n\n\t\tif (source.stencilBack) {\n\t\t\tif (source.stencilFront === source.stencilBack) {\n\t\t\t\tthis.stencilBack = this.stencilFront;\n\t\t\t} else {\n\t\t\t\tthis.stencilBack = source.stencilBack.clone();\n\t\t\t}\n\t\t}\n\n\t\tthis.redWrite = source.redWrite;\n\t\tthis.greenWrite = source.greenWrite;\n\t\tthis.blueWrite = source.blueWrite;\n\t\tthis.alphaWrite = source.alphaWrite;\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst clone = new this.constructor();\n\t\treturn clone.copy(this);\n\t}\n\n\t_updateMeshInstanceKeys() {\n\t\tconst meshInstances = this.meshInstances;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].updateKey();\n\t\t}\n\t}\n\n\tupdateUniforms(device, scene) {}\n\n\tupdateShader(device, scene, objDefs) {}\n\n\tupdate() {\n\t\tthis.dirty = true;\n\t\tif (this._shader) this._shader.failed = false;\n\t}\n\n\tclearParameters() {\n\t\tthis.parameters = {};\n\t}\n\n\tgetParameters() {\n\t\treturn this.parameters;\n\t}\n\n\tclearVariants() {\n\t\tthis.variants = {};\n\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\n\t\t\tfor (let j = 0; j < meshInstance._shader.length; j++) {\n\t\t\t\tmeshInstance._shader[j] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetParameter(name) {\n\t\treturn this.parameters[name];\n\t}\n\n\tsetParameter(name, data) {\n\t\tif (data === undefined && typeof name === 'object') {\n\t\t\tconst uniformObject = name;\n\n\t\t\tif (uniformObject.length) {\n\t\t\t\tfor (let i = 0; i < uniformObject.length; i++) {\n\t\t\t\t\tthis.setParameter(uniformObject[i]);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tname = uniformObject.name;\n\t\t\tdata = uniformObject.value;\n\t\t}\n\n\t\tconst param = this.parameters[name];\n\n\t\tif (param) {\n\t\t\tparam.data = data;\n\t\t} else {\n\t\t\tthis.parameters[name] = {\n\t\t\t\tscopeId: null,\n\t\t\t\tdata: data\n\t\t\t};\n\t\t}\n\t}\n\n\tdeleteParameter(name) {\n\t\tif (this.parameters[name]) {\n\t\t\tdelete this.parameters[name];\n\t\t}\n\t}\n\n\tsetParameters(device, names) {\n\t\tconst parameters = this.parameters;\n\t\tif (names === undefined) names = parameters;\n\n\t\tfor (const paramName in names) {\n\t\t\tconst parameter = parameters[paramName];\n\n\t\t\tif (parameter) {\n\t\t\t\tif (!parameter.scopeId) {\n\t\t\t\t\tparameter.scopeId = device.scope.resolve(paramName);\n\t\t\t\t}\n\n\t\t\t\tparameter.scopeId.setValue(parameter.data);\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis.variants = {};\n\t\tthis.shader = null;\n\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\n\t\t\tfor (let j = 0; j < meshInstance._shader.length; j++) {\n\t\t\t\tmeshInstance._shader[j] = null;\n\t\t\t}\n\n\t\t\tmeshInstance._material = null;\n\n\t\t\tif (meshInstance.mesh) {\n\t\t\t\tconst defaultMaterial = DefaultMaterial.get(meshInstance.mesh.device);\n\n\t\t\t\tif (this !== defaultMaterial) {\n\t\t\t\t\tmeshInstance.material = defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taddMeshInstanceRef(meshInstance) {\n\t\tthis.meshInstances.push(meshInstance);\n\t}\n\n\tremoveMeshInstanceRef(meshInstance) {\n\t\tconst meshInstances = this.meshInstances;\n\t\tconst i = meshInstances.indexOf(meshInstance);\n\n\t\tif (i !== -1) {\n\t\t\tmeshInstances.splice(i, 1);\n\t\t}\n\t}\n\n}\n\nconst arraysEqual = (a, b) => {\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < a.length; ++i) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\nconst notWhite = color => {\n\treturn color.r !== 1 || color.g !== 1 || color.b !== 1;\n};\n\nconst notBlack = color => {\n\treturn color.r !== 0 || color.g !== 0 || color.b !== 0;\n};\n\nclass StandardMaterialOptionsBuilder {\n\tconstructor() {\n\t\tthis._mapXForms = null;\n\t}\n\n\tupdateMinRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {\n\t\tthis._updateSharedOptions(options, scene, stdMat, objDefs, pass);\n\n\t\tthis._updateMinOptions(options, stdMat);\n\n\t\tthis._updateUVOptions(options, stdMat, objDefs, true);\n\t}\n\n\tupdateRef(options, device, scene, stdMat, objDefs, staticLightList, pass, sortedLights) {\n\t\tthis._updateSharedOptions(options, scene, stdMat, objDefs, pass);\n\n\t\tthis._updateEnvOptions(options, device, stdMat, scene);\n\n\t\tthis._updateMaterialOptions(options, stdMat);\n\n\t\tif (pass === SHADER_FORWARDHDR) {\n\t\t\tif (options.gamma) options.gamma = GAMMA_SRGBHDR;\n\t\t\toptions.toneMap = TONEMAP_LINEAR;\n\t\t}\n\n\t\toptions.hasTangents = objDefs && stdMat.normalMap && (objDefs & SHADERDEF_TANGENTS) !== 0;\n\n\t\tthis._updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList);\n\n\t\tthis._updateUVOptions(options, stdMat, objDefs, false);\n\t}\n\n\t_updateSharedOptions(options, scene, stdMat, objDefs, pass) {\n\t\toptions.pass = pass;\n\t\toptions.alphaTest = stdMat.alphaTest > 0;\n\t\toptions.forceFragmentPrecision = stdMat.forceFragmentPrecision || \"\";\n\t\toptions.chunks = stdMat.chunks || \"\";\n\t\toptions.blendType = stdMat.blendType;\n\t\toptions.forceUv1 = stdMat.forceUv1;\n\t\toptions.separateAmbient = false;\n\t\toptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;\n\t\toptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;\n\t\toptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;\n\t\toptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;\n\t\toptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;\n\t\toptions.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;\n\t\toptions.nineSlicedMode = stdMat.nineSlicedMode || 0;\n\n\t\tif (scene.clusteredLightingEnabled) {\n\t\t\toptions.clusteredLightingEnabled = true;\n\t\t\toptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;\n\t\t\toptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;\n\t\t\toptions.clusteredLightingShadowType = scene.lighting.shadowType;\n\t\t\toptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;\n\t\t}\n\t}\n\n\t_updateUVOptions(options, stdMat, objDefs, minimalOptions) {\n\t\tlet hasUv0 = false;\n\t\tlet hasUv1 = false;\n\t\tlet hasVcolor = false;\n\n\t\tif (objDefs) {\n\t\t\thasUv0 = (objDefs & SHADERDEF_UV0) !== 0;\n\t\t\thasUv1 = (objDefs & SHADERDEF_UV1) !== 0;\n\t\t\thasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;\n\t\t}\n\n\t\toptions.vertexColors = false;\n\t\tthis._mapXForms = [];\n\n\t\tfor (const p in _matTex2D) {\n\t\t\tthis._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions);\n\t\t}\n\n\t\tthis._mapXForms = null;\n\t}\n\n\t_updateMinOptions(options, stdMat) {\n\t\toptions.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE;\n\t\toptions.lights = [];\n\t}\n\n\t_updateMaterialOptions(options, stdMat) {\n\t\tconst diffuseTint = (stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor) && notWhite(stdMat.diffuse);\n\t\tconst useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);\n\t\tconst specularTint = useSpecular && !stdMat.useMetalness && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);\n\t\tconst emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;\n\t\tconst emissiveTintIntensity = stdMat.emissiveIntensity !== 1;\n\t\tconst isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;\n\t\toptions.opacityTint = stdMat.opacity !== 1 && stdMat.blendType !== BLEND_NONE ? 1 : 0;\n\t\toptions.blendMapsWithColors = true;\n\t\toptions.ambientTint = stdMat.ambientTint;\n\t\toptions.diffuseTint = diffuseTint ? 2 : 0;\n\t\toptions.specularTint = specularTint ? 2 : 0;\n\t\toptions.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;\n\t\toptions.glossTint = 1;\n\t\toptions.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);\n\t\toptions.alphaToCoverage = stdMat.alphaToCoverage;\n\t\toptions.normalizeNormalMap = stdMat.normalizeNormalMap;\n\t\toptions.ambientSH = !!stdMat.ambientSH;\n\t\toptions.useSpecular = useSpecular;\n\t\toptions.emissiveFormat = stdMat.emissiveMap ? stdMat.emissiveMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.emissiveMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;\n\t\toptions.lightMapFormat = stdMat.lightMap ? stdMat.lightMap.type === TEXTURETYPE_RGBM ? 1 : stdMat.lightMap.format === PIXELFORMAT_RGBA32F ? 2 : 0 : null;\n\t\toptions.specularAntialias = stdMat.specularAntialias && !!stdMat.normalMap && !!stdMat.normalMap.mipmaps && !isPackedNormalMap;\n\t\toptions.conserveEnergy = stdMat.conserveEnergy;\n\t\toptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;\n\t\toptions.alphaFade = stdMat.alphaFade;\n\t\toptions.occludeSpecular = stdMat.occludeSpecular;\n\t\toptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;\n\t\toptions.occludeDirect = stdMat.occludeDirect;\n\t\toptions.shadingModel = stdMat.shadingModel;\n\t\toptions.fresnelModel = stdMat.fresnelModel;\n\t\toptions.packedNormal = isPackedNormalMap;\n\t\toptions.fastTbn = stdMat.fastTbn;\n\t\toptions.cubeMapProjection = stdMat.cubeMapProjection;\n\t\toptions.customFragmentShader = stdMat.customFragmentShader;\n\t\toptions.refraction = !!stdMat.refraction;\n\t\toptions.useMetalness = stdMat.useMetalness;\n\t\toptions.enableGGXSpecular = stdMat.enableGGXSpecular;\n\t\toptions.msdf = !!stdMat.msdfMap;\n\t\toptions.twoSidedLighting = stdMat.twoSidedLighting;\n\t\toptions.pixelSnap = stdMat.pixelSnap;\n\t\toptions.aoMapUv = stdMat.aoUvSet;\n\t\toptions.diffuseDetail = !!stdMat.diffuseMap;\n\t\toptions.normalDetail = !!stdMat.normalMap;\n\t\toptions.diffuseDetailMode = stdMat.diffuseDetailMode;\n\t\toptions.detailModes = !!options.diffuseDetail;\n\t\toptions.clearCoat = !!stdMat.clearCoat;\n\t\toptions.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;\n\t\toptions.clearCoatGlossiness = !!stdMat.clearCoatGlossiness;\n\t\toptions.clearCoatGlossTint = stdMat.clearCoatGlossiness !== 1.0 ? 1 : 0;\n\t}\n\n\t_updateEnvOptions(options, device, stdMat, scene) {\n\t\toptions.fog = stdMat.useFog ? scene.fog : \"none\";\n\t\toptions.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;\n\t\toptions.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;\n\t\toptions.useRgbm = stdMat.emissiveMap && stdMat.emissiveMap.type === TEXTURETYPE_RGBM || stdMat.lightMap && stdMat.lightMap.type === TEXTURETYPE_RGBM;\n\t\toptions.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;\n\t\toptions.skyboxIntensity = scene.skyboxIntensity !== 1;\n\t\tconst isPhong = stdMat.shadingModel === SPECULAR_PHONG;\n\t\tlet usingSceneEnv = false;\n\n\t\tif (stdMat.envAtlas && !isPhong) {\n\t\t\toptions.reflectionSource = 'envAtlas';\n\t\t\toptions.reflectionEncoding = stdMat.envAtlas.encoding;\n\t\t} else if (stdMat.cubeMap) {\n\t\t\toptions.reflectionSource = 'cubeMap';\n\t\t\toptions.reflectionEncoding = stdMat.cubeMap.encoding;\n\t\t} else if (stdMat.sphereMap) {\n\t\t\toptions.reflectionSource = 'sphereMap';\n\t\t\toptions.reflectionEncoding = stdMat.sphereMap.encoding;\n\t\t} else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {\n\t\t\toptions.reflectionSource = 'envAtlas';\n\t\t\toptions.reflectionEncoding = scene.envAtlas.encoding;\n\t\t\tusingSceneEnv = true;\n\t\t} else {\n\t\t\toptions.reflectionSource = null;\n\t\t\toptions.reflectionEncoding = null;\n\t\t}\n\n\t\tif (stdMat.ambientSH && !isPhong) {\n\t\t\toptions.ambientSource = 'ambientSH';\n\t\t\toptions.ambientEncoding = null;\n\t\t} else {\n\t\t\tconst envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);\n\n\t\t\tif (envAtlas && !isPhong) {\n\t\t\t\toptions.ambientSource = 'envAtlas';\n\t\t\t\toptions.ambientEncoding = envAtlas.encoding;\n\t\t\t} else {\n\t\t\t\toptions.ambientSource = 'constant';\n\t\t\t\toptions.ambientEncoding = null;\n\t\t\t}\n\t\t}\n\n\t\toptions.useCubeMapRotation = usingSceneEnv && scene.skyboxRotation && !scene.skyboxRotation.equals(Quat.IDENTITY);\n\t}\n\n\t_updateLightOptions(options, stdMat, objDefs, sortedLights, staticLightList) {\n\t\toptions.lightMap = false;\n\t\toptions.lightMapChannel = \"\";\n\t\toptions.lightMapUv = 0;\n\t\toptions.lightMapTransform = 0;\n\t\toptions.lightMapWithoutAmbient = false;\n\t\toptions.dirLightMap = false;\n\n\t\tif (objDefs) {\n\t\t\toptions.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;\n\n\t\t\tif ((objDefs & SHADERDEF_LM) !== 0) {\n\t\t\t\toptions.lightMapFormat = 1;\n\t\t\t\toptions.lightMap = true;\n\t\t\t\toptions.lightMapChannel = \"rgb\";\n\t\t\t\toptions.lightMapUv = 1;\n\t\t\t\toptions.lightMapTransform = 0;\n\t\t\t\toptions.lightMapWithoutAmbient = !stdMat.lightMap;\n\t\t\t\toptions.useRgbm = true;\n\n\t\t\t\tif ((objDefs & SHADERDEF_DIRLM) !== 0) {\n\t\t\t\t\toptions.dirLightMap = true;\n\t\t\t\t}\n\n\t\t\t\tif ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {\n\t\t\t\t\toptions.lightMapWithoutAmbient = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (stdMat.useLighting) {\n\t\t\tconst lightsFiltered = [];\n\t\t\tconst mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;\n\t\t\toptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);\n\n\t\t\tif (sortedLights) {\n\t\t\t\tthis._collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);\n\n\t\t\t\tthis._collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask, staticLightList);\n\n\t\t\t\tthis._collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask, staticLightList);\n\t\t\t}\n\n\t\t\toptions.lights = lightsFiltered;\n\t\t} else {\n\t\t\toptions.lights = [];\n\t\t}\n\n\t\tif (options.lights.length === 0) {\n\t\t\toptions.noShadow = true;\n\t\t}\n\t}\n\n\t_updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions) {\n\t\tconst mname = p + \"Map\";\n\t\tconst vname = p + \"VertexColor\";\n\t\tconst vcname = p + \"VertexColorChannel\";\n\t\tconst cname = mname + \"Channel\";\n\t\tconst tname = mname + \"Transform\";\n\t\tconst uname = mname + \"Uv\";\n\n\t\tif (p !== \"light\") {\n\t\t\toptions[mname] = false;\n\t\t\toptions[cname] = \"\";\n\t\t\toptions[tname] = 0;\n\t\t\toptions[uname] = 0;\n\t\t}\n\n\t\toptions[vname] = false;\n\t\toptions[vcname] = \"\";\n\t\tconst isOpacity = p === \"opacity\";\n\t\tif (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage) return options;\n\n\t\tif (!minimalOptions || isOpacity) {\n\t\t\tif (p !== \"height\" && stdMat[vname]) {\n\t\t\t\tif (hasVcolor) {\n\t\t\t\t\toptions[vname] = stdMat[vname];\n\t\t\t\t\toptions[vcname] = stdMat[vcname];\n\t\t\t\t\toptions.vertexColors = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (stdMat[mname]) {\n\t\t\t\tlet allow = true;\n\t\t\t\tif (stdMat[uname] === 0 && !hasUv0) allow = false;\n\t\t\t\tif (stdMat[uname] === 1 && !hasUv1) allow = false;\n\n\t\t\t\tif (allow) {\n\t\t\t\t\toptions[mname] = !!stdMat[mname];\n\t\t\t\t\toptions[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);\n\t\t\t\t\toptions[cname] = stdMat[cname];\n\t\t\t\t\toptions[uname] = stdMat[uname];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_collectLights(lType, lights, lightsFiltered, mask, staticLightList) {\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\n\t\t\tif (light.enabled) {\n\t\t\t\tif (light.mask & mask) {\n\t\t\t\t\tif (lType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\t\tif (light.isStatic) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlightsFiltered.push(light);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (staticLightList) {\n\t\t\tfor (let i = 0; i < staticLightList.length; i++) {\n\t\t\t\tconst light = staticLightList[i];\n\n\t\t\t\tif (light._type === lType) {\n\t\t\t\t\tlightsFiltered.push(light);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_getMapTransformID(xform, uv) {\n\t\tif (!xform) return 0;\n\t\tlet xforms = this._mapXForms[uv];\n\n\t\tif (!xforms) {\n\t\t\txforms = [];\n\t\t\tthis._mapXForms[uv] = xforms;\n\t\t}\n\n\t\tfor (let i = 0; i < xforms.length; i++) {\n\t\t\tif (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn xforms.push(xform);\n\t}\n\n}\n\nconst standardMaterialParameterTypes = {\n\tname: 'string',\n\tchunks: 'chunks',\n\tmappingFormat: 'string',\n\t_engine: 'boolean',\n\tambient: 'rgb',\n\tambientTint: 'boolean',\n\taoVertexColor: 'boolean',\n\taoVertexColorChannel: 'string',\n\taoMap: 'texture',\n\taoMapChannel: 'string',\n\taoMapUv: 'number',\n\taoMapTiling: 'vec2',\n\taoMapOffset: 'vec2',\n\taoMapRotation: 'number',\n\tdiffuse: 'rgb',\n\tdiffuseTint: 'boolean',\n\tdiffuseVertexColor: 'boolean',\n\tdiffuseVertexColorChannel: 'string',\n\tdiffuseMap: 'texture',\n\tdiffuseMapChannel: 'string',\n\tdiffuseMapUv: 'number',\n\tdiffuseMapTiling: 'vec2',\n\tdiffuseMapOffset: 'vec2',\n\tdiffuseMapRotation: 'number',\n\tdiffuseDetailMap: 'texture',\n\tdiffuseDetailMapChannel: 'string',\n\tdiffuseDetailMapUv: 'number',\n\tdiffuseDetailMapTiling: 'vec2',\n\tdiffuseDetailMapOffset: 'vec2',\n\tdiffuseDetailMapRotation: 'number',\n\tdiffuseDetailMode: 'string',\n\tspecular: 'rgb',\n\tspecularTint: 'boolean',\n\tspecularVertexColor: 'boolean',\n\tspecularVertexColorChannel: 'string',\n\tspecularMap: 'texture',\n\tspecularMapChannel: 'string',\n\tspecularMapUv: 'number',\n\tspecularMapTiling: 'vec2',\n\tspecularMapOffset: 'vec2',\n\tspecularMapRotation: 'number',\n\tspecularAntialias: 'boolean',\n\toccludeSpecular: 'enum:occludeSpecular',\n\tuseMetalness: 'boolean',\n\tmetalness: 'number',\n\tenableGGXSpecular: 'boolean',\n\tanisotropy: 'number',\n\tmetalnessTint: 'boolean',\n\tmetalnessVertexColor: 'boolean',\n\tmetalnessVertexColorChannel: 'string',\n\tmetalnessMap: 'texture',\n\tmetalnessMapChannel: 'string',\n\tmetalnessMapUv: 'number',\n\tmetalnessMapTiling: 'vec2',\n\tmetalnessMapOffset: 'vec2',\n\tnetalnessMapRotation: 'number',\n\tconserveEnergy: 'boolean',\n\tshininess: 'number',\n\tglossVertexColor: 'boolean',\n\tglossVertexColorChannel: 'string',\n\tglossMap: 'texture',\n\tglossMapChannel: 'string',\n\tglossMapUv: 'number',\n\tglossMapTiling: 'vec2',\n\tglossMapOffset: 'vec2',\n\tglossMapRotation: 'number',\n\tclearCoat: 'number',\n\tclearCoatVertexColor: 'boolean',\n\tclearCoatVertexColorChannel: 'string',\n\tclearCoatMap: 'texture',\n\tclearCoatMapChannel: 'string',\n\tclearCoatMapUv: 'number',\n\tclearCoatMapTiling: 'vec2',\n\tclearCoatMapOffset: 'vec2',\n\tclearCoatMapRotation: 'number',\n\tclearCoatGlossiness: 'number',\n\tclearCoatGlossVertexColor: 'boolean',\n\tclearCoatGlossVertexColorChannel: 'string',\n\tclearCoatGlossMap: 'texture',\n\tclearCoatGlossMapChannel: 'string',\n\tclearCoatGlossMapUv: 'number',\n\tclearCoatGlossMapTiling: 'vec2',\n\tclearCoatGlossMapOffset: 'vec2',\n\tclearCoatGlossMapRotation: 'number',\n\tclearCoatBumpiness: 'number',\n\tclearCoatNormalMap: 'texture',\n\tclearCoatNormalMapUv: 'number',\n\tclearCoatNormalMapTiling: 'vec2',\n\tclearCoatNormalMapOffset: 'vec2',\n\tclearCoatNormalMapRotation: 'number',\n\tfresnelModel: 'number',\n\temissive: 'rgb',\n\temissiveTint: 'boolean',\n\temissiveVertexColor: 'boolean',\n\temissiveVertexColorChannel: 'string',\n\temissiveMap: 'texture',\n\temissiveMapChannel: 'string',\n\temissiveMapUv: 'number',\n\temissiveMapTiling: 'vec2',\n\temissiveMapOffset: 'vec2',\n\temissiveMapMapRotation: 'number',\n\temissiveIntensity: 'number',\n\tnormalMap: 'texture',\n\tnormalMapTiling: 'vec2',\n\tnormalMapOffset: 'vec2',\n\tnormalMapRotation: 'number',\n\tnormalMapUv: 'number',\n\tbumpiness: 'number',\n\tnormalDetailMap: 'texture',\n\tnormalDetailMapTiling: 'vec2',\n\tnormalDetailMapOffset: 'vec2',\n\tnormalDetailMapRotation: 'number',\n\tnormalDetailMapUv: 'number',\n\tnormalDetailMapBumpiness: 'number',\n\theightMap: 'texture',\n\theightMapChannel: 'string',\n\theightMapUv: 'number',\n\theightMapTiling: 'vec2',\n\theightMapOffset: 'vec2',\n\theightMapRotation: 'number',\n\theightMapFactor: 'number',\n\talphaToCoverage: 'boolean',\n\talphaTest: 'number',\n\talphaFade: 'number',\n\topacity: 'number',\n\topacityVertexColor: 'boolean',\n\topacityVertexColorChannel: 'string',\n\topacityMap: 'texture',\n\topacityMapChannel: 'string',\n\topacityMapUv: 'number',\n\topacityMapTiling: 'vec2',\n\topacityMapOffset: 'vec2',\n\topacityMapRotation: 'number',\n\topacityFadesSpecular: 'boolean',\n\treflectivity: 'number',\n\trefraction: 'number',\n\trefractionIndex: 'number',\n\tsphereMap: 'texture',\n\tcubeMap: 'cubemap',\n\tcubeMapProjection: 'number',\n\tcubeMapProjectionBox: 'boundingbox',\n\tlightVertexColor: 'boolean',\n\tlightVertexColorChannel: 'string',\n\tlightMap: 'texture',\n\tlightMapChannel: 'string',\n\tlightMapUv: 'number',\n\tlightMapTiling: 'vec2',\n\tlightMapOffset: 'vec2',\n\tlightMapRotation: 'number',\n\tdepthTest: 'boolean',\n\tdepthWrite: 'boolean',\n\tdepthBias: 'number',\n\tslopeDepthBias: 'number',\n\tcull: 'enum:cull',\n\tblendType: 'enum:blendType',\n\tshadingModel: 'enum:shadingModel',\n\tuseFog: 'boolean',\n\tuseLighting: 'boolean',\n\tuseSkybox: 'boolean',\n\tuseGammaTonemap: 'boolean',\n\tenvAtlas: 'texture'\n};\nconst standardMaterialTextureParameters = [];\n\nfor (const key in standardMaterialParameterTypes) {\n\tconst type = standardMaterialParameterTypes[key];\n\n\tif (type === 'texture') {\n\t\tstandardMaterialTextureParameters.push(key);\n\t}\n}\n\nconst standardMaterialCubemapParameters = [];\n\nfor (const key in standardMaterialParameterTypes) {\n\tconst type = standardMaterialParameterTypes[key];\n\n\tif (type === 'cubemap') {\n\t\tstandardMaterialCubemapParameters.push(key);\n\t}\n}\n\nconst _props = {};\nconst _uniforms = {};\n\nlet _params = new Set();\n\nclass StandardMaterial extends Material {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._dirtyShader = true;\n\t\tthis._assetReferences = {};\n\t\tthis._activeParams = new Set();\n\t\tthis._activeLightingParams = new Set();\n\t\tthis.shaderOptBuilder = new StandardMaterialOptionsBuilder();\n\t\tthis.reset();\n\t}\n\n\treset() {\n\t\tObject.keys(_props).forEach(name => {\n\t\t\tthis[`_${name}`] = _props[name].value();\n\t\t});\n\t\tthis._chunks = {};\n\t\tthis._uniformCache = {};\n\t}\n\n\tset chunks(value) {\n\t\tthis._dirtyShader = true;\n\t\tthis._chunks = value;\n\t}\n\n\tget chunks() {\n\t\tthis._dirtyShader = true;\n\t\treturn this._chunks;\n\t}\n\n\tcopy(source) {\n\t\tsuper.copy(source);\n\t\tObject.keys(_props).forEach(k => {\n\t\t\tthis[k] = source[k];\n\t\t});\n\n\t\tfor (const p in source._chunks) {\n\t\t\tif (source._chunks.hasOwnProperty(p)) this._chunks[p] = source._chunks[p];\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t_setParameter(name, value) {\n\t\t_params.add(name);\n\n\t\tthis.setParameter(name, value);\n\t}\n\n\t_setParameters(parameters) {\n\t\tparameters.forEach(v => {\n\t\t\tthis._setParameter(v.name, v.value);\n\t\t});\n\t}\n\n\t_processParameters(paramsName) {\n\t\tconst prevParams = this[paramsName];\n\t\tprevParams.forEach(param => {\n\t\t\tif (!_params.has(param)) {\n\t\t\t\tdelete this.parameters[param];\n\t\t\t}\n\t\t});\n\t\tthis[paramsName] = _params;\n\t\t_params = prevParams;\n\n\t\t_params.clear();\n\t}\n\n\t_updateMap(p) {\n\t\tconst mname = p + \"Map\";\n\t\tconst map = this[mname];\n\n\t\tif (map) {\n\t\t\tthis._setParameter(\"texture_\" + mname, map);\n\n\t\t\tconst tname = mname + \"Transform\";\n\t\t\tconst uniform = this.getUniform(tname);\n\n\t\t\tif (uniform) {\n\t\t\t\tthis._setParameters(uniform);\n\t\t\t}\n\t\t}\n\t}\n\n\t_allocUniform(name, allocFunc) {\n\t\tlet uniform = this._uniformCache[name];\n\n\t\tif (!uniform) {\n\t\t\tuniform = allocFunc();\n\t\t\tthis._uniformCache[name] = uniform;\n\t\t}\n\n\t\treturn uniform;\n\t}\n\n\tgetUniform(name, device, scene) {\n\t\treturn _uniforms[name](this, device, scene);\n\t}\n\n\tupdateUniforms(device, scene) {\n\t\tconst getUniform = name => {\n\t\t\treturn this.getUniform(name, device, scene);\n\t\t};\n\n\t\tthis._setParameter('material_ambient', getUniform('ambient'));\n\n\t\tif (!this.diffuseMap || this.diffuseTint) {\n\t\t\tthis._setParameter('material_diffuse', getUniform('diffuse'));\n\t\t}\n\n\t\tif (!this.useMetalness) {\n\t\t\tif (!this.specularMap || this.specularTint) {\n\t\t\t\tthis._setParameter('material_specular', getUniform('specular'));\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this.metalnessMap || this.metalness < 1) {\n\t\t\t\tthis._setParameter('material_metalness', this.metalness);\n\t\t\t}\n\t\t}\n\n\t\tif (this.enableGGXSpecular) {\n\t\t\tthis._setParameter('material_anisotropy', this.anisotropy);\n\t\t}\n\n\t\tif (this.clearCoat > 0) {\n\t\t\tthis._setParameter('material_clearCoat', this.clearCoat);\n\n\t\t\tthis._setParameter('material_clearCoatGlossiness', this.clearCoatGlossiness);\n\n\t\t\tthis._setParameter('material_clearCoatReflectivity', this.clearCoat);\n\n\t\t\tthis._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);\n\t\t}\n\n\t\tthis._setParameter(\"material_shininess\", getUniform('shininess'));\n\n\t\tif (!this.emissiveMap || this.emissiveTint) {\n\t\t\tthis._setParameter('material_emissive', getUniform('emissive'));\n\t\t}\n\n\t\tif (this.emissiveIntensity !== 1) {\n\t\t\tthis._setParameter('material_emissiveIntensity', this.emissiveIntensity);\n\t\t}\n\n\t\tif (this.refraction > 0) {\n\t\t\tthis._setParameter('material_refraction', this.refraction);\n\n\t\t\tthis._setParameter('material_refractionIndex', this.refractionIndex);\n\t\t}\n\n\t\tthis._setParameter('material_opacity', this.opacity);\n\n\t\tif (this.opacityFadesSpecular === false) {\n\t\t\tthis._setParameter('material_alphaFade', this.alphaFade);\n\t\t}\n\n\t\tif (this.occludeSpecular) {\n\t\t\tthis._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);\n\t\t}\n\n\t\tif (this.cubeMapProjection === CUBEPROJ_BOX) {\n\t\t\tthis._setParameter(getUniform(\"cubeMapProjectionBox\"));\n\t\t}\n\n\t\tfor (const p in _matTex2D) {\n\t\t\tthis._updateMap(p);\n\t\t}\n\n\t\tif (this.ambientSH) {\n\t\t\tthis._setParameter('ambientSH[0]', this.ambientSH);\n\t\t}\n\n\t\tif (this.normalMap) {\n\t\t\tthis._setParameter('material_bumpiness', this.bumpiness);\n\t\t}\n\n\t\tif (this.normalMap && this.normalDetailMap) {\n\t\t\tthis._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);\n\t\t}\n\n\t\tif (this.heightMap) {\n\t\t\tthis._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));\n\t\t}\n\n\t\tif (this.cubeMap) {\n\t\t\tthis._setParameter('texture_cubeMap', this.cubeMap);\n\t\t}\n\n\t\tif (this.sphereMap) {\n\t\t\tthis._setParameter('texture_sphereMap', this.sphereMap);\n\t\t}\n\n\t\tthis._setParameter('material_reflectivity', this.reflectivity);\n\n\t\tthis._processParameters('_activeParams');\n\n\t\tif (this._dirtyShader) {\n\t\t\tthis.shader = null;\n\t\t\tthis.clearVariants();\n\t\t}\n\t}\n\n\tupdateEnvUniforms(device, scene) {\n\t\tconst envAtlas = this.envAtlas || (this.useSkybox ? scene.envAtlas : null);\n\n\t\tif (envAtlas) {\n\t\t\tthis._setParameter('texture_envAtlas', envAtlas);\n\n\t\t\tif (this.useSkybox && !scene.skyboxRotation.equals(Quat.IDENTITY) && scene._skyboxRotationMat3) {\n\t\t\t\tthis._setParameter('cubeMapRotationMatrix', scene._skyboxRotationMat3.data);\n\t\t\t}\n\t\t}\n\n\t\tthis._processParameters('_activeLightingParams');\n\t}\n\n\tupdateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {\n\t\tthis.updateEnvUniforms(device, scene);\n\t\tconst minimalOptions = pass > SHADER_FORWARDHDR && pass <= SHADER_PICK;\n\t\tlet options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;\n\t\tif (minimalOptions) this.shaderOptBuilder.updateMinRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);else this.shaderOptBuilder.updateRef(options, device, scene, this, objDefs, staticLightList, pass, sortedLights);\n\n\t\tif (this.onUpdateShader) {\n\t\t\toptions = this.onUpdateShader(options);\n\t\t}\n\n\t\tconst library = device.getProgramLibrary();\n\t\tthis.shader = library.getProgram('standard', options);\n\n\t\tif (!objDefs) {\n\t\t\tthis.clearVariants();\n\t\t\tthis.variants[0] = this.shader;\n\t\t}\n\n\t\tthis._dirtyShader = false;\n\t}\n\n\tdestroy() {\n\t\tfor (const asset in this._assetReferences) {\n\t\t\tthis._assetReferences[asset]._unbind();\n\t\t}\n\n\t\tthis._assetReferences = null;\n\t\tsuper.destroy();\n\t}\n\n}\n\nStandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;\nStandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;\n\nconst defineUniform = (name, getUniformFunc) => {\n\t_uniforms[name] = getUniformFunc;\n};\n\nconst definePropInternal = (name, constructorFunc, setterFunc, getterFunc) => {\n\tObject.defineProperty(StandardMaterial.prototype, name, {\n\t\tget: getterFunc || function () {\n\t\t\treturn this[`_${name}`];\n\t\t},\n\t\tset: setterFunc\n\t});\n\t_props[name] = {\n\t\tvalue: constructorFunc\n\t};\n};\n\nconst defineValueProp = prop => {\n\tconst internalName = `_${prop.name}`;\n\n\tconst dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);\n\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst oldValue = this[internalName];\n\n\t\tif (oldValue !== value) {\n\t\t\tthis._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);\n\t\t\tthis[internalName] = value;\n\t\t}\n\t};\n\n\tdefinePropInternal(prop.name, () => prop.defaultValue, setterFunc, prop.getterFunc);\n};\n\nconst defineAggProp = prop => {\n\tconst internalName = `_${prop.name}`;\n\n\tconst dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);\n\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst oldValue = this[internalName];\n\n\t\tif (!oldValue.equals(value)) {\n\t\t\tthis._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);\n\t\t\tthis[internalName] = oldValue.copy(value);\n\t\t}\n\t};\n\n\tdefinePropInternal(prop.name, () => prop.defaultValue.clone(), setterFunc, prop.getterFunc);\n};\n\nconst defineProp = prop => {\n\treturn prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);\n};\n\nfunction _defineTex2D(name, uv, channels, defChannel, vertexColor, detailMode) {\n\t_matTex2D[name] = channels;\n\tdefineProp({\n\t\tname: `${name}Map`,\n\t\tdefaultValue: null,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);\n\t\t}\n\t});\n\tdefineProp({\n\t\tname: `${name}MapTiling`,\n\t\tdefaultValue: new Vec2(1, 1)\n\t});\n\tdefineProp({\n\t\tname: `${name}MapOffset`,\n\t\tdefaultValue: new Vec2(0, 0)\n\t});\n\tdefineProp({\n\t\tname: `${name}MapRotation`,\n\t\tdefaultValue: 0\n\t});\n\tdefineProp({\n\t\tname: `${name}MapUv`,\n\t\tdefaultValue: uv\n\t});\n\n\tif (channels > 0) {\n\t\tdefineProp({\n\t\t\tname: `${name}MapChannel`,\n\t\t\tdefaultValue: defChannel ? defChannel : channels > 1 ? \"rgb\" : \"g\"\n\t\t});\n\t}\n\n\tif (vertexColor) {\n\t\tdefineProp({\n\t\t\tname: `${name}VertexColor`,\n\t\t\tdefaultValue: false\n\t\t});\n\n\t\tif (channels > 0) {\n\t\t\tdefineProp({\n\t\t\t\tname: `${name}VertexColorChannel`,\n\t\t\t\tdefaultValue: defChannel ? defChannel : channels > 1 ? \"rgb\" : \"g\"\n\t\t\t});\n\t\t}\n\t}\n\n\tif (detailMode) {\n\t\tdefineProp({\n\t\t\tname: `${name}Mode`,\n\t\t\tdefaultValue: DETAILMODE_MUL\n\t\t});\n\t}\n\n\tconst mapTiling = `${name}MapTiling`;\n\tconst mapOffset = `${name}MapOffset`;\n\tconst mapRotation = `${name}MapRotation`;\n\tconst mapTransform = `${name}MapTransform`;\n\tdefineUniform(mapTransform, (material, device, scene) => {\n\t\tconst tiling = material[mapTiling];\n\t\tconst offset = material[mapOffset];\n\t\tconst rotation = material[mapRotation];\n\n\t\tif (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst uniform = material._allocUniform(mapTransform, () => {\n\t\t\treturn [{\n\t\t\t\tname: `texture_${mapTransform}0`,\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}, {\n\t\t\t\tname: `texture_${mapTransform}1`,\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}];\n\t\t});\n\n\t\tconst cr = Math.cos(rotation * math.DEG_TO_RAD);\n\t\tconst sr = Math.sin(rotation * math.DEG_TO_RAD);\n\t\tconst uniform0 = uniform[0].value;\n\t\tuniform0[0] = cr * tiling.x;\n\t\tuniform0[1] = -sr * tiling.y;\n\t\tuniform0[2] = offset.x;\n\t\tconst uniform1 = uniform[1].value;\n\t\tuniform1[0] = sr * tiling.x;\n\t\tuniform1[1] = cr * tiling.y;\n\t\tuniform1[2] = 1.0 - tiling.y - offset.y;\n\t\treturn uniform;\n\t});\n}\n\nfunction _defineColor(name, defaultValue) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue,\n\t\tgetterFunc: function () {\n\t\t\tthis._dirtyShader = true;\n\t\t\treturn this[`_${name}`];\n\t\t}\n\t});\n\tdefineUniform(name, (material, device, scene) => {\n\t\tconst uniform = material._allocUniform(name, () => new Float32Array(3));\n\n\t\tconst color = material[name];\n\t\tconst gamma = material.useGammaTonemap && scene.gammaCorrection;\n\n\t\tif (gamma) {\n\t\t\tuniform[0] = Math.pow(color.r, 2.2);\n\t\t\tuniform[1] = Math.pow(color.g, 2.2);\n\t\t\tuniform[2] = Math.pow(color.b, 2.2);\n\t\t} else {\n\t\t\tuniform[0] = color.r;\n\t\t\tuniform[1] = color.g;\n\t\t\tuniform[2] = color.b;\n\t\t}\n\n\t\treturn uniform;\n\t});\n}\n\nfunction _defineFloat(name, defaultValue, getUniformFunc) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);\n\t\t}\n\t});\n\tdefineUniform(name, getUniformFunc);\n}\n\nfunction _defineObject(name, getUniformFunc) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: null,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn !!oldValue === !!newValue;\n\t\t}\n\t});\n\tdefineUniform(name, getUniformFunc);\n}\n\nfunction _defineFlag(name, defaultValue) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue\n\t});\n}\n\nfunction _defineMaterialProps() {\n\t_defineColor(\"ambient\", new Color(0.7, 0.7, 0.7));\n\n\t_defineColor(\"diffuse\", new Color(1, 1, 1));\n\n\t_defineColor(\"specular\", new Color(0, 0, 0));\n\n\t_defineColor(\"emissive\", new Color(0, 0, 0));\n\n\t_defineFloat(\"emissiveIntensity\", 1);\n\n\t_defineFloat(\"shininess\", 25, (material, device, scene) => {\n\t\treturn material.shadingModel === SPECULAR_PHONG ? Math.pow(2, material.shininess * 0.01 * 11) : material.shininess * 0.01;\n\t});\n\n\t_defineFloat(\"heightMapFactor\", 1, (material, device, scene) => {\n\t\treturn material.heightMapFactor * 0.025;\n\t});\n\n\t_defineFloat(\"opacity\", 1);\n\n\t_defineFloat(\"alphaFade\", 1);\n\n\t_defineFloat(\"alphaTest\", 0);\n\n\t_defineFloat(\"bumpiness\", 1);\n\n\t_defineFloat(\"normalDetailMapBumpiness\", 1);\n\n\t_defineFloat(\"reflectivity\", 1);\n\n\t_defineFloat(\"occludeSpecularIntensity\", 1);\n\n\t_defineFloat(\"refraction\", 0);\n\n\t_defineFloat(\"refractionIndex\", 1.0 / 1.5);\n\n\t_defineFloat(\"metalness\", 1);\n\n\t_defineFloat(\"anisotropy\", 0);\n\n\t_defineFloat(\"clearCoat\", 0);\n\n\t_defineFloat(\"clearCoatGlossiness\", 1);\n\n\t_defineFloat(\"clearCoatBumpiness\", 1);\n\n\t_defineFloat(\"aoUvSet\", 0, null);\n\n\t_defineObject(\"ambientSH\");\n\n\t_defineObject(\"cubeMapProjectionBox\", (material, device, scene) => {\n\t\tconst uniform = material._allocUniform('cubeMapProjectionBox', () => {\n\t\t\treturn [{\n\t\t\t\tname: 'envBoxMin',\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}, {\n\t\t\t\tname: 'envBoxMax',\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}];\n\t\t});\n\n\t\tconst bboxMin = material.cubeMapProjectionBox.getMin();\n\t\tconst minUniform = uniform[0].value;\n\t\tminUniform[0] = bboxMin.x;\n\t\tminUniform[1] = bboxMin.y;\n\t\tminUniform[2] = bboxMin.z;\n\t\tconst bboxMax = material.cubeMapProjectionBox.getMax();\n\t\tconst maxUniform = uniform[1].value;\n\t\tmaxUniform[0] = bboxMax.x;\n\t\tmaxUniform[1] = bboxMax.y;\n\t\tmaxUniform[2] = bboxMax.z;\n\t\treturn uniform;\n\t});\n\n\t_defineFlag(\"ambientTint\", false);\n\n\t_defineFlag(\"diffuseTint\", false);\n\n\t_defineFlag(\"specularTint\", false);\n\n\t_defineFlag(\"emissiveTint\", false);\n\n\t_defineFlag(\"fastTbn\", false);\n\n\t_defineFlag(\"specularAntialias\", false);\n\n\t_defineFlag(\"useMetalness\", false);\n\n\t_defineFlag(\"enableGGXSpecular\", false);\n\n\t_defineFlag(\"occludeDirect\", false);\n\n\t_defineFlag(\"normalizeNormalMap\", true);\n\n\t_defineFlag(\"conserveEnergy\", true);\n\n\t_defineFlag(\"opacityFadesSpecular\", true);\n\n\t_defineFlag(\"occludeSpecular\", SPECOCC_AO);\n\n\t_defineFlag(\"shadingModel\", SPECULAR_BLINN);\n\n\t_defineFlag(\"fresnelModel\", FRESNEL_SCHLICK);\n\n\t_defineFlag(\"cubeMapProjection\", CUBEPROJ_NONE);\n\n\t_defineFlag(\"customFragmentShader\", null);\n\n\t_defineFlag(\"forceFragmentPrecision\", null);\n\n\t_defineFlag(\"useFog\", true);\n\n\t_defineFlag(\"useLighting\", true);\n\n\t_defineFlag(\"useGammaTonemap\", true);\n\n\t_defineFlag(\"useSkybox\", true);\n\n\t_defineFlag(\"forceUv1\", false);\n\n\t_defineFlag(\"pixelSnap\", false);\n\n\t_defineFlag(\"twoSidedLighting\", false);\n\n\t_defineFlag(\"nineSlicedMode\", undefined);\n\n\t_defineTex2D(\"diffuse\", 0, 3, \"\", true);\n\n\t_defineTex2D(\"specular\", 0, 3, \"\", true);\n\n\t_defineTex2D(\"emissive\", 0, 3, \"\", true);\n\n\t_defineTex2D(\"normal\", 0, -1, \"\", false);\n\n\t_defineTex2D(\"metalness\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"gloss\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"opacity\", 0, 1, \"a\", true);\n\n\t_defineTex2D(\"height\", 0, 1, \"\", false);\n\n\t_defineTex2D(\"ao\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"light\", 1, 3, \"\", true);\n\n\t_defineTex2D(\"msdf\", 0, 3, \"\", false);\n\n\t_defineTex2D(\"diffuseDetail\", 0, 3, \"\", false, true);\n\n\t_defineTex2D(\"normalDetail\", 0, -1, \"\", false);\n\n\t_defineTex2D(\"clearCoat\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"clearCoatGloss\", 0, 1, \"\", true);\n\n\t_defineTex2D(\"clearCoatNormal\", 0, -1, \"\", false);\n\n\t_defineObject(\"cubeMap\");\n\n\t_defineObject(\"sphereMap\");\n\n\t_defineObject(\"envAtlas\");\n\n\tconst getterFunc = function getterFunc() {\n\t\treturn this._prefilteredCubemaps;\n\t};\n\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\t\tvalue = value || [];\n\t\tlet changed = false;\n\t\tlet complete = true;\n\n\t\tfor (let i = 0; i < 6; ++i) {\n\t\t\tconst v = value[i] || null;\n\n\t\t\tif (cubemaps[i] !== v) {\n\t\t\t\tcubemaps[i] = v;\n\t\t\t\tchanged = true;\n\t\t\t}\n\n\t\t\tcomplete = complete && !!cubemaps[i];\n\t\t}\n\n\t\tif (changed) {\n\t\t\tif (complete) {\n\t\t\t\tthis.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {\n\t\t\t\t\ttarget: this.envAtlas\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (this.envAtlas) {\n\t\t\t\t\tthis.envAtlas.destroy();\n\t\t\t\t\tthis.envAtlas = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirtyShader = true;\n\t\t}\n\t};\n\n\tconst empty = [null, null, null, null, null, null];\n\tdefinePropInternal(\"prefilteredCubemaps\", () => empty.slice(), setterFunc, getterFunc);\n}\n\n_defineMaterialProps();\n\nclass ProgramLibrary {\n\tconstructor(device) {\n\t\tthis._device = device;\n\t\tthis._cache = {};\n\t\tthis._generators = {};\n\t\tthis._isClearingCache = false;\n\t\tthis._precached = false;\n\t\tthis._programsCollection = [];\n\t\tthis._defaultStdMatOption = {};\n\t\tthis._defaultStdMatOptionMin = {};\n\t\tconst m = new StandardMaterial();\n\t\tm.shaderOptBuilder.updateRef(this._defaultStdMatOption, device, {}, m, null, [], SHADER_FORWARD, null, null);\n\t\tm.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, device, {}, m, null, [], SHADER_SHADOW, null, null);\n\t}\n\n\tregister(name, generator) {\n\t\tif (!this.isRegistered(name)) {\n\t\t\tthis._generators[name] = generator;\n\t\t}\n\t}\n\n\tunregister(name) {\n\t\tif (this.isRegistered(name)) {\n\t\t\tdelete this._generators[name];\n\t\t}\n\t}\n\n\tisRegistered(name) {\n\t\tconst generator = this._generators[name];\n\t\treturn generator !== undefined;\n\t}\n\n\tgetProgram(name, options) {\n\t\tconst generator = this._generators[name];\n\n\t\tif (generator === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst gd = this._device;\n\t\tconst key = generator.generateKey(options);\n\t\tlet shader = this._cache[key];\n\n\t\tif (!shader) {\n\t\t\tlet lights;\n\n\t\t\tif (options.lights) {\n\t\t\t\tlights = options.lights;\n\t\t\t\toptions.lights = lights.map(function (l) {\n\t\t\t\t\tconst lcopy = l.clone ? l.clone() : l;\n\t\t\t\t\tlcopy.key = l.key;\n\t\t\t\t\treturn lcopy;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.storeNewProgram(name, options);\n\t\t\tif (options.lights) options.lights = lights;\n\t\t\tif (this._precached) console.warn(`ProgramLibrary#getProgram: Cache miss for shader ${name} key ${key} after shaders precaching`);\n\t\t\tconst shaderDefinition = generator.createShaderDefinition(gd, options);\n\t\t\tshader = this._cache[key] = new Shader(gd, shaderDefinition);\n\t\t}\n\n\t\treturn shader;\n\t}\n\n\tstoreNewProgram(name, options) {\n\t\tlet opt = {};\n\n\t\tif (name === \"standard\") {\n\t\t\tconst defaultMat = this._getDefaultStdMatOptions(options.pass);\n\n\t\t\tfor (const p in options) {\n\t\t\t\tif (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === \"pass\") opt[p] = options[p];\n\t\t\t}\n\t\t} else {\n\t\t\topt = options;\n\t\t}\n\n\t\tthis._programsCollection.push(JSON.stringify({\n\t\t\tname: name,\n\t\t\toptions: opt\n\t\t}));\n\t}\n\n\tdumpPrograms() {\n\t\tlet text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\\n';\n\t\ttext += 'let shaders = [';\n\t\tif (this._programsCollection[0]) text += '\\n\\t' + this._programsCollection[0];\n\n\t\tfor (let i = 1; i < this._programsCollection.length; ++i) {\n\t\t\ttext += ',\\n\\t' + this._programsCollection[i];\n\t\t}\n\n\t\ttext += '\\n];\\n';\n\t\ttext += 'device.programLib.precompile(shaders);\\n';\n\t\ttext += 'if (pc.version != \\\"' + version + '\\\" || pc.revision != \\\"' + revision + '\\\")\\n';\n\t\ttext += '\\tconsole.warn(\\\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\\\");';\n\t\tconst element = document.createElement('a');\n\t\telement.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n\t\telement.setAttribute('download', 'precompile-shaders.js');\n\t\telement.style.display = 'none';\n\t\tdocument.body.appendChild(element);\n\t\telement.click();\n\t\tdocument.body.removeChild(element);\n\t}\n\n\tclearCache() {\n\t\tconst cache = this._cache;\n\t\tthis._isClearingCache = true;\n\n\t\tfor (const key in cache) {\n\t\t\tif (cache.hasOwnProperty(key)) {\n\t\t\t\tcache[key].destroy();\n\t\t\t}\n\t\t}\n\n\t\tthis._cache = {};\n\t\tthis._isClearingCache = false;\n\t}\n\n\tremoveFromCache(shader) {\n\t\tif (this._isClearingCache) return;\n\t\tconst cache = this._cache;\n\n\t\tfor (const key in cache) {\n\t\t\tif (cache.hasOwnProperty(key)) {\n\t\t\t\tif (cache[key] === shader) {\n\t\t\t\t\tdelete cache[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_getDefaultStdMatOptions(pass) {\n\t\treturn pass > SHADER_FORWARDHDR && pass <= SHADER_PICK ? this._defaultStdMatOptionMin : this._defaultStdMatOption;\n\t}\n\n\tprecompile(cache) {\n\t\tif (cache) {\n\t\t\tconst shaders = new Array(cache.length);\n\n\t\t\tfor (let i = 0; i < cache.length; i++) {\n\t\t\t\tif (cache[i].name === \"standard\") {\n\t\t\t\t\tconst opt = cache[i].options;\n\n\t\t\t\t\tconst defaultMat = this._getDefaultStdMatOptions(opt.pass);\n\n\t\t\t\t\tfor (const p in defaultMat) {\n\t\t\t\t\t\tif (defaultMat.hasOwnProperty(p) && opt[p] === undefined) opt[p] = defaultMat[p];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tshaders[i] = this.getProgram(cache[i].name, cache[i].options);\n\t\t\t}\n\t\t}\n\n\t\tthis._precached = true;\n\t}\n\n}\n\nclass Version {\n\tconstructor() {\n\t\tthis.globalId = 0;\n\t\tthis.revision = 0;\n\t}\n\n\tequals(other) {\n\t\treturn this.globalId === other.globalId && this.revision === other.revision;\n\t}\n\n\tcopy(other) {\n\t\tthis.globalId = other.globalId;\n\t\tthis.revision = other.revision;\n\t}\n\n\treset() {\n\t\tthis.globalId = 0;\n\t\tthis.revision = 0;\n\t}\n\n}\n\nlet idCounter = 0;\n\nclass VersionedObject {\n\tconstructor() {\n\t\tidCounter++;\n\t\tthis.version = new Version();\n\t\tthis.version.globalId = idCounter;\n\t}\n\n\tincrement() {\n\t\tthis.version.revision++;\n\t}\n\n}\n\nclass ScopeId {\n\tconstructor(name) {\n\t\tthis.name = name;\n\t\tthis.value = null;\n\t\tthis.versionObject = new VersionedObject();\n\t}\n\n\tsetValue(value) {\n\t\tthis.value = value;\n\t\tthis.versionObject.increment();\n\t}\n\n\tgetValue() {\n\t\treturn this.value;\n\t}\n\n}\n\nclass ScopeSpace {\n\tconstructor(name) {\n\t\tthis.name = name;\n\t\tthis.variables = new Map();\n\t}\n\n\tresolve(name) {\n\t\tif (!this.variables.has(name)) {\n\t\t\tthis.variables.set(name, new ScopeId(name));\n\t\t}\n\n\t\treturn this.variables.get(name);\n\t}\n\n\tremoveValue(value) {\n\t\tfor (const uniformName in this.variables) {\n\t\t\tconst uniform = this.variables[uniformName];\n\n\t\t\tif (uniform.value === value) {\n\t\t\t\tuniform.value = null;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass ShaderInput {\n\tconstructor(graphicsDevice, name, type, locationId) {\n\t\tthis.locationId = locationId;\n\t\tthis.scopeId = graphicsDevice.scope.resolve(name);\n\t\tthis.version = new Version();\n\n\t\tif (name.substr(name.length - 3) === \"[0]\") {\n\t\t\tswitch (type) {\n\t\t\t\tcase UNIFORMTYPE_FLOAT:\n\t\t\t\t\ttype = UNIFORMTYPE_FLOATARRAY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UNIFORMTYPE_VEC2:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC2ARRAY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UNIFORMTYPE_VEC3:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC3ARRAY;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UNIFORMTYPE_VEC4:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.dataType = type;\n\t\tthis.value = [null, null, null, null];\n\t\tthis.array = [];\n\t}\n\n}\n\nclass GrabPass {\n\tconstructor(device, useAlpha) {\n\t\tthis.device = device;\n\t\tthis.useAlpha = useAlpha;\n\t\tthis.useMipmaps = device.webgl2;\n\t\tthis.texture = null;\n\t\tthis.renderTarget = null;\n\t\tthis.textureId = null;\n\t}\n\n\tdestroy() {\n\t\tthis.textureId = null;\n\n\t\tif (this.renderTarget) {\n\t\t\tthis.renderTarget.destroy();\n\t\t\tthis.renderTarget = null;\n\t\t}\n\n\t\tif (this.texture) {\n\t\t\tthis.texture.destroy();\n\t\t\tthis.texture = null;\n\t\t}\n\t}\n\n\tcreate() {\n\t\tif (!this.texture) {\n\t\t\tconst texture = new Texture(this.device, {\n\t\t\t\tname: 'texture_grabPass',\n\t\t\t\tformat: this.useAlpha ? PIXELFORMAT_R8_G8_B8_A8 : PIXELFORMAT_R8_G8_B8,\n\t\t\t\tminFilter: this.useMipmaps ? FILTER_LINEAR_MIPMAP_LINEAR : FILTER_LINEAR,\n\t\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\tmipmaps: this.useMipmaps\n\t\t\t});\n\t\t\tthis.texture = texture;\n\t\t\tthis.renderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: texture,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tthis.textureId = this.device.scope.resolve(texture.name);\n\t\t\tthis.textureId.setValue(texture);\n\t\t}\n\t}\n\n\tupdate() {\n\t\tconst device = this.device;\n\t\tconst gl = device.gl;\n\n\t\tif (!device.grabPassAvailable) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst renderTarget = device.renderTarget;\n\t\tconst resolveRenderTarget = renderTarget && renderTarget._glResolveFrameBuffer;\n\t\tconst texture = this.texture;\n\t\tconst width = device.width;\n\t\tconst height = device.height;\n\n\t\tif (device.webgl2 && !device._tempMacChromeBlitFramebufferWorkaround && width === texture._width && height === texture._height) {\n\t\t\tif (resolveRenderTarget) {\n\t\t\t\trenderTarget.resolve(true);\n\t\t\t}\n\n\t\t\tconst currentFrameBuffer = renderTarget ? renderTarget._glFrameBuffer : null;\n\t\t\tconst resolvedFrameBuffer = renderTarget ? renderTarget._glResolveFrameBuffer || renderTarget._glFrameBuffer : null;\n\t\t\tdevice.initRenderTarget(this.renderTarget);\n\t\t\tconst grabPassFrameBuffer = this.renderTarget._glFrameBuffer;\n\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, resolvedFrameBuffer);\n\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, grabPassFrameBuffer);\n\t\t\tgl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, currentFrameBuffer);\n\t\t} else {\n\t\t\tif (resolveRenderTarget) {\n\t\t\t\trenderTarget.resolve(true);\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glResolveFrameBuffer);\n\t\t\t}\n\n\t\t\tconst format = texture._glFormat;\n\t\t\tgl.copyTexImage2D(gl.TEXTURE_2D, 0, format, 0, 0, width, height, 0);\n\t\t\ttexture._width = width;\n\t\t\ttexture._height = height;\n\n\t\t\tif (resolveRenderTarget) {\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._glFrameBuffer);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tgenerateMipmaps() {\n\t\tif (this.useMipmaps) {\n\t\t\tthis.device.gl.generateMipmap(this.texture._glTarget);\n\t\t}\n\t}\n\n\tprepareTexture() {\n\t\tconst updated = this.update();\n\n\t\tif (updated) {\n\t\t\tthis.generateMipmaps();\n\t\t}\n\n\t\treturn updated;\n\t}\n\n}\n\nconst EVENT_RESIZE = 'resizecanvas';\n\nfunction downsampleImage(image, size) {\n\tconst srcW = image.width;\n\tconst srcH = image.height;\n\n\tif (srcW > size || srcH > size) {\n\t\tconst scale = size / Math.max(srcW, srcH);\n\t\tconst dstW = Math.floor(srcW * scale);\n\t\tconst dstH = Math.floor(srcH * scale);\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = dstW;\n\t\tcanvas.height = dstH;\n\t\tconst context = canvas.getContext('2d');\n\t\tcontext.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);\n\t\treturn canvas;\n\t}\n\n\treturn image;\n}\n\nfunction testRenderable(gl, pixelFormat) {\n\tlet result = true;\n\tconst texture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);\n\tconst framebuffer = gl.createFramebuffer();\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n\tif (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n\t\tresult = false;\n\t}\n\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\tgl.deleteTexture(texture);\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\tgl.deleteFramebuffer(framebuffer);\n\treturn result;\n}\n\nfunction testTextureHalfFloatUpdatable(gl, pixelFormat) {\n\tlet result = true;\n\tconst texture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\tconst data = new Uint16Array(4 * 2 * 2);\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);\n\n\tif (gl.getError() !== gl.NO_ERROR) {\n\t\tresult = false;\n\t\tconsole.log(\"Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support\");\n\t}\n\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\tgl.deleteTexture(texture);\n\treturn result;\n}\n\nfunction testTextureFloatHighPrecision(device) {\n\tif (!device.textureFloatRenderable) return false;\n\tconst test1 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTestPS, \"ptest1\");\n\tconst test2 = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.precisionTest2PS, \"ptest2\");\n\tconst textureOptions = {\n\t\tformat: PIXELFORMAT_RGBA32F,\n\t\twidth: 1,\n\t\theight: 1,\n\t\tmipmaps: false,\n\t\tminFilter: FILTER_NEAREST,\n\t\tmagFilter: FILTER_NEAREST\n\t};\n\tconst tex1 = new Texture(device, textureOptions);\n\ttex1.name = 'testFHP';\n\tconst targ1 = new RenderTarget({\n\t\tcolorBuffer: tex1,\n\t\tdepth: false\n\t});\n\tdrawQuadWithShader(device, targ1, test1);\n\ttextureOptions.format = PIXELFORMAT_R8_G8_B8_A8;\n\tconst tex2 = new Texture(device, textureOptions);\n\ttex2.name = 'testFHP';\n\tconst targ2 = new RenderTarget({\n\t\tcolorBuffer: tex2,\n\t\tdepth: false\n\t});\n\tdevice.constantTexSource.setValue(tex1);\n\tdrawQuadWithShader(device, targ2, test2);\n\tconst prevFramebuffer = device.activeFramebuffer;\n\tdevice.setFramebuffer(targ2._glFrameBuffer);\n\tconst pixels = new Uint8Array(4);\n\tdevice.readPixels(0, 0, 1, 1, pixels);\n\tdevice.setFramebuffer(prevFramebuffer);\n\tconst x = pixels[0] / 255;\n\tconst y = pixels[1] / 255;\n\tconst z = pixels[2] / 255;\n\tconst w = pixels[3] / 255;\n\tconst f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;\n\ttex1.destroy();\n\ttarg1.destroy();\n\ttex2.destroy();\n\ttarg2.destroy();\n\treturn f === 0;\n}\n\nclass GraphicsDevice extends EventHandler {\n\tconstructor(canvas, options = {}) {\n\t\tsuper();\n\t\tthis.canvas = void 0;\n\t\tthis.gl = void 0;\n\t\tthis.maxAnisotropy = void 0;\n\t\tthis.maxCubeMapSize = void 0;\n\t\tthis.maxTextureSize = void 0;\n\t\tthis.maxVolumeSize = void 0;\n\t\tthis.precision = void 0;\n\t\tthis.scope = void 0;\n\t\tthis.supportsInstancing = void 0;\n\t\tthis.textureFloatRenderable = void 0;\n\t\tthis.textureHalfFloatRenderable = void 0;\n\t\tthis.webgl2 = void 0;\n\t\tthis.canvas = canvas;\n\t\tthis._enableAutoInstancing = false;\n\t\tthis.autoInstancingMaxObjects = 16384;\n\t\tthis.defaultFramebuffer = null;\n\t\tthis._maxPixelRatio = 1;\n\t\tthis._width = 0;\n\t\tthis._height = 0;\n\t\tthis.updateClientRect();\n\t\tthis.shaders = [];\n\t\tthis.buffers = [];\n\t\tthis.textures = [];\n\t\tthis.targets = [];\n\t\tthis.contextLost = false;\n\n\t\tthis._contextLostHandler = event => {\n\t\t\tevent.preventDefault();\n\t\t\tthis.contextLost = true;\n\t\t\tthis.loseContext();\n\t\t\tthis.fire('devicelost');\n\t\t};\n\n\t\tthis._contextRestoredHandler = () => {\n\t\t\tthis.restoreContext();\n\t\t\tthis.contextLost = false;\n\t\t\tthis.fire('devicerestored');\n\t\t};\n\n\t\toptions.stencil = true;\n\n\t\tif (!options.powerPreference) {\n\t\t\toptions.powerPreference = 'high-performance';\n\t\t}\n\n\t\tconst preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;\n\t\tconst names = preferWebGl2 ? [\"webgl2\", \"webgl\", \"experimental-webgl\"] : [\"webgl\", \"experimental-webgl\"];\n\t\tlet gl = null;\n\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tgl = canvas.getContext(names[i], options);\n\n\t\t\tif (gl) {\n\t\t\t\tthis.webgl2 = names[i] === 'webgl2';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!gl) {\n\t\t\tthrow new Error(\"WebGL not supported\");\n\t\t}\n\n\t\tconst isChrome = platform.browser && !!window.chrome;\n\t\tconst isMac = platform.browser && navigator.appVersion.indexOf(\"Mac\") !== -1;\n\t\tthis.gl = gl;\n\t\tthis._tempEnableSafariTextureUnitWorkaround = platform.browser && !!window.safari;\n\t\tthis._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;\n\n\t\tif (!this.webgl2) {\n\t\t\tsetupVertexArrayObject(gl);\n\t\t}\n\n\t\tcanvas.addEventListener(\"webglcontextlost\", this._contextLostHandler, false);\n\t\tcanvas.addEventListener(\"webglcontextrestored\", this._contextRestoredHandler, false);\n\t\tthis.initializeExtensions();\n\t\tthis.initializeCapabilities();\n\t\tthis.initializeRenderState();\n\t\tthis.initializeContextCaches();\n\t\tthis.defaultClearOptions = {\n\t\t\tcolor: [0, 0, 0, 1],\n\t\t\tdepth: 1,\n\t\t\tstencil: 0,\n\t\t\tflags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH\n\t\t};\n\t\tthis.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];\n\t\tthis.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, this.webgl2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, this.webgl2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];\n\t\tthis.glBlendFunction = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA];\n\t\tthis.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];\n\t\tthis.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];\n\t\tthis.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];\n\t\tthis.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];\n\t\tthis.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];\n\t\tthis.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];\n\t\tthis.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT];\n\t\tthis.pcUniformType = {};\n\t\tthis.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;\n\t\tthis.pcUniformType[gl.INT] = UNIFORMTYPE_INT;\n\t\tthis.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;\n\t\tthis.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;\n\t\tthis.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;\n\t\tthis.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;\n\t\tthis.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;\n\t\tthis.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;\n\t\tthis.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;\n\t\tthis.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;\n\t\tthis.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;\n\t\tthis.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;\n\t\tthis.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;\n\t\tthis.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;\n\t\tthis.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;\n\t\tthis.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;\n\t\tthis.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;\n\n\t\tif (this.webgl2) {\n\t\t\tthis.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;\n\t\t\tthis.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;\n\t\t\tthis.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;\n\t\t}\n\n\t\tthis.targetToSlot = {};\n\t\tthis.targetToSlot[gl.TEXTURE_2D] = 0;\n\t\tthis.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;\n\t\tthis.targetToSlot[gl.TEXTURE_3D] = 2;\n\t\tlet scopeX, scopeY, scopeZ, scopeW;\n\t\tlet uniformValue;\n\t\tthis.commitFunction = [];\n\n\t\tthis.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {\n\t\t\tif (uniform.value !== value) {\n\t\t\t\tgl.uniform1i(uniform.locationId, value);\n\t\t\t\tuniform.value = value;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];\n\n\t\tthis.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {\n\t\t\tif (uniform.value !== value) {\n\t\t\t\tgl.uniform1f(uniform.locationId, value);\n\t\t\t\tuniform.value = value;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n\t\t\t\tgl.uniform2fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n\t\t\t\tgl.uniform3fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tscopeW = value[3];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n\t\t\t\tgl.uniform4fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t\tuniformValue[3] = scopeW;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n\t\t\t\tgl.uniform2iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];\n\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n\t\t\t\tgl.uniform3iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];\n\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tscopeW = value[3];\n\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n\t\t\t\tgl.uniform4iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t\tuniformValue[3] = scopeW;\n\t\t\t}\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];\n\n\t\tthis.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {\n\t\t\tgl.uniformMatrix2fv(uniform.locationId, false, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {\n\t\t\tgl.uniformMatrix3fv(uniform.locationId, false, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {\n\t\t\tgl.uniformMatrix4fv(uniform.locationId, false, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {\n\t\t\tgl.uniform1fv(uniform.locationId, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform2fv(uniform.locationId, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform3fv(uniform.locationId, value);\n\t\t};\n\n\t\tthis.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform4fv(uniform.locationId, value);\n\t\t};\n\n\t\tthis.scope = new ScopeSpace(\"Device\");\n\t\tthis.programLib = new ProgramLibrary(this);\n\n\t\tfor (const generator in programlib) this.programLib.register(generator, programlib[generator]);\n\n\t\tthis.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;\n\t\tlet numUniforms = this.vertexUniformsCount;\n\t\tnumUniforms -= 4 * 4;\n\t\tnumUniforms -= 8;\n\t\tnumUniforms -= 1;\n\t\tnumUniforms -= 4 * 4;\n\t\tthis.boneLimit = Math.floor(numUniforms / 3);\n\t\tthis.boneLimit = Math.min(this.boneLimit, 128);\n\n\t\tif (this.unmaskedRenderer === 'Mali-450 MP') {\n\t\t\tthis.boneLimit = 34;\n\t\t}\n\n\t\tthis._drawCallsPerFrame = 0;\n\t\tthis._shaderSwitchesPerFrame = 0;\n\t\tthis._primsPerFrame = [];\n\n\t\tfor (let i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {\n\t\t\tthis._primsPerFrame[i] = 0;\n\t\t}\n\n\t\tthis._renderTargetCreationTime = 0;\n\t\tthis._vram = {\n\t\t\ttex: 0,\n\t\t\tvb: 0,\n\t\t\tib: 0\n\t\t};\n\t\tthis._shaderStats = {\n\t\t\tvsCompiled: 0,\n\t\t\tfsCompiled: 0,\n\t\t\tlinked: 0,\n\t\t\tmaterialShaders: 0,\n\t\t\tcompileTime: 0\n\t\t};\n\t\tthis.constantTexSource = this.scope.resolve(\"source\");\n\n\t\tif (this.extTextureFloat) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tthis.textureFloatRenderable = !!this.extColorBufferFloat;\n\t\t\t} else {\n\t\t\t\tthis.textureFloatRenderable = testRenderable(gl, gl.FLOAT);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.textureFloatRenderable = false;\n\t\t}\n\n\t\tif (this.extColorBufferHalfFloat) {\n\t\t\tthis.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat;\n\t\t} else if (this.extTextureHalfFloat) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tthis.textureHalfFloatRenderable = !!this.extColorBufferFloat;\n\t\t\t} else {\n\t\t\t\tthis.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.textureHalfFloatRenderable = false;\n\t\t}\n\n\t\tthis.supportsMorphTargetTexturesCore = this.maxPrecision === \"highp\" && this.maxVertexTextures >= 2;\n\t\tthis._textureFloatHighPrecision = undefined;\n\t\tthis._textureHalfFloatUpdatable = undefined;\n\t\tthis.grabPassAvailable = true;\n\t\tthis.grabPass = new GrabPass(this, options.alpha);\n\t\tthis.grabPass.create();\n\t\tVertexFormat.init(this);\n\t\tthis.areaLightLutFormat = PIXELFORMAT_R8_G8_B8_A8;\n\n\t\tif (this.extTextureHalfFloat && this.textureHalfFloatUpdatable && this.extTextureHalfFloatLinear) {\n\t\t\tthis.areaLightLutFormat = PIXELFORMAT_RGBA16F;\n\t\t} else if (this.extTextureFloat && this.extTextureFloatLinear) {\n\t\t\tthis.areaLightLutFormat = PIXELFORMAT_RGBA32F;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tconst gl = this.gl;\n\t\tthis.fire('destroy');\n\t\tthis.grabPass.destroy();\n\n\t\tif (this.webgl2 && this.feedback) {\n\t\t\tgl.deleteTransformFeedback(this.feedback);\n\t\t}\n\n\t\tthis.clearShaderCache();\n\t\tthis.clearVertexArrayObjectCache();\n\t\tthis.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);\n\t\tthis.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);\n\t\tthis._contextLostHandler = null;\n\t\tthis._contextRestoredHandler = null;\n\t\tthis.scope = null;\n\t\tthis.canvas = null;\n\t\tthis.gl = null;\n\t}\n\n\ttoJSON(key) {\n\t\treturn undefined;\n\t}\n\n\tgetPrecision() {\n\t\tconst gl = this.gl;\n\t\tlet precision = \"highp\";\n\n\t\tif (gl.getShaderPrecisionFormat) {\n\t\t\tconst vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n\t\t\tconst vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\n\t\t\tconst fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\t\t\tconst fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n\t\t\tconst highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;\n\t\t\tconst mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;\n\n\t\t\tif (!highpAvailable) {\n\t\t\t\tif (mediumpAvailable) {\n\t\t\t\t\tprecision = \"mediump\";\n\t\t\t\t} else {\n\t\t\t\t\tprecision = \"lowp\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn precision;\n\t}\n\n\tinitializeExtensions() {\n\t\tconst gl = this.gl;\n\t\tconst supportedExtensions = gl.getSupportedExtensions();\n\n\t\tconst getExtension = function getExtension() {\n\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\tif (supportedExtensions.indexOf(arguments[i]) !== -1) {\n\t\t\t\t\treturn gl.getExtension(arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tif (this.webgl2) {\n\t\t\tthis.extBlendMinmax = true;\n\t\t\tthis.extDrawBuffers = true;\n\t\t\tthis.extInstancing = true;\n\t\t\tthis.extStandardDerivatives = true;\n\t\t\tthis.extTextureFloat = true;\n\t\t\tthis.extTextureHalfFloat = true;\n\t\t\tthis.extTextureLod = true;\n\t\t\tthis.extUintElement = true;\n\t\t\tthis.extVertexArrayObject = true;\n\t\t\tthis.extColorBufferFloat = getExtension('EXT_color_buffer_float');\n\t\t\tthis.extDisjointTimerQuery = getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');\n\t\t} else {\n\t\t\tthis.extBlendMinmax = getExtension(\"EXT_blend_minmax\");\n\t\t\tthis.extDrawBuffers = getExtension('EXT_draw_buffers');\n\t\t\tthis.extInstancing = getExtension(\"ANGLE_instanced_arrays\");\n\n\t\t\tif (this.extInstancing) {\n\t\t\t\tconst ext = this.extInstancing;\n\t\t\t\tgl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);\n\t\t\t\tgl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);\n\t\t\t\tgl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);\n\t\t\t}\n\n\t\t\tthis.extStandardDerivatives = getExtension(\"OES_standard_derivatives\");\n\t\t\tthis.extTextureFloat = getExtension(\"OES_texture_float\");\n\t\t\tthis.extTextureHalfFloat = getExtension(\"OES_texture_half_float\");\n\t\t\tthis.extTextureLod = getExtension('EXT_shader_texture_lod');\n\t\t\tthis.extUintElement = getExtension(\"OES_element_index_uint\");\n\t\t\tthis.extVertexArrayObject = getExtension(\"OES_vertex_array_object\");\n\n\t\t\tif (this.extVertexArrayObject) {\n\t\t\t\tconst ext = this.extVertexArrayObject;\n\t\t\t\tgl.createVertexArray = ext.createVertexArrayOES.bind(ext);\n\t\t\t\tgl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);\n\t\t\t\tgl.isVertexArray = ext.isVertexArrayOES.bind(ext);\n\t\t\t\tgl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);\n\t\t\t}\n\n\t\t\tthis.extColorBufferFloat = null;\n\t\t\tthis.extDisjointTimerQuery = null;\n\t\t}\n\n\t\tthis.extDebugRendererInfo = getExtension('WEBGL_debug_renderer_info');\n\t\tthis.extTextureFloatLinear = getExtension(\"OES_texture_float_linear\");\n\t\tthis.extTextureHalfFloatLinear = getExtension(\"OES_texture_half_float_linear\");\n\t\tthis.extFloatBlend = getExtension(\"EXT_float_blend\");\n\t\tthis.extTextureFilterAnisotropic = getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');\n\t\tthis.extCompressedTextureETC1 = getExtension('WEBGL_compressed_texture_etc1');\n\t\tthis.extCompressedTextureETC = getExtension('WEBGL_compressed_texture_etc');\n\t\tthis.extCompressedTexturePVRTC = getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');\n\t\tthis.extCompressedTextureS3TC = getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');\n\t\tthis.extCompressedTextureATC = getExtension('WEBGL_compressed_texture_atc');\n\t\tthis.extCompressedTextureASTC = getExtension('WEBGL_compressed_texture_astc');\n\t\tthis.extParallelShaderCompile = getExtension('KHR_parallel_shader_compile');\n\t\tthis.extColorBufferHalfFloat = getExtension(\"EXT_color_buffer_half_float\");\n\t\tthis.supportsInstancing = !!this.extInstancing;\n\t}\n\n\tinitializeCapabilities() {\n\t\tconst gl = this.gl;\n\t\tlet ext;\n\t\tthis.maxPrecision = this.precision = this.getPrecision();\n\t\tconst contextAttribs = gl.getContextAttributes();\n\t\tthis.supportsMsaa = contextAttribs.antialias;\n\t\tthis.supportsStencil = contextAttribs.stencil;\n\t\tthis.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\t\tthis.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n\t\tthis.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n\t\tthis.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\t\tthis.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n\t\tthis.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n\t\tthis.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n\t\tthis.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\n\t\tif (this.webgl2) {\n\t\t\tthis.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);\n\t\t\tthis.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);\n\t\t\tthis.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);\n\t\t} else {\n\t\t\text = this.extDrawBuffers;\n\t\t\tthis.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_EXT) : 1;\n\t\t\tthis.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_EXT) : 1;\n\t\t\tthis.maxVolumeSize = 1;\n\t\t}\n\n\t\text = this.extDebugRendererInfo;\n\t\tthis.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';\n\t\tthis.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';\n\t\text = this.extTextureFilterAnisotropic;\n\t\tthis.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;\n\t\tthis.samples = gl.getParameter(gl.SAMPLES);\n\t\tthis.maxSamples = this.webgl2 ? gl.getParameter(gl.MAX_SAMPLES) : 1;\n\t\tthis.supportsAreaLights = this.webgl2 || !platform.android;\n\n\t\tif (this.maxTextures <= 8) {\n\t\t\tthis.supportsAreaLights = false;\n\t\t}\n\t}\n\n\tinitializeRenderState() {\n\t\tconst gl = this.gl;\n\t\tthis.blending = false;\n\t\tgl.disable(gl.BLEND);\n\t\tthis.blendSrc = BLENDMODE_ONE;\n\t\tthis.blendDst = BLENDMODE_ZERO;\n\t\tthis.blendSrcAlpha = BLENDMODE_ONE;\n\t\tthis.blendDstAlpha = BLENDMODE_ZERO;\n\t\tthis.separateAlphaBlend = false;\n\t\tthis.blendEquation = BLENDEQUATION_ADD;\n\t\tthis.blendAlphaEquation = BLENDEQUATION_ADD;\n\t\tthis.separateAlphaEquation = false;\n\t\tgl.blendFunc(gl.ONE, gl.ZERO);\n\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\tthis.writeRed = true;\n\t\tthis.writeGreen = true;\n\t\tthis.writeBlue = true;\n\t\tthis.writeAlpha = true;\n\t\tgl.colorMask(true, true, true, true);\n\t\tthis.cullMode = CULLFACE_BACK;\n\t\tgl.enable(gl.CULL_FACE);\n\t\tgl.cullFace(gl.BACK);\n\t\tthis.depthTest = true;\n\t\tgl.enable(gl.DEPTH_TEST);\n\t\tthis.depthFunc = FUNC_LESSEQUAL;\n\t\tgl.depthFunc(gl.LEQUAL);\n\t\tthis.depthWrite = true;\n\t\tgl.depthMask(true);\n\t\tthis.stencil = false;\n\t\tgl.disable(gl.STENCIL_TEST);\n\t\tthis.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;\n\t\tthis.stencilRefFront = this.stencilRefBack = 0;\n\t\tthis.stencilMaskFront = this.stencilMaskBack = 0xFF;\n\t\tgl.stencilFunc(gl.ALWAYS, 0, 0xFF);\n\t\tthis.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;\n\t\tthis.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;\n\t\tthis.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;\n\t\tthis.stencilWriteMaskFront = 0xFF;\n\t\tthis.stencilWriteMaskBack = 0xFF;\n\t\tgl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\t\tgl.stencilMask(0xFF);\n\t\tthis.alphaToCoverage = false;\n\t\tthis.raster = true;\n\n\t\tif (this.webgl2) {\n\t\t\tgl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t\tgl.disable(gl.RASTERIZER_DISCARD);\n\t\t}\n\n\t\tthis.depthBiasEnabled = false;\n\t\tgl.disable(gl.POLYGON_OFFSET_FILL);\n\t\tthis.clearDepth = 1;\n\t\tgl.clearDepth(1);\n\t\tthis.clearRed = 0;\n\t\tthis.clearBlue = 0;\n\t\tthis.clearGreen = 0;\n\t\tthis.clearAlpha = 0;\n\t\tgl.clearColor(0, 0, 0, 0);\n\t\tthis.clearStencil = 0;\n\t\tgl.clearStencil(0);\n\t\tthis.vx = this.vy = this.vw = this.vh = 0;\n\t\tthis.sx = this.sy = this.sw = this.sh = 0;\n\n\t\tif (this.webgl2) {\n\t\t\tgl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);\n\t\t} else {\n\t\t\tif (this.extStandardDerivatives) {\n\t\t\t\tgl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);\n\t\t\t}\n\t\t}\n\n\t\tgl.enable(gl.SCISSOR_TEST);\n\t\tgl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n\t\tthis.unpackFlipY = false;\n\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\t\tthis.unpackPremultiplyAlpha = false;\n\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\t\tgl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\t}\n\n\tinitializeContextCaches() {\n\t\tthis.vertexShaderCache = {};\n\t\tthis.fragmentShaderCache = {};\n\t\tthis._vaoMap = new Map();\n\t\tthis.boundVao = null;\n\t\tthis.indexBuffer = null;\n\t\tthis.vertexBuffers = [];\n\t\tthis.shader = null;\n\t\tthis.renderTarget = null;\n\t\tthis.activeFramebuffer = null;\n\t\tthis.feedback = null;\n\t\tthis.transformFeedbackBuffer = null;\n\t\tthis.textureUnit = 0;\n\t\tthis.textureUnits = [];\n\n\t\tfor (let i = 0; i < this.maxCombinedTextures; i++) {\n\t\t\tthis.textureUnits.push([null, null, null]);\n\t\t}\n\t}\n\n\tloseContext() {\n\t\tfor (const shader of this.shaders) {\n\t\t\tshader.loseContext();\n\t\t}\n\n\t\tthis.grabPass.destroy();\n\n\t\twhile (this.textures.length > 0) {\n\t\t\tconst texture = this.textures[0];\n\t\t\tthis.destroyTexture(texture);\n\t\t\ttexture.dirtyAll();\n\t\t}\n\n\t\tfor (const buffer of this.buffers) {\n\t\t\tbuffer.loseContext();\n\t\t}\n\n\t\tfor (const target of this.targets) {\n\t\t\ttarget.loseContext();\n\t\t}\n\t}\n\n\trestoreContext() {\n\t\tthis.initializeExtensions();\n\t\tthis.initializeCapabilities();\n\t\tthis.initializeRenderState();\n\t\tthis.initializeContextCaches();\n\n\t\tfor (const shader of this.shaders) {\n\t\t\tthis.compileAndLinkShader(shader);\n\t\t}\n\n\t\tfor (const buffer of this.buffers) {\n\t\t\tbuffer.unlock();\n\t\t}\n\n\t\tthis.grabPass.create();\n\t}\n\n\tupdateClientRect() {\n\t\tthis.clientRect = this.canvas.getBoundingClientRect();\n\t}\n\n\tsetViewport(x, y, w, h) {\n\t\tif (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {\n\t\t\tthis.gl.viewport(x, y, w, h);\n\t\t\tthis.vx = x;\n\t\t\tthis.vy = y;\n\t\t\tthis.vw = w;\n\t\t\tthis.vh = h;\n\t\t}\n\t}\n\n\tsetScissor(x, y, w, h) {\n\t\tif (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {\n\t\t\tthis.gl.scissor(x, y, w, h);\n\t\t\tthis.sx = x;\n\t\t\tthis.sy = y;\n\t\t\tthis.sw = w;\n\t\t\tthis.sh = h;\n\t\t}\n\t}\n\n\tgetProgramLibrary() {\n\t\treturn this.programLib;\n\t}\n\n\tsetProgramLibrary(programLib) {\n\t\tthis.programLib = programLib;\n\t}\n\n\tsetFramebuffer(fb) {\n\t\tif (this.activeFramebuffer !== fb) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\t\t\tthis.activeFramebuffer = fb;\n\t\t}\n\t}\n\n\t_checkFbo() {\n\t\tconst gl = this.gl;\n\t\tconst status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n\t\tswitch (status) {\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n\t\t\t\tconsole.error(\"ERROR: FRAMEBUFFER_INCOMPLETE_ATTACHMENT\");\n\t\t\t\tbreak;\n\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n\t\t\t\tconsole.error(\"ERROR: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n\t\t\t\tbreak;\n\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n\t\t\t\tconsole.error(\"ERROR: FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n\t\t\t\tbreak;\n\n\t\t\tcase gl.FRAMEBUFFER_UNSUPPORTED:\n\t\t\t\tconsole.error(\"ERROR: FRAMEBUFFER_UNSUPPORTED\");\n\t\t\t\tbreak;\n\n\t\t\tcase gl.FRAMEBUFFER_COMPLETE:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tcopyRenderTarget(source, dest, color, depth) {\n\t\tconst gl = this.gl;\n\n\t\tif (!this.webgl2 && depth) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (color) {\n\t\t\tif (!dest) {\n\t\t\t\tif (!source._colorBuffer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!source._colorBuffer || !dest._colorBuffer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (source._colorBuffer._format !== dest._colorBuffer._format) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (depth) {\n\t\t\tif (!source._depthBuffer || !dest._depthBuffer) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (source._depthBuffer._format !== dest._depthBuffer._format) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.webgl2 && dest) {\n\t\t\tconst prevRt = this.renderTarget;\n\t\t\tthis.renderTarget = dest;\n\t\t\tthis.updateBegin();\n\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, source ? source._glFrameBuffer : null);\n\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dest._glFrameBuffer);\n\t\t\tconst w = source ? source.width : dest.width;\n\t\t\tconst h = source ? source.height : dest.height;\n\t\t\tgl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);\n\t\t\tthis.renderTarget = prevRt;\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt._glFrameBuffer : null);\n\t\t} else {\n\t\t\tconst shader = this.getCopyShader();\n\t\t\tthis.constantTexSource.setValue(source._colorBuffer);\n\t\t\tdrawQuadWithShader(this, dest, shader);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tinitRenderTarget(target) {\n\t\tif (target._glFrameBuffer) return;\n\t\tconst gl = this.gl;\n\t\ttarget._glFrameBuffer = gl.createFramebuffer();\n\t\tthis.setFramebuffer(target._glFrameBuffer);\n\t\tconst colorBuffer = target._colorBuffer;\n\n\t\tif (colorBuffer) {\n\t\t\tif (!colorBuffer._glTexture) {\n\t\t\t\tcolorBuffer._width = Math.min(colorBuffer.width, this.maxRenderBufferSize);\n\t\t\t\tcolorBuffer._height = Math.min(colorBuffer.height, this.maxRenderBufferSize);\n\t\t\t\tthis.setTexture(colorBuffer, 0);\n\t\t\t}\n\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer._glTexture, 0);\n\t\t}\n\n\t\tconst depthBuffer = target._depthBuffer;\n\n\t\tif (depthBuffer && this.webgl2) {\n\t\t\tif (!depthBuffer._glTexture) {\n\t\t\t\tdepthBuffer._width = Math.min(depthBuffer.width, this.maxRenderBufferSize);\n\t\t\t\tdepthBuffer._height = Math.min(depthBuffer.height, this.maxRenderBufferSize);\n\t\t\t\tthis.setTexture(depthBuffer, 0);\n\t\t\t}\n\n\t\t\tif (target._stencil) {\n\t\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTexture, 0);\n\t\t\t} else {\n\t\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer._glTexture, 0);\n\t\t\t}\n\t\t} else if (target._depth) {\n\t\t\tconst willRenderMsaa = target._samples > 1 && this.webgl2;\n\n\t\t\tif (!willRenderMsaa) {\n\t\t\t\tif (!target._glDepthBuffer) {\n\t\t\t\t\ttarget._glDepthBuffer = gl.createRenderbuffer();\n\t\t\t\t}\n\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, target._glDepthBuffer);\n\n\t\t\t\tif (target._stencil) {\n\t\t\t\t\tgl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tgl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glDepthBuffer);\n\t\t\t\t}\n\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, null);\n\t\t\t}\n\t\t}\n\n\t\tif (this.webgl2 && target._samples > 1) {\n\t\t\ttarget._glResolveFrameBuffer = target._glFrameBuffer;\n\t\t\ttarget._glFrameBuffer = gl.createFramebuffer();\n\t\t\tthis.setFramebuffer(target._glFrameBuffer);\n\n\t\t\tif (colorBuffer) {\n\t\t\t\tif (!target._glMsaaColorBuffer) {\n\t\t\t\t\ttarget._glMsaaColorBuffer = gl.createRenderbuffer();\n\t\t\t\t}\n\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaColorBuffer);\n\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer._glInternalFormat, target.width, target.height);\n\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, target._glMsaaColorBuffer);\n\t\t\t}\n\n\t\t\tif (target._depth) {\n\t\t\t\tif (!target._glMsaaDepthBuffer) {\n\t\t\t\t\ttarget._glMsaaDepthBuffer = gl.createRenderbuffer();\n\t\t\t\t}\n\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, target._glMsaaDepthBuffer);\n\n\t\t\t\tif (target._stencil) {\n\t\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, target._glMsaaDepthBuffer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.targets.push(target);\n\t}\n\n\tgetCopyShader() {\n\t\tif (!this._copyShader) {\n\t\t\tconst vs = shaderChunks.fullscreenQuadVS;\n\t\t\tconst fs = shaderChunks.outputTex2DPS;\n\t\t\tthis._copyShader = createShaderFromCode(this, vs, fs, \"outputTex2D\");\n\t\t}\n\n\t\treturn this._copyShader;\n\t}\n\n\tupdateBegin() {\n\t\tthis.boundVao = null;\n\n\t\tif (this._tempEnableSafariTextureUnitWorkaround) {\n\t\t\tfor (let unit = 0; unit < this.textureUnits.length; ++unit) {\n\t\t\t\tfor (let slot = 0; slot < 3; ++slot) {\n\t\t\t\t\tthis.textureUnits[unit][slot] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst target = this.renderTarget;\n\n\t\tif (target) {\n\t\t\tif (!target._glFrameBuffer) {\n\t\t\t\tthis.initRenderTarget(target);\n\t\t\t} else {\n\t\t\t\tthis.setFramebuffer(target._glFrameBuffer);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.setFramebuffer(this.defaultFramebuffer);\n\t\t}\n\t}\n\n\tupdateEnd() {\n\t\tconst gl = this.gl;\n\n\t\tif (this.boundVao) {\n\t\t\tthis.boundVao = null;\n\t\t\tthis.gl.bindVertexArray(null);\n\t\t}\n\n\t\tconst target = this.renderTarget;\n\n\t\tif (target) {\n\t\t\tconst colorBuffer = target._colorBuffer;\n\n\t\t\tif (colorBuffer && colorBuffer._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.webgl2)) {\n\t\t\t\tthis.activeTexture(this.maxCombinedTextures - 1);\n\t\t\t\tthis.bindTexture(colorBuffer);\n\t\t\t\tgl.generateMipmap(colorBuffer._glTarget);\n\t\t\t}\n\n\t\t\tif (this.webgl2 && target._samples > 1 && target.autoResolve) {\n\t\t\t\ttarget.resolve();\n\t\t\t}\n\t\t}\n\t}\n\n\tinitializeTexture(texture) {\n\t\tconst gl = this.gl;\n\t\tlet ext;\n\t\ttexture._glTexture = gl.createTexture();\n\t\ttexture._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : gl.TEXTURE_2D;\n\n\t\tswitch (texture._format) {\n\t\t\tcase PIXELFORMAT_A8:\n\t\t\t\ttexture._glFormat = gl.ALPHA;\n\t\t\t\ttexture._glInternalFormat = gl.ALPHA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_L8:\n\t\t\t\ttexture._glFormat = gl.LUMINANCE;\n\t\t\t\ttexture._glInternalFormat = gl.LUMINANCE;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_L8_A8:\n\t\t\t\ttexture._glFormat = gl.LUMINANCE_ALPHA;\n\t\t\t\ttexture._glInternalFormat = gl.LUMINANCE_ALPHA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R5_G6_B5:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = gl.RGB;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_SHORT_5_6_5;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R5_G5_B5_A1:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = gl.RGBA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R4_G4_B4_A4:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = gl.RGBA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R8_G8_B8:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = this.webgl2 ? gl.RGB8 : gl.RGB;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R8_G8_B8_A8:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = this.webgl2 ? gl.RGBA8 : gl.RGBA;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DXT1:\n\t\t\t\text = this.extCompressedTextureS3TC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DXT3:\n\t\t\t\text = this.extCompressedTextureS3TC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DXT5:\n\t\t\t\text = this.extCompressedTextureS3TC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ETC1:\n\t\t\t\text = this.extCompressedTextureETC1;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_ETC1_WEBGL;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_PVRTC_2BPP_RGB_1:\n\t\t\t\text = this.extCompressedTexturePVRTC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_PVRTC_2BPP_RGBA_1:\n\t\t\t\text = this.extCompressedTexturePVRTC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_PVRTC_4BPP_RGB_1:\n\t\t\t\text = this.extCompressedTexturePVRTC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_PVRTC_4BPP_RGBA_1:\n\t\t\t\text = this.extCompressedTexturePVRTC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ETC2_RGB:\n\t\t\t\text = this.extCompressedTextureETC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB8_ETC2;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ETC2_RGBA:\n\t\t\t\text = this.extCompressedTextureETC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA8_ETC2_EAC;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ASTC_4x4:\n\t\t\t\text = this.extCompressedTextureASTC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ATC_RGB:\n\t\t\t\text = this.extCompressedTextureATC;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGB_ATC_WEBGL;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_ATC_RGBA:\n\t\t\t\text = this.extCompressedTextureATC;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_RGB16F:\n\t\t\t\text = this.extTextureHalfFloat;\n\t\t\t\ttexture._glFormat = gl.RGB;\n\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGB16F;\n\t\t\t\t\ttexture._glPixelType = gl.HALF_FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGB;\n\t\t\t\t\ttexture._glPixelType = ext.HALF_FLOAT_OES;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\t\text = this.extTextureHalfFloat;\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGBA16F;\n\t\t\t\t\ttexture._glPixelType = gl.HALF_FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGBA;\n\t\t\t\t\ttexture._glPixelType = ext.HALF_FLOAT_OES;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_RGB32F:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGB32F;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGB;\n\t\t\t\t}\n\n\t\t\t\ttexture._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGBA32F;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glInternalFormat = gl.RGBA;\n\t\t\t\t}\n\n\t\t\t\ttexture._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_R32F:\n\t\t\t\ttexture._glFormat = gl.RED;\n\t\t\t\ttexture._glInternalFormat = gl.R32F;\n\t\t\t\ttexture._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DEPTH:\n\t\t\t\tif (this.webgl2) {\n\t\t\t\t\ttexture._glFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\ttexture._glInternalFormat = gl.DEPTH_COMPONENT32F;\n\t\t\t\t\ttexture._glPixelType = gl.FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._glFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\ttexture._glInternalFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\ttexture._glPixelType = gl.UNSIGNED_SHORT;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_DEPTHSTENCIL:\n\t\t\t\ttexture._glFormat = gl.DEPTH_STENCIL;\n\t\t\t\ttexture._glInternalFormat = gl.DEPTH24_STENCIL8;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_INT_24_8;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_111110F:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = gl.R11F_G11F_B10F;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_SRGB:\n\t\t\t\ttexture._glFormat = gl.RGB;\n\t\t\t\ttexture._glInternalFormat = gl.SRGB8;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\n\t\t\tcase PIXELFORMAT_SRGBA:\n\t\t\t\ttexture._glFormat = gl.RGBA;\n\t\t\t\ttexture._glInternalFormat = gl.SRGB8_ALPHA8;\n\t\t\t\ttexture._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tthis.textures.push(texture);\n\t}\n\n\tdestroyTexture(texture) {\n\t\tif (texture._glTexture) {\n\t\t\tconst idx = this.textures.indexOf(texture);\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tthis.textures.splice(idx, 1);\n\t\t\t}\n\n\t\t\tthis.scope.removeValue(texture);\n\n\t\t\tfor (let i = 0; i < this.textureUnits.length; i++) {\n\t\t\t\tconst textureUnit = this.textureUnits[i];\n\n\t\t\t\tfor (let j = 0; j < textureUnit.length; j++) {\n\t\t\t\t\tif (textureUnit[j] === texture._glTexture) {\n\t\t\t\t\t\ttextureUnit[j] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst gl = this.gl;\n\t\t\tgl.deleteTexture(texture._glTexture);\n\t\t\tdelete texture._glTexture;\n\t\t\tdelete texture._glTarget;\n\t\t\tdelete texture._glFormat;\n\t\t\tdelete texture._glInternalFormat;\n\t\t\tdelete texture._glPixelType;\n\t\t\tthis._vram.tex -= texture._gpuSize;\n\t\t}\n\t}\n\n\tsetUnpackFlipY(flipY) {\n\t\tif (this.unpackFlipY !== flipY) {\n\t\t\tthis.unpackFlipY = flipY;\n\t\t\tconst gl = this.gl;\n\t\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\t\t}\n\t}\n\n\tsetUnpackPremultiplyAlpha(premultiplyAlpha) {\n\t\tif (this.unpackPremultiplyAlpha !== premultiplyAlpha) {\n\t\t\tthis.unpackPremultiplyAlpha = premultiplyAlpha;\n\t\t\tconst gl = this.gl;\n\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);\n\t\t}\n\t}\n\n\t_isBrowserInterface(texture) {\n\t\treturn typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement || typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap;\n\t}\n\n\tuploadTexture(texture) {\n\t\tconst gl = this.gl;\n\t\tif (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) return;\n\t\tlet mipLevel = 0;\n\t\tlet mipObject;\n\t\tlet resMult;\n\t\tconst requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;\n\n\t\twhile (texture._levels[mipLevel] || mipLevel === 0) {\n\t\t\tif (!texture._needsUpload && mipLevel === 0) {\n\t\t\t\tmipLevel++;\n\t\t\t\tcontinue;\n\t\t\t} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmipObject = texture._levels[mipLevel];\n\n\t\t\tif (mipLevel === 1 && !texture._compressed && texture._levels.length < requiredMipLevels) {\n\t\t\t\tgl.generateMipmap(texture._glTarget);\n\t\t\t\ttexture._mipmapsUploaded = true;\n\t\t\t}\n\n\t\t\tif (texture._cubemap) {\n\t\t\t\tlet face;\n\n\t\t\t\tif (this._isBrowserInterface(mipObject[0])) {\n\t\t\t\t\tfor (face = 0; face < 6; face++) {\n\t\t\t\t\t\tif (!texture._levelsUpdated[0][face]) continue;\n\t\t\t\t\t\tlet src = mipObject[face];\n\n\t\t\t\t\t\tif (src instanceof HTMLImageElement) {\n\t\t\t\t\t\t\tif (src.width > this.maxCubeMapSize || src.height > this.maxCubeMapSize) {\n\t\t\t\t\t\t\t\tsrc = downsampleImage(src, this.maxCubeMapSize);\n\n\t\t\t\t\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\t\t\t\t\ttexture._width = src.width;\n\t\t\t\t\t\t\t\t\ttexture._height = src.height;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.setUnpackFlipY(false);\n\t\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, src);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\n\t\t\t\t\tfor (face = 0; face < 6; face++) {\n\t\t\t\t\t\tif (!texture._levelsUpdated[0][face]) continue;\n\t\t\t\t\t\tconst texData = mipObject[face];\n\n\t\t\t\t\t\tif (texture._compressed) {\n\t\t\t\t\t\t\tgl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.setUnpackFlipY(false);\n\t\t\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, texData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (texture._volume) {\n\t\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\n\t\t\t\tif (texture._compressed) {\n\t\t\t\t\tgl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);\n\t\t\t\t} else {\n\t\t\t\t\tthis.setUnpackFlipY(false);\n\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\tgl.texImage3D(gl.TEXTURE_3D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._isBrowserInterface(mipObject)) {\n\t\t\t\t\tif (mipObject instanceof HTMLImageElement) {\n\t\t\t\t\t\tif (mipObject.width > this.maxTextureSize || mipObject.height > this.maxTextureSize) {\n\t\t\t\t\t\t\tmipObject = downsampleImage(mipObject, this.maxTextureSize);\n\n\t\t\t\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\t\t\t\ttexture._width = mipObject.width;\n\t\t\t\t\t\t\t\ttexture._height = mipObject.height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setUnpackFlipY(texture._flipY);\n\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, texture._glFormat, texture._glPixelType, mipObject);\n\t\t\t\t} else {\n\t\t\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\n\t\t\t\t\tif (texture._compressed) {\n\t\t\t\t\t\tgl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.setUnpackFlipY(false);\n\t\t\t\t\t\tthis.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, mipLevel, texture._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texture._glFormat, texture._glPixelType, mipObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\ttexture._mipmapsUploaded = false;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._mipmapsUploaded = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmipLevel++;\n\t\t}\n\n\t\tif (texture._needsUpload) {\n\t\t\tif (texture._cubemap) {\n\t\t\t\tfor (let i = 0; i < 6; i++) texture._levelsUpdated[0][i] = false;\n\t\t\t} else {\n\t\t\t\ttexture._levelsUpdated[0] = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!texture._compressed && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || this.webgl2) && texture._levels.length === 1) {\n\t\t\tgl.generateMipmap(texture._glTarget);\n\t\t\ttexture._mipmapsUploaded = true;\n\t\t}\n\n\t\tif (texture._gpuSize) {\n\t\t\tthis._vram.tex -= texture._gpuSize;\n\t\t}\n\n\t\ttexture._gpuSize = texture.gpuSize;\n\t\tthis._vram.tex += texture._gpuSize;\n\t}\n\n\tactiveTexture(textureUnit) {\n\t\tif (this.textureUnit !== textureUnit) {\n\t\t\tthis.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n\t\t\tthis.textureUnit = textureUnit;\n\t\t}\n\t}\n\n\tbindTexture(texture) {\n\t\tconst textureTarget = texture._glTarget;\n\t\tconst textureObject = texture._glTexture;\n\t\tconst textureUnit = this.textureUnit;\n\t\tconst slot = this.targetToSlot[textureTarget];\n\n\t\tif (this.textureUnits[textureUnit][slot] !== textureObject) {\n\t\t\tthis.gl.bindTexture(textureTarget, textureObject);\n\t\t\tthis.textureUnits[textureUnit][slot] = textureObject;\n\t\t}\n\t}\n\n\tbindTextureOnUnit(texture, textureUnit) {\n\t\tconst textureTarget = texture._glTarget;\n\t\tconst textureObject = texture._glTexture;\n\t\tconst slot = this.targetToSlot[textureTarget];\n\n\t\tif (this.textureUnits[textureUnit][slot] !== textureObject) {\n\t\t\tthis.activeTexture(textureUnit);\n\t\t\tthis.gl.bindTexture(textureTarget, textureObject);\n\t\t\tthis.textureUnits[textureUnit][slot] = textureObject;\n\t\t}\n\t}\n\n\tsetTextureParameters(texture) {\n\t\tconst gl = this.gl;\n\t\tconst flags = texture._parameterFlags;\n\t\tconst target = texture._glTarget;\n\n\t\tif (flags & 1) {\n\t\t\tlet filter = texture._minFilter;\n\n\t\t\tif (!texture.pot && !this.webgl2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {\n\t\t\t\tif (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {\n\t\t\t\t\tfilter = FILTER_NEAREST;\n\t\t\t\t} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {\n\t\t\t\t\tfilter = FILTER_LINEAR;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);\n\t\t}\n\n\t\tif (flags & 2) {\n\t\t\tgl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);\n\t\t}\n\n\t\tif (flags & 4) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);\n\t\t\t} else {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 8) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);\n\t\t\t} else {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 16) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 32) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 64) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & 128) {\n\t\t\tconst ext = this.extTextureFilterAnisotropic;\n\n\t\t\tif (ext) {\n\t\t\t\tgl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(texture._anisotropy), this.maxAnisotropy)));\n\t\t\t}\n\t\t}\n\t}\n\n\tsetTexture(texture, textureUnit) {\n\t\tif (!texture._glTexture) this.initializeTexture(texture);\n\n\t\tif (texture._parameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload || texture === this.grabPass.texture) {\n\t\t\tthis.activeTexture(textureUnit);\n\t\t\tthis.bindTexture(texture);\n\n\t\t\tif (texture._parameterFlags) {\n\t\t\t\tthis.setTextureParameters(texture);\n\t\t\t\ttexture._parameterFlags = 0;\n\t\t\t}\n\n\t\t\tconst processed = texture === this.grabPass.texture && this.grabPass.prepareTexture();\n\n\t\t\tif (!processed && (texture._needsUpload || texture._needsMipmapsUpload)) {\n\t\t\t\tthis.uploadTexture(texture);\n\t\t\t\ttexture._needsUpload = false;\n\t\t\t\ttexture._needsMipmapsUpload = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.bindTextureOnUnit(texture, textureUnit);\n\t\t}\n\t}\n\n\tcreateVertexArray(vertexBuffers) {\n\t\tlet key, vao;\n\t\tconst useCache = vertexBuffers.length > 1;\n\n\t\tif (useCache) {\n\t\t\tkey = \"\";\n\n\t\t\tfor (let i = 0; i < vertexBuffers.length; i++) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[i];\n\t\t\t\tkey += vertexBuffer.id + vertexBuffer.format.renderingingHash;\n\t\t\t}\n\n\t\t\tvao = this._vaoMap.get(key);\n\t\t}\n\n\t\tif (!vao) {\n\t\t\tconst gl = this.gl;\n\t\t\tvao = gl.createVertexArray();\n\t\t\tgl.bindVertexArray(vao);\n\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\n\t\t\tfor (let i = 0; i < vertexBuffers.length; i++) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[i];\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.bufferId);\n\t\t\t\tconst elements = vertexBuffer.format.elements;\n\n\t\t\t\tfor (let j = 0; j < elements.length; j++) {\n\t\t\t\t\tconst e = elements[j];\n\t\t\t\t\tconst loc = semanticToLocation[e.name];\n\n\t\t\t\t\tgl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);\n\t\t\t\t\tgl.enableVertexAttribArray(loc);\n\n\t\t\t\t\tif (vertexBuffer.instancing) {\n\t\t\t\t\t\tgl.vertexAttribDivisor(loc, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgl.bindVertexArray(null);\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n\t\t\tif (useCache) {\n\t\t\t\tthis._vaoMap.set(key, vao);\n\t\t\t}\n\t\t}\n\n\t\treturn vao;\n\t}\n\n\tsetBuffers() {\n\t\tconst gl = this.gl;\n\t\tlet vao;\n\n\t\tif (this.vertexBuffers.length === 1) {\n\t\t\tconst vertexBuffer = this.vertexBuffers[0];\n\n\t\t\tif (!vertexBuffer._vao) {\n\t\t\t\tvertexBuffer._vao = this.createVertexArray(this.vertexBuffers);\n\t\t\t}\n\n\t\t\tvao = vertexBuffer._vao;\n\t\t} else {\n\t\t\tvao = this.createVertexArray(this.vertexBuffers);\n\t\t}\n\n\t\tif (this.boundVao !== vao) {\n\t\t\tthis.boundVao = vao;\n\t\t\tgl.bindVertexArray(vao);\n\t\t}\n\n\t\tthis.vertexBuffers.length = 0;\n\t\tconst bufferId = this.indexBuffer ? this.indexBuffer.bufferId : null;\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);\n\t}\n\n\tdraw(primitive, numInstances, keepBuffers) {\n\t\tconst gl = this.gl;\n\t\tlet sampler, samplerValue, texture, numTextures;\n\t\tlet uniform, scopeId, uniformVersion, programVersion;\n\t\tconst shader = this.shader;\n\t\tif (!shader) return;\n\t\tconst samplers = shader.samplers;\n\t\tconst uniforms = shader.uniforms;\n\n\t\tif (!keepBuffers) {\n\t\t\tthis.setBuffers();\n\t\t}\n\n\t\tlet textureUnit = 0;\n\n\t\tfor (let i = 0, len = samplers.length; i < len; i++) {\n\t\t\tsampler = samplers[i];\n\t\t\tsamplerValue = sampler.scopeId.value;\n\n\t\t\tif (!samplerValue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (samplerValue instanceof Texture) {\n\t\t\t\ttexture = samplerValue;\n\t\t\t\tthis.setTexture(texture, textureUnit);\n\n\t\t\t\tif (sampler.slot !== textureUnit) {\n\t\t\t\t\tgl.uniform1i(sampler.locationId, textureUnit);\n\t\t\t\t\tsampler.slot = textureUnit;\n\t\t\t\t}\n\n\t\t\t\ttextureUnit++;\n\t\t\t} else {\n\t\t\t\tsampler.array.length = 0;\n\t\t\t\tnumTextures = samplerValue.length;\n\n\t\t\t\tfor (let j = 0; j < numTextures; j++) {\n\t\t\t\t\ttexture = samplerValue[j];\n\t\t\t\t\tthis.setTexture(texture, textureUnit);\n\t\t\t\t\tsampler.array[j] = textureUnit;\n\t\t\t\t\ttextureUnit++;\n\t\t\t\t}\n\n\t\t\t\tgl.uniform1iv(sampler.locationId, sampler.array);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = uniforms.length; i < len; i++) {\n\t\t\tuniform = uniforms[i];\n\t\t\tscopeId = uniform.scopeId;\n\t\t\tuniformVersion = uniform.version;\n\t\t\tprogramVersion = scopeId.versionObject.version;\n\n\t\t\tif (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {\n\t\t\t\tuniformVersion.globalId = programVersion.globalId;\n\t\t\t\tuniformVersion.revision = programVersion.revision;\n\n\t\t\t\tif (scopeId.value !== null) {\n\t\t\t\t\tthis.commitFunction[uniform.dataType](uniform, scopeId.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.webgl2 && this.transformFeedbackBuffer) {\n\t\t\tgl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.bufferId);\n\t\t\tgl.beginTransformFeedback(gl.POINTS);\n\t\t}\n\n\t\tconst mode = this.glPrimitive[primitive.type];\n\t\tconst count = primitive.count;\n\n\t\tif (primitive.indexed) {\n\t\t\tconst indexBuffer = this.indexBuffer;\n\t\t\tconst format = indexBuffer.glFormat;\n\t\t\tconst offset = primitive.base * indexBuffer.bytesPerIndex;\n\n\t\t\tif (numInstances > 0) {\n\t\t\t\tgl.drawElementsInstanced(mode, count, format, offset, numInstances);\n\t\t\t} else {\n\t\t\t\tgl.drawElements(mode, count, format, offset);\n\t\t\t}\n\t\t} else {\n\t\t\tconst first = primitive.base;\n\n\t\t\tif (numInstances > 0) {\n\t\t\t\tgl.drawArraysInstanced(mode, first, count, numInstances);\n\t\t\t} else {\n\t\t\t\tgl.drawArrays(mode, first, count);\n\t\t\t}\n\t\t}\n\n\t\tif (this.webgl2 && this.transformFeedbackBuffer) {\n\t\t\tgl.endTransformFeedback();\n\t\t\tgl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);\n\t\t}\n\n\t\tthis._drawCallsPerFrame++;\n\t}\n\n\tclear(options) {\n\t\tconst defaultOptions = this.defaultClearOptions;\n\t\toptions = options || defaultOptions;\n\t\tconst flags = options.flags == undefined ? defaultOptions.flags : options.flags;\n\n\t\tif (flags !== 0) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (flags & CLEARFLAG_COLOR) {\n\t\t\t\tconst color = options.color == undefined ? defaultOptions.color : options.color;\n\t\t\t\tthis.setClearColor(color[0], color[1], color[2], color[3]);\n\t\t\t}\n\n\t\t\tif (flags & CLEARFLAG_DEPTH) {\n\t\t\t\tconst depth = options.depth == undefined ? defaultOptions.depth : options.depth;\n\t\t\t\tthis.setClearDepth(depth);\n\n\t\t\t\tif (!this.depthWrite) {\n\t\t\t\t\tgl.depthMask(true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flags & CLEARFLAG_STENCIL) {\n\t\t\t\tconst stencil = options.stencil == undefined ? defaultOptions.stencil : options.stencil;\n\t\t\t\tthis.setClearStencil(stencil);\n\t\t\t}\n\n\t\t\tgl.clear(this.glClearFlag[flags]);\n\n\t\t\tif (flags & CLEARFLAG_DEPTH) {\n\t\t\t\tif (!this.depthWrite) {\n\t\t\t\t\tgl.depthMask(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treadPixels(x, y, w, h, pixels) {\n\t\tconst gl = this.gl;\n\t\tgl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\t}\n\n\tsetClearDepth(depth) {\n\t\tif (depth !== this.clearDepth) {\n\t\t\tthis.gl.clearDepth(depth);\n\t\t\tthis.clearDepth = depth;\n\t\t}\n\t}\n\n\tsetClearColor(r, g, b, a) {\n\t\tif (r !== this.clearRed || g !== this.clearGreen || b !== this.clearBlue || a !== this.clearAlpha) {\n\t\t\tthis.gl.clearColor(r, g, b, a);\n\t\t\tthis.clearRed = r;\n\t\t\tthis.clearGreen = g;\n\t\t\tthis.clearBlue = b;\n\t\t\tthis.clearAlpha = a;\n\t\t}\n\t}\n\n\tsetClearStencil(value) {\n\t\tif (value !== this.clearStencil) {\n\t\t\tthis.gl.clearStencil(value);\n\t\t\tthis.clearStencil = value;\n\t\t}\n\t}\n\n\tsetRenderTarget(renderTarget) {\n\t\tthis.renderTarget = renderTarget;\n\t}\n\n\tgetRenderTarget() {\n\t\treturn this.renderTarget;\n\t}\n\n\tgetDepthTest() {\n\t\treturn this.depthTest;\n\t}\n\n\tsetDepthTest(depthTest) {\n\t\tif (this.depthTest !== depthTest) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (depthTest) {\n\t\t\t\tgl.enable(gl.DEPTH_TEST);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\t}\n\n\t\t\tthis.depthTest = depthTest;\n\t\t}\n\t}\n\n\tsetDepthFunc(func) {\n\t\tif (this.depthFunc === func) return;\n\t\tthis.gl.depthFunc(this.glComparison[func]);\n\t\tthis.depthFunc = func;\n\t}\n\n\tgetDepthWrite() {\n\t\treturn this.depthWrite;\n\t}\n\n\tsetDepthWrite(writeDepth) {\n\t\tif (this.depthWrite !== writeDepth) {\n\t\t\tthis.gl.depthMask(writeDepth);\n\t\t\tthis.depthWrite = writeDepth;\n\t\t}\n\t}\n\n\tsetColorWrite(writeRed, writeGreen, writeBlue, writeAlpha) {\n\t\tif (this.writeRed !== writeRed || this.writeGreen !== writeGreen || this.writeBlue !== writeBlue || this.writeAlpha !== writeAlpha) {\n\t\t\tthis.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);\n\t\t\tthis.writeRed = writeRed;\n\t\t\tthis.writeGreen = writeGreen;\n\t\t\tthis.writeBlue = writeBlue;\n\t\t\tthis.writeAlpha = writeAlpha;\n\t\t}\n\t}\n\n\tsetAlphaToCoverage(state) {\n\t\tif (!this.webgl2) return;\n\t\tif (this.alphaToCoverage === state) return;\n\t\tthis.alphaToCoverage = state;\n\n\t\tif (state) {\n\t\t\tthis.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t} else {\n\t\t\tthis.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t}\n\t}\n\n\tsetTransformFeedbackBuffer(tf) {\n\t\tif (this.transformFeedbackBuffer === tf) return;\n\t\tthis.transformFeedbackBuffer = tf;\n\n\t\tif (this.webgl2) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (tf) {\n\t\t\t\tif (!this.feedback) {\n\t\t\t\t\tthis.feedback = gl.createTransformFeedback();\n\t\t\t\t}\n\n\t\t\t\tgl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);\n\t\t\t} else {\n\t\t\t\tgl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetRaster(on) {\n\t\tif (this.raster === on) return;\n\t\tthis.raster = on;\n\n\t\tif (this.webgl2) {\n\t\t\tif (on) {\n\t\t\t\tthis.gl.disable(this.gl.RASTERIZER_DISCARD);\n\t\t\t} else {\n\t\t\t\tthis.gl.enable(this.gl.RASTERIZER_DISCARD);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetDepthBias(on) {\n\t\tif (this.depthBiasEnabled === on) return;\n\t\tthis.depthBiasEnabled = on;\n\n\t\tif (on) {\n\t\t\tthis.gl.enable(this.gl.POLYGON_OFFSET_FILL);\n\t\t} else {\n\t\t\tthis.gl.disable(this.gl.POLYGON_OFFSET_FILL);\n\t\t}\n\t}\n\n\tsetDepthBiasValues(constBias, slopeBias) {\n\t\tthis.gl.polygonOffset(slopeBias, constBias);\n\t}\n\n\tgetBlending() {\n\t\treturn this.blending;\n\t}\n\n\tsetBlending(blending) {\n\t\tif (this.blending !== blending) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (blending) {\n\t\t\t\tgl.enable(gl.BLEND);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.BLEND);\n\t\t\t}\n\n\t\t\tthis.blending = blending;\n\t\t}\n\t}\n\n\tsetStencilTest(enable) {\n\t\tif (this.stencil !== enable) {\n\t\t\tconst gl = this.gl;\n\n\t\t\tif (enable) {\n\t\t\t\tgl.enable(gl.STENCIL_TEST);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.STENCIL_TEST);\n\t\t\t}\n\n\t\t\tthis.stencil = enable;\n\t\t}\n\t}\n\n\tsetStencilFunc(func, ref, mask) {\n\t\tif (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.stencilFunc(this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncFront = this.stencilFuncBack = func;\n\t\t\tthis.stencilRefFront = this.stencilRefBack = ref;\n\t\t\tthis.stencilMaskFront = this.stencilMaskBack = mask;\n\t\t}\n\t}\n\n\tsetStencilFuncFront(func, ref, mask) {\n\t\tif (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncFront = func;\n\t\t\tthis.stencilRefFront = ref;\n\t\t\tthis.stencilMaskFront = mask;\n\t\t}\n\t}\n\n\tsetStencilFuncBack(func, ref, mask) {\n\t\tif (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncBack = func;\n\t\t\tthis.stencilRefBack = ref;\n\t\t\tthis.stencilMaskBack = mask;\n\t\t}\n\t}\n\n\tsetStencilOperation(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {\n\t\t\tthis.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailFront = this.stencilFailBack = fail;\n\t\t\tthis.stencilZfailFront = this.stencilZfailBack = zfail;\n\t\t\tthis.stencilZpassFront = this.stencilZpassBack = zpass;\n\t\t}\n\n\t\tif (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {\n\t\t\tthis.gl.stencilMask(writeMask);\n\t\t\tthis.stencilWriteMaskFront = writeMask;\n\t\t\tthis.stencilWriteMaskBack = writeMask;\n\t\t}\n\t}\n\n\tsetStencilOperationFront(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {\n\t\t\tthis.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailFront = fail;\n\t\t\tthis.stencilZfailFront = zfail;\n\t\t\tthis.stencilZpassFront = zpass;\n\t\t}\n\n\t\tif (this.stencilWriteMaskFront !== writeMask) {\n\t\t\tthis.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);\n\t\t\tthis.stencilWriteMaskFront = writeMask;\n\t\t}\n\t}\n\n\tsetStencilOperationBack(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {\n\t\t\tthis.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailBack = fail;\n\t\t\tthis.stencilZfailBack = zfail;\n\t\t\tthis.stencilZpassBack = zpass;\n\t\t}\n\n\t\tif (this.stencilWriteMaskBack !== writeMask) {\n\t\t\tthis.gl.stencilMaskSeparate(this.gl.BACK, writeMask);\n\t\t\tthis.stencilWriteMaskBack = writeMask;\n\t\t}\n\t}\n\n\tsetBlendFunction(blendSrc, blendDst) {\n\t\tif (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.separateAlphaBlend) {\n\t\t\tthis.gl.blendFunc(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst]);\n\t\t\tthis.blendSrc = blendSrc;\n\t\t\tthis.blendDst = blendDst;\n\t\t\tthis.separateAlphaBlend = false;\n\t\t}\n\t}\n\n\tsetBlendFunctionSeparate(blendSrc, blendDst, blendSrcAlpha, blendDstAlpha) {\n\t\tif (this.blendSrc !== blendSrc || this.blendDst !== blendDst || this.blendSrcAlpha !== blendSrcAlpha || this.blendDstAlpha !== blendDstAlpha || !this.separateAlphaBlend) {\n\t\t\tthis.gl.blendFuncSeparate(this.glBlendFunction[blendSrc], this.glBlendFunction[blendDst], this.glBlendFunction[blendSrcAlpha], this.glBlendFunction[blendDstAlpha]);\n\t\t\tthis.blendSrc = blendSrc;\n\t\t\tthis.blendDst = blendDst;\n\t\t\tthis.blendSrcAlpha = blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = blendDstAlpha;\n\t\t\tthis.separateAlphaBlend = true;\n\t\t}\n\t}\n\n\tsetBlendEquation(blendEquation) {\n\t\tif (this.blendEquation !== blendEquation || this.separateAlphaEquation) {\n\t\t\tthis.gl.blendEquation(this.glBlendEquation[blendEquation]);\n\t\t\tthis.blendEquation = blendEquation;\n\t\t\tthis.separateAlphaEquation = false;\n\t\t}\n\t}\n\n\tsetBlendEquationSeparate(blendEquation, blendAlphaEquation) {\n\t\tif (this.blendEquation !== blendEquation || this.blendAlphaEquation !== blendAlphaEquation || !this.separateAlphaEquation) {\n\t\t\tthis.gl.blendEquationSeparate(this.glBlendEquation[blendEquation], this.glBlendEquation[blendAlphaEquation]);\n\t\t\tthis.blendEquation = blendEquation;\n\t\t\tthis.blendAlphaEquation = blendAlphaEquation;\n\t\t\tthis.separateAlphaEquation = true;\n\t\t}\n\t}\n\n\tsetCullMode(cullMode) {\n\t\tif (this.cullMode !== cullMode) {\n\t\t\tif (cullMode === CULLFACE_NONE) {\n\t\t\t\tthis.gl.disable(this.gl.CULL_FACE);\n\t\t\t} else {\n\t\t\t\tif (this.cullMode === CULLFACE_NONE) {\n\t\t\t\t\tthis.gl.enable(this.gl.CULL_FACE);\n\t\t\t\t}\n\n\t\t\t\tconst mode = this.glCull[cullMode];\n\n\t\t\t\tif (this.cullFace !== mode) {\n\t\t\t\t\tthis.gl.cullFace(mode);\n\t\t\t\t\tthis.cullFace = mode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.cullMode = cullMode;\n\t\t}\n\t}\n\n\tgetCullMode() {\n\t\treturn this.cullMode;\n\t}\n\n\tsetIndexBuffer(indexBuffer) {\n\t\tthis.indexBuffer = indexBuffer;\n\t}\n\n\tsetVertexBuffer(vertexBuffer) {\n\t\tif (vertexBuffer) {\n\t\t\tthis.vertexBuffers.push(vertexBuffer);\n\t\t}\n\t}\n\n\tcompileShaderSource(src, isVertexShader) {\n\t\tconst gl = this.gl;\n\t\tlet glShader = isVertexShader ? this.vertexShaderCache[src] : this.fragmentShaderCache[src];\n\n\t\tif (!glShader) {\n\t\t\tglShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\n\t\t\tgl.shaderSource(glShader, src);\n\t\t\tgl.compileShader(glShader);\n\n\t\t\tif (isVertexShader) {\n\t\t\t\tthis.vertexShaderCache[src] = glShader;\n\t\t\t} else {\n\t\t\t\tthis.fragmentShaderCache[src] = glShader;\n\t\t\t}\n\t\t}\n\n\t\treturn glShader;\n\t}\n\n\tcompileAndLinkShader(shader) {\n\t\tconst definition = shader.definition;\n\t\tconst glVertexShader = this.compileShaderSource(definition.vshader, true);\n\t\tconst glFragmentShader = this.compileShaderSource(definition.fshader, false);\n\t\tconst gl = this.gl;\n\t\tconst glProgram = gl.createProgram();\n\t\tgl.attachShader(glProgram, glVertexShader);\n\t\tgl.attachShader(glProgram, glFragmentShader);\n\t\tconst attrs = definition.attributes;\n\n\t\tif (this.webgl2 && definition.useTransformFeedback) {\n\t\t\tconst outNames = [];\n\n\t\t\tfor (const attr in attrs) {\n\t\t\t\tif (attrs.hasOwnProperty(attr)) {\n\t\t\t\t\toutNames.push(\"out_\" + attr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);\n\t\t}\n\n\t\tconst locations = {};\n\n\t\tfor (const attr in attrs) {\n\t\t\tif (attrs.hasOwnProperty(attr)) {\n\t\t\t\tconst semantic = attrs[attr];\n\t\t\t\tconst loc = semanticToLocation[semantic];\n\t\t\t\tlocations[loc] = attr;\n\t\t\t\tgl.bindAttribLocation(glProgram, loc, attr);\n\t\t\t}\n\t\t}\n\n\t\tgl.linkProgram(glProgram);\n\t\tshader._glVertexShader = glVertexShader;\n\t\tshader._glFragmentShader = glFragmentShader;\n\t\tshader._glProgram = glProgram;\n\t}\n\n\tcreateShader(shader) {\n\t\tthis.compileAndLinkShader(shader);\n\t\tthis.shaders.push(shader);\n\t}\n\n\tdestroyShader(shader) {\n\t\tconst idx = this.shaders.indexOf(shader);\n\n\t\tif (idx !== -1) {\n\t\t\tthis.shaders.splice(idx, 1);\n\t\t}\n\n\t\tif (shader._glProgram) {\n\t\t\tthis.gl.deleteProgram(shader._glProgram);\n\t\t\tshader._glProgram = null;\n\t\t\tthis.removeShaderFromCache(shader);\n\t\t}\n\t}\n\n\t_processError(src, infoLog) {\n\t\tif (!src) return \"\";\n\t\tconst lines = src.split('\\n');\n\t\tconst error = {};\n\t\tlet code = '';\n\t\tlet from = 0;\n\t\tlet to = lines.length;\n\n\t\tif (infoLog && infoLog.startsWith('ERROR:')) {\n\t\t\tconst match = infoLog.match(/^ERROR:\\s([0-9]+):([0-9]+):\\s*(.+)/);\n\n\t\t\tif (match) {\n\t\t\t\terror.message = match[3];\n\t\t\t\terror.line = parseInt(match[2], 10);\n\t\t\t\tfrom = Math.max(0, error.line - 6);\n\t\t\t\tto = Math.min(lines.length, error.line + 5);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tcode += i + 1 + \":\\t\" + lines[i] + '\\n';\n\t\t}\n\n\t\terror.source = src;\n\t\treturn [code, error];\n\t}\n\n\t_isShaderCompiled(shader, glShader, source, shaderType) {\n\t\tconst gl = this.gl;\n\n\t\tif (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {\n\t\t\tconst infoLog = gl.getShaderInfoLog(glShader);\n\n\t\t\tconst [code, error] = this._processError(source, infoLog);\n\n\t\t\tconst message = `Failed to compile ${shaderType} shader:\\n\\n${infoLog}\\n${code}`;\n\t\t\tconsole.error(message);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpostLink(shader) {\n\t\tconst gl = this.gl;\n\t\tconst glProgram = shader._glProgram;\n\t\tconst definition = shader.definition;\n\t\tif (!this._isShaderCompiled(shader, shader._glVertexShader, definition.vshader, \"vertex\")) return false;\n\t\tif (!this._isShaderCompiled(shader, shader._glFragmentShader, definition.fshader, \"fragment\")) return false;\n\n\t\tif (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {\n\t\t\tconst message = \"Failed to link shader program. Error: \" + gl.getProgramInfoLog(glProgram);\n\t\t\tconsole.error(message);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet i, info, location, shaderInput;\n\t\ti = 0;\n\t\tconst numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);\n\n\t\twhile (i < numAttributes) {\n\t\t\tinfo = gl.getActiveAttrib(glProgram, i++);\n\t\t\tlocation = gl.getAttribLocation(glProgram, info.name);\n\n\t\t\tif (definition.attributes[info.name] === undefined) {\n\t\t\t\tconsole.error(`Vertex shader attribute \"${info.name}\" is not mapped to a semantic in shader definition.`);\n\t\t\t}\n\n\t\t\tshaderInput = new ShaderInput(this, definition.attributes[info.name], this.pcUniformType[info.type], location);\n\t\t\tshader.attributes.push(shaderInput);\n\t\t}\n\n\t\ti = 0;\n\t\tconst numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);\n\n\t\twhile (i < numUniforms) {\n\t\t\tinfo = gl.getActiveUniform(glProgram, i++);\n\t\t\tlocation = gl.getUniformLocation(glProgram, info.name);\n\t\t\tshaderInput = new ShaderInput(this, info.name, this.pcUniformType[info.type], location);\n\n\t\t\tif (info.type === gl.SAMPLER_2D || info.type === gl.SAMPLER_CUBE || this.webgl2 && (info.type === gl.SAMPLER_2D_SHADOW || info.type === gl.SAMPLER_CUBE_SHADOW || info.type === gl.SAMPLER_3D)) {\n\t\t\t\tshader.samplers.push(shaderInput);\n\t\t\t} else {\n\t\t\t\tshader.uniforms.push(shaderInput);\n\t\t\t}\n\t\t}\n\n\t\tshader.ready = true;\n\t\treturn true;\n\t}\n\n\tsetShader(shader) {\n\t\tif (shader !== this.shader) {\n\t\t\tif (!shader.ready) {\n\t\t\t\tif (!this.postLink(shader)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.shader = shader;\n\t\t\tthis.gl.useProgram(shader._glProgram);\n\t\t\tthis.attributesInvalidated = true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tgetHdrFormat() {\n\t\tif (this.textureHalfFloatRenderable) {\n\t\t\treturn PIXELFORMAT_RGBA16F;\n\t\t} else if (this.textureFloatRenderable) {\n\t\t\treturn PIXELFORMAT_RGBA32F;\n\t\t}\n\n\t\treturn PIXELFORMAT_R8_G8_B8_A8;\n\t}\n\n\tgetBoneLimit() {\n\t\treturn this.boneLimit;\n\t}\n\n\tsetBoneLimit(maxBones) {\n\t\tthis.boneLimit = maxBones;\n\t}\n\n\tresizeCanvas(width, height) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tconst ratio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);\n\t\twidth = Math.floor(width * ratio);\n\t\theight = Math.floor(height * ratio);\n\n\t\tif (this.canvas.width !== width || this.canvas.height !== height) {\n\t\t\tthis.canvas.width = width;\n\t\t\tthis.canvas.height = height;\n\t\t\tthis.fire(EVENT_RESIZE, width, height);\n\t\t}\n\t}\n\n\tsetResolution(width, height) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis.canvas.width = width;\n\t\tthis.canvas.height = height;\n\t\tthis.fire(EVENT_RESIZE, width, height);\n\t}\n\n\tclearShaderCache() {\n\t\tconst gl = this.gl;\n\n\t\tfor (const shaderSrc in this.fragmentShaderCache) {\n\t\t\tgl.deleteShader(this.fragmentShaderCache[shaderSrc]);\n\t\t\tdelete this.fragmentShaderCache[shaderSrc];\n\t\t}\n\n\t\tfor (const shaderSrc in this.vertexShaderCache) {\n\t\t\tgl.deleteShader(this.vertexShaderCache[shaderSrc]);\n\t\t\tdelete this.vertexShaderCache[shaderSrc];\n\t\t}\n\n\t\tthis.programLib.clearCache();\n\t}\n\n\tclearVertexArrayObjectCache() {\n\t\tconst gl = this.gl;\n\n\t\tthis._vaoMap.forEach((item, key, mapObj) => {\n\t\t\tgl.deleteVertexArray(item);\n\t\t});\n\n\t\tthis._vaoMap.clear();\n\t}\n\n\tremoveShaderFromCache(shader) {\n\t\tthis.programLib.removeFromCache(shader);\n\t}\n\n\tget width() {\n\t\treturn this.gl.drawingBufferWidth || this.canvas.width;\n\t}\n\n\tget height() {\n\t\treturn this.gl.drawingBufferHeight || this.canvas.height;\n\t}\n\n\tset fullscreen(fullscreen) {\n\t\tif (fullscreen) {\n\t\t\tconst canvas = this.gl.canvas;\n\t\t\tcanvas.requestFullscreen();\n\t\t} else {\n\t\t\tdocument.exitFullscreen();\n\t\t}\n\t}\n\n\tget fullscreen() {\n\t\treturn !!document.fullscreenElement;\n\t}\n\n\tset enableAutoInstancing(value) {\n\t\tthis._enableAutoInstancing = value && this.extInstancing;\n\t}\n\n\tget enableAutoInstancing() {\n\t\treturn this._enableAutoInstancing;\n\t}\n\n\tset maxPixelRatio(ratio) {\n\t\tthis._maxPixelRatio = ratio;\n\t\tthis.resizeCanvas(this._width, this._height);\n\t}\n\n\tget maxPixelRatio() {\n\t\treturn this._maxPixelRatio;\n\t}\n\n\tget textureFloatHighPrecision() {\n\t\tif (this._textureFloatHighPrecision === undefined) {\n\t\t\tthis._textureFloatHighPrecision = testTextureFloatHighPrecision(this);\n\t\t}\n\n\t\treturn this._textureFloatHighPrecision;\n\t}\n\n\tget textureHalfFloatUpdatable() {\n\t\tif (this._textureHalfFloatUpdatable === undefined) {\n\t\t\tif (this.webgl2) {\n\t\t\t\tthis._textureHalfFloatUpdatable = true;\n\t\t\t} else {\n\t\t\t\tthis._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);\n\t\t\t}\n\t\t}\n\n\t\treturn this._textureHalfFloatUpdatable;\n\t}\n\n}\n\nconst defaultOptions = {\n\tdepth: true,\n\tface: 0\n};\n\nclass RenderTarget {\n\tconstructor(options) {\n\t\tvar _this$_colorBuffer, _this$_depthBuffer;\n\n\t\tconst _arg2 = arguments[1];\n\t\tconst _arg3 = arguments[2];\n\n\t\tif (options instanceof GraphicsDevice) {\n\t\t\tthis._colorBuffer = _arg2;\n\t\t\toptions = _arg3;\n\t\t} else {\n\t\t\tthis._colorBuffer = options.colorBuffer;\n\t\t}\n\n\t\tif (this._colorBuffer) {\n\t\t\tthis._colorBuffer._isRenderTarget = true;\n\t\t}\n\n\t\tthis._glFrameBuffer = null;\n\t\tthis._glDepthBuffer = null;\n\t\toptions = options !== undefined ? options : defaultOptions;\n\t\tthis._depthBuffer = options.depthBuffer;\n\t\tthis._face = options.face !== undefined ? options.face : 0;\n\n\t\tif (this._depthBuffer) {\n\t\t\tconst format = this._depthBuffer._format;\n\n\t\t\tif (format === PIXELFORMAT_DEPTH) {\n\t\t\t\tthis._depth = true;\n\t\t\t\tthis._stencil = false;\n\t\t\t} else if (format === PIXELFORMAT_DEPTHSTENCIL) {\n\t\t\t\tthis._depth = true;\n\t\t\t\tthis._stencil = true;\n\t\t\t} else {\n\t\t\t\tthis._depth = false;\n\t\t\t\tthis._stencil = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._depth = options.depth !== undefined ? options.depth : true;\n\t\t\tthis._stencil = options.stencil !== undefined ? options.stencil : false;\n\t\t}\n\n\t\tthis._device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device);\n\t\tthis._samples = options.samples !== undefined ? Math.min(options.samples, this._device.maxSamples) : 1;\n\t\tthis.autoResolve = options.autoResolve !== undefined ? options.autoResolve : true;\n\t\tthis._glResolveFrameBuffer = null;\n\t\tthis._glMsaaColorBuffer = null;\n\t\tthis._glMsaaDepthBuffer = null;\n\t\tthis.name = options.name;\n\n\t\tif (!this.name) {\n\t\t\tvar _this$_colorBuffer2;\n\n\t\t\tthis.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;\n\t\t}\n\n\t\tif (!this.name) {\n\t\t\tvar _this$_depthBuffer2;\n\n\t\t\tthis.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;\n\t\t}\n\n\t\tif (!this.name) {\n\t\t\tthis.name = \"Untitled\";\n\t\t}\n\n\t\tthis.flipY = !!options.flipY;\n\t}\n\n\tdestroy() {\n\t\tconst device = this._device;\n\n\t\tif (device) {\n\t\t\tconst idx = device.targets.indexOf(this);\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tdevice.targets.splice(idx, 1);\n\t\t\t}\n\n\t\t\tthis.destroyFrameBuffers();\n\t\t}\n\t}\n\n\tdestroyFrameBuffers() {\n\t\tconst device = this._device;\n\n\t\tif (device) {\n\t\t\tconst gl = device.gl;\n\n\t\t\tif (this._glFrameBuffer) {\n\t\t\t\tgl.deleteFramebuffer(this._glFrameBuffer);\n\t\t\t\tthis._glFrameBuffer = null;\n\t\t\t}\n\n\t\t\tif (this._glDepthBuffer) {\n\t\t\t\tgl.deleteRenderbuffer(this._glDepthBuffer);\n\t\t\t\tthis._glDepthBuffer = null;\n\t\t\t}\n\n\t\t\tif (this._glResolveFrameBuffer) {\n\t\t\t\tgl.deleteFramebuffer(this._glResolveFrameBuffer);\n\t\t\t\tthis._glResolveFrameBuffer = null;\n\t\t\t}\n\n\t\t\tif (this._glMsaaColorBuffer) {\n\t\t\t\tgl.deleteRenderbuffer(this._glMsaaColorBuffer);\n\t\t\t\tthis._glMsaaColorBuffer = null;\n\t\t\t}\n\n\t\t\tif (this._glMsaaDepthBuffer) {\n\t\t\t\tgl.deleteRenderbuffer(this._glMsaaDepthBuffer);\n\t\t\t\tthis._glMsaaDepthBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroyTextureBuffers() {\n\t\tif (this._depthBuffer) {\n\t\t\tthis._depthBuffer.destroy();\n\n\t\t\tthis._depthBuffer = null;\n\t\t}\n\n\t\tif (this._colorBuffer) {\n\t\t\tthis._colorBuffer.destroy();\n\n\t\t\tthis._colorBuffer = null;\n\t\t}\n\t}\n\n\tloseContext() {\n\t\tthis._glFrameBuffer = undefined;\n\t\tthis._glDepthBuffer = undefined;\n\t\tthis._glResolveFrameBuffer = undefined;\n\t\tthis._glMsaaColorBuffer = undefined;\n\t\tthis._glMsaaDepthBuffer = undefined;\n\t}\n\n\tresolve(color = true, depth = !!this._depthBuffer) {\n\t\tif (!this._device) return;\n\t\tif (!this._device.webgl2) return;\n\t\tconst gl = this._device.gl;\n\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._glFrameBuffer);\n\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer);\n\t\tgl.blitFramebuffer(0, 0, this.width, this.height, 0, 0, this.width, this.height, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);\n\t}\n\n\tcopy(source, color, depth) {\n\t\tif (!this._device) {\n\t\t\tif (source._device) {\n\t\t\t\tthis._device = source._device;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn this._device.copyRenderTarget(source, this, color, depth);\n\t}\n\n\tget colorBuffer() {\n\t\treturn this._colorBuffer;\n\t}\n\n\tget depthBuffer() {\n\t\treturn this._depthBuffer;\n\t}\n\n\tget face() {\n\t\treturn this._face;\n\t}\n\n\tget width() {\n\t\treturn this._colorBuffer ? this._colorBuffer.width : this._depthBuffer.width;\n\t}\n\n\tget height() {\n\t\treturn this._colorBuffer ? this._colorBuffer.height : this._depthBuffer.height;\n\t}\n\n}\n\nfunction areaElement(x, y) {\n\treturn Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\n}\n\nfunction texelCoordSolidAngle(u, v, size) {\n\tlet _u = 2.0 * (u + 0.5) / size - 1.0;\n\n\tlet _v = 2.0 * (v + 0.5) / size - 1.0;\n\n\t_u *= 1.0 - 1.0 / size;\n\t_v *= 1.0 - 1.0 / size;\n\tconst invResolution = 1.0 / size;\n\tconst x0 = _u - invResolution;\n\tconst y0 = _v - invResolution;\n\tconst x1 = _u + invResolution;\n\tconst y1 = _v + invResolution;\n\tlet solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);\n\n\tif (u === 0 && v === 0 || u === size - 1 && v === 0 || u === 0 && v === size - 1 || u === size - 1 && v === size - 1) {\n\t\tsolidAngle /= 3;\n\t} else if (u === 0 || v === 0 || u === size - 1 || v === size - 1) {\n\t\tsolidAngle *= 0.5;\n\t}\n\n\treturn solidAngle;\n}\n\nfunction shFromCubemap(device, source, dontFlipX) {\n\tif (source.format !== PIXELFORMAT_R8_G8_B8_A8) {\n\t\treturn null;\n\t}\n\n\tif (!source._levels[0] || !source._levels[0][0]) {\n\t\treturn null;\n\t}\n\n\tconst cubeSize = source.width;\n\n\tif (!source._levels[0][0].length) {\n\t\tif (source._levels[0][0] instanceof HTMLImageElement) {\n\t\t\tconst shader = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.fullscreenQuadPS, \"fsQuadSimple\");\n\t\t\tconst constantTexSource = device.scope.resolve(\"source\");\n\n\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\tconst img = source._levels[0][face];\n\t\t\t\tconst tex = new Texture(device, {\n\t\t\t\t\tcubemap: false,\n\t\t\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\t\t\tformat: source.format,\n\t\t\t\t\twidth: cubeSize,\n\t\t\t\t\theight: cubeSize,\n\t\t\t\t\tmipmaps: false\n\t\t\t\t});\n\t\t\t\ttex.name = 'prefiltered-cube';\n\t\t\t\ttex._levels[0] = img;\n\t\t\t\ttex.upload();\n\t\t\t\tconst tex2 = new Texture(device, {\n\t\t\t\t\tcubemap: false,\n\t\t\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\t\t\tformat: source.format,\n\t\t\t\t\twidth: cubeSize,\n\t\t\t\t\theight: cubeSize,\n\t\t\t\t\tmipmaps: false\n\t\t\t\t});\n\t\t\t\ttex2.name = 'prefiltered-cube';\n\t\t\t\tconst targ = new RenderTarget({\n\t\t\t\t\tcolorBuffer: tex2,\n\t\t\t\t\tdepth: false\n\t\t\t\t});\n\t\t\t\tconstantTexSource.setValue(tex);\n\t\t\t\tdrawQuadWithShader(device, targ, shader);\n\t\t\t\tconst gl = device.gl;\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, targ._glFrameBuffer);\n\t\t\t\tconst pixels = new Uint8Array(cubeSize * cubeSize * 4);\n\t\t\t\tgl.readPixels(0, 0, tex.width, tex.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\t\t\t\tsource._levels[0][face] = pixels;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst dirs = [];\n\n\tfor (let y = 0; y < cubeSize; y++) {\n\t\tfor (let x = 0; x < cubeSize; x++) {\n\t\t\tconst u = x / (cubeSize - 1) * 2 - 1;\n\t\t\tconst v = y / (cubeSize - 1) * 2 - 1;\n\t\t\tdirs[y * cubeSize + x] = new Vec3(u, v, 1.0).normalize();\n\t\t}\n\t}\n\n\tconst sh = new Float32Array(9 * 3);\n\tconst coef1 = 0;\n\tconst coef2 = 1 * 3;\n\tconst coef3 = 2 * 3;\n\tconst coef4 = 3 * 3;\n\tconst coef5 = 4 * 3;\n\tconst coef6 = 5 * 3;\n\tconst coef7 = 6 * 3;\n\tconst coef8 = 7 * 3;\n\tconst coef9 = 8 * 3;\n\tconst nx = 0;\n\tconst px = 1;\n\tconst ny = 2;\n\tconst py = 3;\n\tconst nz = 4;\n\tconst pz = 5;\n\tlet accum = 0;\n\n\tfor (let face = 0; face < 6; face++) {\n\t\tfor (let y = 0; y < cubeSize; y++) {\n\t\t\tfor (let x = 0; x < cubeSize; x++) {\n\t\t\t\tconst addr = y * cubeSize + x;\n\t\t\t\tconst weight = texelCoordSolidAngle(x, y, cubeSize);\n\t\t\t\tconst weight1 = weight * 4 / 17;\n\t\t\t\tconst weight2 = weight * 8 / 17;\n\t\t\t\tconst weight3 = weight * 15 / 17;\n\t\t\t\tconst weight4 = weight * 5 / 68;\n\t\t\t\tconst weight5 = weight * 15 / 68;\n\t\t\t\tconst dir = dirs[addr];\n\t\t\t\tlet dx, dy, dz;\n\n\t\t\t\tif (face === nx) {\n\t\t\t\t\tdx = dir.z;\n\t\t\t\t\tdy = -dir.y;\n\t\t\t\t\tdz = -dir.x;\n\t\t\t\t} else if (face === px) {\n\t\t\t\t\tdx = -dir.z;\n\t\t\t\t\tdy = -dir.y;\n\t\t\t\t\tdz = dir.x;\n\t\t\t\t} else if (face === ny) {\n\t\t\t\t\tdx = dir.x;\n\t\t\t\t\tdy = dir.z;\n\t\t\t\t\tdz = dir.y;\n\t\t\t\t} else if (face === py) {\n\t\t\t\t\tdx = dir.x;\n\t\t\t\t\tdy = -dir.z;\n\t\t\t\t\tdz = -dir.y;\n\t\t\t\t} else if (face === nz) {\n\t\t\t\t\tdx = dir.x;\n\t\t\t\t\tdy = -dir.y;\n\t\t\t\t\tdz = dir.z;\n\t\t\t\t} else if (face === pz) {\n\t\t\t\t\tdx = -dir.x;\n\t\t\t\t\tdy = -dir.y;\n\t\t\t\t\tdz = -dir.z;\n\t\t\t\t}\n\n\t\t\t\tif (!dontFlipX) dx = -dx;\n\t\t\t\tconst a = source._levels[0][face][addr * 4 + 3] / 255.0;\n\n\t\t\t\tfor (let c = 0; c < 3; c++) {\n\t\t\t\t\tlet value = source._levels[0][face][addr * 4 + c] / 255.0;\n\n\t\t\t\t\tif (source.type === TEXTURETYPE_RGBM) {\n\t\t\t\t\t\tvalue *= a * 8.0;\n\t\t\t\t\t\tvalue *= value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = Math.pow(value, 2.2);\n\t\t\t\t\t}\n\n\t\t\t\t\tsh[coef1 + c] += value * weight1;\n\t\t\t\t\tsh[coef2 + c] += value * weight2 * dx;\n\t\t\t\t\tsh[coef3 + c] += value * weight2 * dy;\n\t\t\t\t\tsh[coef4 + c] += value * weight2 * dz;\n\t\t\t\t\tsh[coef5 + c] += value * weight3 * dx * dz;\n\t\t\t\t\tsh[coef6 + c] += value * weight3 * dz * dy;\n\t\t\t\t\tsh[coef7 + c] += value * weight3 * dy * dx;\n\t\t\t\t\tsh[coef8 + c] += value * weight4 * (3.0 * dz * dz - 1.0);\n\t\t\t\t\tsh[coef9 + c] += value * weight5 * (dx * dx - dy * dy);\n\t\t\t\t\taccum += weight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (let c = 0; c < sh.length; c++) {\n\t\tsh[c] *= 4 * Math.PI / accum;\n\t}\n\n\treturn sh;\n}\n\nclass IndexBuffer {\n\tconstructor(graphicsDevice, format, numIndices, usage = BUFFER_STATIC, initialData) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.format = format;\n\t\tthis.numIndices = numIndices;\n\t\tthis.usage = usage;\n\t\tconst gl = this.device.gl;\n\t\tlet bytesPerIndex;\n\n\t\tif (format === INDEXFORMAT_UINT8) {\n\t\t\tbytesPerIndex = 1;\n\t\t\tthis.glFormat = gl.UNSIGNED_BYTE;\n\t\t} else if (format === INDEXFORMAT_UINT16) {\n\t\t\tbytesPerIndex = 2;\n\t\t\tthis.glFormat = gl.UNSIGNED_SHORT;\n\t\t} else if (format === INDEXFORMAT_UINT32) {\n\t\t\tbytesPerIndex = 4;\n\t\t\tthis.glFormat = gl.UNSIGNED_INT;\n\t\t}\n\n\t\tthis.bytesPerIndex = bytesPerIndex;\n\t\tthis.numBytes = this.numIndices * bytesPerIndex;\n\n\t\tif (initialData) {\n\t\t\tthis.setData(initialData);\n\t\t} else {\n\t\t\tthis.storage = new ArrayBuffer(this.numBytes);\n\t\t}\n\n\t\tgraphicsDevice._vram.ib += this.numBytes;\n\t\tthis.device.buffers.push(this);\n\t}\n\n\tdestroy() {\n\t\tconst device = this.device;\n\t\tconst idx = device.buffers.indexOf(this);\n\n\t\tif (idx !== -1) {\n\t\t\tdevice.buffers.splice(idx, 1);\n\t\t}\n\n\t\tif (this.bufferId) {\n\t\t\tconst gl = this.device.gl;\n\t\t\tgl.deleteBuffer(this.bufferId);\n\t\t\tthis.device._vram.ib -= this.storage.byteLength;\n\t\t\tthis.bufferId = null;\n\n\t\t\tif (this.device.indexBuffer === this) {\n\t\t\t\tthis.device.indexBuffer = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tloseContext() {\n\t\tthis.bufferId = undefined;\n\t}\n\n\tgetFormat() {\n\t\treturn this.format;\n\t}\n\n\tgetNumIndices() {\n\t\treturn this.numIndices;\n\t}\n\n\tlock() {\n\t\treturn this.storage;\n\t}\n\n\tunlock() {\n\t\tconst gl = this.device.gl;\n\n\t\tif (!this.bufferId) {\n\t\t\tthis.bufferId = gl.createBuffer();\n\t\t}\n\n\t\tlet glUsage;\n\n\t\tswitch (this.usage) {\n\t\t\tcase BUFFER_STATIC:\n\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_DYNAMIC:\n\t\t\t\tglUsage = gl.DYNAMIC_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_STREAM:\n\t\t\t\tglUsage = gl.STREAM_DRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase BUFFER_GPUDYNAMIC:\n\t\t\t\tif (this.device.webgl2) {\n\t\t\t\t\tglUsage = gl.DYNAMIC_COPY;\n\t\t\t\t} else {\n\t\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufferId);\n\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.storage, glUsage);\n\t}\n\n\tsetData(data) {\n\t\tif (data.byteLength !== this.numBytes) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.storage = data;\n\t\tthis.unlock();\n\t\treturn true;\n\t}\n\n\t_lockTypedArray() {\n\t\tconst lock = this.lock();\n\t\tconst indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);\n\t\treturn indices;\n\t}\n\n\twriteData(data, count) {\n\t\tconst indices = this._lockTypedArray();\n\n\t\tif (data.length > count) {\n\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\tdata = data.subarray(0, count);\n\t\t\t\tindices.set(data);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < count; i++) indices[i] = data[i];\n\t\t\t}\n\t\t} else {\n\t\t\tindices.set(data);\n\t\t}\n\n\t\tthis.unlock();\n\t}\n\n\treadData(data) {\n\t\tconst indices = this._lockTypedArray();\n\n\t\tconst count = this.numIndices;\n\n\t\tif (ArrayBuffer.isView(data)) {\n\t\t\tdata.set(indices);\n\t\t} else {\n\t\t\tdata.length = 0;\n\n\t\t\tfor (let i = 0; i < count; i++) data[i] = indices[i];\n\t\t}\n\n\t\treturn count;\n\t}\n\n}\n\nfunction set1(a) {\n\tthis.array[this.index] = a;\n}\n\nfunction set2(a, b) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n}\n\nfunction set3(a, b, c) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n\tthis.array[this.index + 2] = c;\n}\n\nfunction set4(a, b, c, d) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n\tthis.array[this.index + 2] = c;\n\tthis.array[this.index + 3] = d;\n}\n\nfunction arraySet1(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n}\n\nfunction arraySet2(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n}\n\nfunction arraySet3(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n\tthis.array[index + 2] = inputArray[inputIndex + 2];\n}\n\nfunction arraySet4(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n\tthis.array[index + 2] = inputArray[inputIndex + 2];\n\tthis.array[index + 3] = inputArray[inputIndex + 3];\n}\n\nfunction arrayGet1(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n}\n\nfunction arrayGet2(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n}\n\nfunction arrayGet3(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n\toutputArray[outputIndex + 2] = this.array[offset + 2];\n}\n\nfunction arrayGet4(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n\toutputArray[outputIndex + 2] = this.array[offset + 2];\n\toutputArray[outputIndex + 3] = this.array[offset + 3];\n}\n\nclass VertexIteratorAccessor {\n\tconstructor(buffer, vertexElement, vertexFormat) {\n\t\tthis.index = 0;\n\t\tthis.numComponents = vertexElement.numComponents;\n\n\t\tif (vertexFormat.interleaved) {\n\t\t\tthis.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);\n\t\t} else {\n\t\t\tthis.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);\n\t\t}\n\n\t\tthis.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;\n\n\t\tswitch (vertexElement.numComponents) {\n\t\t\tcase 1:\n\t\t\t\tthis.set = set1;\n\t\t\t\tthis.getToArray = arrayGet1;\n\t\t\t\tthis.setFromArray = arraySet1;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tthis.set = set2;\n\t\t\t\tthis.getToArray = arrayGet2;\n\t\t\t\tthis.setFromArray = arraySet2;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tthis.set = set3;\n\t\t\t\tthis.getToArray = arrayGet3;\n\t\t\t\tthis.setFromArray = arraySet3;\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tthis.set = set4;\n\t\t\t\tthis.getToArray = arrayGet4;\n\t\t\t\tthis.setFromArray = arraySet4;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tget(offset) {\n\t\treturn this.array[this.index + offset];\n\t}\n\n\tset(a, b, c, d) {}\n\n\tgetToArray(offset, outputArray, outputIndex) {}\n\n\tsetFromArray(index, inputArray, inputIndex) {}\n\n}\n\nclass VertexIterator {\n\tconstructor(vertexBuffer) {\n\t\tthis.vertexBuffer = vertexBuffer;\n\t\tthis.vertexFormatSize = vertexBuffer.getFormat().size;\n\t\tthis.buffer = this.vertexBuffer.lock();\n\t\tthis.accessors = [];\n\t\tthis.element = {};\n\t\tconst vertexFormat = this.vertexBuffer.getFormat();\n\n\t\tfor (let i = 0; i < vertexFormat.elements.length; i++) {\n\t\t\tconst vertexElement = vertexFormat.elements[i];\n\t\t\tthis.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);\n\t\t\tthis.element[vertexElement.name] = this.accessors[i];\n\t\t}\n\t}\n\n\tnext(count = 1) {\n\t\tlet i = 0;\n\t\tconst accessors = this.accessors;\n\t\tconst numAccessors = this.accessors.length;\n\n\t\twhile (i < numAccessors) {\n\t\t\tconst accessor = accessors[i++];\n\t\t\taccessor.index += count * accessor.stride;\n\t\t}\n\t}\n\n\tend() {\n\t\tthis.vertexBuffer.unlock();\n\t}\n\n\twriteData(semantic, data, numVertices) {\n\t\tconst element = this.element[semantic];\n\n\t\tif (element) {\n\t\t\tif (numVertices > this.vertexBuffer.numVertices) {\n\t\t\t\tnumVertices = this.vertexBuffer.numVertices;\n\t\t\t}\n\n\t\t\tconst numComponents = element.numComponents;\n\n\t\t\tif (this.vertexBuffer.getFormat().interleaved) {\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor (let i = 0; i < numVertices; i++) {\n\t\t\t\t\telement.setFromArray(index, data, i * numComponents);\n\t\t\t\t\tindex += element.stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (data.length > numVertices * numComponents) {\n\t\t\t\t\tconst copyCount = numVertices * numComponents;\n\n\t\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\t\tdata = data.subarray(0, copyCount);\n\t\t\t\t\t\telement.array.set(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0; i < copyCount; i++) element.array[i] = data[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.array.set(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treadData(semantic, data) {\n\t\tconst element = this.element[semantic];\n\t\tlet count = 0;\n\n\t\tif (element) {\n\t\t\tcount = this.vertexBuffer.numVertices;\n\t\t\tlet i;\n\t\t\tconst numComponents = element.numComponents;\n\n\t\t\tif (this.vertexBuffer.getFormat().interleaved) {\n\t\t\t\tif (Array.isArray(data)) data.length = 0;\n\t\t\t\telement.index = 0;\n\t\t\t\tlet offset = 0;\n\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\telement.getToArray(offset, data, i * numComponents);\n\t\t\t\t\toffset += element.stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\tdata.set(element.array);\n\t\t\t\t} else {\n\t\t\t\t\tdata.length = 0;\n\t\t\t\t\tconst copyCount = count * numComponents;\n\n\t\t\t\t\tfor (i = 0; i < copyCount; i++) data[i] = element.array[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n}\n\nconst primitive = {\n\ttype: PRIMITIVE_TRISTRIP,\n\tbase: 0,\n\tcount: 4,\n\tindexed: false\n};\n\nclass PostEffect$1 {\n\tconstructor(graphicsDevice) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.shader = null;\n\t\tthis.vertexBuffer = createFullscreenQuad(graphicsDevice);\n\t\tthis.needsDepthBuffer = false;\n\t\tthis.depthMap = null;\n\t}\n\n\trender(inputTarget, outputTarget, rect) {}\n\n}\n\nfunction createFullscreenQuad(device) {\n\tconst vertexFormat = new VertexFormat(device, [{\n\t\tsemantic: SEMANTIC_POSITION,\n\t\tcomponents: 2,\n\t\ttype: TYPE_FLOAT32\n\t}]);\n\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, 4);\n\tconst iterator = new VertexIterator(vertexBuffer);\n\titerator.element[SEMANTIC_POSITION].set(-1.0, -1.0);\n\titerator.next();\n\titerator.element[SEMANTIC_POSITION].set(1.0, -1.0);\n\titerator.next();\n\titerator.element[SEMANTIC_POSITION].set(-1.0, 1.0);\n\titerator.next();\n\titerator.element[SEMANTIC_POSITION].set(1.0, 1.0);\n\titerator.end();\n\treturn vertexBuffer;\n}\n\nfunction drawFullscreenQuad(device, target, vertexBuffer, shader, rect) {\n\tconst oldRt = device.getRenderTarget();\n\tdevice.setRenderTarget(target);\n\tdevice.updateBegin();\n\tlet w = target ? target.width : device.width;\n\tlet h = target ? target.height : device.height;\n\tlet x = 0;\n\tlet y = 0;\n\n\tif (rect) {\n\t\tx = rect.x * w;\n\t\ty = rect.y * h;\n\t\tw *= rect.z;\n\t\th *= rect.w;\n\t}\n\n\tconst oldVx = device.vx;\n\tconst oldVy = device.vy;\n\tconst oldVw = device.vw;\n\tconst oldVh = device.vh;\n\tdevice.setViewport(x, y, w, h);\n\tconst oldSx = device.sx;\n\tconst oldSy = device.sy;\n\tconst oldSw = device.sw;\n\tconst oldSh = device.sh;\n\tdevice.setScissor(x, y, w, h);\n\tconst oldBlending = device.getBlending();\n\tconst oldDepthTest = device.getDepthTest();\n\tconst oldDepthWrite = device.getDepthWrite();\n\tconst oldCullMode = device.getCullMode();\n\tconst oldWR = device.writeRed;\n\tconst oldWG = device.writeGreen;\n\tconst oldWB = device.writeBlue;\n\tconst oldWA = device.writeAlpha;\n\tdevice.setBlending(false);\n\tdevice.setDepthTest(false);\n\tdevice.setDepthWrite(false);\n\tdevice.setCullMode(CULLFACE_NONE);\n\tdevice.setColorWrite(true, true, true, true);\n\tdevice.setVertexBuffer(vertexBuffer, 0);\n\tdevice.setShader(shader);\n\tdevice.draw(primitive);\n\tdevice.setBlending(oldBlending);\n\tdevice.setDepthTest(oldDepthTest);\n\tdevice.setDepthWrite(oldDepthWrite);\n\tdevice.setCullMode(oldCullMode);\n\tdevice.setColorWrite(oldWR, oldWG, oldWB, oldWA);\n\tdevice.updateEnd();\n\tdevice.setRenderTarget(oldRt);\n\tdevice.updateBegin();\n\tdevice.setViewport(oldVx, oldVy, oldVw, oldVh);\n\tdevice.setScissor(oldSx, oldSy, oldSw, oldSh);\n}\n\nclass TransformFeedback {\n\tconstructor(inputBuffer, usage = BUFFER_GPUDYNAMIC) {\n\t\tthis.device = inputBuffer.device;\n\t\tconst gl = this.device.gl;\n\t\tthis._inputBuffer = inputBuffer;\n\n\t\tif (usage === BUFFER_GPUDYNAMIC && inputBuffer.usage !== usage) {\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, inputBuffer.bufferId);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, inputBuffer.storage, gl.DYNAMIC_COPY);\n\t\t}\n\n\t\tthis._outputBuffer = new VertexBuffer(inputBuffer.device, inputBuffer.format, inputBuffer.numVertices, usage, inputBuffer.storage);\n\t}\n\n\tstatic createShader(graphicsDevice, vsCode, name) {\n\t\treturn createShaderFromCode(graphicsDevice, vsCode, null, name, true);\n\t}\n\n\tdestroy() {\n\t\tthis._outputBuffer.destroy();\n\t}\n\n\tprocess(shader, swap = true) {\n\t\tconst device = this.device;\n\t\tconst oldRt = device.getRenderTarget();\n\t\tdevice.setRenderTarget(null);\n\t\tdevice.updateBegin();\n\t\tdevice.setVertexBuffer(this._inputBuffer, 0);\n\t\tdevice.setRaster(false);\n\t\tdevice.setTransformFeedbackBuffer(this._outputBuffer);\n\t\tdevice.setShader(shader);\n\t\tdevice.draw({\n\t\t\ttype: PRIMITIVE_POINTS,\n\t\t\tbase: 0,\n\t\t\tcount: this._inputBuffer.numVertices,\n\t\t\tindexed: false\n\t\t});\n\t\tdevice.setTransformFeedbackBuffer(null);\n\t\tdevice.setRaster(true);\n\t\tdevice.updateEnd();\n\t\tdevice.setRenderTarget(oldRt);\n\n\t\tif (swap) {\n\t\t\tlet tmp = this._inputBuffer.bufferId;\n\t\t\tthis._inputBuffer.bufferId = this._outputBuffer.bufferId;\n\t\t\tthis._outputBuffer.bufferId = tmp;\n\t\t\ttmp = this._inputBuffer._vao;\n\t\t\tthis._inputBuffer._vao = this._outputBuffer._vao;\n\t\t\tthis._outputBuffer._vao = tmp;\n\t\t}\n\t}\n\n\tget inputBuffer() {\n\t\treturn this._inputBuffer;\n\t}\n\n\tget outputBuffer() {\n\t\treturn this._outputBuffer;\n\t}\n\n}\n\nclass RefCountedObject {\n\tconstructor() {\n\t\tthis._refCount = 0;\n\t}\n\n\tincRefCount() {\n\t\tthis._refCount++;\n\t}\n\n\tdecRefCount() {\n\t\tthis._refCount--;\n\t}\n\n\tget refCount() {\n\t\treturn this._refCount;\n\t}\n\n}\n\nlet currentApplication;\n\nfunction getApplication() {\n\treturn currentApplication;\n}\n\nfunction setApplication(app) {\n\tcurrentApplication = app;\n}\n\nlet id$1 = 0;\n\nclass GeometryData {\n\tconstructor() {\n\t\tthis.initDefaults();\n\t}\n\n\tinitDefaults() {\n\t\tthis.recreate = false;\n\t\tthis.verticesUsage = BUFFER_STATIC;\n\t\tthis.indicesUsage = BUFFER_STATIC;\n\t\tthis.maxVertices = 0;\n\t\tthis.maxIndices = 0;\n\t\tthis.vertexCount = 0;\n\t\tthis.indexCount = 0;\n\t\tthis.vertexStreamsUpdated = false;\n\t\tthis.indexStreamUpdated = false;\n\t\tthis.vertexStreamDictionary = {};\n\t\tthis.indices = null;\n\t}\n\n\t_changeVertexCount(count, semantic) {\n\t\tif (!this.vertexCount) {\n\t\t\tthis.vertexCount = count;\n\t\t}\n\t}\n\n}\n\nGeometryData.DEFAULT_COMPONENTS_POSITION = 3;\nGeometryData.DEFAULT_COMPONENTS_NORMAL = 3;\nGeometryData.DEFAULT_COMPONENTS_UV = 2;\nGeometryData.DEFAULT_COMPONENTS_COLORS = 4;\n\nclass GeometryVertexStream {\n\tconstructor(data, componentCount, dataType, dataTypeNormalize) {\n\t\tthis.data = data;\n\t\tthis.componentCount = componentCount;\n\t\tthis.dataType = dataType;\n\t\tthis.dataTypeNormalize = dataTypeNormalize;\n\t}\n\n}\n\nclass Mesh extends RefCountedObject {\n\tconstructor(graphicsDevice) {\n\t\tsuper();\n\t\tthis.id = id$1++;\n\t\tthis.device = graphicsDevice || getApplication().graphicsDevice;\n\t\tthis.vertexBuffer = null;\n\t\tthis.indexBuffer = [null];\n\t\tthis.primitive = [{\n\t\t\ttype: 0,\n\t\t\tbase: 0,\n\t\t\tcount: 0\n\t\t}];\n\t\tthis.skin = null;\n\t\tthis._morph = null;\n\t\tthis._geometryData = null;\n\t\tthis._aabb = new BoundingBox();\n\t\tthis.boneAabb = null;\n\t}\n\n\tset morph(morph) {\n\t\tif (morph !== this._morph) {\n\t\t\tif (this._morph) {\n\t\t\t\tthis._morph.decRefCount();\n\t\t\t}\n\n\t\t\tthis._morph = morph;\n\n\t\t\tif (morph) {\n\t\t\t\tmorph.incRefCount();\n\t\t\t}\n\t\t}\n\t}\n\n\tget morph() {\n\t\treturn this._morph;\n\t}\n\n\tset aabb(aabb) {\n\t\tthis._aabb = aabb;\n\t}\n\n\tget aabb() {\n\t\treturn this._aabb;\n\t}\n\n\tdestroy() {\n\t\tconst morph = this.morph;\n\n\t\tif (morph) {\n\t\t\tthis.morph = null;\n\n\t\t\tif (morph.refCount < 1) {\n\t\t\t\tmorph.destroy();\n\t\t\t}\n\t\t}\n\n\t\tif (this.vertexBuffer) {\n\t\t\tthis.vertexBuffer.destroy();\n\t\t\tthis.vertexBuffer = null;\n\t\t}\n\n\t\tfor (let j = 0; j < this.indexBuffer.length; j++) {\n\t\t\tthis._destroyIndexBuffer(j);\n\t\t}\n\n\t\tthis.indexBuffer.length = 0;\n\t\tthis._geometryData = null;\n\t}\n\n\t_destroyIndexBuffer(index) {\n\t\tif (this.indexBuffer[index]) {\n\t\t\tthis.indexBuffer[index].destroy();\n\t\t\tthis.indexBuffer[index] = null;\n\t\t}\n\t}\n\n\t_initBoneAabbs(morphTargets) {\n\t\tthis.boneAabb = [];\n\t\tthis.boneUsed = [];\n\t\tlet x, y, z;\n\t\tlet bMax, bMin;\n\t\tconst boneMin = [];\n\t\tconst boneMax = [];\n\t\tconst boneUsed = this.boneUsed;\n\t\tconst numBones = this.skin.boneNames.length;\n\t\tlet maxMorphX, maxMorphY, maxMorphZ;\n\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tboneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n\t\t\tboneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\t\t}\n\n\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\tconst posElement = iterator.element[SEMANTIC_POSITION];\n\t\tconst weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];\n\t\tconst indicesElement = iterator.element[SEMANTIC_BLENDINDICES];\n\t\tconst numVerts = this.vertexBuffer.numVertices;\n\n\t\tfor (let j = 0; j < numVerts; j++) {\n\t\t\tfor (let k = 0; k < 4; k++) {\n\t\t\t\tconst boneWeight = weightsElement.array[weightsElement.index + k];\n\n\t\t\t\tif (boneWeight > 0) {\n\t\t\t\t\tconst boneIndex = indicesElement.array[indicesElement.index + k];\n\t\t\t\t\tboneUsed[boneIndex] = true;\n\t\t\t\t\tx = posElement.array[posElement.index];\n\t\t\t\t\ty = posElement.array[posElement.index + 1];\n\t\t\t\t\tz = posElement.array[posElement.index + 2];\n\t\t\t\t\tbMax = boneMax[boneIndex];\n\t\t\t\t\tbMin = boneMin[boneIndex];\n\t\t\t\t\tif (bMin.x > x) bMin.x = x;\n\t\t\t\t\tif (bMin.y > y) bMin.y = y;\n\t\t\t\t\tif (bMin.z > z) bMin.z = z;\n\t\t\t\t\tif (bMax.x < x) bMax.x = x;\n\t\t\t\t\tif (bMax.y < y) bMax.y = y;\n\t\t\t\t\tif (bMax.z < z) bMax.z = z;\n\n\t\t\t\t\tif (morphTargets) {\n\t\t\t\t\t\tlet minMorphX = maxMorphX = x;\n\t\t\t\t\t\tlet minMorphY = maxMorphY = y;\n\t\t\t\t\t\tlet minMorphZ = maxMorphZ = z;\n\n\t\t\t\t\t\tfor (let l = 0; l < morphTargets.length; l++) {\n\t\t\t\t\t\t\tconst target = morphTargets[l];\n\t\t\t\t\t\t\tconst dx = target.deltaPositions[j * 3];\n\t\t\t\t\t\t\tconst dy = target.deltaPositions[j * 3 + 1];\n\t\t\t\t\t\t\tconst dz = target.deltaPositions[j * 3 + 2];\n\n\t\t\t\t\t\t\tif (dx < 0) {\n\t\t\t\t\t\t\t\tminMorphX += dx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphX += dx;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (dy < 0) {\n\t\t\t\t\t\t\t\tminMorphY += dy;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphY += dy;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (dz < 0) {\n\t\t\t\t\t\t\t\tminMorphZ += dz;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphZ += dz;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (bMin.x > minMorphX) bMin.x = minMorphX;\n\t\t\t\t\t\tif (bMin.y > minMorphY) bMin.y = minMorphY;\n\t\t\t\t\t\tif (bMin.z > minMorphZ) bMin.z = minMorphZ;\n\t\t\t\t\t\tif (bMax.x < maxMorphX) bMax.x = maxMorphX;\n\t\t\t\t\t\tif (bMax.y < maxMorphY) bMax.y = maxMorphY;\n\t\t\t\t\t\tif (bMax.z < maxMorphZ) bMax.z = maxMorphZ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titerator.next();\n\t\t}\n\n\t\tconst positionElement = this.vertexBuffer.getFormat().elements.find(e => e.name === SEMANTIC_POSITION);\n\n\t\tif (positionElement && positionElement.normalize) {\n\t\t\tconst func = (() => {\n\t\t\t\tswitch (positionElement.dataType) {\n\t\t\t\t\tcase TYPE_INT8:\n\t\t\t\t\t\treturn x => Math.max(x / 127.0, -1.0);\n\n\t\t\t\t\tcase TYPE_UINT8:\n\t\t\t\t\t\treturn x => x / 255.0;\n\n\t\t\t\t\tcase TYPE_INT16:\n\t\t\t\t\t\treturn x => Math.max(x / 32767.0, -1.0);\n\n\t\t\t\t\tcase TYPE_UINT16:\n\t\t\t\t\t\treturn x => x / 65535.0;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn x => x;\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\t\tif (boneUsed[i]) {\n\t\t\t\t\tconst min = boneMin[i];\n\t\t\t\t\tconst max = boneMax[i];\n\t\t\t\t\tmin.set(func(min.x), func(min.y), func(min.z));\n\t\t\t\t\tmax.set(func(max.x), func(max.y), func(max.z));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tconst aabb = new BoundingBox();\n\t\t\taabb.setMinMax(boneMin[i], boneMax[i]);\n\t\t\tthis.boneAabb.push(aabb);\n\t\t}\n\t}\n\n\t_initGeometryData() {\n\t\tif (!this._geometryData) {\n\t\t\tthis._geometryData = new GeometryData();\n\n\t\t\tif (this.vertexBuffer) {\n\t\t\t\tthis._geometryData.vertexCount = this.vertexBuffer.numVertices;\n\t\t\t\tthis._geometryData.maxVertices = this.vertexBuffer.numVertices;\n\t\t\t}\n\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tthis._geometryData.indexCount = this.indexBuffer[0].numIndices;\n\t\t\t\tthis._geometryData.maxIndices = this.indexBuffer[0].numIndices;\n\t\t\t}\n\t\t}\n\t}\n\n\tclear(verticesDynamic, indicesDynamic, maxVertices = 0, maxIndices = 0) {\n\t\tthis._initGeometryData();\n\n\t\tthis._geometryData.initDefaults();\n\n\t\tthis._geometryData.recreate = true;\n\t\tthis._geometryData.maxVertices = maxVertices;\n\t\tthis._geometryData.maxIndices = maxIndices;\n\t\tthis._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;\n\t\tthis._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;\n\t}\n\n\tsetVertexStream(semantic, data, componentCount, numVertices, dataType = TYPE_FLOAT32, dataTypeNormalize = false) {\n\t\tthis._initGeometryData();\n\n\t\tconst vertexCount = numVertices || data.length / componentCount;\n\n\t\tthis._geometryData._changeVertexCount(vertexCount, semantic);\n\n\t\tthis._geometryData.vertexStreamsUpdated = true;\n\t\tthis._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize);\n\t}\n\n\tgetVertexStream(semantic, data) {\n\t\tlet count = 0;\n\t\tlet done = false;\n\n\t\tif (this._geometryData) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\n\t\t\tif (stream) {\n\t\t\t\tdone = true;\n\t\t\t\tcount = this._geometryData.vertexCount;\n\n\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\tdata.set(stream.data);\n\t\t\t\t} else {\n\t\t\t\t\tdata.length = 0;\n\t\t\t\t\tdata.push(stream.data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!done) {\n\t\t\tif (this.vertexBuffer) {\n\t\t\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\t\t\tcount = iterator.readData(semantic, data);\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tsetPositions(positions, componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\n\tsetNormals(normals, componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\n\tsetUvs(channel, uvs, componentCount = GeometryData.DEFAULT_COMPONENTS_UV, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\n\tsetColors(colors, componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\n\tsetColors32(colors, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);\n\t}\n\n\tsetIndices(indices, numIndices) {\n\t\tthis._initGeometryData();\n\n\t\tthis._geometryData.indexStreamUpdated = true;\n\t\tthis._geometryData.indices = indices;\n\t\tthis._geometryData.indexCount = numIndices || indices.length;\n\t}\n\n\tgetPositions(positions) {\n\t\treturn this.getVertexStream(SEMANTIC_POSITION, positions);\n\t}\n\n\tgetNormals(normals) {\n\t\treturn this.getVertexStream(SEMANTIC_NORMAL, normals);\n\t}\n\n\tgetUvs(channel, uvs) {\n\t\treturn this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);\n\t}\n\n\tgetColors(colors) {\n\t\treturn this.getVertexStream(SEMANTIC_COLOR, colors);\n\t}\n\n\tgetIndices(indices) {\n\t\tlet count = 0;\n\n\t\tif (this._geometryData && this._geometryData.indices) {\n\t\t\tconst streamIndices = this._geometryData.indices;\n\t\t\tcount = this._geometryData.indexCount;\n\n\t\t\tif (ArrayBuffer.isView(indices)) {\n\t\t\t\tindices.set(streamIndices);\n\t\t\t} else {\n\t\t\t\tindices.length = 0;\n\t\t\t\tindices.push(streamIndices);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tconst indexBuffer = this.indexBuffer[0];\n\t\t\t\tcount = indexBuffer.readData(indices);\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tupdate(primitiveType = PRIMITIVE_TRIANGLES, updateBoundingBox = true) {\n\t\tif (this._geometryData) {\n\t\t\tif (updateBoundingBox) {\n\t\t\t\tconst stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];\n\n\t\t\t\tif (stream) {\n\t\t\t\t\tif (stream.componentCount === 3) {\n\t\t\t\t\t\tthis._aabb.compute(stream.data, this._geometryData.vertexCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet destroyVB = this._geometryData.recreate;\n\n\t\t\tif (this._geometryData.vertexCount > this._geometryData.maxVertices) {\n\t\t\t\tdestroyVB = true;\n\t\t\t\tthis._geometryData.maxVertices = this._geometryData.vertexCount;\n\t\t\t}\n\n\t\t\tif (destroyVB) {\n\t\t\t\tif (this.vertexBuffer) {\n\t\t\t\t\tthis.vertexBuffer.destroy();\n\t\t\t\t\tthis.vertexBuffer = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet destroyIB = this._geometryData.recreate;\n\n\t\t\tif (this._geometryData.indexCount > this._geometryData.maxIndices) {\n\t\t\t\tdestroyIB = true;\n\t\t\t\tthis._geometryData.maxIndices = this._geometryData.indexCount;\n\t\t\t}\n\n\t\t\tif (destroyIB) {\n\t\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\t\tthis.indexBuffer[0].destroy();\n\t\t\t\t\tthis.indexBuffer[0] = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._geometryData.vertexStreamsUpdated) {\n\t\t\t\tthis._updateVertexBuffer();\n\t\t\t}\n\n\t\t\tif (this._geometryData.indexStreamUpdated) {\n\t\t\t\tthis._updateIndexBuffer();\n\t\t\t}\n\n\t\t\tthis.primitive[0].type = primitiveType;\n\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tif (this._geometryData.indexStreamUpdated) {\n\t\t\t\t\tthis.primitive[0].count = this._geometryData.indexCount;\n\t\t\t\t\tthis.primitive[0].indexed = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._geometryData.vertexStreamsUpdated) {\n\t\t\t\t\tthis.primitive[0].count = this._geometryData.vertexCount;\n\t\t\t\t\tthis.primitive[0].indexed = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._geometryData.vertexCount = 0;\n\t\t\tthis._geometryData.indexCount = 0;\n\t\t\tthis._geometryData.vertexStreamsUpdated = false;\n\t\t\tthis._geometryData.indexStreamUpdated = false;\n\t\t\tthis._geometryData.recreate = false;\n\t\t\tthis.updateRenderStates();\n\t\t}\n\t}\n\n\t_buildVertexFormat(vertexCount) {\n\t\tconst vertexDesc = [];\n\n\t\tfor (const semantic in this._geometryData.vertexStreamDictionary) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\t\t\tvertexDesc.push({\n\t\t\t\tsemantic: semantic,\n\t\t\t\tcomponents: stream.componentCount,\n\t\t\t\ttype: stream.dataType,\n\t\t\t\tnormalize: stream.dataTypeNormalize\n\t\t\t});\n\t\t}\n\n\t\treturn new VertexFormat(this.device, vertexDesc, vertexCount);\n\t}\n\n\t_updateVertexBuffer() {\n\t\tif (!this.vertexBuffer) {\n\t\t\tconst allocateVertexCount = this._geometryData.maxVertices;\n\n\t\t\tconst format = this._buildVertexFormat(allocateVertexCount);\n\n\t\t\tthis.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, this._geometryData.verticesUsage);\n\t\t}\n\n\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\tconst numVertices = this._geometryData.vertexCount;\n\n\t\tfor (const semantic in this._geometryData.vertexStreamDictionary) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\t\t\titerator.writeData(semantic, stream.data, numVertices);\n\t\t\tdelete this._geometryData.vertexStreamDictionary[semantic];\n\t\t}\n\n\t\titerator.end();\n\t}\n\n\t_updateIndexBuffer() {\n\t\tif (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {\n\t\t\tconst createFormat = this._geometryData.maxVertices > 0xffff ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;\n\t\t\tthis.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage);\n\t\t}\n\n\t\tconst srcIndices = this._geometryData.indices;\n\n\t\tif (srcIndices) {\n\t\t\tconst indexBuffer = this.indexBuffer[0];\n\t\t\tindexBuffer.writeData(srcIndices, this._geometryData.indexCount);\n\t\t\tthis._geometryData.indices = null;\n\t\t}\n\t}\n\n\tprepareRenderState(renderStyle) {\n\t\tif (renderStyle === RENDERSTYLE_WIREFRAME) {\n\t\t\tthis.generateWireframe();\n\t\t} else if (renderStyle === RENDERSTYLE_POINTS) {\n\t\t\tthis.primitive[RENDERSTYLE_POINTS] = {\n\t\t\t\ttype: PRIMITIVE_POINTS,\n\t\t\t\tbase: 0,\n\t\t\t\tcount: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,\n\t\t\t\tindexed: false\n\t\t\t};\n\t\t}\n\t}\n\n\tupdateRenderStates() {\n\t\tif (this.primitive[RENDERSTYLE_POINTS]) {\n\t\t\tthis.prepareRenderState(RENDERSTYLE_POINTS);\n\t\t}\n\n\t\tif (this.primitive[RENDERSTYLE_WIREFRAME]) {\n\t\t\tthis.prepareRenderState(RENDERSTYLE_WIREFRAME);\n\t\t}\n\t}\n\n\tgenerateWireframe() {\n\t\tthis._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);\n\n\t\tconst lines = [];\n\t\tlet format;\n\n\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\tconst offsets = [[0, 1], [1, 2], [2, 0]];\n\t\t\tconst base = this.primitive[RENDERSTYLE_SOLID].base;\n\t\t\tconst count = this.primitive[RENDERSTYLE_SOLID].count;\n\t\t\tconst indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];\n\t\t\tconst srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);\n\t\t\tconst uniqueLineIndices = {};\n\n\t\t\tfor (let j = base; j < base + count; j += 3) {\n\t\t\t\tfor (let k = 0; k < 3; k++) {\n\t\t\t\t\tconst i1 = srcIndices[j + offsets[k][0]];\n\t\t\t\t\tconst i2 = srcIndices[j + offsets[k][1]];\n\t\t\t\t\tconst line = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;\n\n\t\t\t\t\tif (uniqueLineIndices[line] === undefined) {\n\t\t\t\t\t\tuniqueLineIndices[line] = 0;\n\t\t\t\t\t\tlines.push(i1, i2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tformat = indexBuffer.format;\n\t\t} else {\n\t\t\tfor (let i = 0; i < this.vertexBuffer.numVertices; i += 3) {\n\t\t\t\tlines.push(i, i + 1, i + 1, i + 2, i + 2, i);\n\t\t\t}\n\n\t\t\tformat = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;\n\t\t}\n\n\t\tconst wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);\n\t\tconst dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);\n\t\tdstIndices.set(lines);\n\t\twireBuffer.unlock();\n\t\tthis.primitive[RENDERSTYLE_WIREFRAME] = {\n\t\t\ttype: PRIMITIVE_LINES,\n\t\t\tbase: 0,\n\t\t\tcount: lines.length,\n\t\t\tindexed: true\n\t\t};\n\t\tthis.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;\n\t}\n\n}\n\nconst primitiveUv1Padding = 4.0 / 64;\nconst primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nconst shapePrimitives = [];\n\nfunction calculateNormals(positions, indices) {\n\tconst triangleCount = indices.length / 3;\n\tconst vertexCount = positions.length / 3;\n\tconst p1 = new Vec3();\n\tconst p2 = new Vec3();\n\tconst p3 = new Vec3();\n\tconst p1p2 = new Vec3();\n\tconst p1p3 = new Vec3();\n\tconst faceNormal = new Vec3();\n\tconst normals = [];\n\n\tfor (let i = 0; i < positions.length; i++) {\n\t\tnormals[i] = 0;\n\t}\n\n\tfor (let i = 0; i < triangleCount; i++) {\n\t\tconst i1 = indices[i * 3];\n\t\tconst i2 = indices[i * 3 + 1];\n\t\tconst i3 = indices[i * 3 + 2];\n\t\tp1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n\t\tp2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n\t\tp3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n\t\tp1p2.sub2(p2, p1);\n\t\tp1p3.sub2(p3, p1);\n\t\tfaceNormal.cross(p1p2, p1p3).normalize();\n\t\tnormals[i1 * 3] += faceNormal.x;\n\t\tnormals[i1 * 3 + 1] += faceNormal.y;\n\t\tnormals[i1 * 3 + 2] += faceNormal.z;\n\t\tnormals[i2 * 3] += faceNormal.x;\n\t\tnormals[i2 * 3 + 1] += faceNormal.y;\n\t\tnormals[i2 * 3 + 2] += faceNormal.z;\n\t\tnormals[i3 * 3] += faceNormal.x;\n\t\tnormals[i3 * 3 + 1] += faceNormal.y;\n\t\tnormals[i3 * 3 + 2] += faceNormal.z;\n\t}\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tconst nx = normals[i * 3];\n\t\tconst ny = normals[i * 3 + 1];\n\t\tconst nz = normals[i * 3 + 2];\n\t\tconst invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n\t\tnormals[i * 3] *= invLen;\n\t\tnormals[i * 3 + 1] *= invLen;\n\t\tnormals[i * 3 + 2] *= invLen;\n\t}\n\n\treturn normals;\n}\n\nfunction calculateTangents(positions, normals, uvs, indices) {\n\tconst triangleCount = indices.length / 3;\n\tconst vertexCount = positions.length / 3;\n\tconst v1 = new Vec3();\n\tconst v2 = new Vec3();\n\tconst v3 = new Vec3();\n\tconst w1 = new Vec2();\n\tconst w2 = new Vec2();\n\tconst w3 = new Vec2();\n\tconst sdir = new Vec3();\n\tconst tdir = new Vec3();\n\tconst tan1 = new Float32Array(vertexCount * 3);\n\tconst tan2 = new Float32Array(vertexCount * 3);\n\tconst tangents = [];\n\n\tfor (let i = 0; i < triangleCount; i++) {\n\t\tconst i1 = indices[i * 3];\n\t\tconst i2 = indices[i * 3 + 1];\n\t\tconst i3 = indices[i * 3 + 2];\n\t\tv1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n\t\tv2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n\t\tv3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n\t\tw1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);\n\t\tw2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);\n\t\tw3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);\n\t\tconst x1 = v2.x - v1.x;\n\t\tconst x2 = v3.x - v1.x;\n\t\tconst y1 = v2.y - v1.y;\n\t\tconst y2 = v3.y - v1.y;\n\t\tconst z1 = v2.z - v1.z;\n\t\tconst z2 = v3.z - v1.z;\n\t\tconst s1 = w2.x - w1.x;\n\t\tconst s2 = w3.x - w1.x;\n\n\t\tconst _t = w2.y - w1.y;\n\n\t\tconst _t2 = w3.y - w1.y;\n\n\t\tconst area = s1 * _t2 - s2 * _t;\n\n\t\tif (area === 0) {\n\t\t\tsdir.set(0, 1, 0);\n\t\t\ttdir.set(1, 0, 0);\n\t\t} else {\n\t\t\tconst r = 1 / area;\n\t\t\tsdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);\n\t\t\ttdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n\t\t}\n\n\t\ttan1[i1 * 3 + 0] += sdir.x;\n\t\ttan1[i1 * 3 + 1] += sdir.y;\n\t\ttan1[i1 * 3 + 2] += sdir.z;\n\t\ttan1[i2 * 3 + 0] += sdir.x;\n\t\ttan1[i2 * 3 + 1] += sdir.y;\n\t\ttan1[i2 * 3 + 2] += sdir.z;\n\t\ttan1[i3 * 3 + 0] += sdir.x;\n\t\ttan1[i3 * 3 + 1] += sdir.y;\n\t\ttan1[i3 * 3 + 2] += sdir.z;\n\t\ttan2[i1 * 3 + 0] += tdir.x;\n\t\ttan2[i1 * 3 + 1] += tdir.y;\n\t\ttan2[i1 * 3 + 2] += tdir.z;\n\t\ttan2[i2 * 3 + 0] += tdir.x;\n\t\ttan2[i2 * 3 + 1] += tdir.y;\n\t\ttan2[i2 * 3 + 2] += tdir.z;\n\t\ttan2[i3 * 3 + 0] += tdir.x;\n\t\ttan2[i3 * 3 + 1] += tdir.y;\n\t\ttan2[i3 * 3 + 2] += tdir.z;\n\t}\n\n\tconst t1 = new Vec3();\n\tconst t2 = new Vec3();\n\tconst n = new Vec3();\n\tconst temp = new Vec3();\n\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tn.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);\n\t\tt1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);\n\t\tt2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);\n\t\tconst ndott = n.dot(t1);\n\t\ttemp.copy(n).mulScalar(ndott);\n\t\ttemp.sub2(t1, temp).normalize();\n\t\ttangents[i * 4] = temp.x;\n\t\ttangents[i * 4 + 1] = temp.y;\n\t\ttangents[i * 4 + 2] = temp.z;\n\t\ttemp.cross(n, t1);\n\t\ttangents[i * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;\n\t}\n\n\treturn tangents;\n}\n\nfunction createMesh$1(device, positions, opts) {\n\tconst mesh = new Mesh(device);\n\tmesh.setPositions(positions);\n\n\tif (opts) {\n\t\tif (opts.normals) {\n\t\t\tmesh.setNormals(opts.normals);\n\t\t}\n\n\t\tif (opts.tangents) {\n\t\t\tmesh.setVertexStream(SEMANTIC_TANGENT, opts.tangents, 4);\n\t\t}\n\n\t\tif (opts.colors) {\n\t\t\tmesh.setColors32(opts.colors);\n\t\t}\n\n\t\tif (opts.uvs) {\n\t\t\tmesh.setUvs(0, opts.uvs);\n\t\t}\n\n\t\tif (opts.uvs1) {\n\t\t\tmesh.setUvs(1, opts.uvs1);\n\t\t}\n\n\t\tif (opts.blendIndices) {\n\t\t\tmesh.setVertexStream(SEMANTIC_BLENDINDICES, opts.blendIndices, 4, opts.blendIndices.length / 4, TYPE_UINT8);\n\t\t}\n\n\t\tif (opts.blendWeights) {\n\t\t\tmesh.setVertexStream(SEMANTIC_BLENDWEIGHT, opts.blendWeights, 4);\n\t\t}\n\n\t\tif (opts.indices) {\n\t\t\tmesh.setIndices(opts.indices);\n\t\t}\n\t}\n\n\tmesh.update();\n\treturn mesh;\n}\n\nfunction createTorus(device, opts) {\n\tconst rc = opts && opts.tubeRadius !== undefined ? opts.tubeRadius : 0.2;\n\tconst rt = opts && opts.ringRadius !== undefined ? opts.ringRadius : 0.3;\n\tconst segments = opts && opts.segments !== undefined ? opts.segments : 30;\n\tconst sides = opts && opts.sides !== undefined ? opts.sides : 20;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst indices = [];\n\n\tfor (let i = 0; i <= sides; i++) {\n\t\tfor (let j = 0; j <= segments; j++) {\n\t\t\tconst x = Math.cos(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));\n\t\t\tconst y = Math.sin(2 * Math.PI * i / sides) * rc;\n\t\t\tconst z = Math.sin(2 * Math.PI * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));\n\t\t\tconst nx = Math.cos(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);\n\t\t\tconst ny = Math.sin(2 * Math.PI * i / sides);\n\t\t\tconst nz = Math.sin(2 * Math.PI * j / segments) * Math.cos(2 * Math.PI * i / sides);\n\t\t\tconst u = i / sides;\n\t\t\tconst v = 1 - j / segments;\n\t\t\tpositions.push(x, y, z);\n\t\t\tnormals.push(nx, ny, nz);\n\t\t\tuvs.push(u, 1.0 - v);\n\n\t\t\tif (i < sides && j < segments) {\n\t\t\t\tconst first = i * (segments + 1) + j;\n\t\t\t\tconst second = (i + 1) * (segments + 1) + j;\n\t\t\t\tconst third = i * (segments + 1) + (j + 1);\n\t\t\t\tconst fourth = (i + 1) * (segments + 1) + (j + 1);\n\t\t\t\tindices.push(first, second, third);\n\t\t\t\tindices.push(second, fourth, third);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst options = {\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tindices: indices\n\t};\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(positions, normals, uvs, indices);\n\t}\n\n\treturn createMesh$1(device, positions, options);\n}\n\nfunction _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {\n\tconst pos = new Vec3();\n\tconst bottomToTop = new Vec3();\n\tconst norm = new Vec3();\n\tconst top = new Vec3();\n\tconst bottom = new Vec3();\n\tconst tangent = new Vec3();\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst uvs1 = [];\n\tconst indices = [];\n\tlet offset;\n\n\tif (height > 0) {\n\t\tfor (let i = 0; i <= heightSegments; i++) {\n\t\t\tfor (let j = 0; j <= capSegments; j++) {\n\t\t\t\tconst theta = j / capSegments * 2 * Math.PI - Math.PI;\n\t\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\t\tbottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);\n\t\t\t\ttop.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);\n\t\t\t\tpos.lerp(bottom, top, i / heightSegments);\n\t\t\t\tbottomToTop.sub2(top, bottom).normalize();\n\t\t\t\ttangent.set(cosTheta, 0, -sinTheta);\n\t\t\t\tnorm.cross(tangent, bottomToTop).normalize();\n\t\t\t\tpositions.push(pos.x, pos.y, pos.z);\n\t\t\t\tnormals.push(norm.x, norm.y, norm.z);\n\t\t\t\tlet u = j / capSegments;\n\t\t\t\tlet v = i / heightSegments;\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tconst _v = v;\n\t\t\t\tv = u;\n\t\t\t\tu = _v;\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\n\t\t\t\tif (i < heightSegments && j < capSegments) {\n\t\t\t\t\tconst first = i * (capSegments + 1) + j;\n\t\t\t\t\tconst second = i * (capSegments + 1) + (j + 1);\n\t\t\t\t\tconst third = (i + 1) * (capSegments + 1) + j;\n\t\t\t\t\tconst fourth = (i + 1) * (capSegments + 1) + (j + 1);\n\t\t\t\t\tindices.push(first, second, third);\n\t\t\t\t\tindices.push(second, fourth, third);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (roundedCaps) {\n\t\tconst latitudeBands = Math.floor(capSegments / 2);\n\t\tconst longitudeBands = capSegments;\n\t\tconst capOffset = height / 2;\n\n\t\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\t\tconst theta = lat * Math.PI * 0.5 / latitudeBands;\n\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\tconst cosTheta = Math.cos(theta);\n\n\t\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\t\tconst x = cosPhi * sinTheta;\n\t\t\t\tconst y = cosTheta;\n\t\t\t\tconst z = sinPhi * sinTheta;\n\t\t\t\tlet u = 1 - lon / longitudeBands;\n\t\t\t\tlet v = 1 - lat / latitudeBands;\n\t\t\t\tpositions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);\n\t\t\t\tnormals.push(x, y, z);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += 1.0 / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t}\n\t\t}\n\n\t\toffset = (heightSegments + 1) * (capSegments + 1);\n\n\t\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\t\tconst second = first + longitudeBands + 1;\n\t\t\t\tindices.push(offset + first + 1, offset + second, offset + first);\n\t\t\t\tindices.push(offset + first + 1, offset + second + 1, offset + second);\n\t\t\t}\n\t\t}\n\n\t\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\t\tconst theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;\n\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\tconst cosTheta = Math.cos(theta);\n\n\t\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\t\tconst x = cosPhi * sinTheta;\n\t\t\t\tconst y = cosTheta;\n\t\t\t\tconst z = sinPhi * sinTheta;\n\t\t\t\tlet u = 1 - lon / longitudeBands;\n\t\t\t\tlet v = 1 - lat / latitudeBands;\n\t\t\t\tpositions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);\n\t\t\t\tnormals.push(x, y, z);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += 2.0 / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t}\n\t\t}\n\n\t\toffset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);\n\n\t\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\t\tconst second = first + longitudeBands + 1;\n\t\t\t\tindices.push(offset + first + 1, offset + second, offset + first);\n\t\t\t\tindices.push(offset + first + 1, offset + second + 1, offset + second);\n\t\t\t}\n\t\t}\n\t} else {\n\t\toffset = (heightSegments + 1) * (capSegments + 1);\n\n\t\tif (baseRadius > 0) {\n\t\t\tfor (let i = 0; i < capSegments; i++) {\n\t\t\t\tconst theta = i / capSegments * 2 * Math.PI;\n\t\t\t\tconst x = Math.sin(theta);\n\t\t\t\tconst y = -height / 2;\n\t\t\t\tconst z = Math.cos(theta);\n\t\t\t\tlet u = 1 - (x + 1) / 2;\n\t\t\t\tlet v = (z + 1) / 2;\n\t\t\t\tpositions.push(x * baseRadius, y, z * baseRadius);\n\t\t\t\tnormals.push(0, -1, 0);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += 1 / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\n\t\t\t\tif (i > 1) {\n\t\t\t\t\tindices.push(offset, offset + i, offset + i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toffset += capSegments;\n\n\t\tif (peakRadius > 0) {\n\t\t\tfor (let i = 0; i < capSegments; i++) {\n\t\t\t\tconst theta = i / capSegments * 2 * Math.PI;\n\t\t\t\tconst x = Math.sin(theta);\n\t\t\t\tconst y = height / 2;\n\t\t\t\tconst z = Math.cos(theta);\n\t\t\t\tlet u = 1 - (x + 1) / 2;\n\t\t\t\tlet v = (z + 1) / 2;\n\t\t\t\tpositions.push(x * peakRadius, y, z * peakRadius);\n\t\t\t\tnormals.push(0, 1, 0);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += 2 / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\n\t\t\t\tif (i > 1) {\n\t\t\t\t\tindices.push(offset, offset + i - 1, offset + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tpositions: positions,\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tuvs1: uvs1,\n\t\tindices: indices\n\t};\n}\n\nfunction createCylinder(device, opts) {\n\tlet radius = opts && (opts.radius || opts.baseRadius);\n\tradius = radius !== undefined ? radius : 0.5;\n\tconst height = opts && opts.height !== undefined ? opts.height : 1.0;\n\tconst heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;\n\tconst capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 20;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\n\tconst options = _createConeData(radius, radius, height, heightSegments, capSegments, false);\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n\t}\n\n\treturn createMesh$1(device, options.positions, options);\n}\n\nfunction createCapsule(device, opts) {\n\tconst radius = opts && opts.radius !== undefined ? opts.radius : 0.3;\n\tconst height = opts && opts.height !== undefined ? opts.height : 1.0;\n\tconst heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;\n\tconst sides = opts && opts.sides !== undefined ? opts.sides : 20;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\n\tconst options = _createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true);\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n\t}\n\n\treturn createMesh$1(device, options.positions, options);\n}\n\nfunction createCone(device, opts) {\n\tconst baseRadius = opts && opts.baseRadius !== undefined ? opts.baseRadius : 0.5;\n\tconst peakRadius = opts && opts.peakRadius !== undefined ? opts.peakRadius : 0.0;\n\tconst height = opts && opts.height !== undefined ? opts.height : 1.0;\n\tconst heightSegments = opts && opts.heightSegments !== undefined ? opts.heightSegments : 5;\n\tconst capSegments = opts && opts.capSegments !== undefined ? opts.capSegments : 18;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\n\tconst options = _createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false);\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(options.positions, options.normals, options.uvs, options.indices);\n\t}\n\n\treturn createMesh$1(device, options.positions, options);\n}\n\nfunction createSphere(device, opts) {\n\tconst radius = opts && opts.radius !== undefined ? opts.radius : 0.5;\n\tconst latitudeBands = opts && opts.latitudeBands !== undefined ? opts.latitudeBands : 16;\n\tconst longitudeBands = opts && opts.longitudeBands !== undefined ? opts.longitudeBands : 16;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst indices = [];\n\n\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\tconst theta = lat * Math.PI / latitudeBands;\n\t\tconst sinTheta = Math.sin(theta);\n\t\tconst cosTheta = Math.cos(theta);\n\n\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\tconst x = cosPhi * sinTheta;\n\t\t\tconst y = cosTheta;\n\t\t\tconst z = sinPhi * sinTheta;\n\t\t\tconst u = 1 - lon / longitudeBands;\n\t\t\tconst v = 1 - lat / latitudeBands;\n\t\t\tpositions.push(x * radius, y * radius, z * radius);\n\t\t\tnormals.push(x, y, z);\n\t\t\tuvs.push(u, 1 - v);\n\t\t}\n\t}\n\n\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\tconst second = first + longitudeBands + 1;\n\t\t\tindices.push(first + 1, second, first);\n\t\t\tindices.push(first + 1, second + 1, second);\n\t\t}\n\t}\n\n\tconst options = {\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tuvs1: uvs,\n\t\tindices: indices\n\t};\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(positions, normals, uvs, indices);\n\t}\n\n\treturn createMesh$1(device, positions, options);\n}\n\nfunction createPlane(device, opts) {\n\tconst he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec2(0.5, 0.5);\n\tconst ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 5;\n\tconst ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 5;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst indices = [];\n\tlet vcounter = 0;\n\n\tfor (let i = 0; i <= ws; i++) {\n\t\tfor (let j = 0; j <= ls; j++) {\n\t\t\tconst x = -he.x + 2 * he.x * i / ws;\n\t\t\tconst y = 0.0;\n\t\t\tconst z = -(-he.y + 2 * he.y * j / ls);\n\t\t\tconst u = i / ws;\n\t\t\tconst v = j / ls;\n\t\t\tpositions.push(x, y, z);\n\t\t\tnormals.push(0, 1, 0);\n\t\t\tuvs.push(u, 1 - v);\n\n\t\t\tif (i < ws && j < ls) {\n\t\t\t\tindices.push(vcounter + ls + 1, vcounter + 1, vcounter);\n\t\t\t\tindices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);\n\t\t\t}\n\n\t\t\tvcounter++;\n\t\t}\n\t}\n\n\tconst options = {\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tuvs1: uvs,\n\t\tindices: indices\n\t};\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(positions, normals, uvs, indices);\n\t}\n\n\treturn createMesh$1(device, positions, options);\n}\n\nfunction createBox(device, opts) {\n\tconst he = opts && opts.halfExtents !== undefined ? opts.halfExtents : new Vec3(0.5, 0.5, 0.5);\n\tconst ws = opts && opts.widthSegments !== undefined ? opts.widthSegments : 1;\n\tconst ls = opts && opts.lengthSegments !== undefined ? opts.lengthSegments : 1;\n\tconst hs = opts && opts.heightSegments !== undefined ? opts.heightSegments : 1;\n\tconst calcTangents = opts && opts.calculateTangents !== undefined ? opts.calculateTangents : false;\n\tconst corners = [new Vec3(-he.x, -he.y, he.z), new Vec3(he.x, -he.y, he.z), new Vec3(he.x, he.y, he.z), new Vec3(-he.x, he.y, he.z), new Vec3(he.x, -he.y, -he.z), new Vec3(-he.x, -he.y, -he.z), new Vec3(-he.x, he.y, -he.z), new Vec3(he.x, he.y, -he.z)];\n\tconst faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];\n\tconst faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];\n\tconst sides = {\n\t\tFRONT: 0,\n\t\tBACK: 1,\n\t\tTOP: 2,\n\t\tBOTTOM: 3,\n\t\tRIGHT: 4,\n\t\tLEFT: 5\n\t};\n\tconst positions = [];\n\tconst normals = [];\n\tconst uvs = [];\n\tconst uvs1 = [];\n\tconst indices = [];\n\tlet vcounter = 0;\n\n\tconst generateFace = (side, uSegments, vSegments) => {\n\t\tconst temp1 = new Vec3();\n\t\tconst temp2 = new Vec3();\n\t\tconst temp3 = new Vec3();\n\t\tconst r = new Vec3();\n\n\t\tfor (let i = 0; i <= uSegments; i++) {\n\t\t\tfor (let j = 0; j <= vSegments; j++) {\n\t\t\t\ttemp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);\n\t\t\t\ttemp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);\n\t\t\t\ttemp3.sub2(temp2, corners[faceAxes[side][0]]);\n\t\t\t\tr.add2(temp1, temp3);\n\t\t\t\tlet u = i / uSegments;\n\t\t\t\tlet v = j / vSegments;\n\t\t\t\tpositions.push(r.x, r.y, r.z);\n\t\t\t\tnormals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\tu /= 3;\n\t\t\t\tv /= 3;\n\t\t\t\tu += side % 3 / 3;\n\t\t\t\tv += Math.floor(side / 3) / 3;\n\t\t\t\tuvs1.push(u, 1 - v);\n\n\t\t\t\tif (i < uSegments && j < vSegments) {\n\t\t\t\t\tindices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n\t\t\t\t\tindices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);\n\t\t\t\t}\n\n\t\t\t\tvcounter++;\n\t\t\t}\n\t\t}\n\t};\n\n\tgenerateFace(sides.FRONT, ws, hs);\n\tgenerateFace(sides.BACK, ws, hs);\n\tgenerateFace(sides.TOP, ws, ls);\n\tgenerateFace(sides.BOTTOM, ws, ls);\n\tgenerateFace(sides.RIGHT, ls, hs);\n\tgenerateFace(sides.LEFT, ls, hs);\n\tconst options = {\n\t\tnormals: normals,\n\t\tuvs: uvs,\n\t\tuvs1: uvs1,\n\t\tindices: indices\n\t};\n\n\tif (calcTangents) {\n\t\toptions.tangents = calculateTangents(positions, normals, uvs, indices);\n\t}\n\n\treturn createMesh$1(device, positions, options);\n}\n\nfunction getShapePrimitive(device, type) {\n\tlet primData = null;\n\n\tfor (let i = 0; i < shapePrimitives.length; i++) {\n\t\tif (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {\n\t\t\tprimData = shapePrimitives[i].primData;\n\t\t}\n\t}\n\n\tif (!primData) {\n\t\tlet mesh, area;\n\n\t\tswitch (type) {\n\t\t\tcase 'box':\n\t\t\t\tmesh = createBox(device, {\n\t\t\t\t\thalfExtents: new Vec3(0.5, 0.5, 0.5)\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: 2,\n\t\t\t\t\ty: 2,\n\t\t\t\t\tz: 2,\n\t\t\t\t\tuv: 2.0 / 3\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'capsule':\n\t\t\t\tmesh = createCapsule(device, {\n\t\t\t\t\tradius: 0.5,\n\t\t\t\t\theight: 2\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI * 2,\n\t\t\t\t\ty: Math.PI,\n\t\t\t\t\tz: Math.PI * 2,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3 * 2\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'cone':\n\t\t\t\tmesh = createCone(device, {\n\t\t\t\t\tbaseRadius: 0.5,\n\t\t\t\t\tpeakRadius: 0,\n\t\t\t\t\theight: 1\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: 2.54,\n\t\t\t\t\ty: 2.54,\n\t\t\t\t\tz: 2.54,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'cylinder':\n\t\t\t\tmesh = createCylinder(device, {\n\t\t\t\t\tradius: 0.5,\n\t\t\t\t\theight: 1\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI,\n\t\t\t\t\ty: 0.79 * 2,\n\t\t\t\t\tz: Math.PI,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3 * 2\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'plane':\n\t\t\t\tmesh = createPlane(device, {\n\t\t\t\t\thalfExtents: new Vec2(0.5, 0.5),\n\t\t\t\t\twidthSegments: 1,\n\t\t\t\t\tlengthSegments: 1\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 1,\n\t\t\t\t\tz: 0,\n\t\t\t\t\tuv: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'sphere':\n\t\t\t\tmesh = createSphere(device, {\n\t\t\t\t\tradius: 0.5\n\t\t\t\t});\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI,\n\t\t\t\t\ty: Math.PI,\n\t\t\t\t\tz: Math.PI,\n\t\t\t\t\tuv: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Invalid primitive type: \" + type);\n\t\t}\n\n\t\tmesh.incRefCount();\n\t\tprimData = {\n\t\t\tmesh: mesh,\n\t\t\tarea: area\n\t\t};\n\t\tshapePrimitives.push({\n\t\t\ttype: type,\n\t\t\tdevice: device,\n\t\t\tprimData: primData\n\t\t});\n\t}\n\n\treturn primData;\n}\n\nclass BasicMaterial extends Material {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.color = new Color(1, 1, 1, 1);\n\t\tthis.colorUniform = new Float32Array(4);\n\t\tthis.colorMap = null;\n\t\tthis.vertexColors = false;\n\t}\n\n\tcopy(source) {\n\t\tsuper.copy(source);\n\t\tthis.color.copy(source.color);\n\t\tthis.colorMap = source.colorMap;\n\t\tthis.vertexColors = source.vertexColors;\n\t\treturn this;\n\t}\n\n\tupdateUniforms(device, scene) {\n\t\tthis.clearParameters();\n\t\tthis.colorUniform[0] = this.color.r;\n\t\tthis.colorUniform[1] = this.color.g;\n\t\tthis.colorUniform[2] = this.color.b;\n\t\tthis.colorUniform[3] = this.color.a;\n\t\tthis.setParameter('uColor', this.colorUniform);\n\n\t\tif (this.colorMap) {\n\t\t\tthis.setParameter('texture_diffuseMap', this.colorMap);\n\t\t}\n\t}\n\n\tupdateShader(device, scene, objDefs, staticLightList, pass, sortedLights) {\n\t\tconst options = {\n\t\t\tskin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,\n\t\t\tscreenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,\n\t\t\tuseInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,\n\t\t\tuseMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,\n\t\t\tuseMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,\n\t\t\tuseMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,\n\t\t\tvertexColors: this.vertexColors,\n\t\t\tdiffuseMap: !!this.colorMap,\n\t\t\tpass: pass\n\t\t};\n\t\tconst library = device.getProgramLibrary();\n\t\tthis.shader = library.getProgram('basic', options);\n\t}\n\n}\n\nclass Batch {\n\tconstructor(meshInstances, dynamic, batchGroupId) {\n\t\tthis.origMeshInstances = meshInstances;\n\t\tthis._aabb = new BoundingBox();\n\t\tthis.meshInstance = null;\n\t\tthis.dynamic = dynamic;\n\t\tthis.batchGroupId = batchGroupId;\n\t}\n\n\tdestroy(scene, layers) {\n\t\tif (this.meshInstance) {\n\t\t\tthis.removeFromLayers(scene, layers);\n\t\t\tthis.meshInstance.destroy();\n\t\t}\n\t}\n\n\taddToLayers(scene, layers) {\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances([this.meshInstance]);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveFromLayers(scene, layers) {\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeMeshInstances([this.meshInstance]);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateBoundingBox() {\n\t\tthis._aabb.copy(this.origMeshInstances[0].aabb);\n\n\t\tfor (let i = 1; i < this.origMeshInstances.length; i++) {\n\t\t\tthis._aabb.add(this.origMeshInstances[i].aabb);\n\t\t}\n\n\t\tthis.meshInstance.aabb = this._aabb;\n\t\tthis.meshInstance._aabbVer = 0;\n\t}\n\n}\n\nclass BatchGroup {\n\tconstructor(id, name, dynamic, maxAabbSize, layers = [LAYERID_WORLD]) {\n\t\tthis.dynamic = dynamic;\n\t\tthis.maxAabbSize = maxAabbSize;\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.layers = layers;\n\t\tthis._ui = false;\n\t\tthis._sprite = false;\n\t\tthis._obj = {\n\t\t\tmodel: [],\n\t\t\telement: [],\n\t\t\tsprite: [],\n\t\t\trender: []\n\t\t};\n\t}\n\n}\n\nBatchGroup.MODEL = 'model';\nBatchGroup.ELEMENT = 'element';\nBatchGroup.SPRITE = 'sprite';\nBatchGroup.RENDER = 'render';\n\nconst _invMatrix = new Mat4();\n\nclass SkinInstance {\n\tconstructor(skin) {\n\t\tthis.bones = void 0;\n\t\tthis._dirty = true;\n\t\tthis._rootBone = null;\n\t\tthis._skinUpdateIndex = -1;\n\t\tthis._updateBeforeCull = true;\n\n\t\tif (skin) {\n\t\t\tthis.initSkin(skin);\n\t\t}\n\t}\n\n\tset rootBone(rootBone) {\n\t\tthis._rootBone = rootBone;\n\t}\n\n\tget rootBone() {\n\t\treturn this._rootBone;\n\t}\n\n\tinit(device, numBones) {\n\t\tif (device.supportsBoneTextures) {\n\t\t\tconst numPixels = numBones * 3;\n\t\t\tlet width = Math.ceil(Math.sqrt(numPixels));\n\t\t\twidth = math.roundUp(width, 3);\n\t\t\tconst height = Math.ceil(numPixels / width);\n\t\t\tthis.boneTexture = new Texture(device, {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tformat: PIXELFORMAT_RGBA32F,\n\t\t\t\tmipmaps: false,\n\t\t\t\tminFilter: FILTER_NEAREST,\n\t\t\t\tmagFilter: FILTER_NEAREST\n\t\t\t});\n\t\t\tthis.boneTexture.name = 'skin';\n\t\t\tthis.matrixPalette = this.boneTexture.lock();\n\t\t} else {\n\t\t\tthis.matrixPalette = new Float32Array(numBones * 12);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this.boneTexture) {\n\t\t\tthis.boneTexture.destroy();\n\t\t\tthis.boneTexture = null;\n\t\t}\n\t}\n\n\tresolve(rootBone, entity) {\n\t\tthis.rootBone = rootBone;\n\t\tconst skin = this.skin;\n\t\tconst bones = [];\n\n\t\tfor (let j = 0; j < skin.boneNames.length; j++) {\n\t\t\tconst boneName = skin.boneNames[j];\n\t\t\tlet bone = rootBone.findByName(boneName);\n\n\t\t\tif (!bone) {\n\t\t\t\tbone = entity;\n\t\t\t}\n\n\t\t\tbones.push(bone);\n\t\t}\n\n\t\tthis.bones = bones;\n\t}\n\n\tinitSkin(skin) {\n\t\tthis.skin = skin;\n\t\tthis.bones = [];\n\t\tconst numBones = skin.inverseBindPose.length;\n\t\tthis.init(skin.device, numBones);\n\t\tthis.matrices = [];\n\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tthis.matrices[i] = new Mat4();\n\t\t}\n\t}\n\n\tuploadBones(device) {\n\t\tif (device.supportsBoneTextures) {\n\t\t\tthis.boneTexture.lock();\n\t\t\tthis.boneTexture.unlock();\n\t\t}\n\t}\n\n\t_updateMatrices(rootNode, skinUpdateIndex) {\n\t\tif (this._skinUpdateIndex !== skinUpdateIndex) {\n\t\t\tthis._skinUpdateIndex = skinUpdateIndex;\n\n\t\t\t_invMatrix.copy(rootNode.getWorldTransform()).invert();\n\n\t\t\tfor (let i = this.bones.length - 1; i >= 0; i--) {\n\t\t\t\tthis.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());\n\t\t\t\tthis.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateMatrices(rootNode, skinUpdateIndex) {\n\t\tif (this._updateBeforeCull) {\n\t\t\tthis._updateMatrices(rootNode, skinUpdateIndex);\n\t\t}\n\t}\n\n\tupdateMatrixPalette(rootNode, skinUpdateIndex) {\n\t\tthis._updateMatrices(rootNode, skinUpdateIndex);\n\n\t\tconst mp = this.matrixPalette;\n\t\tconst count = this.bones.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pe = this.matrices[i].data;\n\t\t\tconst base = i * 12;\n\t\t\tmp[base] = pe[0];\n\t\t\tmp[base + 1] = pe[4];\n\t\t\tmp[base + 2] = pe[8];\n\t\t\tmp[base + 3] = pe[12];\n\t\t\tmp[base + 4] = pe[1];\n\t\t\tmp[base + 5] = pe[5];\n\t\t\tmp[base + 6] = pe[9];\n\t\t\tmp[base + 7] = pe[13];\n\t\t\tmp[base + 8] = pe[2];\n\t\t\tmp[base + 9] = pe[6];\n\t\t\tmp[base + 10] = pe[10];\n\t\t\tmp[base + 11] = pe[14];\n\t\t}\n\n\t\tthis.uploadBones(this.skin.device);\n\t}\n\n}\n\nclass SkinBatchInstance extends SkinInstance {\n\tconstructor(device, nodes, rootNode) {\n\t\tsuper();\n\t\tconst numBones = nodes.length;\n\t\tthis.init(device, numBones);\n\t\tthis.device = device;\n\t\tthis.rootNode = rootNode;\n\t\tthis.bones = nodes;\n\t}\n\n\tupdateMatrices(rootNode, skinUpdateIndex) {}\n\n\tupdateMatrixPalette(rootNode, skinUpdateIndex) {\n\t\tconst mp = this.matrixPalette;\n\t\tconst count = this.bones.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pe = this.bones[i].getWorldTransform().data;\n\t\t\tconst base = i * 12;\n\t\t\tmp[base] = pe[0];\n\t\t\tmp[base + 1] = pe[4];\n\t\t\tmp[base + 2] = pe[8];\n\t\t\tmp[base + 3] = pe[12];\n\t\t\tmp[base + 4] = pe[1];\n\t\t\tmp[base + 5] = pe[5];\n\t\t\tmp[base + 6] = pe[9];\n\t\t\tmp[base + 7] = pe[13];\n\t\t\tmp[base + 8] = pe[2];\n\t\t\tmp[base + 9] = pe[6];\n\t\t\tmp[base + 10] = pe[10];\n\t\t\tmp[base + 11] = pe[14];\n\t\t}\n\n\t\tthis.uploadBones(this.device);\n\t}\n\n}\n\nclass RefCountedCache {\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\tdestroy() {\n\t\tthis.cache.forEach((refCount, object) => {\n\t\t\tobject.destroy();\n\t\t});\n\t\tthis.cache.clear();\n\t}\n\n\tincRef(object) {\n\t\tconst refCount = (this.cache.get(object) || 0) + 1;\n\t\tthis.cache.set(object, refCount);\n\t}\n\n\tdecRef(object) {\n\t\tif (object) {\n\t\t\tlet refCount = this.cache.get(object);\n\n\t\t\tif (refCount) {\n\t\t\t\trefCount--;\n\n\t\t\t\tif (refCount === 0) {\n\t\t\t\t\tthis.cache.delete(object);\n\t\t\t\t\tobject.destroy();\n\t\t\t\t} else {\n\t\t\t\t\tthis.cache.set(object, refCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass LightmapCache {\n\tstatic incRef(texture) {\n\t\tthis.cache.incRef(texture);\n\t}\n\n\tstatic decRef(texture) {\n\t\tthis.cache.decRef(texture);\n\t}\n\n\tstatic destroy() {\n\t\tthis.cache.destroy();\n\t}\n\n}\n\nLightmapCache.cache = new RefCountedCache();\n\nconst _tmpAabb = new BoundingBox();\n\nconst _tempBoneAabb = new BoundingBox();\n\nconst _tempSphere = new BoundingSphere();\n\nconst _meshSet = new Set();\n\nclass InstancingData {\n\tconstructor(numObjects) {\n\t\tthis.count = numObjects;\n\t\tthis.vertexBuffer = null;\n\t}\n\n}\n\nclass Command {\n\tconstructor(layer, blendType, command) {\n\t\tthis._key = [];\n\t\tthis._key[SORTKEY_FORWARD] = getKey(layer, blendType, true, 0);\n\t\tthis.command = command;\n\t}\n\n\tset key(val) {\n\t\tthis._key[SORTKEY_FORWARD] = val;\n\t}\n\n\tget key() {\n\t\treturn this._key[SORTKEY_FORWARD];\n\t}\n\n}\n\nclass MeshInstance {\n\tconstructor(mesh, material, node = null) {\n\t\tif (mesh instanceof GraphNode) {\n\t\t\tconst temp = mesh;\n\t\t\tmesh = material;\n\t\t\tmaterial = node;\n\t\t\tnode = temp;\n\t\t}\n\n\t\tthis._key = [0, 0];\n\t\tthis._shader = [null, null, null];\n\t\tthis.isStatic = false;\n\t\tthis._staticLightList = null;\n\t\tthis._staticSource = null;\n\t\tthis.node = node;\n\t\tthis._mesh = mesh;\n\t\tmesh.incRefCount();\n\t\tthis.material = material;\n\t\tthis._shaderDefs = MASK_AFFECT_DYNAMIC << 16;\n\t\tthis._shaderDefs |= mesh.vertexBuffer.format.hasUv0 ? SHADERDEF_UV0 : 0;\n\t\tthis._shaderDefs |= mesh.vertexBuffer.format.hasUv1 ? SHADERDEF_UV1 : 0;\n\t\tthis._shaderDefs |= mesh.vertexBuffer.format.hasColor ? SHADERDEF_VCOLOR : 0;\n\t\tthis._shaderDefs |= mesh.vertexBuffer.format.hasTangents ? SHADERDEF_TANGENTS : 0;\n\t\tthis._lightHash = 0;\n\t\tthis.visible = true;\n\t\tthis.layer = LAYER_WORLD;\n\t\tthis._renderStyle = RENDERSTYLE_SOLID;\n\t\tthis.castShadow = false;\n\t\tthis._receiveShadow = true;\n\t\tthis._screenSpace = false;\n\t\tthis._noDepthDrawGl1 = false;\n\t\tthis.cull = true;\n\t\tthis.pick = true;\n\t\tthis._updateAabb = true;\n\t\tthis._updateAabbFunc = null;\n\t\tthis._calculateSortDistance = null;\n\t\tthis.updateKey();\n\t\tthis._skinInstance = null;\n\t\tthis._morphInstance = null;\n\t\tthis.instancingData = null;\n\t\tthis._customAabb = null;\n\t\tthis.aabb = new BoundingBox();\n\t\tthis._aabbVer = -1;\n\t\tthis.drawOrder = 0;\n\t\tthis.visibleThisFrame = 0;\n\t\tthis.isVisibleFunc = null;\n\t\tthis.parameters = {};\n\t\tthis.stencilFront = null;\n\t\tthis.stencilBack = null;\n\t\tthis.flipFaces = false;\n\t}\n\n\tset renderStyle(renderStyle) {\n\t\tthis._renderStyle = renderStyle;\n\t\tthis.mesh.prepareRenderState(renderStyle);\n\t}\n\n\tget renderStyle() {\n\t\treturn this._renderStyle;\n\t}\n\n\tset mesh(mesh) {\n\t\tif (mesh === this._mesh) return;\n\n\t\tif (this._mesh) {\n\t\t\tthis._mesh.decRefCount();\n\t\t}\n\n\t\tthis._mesh = mesh;\n\n\t\tif (mesh) {\n\t\t\tmesh.incRefCount();\n\t\t}\n\t}\n\n\tget mesh() {\n\t\treturn this._mesh;\n\t}\n\n\tset aabb(aabb) {\n\t\tthis._aabb = aabb;\n\t}\n\n\tget aabb() {\n\t\tif (!this._updateAabb) {\n\t\t\treturn this._aabb;\n\t\t}\n\n\t\tif (this._updateAabbFunc) {\n\t\t\treturn this._updateAabbFunc(this._aabb);\n\t\t}\n\n\t\tlet localAabb = this._customAabb;\n\t\tlet toWorldSpace = !!localAabb;\n\n\t\tif (!localAabb) {\n\t\t\tlocalAabb = _tmpAabb;\n\n\t\t\tif (this.skinInstance) {\n\t\t\t\tif (!this.mesh.boneAabb) {\n\t\t\t\t\tconst morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;\n\n\t\t\t\t\tthis.mesh._initBoneAabbs(morphTargets);\n\t\t\t\t}\n\n\t\t\t\tconst boneUsed = this.mesh.boneUsed;\n\t\t\t\tlet first = true;\n\n\t\t\t\tfor (let i = 0; i < this.mesh.boneAabb.length; i++) {\n\t\t\t\t\tif (boneUsed[i]) {\n\t\t\t\t\t\t_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);\n\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\tlocalAabb.center.copy(_tempBoneAabb.center);\n\t\t\t\t\t\t\tlocalAabb.halfExtents.copy(_tempBoneAabb.halfExtents);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlocalAabb.add(_tempBoneAabb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttoWorldSpace = true;\n\t\t\t} else if (this.node._aabbVer !== this._aabbVer) {\n\t\t\t\tif (this.mesh) {\n\t\t\t\t\tlocalAabb.center.copy(this.mesh.aabb.center);\n\t\t\t\t\tlocalAabb.halfExtents.copy(this.mesh.aabb.halfExtents);\n\t\t\t\t} else {\n\t\t\t\t\tlocalAabb.center.set(0, 0, 0);\n\t\t\t\t\tlocalAabb.halfExtents.set(0, 0, 0);\n\t\t\t\t}\n\n\t\t\t\tif (this.mesh && this.mesh.morph) {\n\t\t\t\t\tlocalAabb._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax());\n\t\t\t\t}\n\n\t\t\t\ttoWorldSpace = true;\n\t\t\t\tthis._aabbVer = this.node._aabbVer;\n\t\t\t}\n\t\t}\n\n\t\tif (toWorldSpace) {\n\t\t\tthis._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());\n\t\t}\n\n\t\treturn this._aabb;\n\t}\n\n\tset material(material) {\n\t\tfor (let i = 0; i < this._shader.length; i++) {\n\t\t\tthis._shader[i] = null;\n\t\t}\n\n\t\tconst prevMat = this._material;\n\n\t\tif (prevMat) {\n\t\t\tprevMat.removeMeshInstanceRef(this);\n\t\t}\n\n\t\tthis._material = material;\n\n\t\tif (this._material) {\n\t\t\tthis._material.addMeshInstanceRef(this);\n\n\t\t\tthis.updateKey();\n\t\t\tconst prevBlend = prevMat && prevMat.blendType !== BLEND_NONE;\n\t\t\tconst thisBlend = this._material.blendType !== BLEND_NONE;\n\n\t\t\tif (prevBlend !== thisBlend) {\n\t\t\t\tlet scene = this._material._scene;\n\t\t\t\tif (!scene && prevMat && prevMat._scene) scene = prevMat._scene;\n\n\t\t\t\tif (scene) {\n\t\t\t\t\tscene.layers._dirtyBlend = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._material._dirtyBlend = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset layer(layer) {\n\t\tthis._layer = layer;\n\t\tthis.updateKey();\n\t}\n\n\tget layer() {\n\t\treturn this._layer;\n\t}\n\n\tset calculateSortDistance(calculateSortDistance) {\n\t\tthis._calculateSortDistance = calculateSortDistance;\n\t}\n\n\tget calculateSortDistance() {\n\t\treturn this._calculateSortDistance;\n\t}\n\n\tset receiveShadow(val) {\n\t\tthis._receiveShadow = val;\n\t\tthis._shaderDefs = val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW;\n\t\tthis._shader[SHADER_FORWARD] = null;\n\t\tthis._shader[SHADER_FORWARDHDR] = null;\n\t}\n\n\tget receiveShadow() {\n\t\treturn this._receiveShadow;\n\t}\n\n\tset skinInstance(val) {\n\t\tthis._skinInstance = val;\n\t\tthis._shaderDefs = val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN;\n\n\t\tfor (let i = 0; i < this._shader.length; i++) {\n\t\t\tthis._shader[i] = null;\n\t\t}\n\n\t\tthis._setupSkinUpdate();\n\t}\n\n\tget skinInstance() {\n\t\treturn this._skinInstance;\n\t}\n\n\tset morphInstance(val) {\n\t\tthis._morphInstance = val;\n\n\t\tif (this._morphInstance) {\n\t\t\tthis._morphInstance.meshInstance = this;\n\t\t}\n\n\t\tthis._shaderDefs = val && val.morph.useTextureMorph ? this._shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED : this._shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED;\n\t\tthis._shaderDefs = val && val.morph.morphPositions ? this._shaderDefs | SHADERDEF_MORPH_POSITION : this._shaderDefs & ~SHADERDEF_MORPH_POSITION;\n\t\tthis._shaderDefs = val && val.morph.morphNormals ? this._shaderDefs | SHADERDEF_MORPH_NORMAL : this._shaderDefs & ~SHADERDEF_MORPH_NORMAL;\n\n\t\tfor (let i = 0; i < this._shader.length; i++) {\n\t\t\tthis._shader[i] = null;\n\t\t}\n\t}\n\n\tget morphInstance() {\n\t\treturn this._morphInstance;\n\t}\n\n\tset screenSpace(val) {\n\t\tthis._screenSpace = val;\n\t\tthis._shaderDefs = val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE;\n\t\tthis._shader[SHADER_FORWARD] = null;\n\t}\n\n\tget screenSpace() {\n\t\treturn this._screenSpace;\n\t}\n\n\tset key(val) {\n\t\tthis._key[SORTKEY_FORWARD] = val;\n\t}\n\n\tget key() {\n\t\treturn this._key[SORTKEY_FORWARD];\n\t}\n\n\tset mask(val) {\n\t\tconst toggles = this._shaderDefs & 0x0000FFFF;\n\t\tthis._shaderDefs = toggles | val << 16;\n\t\tthis._shader[SHADER_FORWARD] = null;\n\t\tthis._shader[SHADER_FORWARDHDR] = null;\n\t}\n\n\tget mask() {\n\t\treturn this._shaderDefs >> 16;\n\t}\n\n\tset instancingCount(value) {\n\t\tif (this.instancingData) this.instancingData.count = value;\n\t}\n\n\tget instancingCount() {\n\t\treturn this.instancingData ? this.instancingData.count : 0;\n\t}\n\n\tdestroy() {\n\t\tconst mesh = this.mesh;\n\n\t\tif (mesh) {\n\t\t\tthis.mesh = null;\n\n\t\t\tif (mesh.refCount < 1) {\n\t\t\t\tmesh.destroy();\n\t\t\t}\n\t\t}\n\n\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);\n\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);\n\n\t\tif (this._skinInstance) {\n\t\t\tthis._skinInstance.destroy();\n\n\t\t\tthis._skinInstance = null;\n\t\t}\n\n\t\tif (this.morphInstance) {\n\t\t\tthis.morphInstance.destroy();\n\t\t\tthis.morphInstance = null;\n\t\t}\n\n\t\tthis.material = null;\n\t}\n\n\tstatic _prepareRenderStyleForArray(meshInstances, renderStyle) {\n\t\tif (meshInstances) {\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i]._renderStyle = renderStyle;\n\t\t\t\tconst mesh = meshInstances[i].mesh;\n\n\t\t\t\tif (!_meshSet.has(mesh)) {\n\t\t\t\t\t_meshSet.add(mesh);\n\n\t\t\t\t\tmesh.prepareRenderState(renderStyle);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_meshSet.clear();\n\t\t}\n\t}\n\n\t_isVisible(camera) {\n\t\tif (this.visible) {\n\t\t\tif (this.isVisibleFunc) {\n\t\t\t\treturn this.isVisibleFunc(camera);\n\t\t\t}\n\n\t\t\t_tempSphere.center = this.aabb.center;\n\t\t\t_tempSphere.radius = this._aabb.halfExtents.length();\n\t\t\treturn camera.frustum.containsSphere(_tempSphere);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tupdateKey() {\n\t\tconst material = this.material;\n\t\tthis._key[SORTKEY_FORWARD] = getKey(this.layer, material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType, false, material.id);\n\t}\n\n\tsetInstancing(vertexBuffer) {\n\t\tif (vertexBuffer) {\n\t\t\tthis.instancingData = new InstancingData(vertexBuffer.numVertices);\n\t\t\tthis.instancingData.vertexBuffer = vertexBuffer;\n\t\t\tvertexBuffer.instancing = true;\n\t\t\tthis.cull = false;\n\t\t} else {\n\t\t\tthis.instancingData = null;\n\t\t\tthis.cull = true;\n\t\t}\n\t}\n\n\tclearParameters() {\n\t\tthis.parameters = {};\n\t}\n\n\tgetParameters() {\n\t\treturn this.parameters;\n\t}\n\n\tgetParameter(name) {\n\t\treturn this.parameters[name];\n\t}\n\n\tsetParameter(name, data, passFlags = -262141) {\n\t\tif (data === undefined && typeof name === 'object') {\n\t\t\tconst uniformObject = name;\n\n\t\t\tif (uniformObject.length) {\n\t\t\t\tfor (let i = 0; i < uniformObject.length; i++) {\n\t\t\t\t\tthis.setParameter(uniformObject[i]);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tname = uniformObject.name;\n\t\t\tdata = uniformObject.value;\n\t\t}\n\n\t\tconst param = this.parameters[name];\n\n\t\tif (param) {\n\t\t\tparam.data = data;\n\t\t\tparam.passFlags = passFlags;\n\t\t} else {\n\t\t\tthis.parameters[name] = {\n\t\t\t\tscopeId: null,\n\t\t\t\tdata: data,\n\t\t\t\tpassFlags: passFlags\n\t\t\t};\n\t\t}\n\t}\n\n\tsetRealtimeLightmap(name, texture) {\n\t\tconst old = this.getParameter(name);\n\t\tif (old === texture) return;\n\n\t\tif (old) {\n\t\t\tLightmapCache.decRef(old.data);\n\t\t}\n\n\t\tif (texture) {\n\t\t\tLightmapCache.incRef(texture);\n\t\t\tthis.setParameter(name, texture);\n\t\t} else {\n\t\t\tthis.deleteParameter(name);\n\t\t}\n\t}\n\n\tdeleteParameter(name) {\n\t\tif (this.parameters[name]) {\n\t\t\tdelete this.parameters[name];\n\t\t}\n\t}\n\n\tsetParameters(device, passFlag) {\n\t\tconst parameters = this.parameters;\n\n\t\tfor (const paramName in parameters) {\n\t\t\tconst parameter = parameters[paramName];\n\n\t\t\tif (parameter.passFlags & passFlag) {\n\t\t\t\tif (!parameter.scopeId) {\n\t\t\t\t\tparameter.scopeId = device.scope.resolve(paramName);\n\t\t\t\t}\n\n\t\t\t\tparameter.scopeId.setValue(parameter.data);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetLightmapped(value) {\n\t\tif (value) {\n\t\t\tthis.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);\n\t\t} else {\n\t\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);\n\t\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);\n\t\t\tthis._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);\n\t\t\tthis.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);\n\t\t}\n\t}\n\n\tsetCustomAabb(aabb) {\n\t\tif (aabb) {\n\t\t\tif (this._customAabb) {\n\t\t\t\tthis._customAabb.copy(aabb);\n\t\t\t} else {\n\t\t\t\tthis._customAabb = aabb.clone();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._customAabb = null;\n\t\t\tthis._aabbVer = -1;\n\t\t}\n\n\t\tthis._setupSkinUpdate();\n\t}\n\n\t_setupSkinUpdate() {\n\t\tif (this._skinInstance) {\n\t\t\tthis._skinInstance._updateBeforeCull = !this._customAabb;\n\t\t}\n\t}\n\n}\n\nMeshInstance.lightmapParamNames = [\"texture_lightMap\", \"texture_dirLightMap\"];\n\nfunction getKey(layer, blendType, isCommand, materialId) {\n\treturn (layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (isCommand ? 1 : 0) << 25 | (materialId & 0x1ffffff) << 0;\n}\n\nfunction paramsIdentical(a, b) {\n\tif (a && !b) return false;\n\tif (!a && b) return false;\n\ta = a.data;\n\tb = b.data;\n\tif (a === b) return true;\n\n\tif (a instanceof Float32Array && b instanceof Float32Array) {\n\t\tif (a.length !== b.length) return false;\n\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction equalParamSets(params1, params2) {\n\tfor (const param in params1) {\n\t\tif (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) return false;\n\t}\n\n\tfor (const param in params2) {\n\t\tif (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param])) return false;\n\t}\n\n\treturn true;\n}\n\nfunction equalLightLists(lightList1, lightList2) {\n\tfor (let k = 0; k < lightList1.length; k++) {\n\t\tif (lightList2.indexOf(lightList1[k]) < 0) return false;\n\t}\n\n\tfor (let k = 0; k < lightList2.length; k++) {\n\t\tif (lightList1.indexOf(lightList2[k]) < 0) return false;\n\t}\n\n\treturn true;\n}\n\nconst mat3 = new Mat3();\nconst worldMatX$1 = new Vec3();\nconst worldMatY$1 = new Vec3();\nconst worldMatZ$1 = new Vec3();\n\nfunction getScaleSign(mi) {\n\tconst wt = mi.node.worldTransform;\n\twt.getX(worldMatX$1);\n\twt.getY(worldMatY$1);\n\twt.getZ(worldMatZ$1);\n\tworldMatX$1.cross(worldMatX$1, worldMatY$1);\n\treturn worldMatX$1.dot(worldMatZ$1) >= 0 ? 1 : -1;\n}\n\nclass BatchManager {\n\tconstructor(device, root, scene) {\n\t\tthis.device = device;\n\t\tthis.rootNode = root;\n\t\tthis.scene = scene;\n\t\tthis._init = false;\n\t\tthis._batchGroups = {};\n\t\tthis._batchGroupCounter = 0;\n\t\tthis._batchList = [];\n\t\tthis._dirtyGroups = [];\n\t}\n\n\tdestroy() {\n\t\tthis.device = null;\n\t\tthis.rootNode = null;\n\t\tthis.scene = null;\n\t\tthis._batchGroups = {};\n\t\tthis._batchList = [];\n\t\tthis._dirtyGroups = [];\n\t}\n\n\taddGroup(name, dynamic, maxAabbSize, id, layers) {\n\t\tif (id === undefined) {\n\t\t\tid = this._batchGroupCounter;\n\t\t\tthis._batchGroupCounter++;\n\t\t}\n\n\t\tif (this._batchGroups[id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);\n\t\tthis._batchGroups[id] = group;\n\t\treturn group;\n\t}\n\n\tremoveGroup(id) {\n\t\tif (!this._batchGroups[id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst newBatchList = [];\n\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (this._batchList[i].batchGroupId === id) {\n\t\t\t\tthis.destroyBatch(this._batchList[i]);\n\t\t\t} else {\n\t\t\t\tnewBatchList.push(this._batchList[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis._batchList = newBatchList;\n\n\t\tthis._removeModelsFromBatchGroup(this.rootNode, id);\n\n\t\tdelete this._batchGroups[id];\n\t}\n\n\tmarkGroupDirty(id) {\n\t\tif (this._dirtyGroups.indexOf(id) < 0) {\n\t\t\tthis._dirtyGroups.push(id);\n\t\t}\n\t}\n\n\tgetGroupByName(name) {\n\t\tconst groups = this._batchGroups;\n\n\t\tfor (const group in groups) {\n\t\t\tif (!groups.hasOwnProperty(group)) continue;\n\n\t\t\tif (groups[group].name === name) {\n\t\t\t\treturn groups[group];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tgetBatches(batchGroupId) {\n\t\tconst results = [];\n\t\tconst len = this._batchList.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst batch = this._batchList[i];\n\n\t\t\tif (batch.batchGroupId === batchGroupId) {\n\t\t\t\tresults.push(batch);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t_removeModelsFromBatchGroup(node, id) {\n\t\tif (!node.enabled) return;\n\n\t\tif (node.model && node.model.batchGroupId === id) {\n\t\t\tnode.model.batchGroupId = -1;\n\t\t}\n\n\t\tif (node.render && node.render.batchGroupId === id) {\n\t\t\tnode.render.batchGroupId = -1;\n\t\t}\n\n\t\tif (node.element && node.element.batchGroupId === id) {\n\t\t\tnode.element.batchGroupId = -1;\n\t\t}\n\n\t\tif (node.sprite && node.sprite.batchGroupId === id) {\n\t\t\tnode.sprite.batchGroupId = -1;\n\t\t}\n\n\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\tthis._removeModelsFromBatchGroup(node._children[i], id);\n\t\t}\n\t}\n\n\tinsert(type, groupId, node) {\n\t\tconst group = this._batchGroups[groupId];\n\n\t\tif (group) {\n\t\t\tif (group._obj[type].indexOf(node) < 0) {\n\t\t\t\tgroup._obj[type].push(node);\n\n\t\t\t\tthis.markGroupDirty(groupId);\n\t\t\t}\n\t\t}\n\t}\n\n\tremove(type, groupId, node) {\n\t\tconst group = this._batchGroups[groupId];\n\n\t\tif (group) {\n\t\t\tconst idx = group._obj[type].indexOf(node);\n\n\t\t\tif (idx >= 0) {\n\t\t\t\tgroup._obj[type].splice(idx, 1);\n\n\t\t\t\tthis.markGroupDirty(groupId);\n\t\t\t}\n\t\t}\n\t}\n\n\t_extractRender(node, arr, group, groupMeshInstances) {\n\t\tif (node.render) {\n\t\t\tif (node.render.isStatic) {\n\t\t\t\tconst drawCalls = this.scene.drawCalls;\n\t\t\t\tconst nodeMeshInstances = node.render.meshInstances;\n\n\t\t\t\tfor (let i = 0; i < drawCalls.length; i++) {\n\t\t\t\t\tif (!drawCalls[i]._staticSource) continue;\n\t\t\t\t\tif (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;\n\t\t\t\t\tarr.push(drawCalls[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < nodeMeshInstances.length; i++) {\n\t\t\t\t\tif (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {\n\t\t\t\t\t\tarr.push(nodeMeshInstances[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);\n\t\t\t}\n\n\t\t\tnode.render.removeFromLayers();\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t_extractModel(node, arr, group, groupMeshInstances) {\n\t\tif (node.model && node.model.model) {\n\t\t\tif (node.model.isStatic) {\n\t\t\t\tconst drawCalls = this.scene.drawCalls;\n\t\t\t\tconst nodeMeshInstances = node.model.meshInstances;\n\n\t\t\t\tfor (let i = 0; i < drawCalls.length; i++) {\n\t\t\t\t\tif (!drawCalls[i]._staticSource) continue;\n\t\t\t\t\tif (nodeMeshInstances.indexOf(drawCalls[i]._staticSource) < 0) continue;\n\t\t\t\t\tarr.push(drawCalls[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < nodeMeshInstances.length; i++) {\n\t\t\t\t\tif (drawCalls.indexOf(nodeMeshInstances[i]) >= 0) {\n\t\t\t\t\t\tarr.push(nodeMeshInstances[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);\n\t\t\t}\n\n\t\t\tnode.model.removeModelFromLayers();\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t_extractElement(node, arr, group) {\n\t\tif (!node.element) return;\n\t\tlet valid = false;\n\n\t\tif (node.element._text && node.element._text._model.meshInstances.length > 0) {\n\t\t\tarr.push(node.element._text._model.meshInstances[0]);\n\t\t\tnode.element.removeModelFromLayers(node.element._text._model);\n\t\t\tvalid = true;\n\t\t} else if (node.element._image) {\n\t\t\tarr.push(node.element._image._renderable.meshInstance);\n\t\t\tnode.element.removeModelFromLayers(node.element._image._renderable.model);\n\n\t\t\tif (node.element._image._renderable.unmaskMeshInstance) {\n\t\t\t\tarr.push(node.element._image._renderable.unmaskMeshInstance);\n\n\t\t\t\tif (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {\n\t\t\t\t\tnode.element._dirtifyMask();\n\n\t\t\t\t\tnode.element._onPrerender();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalid = true;\n\t\t}\n\n\t\tif (valid) {\n\t\t\tgroup._ui = true;\n\t\t}\n\t}\n\n\t_collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {\n\t\tfor (let g = 0; g < groupIds.length; g++) {\n\t\t\tconst id = groupIds[g];\n\t\t\tconst group = this._batchGroups[id];\n\t\t\tif (!group) continue;\n\t\t\tlet arr = groupMeshInstances[id];\n\t\t\tif (!arr) arr = groupMeshInstances[id] = [];\n\n\t\t\tfor (let m = 0; m < group._obj.model.length; m++) {\n\t\t\t\tarr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);\n\t\t\t}\n\n\t\t\tfor (let r = 0; r < group._obj.render.length; r++) {\n\t\t\t\tarr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);\n\t\t\t}\n\n\t\t\tfor (let e = 0; e < group._obj.element.length; e++) {\n\t\t\t\tthis._extractElement(group._obj.element[e], arr, group);\n\t\t\t}\n\n\t\t\tfor (let s = 0; s < group._obj.sprite.length; s++) {\n\t\t\t\tconst node = group._obj.sprite[s];\n\n\t\t\t\tif (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {\n\t\t\t\t\tarr.push(node.sprite._meshInstance);\n\t\t\t\t\tnode.sprite.removeModelFromLayers();\n\t\t\t\t\tgroup._sprite = true;\n\t\t\t\t\tnode.sprite._batchGroup = group;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgenerate(groupIds) {\n\t\tconst groupMeshInstances = {};\n\n\t\tif (!groupIds) {\n\t\t\tgroupIds = Object.keys(this._batchGroups);\n\t\t}\n\n\t\tconst newBatchList = [];\n\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {\n\t\t\t\tnewBatchList.push(this._batchList[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.destroyBatch(this._batchList[i]);\n\t\t}\n\n\t\tthis._batchList = newBatchList;\n\n\t\tthis._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);\n\n\t\tif (groupIds === this._dirtyGroups) {\n\t\t\tthis._dirtyGroups.length = 0;\n\t\t} else {\n\t\t\tconst newDirtyGroups = [];\n\n\t\t\tfor (let i = 0; i < this._dirtyGroups.length; i++) {\n\t\t\t\tif (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);\n\t\t\t}\n\n\t\t\tthis._dirtyGroups = newDirtyGroups;\n\t\t}\n\n\t\tlet group, lists, groupData, batch;\n\n\t\tfor (const groupId in groupMeshInstances) {\n\t\t\tif (!groupMeshInstances.hasOwnProperty(groupId)) continue;\n\t\t\tgroup = groupMeshInstances[groupId];\n\t\t\tgroupData = this._batchGroups[groupId];\n\n\t\t\tif (!groupData) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);\n\n\t\t\tfor (let i = 0; i < lists.length; i++) {\n\t\t\t\tbatch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));\n\n\t\t\t\tif (batch) {\n\t\t\t\t\tbatch.addToLayers(this.scene, groupData.layers);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprepare(meshInstances, dynamic, maxAabbSize = Number.POSITIVE_INFINITY, translucent) {\n\t\tif (meshInstances.length === 0) return [];\n\t\tconst halfMaxAabbSize = maxAabbSize * 0.5;\n\t\tconst maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;\n\t\tconst maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;\n\t\tconst aabb = new BoundingBox();\n\t\tconst testAabb = new BoundingBox();\n\t\tlet skipTranslucentAabb = null;\n\t\tlet sf;\n\t\tconst lists = [];\n\t\tlet j = 0;\n\n\t\tif (translucent) {\n\t\t\tmeshInstances.sort(function (a, b) {\n\t\t\t\treturn a.drawOrder - b.drawOrder;\n\t\t\t});\n\t\t}\n\n\t\tlet meshInstancesLeftA = meshInstances;\n\t\tlet meshInstancesLeftB;\n\t\tconst skipMesh = translucent ? function (mi) {\n\t\t\tif (skipTranslucentAabb) {\n\t\t\t\tskipTranslucentAabb.add(mi.aabb);\n\t\t\t} else {\n\t\t\t\tskipTranslucentAabb = mi.aabb.clone();\n\t\t\t}\n\n\t\t\tmeshInstancesLeftB.push(mi);\n\t\t} : function (mi) {\n\t\t\tmeshInstancesLeftB.push(mi);\n\t\t};\n\n\t\twhile (meshInstancesLeftA.length > 0) {\n\t\t\tlists[j] = [meshInstancesLeftA[0]];\n\t\t\tmeshInstancesLeftB = [];\n\t\t\tconst material = meshInstancesLeftA[0].material;\n\t\t\tconst layer = meshInstancesLeftA[0].layer;\n\t\t\tconst defs = meshInstancesLeftA[0]._shaderDefs;\n\t\t\tconst params = meshInstancesLeftA[0].parameters;\n\t\t\tconst stencil = meshInstancesLeftA[0].stencilFront;\n\t\t\tconst lightList = meshInstancesLeftA[0]._staticLightList;\n\t\t\tlet vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();\n\t\t\tconst drawOrder = meshInstancesLeftA[0].drawOrder;\n\t\t\taabb.copy(meshInstancesLeftA[0].aabb);\n\t\t\tconst scaleSign = getScaleSign(meshInstancesLeftA[0]);\n\t\t\tconst vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;\n\t\t\tconst indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;\n\t\t\tskipTranslucentAabb = null;\n\n\t\t\tfor (let i = 1; i < meshInstancesLeftA.length; i++) {\n\t\t\t\tconst mi = meshInstancesLeftA[i];\n\n\t\t\t\tif (dynamic && lists[j].length >= maxInstanceCount) {\n\t\t\t\t\tmeshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttestAabb.copy(aabb);\n\t\t\t\ttestAabb.add(mi.aabb);\n\n\t\t\t\tif (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (stencil) {\n\t\t\t\t\tif (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {\n\t\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (scaleSign !== getScaleSign(mi)) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!equalParamSets(params, mi.parameters)) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst staticLights = mi._staticLightList;\n\n\t\t\t\tif (lightList && staticLights) {\n\t\t\t\t\tif (!equalLightLists(lightList, staticLights)) {\n\t\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (lightList || staticLights) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\taabb.add(mi.aabb);\n\t\t\t\tvertCount += mi.mesh.vertexBuffer.getNumVertices();\n\t\t\t\tlists[j].push(mi);\n\t\t\t}\n\n\t\t\tj++;\n\t\t\tmeshInstancesLeftA = meshInstancesLeftB;\n\t\t}\n\n\t\treturn lists;\n\t}\n\n\tcollectBatchedMeshData(meshInstances, dynamic) {\n\t\tlet streams = null;\n\t\tlet batchNumVerts = 0;\n\t\tlet batchNumIndices = 0;\n\t\tlet material = null;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tif (meshInstances[i].visible) {\n\t\t\t\tconst mesh = meshInstances[i].mesh;\n\t\t\t\tconst numVerts = mesh.vertexBuffer.numVertices;\n\t\t\t\tbatchNumVerts += numVerts;\n\t\t\t\tbatchNumIndices += mesh.primitive[0].indexed ? mesh.primitive[0].count : mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4 ? 6 : 0;\n\n\t\t\t\tif (!streams) {\n\t\t\t\t\tmaterial = meshInstances[i].material;\n\t\t\t\t\tstreams = {};\n\t\t\t\t\tconst elems = mesh.vertexBuffer.format.elements;\n\n\t\t\t\t\tfor (let j = 0; j < elems.length; j++) {\n\t\t\t\t\t\tconst semantic = elems[j].name;\n\t\t\t\t\t\tstreams[semantic] = {\n\t\t\t\t\t\t\tnumComponents: elems[j].numComponents,\n\t\t\t\t\t\t\tdataType: elems[j].dataType,\n\t\t\t\t\t\t\tnormalize: elems[j].normalize,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dynamic) {\n\t\t\t\t\t\tstreams[SEMANTIC_BLENDINDICES] = {\n\t\t\t\t\t\t\tnumComponents: 1,\n\t\t\t\t\t\t\tdataType: TYPE_FLOAT32,\n\t\t\t\t\t\t\tnormalize: false,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tstreams: streams,\n\t\t\tbatchNumVerts: batchNumVerts,\n\t\t\tbatchNumIndices: batchNumIndices,\n\t\t\tmaterial: material\n\t\t};\n\t}\n\n\tcreate(meshInstances, dynamic, batchGroupId) {\n\t\tif (!this._init) {\n\t\t\tconst boneLimit = \"#define BONE_LIMIT \" + this.device.getBoneLimit() + \"\\n\";\n\t\t\tthis.transformVS = boneLimit + \"#define DYNAMICBATCH\\n\" + shaderChunks.transformVS;\n\t\t\tthis.skinTexVS = shaderChunks.skinBatchTexVS;\n\t\t\tthis.skinConstVS = shaderChunks.skinBatchConstVS;\n\t\t\tthis.vertexFormats = {};\n\t\t\tthis._init = true;\n\t\t}\n\n\t\tlet stream = null;\n\t\tlet semantic;\n\t\tlet mesh, numVerts;\n\t\tlet batch = null;\n\t\tconst batchData = this.collectBatchedMeshData(meshInstances, dynamic);\n\n\t\tif (batchData.streams) {\n\t\t\tconst streams = batchData.streams;\n\t\t\tlet material = batchData.material;\n\t\t\tconst batchNumVerts = batchData.batchNumVerts;\n\t\t\tconst batchNumIndices = batchData.batchNumIndices;\n\t\t\tbatch = new Batch(meshInstances, dynamic, batchGroupId);\n\n\t\t\tthis._batchList.push(batch);\n\n\t\t\tlet indexBase, numIndices, indexData;\n\t\t\tlet verticesOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tlet transform;\n\t\t\tconst vec = new Vec3();\n\t\t\tconst indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;\n\t\t\tconst indices = new indexArrayType(batchNumIndices);\n\n\t\t\tfor (semantic in streams) {\n\t\t\t\tstream = streams[semantic];\n\t\t\t\tstream.typeArrayType = typedArrayTypes[stream.dataType];\n\t\t\t\tstream.elementByteSize = typedArrayTypesByteSize[stream.dataType];\n\t\t\t\tstream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (!meshInstances[i].visible) continue;\n\t\t\t\tmesh = meshInstances[i].mesh;\n\t\t\t\tnumVerts = mesh.vertexBuffer.numVertices;\n\n\t\t\t\tif (!dynamic) {\n\t\t\t\t\ttransform = meshInstances[i].node.getWorldTransform();\n\t\t\t\t}\n\n\t\t\t\tfor (semantic in streams) {\n\t\t\t\t\tif (semantic !== SEMANTIC_BLENDINDICES) {\n\t\t\t\t\t\tstream = streams[semantic];\n\t\t\t\t\t\tconst subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);\n\t\t\t\t\t\tconst totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;\n\t\t\t\t\t\tstream.count += totalComponents;\n\n\t\t\t\t\t\tif (!dynamic && stream.numComponents >= 3) {\n\t\t\t\t\t\t\tif (semantic === SEMANTIC_POSITION) {\n\t\t\t\t\t\t\t\tfor (let j = 0; j < totalComponents; j += stream.numComponents) {\n\t\t\t\t\t\t\t\t\tvec.set(subarray[j], subarray[j + 1], subarray[j + 2]);\n\t\t\t\t\t\t\t\t\ttransform.transformPoint(vec, vec);\n\t\t\t\t\t\t\t\t\tsubarray[j] = vec.x;\n\t\t\t\t\t\t\t\t\tsubarray[j + 1] = vec.y;\n\t\t\t\t\t\t\t\t\tsubarray[j + 2] = vec.z;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {\n\t\t\t\t\t\t\t\ttransform.invertTo3x3(mat3);\n\t\t\t\t\t\t\t\tmat3.transpose();\n\n\t\t\t\t\t\t\t\tfor (let j = 0; j < totalComponents; j += stream.numComponents) {\n\t\t\t\t\t\t\t\t\tvec.set(subarray[j], subarray[j + 1], subarray[j + 2]);\n\t\t\t\t\t\t\t\t\tmat3.transformVector(vec, vec);\n\t\t\t\t\t\t\t\t\tsubarray[j] = vec.x;\n\t\t\t\t\t\t\t\t\tsubarray[j + 1] = vec.y;\n\t\t\t\t\t\t\t\t\tsubarray[j + 2] = vec.z;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dynamic) {\n\t\t\t\t\tstream = streams[SEMANTIC_BLENDINDICES];\n\n\t\t\t\t\tfor (let j = 0; j < numVerts; j++) stream.buffer[stream.count++] = i;\n\t\t\t\t}\n\n\t\t\t\tif (mesh.primitive[0].indexed) {\n\t\t\t\t\tindexBase = mesh.primitive[0].base;\n\t\t\t\t\tnumIndices = mesh.primitive[0].count;\n\t\t\t\t\tconst srcFormat = mesh.indexBuffer[0].getFormat();\n\t\t\t\t\tindexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);\n\t\t\t\t} else if (mesh.primitive[0].type === PRIMITIVE_TRIFAN && mesh.primitive[0].count === 4) {\n\t\t\t\t\tindexBase = 0;\n\t\t\t\t\tnumIndices = 6;\n\t\t\t\t\tindexData = [0, 1, 3, 2, 3, 1];\n\t\t\t\t} else {\n\t\t\t\t\tnumIndices = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < numIndices; j++) {\n\t\t\t\t\tindices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;\n\t\t\t\t}\n\n\t\t\t\tindexOffset += numIndices;\n\t\t\t\tverticesOffset += numVerts;\n\t\t\t}\n\n\t\t\tmesh = new Mesh(this.device);\n\n\t\t\tfor (semantic in streams) {\n\t\t\t\tstream = streams[semantic];\n\t\t\t\tmesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);\n\t\t\t}\n\n\t\t\tif (indices.length > 0) mesh.setIndices(indices);\n\t\t\tmesh.update(PRIMITIVE_TRIANGLES, false);\n\n\t\t\tif (dynamic) {\n\t\t\t\tmaterial = material.clone();\n\t\t\t\tmaterial.chunks.transformVS = this.transformVS;\n\t\t\t\tmaterial.chunks.skinTexVS = this.skinTexVS;\n\t\t\t\tmaterial.chunks.skinConstVS = this.skinConstVS;\n\t\t\t\tmaterial.update();\n\t\t\t}\n\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, this.rootNode);\n\t\t\tmeshInstance.castShadow = batch.origMeshInstances[0].castShadow;\n\t\t\tmeshInstance.parameters = batch.origMeshInstances[0].parameters;\n\t\t\tmeshInstance.isStatic = batch.origMeshInstances[0].isStatic;\n\t\t\tmeshInstance.layer = batch.origMeshInstances[0].layer;\n\t\t\tmeshInstance._staticLightList = batch.origMeshInstances[0]._staticLightList;\n\t\t\tmeshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;\n\t\t\tmeshInstance.cull = batch.origMeshInstances[0].cull;\n\t\t\tconst batchGroup = this._batchGroups[batchGroupId];\n\t\t\tif (batchGroup && batchGroup._ui) meshInstance.cull = false;\n\n\t\t\tif (dynamic) {\n\t\t\t\tconst nodes = [];\n\n\t\t\t\tfor (let i = 0; i < batch.origMeshInstances.length; i++) {\n\t\t\t\t\tnodes.push(batch.origMeshInstances[i].node);\n\t\t\t\t}\n\n\t\t\t\tmeshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);\n\t\t\t}\n\n\t\t\tmeshInstance._updateAabb = false;\n\t\t\tmeshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;\n\t\t\tmeshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;\n\t\t\tmeshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;\n\t\t\tmeshInstance.flipFaces = getScaleSign(batch.origMeshInstances[0]) < 0;\n\t\t\tmeshInstance.castShadow = batch.origMeshInstances[0].castShadow;\n\t\t\tbatch.meshInstance = meshInstance;\n\t\t\tbatch.updateBoundingBox();\n\t\t}\n\n\t\treturn batch;\n\t}\n\n\tupdateAll() {\n\t\tif (this._dirtyGroups.length > 0) {\n\t\t\tthis.generate(this._dirtyGroups);\n\t\t}\n\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (!this._batchList[i].dynamic) continue;\n\n\t\t\tthis._batchList[i].updateBoundingBox();\n\t\t}\n\t}\n\n\tclone(batch, clonedMeshInstances) {\n\t\tconst batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);\n\n\t\tthis._batchList.push(batch2);\n\n\t\tconst nodes = [];\n\n\t\tfor (let i = 0; i < clonedMeshInstances.length; i++) {\n\t\t\tnodes.push(clonedMeshInstances[i].node);\n\t\t}\n\n\t\tbatch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);\n\t\tbatch2.meshInstance._updateAabb = false;\n\t\tbatch2.meshInstance.parameters = clonedMeshInstances[0].parameters;\n\t\tbatch2.meshInstance.isStatic = clonedMeshInstances[0].isStatic;\n\t\tbatch2.meshInstance.cull = clonedMeshInstances[0].cull;\n\t\tbatch2.meshInstance.layer = clonedMeshInstances[0].layer;\n\t\tbatch2.meshInstance._staticLightList = clonedMeshInstances[0]._staticLightList;\n\n\t\tif (batch.dynamic) {\n\t\t\tbatch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);\n\t\t}\n\n\t\tbatch2.meshInstance.castShadow = batch.meshInstance.castShadow;\n\t\tbatch2.meshInstance._shader = batch.meshInstance._shader;\n\t\tbatch2.meshInstance.castShadow = batch.meshInstance.castShadow;\n\t\treturn batch2;\n\t}\n\n\tdestroyBatch(batch) {\n\t\tbatch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);\n\t}\n\n}\n\nconst tempVec3 = new Vec3();\nconst tempMin3 = new Vec3();\nconst tempMax3 = new Vec3();\nconst tempBox = new BoundingBox();\nconst epsilon = 0.000001;\n\nclass ClusterLight {\n\tconstructor() {\n\t\tthis.light = null;\n\t\tthis.min = new Vec3();\n\t\tthis.max = new Vec3();\n\t}\n\n}\n\nclass WorldClusters {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.name = \"Untitled\";\n\t\tthis.reportCount = 0;\n\t\tthis.boundsMin = new Vec3();\n\t\tthis.boundsMax = new Vec3();\n\t\tthis.boundsDelta = new Vec3();\n\t\tthis._cells = new Vec3(1, 1, 1);\n\t\tthis._cellsLimit = new Vec3();\n\t\tthis.cells = this._cells;\n\t\tthis._maxCellLightCount = 0;\n\t\tthis._pixelsPerCellCount = 0;\n\t\tthis.maxCellLightCount = 4;\n\t\tthis._maxAttenuation = 0;\n\t\tthis._maxColorValue = 0;\n\t\tthis._usedLights = [];\n\n\t\tthis._usedLights.push(new ClusterLight());\n\n\t\tthis.lightsBuffer = new LightsBuffer(device);\n\t\tthis.registerUniforms(device);\n\t}\n\n\tset maxCellLightCount(count) {\n\t\tconst maxCellLightCount = math.roundUp(count, 4);\n\n\t\tif (maxCellLightCount !== this._maxCellLightCount) {\n\t\t\tthis._maxCellLightCount = maxCellLightCount;\n\t\t\tthis._pixelsPerCellCount = this._maxCellLightCount / 4;\n\t\t\tthis._cellsDirty = true;\n\t\t}\n\t}\n\n\tget maxCellLightCount() {\n\t\treturn this._maxCellLightCount;\n\t}\n\n\tset cells(value) {\n\t\ttempVec3.copy(value).floor();\n\n\t\tif (!this._cells.equals(tempVec3)) {\n\t\t\tthis._cells.copy(tempVec3);\n\n\t\t\tthis._cellsLimit.copy(tempVec3).sub(Vec3.ONE);\n\n\t\t\tthis._cellsDirty = true;\n\t\t}\n\t}\n\n\tget cells() {\n\t\treturn this._cells;\n\t}\n\n\tdestroy() {\n\t\tthis.lightsBuffer.destroy();\n\t\tthis.releaseClusterTexture();\n\t}\n\n\treleaseClusterTexture() {\n\t\tif (this.clusterTexture) {\n\t\t\tthis.clusterTexture.destroy();\n\t\t\tthis.clusterTexture = null;\n\t\t}\n\t}\n\n\tregisterUniforms(device) {\n\t\tthis._clusterWorldTextureId = device.scope.resolve(\"clusterWorldTexture\");\n\t\tthis._clusterPixelsPerCellId = device.scope.resolve(\"clusterPixelsPerCell\");\n\t\tthis._clusterTextureSizeId = device.scope.resolve(\"clusterTextureSize\");\n\t\tthis._clusterTextureSizeData = new Float32Array(3);\n\t\tthis._clusterBoundsMinId = device.scope.resolve(\"clusterBoundsMin\");\n\t\tthis._clusterBoundsMinData = new Float32Array(3);\n\t\tthis._clusterBoundsDeltaId = device.scope.resolve(\"clusterBoundsDelta\");\n\t\tthis._clusterBoundsDeltaData = new Float32Array(3);\n\t\tthis._clusterCellsCountByBoundsSizeId = device.scope.resolve(\"clusterCellsCountByBoundsSize\");\n\t\tthis._clusterCellsCountByBoundsSizeData = new Float32Array(3);\n\t\tthis._clusterCellsDotId = device.scope.resolve(\"clusterCellsDot\");\n\t\tthis._clusterCellsDotData = new Float32Array(3);\n\t\tthis._clusterCellsMaxId = device.scope.resolve(\"clusterCellsMax\");\n\t\tthis._clusterCellsMaxData = new Float32Array(3);\n\t\tthis._clusterCompressionLimit0Id = device.scope.resolve(\"clusterCompressionLimit0\");\n\t\tthis._clusterCompressionLimit0Data = new Float32Array(2);\n\t}\n\n\tupdateParams(lightingParams) {\n\t\tif (lightingParams) {\n\t\t\tthis.cells = lightingParams.cells;\n\t\t\tthis.maxCellLightCount = lightingParams.maxLightsPerCell;\n\t\t\tthis.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;\n\t\t\tthis.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;\n\t\t\tthis.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;\n\t\t}\n\t}\n\n\tupdateCells() {\n\t\tif (this._cellsDirty) {\n\t\t\tthis._cellsDirty = false;\n\t\t\tconst cx = this._cells.x;\n\t\t\tconst cy = this._cells.y;\n\t\t\tconst cz = this._cells.z;\n\t\t\tconst numCells = cx * cy * cz;\n\t\t\tconst totalPixels = this._pixelsPerCellCount * numCells;\n\t\t\tlet width = Math.ceil(Math.sqrt(totalPixels));\n\t\t\twidth = math.roundUp(width, this._pixelsPerCellCount);\n\t\t\tconst height = Math.ceil(totalPixels / width);\n\t\t\tthis._clusterCellsMaxData[0] = cx;\n\t\t\tthis._clusterCellsMaxData[1] = cy;\n\t\t\tthis._clusterCellsMaxData[2] = cz;\n\t\t\tthis._clusterCellsDotData[0] = this._pixelsPerCellCount;\n\t\t\tthis._clusterCellsDotData[1] = cx * cz * this._pixelsPerCellCount;\n\t\t\tthis._clusterCellsDotData[2] = cx * this._pixelsPerCellCount;\n\t\t\tthis.clusters = new Uint8ClampedArray(4 * totalPixels);\n\t\t\tthis.counts = new Int32Array(numCells);\n\t\t\tthis._clusterTextureSizeData[0] = width;\n\t\t\tthis._clusterTextureSizeData[1] = 1.0 / width;\n\t\t\tthis._clusterTextureSizeData[2] = 1.0 / height;\n\t\t\tthis.releaseClusterTexture();\n\t\t\tthis.clusterTexture = LightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8_G8_B8_A8, \"ClusterTexture\");\n\t\t}\n\t}\n\n\tuploadTextures() {\n\t\tthis.clusterTexture.lock().set(this.clusters);\n\t\tthis.clusterTexture.unlock();\n\t\tthis.lightsBuffer.uploadTextures();\n\t}\n\n\tupdateUniforms() {\n\t\tthis.lightsBuffer.updateUniforms();\n\n\t\tthis._clusterWorldTextureId.setValue(this.clusterTexture);\n\n\t\tconst boundsDelta = this.boundsDelta;\n\t\tthis._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;\n\t\tthis._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;\n\t\tthis._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;\n\n\t\tthis._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);\n\n\t\tthis._clusterBoundsMinData[0] = this.boundsMin.x;\n\t\tthis._clusterBoundsMinData[1] = this.boundsMin.y;\n\t\tthis._clusterBoundsMinData[2] = this.boundsMin.z;\n\t\tthis._clusterBoundsDeltaData[0] = boundsDelta.x;\n\t\tthis._clusterBoundsDeltaData[1] = boundsDelta.y;\n\t\tthis._clusterBoundsDeltaData[2] = boundsDelta.z;\n\t\tthis._clusterCompressionLimit0Data[0] = this._maxAttenuation;\n\t\tthis._clusterCompressionLimit0Data[1] = this._maxColorValue;\n\n\t\tthis._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount);\n\n\t\tthis._clusterTextureSizeId.setValue(this._clusterTextureSizeData);\n\n\t\tthis._clusterBoundsMinId.setValue(this._clusterBoundsMinData);\n\n\t\tthis._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);\n\n\t\tthis._clusterCellsDotId.setValue(this._clusterCellsDotData);\n\n\t\tthis._clusterCellsMaxId.setValue(this._clusterCellsMaxData);\n\n\t\tthis._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);\n\t}\n\n\tevalLightCellMinMax(clusteredLight, min, max) {\n\t\tmin.copy(clusteredLight.min);\n\t\tmin.sub(this.boundsMin);\n\t\tmin.div(this.boundsDelta);\n\t\tmin.mul2(min, this.cells);\n\t\tmin.floor();\n\t\tmax.copy(clusteredLight.max);\n\t\tmax.sub(this.boundsMin);\n\t\tmax.div(this.boundsDelta);\n\t\tmax.mul2(max, this.cells);\n\t\tmax.ceil();\n\t\tmin.max(Vec3.ZERO);\n\t\tmax.min(this._cellsLimit);\n\t}\n\n\tcollectLights(lights) {\n\t\tconst maxLights = this.lightsBuffer.maxLights;\n\t\tconst usedLights = this._usedLights;\n\t\tlet lightIndex = 1;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\t\t\tconst runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));\n\n\t\t\tif (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight) {\n\t\t\t\tif (lightIndex < maxLights) {\n\t\t\t\t\tlet clusteredLight;\n\n\t\t\t\t\tif (lightIndex < usedLights.length) {\n\t\t\t\t\t\tclusteredLight = usedLights[lightIndex];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclusteredLight = new ClusterLight();\n\t\t\t\t\t\tusedLights.push(clusteredLight);\n\t\t\t\t\t}\n\n\t\t\t\t\tclusteredLight.light = light;\n\t\t\t\t\tlight.getBoundingBox(tempBox);\n\t\t\t\t\tclusteredLight.min.copy(tempBox.getMin());\n\t\t\t\t\tclusteredLight.max.copy(tempBox.getMax());\n\t\t\t\t\tlightIndex++;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`Clustered lighting: more than ${maxLights - 1} lights in the frame, ignoring some.`);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tusedLights.length = lightIndex;\n\t}\n\n\tevaluateBounds() {\n\t\tconst usedLights = this._usedLights;\n\t\tconst min = this.boundsMin;\n\t\tconst max = this.boundsMax;\n\n\t\tif (usedLights.length > 1) {\n\t\t\tmin.copy(usedLights[1].min);\n\t\t\tmax.copy(usedLights[1].max);\n\n\t\t\tfor (let i = 2; i < usedLights.length; i++) {\n\t\t\t\tmin.min(usedLights[i].min);\n\t\t\t\tmax.max(usedLights[i].max);\n\t\t\t}\n\t\t} else {\n\t\t\tmin.set(0, 0, 0);\n\t\t\tmax.set(1, 1, 1);\n\t\t}\n\n\t\tthis.boundsDelta.sub2(max, min);\n\t\tthis.lightsBuffer.setBounds(min, this.boundsDelta);\n\t}\n\n\tevaluateCompressionLimits(gammaCorrection) {\n\t\tlet maxAttenuation = 0;\n\t\tlet maxColorValue = 0;\n\t\tconst usedLights = this._usedLights;\n\n\t\tfor (let i = 1; i < usedLights.length; i++) {\n\t\t\tconst light = usedLights[i].light;\n\t\t\tmaxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);\n\t\t\tconst color = gammaCorrection ? light._linearFinalColor : light._finalColor;\n\t\t\tmaxColorValue = Math.max(color[0], maxColorValue);\n\t\t\tmaxColorValue = Math.max(color[1], maxColorValue);\n\t\t\tmaxColorValue = Math.max(color[2], maxColorValue);\n\t\t}\n\n\t\tthis._maxAttenuation = maxAttenuation + epsilon;\n\t\tthis._maxColorValue = maxColorValue + epsilon;\n\t\tthis.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);\n\t}\n\n\tupdateClusters(gammaCorrection) {\n\t\tthis.counts.fill(0);\n\t\tthis.clusters.fill(0);\n\t\tconst divX = this._cells.x;\n\t\tconst divZ = this._cells.z;\n\t\tconst counts = this.counts;\n\t\tconst limit = this._maxCellLightCount;\n\t\tconst clusters = this.clusters;\n\t\tconst pixelsPerCellCount = this._pixelsPerCellCount;\n\t\tconst usedLights = this._usedLights;\n\n\t\tfor (let i = 1; i < usedLights.length; i++) {\n\t\t\tconst clusteredLight = usedLights[i];\n\t\t\tconst light = clusteredLight.light;\n\t\t\tthis.lightsBuffer.addLightData(light, i, gammaCorrection);\n\t\t\tthis.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);\n\t\t\tconst xStart = tempMin3.x;\n\t\t\tconst xEnd = tempMax3.x;\n\t\t\tconst yStart = tempMin3.y;\n\t\t\tconst yEnd = tempMax3.y;\n\t\t\tconst zStart = tempMin3.z;\n\t\t\tconst zEnd = tempMax3.z;\n\n\t\t\tfor (let x = xStart; x <= xEnd; x++) {\n\t\t\t\tfor (let z = zStart; z <= zEnd; z++) {\n\t\t\t\t\tfor (let y = yStart; y <= yEnd; y++) {\n\t\t\t\t\t\tconst clusterIndex = x + divX * (z + y * divZ);\n\t\t\t\t\t\tconst count = counts[clusterIndex];\n\n\t\t\t\t\t\tif (count < limit) {\n\t\t\t\t\t\t\tclusters[pixelsPerCellCount * clusterIndex * 4 + count] = i;\n\t\t\t\t\t\t\tcounts[clusterIndex] = count + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate(lights, gammaCorrection, lightingParams) {\n\t\tthis.updateParams(lightingParams);\n\t\tthis.updateCells();\n\t\tthis.collectLights(lights);\n\t\tthis.evaluateBounds();\n\t\tthis.evaluateCompressionLimits(gammaCorrection);\n\t\tthis.updateClusters(gammaCorrection);\n\t\tthis.uploadTextures();\n\t}\n\n\tactivate() {\n\t\tthis.updateUniforms();\n\t}\n\n}\n\nclass DepthMaterial extends Material {\n\tupdateShader(device) {\n\t\tconst options = {\n\t\t\tskin: !!this.meshInstances[0].skinInstance\n\t\t};\n\t\tconst library = device.getProgramLibrary();\n\t\tthis.shader = library.getProgram('depth', options);\n\t}\n\n}\n\nconst textureBlitVertexShader = `\n\t\tattribute vec2 vertex_position;\n\t\tvarying vec2 uv0;\n\t\tvoid main(void) {\n\t\t\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\t\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t}`;\nconst textureBlitFragmentShader = `\n\t\tvarying vec2 uv0;\n\t\tuniform sampler2D blitTexture;\n\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = texture2D(blitTexture, uv0);\n\t\t}`;\nconst textureCubeBlitFragmentShader = `\n\t\tvarying vec2 uv0;\n\t\tuniform samplerCube blitTexture;\n\t\tuniform mat4 invViewProj;\n\t\tvoid main(void) {\n\t\t\t\tvec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n\t\t\t\tvec4 worldPos = invViewProj * projPos;\n\t\t\t\tgl_FragColor = textureCube(blitTexture, worldPos.xyz);\n\t\t}`;\n\nconst _viewport$1 = new Vec4();\n\nclass CookieRenderer {\n\tconstructor(device, lightTextureAtlas) {\n\t\tthis.device = device;\n\t\tthis.lightTextureAtlas = lightTextureAtlas;\n\t\tthis.blitShader2d = null;\n\t\tthis.blitShaderCube = null;\n\t\tthis.blitTextureId = null;\n\t\tthis.invViewProjId = null;\n\t}\n\n\tdestroy() {}\n\n\tgetShader(shader, fragment) {\n\t\tif (!this[shader]) this[shader] = createShaderFromCode(this.device, textureBlitVertexShader, fragment, `cookie_renderer_${shader}`);\n\t\tif (!this.blitTextureId) this.blitTextureId = this.device.scope.resolve(\"blitTexture\");\n\t\tif (!this.invViewProjId) this.invViewProjId = this.device.scope.resolve(\"invViewProj\");\n\t\treturn this[shader];\n\t}\n\n\tget shader2d() {\n\t\treturn this.getShader(\"blitShader2d\", textureBlitFragmentShader);\n\t}\n\n\tget shaderCube() {\n\t\treturn this.getShader(\"blitShaderCube\", textureCubeBlitFragmentShader);\n\t}\n\n\tstatic createTexture(device, resolution) {\n\t\tconst texture = new Texture(device, {\n\t\t\tname: \"CookieAtlas\",\n\t\t\twidth: resolution,\n\t\t\theight: resolution,\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\tcubemap: false,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\treturn texture;\n\t}\n\n\tinitInvViewProjMatrices() {\n\t\tif (!CookieRenderer._invViewProjMatrices) {\n\t\t\tCookieRenderer._invViewProjMatrices = [];\n\n\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\tconst camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);\n\t\t\t\tconst projMat = camera.projectionMatrix;\n\t\t\t\tconst viewMat = camera.node.getLocalTransform().clone().invert();\n\t\t\t\tCookieRenderer._invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();\n\t\t\t}\n\t\t}\n\t}\n\n\trender(light, renderTarget) {\n\t\tif (light.enabled && light.cookie && light.visibleThisFrame) {\n\t\t\tconst faceCount = light.numShadowFaces;\n\t\t\tconst shader = faceCount > 1 ? this.shaderCube : this.shader2d;\n\t\t\tconst device = this.device;\n\n\t\t\tif (faceCount > 1) {\n\t\t\t\tthis.initInvViewProjMatrices();\n\t\t\t}\n\n\t\t\tthis.blitTextureId.setValue(light.cookie);\n\n\t\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\t\t_viewport$1.copy(light.atlasViewport);\n\n\t\t\t\tif (faceCount > 1) {\n\t\t\t\t\tconst smallSize = _viewport$1.z / 3;\n\t\t\t\t\tconst offset = this.lightTextureAtlas.cubeSlotsOffsets[face];\n\t\t\t\t\t_viewport$1.x += smallSize * offset.x;\n\t\t\t\t\t_viewport$1.y += smallSize * offset.y;\n\t\t\t\t\t_viewport$1.z = smallSize;\n\t\t\t\t\t_viewport$1.w = smallSize;\n\t\t\t\t\tthis.invViewProjId.setValue(CookieRenderer._invViewProjMatrices[face].data);\n\t\t\t\t}\n\n\t\t\t\t_viewport$1.mulScalar(renderTarget.colorBuffer.width);\n\n\t\t\t\tdrawQuadWithShader(device, renderTarget, shader, _viewport$1);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nCookieRenderer._invViewProjMatrices = null;\n\nclass ShadowMap {\n\tconstructor(texture, targets) {\n\t\tthis.texture = texture;\n\t\tthis.cached = false;\n\t\tthis.renderTargets = targets;\n\t}\n\n\tdestroy() {\n\t\tif (this.texture) {\n\t\t\tthis.texture.destroy();\n\t\t\tthis.texture = null;\n\t\t}\n\n\t\tconst targets = this.renderTargets;\n\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\ttargets[i].destroy();\n\t\t}\n\n\t\tthis.renderTargets.length = 0;\n\t}\n\n\tstatic getShadowFormat(device, shadowType) {\n\t\tif (shadowType === SHADOW_VSM32) {\n\t\t\treturn PIXELFORMAT_RGBA32F;\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\treturn PIXELFORMAT_RGBA16F;\n\t\t} else if (shadowType === SHADOW_PCF5) {\n\t\t\treturn PIXELFORMAT_DEPTH;\n\t\t} else if (shadowType === SHADOW_PCF3 && device.webgl2) {\n\t\t\treturn PIXELFORMAT_DEPTH;\n\t\t}\n\n\t\treturn PIXELFORMAT_R8_G8_B8_A8;\n\t}\n\n\tstatic getShadowFiltering(device, shadowType) {\n\t\tif (shadowType === SHADOW_PCF3 && !device.webgl2) {\n\t\t\treturn FILTER_NEAREST;\n\t\t} else if (shadowType === SHADOW_VSM32) {\n\t\t\treturn device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\treturn device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;\n\t\t}\n\n\t\treturn FILTER_LINEAR;\n\t}\n\n\tstatic create(device, light) {\n\t\tlet shadowMap = null;\n\n\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\tshadowMap = this.createCubemap(device, light._shadowResolution);\n\t\t} else {\n\t\t\tshadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);\n\t\t}\n\n\t\treturn shadowMap;\n\t}\n\n\tstatic createAtlas(device, resolution, shadowType) {\n\t\tconst shadowMap = this.create2dMap(device, resolution, shadowType);\n\t\tconst targets = shadowMap.renderTargets;\n\t\tconst rt = targets[0];\n\n\t\tfor (let i = 0; i < 5; i++) {\n\t\t\ttargets.push(rt);\n\t\t}\n\n\t\treturn shadowMap;\n\t}\n\n\tstatic create2dMap(device, size, shadowType) {\n\t\tconst format = this.getShadowFormat(device, shadowType);\n\t\tconst filter = this.getShadowFiltering(device, shadowType);\n\t\tconst texture = new Texture(device, {\n\t\t\tformat: format,\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: filter,\n\t\t\tmagFilter: filter,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\ttexture.name = 'ShadowMap2D';\n\t\tlet target = null;\n\n\t\tif (shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2) {\n\t\t\ttexture.compareOnRead = true;\n\t\t\ttexture.compareFunc = FUNC_LESS;\n\t\t\ttarget = new RenderTarget({\n\t\t\t\tdepthBuffer: texture\n\t\t\t});\n\t\t} else {\n\t\t\ttarget = new RenderTarget({\n\t\t\t\tcolorBuffer: texture,\n\t\t\t\tdepth: true\n\t\t\t});\n\t\t}\n\n\t\treturn new ShadowMap(texture, [target]);\n\t}\n\n\tstatic createCubemap(device, size) {\n\t\tconst cubemap = new Texture(device, {\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tcubemap: true,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tcubemap.name = 'ShadowMapCube';\n\t\tconst targets = [];\n\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst target = new RenderTarget({\n\t\t\t\tcolorBuffer: cubemap,\n\t\t\t\tface: i,\n\t\t\t\tdepth: true\n\t\t\t});\n\t\t\ttargets.push(target);\n\t\t}\n\n\t\treturn new ShadowMap(cubemap, targets);\n\t}\n\n}\n\nconst _tempArray = [];\nconst _tempArray2 = [];\n\nconst _viewport = new Vec4();\n\nconst _scissor = new Vec4();\n\nclass Slot {\n\tconstructor(rect) {\n\t\tthis.size = Math.floor(rect.w * 1024);\n\t\tthis.used = false;\n\t\tthis.lightId = -1;\n\t\tthis.rect = rect;\n\t}\n\n}\n\nclass LightTextureAtlas {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.version = 1;\n\t\tthis.shadowAtlasResolution = 2048;\n\t\tthis.shadowAtlas = null;\n\t\tthis.shadowEdgePixels = 3;\n\t\tthis.cookieAtlasResolution = 2048;\n\t\tthis.cookieAtlas = null;\n\t\tthis.cookieRenderTarget = null;\n\t\tthis.slots = [];\n\t\tthis.atlasSplit = [];\n\t\tthis.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];\n\t\tthis.scissorVec = new Vec4();\n\t\tthis.allocateShadowAtlas(1);\n\t\tthis.allocateCookieAtlas(1);\n\t\tthis.allocateUniforms();\n\t}\n\n\tdestroy() {\n\t\tthis.destroyShadowAtlas();\n\t\tthis.destroyCookieAtlas();\n\t}\n\n\tdestroyShadowAtlas() {\n\t\tif (this.shadowAtlas) {\n\t\t\tthis.shadowAtlas.destroy();\n\t\t\tthis.shadowAtlas = null;\n\t\t}\n\t}\n\n\tdestroyCookieAtlas() {\n\t\tif (this.cookieAtlas) {\n\t\t\tthis.cookieAtlas.destroy();\n\t\t\tthis.cookieAtlas = null;\n\t\t}\n\n\t\tif (this.cookieRenderTarget) {\n\t\t\tthis.cookieRenderTarget.destroy();\n\t\t\tthis.cookieRenderTarget = null;\n\t\t}\n\t}\n\n\tallocateShadowAtlas(resolution) {\n\t\tif (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {\n\t\t\tthis.version++;\n\t\t\tthis.destroyShadowAtlas();\n\t\t\tthis.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);\n\t\t\tthis.shadowAtlas.cached = true;\n\t\t\tconst scissorOffset = 4 / this.shadowAtlasResolution;\n\t\t\tthis.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);\n\t\t}\n\t}\n\n\tallocateCookieAtlas(resolution) {\n\t\tif (!this.cookieAtlas || this.cookieAtlas.width !== resolution) {\n\t\t\tthis.version++;\n\t\t\tthis.destroyCookieAtlas();\n\t\t\tthis.cookieAtlas = CookieRenderer.createTexture(this.device, resolution);\n\t\t\tthis.cookieRenderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: this.cookieAtlas,\n\t\t\t\tdepth: false,\n\t\t\t\tflipY: true\n\t\t\t});\n\t\t}\n\t}\n\n\tallocateUniforms() {\n\t\tthis._shadowAtlasTextureId = this.device.scope.resolve(\"shadowAtlasTexture\");\n\t\tthis._shadowAtlasParamsId = this.device.scope.resolve(\"shadowAtlasParams\");\n\t\tthis._shadowAtlasParams = new Float32Array(2);\n\t\tthis._cookieAtlasTextureId = this.device.scope.resolve(\"cookieAtlasTexture\");\n\t}\n\n\tupdateUniforms() {\n\t\tconst isShadowFilterPcf = true;\n\t\tconst rt = this.shadowAtlas.renderTargets[0];\n\t\tconst shadowBuffer = this.device.webgl2 && isShadowFilterPcf ? rt.depthBuffer : rt.colorBuffer;\n\n\t\tthis._shadowAtlasTextureId.setValue(shadowBuffer);\n\n\t\tthis._shadowAtlasParams[0] = this.shadowAtlasResolution;\n\t\tthis._shadowAtlasParams[1] = this.shadowEdgePixels;\n\n\t\tthis._shadowAtlasParamsId.setValue(this._shadowAtlasParams);\n\n\t\tthis._cookieAtlasTextureId.setValue(this.cookieAtlas);\n\t}\n\n\tsubdivide(numLights, lightingParams) {\n\t\tlet atlasSplit = lightingParams.atlasSplit;\n\n\t\tif (!atlasSplit) {\n\t\t\tconst gridSize = Math.ceil(Math.sqrt(numLights));\n\t\t\tatlasSplit = _tempArray2;\n\t\t\tatlasSplit[0] = gridSize;\n\t\t\tatlasSplit.length = 1;\n\t\t}\n\n\t\tconst arraysEqual = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\n\n\t\tif (!arraysEqual(atlasSplit, this.atlasSplit)) {\n\t\t\tthis.version++;\n\t\t\tthis.slots.length = 0;\n\t\t\tthis.atlasSplit.length = 0;\n\t\t\tthis.atlasSplit.push(...atlasSplit);\n\t\t\tconst splitCount = this.atlasSplit[0];\n\n\t\t\tif (splitCount > 1) {\n\t\t\t\tconst invSize = 1 / splitCount;\n\n\t\t\t\tfor (let i = 0; i < splitCount; i++) {\n\t\t\t\t\tfor (let j = 0; j < splitCount; j++) {\n\t\t\t\t\t\tconst rect = new Vec4(i * invSize, j * invSize, invSize, invSize);\n\t\t\t\t\t\tconst nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];\n\n\t\t\t\t\t\tif (nextLevelSplit > 1) {\n\t\t\t\t\t\t\tfor (let x = 0; x < nextLevelSplit; x++) {\n\t\t\t\t\t\t\t\tfor (let y = 0; y < nextLevelSplit; y++) {\n\t\t\t\t\t\t\t\t\tconst invSizeNext = invSize / nextLevelSplit;\n\t\t\t\t\t\t\t\t\tconst rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);\n\t\t\t\t\t\t\t\t\tthis.slots.push(new Slot(rectNext));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.slots.push(new Slot(rect));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.slots.push(new Slot(new Vec4(0, 0, 1, 1)));\n\t\t\t}\n\n\t\t\tthis.slots.sort((a, b) => {\n\t\t\t\treturn b.size - a.size;\n\t\t\t});\n\t\t}\n\t}\n\n\tcollectLights(spotLights, omniLights, lightingParams) {\n\t\tconst cookiesEnabled = lightingParams.cookiesEnabled;\n\t\tconst shadowsEnabled = lightingParams.shadowsEnabled;\n\t\tlet needsShadowAtlas = false;\n\t\tlet needsCookieAtlas = false;\n\t\tconst lights = _tempArray;\n\t\tlights.length = 0;\n\n\t\tconst processLights = list => {\n\t\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\t\tconst light = list[i];\n\n\t\t\t\tif (light.visibleThisFrame) {\n\t\t\t\t\tconst lightShadow = shadowsEnabled && light.castShadows;\n\t\t\t\t\tconst lightCookie = cookiesEnabled && !!light.cookie;\n\t\t\t\t\tneedsShadowAtlas || (needsShadowAtlas = lightShadow);\n\t\t\t\t\tneedsCookieAtlas || (needsCookieAtlas = lightCookie);\n\n\t\t\t\t\tif (lightShadow || lightCookie) {\n\t\t\t\t\t\tlights.push(light);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (cookiesEnabled || shadowsEnabled) {\n\t\t\tprocessLights(spotLights);\n\t\t\tprocessLights(omniLights);\n\t\t}\n\n\t\tlights.sort((a, b) => {\n\t\t\treturn b.maxScreenSize - a.maxScreenSize;\n\t\t});\n\n\t\tif (needsShadowAtlas) {\n\t\t\tthis.allocateShadowAtlas(this.shadowAtlasResolution);\n\t\t}\n\n\t\tif (needsCookieAtlas) {\n\t\t\tthis.allocateCookieAtlas(this.cookieAtlasResolution);\n\t\t}\n\n\t\tif (needsShadowAtlas || needsCookieAtlas) {\n\t\t\tthis.subdivide(lights.length, lightingParams);\n\t\t}\n\n\t\treturn lights;\n\t}\n\n\tsetupSlot(light, rect) {\n\t\tlight.atlasViewport.copy(rect);\n\t\tconst faceCount = light.numShadowFaces;\n\n\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\tif (light.castShadows || light._cookie) {\n\t\t\t\t_viewport.copy(rect);\n\n\t\t\t\t_scissor.copy(rect);\n\n\t\t\t\tif (light._type === LIGHTTYPE_SPOT) {\n\t\t\t\t\t_viewport.add(this.scissorVec);\n\t\t\t\t}\n\n\t\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\t\tconst smallSize = _viewport.z / 3;\n\t\t\t\t\tconst offset = this.cubeSlotsOffsets[face];\n\t\t\t\t\t_viewport.x += smallSize * offset.x;\n\t\t\t\t\t_viewport.y += smallSize * offset.y;\n\t\t\t\t\t_viewport.z = smallSize;\n\t\t\t\t\t_viewport.w = smallSize;\n\n\t\t\t\t\t_scissor.copy(_viewport);\n\t\t\t\t}\n\n\t\t\t\tif (light.castShadows) {\n\t\t\t\t\tconst lightRenderData = light.getRenderData(null, face);\n\t\t\t\t\tlightRenderData.shadowViewport.copy(_viewport);\n\t\t\t\t\tlightRenderData.shadowScissor.copy(_scissor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tassignSlot(light, slotIndex, slotReassigned) {\n\t\tlight.atlasViewportAllocated = true;\n\t\tconst slot = this.slots[slotIndex];\n\t\tslot.lightId = light.id;\n\t\tslot.used = true;\n\n\t\tif (slotReassigned) {\n\t\t\tlight.atlasSlotUpdated = true;\n\t\t\tlight.atlasVersion = this.version;\n\t\t\tlight.atlasSlotIndex = slotIndex;\n\t\t}\n\t}\n\n\tupdate(spotLights, omniLights, lightingParams) {\n\t\tthis.shadowAtlasResolution = lightingParams.shadowAtlasResolution;\n\t\tthis.cookieAtlasResolution = lightingParams.cookieAtlasResolution;\n\t\tconst lights = this.collectLights(spotLights, omniLights, lightingParams);\n\n\t\tif (lights.length > 0) {\n\t\t\tconst slots = this.slots;\n\n\t\t\tfor (let i = 0; i < slots.length; i++) {\n\t\t\t\tslots[i].used = false;\n\t\t\t}\n\n\t\t\tconst assignCount = Math.min(lights.length, slots.length);\n\n\t\t\tfor (let i = 0; i < assignCount; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tif (light.castShadows) light._shadowMap = this.shadowAtlas;\n\t\t\t\tconst previousSlot = slots[light.atlasSlotIndex];\n\n\t\t\t\tif (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {\n\t\t\t\t\tconst _previousSlot = slots[light.atlasSlotIndex];\n\n\t\t\t\t\tif (_previousSlot.size === slots[i].size && !_previousSlot.used) {\n\t\t\t\t\t\tthis.assignSlot(light, light.atlasSlotIndex, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet usedCount = 0;\n\n\t\t\tfor (let i = 0; i < assignCount; i++) {\n\t\t\t\twhile (usedCount < slots.length && slots[usedCount].used) usedCount++;\n\n\t\t\t\tconst light = lights[i];\n\n\t\t\t\tif (!light.atlasViewportAllocated) {\n\t\t\t\t\tthis.assignSlot(light, usedCount, true);\n\t\t\t\t}\n\n\t\t\t\tconst slot = slots[light.atlasSlotIndex];\n\t\t\t\tthis.setupSlot(light, slot.rect);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateUniforms();\n\t}\n\n}\n\nclass ShadowMapCache {\n\tconstructor() {\n\t\tthis.shadowMapCache = new Map();\n\t}\n\n\tdestroy() {\n\t\tthis.clear();\n\t\tthis.shadowMapCache = null;\n\t}\n\n\tclear() {\n\t\tthis.shadowMapCache.forEach(shadowMaps => {\n\t\t\tshadowMaps.forEach(shadowMap => {\n\t\t\t\tshadowMap.destroy();\n\t\t\t});\n\t\t});\n\t\tthis.shadowMapCache.clear();\n\t}\n\n\tgetKey(light) {\n\t\tconst isCubeMap = light._type === LIGHTTYPE_OMNI;\n\t\tconst shadowType = light._shadowType;\n\t\tconst resolution = light._shadowResolution;\n\t\treturn `${isCubeMap}-${shadowType}-${resolution}`;\n\t}\n\n\tget(device, light) {\n\t\tconst key = this.getKey(light);\n\t\tconst shadowMaps = this.shadowMapCache.get(key);\n\n\t\tif (shadowMaps && shadowMaps.length) {\n\t\t\treturn shadowMaps.pop();\n\t\t}\n\n\t\tconst shadowMap = ShadowMap.create(device, light);\n\t\tshadowMap.cached = true;\n\t\treturn shadowMap;\n\t}\n\n\tadd(light, shadowMap) {\n\t\tconst key = this.getKey(light);\n\t\tconst shadowMaps = this.shadowMapCache.get(key);\n\n\t\tif (shadowMaps) {\n\t\t\tshadowMaps.push(shadowMap);\n\t\t} else {\n\t\t\tthis.shadowMapCache.set(key, [shadowMap]);\n\t\t}\n\t}\n\n}\n\nconst aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\nconst _depthRange = {\n\tmin: 0,\n\tmax: 0\n};\n\nfunction getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {\n\taabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;\n\taabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;\n\taabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;\n\taabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;\n\taabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;\n\taabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;\n\tlet minz = 9999999999;\n\tlet maxz = -9999999999;\n\n\tfor (let i = 0; i < 8; ++i) {\n\t\tcameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);\n\t\tconst z = aabbPoints[i].z;\n\t\tif (z < minz) minz = z;\n\t\tif (z > maxz) maxz = z;\n\t}\n\n\t_depthRange.min = minz;\n\t_depthRange.max = maxz;\n\treturn _depthRange;\n}\n\nfunction gauss(x, sigma) {\n\treturn Math.exp(-(x * x) / (2.0 * sigma * sigma));\n}\n\nconst maxBlurSize = 25;\n\nfunction gaussWeights(kernelSize) {\n\tif (kernelSize > maxBlurSize) {\n\t\tkernelSize = maxBlurSize;\n\t}\n\n\tconst sigma = (kernelSize - 1) / (2 * 3);\n\tconst halfWidth = (kernelSize - 1) * 0.5;\n\tconst values = new Array(kernelSize);\n\tlet sum = 0.0;\n\n\tfor (let i = 0; i < kernelSize; ++i) {\n\t\tvalues[i] = gauss(i - halfWidth, sigma);\n\t\tsum += values[i];\n\t}\n\n\tfor (let i = 0; i < kernelSize; ++i) {\n\t\tvalues[i] /= sum;\n\t}\n\n\treturn values;\n}\n\nconst visibleSceneAabb = new BoundingBox();\nconst shadowCamView = new Mat4();\nconst shadowCamViewProj = new Mat4();\nconst pixelOffset = new Float32Array(2);\nconst blurScissorRect = {\n\tx: 1,\n\ty: 1,\n\tz: 0,\n\tw: 0\n};\nconst opChanId = {\n\tr: 1,\n\tg: 2,\n\tb: 3,\n\ta: 4\n};\nconst center = new Vec3();\nconst viewportMatrix = new Mat4();\n\nfunction getDepthKey(meshInstance) {\n\tconst material = meshInstance.material;\n\tconst x = meshInstance.skinInstance ? 10 : 0;\n\tlet y = 0;\n\n\tif (material.opacityMap) {\n\t\tconst opChan = material.opacityMapChannel;\n\n\t\tif (opChan) {\n\t\t\ty = opChanId[opChan];\n\t\t}\n\t}\n\n\treturn x + y;\n}\n\nclass ShadowRenderer {\n\tconstructor(forwardRenderer, lightTextureAtlas) {\n\t\tthis.device = forwardRenderer.device;\n\t\tthis.forwardRenderer = forwardRenderer;\n\t\tthis.lightTextureAtlas = lightTextureAtlas;\n\t\tconst scope = this.device.scope;\n\t\tthis.polygonOffsetId = scope.resolve(\"polygonOffset\");\n\t\tthis.polygonOffset = new Float32Array(2);\n\t\tthis.sourceId = scope.resolve(\"source\");\n\t\tthis.pixelOffsetId = scope.resolve(\"pixelOffset\");\n\t\tthis.weightId = scope.resolve(\"weight[0]\");\n\t\tthis.blurVsmShaderCode = [shaderChunks.blurVSMPS, \"#define GAUSS\\n\" + shaderChunks.blurVSMPS];\n\t\tconst packed = \"#define PACKED\\n\";\n\t\tthis.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];\n\t\tthis.blurVsmShader = [{}, {}];\n\t\tthis.blurPackedVsmShader = [{}, {}];\n\t\tthis.blurVsmWeights = {};\n\t\tthis.shadowMapLightRadiusId = scope.resolve('light_radius');\n\t\tthis.shadowMapCache = new ShadowMapCache();\n\t}\n\n\tdestroy() {\n\t\tthis.shadowMapCache.destroy();\n\t\tthis.shadowMapCache = null;\n\t}\n\n\tstatic createShadowCamera(device, shadowType, type, face) {\n\t\tconst shadowCam = LightCamera.create(\"ShadowCamera\", type, face);\n\n\t\tif (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {\n\t\t\tshadowCam.clearColor = new Color(0, 0, 0, 0);\n\t\t} else {\n\t\t\tshadowCam.clearColor = new Color(1, 1, 1, 1);\n\t\t}\n\n\t\tshadowCam.clearDepthBuffer = true;\n\t\tshadowCam.clearStencilBuffer = false;\n\t\treturn shadowCam;\n\t}\n\n\tstatic setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {\n\t\tlet hwPcf = shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCF3 && device.webgl2;\n\n\t\tif (type === LIGHTTYPE_OMNI && !isClustered) {\n\t\t\thwPcf = false;\n\t\t}\n\n\t\tshadowCam.clearColorBuffer = !hwPcf;\n\t}\n\n\tcullShadowCasters(meshInstances, visible, camera) {\n\t\tlet count = 0;\n\t\tconst numInstances = meshInstances.length;\n\n\t\tfor (let i = 0; i < numInstances; i++) {\n\t\t\tconst meshInstance = meshInstances[i];\n\n\t\t\tif (!meshInstance.cull || meshInstance._isVisible(camera)) {\n\t\t\t\tmeshInstance.visibleThisFrame = true;\n\t\t\t\tvisible[count] = meshInstance;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\tvisible.length = count;\n\t\tvisible.sort(this.forwardRenderer.depthSortCompare);\n\t}\n\n\tcullLocal(light, drawCalls) {\n\t\tconst isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;\n\t\tlight.visibleThisFrame = true;\n\n\t\tif (!isClustered) {\n\t\t\tif (!light._shadowMap) {\n\t\t\t\tlight._shadowMap = ShadowMap.create(this.device, light);\n\t\t\t}\n\t\t}\n\n\t\tconst type = light._type;\n\t\tconst faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;\n\n\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\tconst lightRenderData = light.getRenderData(null, face);\n\t\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\t\tshadowCam.nearClip = light.attenuationEnd / 1000;\n\t\t\tshadowCam.farClip = light.attenuationEnd;\n\t\t\tconst shadowCamNode = shadowCam._node;\n\t\t\tconst lightNode = light._node;\n\t\t\tshadowCamNode.setPosition(lightNode.getPosition());\n\n\t\t\tif (type === LIGHTTYPE_SPOT) {\n\t\t\t\tshadowCam.fov = light._outerConeAngle * 2;\n\t\t\t\tshadowCamNode.setRotation(lightNode.getRotation());\n\t\t\t\tshadowCamNode.rotateLocal(-90, 0, 0);\n\t\t\t} else if (type === LIGHTTYPE_OMNI) {\n\t\t\t\tif (isClustered) {\n\t\t\t\t\tconst tileSize = this.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;\n\t\t\t\t\tconst texelSize = 2 / tileSize;\n\t\t\t\t\tconst filterSize = texelSize * this.lightTextureAtlas.shadowEdgePixels;\n\t\t\t\t\tshadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;\n\t\t\t\t} else {\n\t\t\t\t\tshadowCam.fov = 90;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.forwardRenderer.updateCameraFrustum(shadowCam);\n\t\t\tthis.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);\n\t\t}\n\t}\n\n\tgenerateSplitDistances(light, nearDist, farDist) {\n\t\tlight._shadowCascadeDistances.fill(farDist);\n\n\t\tfor (let i = 1; i < light.numCascades; i++) {\n\t\t\tconst fraction = i / light.numCascades;\n\t\t\tconst linearDist = nearDist + (farDist - nearDist) * fraction;\n\t\t\tconst logDist = nearDist * (farDist / nearDist) ** fraction;\n\t\t\tconst dist = math.lerp(linearDist, logDist, light.cascadeDistribution);\n\t\t\tlight._shadowCascadeDistances[i - 1] = dist;\n\t\t}\n\t}\n\n\tcullDirectional(light, drawCalls, camera) {\n\t\tlight.visibleThisFrame = true;\n\n\t\tif (!light._shadowMap) {\n\t\t\tlight._shadowMap = ShadowMap.create(this.device, light);\n\t\t}\n\n\t\tconst nearDist = camera._nearClip;\n\t\tthis.generateSplitDistances(light, nearDist, light.shadowDistance);\n\n\t\tfor (let cascade = 0; cascade < light.numCascades; cascade++) {\n\t\t\tconst lightRenderData = light.getRenderData(camera, cascade);\n\t\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\t\tshadowCam.renderTarget = light._shadowMap.renderTargets[0];\n\t\t\tlightRenderData.shadowViewport.copy(light.cascades[cascade]);\n\t\t\tlightRenderData.shadowScissor.copy(light.cascades[cascade]);\n\t\t\tconst shadowCamNode = shadowCam._node;\n\t\t\tconst lightNode = light._node;\n\t\t\tshadowCamNode.setPosition(lightNode.getPosition());\n\t\t\tshadowCamNode.setRotation(lightNode.getRotation());\n\t\t\tshadowCamNode.rotateLocal(-90, 0, 0);\n\t\t\tconst frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];\n\t\t\tconst frustumFarDist = light._shadowCascadeDistances[cascade];\n\t\t\tconst frustumPoints = Frustum.getPoints(camera, frustumNearDist, frustumFarDist);\n\t\t\tcenter.set(0, 0, 0);\n\t\t\tconst cameraWorldMat = camera.node.getWorldTransform();\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tcameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);\n\t\t\t\tcenter.add(frustumPoints[i]);\n\t\t\t}\n\n\t\t\tcenter.mulScalar(1 / 8);\n\t\t\tlet radius = 0;\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tconst dist = frustumPoints[i].sub(center).length();\n\t\t\t\tif (dist > radius) radius = dist;\n\t\t\t}\n\n\t\t\tconst right = shadowCamNode.right;\n\t\t\tconst up = shadowCamNode.up;\n\t\t\tconst lightDir = shadowCamNode.forward;\n\t\t\tconst sizeRatio = 0.25 * light._shadowResolution / radius;\n\t\t\tconst x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;\n\t\t\tconst y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;\n\t\t\tconst scaledUp = up.mulScalar(x);\n\t\t\tconst scaledRight = right.mulScalar(y);\n\t\t\tconst dot = center.dot(lightDir);\n\t\t\tconst scaledDir = lightDir.mulScalar(dot);\n\t\t\tcenter.add2(scaledUp, scaledRight).add(scaledDir);\n\t\t\tshadowCamNode.setPosition(center);\n\t\t\tshadowCamNode.translateLocal(0, 0, 1000000);\n\t\t\tshadowCam.nearClip = 0;\n\t\t\tshadowCam.farClip = 2000000;\n\t\t\tshadowCam.orthoHeight = radius;\n\t\t\tthis.forwardRenderer.updateCameraFrustum(shadowCam);\n\t\t\tthis.cullShadowCasters(drawCalls, lightRenderData.visibleCasters, shadowCam);\n\t\t\tlet emptyAabb = true;\n\t\t\tconst visibleCasters = lightRenderData.visibleCasters;\n\n\t\t\tfor (let i = 0; i < visibleCasters.length; i++) {\n\t\t\t\tconst meshInstance = visibleCasters[i];\n\n\t\t\t\tif (emptyAabb) {\n\t\t\t\t\temptyAabb = false;\n\t\t\t\t\tvisibleSceneAabb.copy(meshInstance.aabb);\n\t\t\t\t} else {\n\t\t\t\t\tvisibleSceneAabb.add(meshInstance.aabb);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tshadowCamView.copy(shadowCamNode.getWorldTransform()).invert();\n\t\t\tconst depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());\n\t\t\tshadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);\n\t\t\tshadowCam.farClip = depthRange.max - depthRange.min + 0.2;\n\t\t}\n\t}\n\n\tsetupRenderState(device, light) {\n\t\tconst isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;\n\n\t\tif (device.webgl2) {\n\t\t\tif (light._type === LIGHTTYPE_OMNI && !isClustered) {\n\t\t\t\tdevice.setDepthBias(false);\n\t\t\t} else {\n\t\t\t\tdevice.setDepthBias(true);\n\t\t\t\tdevice.setDepthBiasValues(light.shadowBias * -1000.0, light.shadowBias * -1000.0);\n\t\t\t}\n\t\t} else if (device.extStandardDerivatives) {\n\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\tthis.polygonOffset[0] = 0;\n\t\t\t\tthis.polygonOffset[1] = 0;\n\t\t\t\tthis.polygonOffsetId.setValue(this.polygonOffset);\n\t\t\t} else {\n\t\t\t\tthis.polygonOffset[0] = light.shadowBias * -1000.0;\n\t\t\t\tthis.polygonOffset[1] = light.shadowBias * -1000.0;\n\t\t\t\tthis.polygonOffsetId.setValue(this.polygonOffset);\n\t\t\t}\n\t\t}\n\n\t\tdevice.setBlending(false);\n\t\tdevice.setDepthWrite(true);\n\t\tdevice.setDepthTest(true);\n\t\tdevice.setDepthFunc(FUNC_LESSEQUAL);\n\t\tconst useShadowSampler = isClustered ? light._isPcf && device.webgl2 : light._isPcf && device.webgl2 && light._type !== LIGHTTYPE_OMNI;\n\n\t\tif (useShadowSampler) {\n\t\t\tdevice.setColorWrite(false, false, false, false);\n\t\t} else {\n\t\t\tdevice.setColorWrite(true, true, true, true);\n\t\t}\n\t}\n\n\trestoreRenderState(device) {\n\t\tif (device.webgl2) {\n\t\t\tdevice.setDepthBias(false);\n\t\t} else if (device.extStandardDerivatives) {\n\t\t\tthis.polygonOffset[0] = 0;\n\t\t\tthis.polygonOffset[1] = 0;\n\t\t\tthis.polygonOffsetId.setValue(this.polygonOffset);\n\t\t}\n\t}\n\n\tdispatchUniforms(light, shadowCam, lightRenderData, face) {\n\t\tconst shadowCamNode = shadowCam._node;\n\n\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tthis.forwardRenderer.dispatchViewPos(shadowCamNode.getPosition());\n\t\t\tthis.shadowMapLightRadiusId.setValue(light.attenuationEnd);\n\t\t}\n\n\t\tshadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();\n\t\tshadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);\n\t\tconst rectViewport = lightRenderData.shadowViewport;\n\t\tshadowCam.rect = rectViewport;\n\t\tshadowCam.scissorRect = lightRenderData.shadowScissor;\n\t\tviewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);\n\t\tlightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);\n\n\t\tif (light._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\tlight._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);\n\t\t}\n\t}\n\n\tsubmitCasters(visibleCasters, light) {\n\t\tconst device = this.device;\n\t\tconst forwardRenderer = this.forwardRenderer;\n\t\tconst shadowPass = 1 << SHADER_SHADOW;\n\t\tconst shadowType = light._shadowType;\n\t\tconst smode = shadowType + light._type * SHADOW_COUNT;\n\t\tconst count = visibleCasters.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst meshInstance = visibleCasters[i];\n\t\t\tconst mesh = meshInstance.mesh;\n\t\t\tconst material = meshInstance.material;\n\t\t\tforwardRenderer.setBaseConstants(device, material);\n\t\t\tforwardRenderer.setSkinning(device, meshInstance, material);\n\n\t\t\tif (material.dirty) {\n\t\t\t\tmaterial.updateUniforms(device, forwardRenderer.scene);\n\t\t\t\tmaterial.dirty = false;\n\t\t\t}\n\n\t\t\tif (material.chunks) {\n\t\t\t\tforwardRenderer.setCullMode(true, false, meshInstance);\n\t\t\t\tmaterial.setParameters(device);\n\t\t\t\tmeshInstance.setParameters(device, shadowPass);\n\t\t\t}\n\n\t\t\tlet shadowShader = meshInstance._shader[SHADER_SHADOW + smode];\n\n\t\t\tif (!shadowShader) {\n\t\t\t\tforwardRenderer.updateShader(meshInstance, meshInstance._shaderDefs, null, SHADER_SHADOW + smode);\n\t\t\t\tshadowShader = meshInstance._shader[SHADER_SHADOW + smode];\n\t\t\t\tmeshInstance._key[SORTKEY_DEPTH] = getDepthKey(meshInstance);\n\t\t\t}\n\n\t\t\tdevice.setShader(shadowShader);\n\t\t\tforwardRenderer.setVertexBuffers(device, mesh);\n\t\t\tforwardRenderer.setMorphing(device, meshInstance.morphInstance);\n\t\t\tconst style = meshInstance.renderStyle;\n\t\t\tdevice.setIndexBuffer(mesh.indexBuffer[style]);\n\t\t\ti += forwardRenderer.drawInstance(device, meshInstance, mesh, style);\n\t\t\tforwardRenderer._shadowDrawCalls++;\n\t\t}\n\t}\n\n\trender(light, camera) {\n\t\tif (light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame) {\n\t\t\tconst device = this.device;\n\n\t\t\tif (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {\n\t\t\t\tlight.shadowUpdateMode = SHADOWUPDATE_NONE;\n\t\t\t}\n\n\t\t\tconst type = light._type;\n\t\t\tconst shadowType = light._shadowType;\n\t\t\tconst faceCount = light.numShadowFaces;\n\t\t\tconst forwardRenderer = this.forwardRenderer;\n\t\t\tforwardRenderer._shadowMapUpdates += faceCount;\n\t\t\tconst isClustered = forwardRenderer.scene.clusteredLightingEnabled;\n\t\t\tthis.setupRenderState(device, light);\n\n\t\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\t\tconst lightRenderData = light.getRenderData(type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);\n\t\t\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\t\t\tShadowRenderer.setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered);\n\t\t\t\tconst renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;\n\t\t\t\tshadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];\n\t\t\t\tthis.dispatchUniforms(light, shadowCam, lightRenderData, face);\n\t\t\t\tforwardRenderer.setCamera(shadowCam, shadowCam.renderTarget, true);\n\t\t\t\tthis.submitCasters(lightRenderData.visibleCasters, light);\n\t\t\t}\n\n\t\t\tif (light._isVsm && light._vsmBlurSize > 1) {\n\t\t\t\tconst _isClustered = this.forwardRenderer.scene.clusteredLightingEnabled;\n\n\t\t\t\tif (!_isClustered || type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tthis.applyVsmBlur(light, camera);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.restoreRenderState(device);\n\t\t}\n\t}\n\n\tgetVsmBlurShader(isVsm8, blurMode, filterSize) {\n\t\tlet blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];\n\n\t\tif (!blurShader) {\n\t\t\tthis.blurVsmWeights[filterSize] = gaussWeights(filterSize);\n\t\t\tconst blurVS = shaderChunks.fullscreenQuadVS;\n\t\t\tlet blurFS = \"#define SAMPLES \" + filterSize + \"\\n\";\n\n\t\t\tif (isVsm8) {\n\t\t\t\tblurFS += this.blurPackedVsmShaderCode[blurMode];\n\t\t\t} else {\n\t\t\t\tblurFS += this.blurVsmShaderCode[blurMode];\n\t\t\t}\n\n\t\t\tconst blurShaderName = \"blurVsm\" + blurMode + \"\" + filterSize + \"\" + isVsm8;\n\t\t\tblurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);\n\n\t\t\tif (isVsm8) {\n\t\t\t\tthis.blurPackedVsmShader[blurMode][filterSize] = blurShader;\n\t\t\t} else {\n\t\t\t\tthis.blurVsmShader[blurMode][filterSize] = blurShader;\n\t\t\t}\n\t\t}\n\n\t\treturn blurShader;\n\t}\n\n\tapplyVsmBlur(light, camera) {\n\t\tconst device = this.device;\n\t\tconst lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);\n\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\tconst origShadowMap = shadowCam.renderTarget;\n\t\tconst tempShadowMap = this.shadowMapCache.get(device, light);\n\t\tconst tempRt = tempShadowMap.renderTargets[0];\n\t\tconst isVsm8 = light._shadowType === SHADOW_VSM8;\n\t\tconst blurMode = light.vsmBlurMode;\n\t\tconst filterSize = light._vsmBlurSize;\n\t\tconst blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);\n\t\tblurScissorRect.z = light._shadowResolution - 2;\n\t\tblurScissorRect.w = blurScissorRect.z;\n\t\tthis.sourceId.setValue(origShadowMap.colorBuffer);\n\t\tpixelOffset[0] = 1 / light._shadowResolution;\n\t\tpixelOffset[1] = 0;\n\t\tthis.pixelOffsetId.setValue(pixelOffset);\n\t\tif (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);\n\t\tdrawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);\n\t\tthis.sourceId.setValue(tempRt.colorBuffer);\n\t\tpixelOffset[1] = pixelOffset[0];\n\t\tpixelOffset[0] = 0;\n\t\tthis.pixelOffsetId.setValue(pixelOffset);\n\t\tdrawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);\n\t\tthis.shadowMapCache.add(light, tempShadowMap);\n\t}\n\n}\n\nconst tempSphere$2 = new BoundingSphere();\n\nclass StaticMeshes {\n\tstatic lightCompare(lightA, lightB) {\n\t\treturn lightA.key - lightB.key;\n\t}\n\n\tstatic prepare(device, scene, meshInstances, lights) {\n\t\tconst drawCalls = meshInstances;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tconst newDrawCalls = [];\n\t\tconst minVec = new Vec3();\n\t\tconst maxVec = new Vec3();\n\t\tconst localLightBounds = new BoundingBox();\n\t\tconst invMatrix = new Mat4();\n\t\tconst triLightComb = [];\n\t\tconst lightAabb = [];\n\t\tconst triBounds = [];\n\t\tconst staticLights = [];\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\n\t\t\tif (!drawCall.isStatic) {\n\t\t\t\tnewDrawCalls.push(drawCall);\n\t\t\t} else {\n\t\t\t\tconst aabb = drawCall.aabb;\n\t\t\t\tstaticLights.length = 0;\n\n\t\t\t\tfor (let lightTypePass = LIGHTTYPE_OMNI; lightTypePass <= LIGHTTYPE_SPOT; lightTypePass++) {\n\t\t\t\t\tfor (let j = 0; j < lights.length; j++) {\n\t\t\t\t\t\tconst light = lights[j];\n\t\t\t\t\t\tif (light._type !== lightTypePass) continue;\n\n\t\t\t\t\t\tif (light.enabled) {\n\t\t\t\t\t\t\tif (light.mask & drawCall.mask) {\n\t\t\t\t\t\t\t\tif (light.isStatic) {\n\t\t\t\t\t\t\t\t\tif (!lightAabb[j]) {\n\t\t\t\t\t\t\t\t\t\tlightAabb[j] = new BoundingBox();\n\n\t\t\t\t\t\t\t\t\t\tlight._node.getWorldTransform();\n\n\t\t\t\t\t\t\t\t\t\tlight.getBoundingSphere(tempSphere$2);\n\t\t\t\t\t\t\t\t\t\tlightAabb[j].center.copy(tempSphere$2.center);\n\t\t\t\t\t\t\t\t\t\tlightAabb[j].halfExtents.set(tempSphere$2.radius, tempSphere$2.radius, tempSphere$2.radius);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (!lightAabb[j].intersects(aabb)) continue;\n\t\t\t\t\t\t\t\t\tstaticLights.push(j);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (staticLights.length === 0) {\n\t\t\t\t\tnewDrawCalls.push(drawCall);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst mesh = drawCall.mesh;\n\t\t\t\tconst vertexBuffer = mesh.vertexBuffer;\n\t\t\t\tconst indexBuffer = mesh.indexBuffer[drawCall.renderStyle];\n\t\t\t\tconst indices = indexBuffer.bytesPerIndex === 2 ? new Uint16Array(indexBuffer.lock()) : new Uint32Array(indexBuffer.lock());\n\t\t\t\tconst numTris = mesh.primitive[drawCall.renderStyle].count / 3;\n\t\t\t\tconst baseIndex = mesh.primitive[drawCall.renderStyle].base;\n\t\t\t\tconst elems = vertexBuffer.format.elements;\n\t\t\t\tconst vertSize = vertexBuffer.format.size / 4;\n\t\t\t\tconst verts = new Float32Array(vertexBuffer.storage);\n\t\t\t\tlet offsetP;\n\n\t\t\t\tfor (let k = 0; k < elems.length; k++) {\n\t\t\t\t\tif (elems[k].name === SEMANTIC_POSITION) {\n\t\t\t\t\t\toffsetP = elems[k].offset / 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttriLightComb.length = numTris;\n\n\t\t\t\tfor (let k = 0; k < numTris; k++) {\n\t\t\t\t\ttriLightComb[k] = 0;\n\t\t\t\t}\n\n\t\t\t\tlet triLightCombUsed = false;\n\t\t\t\ttriBounds.length = numTris * 6;\n\n\t\t\t\tfor (let k = 0; k < numTris; k++) {\n\t\t\t\t\tlet minx = Number.MAX_VALUE;\n\t\t\t\t\tlet miny = Number.MAX_VALUE;\n\t\t\t\t\tlet minz = Number.MAX_VALUE;\n\t\t\t\t\tlet maxx = -Number.MAX_VALUE;\n\t\t\t\t\tlet maxy = -Number.MAX_VALUE;\n\t\t\t\t\tlet maxz = -Number.MAX_VALUE;\n\n\t\t\t\t\tfor (let v = 0; v < 3; v++) {\n\t\t\t\t\t\tlet _index = indices[k * 3 + v + baseIndex];\n\t\t\t\t\t\t_index = _index * vertSize + offsetP;\n\t\t\t\t\t\tconst _x = verts[_index];\n\t\t\t\t\t\tconst _y = verts[_index + 1];\n\t\t\t\t\t\tconst _z = verts[_index + 2];\n\t\t\t\t\t\tif (_x < minx) minx = _x;\n\t\t\t\t\t\tif (_y < miny) miny = _y;\n\t\t\t\t\t\tif (_z < minz) minz = _z;\n\t\t\t\t\t\tif (_x > maxx) maxx = _x;\n\t\t\t\t\t\tif (_y > maxy) maxy = _y;\n\t\t\t\t\t\tif (_z > maxz) maxz = _z;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst index = k * 6;\n\t\t\t\t\ttriBounds[index] = minx;\n\t\t\t\t\ttriBounds[index + 1] = miny;\n\t\t\t\t\ttriBounds[index + 2] = minz;\n\t\t\t\t\ttriBounds[index + 3] = maxx;\n\t\t\t\t\ttriBounds[index + 4] = maxy;\n\t\t\t\t\ttriBounds[index + 5] = maxz;\n\t\t\t\t}\n\n\t\t\t\tfor (let s = 0; s < staticLights.length; s++) {\n\t\t\t\t\tconst j = staticLights[s];\n\t\t\t\t\tinvMatrix.copy(drawCall.node.worldTransform).invert();\n\t\t\t\t\tlocalLightBounds.setFromTransformedAabb(lightAabb[j], invMatrix);\n\t\t\t\t\tconst minv = localLightBounds.getMin();\n\t\t\t\t\tconst maxv = localLightBounds.getMax();\n\t\t\t\t\tconst bit = 1 << s;\n\n\t\t\t\t\tfor (let k = 0; k < numTris; k++) {\n\t\t\t\t\t\tconst index = k * 6;\n\n\t\t\t\t\t\tif (triBounds[index] <= maxv.x && triBounds[index + 3] >= minv.x && triBounds[index + 1] <= maxv.y && triBounds[index + 4] >= minv.y && triBounds[index + 2] <= maxv.z && triBounds[index + 5] >= minv.z) {\n\t\t\t\t\t\t\ttriLightComb[k] |= bit;\n\t\t\t\t\t\t\ttriLightCombUsed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (triLightCombUsed) {\n\t\t\t\t\tconst combIndices = {};\n\n\t\t\t\t\tfor (let k = 0; k < numTris; k++) {\n\t\t\t\t\t\tconst j = k * 3 + baseIndex;\n\t\t\t\t\t\tconst combIbName = triLightComb[k];\n\t\t\t\t\t\tif (!combIndices[combIbName]) combIndices[combIbName] = [];\n\t\t\t\t\t\tconst combIb = combIndices[combIbName];\n\t\t\t\t\t\tcombIb.push(indices[j]);\n\t\t\t\t\t\tcombIb.push(indices[j + 1]);\n\t\t\t\t\t\tcombIb.push(indices[j + 2]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const combIbName in combIndices) {\n\t\t\t\t\t\tconst combIb = combIndices[combIbName];\n\t\t\t\t\t\tconst ib = new IndexBuffer(device, indexBuffer.format, combIb.length, indexBuffer.usage);\n\t\t\t\t\t\tconst ib2 = ib.bytesPerIndex === 2 ? new Uint16Array(ib.lock()) : new Uint32Array(ib.lock());\n\t\t\t\t\t\tib2.set(combIb);\n\t\t\t\t\t\tib.unlock();\n\t\t\t\t\t\tlet minx = Number.MAX_VALUE;\n\t\t\t\t\t\tlet miny = Number.MAX_VALUE;\n\t\t\t\t\t\tlet minz = Number.MAX_VALUE;\n\t\t\t\t\t\tlet maxx = -Number.MAX_VALUE;\n\t\t\t\t\t\tlet maxy = -Number.MAX_VALUE;\n\t\t\t\t\t\tlet maxz = -Number.MAX_VALUE;\n\n\t\t\t\t\t\tfor (let k = 0; k < combIb.length; k++) {\n\t\t\t\t\t\t\tconst index = combIb[k];\n\t\t\t\t\t\t\tconst _x = verts[index * vertSize + offsetP];\n\t\t\t\t\t\t\tconst _y = verts[index * vertSize + offsetP + 1];\n\t\t\t\t\t\t\tconst _z = verts[index * vertSize + offsetP + 2];\n\t\t\t\t\t\t\tif (_x < minx) minx = _x;\n\t\t\t\t\t\t\tif (_y < miny) miny = _y;\n\t\t\t\t\t\t\tif (_z < minz) minz = _z;\n\t\t\t\t\t\t\tif (_x > maxx) maxx = _x;\n\t\t\t\t\t\t\tif (_y > maxy) maxy = _y;\n\t\t\t\t\t\t\tif (_z > maxz) maxz = _z;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tminVec.set(minx, miny, minz);\n\t\t\t\t\t\tmaxVec.set(maxx, maxy, maxz);\n\t\t\t\t\t\tconst chunkAabb = new BoundingBox();\n\t\t\t\t\t\tchunkAabb.setMinMax(minVec, maxVec);\n\t\t\t\t\t\tconst mesh2 = new Mesh(device);\n\t\t\t\t\t\tmesh2.vertexBuffer = vertexBuffer;\n\t\t\t\t\t\tmesh2.indexBuffer[0] = ib;\n\t\t\t\t\t\tmesh2.primitive[0].type = PRIMITIVE_TRIANGLES;\n\t\t\t\t\t\tmesh2.primitive[0].base = 0;\n\t\t\t\t\t\tmesh2.primitive[0].count = combIb.length;\n\t\t\t\t\t\tmesh2.primitive[0].indexed = true;\n\t\t\t\t\t\tmesh2.aabb = chunkAabb;\n\t\t\t\t\t\tconst instance = new MeshInstance(mesh2, drawCall.material, drawCall.node);\n\t\t\t\t\t\tinstance.isStatic = drawCall.isStatic;\n\t\t\t\t\t\tinstance.visible = drawCall.visible;\n\t\t\t\t\t\tinstance.layer = drawCall.layer;\n\t\t\t\t\t\tinstance.castShadow = drawCall.castShadow;\n\t\t\t\t\t\tinstance._receiveShadow = drawCall._receiveShadow;\n\t\t\t\t\t\tinstance.cull = drawCall.cull;\n\t\t\t\t\t\tinstance.pick = drawCall.pick;\n\t\t\t\t\t\tinstance.mask = drawCall.mask;\n\t\t\t\t\t\tinstance.parameters = drawCall.parameters;\n\t\t\t\t\t\tinstance._shaderDefs = drawCall._shaderDefs;\n\t\t\t\t\t\tinstance._staticSource = drawCall;\n\n\t\t\t\t\t\tif (drawCall._staticLightList) {\n\t\t\t\t\t\t\tinstance._staticLightList = drawCall._staticLightList;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinstance._staticLightList = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let k = 0; k < staticLights.length; k++) {\n\t\t\t\t\t\t\tconst bit = 1 << k;\n\n\t\t\t\t\t\t\tif (combIbName & bit) {\n\t\t\t\t\t\t\t\tconst lht = lights[staticLights[k]];\n\n\t\t\t\t\t\t\t\tif (instance._staticLightList.indexOf(lht) < 0) {\n\t\t\t\t\t\t\t\t\tinstance._staticLightList.push(lht);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinstance._staticLightList.sort(StaticMeshes.lightCompare);\n\n\t\t\t\t\t\tnewDrawCalls.push(instance);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewDrawCalls.push(drawCall);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmeshInstances.length = newDrawCalls.length;\n\n\t\tfor (let i = 0; i < newDrawCalls.length; i++) {\n\t\t\tmeshInstances[i] = newDrawCalls[i];\n\t\t}\n\t}\n\n\tstatic revert(meshInstances) {\n\t\tconst drawCalls = meshInstances;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tconst newDrawCalls = [];\n\t\tlet prevStaticSource;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\n\t\t\tif (drawCall._staticSource) {\n\t\t\t\tif (drawCall._staticSource !== prevStaticSource) {\n\t\t\t\t\tnewDrawCalls.push(drawCall._staticSource);\n\t\t\t\t\tprevStaticSource = drawCall._staticSource;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewDrawCalls.push(drawCall);\n\t\t\t}\n\t\t}\n\n\t\tmeshInstances.length = newDrawCalls.length;\n\n\t\tfor (let i = 0; i < newDrawCalls.length; i++) {\n\t\t\tmeshInstances[i] = newDrawCalls[i];\n\t\t}\n\t}\n\n}\n\nnew Vec3(1, 1, 1);\nnew Vec3(40, 0, 0);\n\nconst viewInvMat = new Mat4();\nconst viewMat = new Mat4();\nconst viewMat3 = new Mat3();\nconst viewProjMat = new Mat4();\nlet projMat;\nconst flipYMat = new Mat4().setScale(1, -1, 1);\nconst flippedViewProjMat = new Mat4();\nconst flippedSkyboxProjMat = new Mat4();\nconst viewInvL = new Mat4();\nconst viewInvR = new Mat4();\nconst viewL = new Mat4();\nconst viewR = new Mat4();\nconst viewPosL = new Vec3();\nconst viewPosR = new Vec3();\nlet projL, projR;\nconst viewMat3L = new Mat3();\nconst viewMat3R = new Mat3();\nconst viewProjMatL = new Mat4();\nconst viewProjMatR = new Mat4();\nconst worldMatX = new Vec3();\nconst worldMatY = new Vec3();\nconst worldMatZ = new Vec3();\nconst tempSphere$1 = new BoundingSphere();\nconst boneTextureSize = [0, 0, 0, 0];\nlet boneTexture, instancingData, modelMatrix, normalMatrix;\nlet keyA$1, keyB$1;\nlet _autoInstanceBuffer = null;\nlet _skinUpdateIndex = 0;\nconst _drawCallList = {\n\tdrawCalls: [],\n\tisNewMaterial: [],\n\tlightMaskChanged: []\n};\n\nconst _tempMaterialSet = new Set();\n\nclass ForwardRenderer {\n\tconstructor(graphicsDevice) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.scene = null;\n\t\tthis._shadowDrawCalls = 0;\n\t\tthis._forwardDrawCalls = 0;\n\t\tthis._skinDrawCalls = 0;\n\t\tthis._numDrawCallsCulled = 0;\n\t\tthis._instancedDrawCalls = 0;\n\t\tthis._camerasRendered = 0;\n\t\tthis._materialSwitches = 0;\n\t\tthis._shadowMapUpdates = 0;\n\t\tthis._shadowMapTime = 0;\n\t\tthis._depthMapTime = 0;\n\t\tthis._forwardTime = 0;\n\t\tthis._cullTime = 0;\n\t\tthis._sortTime = 0;\n\t\tthis._skinTime = 0;\n\t\tthis._morphTime = 0;\n\t\tthis._instancingTime = 0;\n\t\tthis._removedByInstancing = 0;\n\t\tthis._layerCompositionUpdateTime = 0;\n\t\tthis._lightClustersTime = 0;\n\t\tthis._lightClusters = 0;\n\t\tconst device = this.device;\n\t\tconst library = device.getProgramLibrary();\n\t\tthis.library = library;\n\t\tthis.lightTextureAtlas = new LightTextureAtlas(device);\n\t\tthis._shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);\n\t\tthis._cookieRenderer = new CookieRenderer(device, this.lightTextureAtlas);\n\t\tconst scope = device.scope;\n\t\tthis.projId = scope.resolve('matrix_projection');\n\t\tthis.projSkyboxId = scope.resolve('matrix_projectionSkybox');\n\t\tthis.viewId = scope.resolve('matrix_view');\n\t\tthis.viewId3 = scope.resolve('matrix_view3');\n\t\tthis.viewInvId = scope.resolve('matrix_viewInverse');\n\t\tthis.viewProjId = scope.resolve('matrix_viewProjection');\n\t\tthis.viewPos = new Float32Array(3);\n\t\tthis.viewPosId = scope.resolve('view_position');\n\t\tthis.nearClipId = scope.resolve('camera_near');\n\t\tthis.farClipId = scope.resolve('camera_far');\n\t\tthis.cameraParamsId = scope.resolve('camera_params');\n\t\tthis.tbnBasis = scope.resolve('tbnBasis');\n\t\tthis.fogColorId = scope.resolve('fog_color');\n\t\tthis.fogStartId = scope.resolve('fog_start');\n\t\tthis.fogEndId = scope.resolve('fog_end');\n\t\tthis.fogDensityId = scope.resolve('fog_density');\n\t\tthis.modelMatrixId = scope.resolve('matrix_model');\n\t\tthis.normalMatrixId = scope.resolve('matrix_normal');\n\t\tthis.poseMatrixId = scope.resolve('matrix_pose[0]');\n\t\tthis.boneTextureId = scope.resolve('texture_poseMap');\n\t\tthis.boneTextureSizeId = scope.resolve('texture_poseMapSize');\n\t\tthis.morphWeightsA = scope.resolve('morph_weights_a');\n\t\tthis.morphWeightsB = scope.resolve('morph_weights_b');\n\t\tthis.morphPositionTex = scope.resolve('morphPositionTex');\n\t\tthis.morphNormalTex = scope.resolve('morphNormalTex');\n\t\tthis.morphTexParams = scope.resolve('morph_tex_params');\n\t\tthis.alphaTestId = scope.resolve('alpha_ref');\n\t\tthis.opacityMapId = scope.resolve('texture_opacityMap');\n\t\tthis.ambientId = scope.resolve(\"light_globalAmbient\");\n\t\tthis.exposureId = scope.resolve(\"exposure\");\n\t\tthis.skyboxIntensityId = scope.resolve(\"skyboxIntensity\");\n\t\tthis.lightColorId = [];\n\t\tthis.lightDir = [];\n\t\tthis.lightDirId = [];\n\t\tthis.lightShadowMapId = [];\n\t\tthis.lightShadowMatrixId = [];\n\t\tthis.lightShadowParamsId = [];\n\t\tthis.lightRadiusId = [];\n\t\tthis.lightPos = [];\n\t\tthis.lightPosId = [];\n\t\tthis.lightWidth = [];\n\t\tthis.lightWidthId = [];\n\t\tthis.lightHeight = [];\n\t\tthis.lightHeightId = [];\n\t\tthis.lightInAngleId = [];\n\t\tthis.lightOutAngleId = [];\n\t\tthis.lightCookieId = [];\n\t\tthis.lightCookieIntId = [];\n\t\tthis.lightCookieMatrixId = [];\n\t\tthis.lightCookieOffsetId = [];\n\t\tthis.shadowMatrixPaletteId = [];\n\t\tthis.shadowCascadeDistancesId = [];\n\t\tthis.shadowCascadeCountId = [];\n\t\tthis.depthMapId = scope.resolve('uDepthMap');\n\t\tthis.screenSizeId = scope.resolve('uScreenSize');\n\t\tthis._screenSize = new Float32Array(4);\n\t\tthis.twoSidedLightingNegScaleFactorId = scope.resolve(\"twoSidedLightingNegScaleFactor\");\n\t\tthis.fogColor = new Float32Array(3);\n\t\tthis.ambientColor = new Float32Array(3);\n\t\tthis.cameraParams = new Float32Array(4);\n\t}\n\n\tdestroy() {\n\t\tthis._shadowRenderer.destroy();\n\n\t\tthis._shadowRenderer = null;\n\n\t\tthis._cookieRenderer.destroy();\n\n\t\tthis._cookieRenderer = null;\n\t\tthis.lightTextureAtlas.destroy();\n\t\tthis.lightTextureAtlas = null;\n\t}\n\n\tsortCompare(drawCallA, drawCallB) {\n\t\tif (drawCallA.layer === drawCallB.layer) {\n\t\t\tif (drawCallA.drawOrder && drawCallB.drawOrder) {\n\t\t\t\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n\t\t\t} else if (drawCallA.zdist && drawCallB.zdist) {\n\t\t\t\treturn drawCallB.zdist - drawCallA.zdist;\n\t\t\t} else if (drawCallA.zdist2 && drawCallB.zdist2) {\n\t\t\t\treturn drawCallA.zdist2 - drawCallB.zdist2;\n\t\t\t}\n\t\t}\n\n\t\treturn drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];\n\t}\n\n\tsortCompareMesh(drawCallA, drawCallB) {\n\t\tif (drawCallA.layer === drawCallB.layer) {\n\t\t\tif (drawCallA.drawOrder && drawCallB.drawOrder) {\n\t\t\t\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n\t\t\t} else if (drawCallA.zdist && drawCallB.zdist) {\n\t\t\t\treturn drawCallB.zdist - drawCallA.zdist;\n\t\t\t}\n\t\t}\n\n\t\tkeyA$1 = drawCallA._key[SORTKEY_FORWARD];\n\t\tkeyB$1 = drawCallB._key[SORTKEY_FORWARD];\n\n\t\tif (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {\n\t\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t\t}\n\n\t\treturn keyB$1 - keyA$1;\n\t}\n\n\tdepthSortCompare(drawCallA, drawCallB) {\n\t\tkeyA$1 = drawCallA._key[SORTKEY_DEPTH];\n\t\tkeyB$1 = drawCallB._key[SORTKEY_DEPTH];\n\n\t\tif (keyA$1 === keyB$1 && drawCallA.mesh && drawCallB.mesh) {\n\t\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t\t}\n\n\t\treturn keyB$1 - keyA$1;\n\t}\n\n\tupdateCameraFrustum(camera) {\n\t\tif (camera.vrDisplay && camera.vrDisplay.presenting) {\n\t\t\tprojMat = camera.vrDisplay.combinedProj;\n\t\t\tconst parent = camera._node.parent;\n\n\t\t\tif (parent) {\n\t\t\t\tviewMat.copy(parent.getWorldTransform()).mul(camera.vrDisplay.combinedViewInv).invert();\n\t\t\t} else {\n\t\t\t\tviewMat.copy(camera.vrDisplay.combinedView);\n\t\t\t}\n\n\t\t\tviewInvMat.copy(viewMat).invert();\n\t\t\tthis.viewInvId.setValue(viewInvMat.data);\n\t\t\tviewProjMat.mul2(projMat, viewMat);\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t} else if (camera.xr && camera.xr.views.length) {\n\t\t\tconst view = camera.xr.views[0];\n\t\t\tviewProjMat.mul2(view.projMat, view.viewOffMat);\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t\treturn;\n\t\t}\n\n\t\tprojMat = camera.projectionMatrix;\n\n\t\tif (camera.calculateProjection) {\n\t\t\tcamera.calculateProjection(projMat, VIEW_CENTER);\n\t\t}\n\n\t\tif (camera.calculateTransform) {\n\t\t\tcamera.calculateTransform(viewInvMat, VIEW_CENTER);\n\t\t} else {\n\t\t\tconst pos = camera._node.getPosition();\n\n\t\t\tconst rot = camera._node.getRotation();\n\n\t\t\tviewInvMat.setTRS(pos, rot, Vec3.ONE);\n\t\t\tthis.viewInvId.setValue(viewInvMat.data);\n\t\t}\n\n\t\tviewMat.copy(viewInvMat).invert();\n\t\tviewProjMat.mul2(projMat, viewMat);\n\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t}\n\n\tsetCamera(camera, target, clear) {\n\t\tconst vrDisplay = camera.vrDisplay;\n\t\tlet transform;\n\n\t\tif (vrDisplay && vrDisplay.presenting) {\n\t\t\tprojL = vrDisplay.leftProj;\n\t\t\tprojR = vrDisplay.rightProj;\n\t\t\tprojMat = vrDisplay.combinedProj;\n\n\t\t\tif (camera.calculateProjection) {\n\t\t\t\tcamera.calculateProjection(projL, VIEW_LEFT);\n\t\t\t\tcamera.calculateProjection(projR, VIEW_RIGHT);\n\t\t\t\tcamera.calculateProjection(projMat, VIEW_CENTER);\n\t\t\t}\n\n\t\t\tif (camera.calculateTransform) {\n\t\t\t\tcamera.calculateTransform(viewInvL, VIEW_LEFT);\n\t\t\t\tcamera.calculateTransform(viewInvR, VIEW_RIGHT);\n\t\t\t\tcamera.calculateTransform(viewInvMat, VIEW_CENTER);\n\t\t\t\tviewL.copy(viewInvL).invert();\n\t\t\t\tviewR.copy(viewInvR).invert();\n\t\t\t\tviewMat.copy(viewInvMat).invert();\n\t\t\t} else {\n\t\t\t\tconst parent = camera._node.parent;\n\n\t\t\t\tif (parent) {\n\t\t\t\t\ttransform = parent.getWorldTransform();\n\t\t\t\t\tviewInvL.mul2(transform, vrDisplay.leftViewInv);\n\t\t\t\t\tviewInvR.mul2(transform, vrDisplay.rightViewInv);\n\t\t\t\t\tviewL.copy(viewInvL).invert();\n\t\t\t\t\tviewR.copy(viewInvR).invert();\n\t\t\t\t\tviewMat.copy(parent.getWorldTransform()).mul(vrDisplay.combinedViewInv).invert();\n\t\t\t\t} else {\n\t\t\t\t\tviewInvL.copy(vrDisplay.leftViewInv);\n\t\t\t\t\tviewInvR.copy(vrDisplay.rightViewInv);\n\t\t\t\t\tviewL.copy(vrDisplay.leftView);\n\t\t\t\t\tviewR.copy(vrDisplay.rightView);\n\t\t\t\t\tviewMat.copy(vrDisplay.combinedView);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tviewMat3L.setFromMat4(viewL);\n\t\t\tviewMat3R.setFromMat4(viewR);\n\t\t\tviewProjMatL.mul2(projL, viewL);\n\t\t\tviewProjMatR.mul2(projR, viewR);\n\t\t\tviewPosL.x = viewInvL.data[12];\n\t\t\tviewPosL.y = viewInvL.data[13];\n\t\t\tviewPosL.z = viewInvL.data[14];\n\t\t\tviewPosR.x = viewInvR.data[12];\n\t\t\tviewPosR.y = viewInvR.data[13];\n\t\t\tviewPosR.z = viewInvR.data[14];\n\t\t\tviewProjMat.mul2(projMat, viewMat);\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t} else if (camera.xr && camera.xr.session) {\n\t\t\tconst parent = camera._node.parent;\n\t\t\tif (parent) transform = parent.getWorldTransform();\n\t\t\tconst views = camera.xr.views;\n\n\t\t\tfor (let v = 0; v < views.length; v++) {\n\t\t\t\tconst view = views[v];\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tview.viewInvOffMat.mul2(transform, view.viewInvMat);\n\t\t\t\t\tview.viewOffMat.copy(view.viewInvOffMat).invert();\n\t\t\t\t} else {\n\t\t\t\t\tview.viewInvOffMat.copy(view.viewInvMat);\n\t\t\t\t\tview.viewOffMat.copy(view.viewMat);\n\t\t\t\t}\n\n\t\t\t\tview.viewMat3.setFromMat4(view.viewOffMat);\n\t\t\t\tview.projViewOffMat.mul2(view.projMat, view.viewOffMat);\n\t\t\t\tview.position[0] = view.viewInvOffMat.data[12];\n\t\t\t\tview.position[1] = view.viewInvOffMat.data[13];\n\t\t\t\tview.position[2] = view.viewInvOffMat.data[14];\n\t\t\t\tcamera.frustum.setFromMat4(view.projViewOffMat);\n\t\t\t}\n\t\t} else {\n\t\t\tprojMat = camera.projectionMatrix;\n\n\t\t\tif (camera.calculateProjection) {\n\t\t\t\tcamera.calculateProjection(projMat, VIEW_CENTER);\n\t\t\t}\n\n\t\t\tthis.projId.setValue(projMat.data);\n\t\t\tthis.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);\n\n\t\t\tif (camera.calculateTransform) {\n\t\t\t\tcamera.calculateTransform(viewInvMat, VIEW_CENTER);\n\t\t\t} else {\n\t\t\t\tconst pos = camera._node.getPosition();\n\n\t\t\t\tconst rot = camera._node.getRotation();\n\n\t\t\t\tviewInvMat.setTRS(pos, rot, Vec3.ONE);\n\t\t\t}\n\n\t\t\tthis.viewInvId.setValue(viewInvMat.data);\n\t\t\tviewMat.copy(viewInvMat).invert();\n\t\t\tthis.viewId.setValue(viewMat.data);\n\t\t\tviewMat3.setFromMat4(viewMat);\n\t\t\tthis.viewId3.setValue(viewMat3.data);\n\t\t\tviewProjMat.mul2(projMat, viewMat);\n\n\t\t\tif (target && target.flipY) {\n\t\t\t\tflippedViewProjMat.mul2(flipYMat, viewProjMat);\n\t\t\t\tflippedSkyboxProjMat.mul2(flipYMat, camera.getProjectionMatrixSkybox());\n\t\t\t\tthis.viewProjId.setValue(flippedViewProjMat.data);\n\t\t\t\tthis.projSkyboxId.setValue(flippedSkyboxProjMat.data);\n\t\t\t} else {\n\t\t\t\tthis.viewProjId.setValue(viewProjMat.data);\n\t\t\t\tthis.projSkyboxId.setValue(camera.getProjectionMatrixSkybox().data);\n\t\t\t}\n\n\t\t\tthis.dispatchViewPos(camera._node.getPosition());\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t}\n\n\t\tthis.tbnBasis.setValue(target && target.flipY ? -1 : 1);\n\t\tthis.nearClipId.setValue(camera._nearClip);\n\t\tthis.farClipId.setValue(camera._farClip);\n\t\tconst n = camera._nearClip;\n\t\tconst f = camera._farClip;\n\t\tthis.cameraParams[0] = 1 / f;\n\t\tthis.cameraParams[1] = f;\n\t\tthis.cameraParams[2] = (1 - f / n) * 0.5;\n\t\tthis.cameraParams[3] = (1 + f / n) * 0.5;\n\t\tthis.cameraParamsId.setValue(this.cameraParams);\n\t\tthis.clearView(camera, target, clear, false);\n\t}\n\n\tclearView(camera, target, clear, forceWrite, options) {\n\t\tconst device = this.device;\n\t\tdevice.setRenderTarget(target);\n\t\tdevice.updateBegin();\n\n\t\tif (forceWrite) {\n\t\t\tdevice.setColorWrite(true, true, true, true);\n\t\t\tdevice.setDepthWrite(true);\n\t\t}\n\n\t\tconst pixelWidth = target ? target.width : device.width;\n\t\tconst pixelHeight = target ? target.height : device.height;\n\t\tconst rect = camera.rect;\n\t\tlet x = Math.floor(rect.x * pixelWidth);\n\t\tlet y = Math.floor(rect.y * pixelHeight);\n\t\tlet w = Math.floor(rect.z * pixelWidth);\n\t\tlet h = Math.floor(rect.w * pixelHeight);\n\t\tdevice.setViewport(x, y, w, h);\n\n\t\tif (camera._scissorRectClear) {\n\t\t\tconst scissorRect = camera.scissorRect;\n\t\t\tx = Math.floor(scissorRect.x * pixelWidth);\n\t\t\ty = Math.floor(scissorRect.y * pixelHeight);\n\t\t\tw = Math.floor(scissorRect.z * pixelWidth);\n\t\t\th = Math.floor(scissorRect.w * pixelHeight);\n\t\t}\n\n\t\tdevice.setScissor(x, y, w, h);\n\n\t\tif (clear) {\n\t\t\tif (!options) options = camera._clearOptions;\n\t\t\tdevice.clear(options ? options : {\n\t\t\t\tcolor: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],\n\t\t\t\tdepth: camera._clearDepth,\n\t\t\t\tflags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),\n\t\t\t\tstencil: camera._clearStencil\n\t\t\t});\n\t\t}\n\t}\n\n\tdispatchGlobalLights(scene) {\n\t\tthis.ambientColor[0] = scene.ambientLight.r;\n\t\tthis.ambientColor[1] = scene.ambientLight.g;\n\t\tthis.ambientColor[2] = scene.ambientLight.b;\n\n\t\tif (scene.gammaCorrection) {\n\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\tthis.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);\n\t\t\t}\n\t\t}\n\n\t\tthis.ambientId.setValue(this.ambientColor);\n\t\tthis.exposureId.setValue(scene.exposure);\n\t\tif (scene.skyboxModel) this.skyboxIntensityId.setValue(scene.skyboxIntensity);\n\t}\n\n\t_resolveLight(scope, i) {\n\t\tconst light = \"light\" + i;\n\t\tthis.lightColorId[i] = scope.resolve(light + \"_color\");\n\t\tthis.lightDir[i] = new Float32Array(3);\n\t\tthis.lightDirId[i] = scope.resolve(light + \"_direction\");\n\t\tthis.lightShadowMapId[i] = scope.resolve(light + \"_shadowMap\");\n\t\tthis.lightShadowMatrixId[i] = scope.resolve(light + \"_shadowMatrix\");\n\t\tthis.lightShadowParamsId[i] = scope.resolve(light + \"_shadowParams\");\n\t\tthis.lightRadiusId[i] = scope.resolve(light + \"_radius\");\n\t\tthis.lightPos[i] = new Float32Array(3);\n\t\tthis.lightPosId[i] = scope.resolve(light + \"_position\");\n\t\tthis.lightWidth[i] = new Float32Array(3);\n\t\tthis.lightWidthId[i] = scope.resolve(light + \"_halfWidth\");\n\t\tthis.lightHeight[i] = new Float32Array(3);\n\t\tthis.lightHeightId[i] = scope.resolve(light + \"_halfHeight\");\n\t\tthis.lightInAngleId[i] = scope.resolve(light + \"_innerConeAngle\");\n\t\tthis.lightOutAngleId[i] = scope.resolve(light + \"_outerConeAngle\");\n\t\tthis.lightCookieId[i] = scope.resolve(light + \"_cookie\");\n\t\tthis.lightCookieIntId[i] = scope.resolve(light + \"_cookieIntensity\");\n\t\tthis.lightCookieMatrixId[i] = scope.resolve(light + \"_cookieMatrix\");\n\t\tthis.lightCookieOffsetId[i] = scope.resolve(light + \"_cookieOffset\");\n\t\tthis.shadowMatrixPaletteId[i] = scope.resolve(light + \"_shadowMatrixPalette[0]\");\n\t\tthis.shadowCascadeDistancesId[i] = scope.resolve(light + \"_shadowCascadeDistances[0]\");\n\t\tthis.shadowCascadeCountId[i] = scope.resolve(light + \"_shadowCascadeCount\");\n\t}\n\n\tsetLTCDirectionallLight(wtm, cnt, dir, campos, far) {\n\t\tthis.lightPos[cnt][0] = campos.x - dir.x * far;\n\t\tthis.lightPos[cnt][1] = campos.y - dir.y * far;\n\t\tthis.lightPos[cnt][2] = campos.z - dir.z * far;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\t\tconst hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));\n\t\tthis.lightWidth[cnt][0] = hWidth.x * far;\n\t\tthis.lightWidth[cnt][1] = hWidth.y * far;\n\t\tthis.lightWidth[cnt][2] = hWidth.z * far;\n\t\tthis.lightWidthId[cnt].setValue(this.lightWidth[cnt]);\n\t\tconst hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));\n\t\tthis.lightHeight[cnt][0] = hHeight.x * far;\n\t\tthis.lightHeight[cnt][1] = hHeight.y * far;\n\t\tthis.lightHeight[cnt][2] = hHeight.z * far;\n\t\tthis.lightHeightId[cnt].setValue(this.lightHeight[cnt]);\n\t}\n\n\tdispatchDirectLights(dirs, scene, mask, camera) {\n\t\tlet cnt = 0;\n\t\tconst scope = this.device.scope;\n\n\t\tfor (let i = 0; i < dirs.length; i++) {\n\t\t\tif (!(dirs[i].mask & mask)) continue;\n\t\t\tconst directional = dirs[i];\n\n\t\t\tconst wtm = directional._node.getWorldTransform();\n\n\t\t\tif (!this.lightColorId[cnt]) {\n\t\t\t\tthis._resolveLight(scope, cnt);\n\t\t\t}\n\n\t\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);\n\t\t\twtm.getY(directional._direction).mulScalar(-1);\n\n\t\t\tdirectional._direction.normalize();\n\n\t\t\tthis.lightDir[cnt][0] = directional._direction.x;\n\t\t\tthis.lightDir[cnt][1] = directional._direction.y;\n\t\t\tthis.lightDir[cnt][2] = directional._direction.z;\n\t\t\tthis.lightDirId[cnt].setValue(this.lightDir[cnt]);\n\n\t\t\tif (directional.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\tthis.setLTCDirectionallLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);\n\t\t\t}\n\n\t\t\tif (directional.castShadows) {\n\t\t\t\tconst lightRenderData = directional.getRenderData(camera, 0);\n\n\t\t\t\tconst biases = directional._getUniformBiasValues(lightRenderData);\n\n\t\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\t\t\t\tthis.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);\n\t\t\t\tthis.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);\n\t\t\t\tthis.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);\n\t\t\t\tthis.shadowCascadeCountId[cnt].setValue(directional.numCascades);\n\t\t\t\tconst params = directional._shadowRenderParams;\n\t\t\t\tparams.length = 3;\n\t\t\t\tparams[0] = directional._shadowResolution;\n\t\t\t\tparams[1] = biases.normalBias;\n\t\t\t\tparams[2] = biases.bias;\n\t\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t\t}\n\n\t\t\tcnt++;\n\t\t}\n\n\t\treturn cnt;\n\t}\n\n\tsetLTCPositionalLight(wtm, cnt) {\n\t\tconst hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));\n\t\tthis.lightWidth[cnt][0] = hWidth.x;\n\t\tthis.lightWidth[cnt][1] = hWidth.y;\n\t\tthis.lightWidth[cnt][2] = hWidth.z;\n\t\tthis.lightWidthId[cnt].setValue(this.lightWidth[cnt]);\n\t\tconst hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));\n\t\tthis.lightHeight[cnt][0] = hHeight.x;\n\t\tthis.lightHeight[cnt][1] = hHeight.y;\n\t\tthis.lightHeight[cnt][2] = hHeight.z;\n\t\tthis.lightHeightId[cnt].setValue(this.lightHeight[cnt]);\n\t}\n\n\tdispatchOmniLight(scene, scope, omni, cnt) {\n\t\tconst wtm = omni._node.getWorldTransform();\n\n\t\tif (!this.lightColorId[cnt]) {\n\t\t\tthis._resolveLight(scope, cnt);\n\t\t}\n\n\t\tthis.lightRadiusId[cnt].setValue(omni.attenuationEnd);\n\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);\n\t\twtm.getTranslation(omni._position);\n\t\tthis.lightPos[cnt][0] = omni._position.x;\n\t\tthis.lightPos[cnt][1] = omni._position.y;\n\t\tthis.lightPos[cnt][2] = omni._position.z;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\n\t\tif (omni.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\tthis.setLTCPositionalLight(wtm, cnt);\n\t\t}\n\n\t\tif (omni.castShadows) {\n\t\t\tconst lightRenderData = omni.getRenderData(null, 0);\n\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\n\t\t\tconst biases = omni._getUniformBiasValues(lightRenderData);\n\n\t\t\tconst params = omni._shadowRenderParams;\n\t\t\tparams.length = 4;\n\t\t\tparams[0] = omni._shadowResolution;\n\t\t\tparams[1] = biases.normalBias;\n\t\t\tparams[2] = biases.bias;\n\t\t\tparams[3] = 1.0 / omni.attenuationEnd;\n\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t}\n\n\t\tif (omni._cookie) {\n\t\t\tthis.lightCookieId[cnt].setValue(omni._cookie);\n\t\t\tthis.lightShadowMatrixId[cnt].setValue(wtm.data);\n\t\t\tthis.lightCookieIntId[cnt].setValue(omni.cookieIntensity);\n\t\t}\n\t}\n\n\tdispatchSpotLight(scene, scope, spot, cnt) {\n\t\tconst wtm = spot._node.getWorldTransform();\n\n\t\tif (!this.lightColorId[cnt]) {\n\t\t\tthis._resolveLight(scope, cnt);\n\t\t}\n\n\t\tthis.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);\n\t\tthis.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);\n\t\tthis.lightRadiusId[cnt].setValue(spot.attenuationEnd);\n\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);\n\t\twtm.getTranslation(spot._position);\n\t\tthis.lightPos[cnt][0] = spot._position.x;\n\t\tthis.lightPos[cnt][1] = spot._position.y;\n\t\tthis.lightPos[cnt][2] = spot._position.z;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\n\t\tif (spot.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\tthis.setLTCPositionalLight(wtm, cnt);\n\t\t}\n\n\t\twtm.getY(spot._direction).mulScalar(-1);\n\n\t\tspot._direction.normalize();\n\n\t\tthis.lightDir[cnt][0] = spot._direction.x;\n\t\tthis.lightDir[cnt][1] = spot._direction.y;\n\t\tthis.lightDir[cnt][2] = spot._direction.z;\n\t\tthis.lightDirId[cnt].setValue(this.lightDir[cnt]);\n\n\t\tif (spot.castShadows) {\n\t\t\tconst lightRenderData = spot.getRenderData(null, 0);\n\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\t\t\tthis.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);\n\n\t\t\tconst biases = spot._getUniformBiasValues(lightRenderData);\n\n\t\t\tconst params = spot._shadowRenderParams;\n\t\t\tparams.length = 4;\n\t\t\tparams[0] = spot._shadowResolution;\n\t\t\tparams[1] = biases.normalBias;\n\t\t\tparams[2] = biases.bias;\n\t\t\tparams[3] = 1.0 / spot.attenuationEnd;\n\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t}\n\n\t\tif (spot._cookie) {\n\t\t\tif (!spot.castShadows) {\n\t\t\t\tconst cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);\n\t\t\t\tthis.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);\n\t\t\t}\n\n\t\t\tthis.lightCookieId[cnt].setValue(spot._cookie);\n\t\t\tthis.lightCookieIntId[cnt].setValue(spot.cookieIntensity);\n\n\t\t\tif (spot._cookieTransform) {\n\t\t\t\tspot._cookieTransformUniform[0] = spot._cookieTransform.x;\n\t\t\t\tspot._cookieTransformUniform[1] = spot._cookieTransform.y;\n\t\t\t\tspot._cookieTransformUniform[2] = spot._cookieTransform.z;\n\t\t\t\tspot._cookieTransformUniform[3] = spot._cookieTransform.w;\n\t\t\t\tthis.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);\n\t\t\t\tspot._cookieOffsetUniform[0] = spot._cookieOffset.x;\n\t\t\t\tspot._cookieOffsetUniform[1] = spot._cookieOffset.y;\n\t\t\t\tthis.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tdispatchLocalLights(sortedLights, scene, mask, usedDirLights, staticLightList) {\n\t\tlet cnt = usedDirLights;\n\t\tconst scope = this.device.scope;\n\t\tconst omnis = sortedLights[LIGHTTYPE_OMNI];\n\t\tconst numOmnis = omnis.length;\n\n\t\tfor (let i = 0; i < numOmnis; i++) {\n\t\t\tconst omni = omnis[i];\n\t\t\tif (!(omni.mask & mask)) continue;\n\t\t\tif (omni.isStatic) continue;\n\t\t\tthis.dispatchOmniLight(scene, scope, omni, cnt);\n\t\t\tcnt++;\n\t\t}\n\n\t\tlet staticId = 0;\n\n\t\tif (staticLightList) {\n\t\t\tlet omni = staticLightList[staticId];\n\n\t\t\twhile (omni && omni._type === LIGHTTYPE_OMNI) {\n\t\t\t\tthis.dispatchOmniLight(scene, scope, omni, cnt);\n\t\t\t\tcnt++;\n\t\t\t\tstaticId++;\n\t\t\t\tomni = staticLightList[staticId];\n\t\t\t}\n\t\t}\n\n\t\tconst spts = sortedLights[LIGHTTYPE_SPOT];\n\t\tconst numSpts = spts.length;\n\n\t\tfor (let i = 0; i < numSpts; i++) {\n\t\t\tconst spot = spts[i];\n\t\t\tif (!(spot.mask & mask)) continue;\n\t\t\tif (spot.isStatic) continue;\n\t\t\tthis.dispatchSpotLight(scene, scope, spot, cnt);\n\t\t\tcnt++;\n\t\t}\n\n\t\tif (staticLightList) {\n\t\t\tlet spot = staticLightList[staticId];\n\n\t\t\twhile (spot && spot._type === LIGHTTYPE_SPOT) {\n\t\t\t\tthis.dispatchSpotLight(scene, scope, spot, cnt);\n\t\t\t\tcnt++;\n\t\t\t\tstaticId++;\n\t\t\t\tspot = staticLightList[staticId];\n\t\t\t}\n\t\t}\n\t}\n\n\tcull(camera, drawCalls, visibleList) {\n\t\tlet visibleLength = 0;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tconst cullingMask = camera.cullingMask || 0xFFFFFFFF;\n\n\t\tif (!camera.frustumCulling) {\n\t\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\t\tconst drawCall = drawCalls[i];\n\t\t\t\tif (!drawCall.visible && !drawCall.command) continue;\n\t\t\t\tif (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;\n\t\t\t\tvisibleList[visibleLength] = drawCall;\n\t\t\t\tvisibleLength++;\n\t\t\t\tdrawCall.visibleThisFrame = true;\n\t\t\t}\n\n\t\t\treturn visibleLength;\n\t\t}\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\n\t\t\tif (!drawCall.command) {\n\t\t\t\tif (!drawCall.visible) continue;\n\t\t\t\tlet visible = true;\n\t\t\t\tif (drawCall.mask && (drawCall.mask & cullingMask) === 0) continue;\n\n\t\t\t\tif (drawCall.cull) {\n\t\t\t\t\tvisible = drawCall._isVisible(camera);\n\t\t\t\t}\n\n\t\t\t\tif (visible) {\n\t\t\t\t\tvisibleList[visibleLength] = drawCall;\n\t\t\t\t\tvisibleLength++;\n\t\t\t\t\tdrawCall.visibleThisFrame = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvisibleList[visibleLength] = drawCall;\n\t\t\t\tvisibleLength++;\n\t\t\t\tdrawCall.visibleThisFrame = true;\n\t\t\t}\n\t\t}\n\n\t\treturn visibleLength;\n\t}\n\n\tcullLights(camera, lights) {\n\t\tconst clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\n\t\t\tif (light.enabled) {\n\t\t\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tlight.getBoundingSphere(tempSphere$1);\n\n\t\t\t\t\tif (camera.frustum.containsSphere(tempSphere$1)) {\n\t\t\t\t\t\tlight.visibleThisFrame = true;\n\t\t\t\t\t\tconst screenSize = camera.getScreenSize(tempSphere$1);\n\t\t\t\t\t\tlight.maxScreenSize = Math.max(light.maxScreenSize, screenSize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!clusteredLightingEnabled) {\n\t\t\t\t\t\t\tif (light.castShadows && !light.shadowMap) {\n\t\t\t\t\t\t\t\tlight.visibleThisFrame = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateCpuSkinMatrices(drawCalls) {\n\t\t_skinUpdateIndex++;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tif (drawCallsCount === 0) return;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst si = drawCalls[i].skinInstance;\n\n\t\t\tif (si) {\n\t\t\t\tsi.updateMatrices(drawCalls[i].node, _skinUpdateIndex);\n\t\t\t\tsi._dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateGpuSkinMatrices(drawCalls) {\n\t\tconst drawCallsCount = drawCalls.length;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tif (!drawCalls[i].visibleThisFrame) continue;\n\t\t\tconst skin = drawCalls[i].skinInstance;\n\n\t\t\tif (skin) {\n\t\t\t\tif (skin._dirty) {\n\t\t\t\t\tskin.updateMatrixPalette(drawCalls[i].node, _skinUpdateIndex);\n\t\t\t\t\tskin._dirty = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateMorphing(drawCalls) {\n\t\tconst drawCallsCount = drawCalls.length;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst morphInst = drawCalls[i].morphInstance;\n\n\t\t\tif (morphInst && morphInst._dirty && drawCalls[i].visibleThisFrame) {\n\t\t\t\tmorphInst.update();\n\t\t\t}\n\t\t}\n\t}\n\n\tsetBaseConstants(device, material) {\n\t\tdevice.setCullMode(material.cull);\n\n\t\tif (material.opacityMap) {\n\t\t\tthis.opacityMapId.setValue(material.opacityMap);\n\t\t\tthis.alphaTestId.setValue(material.alphaTest);\n\t\t}\n\t}\n\n\tsetSkinning(device, meshInstance, material) {\n\t\tif (meshInstance.skinInstance) {\n\t\t\tthis._skinDrawCalls++;\n\n\t\t\tif (device.supportsBoneTextures) {\n\t\t\t\tboneTexture = meshInstance.skinInstance.boneTexture;\n\t\t\t\tthis.boneTextureId.setValue(boneTexture);\n\t\t\t\tboneTextureSize[0] = boneTexture.width;\n\t\t\t\tboneTextureSize[1] = boneTexture.height;\n\t\t\t\tboneTextureSize[2] = 1.0 / boneTexture.width;\n\t\t\t\tboneTextureSize[3] = 1.0 / boneTexture.height;\n\t\t\t\tthis.boneTextureSizeId.setValue(boneTextureSize);\n\t\t\t} else {\n\t\t\t\tthis.poseMatrixId.setValue(meshInstance.skinInstance.matrixPalette);\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawInstance(device, meshInstance, mesh, style, normal) {\n\t\tinstancingData = meshInstance.instancingData;\n\n\t\tif (instancingData) {\n\t\t\tif (instancingData.count > 0) {\n\t\t\t\tthis._instancedDrawCalls++;\n\t\t\t\tdevice.setVertexBuffer(instancingData.vertexBuffer);\n\t\t\t\tdevice.draw(mesh.primitive[style], instancingData.count);\n\n\t\t\t\tif (instancingData.vertexBuffer === _autoInstanceBuffer) {\n\t\t\t\t\tthis._removedByInstancing += instancingData.count;\n\t\t\t\t\tmeshInstance.instancingData = null;\n\t\t\t\t\treturn instancingData.count - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmodelMatrix = meshInstance.node.worldTransform;\n\t\t\tthis.modelMatrixId.setValue(modelMatrix.data);\n\n\t\t\tif (normal) {\n\t\t\t\tnormalMatrix = meshInstance.node.normalMatrix;\n\n\t\t\t\tif (meshInstance.node._dirtyNormal) {\n\t\t\t\t\tmodelMatrix.invertTo3x3(normalMatrix);\n\t\t\t\t\tnormalMatrix.transpose();\n\t\t\t\t\tmeshInstance.node._dirtyNormal = false;\n\t\t\t\t}\n\n\t\t\t\tthis.normalMatrixId.setValue(normalMatrix.data);\n\t\t\t}\n\n\t\t\tdevice.draw(mesh.primitive[style]);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdrawInstance2(device, meshInstance, mesh, style) {\n\t\tinstancingData = meshInstance.instancingData;\n\n\t\tif (instancingData) {\n\t\t\tif (instancingData.count > 0) {\n\t\t\t\tthis._instancedDrawCalls++;\n\t\t\t\tdevice.draw(mesh.primitive[style], instancingData.count, true);\n\n\t\t\t\tif (instancingData.vertexBuffer === _autoInstanceBuffer) {\n\t\t\t\t\tthis._removedByInstancing += instancingData.count;\n\t\t\t\t\tmeshInstance.instancingData = null;\n\t\t\t\t\treturn instancingData.count - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdevice.draw(mesh.primitive[style], undefined, true);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\trenderShadows(lights, camera) {\n\t\tconst isClustered = this.scene.clusteredLightingEnabled;\n\t\tconst device = this.device;\n\t\tdevice.grabPassAvailable = false;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\n\t\t\tif (isClustered && light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tif (!light.atlasViewportAllocated) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {\n\t\t\t\t\tlight.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._shadowRenderer.render(light, camera);\n\t\t}\n\n\t\tdevice.grabPassAvailable = true;\n\t}\n\n\trenderCookies(lights) {\n\t\tconst cookieRenderTarget = this.lightTextureAtlas.cookieRenderTarget;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\t\t\tif (!light.atlasViewportAllocated) continue;\n\t\t\tif (!light.atlasSlotUpdated) continue;\n\n\t\t\tthis._cookieRenderer.render(light, cookieRenderTarget);\n\t\t}\n\t}\n\n\tupdateShader(meshInstance, objDefs, staticLightList, pass, sortedLights) {\n\t\tmeshInstance.material._scene = this.scene;\n\n\t\tif (meshInstance.material._dirtyBlend) {\n\t\t\tthis.scene.layers._dirtyBlend = true;\n\t\t}\n\n\t\tmeshInstance.material.updateShader(this.device, this.scene, objDefs, staticLightList, pass, sortedLights);\n\t\tmeshInstance._shader[pass] = meshInstance.material.shader;\n\t}\n\n\tsetCullMode(cullFaces, flip, drawCall) {\n\t\tconst material = drawCall.material;\n\t\tlet mode = CULLFACE_NONE;\n\n\t\tif (cullFaces) {\n\t\t\tlet flipFaces = 1;\n\n\t\t\tif (material.cull > CULLFACE_NONE && material.cull < CULLFACE_FRONTANDBACK) {\n\t\t\t\tif (drawCall.flipFaces) flipFaces *= -1;\n\t\t\t\tif (flip) flipFaces *= -1;\n\t\t\t\tconst wt = drawCall.node.worldTransform;\n\t\t\t\twt.getX(worldMatX);\n\t\t\t\twt.getY(worldMatY);\n\t\t\t\twt.getZ(worldMatZ);\n\t\t\t\tworldMatX.cross(worldMatX, worldMatY);\n\n\t\t\t\tif (worldMatX.dot(worldMatZ) < 0) {\n\t\t\t\t\tflipFaces *= -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (flipFaces < 0) {\n\t\t\t\tmode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;\n\t\t\t} else {\n\t\t\t\tmode = material.cull;\n\t\t\t}\n\t\t}\n\n\t\tthis.device.setCullMode(mode);\n\n\t\tif (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {\n\t\t\tconst wt2 = drawCall.node.worldTransform;\n\t\t\twt2.getX(worldMatX);\n\t\t\twt2.getY(worldMatY);\n\t\t\twt2.getZ(worldMatZ);\n\t\t\tworldMatX.cross(worldMatX, worldMatY);\n\n\t\t\tif (worldMatX.dot(worldMatZ) < 0) {\n\t\t\t\tthis.twoSidedLightingNegScaleFactorId.setValue(-1.0);\n\t\t\t} else {\n\t\t\t\tthis.twoSidedLightingNegScaleFactorId.setValue(1.0);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetVertexBuffers(device, mesh) {\n\t\tdevice.setVertexBuffer(mesh.vertexBuffer);\n\t}\n\n\tsetMorphing(device, morphInstance) {\n\t\tif (morphInstance) {\n\t\t\tif (morphInstance.morph.useTextureMorph) {\n\t\t\t\tdevice.setVertexBuffer(morphInstance.morph.vertexBufferIds);\n\t\t\t\tthis.morphPositionTex.setValue(morphInstance.texturePositions);\n\t\t\t\tthis.morphNormalTex.setValue(morphInstance.textureNormals);\n\t\t\t\tthis.morphTexParams.setValue(morphInstance._textureParams);\n\t\t\t} else {\n\t\t\t\tfor (let t = 0; t < morphInstance._activeVertexBuffers.length; t++) {\n\t\t\t\t\tconst vb = morphInstance._activeVertexBuffers[t];\n\n\t\t\t\t\tif (vb) {\n\t\t\t\t\t\tconst semantic = SEMANTIC_ATTR + (t + 8);\n\t\t\t\t\t\tvb.format.elements[0].name = semantic;\n\t\t\t\t\t\tvb.format.elements[0].scopeId = device.scope.resolve(semantic);\n\t\t\t\t\t\tvb.format.update();\n\t\t\t\t\t\tdevice.setVertexBuffer(vb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);\n\t\t\t\tthis.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);\n\t\t\t}\n\t\t}\n\t}\n\n\tdispatchViewPos(position) {\n\t\tconst vp = this.viewPos;\n\t\tvp[0] = position.x;\n\t\tvp[1] = position.y;\n\t\tvp[2] = position.z;\n\t\tthis.viewPosId.setValue(vp);\n\t}\n\n\trenderForwardPrepareMaterials(camera, drawCalls, drawCallsCount, sortedLights, cullingMask, layer, pass) {\n\t\tconst addCall = (drawCall, isNewMaterial, lightMaskChanged) => {\n\t\t\t_drawCallList.drawCalls.push(drawCall);\n\n\t\t\t_drawCallList.isNewMaterial.push(isNewMaterial);\n\n\t\t\t_drawCallList.lightMaskChanged.push(lightMaskChanged);\n\t\t};\n\n\t\t_drawCallList.drawCalls.length = 0;\n\t\t_drawCallList.isNewMaterial.length = 0;\n\t\t_drawCallList.lightMaskChanged.length = 0;\n\t\tconst device = this.device;\n\t\tconst scene = this.scene;\n\t\tconst lightHash = layer ? layer._lightHash : 0;\n\t\tlet prevMaterial = null,\n\t\t\t\tprevObjDefs,\n\t\t\t\tprevStatic,\n\t\t\t\tprevLightMask;\n\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\t\t\tif (cullingMask && drawCall.mask && !(cullingMask & drawCall.mask)) continue;\n\n\t\t\tif (drawCall.command) {\n\t\t\t\taddCall(drawCall, false, false);\n\t\t\t} else {\n\t\t\t\tif (!drawCall.material) drawCall.material = DefaultMaterial.get(device);\n\t\t\t\tconst material = drawCall.material;\n\t\t\t\tconst objDefs = drawCall._shaderDefs;\n\t\t\t\tconst lightMask = drawCall.mask;\n\n\t\t\t\tif (material && material === prevMaterial && objDefs !== prevObjDefs) {\n\t\t\t\t\tprevMaterial = null;\n\t\t\t\t}\n\n\t\t\t\tif (drawCall.isStatic || prevStatic) {\n\t\t\t\t\tprevMaterial = null;\n\t\t\t\t}\n\n\t\t\t\tif (material !== prevMaterial) {\n\t\t\t\t\tthis._materialSwitches++;\n\n\t\t\t\t\tif (material.dirty) {\n\t\t\t\t\t\tmaterial.updateUniforms(device, scene);\n\t\t\t\t\t\tmaterial.dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!drawCall._shader[pass] || drawCall._shaderDefs !== objDefs || drawCall._lightHash !== lightHash) {\n\t\t\t\t\t\tif (!drawCall.isStatic) {\n\t\t\t\t\t\t\tconst variantKey = pass + \"_\" + objDefs + \"_\" + lightHash;\n\t\t\t\t\t\t\tdrawCall._shader[pass] = material.variants[variantKey];\n\n\t\t\t\t\t\t\tif (!drawCall._shader[pass]) {\n\t\t\t\t\t\t\t\tthis.updateShader(drawCall, objDefs, null, pass, sortedLights);\n\t\t\t\t\t\t\t\tmaterial.variants[variantKey] = drawCall._shader[pass];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.updateShader(drawCall, objDefs, drawCall._staticLightList, pass, sortedLights);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdrawCall._shaderDefs = objDefs;\n\t\t\t\t\t\tdrawCall._lightHash = lightHash;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\taddCall(drawCall, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);\n\t\t\t\tprevMaterial = material;\n\t\t\t\tprevObjDefs = objDefs;\n\t\t\t\tprevLightMask = lightMask;\n\t\t\t\tprevStatic = drawCall.isStatic;\n\t\t\t}\n\t\t}\n\n\t\treturn _drawCallList;\n\t}\n\n\trenderForward(camera, allDrawCalls, allDrawCallsCount, sortedLights, pass, cullingMask, drawCallback, layer, flipFaces) {\n\t\tconst device = this.device;\n\t\tconst scene = this.scene;\n\t\tconst vrDisplay = camera.vrDisplay;\n\t\tconst passFlag = 1 << pass;\n\t\tconst halfWidth = device.width * 0.5;\n\t\tconst preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, allDrawCallsCount, sortedLights, cullingMask, layer, pass);\n\t\tconst preparedCallsCount = preparedCalls.drawCalls.length;\n\n\t\tfor (let i = 0; i < preparedCallsCount; i++) {\n\t\t\tconst drawCall = preparedCalls.drawCalls[i];\n\n\t\t\tif (drawCall.command) {\n\t\t\t\tdrawCall.command();\n\t\t\t} else {\n\t\t\t\tconst newMaterial = preparedCalls.isNewMaterial[i];\n\t\t\t\tconst lightMaskChanged = preparedCalls.lightMaskChanged[i];\n\t\t\t\tconst material = drawCall.material;\n\t\t\t\tdrawCall._shaderDefs;\n\t\t\t\tconst lightMask = drawCall.mask;\n\n\t\t\t\tif (newMaterial) {\n\t\t\t\t\tconst shader = drawCall._shader[pass];\n\n\t\t\t\t\tif (!shader.failed && !device.setShader(shader)) {\n\t\t\t\t\t\tshader.failed = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterial.setParameters(device);\n\n\t\t\t\t\tif (lightMaskChanged) {\n\t\t\t\t\t\tconst usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);\n\t\t\t\t\t\tthis.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights, drawCall._staticLightList);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.alphaTestId.setValue(material.alphaTest);\n\t\t\t\t\tdevice.setBlending(material.blend);\n\n\t\t\t\t\tif (material.blend) {\n\t\t\t\t\t\tif (material.separateAlphaBlend) {\n\t\t\t\t\t\t\tdevice.setBlendFunctionSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);\n\t\t\t\t\t\t\tdevice.setBlendEquationSeparate(material.blendEquation, material.blendAlphaEquation);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdevice.setBlendFunction(material.blendSrc, material.blendDst);\n\t\t\t\t\t\t\tdevice.setBlendEquation(material.blendEquation);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdevice.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);\n\t\t\t\t\tdevice.setDepthWrite(material.depthWrite);\n\n\t\t\t\t\tif (material.depthWrite && !material.depthTest) {\n\t\t\t\t\t\tdevice.setDepthFunc(FUNC_ALWAYS);\n\t\t\t\t\t\tdevice.setDepthTest(true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdevice.setDepthFunc(FUNC_LESSEQUAL);\n\t\t\t\t\t\tdevice.setDepthTest(material.depthTest);\n\t\t\t\t\t}\n\n\t\t\t\t\tdevice.setAlphaToCoverage(material.alphaToCoverage);\n\n\t\t\t\t\tif (material.depthBias || material.slopeDepthBias) {\n\t\t\t\t\t\tdevice.setDepthBias(true);\n\t\t\t\t\t\tdevice.setDepthBiasValues(material.depthBias, material.slopeDepthBias);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdevice.setDepthBias(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setCullMode(camera._cullFaces, flipFaces, drawCall);\n\t\t\t\tconst stencilFront = drawCall.stencilFront || material.stencilFront;\n\t\t\t\tconst stencilBack = drawCall.stencilBack || material.stencilBack;\n\n\t\t\t\tif (stencilFront || stencilBack) {\n\t\t\t\t\tdevice.setStencilTest(true);\n\n\t\t\t\t\tif (stencilFront === stencilBack) {\n\t\t\t\t\t\tdevice.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);\n\t\t\t\t\t\tdevice.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (stencilFront) {\n\t\t\t\t\t\t\tdevice.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);\n\t\t\t\t\t\t\tdevice.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdevice.setStencilFuncFront(FUNC_ALWAYS, 0, 0xFF);\n\t\t\t\t\t\t\tdevice.setStencilOperationFront(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (stencilBack) {\n\t\t\t\t\t\t\tdevice.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);\n\t\t\t\t\t\t\tdevice.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdevice.setStencilFuncBack(FUNC_ALWAYS, 0, 0xFF);\n\t\t\t\t\t\t\tdevice.setStencilOperationBack(STENCILOP_KEEP, STENCILOP_KEEP, STENCILOP_KEEP, 0xFF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdevice.setStencilTest(false);\n\t\t\t\t}\n\n\t\t\t\tconst mesh = drawCall.mesh;\n\t\t\t\tdrawCall.setParameters(device, passFlag);\n\t\t\t\tthis.setVertexBuffers(device, mesh);\n\t\t\t\tthis.setMorphing(device, drawCall.morphInstance);\n\t\t\t\tthis.setSkinning(device, drawCall, material);\n\t\t\t\tconst style = drawCall.renderStyle;\n\t\t\t\tdevice.setIndexBuffer(mesh.indexBuffer[style]);\n\n\t\t\t\tif (drawCallback) {\n\t\t\t\t\tdrawCallback(drawCall, i);\n\t\t\t\t}\n\n\t\t\t\tif (vrDisplay && vrDisplay.presenting) {\n\t\t\t\t\tdevice.setViewport(0, 0, halfWidth, device.height);\n\t\t\t\t\tthis.projId.setValue(projL.data);\n\t\t\t\t\tthis.projSkyboxId.setValue(projL.data);\n\t\t\t\t\tthis.viewInvId.setValue(viewInvL.data);\n\t\t\t\t\tthis.viewId.setValue(viewL.data);\n\t\t\t\t\tthis.viewId3.setValue(viewMat3L.data);\n\t\t\t\t\tthis.viewProjId.setValue(viewProjMatL.data);\n\t\t\t\t\tthis.dispatchViewPos(viewPosL);\n\t\t\t\t\ti += this.drawInstance(device, drawCall, mesh, style, true);\n\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t\tdevice.setViewport(halfWidth, 0, halfWidth, device.height);\n\t\t\t\t\tthis.projId.setValue(projR.data);\n\t\t\t\t\tthis.projSkyboxId.setValue(projR.data);\n\t\t\t\t\tthis.viewInvId.setValue(viewInvR.data);\n\t\t\t\t\tthis.viewId.setValue(viewR.data);\n\t\t\t\t\tthis.viewId3.setValue(viewMat3R.data);\n\t\t\t\t\tthis.viewProjId.setValue(viewProjMatR.data);\n\t\t\t\t\tthis.dispatchViewPos(viewPosR);\n\t\t\t\t\ti += this.drawInstance2(device, drawCall, mesh, style);\n\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t} else if (camera.xr && camera.xr.session && camera.xr.views.length) {\n\t\t\t\t\tconst views = camera.xr.views;\n\n\t\t\t\t\tfor (let v = 0; v < views.length; v++) {\n\t\t\t\t\t\tconst view = views[v];\n\t\t\t\t\t\tdevice.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);\n\t\t\t\t\t\tthis.projId.setValue(view.projMat.data);\n\t\t\t\t\t\tthis.projSkyboxId.setValue(view.projMat.data);\n\t\t\t\t\t\tthis.viewId.setValue(view.viewOffMat.data);\n\t\t\t\t\t\tthis.viewInvId.setValue(view.viewInvOffMat.data);\n\t\t\t\t\t\tthis.viewId3.setValue(view.viewMat3.data);\n\t\t\t\t\t\tthis.viewProjId.setValue(view.projViewOffMat.data);\n\t\t\t\t\t\tthis.viewPosId.setValue(view.position);\n\n\t\t\t\t\t\tif (v === 0) {\n\t\t\t\t\t\t\ti += this.drawInstance(device, drawCall, mesh, style, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ti += this.drawInstance2(device, drawCall, mesh, style);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti += this.drawInstance(device, drawCall, mesh, style, true);\n\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t}\n\n\t\t\t\tif (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {\n\t\t\t\t\tmaterial.setParameters(device, drawCall.parameters);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdevice.updateEnd();\n\t\t_drawCallList.length = 0;\n\t}\n\n\tsetupInstancing(device) {\n\t\tif (device.enableAutoInstancing) {\n\t\t\tif (!_autoInstanceBuffer) {\n\t\t\t\t_autoInstanceBuffer = new VertexBuffer(device, VertexFormat.defaultInstancingFormat, device.autoInstancingMaxObjects, BUFFER_DYNAMIC);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateShaders(drawCalls, onlyLitShaders) {\n\t\tconst count = drawCalls.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst mat = drawCalls[i].material;\n\n\t\t\tif (mat) {\n\t\t\t\tif (!_tempMaterialSet.has(mat)) {\n\t\t\t\t\t_tempMaterialSet.add(mat);\n\n\t\t\t\t\tif (mat.updateShader !== Material.prototype.updateShader) {\n\t\t\t\t\t\tif (onlyLitShaders) {\n\t\t\t\t\t\t\tif (!mat.useLighting || mat.emitter && !mat.emitter.lighting) continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmat.clearVariants();\n\t\t\t\t\t\tmat.shader = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_tempMaterialSet.clear();\n\t}\n\n\tbeginFrame(comp, lightsChanged) {\n\t\tconst meshInstances = comp._meshInstances;\n\t\tconst scene = this.scene;\n\n\t\tif (scene.updateShaders || lightsChanged) {\n\t\t\tconst onlyLitShaders = !scene.updateShaders && lightsChanged;\n\t\t\tthis.updateShaders(meshInstances, onlyLitShaders);\n\t\t\tscene.updateShaders = false;\n\t\t\tscene._shaderVersion++;\n\t\t}\n\n\t\tthis.updateCpuSkinMatrices(meshInstances);\n\t\tconst miCount = meshInstances.length;\n\n\t\tfor (let i = 0; i < miCount; i++) {\n\t\t\tmeshInstances[i].visibleThisFrame = false;\n\t\t}\n\n\t\tconst lights = comp._lights;\n\t\tconst lightCount = lights.length;\n\n\t\tfor (let i = 0; i < lightCount; i++) {\n\t\t\tlights[i].beginFrame();\n\t\t}\n\t}\n\n\tbeginLayers(comp) {\n\t\tconst len = comp.layerList.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tcomp.layerList[i]._postRenderCounter = 0;\n\t\t}\n\n\t\tconst scene = this.scene;\n\t\tconst shaderVersion = scene._shaderVersion;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst layer = comp.layerList[i];\n\t\t\tlayer._shaderVersion = shaderVersion;\n\t\t\tlayer._preRenderCalledForCameras = 0;\n\t\t\tlayer._postRenderCalledForCameras = 0;\n\t\t\tconst transparent = comp.subLayerList[i];\n\n\t\t\tif (transparent) {\n\t\t\t\tlayer._postRenderCounter |= 2;\n\t\t\t} else {\n\t\t\t\tlayer._postRenderCounter |= 1;\n\t\t\t}\n\n\t\t\tlayer._postRenderCounterMax = layer._postRenderCounter;\n\n\t\t\tfor (let j = 0; j < layer.cameras.length; j++) {\n\t\t\t\tlayer.instances.prepare(j);\n\t\t\t}\n\n\t\t\tif (layer._needsStaticPrepare && layer._staticLightHash && !this.scene.clusteredLightingEnabled) {\n\t\t\t\tif (layer._staticPrepareDone) {\n\t\t\t\t\tStaticMeshes.revert(layer.opaqueMeshInstances);\n\t\t\t\t\tStaticMeshes.revert(layer.transparentMeshInstances);\n\t\t\t\t}\n\n\t\t\t\tStaticMeshes.prepare(this.device, scene, layer.opaqueMeshInstances, layer._lights);\n\t\t\t\tStaticMeshes.prepare(this.device, scene, layer.transparentMeshInstances, layer._lights);\n\t\t\t\tcomp._dirty = true;\n\t\t\t\tscene.updateShaders = true;\n\t\t\t\tlayer._needsStaticPrepare = false;\n\t\t\t\tlayer._staticPrepareDone = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tgpuUpdate(drawCalls) {\n\t\tthis.updateGpuSkinMatrices(drawCalls);\n\t\tthis.updateMorphing(drawCalls);\n\t}\n\n\tsetSceneConstants() {\n\t\tconst scene = this.scene;\n\t\tthis.dispatchGlobalLights(scene);\n\n\t\tif (scene.fog !== FOG_NONE) {\n\t\t\tthis.fogColor[0] = scene.fogColor.r;\n\t\t\tthis.fogColor[1] = scene.fogColor.g;\n\t\t\tthis.fogColor[2] = scene.fogColor.b;\n\n\t\t\tif (scene.gammaCorrection) {\n\t\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\t\tthis.fogColor[i] = Math.pow(this.fogColor[i], 2.2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.fogColorId.setValue(this.fogColor);\n\n\t\t\tif (scene.fog === FOG_LINEAR) {\n\t\t\t\tthis.fogStartId.setValue(scene.fogStart);\n\t\t\t\tthis.fogEndId.setValue(scene.fogEnd);\n\t\t\t} else {\n\t\t\t\tthis.fogDensityId.setValue(scene.fogDensity);\n\t\t\t}\n\t\t}\n\n\t\tconst device = this.device;\n\t\tthis._screenSize[0] = device.width;\n\t\tthis._screenSize[1] = device.height;\n\t\tthis._screenSize[2] = 1 / device.width;\n\t\tthis._screenSize[3] = 1 / device.height;\n\t\tthis.screenSizeId.setValue(this._screenSize);\n\t}\n\n\tupdateLightStats(comp, compUpdatedFlags) {}\n\n\tcullShadowmaps(comp) {\n\t\tfor (let i = 0; i < comp._lights.length; i++) {\n\t\t\tconst light = comp._lights[i];\n\n\t\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tif (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {\n\t\t\t\t\tconst casters = comp._lightCompositionData[i].shadowCastersList;\n\n\t\t\t\t\tthis._shadowRenderer.cullLocal(light, casters);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst renderActions = comp._renderActions;\n\n\t\tfor (let i = 0; i < renderActions.length; i++) {\n\t\t\tconst renderAction = renderActions[i];\n\t\t\tconst count = renderAction.directionalLightsIndices.length;\n\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tconst lightIndex = renderAction.directionalLightsIndices[j];\n\t\t\t\tconst light = comp._lights[lightIndex];\n\t\t\t\tconst casters = comp._lightCompositionData[lightIndex].shadowCastersList;\n\n\t\t\t\tthis._shadowRenderer.cullDirectional(light, casters, renderAction.camera.camera);\n\t\t\t}\n\t\t}\n\t}\n\n\tcullComposition(comp) {\n\t\tconst renderActions = comp._renderActions;\n\n\t\tfor (let i = 0; i < renderActions.length; i++) {\n\t\t\tconst renderAction = renderActions[i];\n\t\t\tconst layerIndex = renderAction.layerIndex;\n\t\t\tconst layer = comp.layerList[layerIndex];\n\t\t\tif (!layer.enabled || !comp.subLayerEnabled[layerIndex]) continue;\n\t\t\tconst transparent = comp.subLayerList[layerIndex];\n\t\t\tconst cameraPass = renderAction.cameraIndex;\n\t\t\tconst camera = layer.cameras[cameraPass];\n\n\t\t\tif (camera) {\n\t\t\t\tcamera.frameBegin(renderAction.renderTarget);\n\n\t\t\t\tif (renderAction.firstCameraUse) {\n\t\t\t\t\tthis.updateCameraFrustum(camera.camera);\n\t\t\t\t\tthis._camerasRendered++;\n\t\t\t\t}\n\n\t\t\t\tthis.cullLights(camera.camera, layer._lights);\n\t\t\t\tconst objects = layer.instances;\n\t\t\t\tconst visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n\n\t\t\t\tif (!visible.done) {\n\t\t\t\t\tif (layer.onPreCull) {\n\t\t\t\t\t\tlayer.onPreCull(cameraPass);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst drawCalls = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;\n\t\t\t\t\tvisible.length = this.cull(camera.camera, drawCalls, visible.list);\n\t\t\t\t\tvisible.done = true;\n\n\t\t\t\t\tif (layer.onPostCull) {\n\t\t\t\t\t\tlayer.onPostCull(cameraPass);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcamera.frameEnd();\n\t\t\t}\n\t\t}\n\n\t\tthis.cullShadowmaps(comp);\n\t}\n\n\tupdateLightTextureAtlas(comp) {\n\t\tthis.lightTextureAtlas.update(comp._splitLights[LIGHTTYPE_SPOT], comp._splitLights[LIGHTTYPE_OMNI], this.scene.lighting);\n\t}\n\n\tupdateClusters(comp) {\n\t\tfor (let i = 0; i < comp._worldClusters.length; i++) {\n\t\t\tconst cluster = comp._worldClusters[i];\n\t\t\tcluster.update(comp._lights, this.scene.gammaCorrection, this.scene.lighting);\n\t\t}\n\t}\n\n\trenderComposition(comp) {\n\t\tconst device = this.device;\n\t\tconst clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n\n\t\tthis.scene._updateSkybox(this.device);\n\n\t\tthis.beginLayers(comp);\n\n\t\tconst updated = comp._update(device, clusteredLightingEnabled);\n\n\t\tconst lightsChanged = (updated & COMPUPDATED_LIGHTS) !== 0;\n\t\tthis.updateLightStats(comp, updated);\n\t\tthis.beginFrame(comp, lightsChanged);\n\t\tthis.setSceneConstants();\n\t\tthis.cullComposition(comp);\n\t\tthis.gpuUpdate(comp._meshInstances);\n\n\t\tif (clusteredLightingEnabled) {\n\t\t\tthis.updateLightTextureAtlas(comp);\n\n\t\t\tif (this.scene.lighting.cookiesEnabled) {\n\t\t\t\tthis.renderCookies(comp._splitLights[LIGHTTYPE_SPOT]);\n\t\t\t\tthis.renderCookies(comp._splitLights[LIGHTTYPE_OMNI]);\n\t\t\t}\n\t\t}\n\n\t\tif (!clusteredLightingEnabled || clusteredLightingEnabled && this.scene.lighting.shadowsEnabled) {\n\t\t\tthis.renderShadows(comp._splitLights[LIGHTTYPE_SPOT]);\n\t\t\tthis.renderShadows(comp._splitLights[LIGHTTYPE_OMNI]);\n\t\t}\n\n\t\tif (clusteredLightingEnabled) {\n\t\t\tthis.updateClusters(comp);\n\t\t}\n\t\tlet clustersDebugRendered = false;\n\t\tconst renderActions = comp._renderActions;\n\n\t\tfor (let i = 0; i < renderActions.length; i++) {\n\t\t\tconst renderAction = renderActions[i];\n\t\t\tconst layerIndex = renderAction.layerIndex;\n\t\t\tconst layer = comp.layerList[layerIndex];\n\t\t\tconst transparent = comp.subLayerList[layerIndex];\n\t\t\tconst cameraPass = renderAction.cameraIndex;\n\t\t\tconst camera = layer.cameras[cameraPass];\n\n\t\t\tif (renderAction.directionalLights.length > 0) {\n\t\t\t\tthis.renderShadows(renderAction.directionalLights, camera.camera);\n\t\t\t}\n\n\t\t\tif (!layer.enabled || !comp.subLayerEnabled[layerIndex]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (camera) {\n\t\t\t\tcamera.frameBegin(renderAction.renderTarget);\n\n\t\t\t\tif (renderAction.firstCameraUse && camera.onPreRender) {\n\t\t\t\t\tcamera.onPreRender();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!transparent && layer.onPreRenderOpaque) {\n\t\t\t\tlayer.onPreRenderOpaque(cameraPass);\n\t\t\t} else if (transparent && layer.onPreRenderTransparent) {\n\t\t\t\tlayer.onPreRenderTransparent(cameraPass);\n\t\t\t}\n\n\t\t\tif (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {\n\t\t\t\tif (layer.onPreRender) {\n\t\t\t\t\tlayer.onPreRender(cameraPass);\n\t\t\t\t}\n\n\t\t\t\tlayer._preRenderCalledForCameras |= 1 << cameraPass;\n\t\t\t}\n\n\t\t\tif (camera) {\n\t\t\t\tvar _renderAction$renderT;\n\n\t\t\t\tif (renderAction.clearColor || renderAction.clearDepth || renderAction.clearStencil) {\n\t\t\t\t\tconst backupColor = camera.camera._clearColorBuffer;\n\t\t\t\t\tconst backupDepth = camera.camera._clearDepthBuffer;\n\t\t\t\t\tconst backupStencil = camera.camera._clearStencilBuffer;\n\t\t\t\t\tcamera.camera._clearColorBuffer = renderAction.clearColor;\n\t\t\t\t\tcamera.camera._clearDepthBuffer = renderAction.clearDepth;\n\t\t\t\t\tcamera.camera._clearStencilBuffer = renderAction.clearStencil;\n\t\t\t\t\tthis.clearView(camera.camera, renderAction.renderTarget, true, true);\n\t\t\t\t\tcamera.camera._clearColorBuffer = backupColor;\n\t\t\t\t\tcamera.camera._clearDepthBuffer = backupDepth;\n\t\t\t\t\tcamera.camera._clearStencilBuffer = backupStencil;\n\t\t\t\t}\n\n\t\t\t\tlayer._sortVisible(transparent, camera.camera.node, cameraPass);\n\n\t\t\t\tconst objects = layer.instances;\n\t\t\t\tconst visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n\t\t\t\tthis.scene.immediate.onPreRenderLayer(layer, visible, transparent);\n\t\t\t\tthis.scene._activeCamera = camera.camera;\n\t\t\t\tthis.setCamera(camera.camera, renderAction.renderTarget);\n\n\t\t\t\tif (clusteredLightingEnabled && renderAction.lightClusters) {\n\t\t\t\t\trenderAction.lightClusters.activate(this.lightTextureAtlas);\n\n\t\t\t\t\tif (!clustersDebugRendered && this.scene.lighting.debugLayer === layer.id) {\n\t\t\t\t\t\tclustersDebugRendered = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst flipFaces = !!(camera.camera._flipFaces ^ (renderAction == null ? void 0 : (_renderAction$renderT = renderAction.renderTarget) == null ? void 0 : _renderAction$renderT.flipY));\n\t\t\t\tconst draws = this._forwardDrawCalls;\n\t\t\t\tthis.renderForward(camera.camera, visible.list, visible.length, layer._splitLights, layer.shaderPass, layer.cullingMask, layer.onDrawCall, layer, flipFaces);\n\t\t\t\tlayer._forwardDrawCalls += this._forwardDrawCalls - draws;\n\t\t\t\tdevice.setColorWrite(true, true, true, true);\n\t\t\t\tdevice.setStencilTest(false);\n\t\t\t\tdevice.setAlphaToCoverage(false);\n\t\t\t\tdevice.setDepthBias(false);\n\t\t\t\tcamera.frameEnd();\n\n\t\t\t\tif (renderAction.lastCameraUse && camera.onPostRender) {\n\t\t\t\t\tcamera.onPostRender();\n\t\t\t\t}\n\n\t\t\t\tif (renderAction.triggerPostprocess && camera.onPostprocessing) {\n\t\t\t\t\tcamera.onPostprocessing();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!transparent && layer.onPostRenderOpaque) {\n\t\t\t\tlayer.onPostRenderOpaque(cameraPass);\n\t\t\t} else if (transparent && layer.onPostRenderTransparent) {\n\t\t\t\tlayer.onPostRenderTransparent(cameraPass);\n\t\t\t}\n\n\t\t\tif (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {\n\t\t\t\tlayer._postRenderCounter &= ~(transparent ? 2 : 1);\n\n\t\t\t\tif (layer._postRenderCounter === 0) {\n\t\t\t\t\tlayer.onPostRender(cameraPass);\n\t\t\t\t\tlayer._postRenderCalledForCameras |= 1 << cameraPass;\n\t\t\t\t\tlayer._postRenderCounter = layer._postRenderCounterMax;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nlet keyA, keyB, sortPos, sortDir;\n\nfunction sortManual(drawCallA, drawCallB) {\n\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n}\n\nfunction sortMaterialMesh(drawCallA, drawCallB) {\n\tkeyA = drawCallA._key[SORTKEY_FORWARD];\n\tkeyB = drawCallB._key[SORTKEY_FORWARD];\n\n\tif (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {\n\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t}\n\n\treturn keyB - keyA;\n}\n\nfunction sortBackToFront(drawCallA, drawCallB) {\n\treturn drawCallB.zdist - drawCallA.zdist;\n}\n\nfunction sortFrontToBack(drawCallA, drawCallB) {\n\treturn drawCallA.zdist - drawCallB.zdist;\n}\n\nconst sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];\n\nfunction sortLights(lightA, lightB) {\n\treturn lightB.key - lightA.key;\n}\n\nlet layerCounter = 0;\n\nclass VisibleInstanceList {\n\tconstructor() {\n\t\tthis.list = [];\n\t\tthis.length = 0;\n\t\tthis.done = false;\n\t}\n\n}\n\nclass InstanceList {\n\tconstructor() {\n\t\tthis.opaqueMeshInstances = [];\n\t\tthis.transparentMeshInstances = [];\n\t\tthis.shadowCasters = [];\n\t\tthis.visibleOpaque = [];\n\t\tthis.visibleTransparent = [];\n\t}\n\n\tprepare(index) {\n\t\tif (!this.visibleOpaque[index]) {\n\t\t\tthis.visibleOpaque[index] = new VisibleInstanceList();\n\t\t}\n\n\t\tif (!this.visibleTransparent[index]) {\n\t\t\tthis.visibleTransparent[index] = new VisibleInstanceList();\n\t\t}\n\n\t\tthis.visibleOpaque[index].done = false;\n\t\tthis.visibleTransparent[index].done = false;\n\t}\n\n\tdelete(index) {\n\t\tif (index < this.visibleOpaque.length) {\n\t\t\tthis.visibleOpaque.splice(index, 1);\n\t\t}\n\n\t\tif (index < this.visibleTransparent.length) {\n\t\t\tthis.visibleTransparent.splice(index, 1);\n\t\t}\n\t}\n\n}\n\nclass Layer {\n\tconstructor(options = {}) {\n\t\tif (options.id !== undefined) {\n\t\t\tthis.id = options.id;\n\t\t\tlayerCounter = Math.max(this.id + 1, layerCounter);\n\t\t} else {\n\t\t\tthis.id = layerCounter++;\n\t\t}\n\n\t\tthis.name = options.name;\n\t\tthis._enabled = options.enabled === undefined ? true : options.enabled;\n\t\tthis._refCounter = this._enabled ? 1 : 0;\n\t\tthis.opaqueSortMode = options.opaqueSortMode === undefined ? SORTMODE_MATERIALMESH : options.opaqueSortMode;\n\t\tthis.transparentSortMode = options.transparentSortMode === undefined ? SORTMODE_BACK2FRONT : options.transparentSortMode;\n\t\tthis.renderTarget = options.renderTarget;\n\t\tthis.shaderPass = options.shaderPass === undefined ? SHADER_FORWARD : options.shaderPass;\n\t\tthis.passThrough = options.passThrough === undefined ? false : options.passThrough;\n\t\tthis._clearColorBuffer = options.clearColorBuffer ? options.clearColorBuffer : false;\n\t\tthis._clearDepthBuffer = options.clearDepthBuffer ? options.clearDepthBuffer : false;\n\t\tthis._clearStencilBuffer = options.clearStencilBuffer ? options.clearStencilBuffer : false;\n\t\tthis.onPreCull = options.onPreCull;\n\t\tthis.onPreRender = options.onPreRender;\n\t\tthis.onPreRenderOpaque = options.onPreRenderOpaque;\n\t\tthis.onPreRenderTransparent = options.onPreRenderTransparent;\n\t\tthis.onPostCull = options.onPostCull;\n\t\tthis.onPostRender = options.onPostRender;\n\t\tthis.onPostRenderOpaque = options.onPostRenderOpaque;\n\t\tthis.onPostRenderTransparent = options.onPostRenderTransparent;\n\t\tthis.onDrawCall = options.onDrawCall;\n\t\tthis.onEnable = options.onEnable;\n\t\tthis.onDisable = options.onDisable;\n\n\t\tif (this._enabled && this.onEnable) {\n\t\t\tthis.onEnable();\n\t\t}\n\n\t\tthis.layerReference = options.layerReference;\n\t\tthis.instances = options.layerReference ? options.layerReference.instances : new InstanceList();\n\t\tthis.cullingMask = options.cullingMask ? options.cullingMask : 0xFFFFFFFF;\n\t\tthis.opaqueMeshInstances = this.instances.opaqueMeshInstances;\n\t\tthis.transparentMeshInstances = this.instances.transparentMeshInstances;\n\t\tthis.shadowCasters = this.instances.shadowCasters;\n\t\tthis.customSortCallback = null;\n\t\tthis.customCalculateSortValues = null;\n\t\tthis._lights = [];\n\t\tthis._lightsSet = new Set();\n\t\tthis._clusteredLightsSet = new Set();\n\t\tthis._splitLights = [[], [], []];\n\t\tthis.cameras = [];\n\t\tthis._dirty = false;\n\t\tthis._dirtyLights = false;\n\t\tthis._dirtyCameras = false;\n\t\tthis._lightHash = 0;\n\t\tthis._staticLightHash = 0;\n\t\tthis._needsStaticPrepare = true;\n\t\tthis._staticPrepareDone = false;\n\t\tthis._shaderVersion = -1;\n\t\tthis._lightCube = null;\n\t}\n\n\tset renderTarget(rt) {\n\t\tthis._renderTarget = rt;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tget renderTarget() {\n\t\treturn this._renderTarget;\n\t}\n\n\tset enabled(val) {\n\t\tif (val !== this._enabled) {\n\t\t\tthis._enabled = val;\n\n\t\t\tif (val) {\n\t\t\t\tthis.incrementCounter();\n\t\t\t\tif (this.onEnable) this.onEnable();\n\t\t\t} else {\n\t\t\t\tthis.decrementCounter();\n\t\t\t\tif (this.onDisable) this.onDisable();\n\t\t\t}\n\t\t}\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tset clearColor(val) {\n\t\tthis._clearColor.copy(val);\n\t}\n\n\tget clearColor() {\n\t\treturn this._clearColor;\n\t}\n\n\tset clearColorBuffer(val) {\n\t\tthis._clearColorBuffer = val;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tget clearColorBuffer() {\n\t\treturn this._clearColorBuffer;\n\t}\n\n\tset clearDepthBuffer(val) {\n\t\tthis._clearDepthBuffer = val;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tget clearDepthBuffer() {\n\t\treturn this._clearDepthBuffer;\n\t}\n\n\tset clearStencilBuffer(val) {\n\t\tthis._clearStencilBuffer = val;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tget clearStencilBuffer() {\n\t\treturn this._clearStencilBuffer;\n\t}\n\n\tincrementCounter() {\n\t\tif (this._refCounter === 0) {\n\t\t\tthis._enabled = true;\n\t\t\tif (this.onEnable) this.onEnable();\n\t\t}\n\n\t\tthis._refCounter++;\n\t}\n\n\tdecrementCounter() {\n\t\tif (this._refCounter === 1) {\n\t\t\tthis._enabled = false;\n\t\t\tif (this.onDisable) this.onDisable();\n\t\t} else if (this._refCounter === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._refCounter--;\n\t}\n\n\taddMeshInstances(meshInstances, skipShadowCasters) {\n\t\tconst sceneShaderVer = this._shaderVersion;\n\t\tconst casters = this.shadowCasters;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst m = meshInstances[i];\n\t\t\tconst mat = m.material;\n\t\t\tconst arr = mat.blendType === BLEND_NONE ? this.opaqueMeshInstances : this.transparentMeshInstances;\n\n\t\t\tif (this.opaqueMeshInstances.indexOf(m) < 0 && this.transparentMeshInstances.indexOf(m) < 0) {\n\t\t\t\tarr.push(m);\n\t\t\t}\n\n\t\t\tif (!skipShadowCasters && m.castShadow && casters.indexOf(m) < 0) casters.push(m);\n\n\t\t\tif (!this.passThrough && sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {\n\t\t\t\tif (mat.updateShader !== Material.prototype.updateShader) {\n\t\t\t\t\tmat.clearVariants();\n\t\t\t\t\tmat.shader = null;\n\t\t\t\t}\n\n\t\t\t\tmat._shaderVersion = sceneShaderVer;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.passThrough) this._dirty = true;\n\t}\n\n\tremoveMeshInstanceFromArray(m, arr) {\n\t\tlet spliceOffset = -1;\n\t\tlet spliceCount = 0;\n\t\tconst len = arr.length;\n\n\t\tfor (let j = 0; j < len; j++) {\n\t\t\tconst drawCall = arr[j];\n\n\t\t\tif (drawCall === m) {\n\t\t\t\tspliceOffset = j;\n\t\t\t\tspliceCount = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (drawCall._staticSource === m) {\n\t\t\t\tif (spliceOffset < 0) spliceOffset = j;\n\t\t\t\tspliceCount++;\n\t\t\t} else if (spliceOffset >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (spliceOffset >= 0) {\n\t\t\tarr.splice(spliceOffset, spliceCount);\n\t\t}\n\t}\n\n\tremoveMeshInstances(meshInstances, skipShadowCasters) {\n\t\tconst opaque = this.opaqueMeshInstances;\n\t\tconst transparent = this.transparentMeshInstances;\n\t\tconst casters = this.shadowCasters;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst m = meshInstances[i];\n\t\t\tthis.removeMeshInstanceFromArray(m, opaque);\n\t\t\tthis.removeMeshInstanceFromArray(m, transparent);\n\n\t\t\tif (!skipShadowCasters) {\n\t\t\t\tconst j = casters.indexOf(m);\n\t\t\t\tif (j >= 0) casters.splice(j, 1);\n\t\t\t}\n\t\t}\n\n\t\tthis._dirty = true;\n\t}\n\n\tclearMeshInstances(skipShadowCasters) {\n\t\tif (this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0) {\n\t\t\tif (skipShadowCasters || this.shadowCasters.length === 0) return;\n\t\t}\n\n\t\tthis.opaqueMeshInstances.length = 0;\n\t\tthis.transparentMeshInstances.length = 0;\n\t\tif (!skipShadowCasters) this.shadowCasters.length = 0;\n\t\tif (!this.passThrough) this._dirty = true;\n\t}\n\n\taddLight(light) {\n\t\tconst l = light.light;\n\n\t\tif (!this._lightsSet.has(l)) {\n\t\t\tthis._lightsSet.add(l);\n\n\t\t\tif (l.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tthis._clusteredLightsSet.add(l);\n\t\t\t}\n\n\t\t\tthis._lights.push(l);\n\n\t\t\tthis._dirtyLights = true;\n\n\t\t\tthis._generateLightHash();\n\t\t}\n\t}\n\n\tremoveLight(light) {\n\t\tconst l = light.light;\n\n\t\tif (this._lightsSet.has(l)) {\n\t\t\tthis._lightsSet.delete(l);\n\n\t\t\tif (l.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tthis._clusteredLightsSet.delete(l);\n\t\t\t}\n\n\t\t\tthis._lights.splice(this._lights.indexOf(l), 1);\n\n\t\t\tthis._dirtyLights = true;\n\n\t\t\tthis._generateLightHash();\n\t\t}\n\t}\n\n\tclearLights() {\n\t\tthis._lightsSet.clear();\n\n\t\tthis._clusteredLightsSet.clear();\n\n\t\tthis._lights.length = 0;\n\t\tthis._dirtyLights = true;\n\t}\n\n\tget clusteredLightsSet() {\n\t\treturn this._clusteredLightsSet;\n\t}\n\n\taddShadowCasters(meshInstances) {\n\t\tconst arr = this.shadowCasters;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst m = meshInstances[i];\n\t\t\tif (!m.castShadow) continue;\n\t\t\tif (arr.indexOf(m) < 0) arr.push(m);\n\t\t}\n\n\t\tthis._dirtyLights = true;\n\t}\n\n\tremoveShadowCasters(meshInstances) {\n\t\tconst arr = this.shadowCasters;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst id = arr.indexOf(meshInstances[i]);\n\t\t\tif (id >= 0) arr.splice(id, 1);\n\t\t}\n\n\t\tthis._dirtyLights = true;\n\t}\n\n\t_generateLightHash() {\n\t\tif (this._lights.length > 0) {\n\t\t\tthis._lights.sort(sortLights);\n\n\t\t\tlet str = \"\";\n\t\t\tlet strStatic = \"\";\n\n\t\t\tfor (let i = 0; i < this._lights.length; i++) {\n\t\t\t\tif (this._lights[i].isStatic) {\n\t\t\t\t\tstrStatic += this._lights[i].key;\n\t\t\t\t} else {\n\t\t\t\t\tstr += this._lights[i].key;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (str.length === 0) {\n\t\t\t\tthis._lightHash = 0;\n\t\t\t} else {\n\t\t\t\tthis._lightHash = hashCode(str);\n\t\t\t}\n\n\t\t\tif (strStatic.length === 0) {\n\t\t\t\tthis._staticLightHash = 0;\n\t\t\t} else {\n\t\t\t\tthis._staticLightHash = hashCode(strStatic);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._lightHash = 0;\n\t\t\tthis._staticLightHash = 0;\n\t\t}\n\t}\n\n\taddCamera(camera) {\n\t\tif (this.cameras.indexOf(camera) >= 0) return;\n\t\tthis.cameras.push(camera);\n\t\tthis._dirtyCameras = true;\n\t}\n\n\tremoveCamera(camera) {\n\t\tconst index = this.cameras.indexOf(camera);\n\n\t\tif (index >= 0) {\n\t\t\tthis.cameras.splice(index, 1);\n\t\t\tthis._dirtyCameras = true;\n\t\t\tthis.instances.delete(index);\n\t\t}\n\t}\n\n\tclearCameras() {\n\t\tthis.cameras.length = 0;\n\t\tthis._dirtyCameras = true;\n\t}\n\n\t_calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\t\t\tif (drawCall.command) continue;\n\t\t\tif (drawCall.layer <= LAYER_FX) continue;\n\n\t\t\tif (drawCall.calculateSortDistance) {\n\t\t\t\tdrawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst meshPos = drawCall.aabb.center;\n\t\t\tconst tempx = meshPos.x - camPos.x;\n\t\t\tconst tempy = meshPos.y - camPos.y;\n\t\t\tconst tempz = meshPos.z - camPos.z;\n\t\t\tdrawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;\n\t\t}\n\t}\n\n\t_sortVisible(transparent, cameraNode, cameraPass) {\n\t\tconst objects = this.instances;\n\t\tconst sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;\n\t\tif (sortMode === SORTMODE_NONE) return;\n\t\tconst visible = transparent ? objects.visibleTransparent[cameraPass] : objects.visibleOpaque[cameraPass];\n\n\t\tif (sortMode === SORTMODE_CUSTOM) {\n\t\t\tsortPos = cameraNode.getPosition();\n\t\t\tsortDir = cameraNode.forward;\n\n\t\t\tif (this.customCalculateSortValues) {\n\t\t\t\tthis.customCalculateSortValues(visible.list, visible.length, sortPos, sortDir);\n\t\t\t}\n\n\t\t\tif (visible.list.length !== visible.length) {\n\t\t\t\tvisible.list.length = visible.length;\n\t\t\t}\n\n\t\t\tif (this.customSortCallback) {\n\t\t\t\tvisible.list.sort(this.customSortCallback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {\n\t\t\t\tsortPos = cameraNode.getPosition();\n\t\t\t\tsortDir = cameraNode.forward;\n\n\t\t\t\tthis._calculateSortDistances(visible.list, visible.length, sortPos, sortDir);\n\t\t\t}\n\n\t\t\tif (visible.list.length !== visible.length) {\n\t\t\t\tvisible.list.length = visible.length;\n\t\t\t}\n\n\t\t\tvisible.list.sort(sortCallbacks[sortMode]);\n\t\t}\n\t}\n\n}\n\nconst set = {\n\tequals: function (set1, set2) {\n\t\tif (set1.size !== set2.size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (const item of set1) {\n\t\t\tif (!set2.has(item)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n\nclass RenderAction {\n\tconstructor() {\n\t\tthis.layerIndex = 0;\n\t\tthis.cameraIndex = 0;\n\t\tthis.camera = null;\n\t\tthis.renderTarget = null;\n\t\tthis.lightClusters = null;\n\t\tthis.clearColor = false;\n\t\tthis.clearDepth = false;\n\t\tthis.clearStencil = false;\n\t\tthis.triggerPostprocess = false;\n\t\tthis.firstCameraUse = false;\n\t\tthis.lastCameraUse = false;\n\t\tthis.directionalLightsSet = new Set();\n\t\tthis.directionalLights = [];\n\t\tthis.directionalLightsIndices = [];\n\t}\n\n\treset() {\n\t\tthis.lightClusters = null;\n\t\tthis.directionalLightsSet.clear();\n\t\tthis.directionalLights.length = 0;\n\t\tthis.directionalLightsIndices.length = 0;\n\t}\n\n\tcollectDirectionalLights(cameraLayers, dirLights, allLights) {\n\t\tthis.directionalLightsSet.clear();\n\t\tthis.directionalLights.length = 0;\n\t\tthis.directionalLightsIndices.length = 0;\n\n\t\tfor (let i = 0; i < dirLights.length; i++) {\n\t\t\tconst light = dirLights[i];\n\n\t\t\tif (light.castShadows) {\n\t\t\t\tfor (let l = 0; l < cameraLayers.length; l++) {\n\t\t\t\t\tif (cameraLayers[l]._splitLights[LIGHTTYPE_DIRECTIONAL].indexOf(light) >= 0) {\n\t\t\t\t\t\tif (!this.directionalLightsSet.has(light)) {\n\t\t\t\t\t\t\tthis.directionalLightsSet.add(light);\n\t\t\t\t\t\t\tthis.directionalLights.push(light);\n\t\t\t\t\t\t\tconst lightIndex = allLights.indexOf(light);\n\t\t\t\t\t\t\tthis.directionalLightsIndices.push(lightIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass LightCompositionData {\n\tconstructor() {\n\t\tthis.shadowCastersSet = new Set();\n\t\tthis.shadowCastersList = [];\n\t}\n\n\tclearShadowCasters() {\n\t\tthis.shadowCastersSet.clear();\n\t\tthis.shadowCastersList.length = 0;\n\t}\n\n\taddShadowCasters(casters) {\n\t\tfor (let i = 0; i < casters.length; i++) {\n\t\t\tconst item = casters[i];\n\n\t\t\tif (!this.shadowCastersSet.has(item)) {\n\t\t\t\tthis.shadowCastersSet.add(item);\n\t\t\t\tthis.shadowCastersList.push(item);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nconst tempSet$1 = new Set();\nconst tempClusterArray = [];\n\nclass LayerComposition extends EventHandler {\n\tconstructor(name = \"Untitled\") {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.logRenderActions = false;\n\t\tthis.layerList = [];\n\t\tthis.subLayerList = [];\n\t\tthis.subLayerEnabled = [];\n\t\tthis._opaqueOrder = {};\n\t\tthis._transparentOrder = {};\n\t\tthis._dirty = false;\n\t\tthis._dirtyBlend = false;\n\t\tthis._dirtyLights = false;\n\t\tthis._dirtyCameras = false;\n\t\tthis._meshInstances = [];\n\t\tthis._meshInstancesSet = new Set();\n\t\tthis._lights = [];\n\t\tthis._lightsMap = new Map();\n\t\tthis._lightCompositionData = [];\n\t\tthis._splitLights = [[], [], []];\n\t\tthis.cameras = [];\n\t\tthis._renderActions = [];\n\t\tthis._worldClusters = [];\n\t\tthis._emptyWorldClusters = null;\n\t}\n\n\tdestroy() {\n\t\tif (this._emptyWorldClusters) {\n\t\t\tthis._emptyWorldClusters.destroy();\n\n\t\t\tthis._emptyWorldClusters = null;\n\t\t}\n\n\t\tthis._worldClusters.forEach(cluster => {\n\t\t\tcluster.destroy();\n\t\t});\n\n\t\tthis._worldClusters = null;\n\t}\n\n\tgetEmptyWorldClusters(device) {\n\t\tif (!this._emptyWorldClusters) {\n\t\t\tthis._emptyWorldClusters = new WorldClusters(device);\n\t\t\tthis._emptyWorldClusters.name = \"ClusterEmpty\";\n\n\t\t\tthis._emptyWorldClusters.update([], false, null);\n\t\t}\n\n\t\treturn this._emptyWorldClusters;\n\t}\n\n\t_splitLightsArray(target) {\n\t\tconst lights = target._lights;\n\t\ttarget._splitLights[LIGHTTYPE_DIRECTIONAL].length = 0;\n\t\ttarget._splitLights[LIGHTTYPE_OMNI].length = 0;\n\t\ttarget._splitLights[LIGHTTYPE_SPOT].length = 0;\n\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\n\t\t\tif (light.enabled) {\n\t\t\t\ttarget._splitLights[light._type].push(light);\n\t\t\t}\n\t\t}\n\t}\n\n\t_update(device, clusteredLightingEnabled = false) {\n\t\tconst len = this.layerList.length;\n\t\tlet result = 0;\n\n\t\tif (!this._dirty || !this._dirtyLights || !this._dirtyCameras) {\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\n\t\t\t\tif (layer._dirty) {\n\t\t\t\t\tthis._dirty = true;\n\t\t\t\t}\n\n\t\t\t\tif (layer._dirtyLights) {\n\t\t\t\t\tthis._dirtyLights = true;\n\t\t\t\t}\n\n\t\t\t\tif (layer._dirtyCameras) {\n\t\t\t\t\tthis._dirtyCameras = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction addUniqueMeshInstance(destArray, destSet, srcArray) {\n\t\t\tlet dirtyBlend = false;\n\t\t\tconst srcLen = srcArray.length;\n\n\t\t\tfor (let s = 0; s < srcLen; s++) {\n\t\t\t\tconst meshInst = srcArray[s];\n\n\t\t\t\tif (!destSet.has(meshInst)) {\n\t\t\t\t\tdestSet.add(meshInst);\n\t\t\t\t\tdestArray.push(meshInst);\n\t\t\t\t\tconst material = meshInst.material;\n\n\t\t\t\t\tif (material && material._dirtyBlend) {\n\t\t\t\t\t\tdirtyBlend = true;\n\t\t\t\t\t\tmaterial._dirtyBlend = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dirtyBlend;\n\t\t}\n\n\t\tif (this._dirty) {\n\t\t\tresult |= COMPUPDATED_INSTANCES;\n\t\t\tthis._meshInstances.length = 0;\n\n\t\t\tthis._meshInstancesSet.clear();\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\n\t\t\t\tif (!layer.passThrough) {\n\t\t\t\t\tthis._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.opaqueMeshInstances) || this._dirtyBlend;\n\t\t\t\t\tthis._dirtyBlend = addUniqueMeshInstance(this._meshInstances, this._meshInstancesSet, layer.transparentMeshInstances) || this._dirtyBlend;\n\t\t\t\t}\n\n\t\t\t\tlayer._dirty = false;\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tfunction moveByBlendType(dest, src, moveTransparent) {\n\t\t\tfor (let s = 0; s < src.length;) {\n\t\t\t\tvar _src$s$material;\n\n\t\t\t\tif (((_src$s$material = src[s].material) == null ? void 0 : _src$s$material.transparent) === moveTransparent) {\n\t\t\t\t\tdest.push(src[s]);\n\t\t\t\t\tsrc[s] = src[src.length - 1];\n\t\t\t\t\tsrc.length--;\n\t\t\t\t} else {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._dirtyBlend) {\n\t\t\tresult |= COMPUPDATED_BLEND;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\n\t\t\t\tif (!layer.passThrough) {\n\t\t\t\t\tmoveByBlendType(layer.opaqueMeshInstances, layer.transparentMeshInstances, false);\n\t\t\t\t\tmoveByBlendType(layer.transparentMeshInstances, layer.opaqueMeshInstances, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirtyBlend = false;\n\t\t}\n\n\t\tif (this._dirtyLights) {\n\t\t\tresult |= COMPUPDATED_LIGHTS;\n\t\t\tthis._dirtyLights = false;\n\t\t\tthis.updateLights();\n\t\t}\n\n\t\tif (result) {\n\t\t\tthis.updateShadowCasters();\n\t\t}\n\n\t\tif (this._dirtyCameras || result & COMPUPDATED_LIGHTS) {\n\t\t\tthis._dirtyCameras = false;\n\t\t\tresult |= COMPUPDATED_CAMERAS;\n\t\t\tthis.cameras.length = 0;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\t\t\t\tlayer._dirtyCameras = false;\n\n\t\t\t\tfor (let j = 0; j < layer.cameras.length; j++) {\n\t\t\t\t\tconst camera = layer.cameras[j];\n\t\t\t\t\tconst index = this.cameras.indexOf(camera);\n\n\t\t\t\t\tif (index < 0) {\n\t\t\t\t\t\tthis.cameras.push(camera);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.cameras.length > 1) {\n\t\t\t\tthis.cameras.sort((a, b) => a.priority - b.priority);\n\t\t\t}\n\n\t\t\tconst cameraLayers = [];\n\t\t\tlet renderActionCount = 0;\n\n\t\t\tfor (let i = 0; i < this.cameras.length; i++) {\n\t\t\t\tconst camera = this.cameras[i];\n\t\t\t\tcameraLayers.length = 0;\n\t\t\t\tlet cameraFirstRenderAction = true;\n\t\t\t\tconst cameraFirstRenderActionIndex = renderActionCount;\n\t\t\t\tlet lastRenderAction = null;\n\t\t\t\tlet postProcessMarked = false;\n\n\t\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\t\tconst layer = this.layerList[j];\n\n\t\t\t\t\tif (layer) {\n\t\t\t\t\t\tif (layer.cameras.length > 0) {\n\t\t\t\t\t\t\tif (camera.layers.indexOf(layer.id) >= 0) {\n\t\t\t\t\t\t\t\tcameraLayers.push(layer);\n\n\t\t\t\t\t\t\t\tif (!postProcessMarked && layer.id === camera.disablePostEffectsLayer) {\n\t\t\t\t\t\t\t\t\tpostProcessMarked = true;\n\n\t\t\t\t\t\t\t\t\tif (lastRenderAction) {\n\t\t\t\t\t\t\t\t\t\tlastRenderAction.triggerPostprocess = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst cameraIndex = layer.cameras.indexOf(camera);\n\n\t\t\t\t\t\t\t\tif (cameraIndex >= 0) {\n\t\t\t\t\t\t\t\t\tlastRenderAction = this.addRenderAction(this._renderActions, renderActionCount, layer, j, cameraIndex, cameraFirstRenderAction, postProcessMarked);\n\t\t\t\t\t\t\t\t\trenderActionCount++;\n\t\t\t\t\t\t\t\t\tcameraFirstRenderAction = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cameraFirstRenderActionIndex < renderActionCount) {\n\t\t\t\t\tthis._renderActions[cameraFirstRenderActionIndex].collectDirectionalLights(cameraLayers, this._splitLights[LIGHTTYPE_DIRECTIONAL], this._lights);\n\n\t\t\t\t\tlastRenderAction.lastCameraUse = true;\n\t\t\t\t}\n\n\t\t\t\tif (!postProcessMarked && lastRenderAction) {\n\t\t\t\t\tlastRenderAction.triggerPostprocess = true;\n\t\t\t\t}\n\n\t\t\t\tif (camera.renderTarget && camera.postEffectsEnabled) {\n\t\t\t\t\tthis.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._renderActions.length = renderActionCount;\n\n\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\tthis.allocateLightClusters(device);\n\t\t\t}\n\t\t}\n\n\t\tif (result & COMPUPDATED_LIGHTS || result & COMPUPDATED_CAMERAS) {\n\t\t\tthis._logRenderActions();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tupdateShadowCasters() {\n\t\tconst lightCount = this._lights.length;\n\n\t\tfor (let i = 0; i < lightCount; i++) {\n\t\t\tthis._lightCompositionData[i].clearShadowCasters();\n\t\t}\n\n\t\tconst len = this.layerList.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst layer = this.layerList[i];\n\n\t\t\tif (!tempSet$1.has(layer)) {\n\t\t\t\ttempSet$1.add(layer);\n\t\t\t\tconst lights = layer._lights;\n\n\t\t\t\tfor (let j = 0; j < lights.length; j++) {\n\t\t\t\t\tif (lights[j].castShadows) {\n\t\t\t\t\t\tconst lightIndex = this._lightsMap.get(lights[j]);\n\n\t\t\t\t\t\tconst lightCompData = this._lightCompositionData[lightIndex];\n\t\t\t\t\t\tlightCompData.addShadowCasters(layer.shadowCasters);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttempSet$1.clear();\n\t}\n\n\tupdateLights() {\n\t\tthis._lights.length = 0;\n\n\t\tthis._lightsMap.clear();\n\n\t\tconst count = this.layerList.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst layer = this.layerList[i];\n\n\t\t\tif (!tempSet$1.has(layer)) {\n\t\t\t\ttempSet$1.add(layer);\n\t\t\t\tconst lights = layer._lights;\n\n\t\t\t\tfor (let j = 0; j < lights.length; j++) {\n\t\t\t\t\tconst light = lights[j];\n\n\t\t\t\t\tlet lightIndex = this._lightsMap.get(light);\n\n\t\t\t\t\tif (lightIndex === undefined) {\n\t\t\t\t\t\tlightIndex = this._lights.length;\n\n\t\t\t\t\t\tthis._lightsMap.set(light, lightIndex);\n\n\t\t\t\t\t\tthis._lights.push(light);\n\n\t\t\t\t\t\tlet lightCompData = this._lightCompositionData[lightIndex];\n\n\t\t\t\t\t\tif (!lightCompData) {\n\t\t\t\t\t\t\tlightCompData = new LightCompositionData();\n\t\t\t\t\t\t\tthis._lightCompositionData[lightIndex] = lightCompData;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._splitLightsArray(layer);\n\n\t\t\tlayer._dirtyLights = false;\n\t\t}\n\n\t\ttempSet$1.clear();\n\n\t\tthis._splitLightsArray(this);\n\n\t\tconst lightCount = this._lights.length;\n\t\tthis._lightCompositionData.length = lightCount;\n\t}\n\n\tfindCompatibleCluster(layer, renderActionCount) {\n\t\tfor (let i = 0; i < renderActionCount; i++) {\n\t\t\tconst ra = this._renderActions[i];\n\t\t\tconst raLayer = this.layerList[ra.layerIndex];\n\n\t\t\tif (layer === raLayer) {\n\t\t\t\treturn ra.lightClusters;\n\t\t\t}\n\n\t\t\tif (ra.lightClusters) {\n\t\t\t\tif (set.equals(layer._clusteredLightsSet, raLayer._clusteredLightsSet)) {\n\t\t\t\t\treturn ra.lightClusters;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tallocateLightClusters(device) {\n\t\ttempClusterArray.push(...this._worldClusters);\n\t\tthis._worldClusters.length = 0;\n\t\tconst count = this._renderActions.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst ra = this._renderActions[i];\n\t\t\tconst layer = this.layerList[ra.layerIndex];\n\n\t\t\tif (layer._clusteredLightsSet.size) {\n\t\t\t\tconst transparent = this.subLayerList[ra.layerIndex];\n\t\t\t\tconst meshInstances = transparent ? layer.transparentMeshInstances : layer.opaqueMeshInstances;\n\n\t\t\t\tif (meshInstances.length) {\n\t\t\t\t\tlet clusters = this.findCompatibleCluster(layer, i);\n\n\t\t\t\t\tif (!clusters) {\n\t\t\t\t\t\tif (tempClusterArray.length) {\n\t\t\t\t\t\t\tclusters = tempClusterArray.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!clusters) {\n\t\t\t\t\t\t\tclusters = new WorldClusters(device);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclusters.name = \"Cluster-\" + this._worldClusters.length;\n\n\t\t\t\t\t\tthis._worldClusters.push(clusters);\n\t\t\t\t\t}\n\n\t\t\t\t\tra.lightClusters = clusters;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ra.lightClusters) {\n\t\t\t\tra.lightClusters = this.getEmptyWorldClusters(device);\n\t\t\t}\n\t\t}\n\n\t\ttempClusterArray.forEach(item => {\n\t\t\titem.destroy();\n\t\t});\n\t\ttempClusterArray.length = 0;\n\t}\n\n\taddRenderAction(renderActions, renderActionIndex, layer, layerIndex, cameraIndex, cameraFirstRenderAction, postProcessMarked) {\n\t\tlet renderAction = renderActions[renderActionIndex];\n\n\t\tif (!renderAction) {\n\t\t\trenderAction = renderActions[renderActionIndex] = new RenderAction();\n\t\t}\n\n\t\tlet rt = layer.renderTarget;\n\t\tconst camera = layer.cameras[cameraIndex];\n\n\t\tif (camera && camera.renderTarget) {\n\t\t\tif (layer.id !== LAYERID_DEPTH) {\n\t\t\t\trt = camera.renderTarget;\n\t\t\t}\n\t\t}\n\n\t\tlet used = false;\n\n\t\tfor (let i = renderActionIndex - 1; i >= 0; i--) {\n\t\t\tif (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {\n\t\t\t\tused = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tconst needsClear = cameraFirstRenderAction || !used;\n\t\tlet clearColor = needsClear ? camera.clearColorBuffer : false;\n\t\tlet clearDepth = needsClear ? camera.clearDepthBuffer : false;\n\t\tlet clearStencil = needsClear ? camera.clearStencilBuffer : false;\n\t\tclearColor |= layer.clearColorBuffer;\n\t\tclearDepth |= layer.clearDepthBuffer;\n\t\tclearStencil |= layer.clearStencilBuffer;\n\n\t\tif (postProcessMarked && camera.postEffectsEnabled) {\n\t\t\trt = null;\n\t\t}\n\n\t\trenderAction.reset();\n\t\trenderAction.triggerPostprocess = false;\n\t\trenderAction.layerIndex = layerIndex;\n\t\trenderAction.cameraIndex = cameraIndex;\n\t\trenderAction.camera = camera;\n\t\trenderAction.renderTarget = rt;\n\t\trenderAction.clearColor = clearColor;\n\t\trenderAction.clearDepth = clearDepth;\n\t\trenderAction.clearStencil = clearStencil;\n\t\trenderAction.firstCameraUse = cameraFirstRenderAction;\n\t\trenderAction.lastCameraUse = false;\n\t\treturn renderAction;\n\t}\n\n\tpropagateRenderTarget(startIndex, fromCamera) {\n\t\tfor (let a = startIndex; a >= 0; a--) {\n\t\t\tconst ra = this._renderActions[a];\n\t\t\tconst layer = this.layerList[ra.layerIndex];\n\n\t\t\tif (ra.renderTarget && layer.id !== LAYERID_DEPTH) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (layer.id === LAYERID_DEPTH) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst thisCamera = ra == null ? void 0 : ra.camera.camera;\n\n\t\t\tif (thisCamera) {\n\t\t\t\tif (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tra.renderTarget = fromCamera.renderTarget;\n\t\t}\n\t}\n\n\t_logRenderActions() {}\n\n\t_isLayerAdded(layer) {\n\t\tif (this.layerList.indexOf(layer) >= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_isSublayerAdded(layer, transparent) {\n\t\tfor (let i = 0; i < this.layerList.length; i++) {\n\t\t\tif (this.layerList[i] === layer && this.subLayerList[i] === transparent) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpush(layer) {\n\t\tif (this._isLayerAdded(layer)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis.layerList.push(layer);\n\t\tthis._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;\n\t\tthis._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tinsert(layer, index) {\n\t\tif (this._isLayerAdded(layer)) return;\n\t\tthis.layerList.splice(index, 0, layer, layer);\n\t\tthis.subLayerList.splice(index, 0, false, true);\n\t\tconst count = this.layerList.length;\n\n\t\tthis._updateOpaqueOrder(index, count - 1);\n\n\t\tthis._updateTransparentOrder(index, count - 1);\n\n\t\tthis.subLayerEnabled.splice(index, 0, true, true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tremove(layer) {\n\t\tlet id = this.layerList.indexOf(layer);\n\t\tdelete this._opaqueOrder[id];\n\t\tdelete this._transparentOrder[id];\n\n\t\twhile (id >= 0) {\n\t\t\tthis.layerList.splice(id, 1);\n\t\t\tthis.subLayerList.splice(id, 1);\n\t\t\tthis.subLayerEnabled.splice(id, 1);\n\t\t\tid = this.layerList.indexOf(layer);\n\t\t\tthis._dirty = true;\n\t\t\tthis._dirtyLights = true;\n\t\t\tthis._dirtyCameras = true;\n\t\t\tthis.fire(\"remove\", layer);\n\t\t}\n\n\t\tconst count = this.layerList.length;\n\n\t\tthis._updateOpaqueOrder(0, count - 1);\n\n\t\tthis._updateTransparentOrder(0, count - 1);\n\t}\n\n\tpushOpaque(layer) {\n\t\tif (this._isSublayerAdded(layer, false)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tinsertOpaque(layer, index) {\n\t\tif (this._isSublayerAdded(layer, false)) return;\n\t\tthis.layerList.splice(index, 0, layer);\n\t\tthis.subLayerList.splice(index, 0, false);\n\t\tconst count = this.subLayerList.length;\n\n\t\tthis._updateOpaqueOrder(index, count - 1);\n\n\t\tthis.subLayerEnabled.splice(index, 0, true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tremoveOpaque(layer) {\n\t\tfor (let i = 0, len = this.layerList.length; i < len; i++) {\n\t\t\tif (this.layerList[i] === layer && !this.subLayerList[i]) {\n\t\t\t\tthis.layerList.splice(i, 1);\n\t\t\t\tthis.subLayerList.splice(i, 1);\n\t\t\t\tlen--;\n\n\t\t\t\tthis._updateOpaqueOrder(i, len - 1);\n\n\t\t\t\tthis.subLayerEnabled.splice(i, 1);\n\t\t\t\tthis._dirty = true;\n\t\t\t\tthis._dirtyLights = true;\n\t\t\t\tthis._dirtyCameras = true;\n\n\t\t\t\tif (this.layerList.indexOf(layer) < 0) {\n\t\t\t\t\tthis.fire(\"remove\", layer);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpushTransparent(layer) {\n\t\tif (this._isSublayerAdded(layer, true)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tinsertTransparent(layer, index) {\n\t\tif (this._isSublayerAdded(layer, true)) return;\n\t\tthis.layerList.splice(index, 0, layer);\n\t\tthis.subLayerList.splice(index, 0, true);\n\t\tconst count = this.subLayerList.length;\n\n\t\tthis._updateTransparentOrder(index, count - 1);\n\n\t\tthis.subLayerEnabled.splice(index, 0, true);\n\t\tthis._dirty = true;\n\t\tthis._dirtyLights = true;\n\t\tthis._dirtyCameras = true;\n\t\tthis.fire(\"add\", layer);\n\t}\n\n\tremoveTransparent(layer) {\n\t\tfor (let i = 0, len = this.layerList.length; i < len; i++) {\n\t\t\tif (this.layerList[i] === layer && this.subLayerList[i]) {\n\t\t\t\tthis.layerList.splice(i, 1);\n\t\t\t\tthis.subLayerList.splice(i, 1);\n\t\t\t\tlen--;\n\n\t\t\t\tthis._updateTransparentOrder(i, len - 1);\n\n\t\t\t\tthis.subLayerEnabled.splice(i, 1);\n\t\t\t\tthis._dirty = true;\n\t\t\t\tthis._dirtyLights = true;\n\t\t\t\tthis._dirtyCameras = true;\n\n\t\t\t\tif (this.layerList.indexOf(layer) < 0) {\n\t\t\t\t\tthis.fire(\"remove\", layer);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t_getSublayerIndex(layer, transparent) {\n\t\tlet id = this.layerList.indexOf(layer);\n\t\tif (id < 0) return -1;\n\n\t\tif (this.subLayerList[id] !== transparent) {\n\t\t\tid = this.layerList.indexOf(layer, id + 1);\n\t\t\tif (id < 0) return -1;\n\n\t\t\tif (this.subLayerList[id] !== transparent) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\treturn id;\n\t}\n\n\tgetOpaqueIndex(layer) {\n\t\treturn this._getSublayerIndex(layer, false);\n\t}\n\n\tgetTransparentIndex(layer) {\n\t\treturn this._getSublayerIndex(layer, true);\n\t}\n\n\tgetLayerById(id) {\n\t\tfor (let i = 0; i < this.layerList.length; i++) {\n\t\t\tif (this.layerList[i].id === id) return this.layerList[i];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tgetLayerByName(name) {\n\t\tfor (let i = 0; i < this.layerList.length; i++) {\n\t\t\tif (this.layerList[i].name === name) return this.layerList[i];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_updateOpaqueOrder(startIndex, endIndex) {\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tif (this.subLayerList[i] === false) {\n\t\t\t\tthis._opaqueOrder[this.layerList[i].id] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateTransparentOrder(startIndex, endIndex) {\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tif (this.subLayerList[i] === true) {\n\t\t\t\tthis._transparentOrder[this.layerList[i].id] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t_sortLayersDescending(layersA, layersB, order) {\n\t\tlet topLayerA = -1;\n\t\tlet topLayerB = -1;\n\n\t\tfor (let i = 0, len = layersA.length; i < len; i++) {\n\t\t\tconst id = layersA[i];\n\n\t\t\tif (order.hasOwnProperty(id)) {\n\t\t\t\ttopLayerA = Math.max(topLayerA, order[id]);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = layersB.length; i < len; i++) {\n\t\t\tconst id = layersB[i];\n\n\t\t\tif (order.hasOwnProperty(id)) {\n\t\t\t\ttopLayerB = Math.max(topLayerB, order[id]);\n\t\t\t}\n\t\t}\n\n\t\tif (topLayerA === -1 && topLayerB !== -1) {\n\t\t\treturn 1;\n\t\t} else if (topLayerB === -1 && topLayerA !== -1) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn topLayerB - topLayerA;\n\t}\n\n\tsortTransparentLayers(layersA, layersB) {\n\t\treturn this._sortLayersDescending(layersA, layersB, this._transparentOrder);\n\t}\n\n\tsortOpaqueLayers(layersA, layersB) {\n\t\treturn this._sortLayersDescending(layersA, layersB, this._opaqueOrder);\n\t}\n\n}\n\nconst spotCenter = new Vec3();\nconst spotEndPoint = new Vec3();\nconst tmpVec = new Vec3();\nconst tmpBiases = {\n\tbias: 0,\n\tnormalBias: 0\n};\nconst chanId = {\n\tr: 0,\n\tg: 1,\n\tb: 2,\n\ta: 3\n};\nconst directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];\nlet id = 0;\n\nclass LightRenderData {\n\tconstructor(device, camera, face, light) {\n\t\tthis.light = light;\n\t\tthis.camera = camera;\n\t\tthis.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);\n\t\tthis.shadowMatrix = new Mat4();\n\t\tthis.shadowViewport = new Vec4(0, 0, 1, 1);\n\t\tthis.shadowScissor = new Vec4(0, 0, 1, 1);\n\t\tthis.face = face;\n\t\tthis.visibleCasters = [];\n\t}\n\n\tget shadowBuffer() {\n\t\tconst rt = this.shadowCamera.renderTarget;\n\n\t\tif (rt) {\n\t\t\tconst light = this.light;\n\n\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\treturn rt.colorBuffer;\n\t\t\t}\n\n\t\t\treturn light._isPcf && light.device.webgl2 ? rt.depthBuffer : rt.colorBuffer;\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n\nclass Light {\n\tconstructor(graphicsDevice) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.id = id++;\n\t\tthis._type = LIGHTTYPE_DIRECTIONAL;\n\t\tthis._color = new Color(0.8, 0.8, 0.8);\n\t\tthis._intensity = 1;\n\t\tthis._castShadows = false;\n\t\tthis._enabled = false;\n\t\tthis.mask = MASK_AFFECT_DYNAMIC;\n\t\tthis.isStatic = false;\n\t\tthis.key = 0;\n\t\tthis.bakeDir = true;\n\t\tthis.bakeNumSamples = 1;\n\t\tthis.bakeArea = 0;\n\t\tthis.attenuationStart = 10;\n\t\tthis.attenuationEnd = 10;\n\t\tthis._falloffMode = LIGHTFALLOFF_LINEAR;\n\t\tthis._shadowType = SHADOW_PCF3;\n\t\tthis._vsmBlurSize = 11;\n\t\tthis.vsmBlurMode = BLUR_GAUSSIAN;\n\t\tthis.vsmBias = 0.01 * 0.25;\n\t\tthis._cookie = null;\n\t\tthis.cookieIntensity = 1;\n\t\tthis._cookieFalloff = true;\n\t\tthis._cookieChannel = \"rgb\";\n\t\tthis._cookieTransform = null;\n\t\tthis._cookieTransformUniform = new Float32Array(4);\n\t\tthis._cookieOffset = null;\n\t\tthis._cookieOffsetUniform = new Float32Array(2);\n\t\tthis._cookieTransformSet = false;\n\t\tthis._cookieOffsetSet = false;\n\t\tthis._innerConeAngle = 40;\n\t\tthis._outerConeAngle = 45;\n\t\tthis.cascades = null;\n\t\tthis._shadowMatrixPalette = null;\n\t\tthis._shadowCascadeDistances = null;\n\t\tthis.numCascades = 1;\n\t\tthis.cascadeDistribution = 0.5;\n\t\tthis._shape = LIGHTSHAPE_PUNCTUAL;\n\t\tthis._finalColor = new Float32Array([0.8, 0.8, 0.8]);\n\t\tconst c = Math.pow(this._finalColor[0], 2.2);\n\t\tthis._linearFinalColor = new Float32Array([c, c, c]);\n\t\tthis._position = new Vec3(0, 0, 0);\n\t\tthis._direction = new Vec3(0, 0, 0);\n\t\tthis._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);\n\t\tthis._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);\n\t\tthis._shadowMap = null;\n\t\tthis._shadowRenderParams = [];\n\t\tthis.shadowDistance = 40;\n\t\tthis._shadowResolution = 1024;\n\t\tthis.shadowBias = -0.0005;\n\t\tthis._normalOffsetBias = 0.0;\n\t\tthis.shadowUpdateMode = SHADOWUPDATE_REALTIME;\n\t\tthis._isVsm = false;\n\t\tthis._isPcf = true;\n\t\tthis._cookieMatrix = null;\n\t\tthis._atlasViewport = null;\n\t\tthis.atlasViewportAllocated = false;\n\t\tthis.atlasVersion = 0;\n\t\tthis.atlasSlotIndex = 0;\n\t\tthis.atlasSlotUpdated = false;\n\t\tthis._scene = null;\n\t\tthis._node = null;\n\t\tthis._renderData = [];\n\t\tthis.visibleThisFrame = false;\n\t\tthis.maxScreenSize = 0;\n\t}\n\n\tdestroy() {\n\t\tthis._destroyShadowMap();\n\n\t\tthis._renderData = null;\n\t}\n\n\tset numCascades(value) {\n\t\tif (!this.cascades || this.numCascades != value) {\n\t\t\tthis.cascades = directionalCascades[value - 1];\n\t\t\tthis._shadowMatrixPalette = new Float32Array(4 * 16);\n\t\t\tthis._shadowCascadeDistances = new Float32Array(4);\n\n\t\t\tthis._destroyShadowMap();\n\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\n\tget numCascades() {\n\t\treturn this.cascades.length;\n\t}\n\n\tset shadowMap(shadowMap) {\n\t\tif (this._shadowMap !== shadowMap) {\n\t\t\tthis._destroyShadowMap();\n\n\t\t\tthis._shadowMap = shadowMap;\n\t\t}\n\t}\n\n\tget shadowMap() {\n\t\treturn this._shadowMap;\n\t}\n\n\tget numShadowFaces() {\n\t\tconst type = this._type;\n\n\t\tif (type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\treturn this.numCascades;\n\t\t} else if (type === LIGHTTYPE_OMNI) {\n\t\t\treturn 6;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tset type(value) {\n\t\tif (this._type === value) return;\n\t\tthis._type = value;\n\n\t\tthis._destroyShadowMap();\n\n\t\tthis.updateKey();\n\t\tconst stype = this._shadowType;\n\t\tthis._shadowType = null;\n\t\tthis.shadowType = stype;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset shape(value) {\n\t\tif (this._shape === value) return;\n\t\tthis._shape = value;\n\n\t\tthis._destroyShadowMap();\n\n\t\tthis.updateKey();\n\t\tconst stype = this._shadowType;\n\t\tthis._shadowType = null;\n\t\tthis.shadowType = stype;\n\t}\n\n\tget shape() {\n\t\treturn this._shape;\n\t}\n\n\tset shadowType(value) {\n\t\tif (this._shadowType === value) return;\n\t\tconst device = this.device;\n\t\tif (this._type === LIGHTTYPE_OMNI) value = SHADOW_PCF3;\n\n\t\tif (value === SHADOW_PCF5 && !device.webgl2) {\n\t\t\tvalue = SHADOW_PCF3;\n\t\t}\n\n\t\tif (value === SHADOW_VSM32 && !device.textureFloatRenderable) value = SHADOW_VSM16;\n\t\tif (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) value = SHADOW_VSM8;\n\t\tthis._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;\n\t\tthis._isPcf = value === SHADOW_PCF5 || value === SHADOW_PCF3;\n\t\tthis._shadowType = value;\n\n\t\tthis._destroyShadowMap();\n\n\t\tthis.updateKey();\n\t}\n\n\tget shadowType() {\n\t\treturn this._shadowType;\n\t}\n\n\tset enabled(value) {\n\t\tif (this._enabled !== value) {\n\t\t\tthis._enabled = value;\n\t\t\tthis.layersDirty();\n\t\t}\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tset castShadows(value) {\n\t\tif (this._castShadows !== value) {\n\t\t\tthis._castShadows = value;\n\n\t\t\tthis._destroyShadowMap();\n\n\t\t\tthis.layersDirty();\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\n\tget castShadows() {\n\t\treturn this._castShadows && this.mask !== MASK_BAKE && this.mask !== 0;\n\t}\n\n\tset shadowResolution(value) {\n\t\tif (this._shadowResolution !== value) {\n\t\t\tif (this._type === LIGHTTYPE_OMNI) {\n\t\t\t\tvalue = Math.min(value, this.device.maxCubeMapSize);\n\t\t\t} else {\n\t\t\t\tvalue = Math.min(value, this.device.maxTextureSize);\n\t\t\t}\n\n\t\t\tthis._shadowResolution = value;\n\n\t\t\tthis._destroyShadowMap();\n\t\t}\n\t}\n\n\tget shadowResolution() {\n\t\treturn this._shadowResolution;\n\t}\n\n\tset vsmBlurSize(value) {\n\t\tif (this._vsmBlurSize === value) return;\n\t\tif (value % 2 === 0) value++;\n\t\tthis._vsmBlurSize = value;\n\t}\n\n\tget vsmBlurSize() {\n\t\treturn this._vsmBlurSize;\n\t}\n\n\tset normalOffsetBias(value) {\n\t\tif (this._normalOffsetBias === value) return;\n\n\t\tif (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {\n\t\t\tthis.updateKey();\n\t\t}\n\n\t\tthis._normalOffsetBias = value;\n\t}\n\n\tget normalOffsetBias() {\n\t\treturn this._normalOffsetBias;\n\t}\n\n\tset falloffMode(value) {\n\t\tif (this._falloffMode === value) return;\n\t\tthis._falloffMode = value;\n\t\tthis.updateKey();\n\t}\n\n\tget falloffMode() {\n\t\treturn this._falloffMode;\n\t}\n\n\tset innerConeAngle(value) {\n\t\tif (this._innerConeAngle === value) return;\n\t\tthis._innerConeAngle = value;\n\t\tthis._innerConeAngleCos = Math.cos(value * Math.PI / 180);\n\t}\n\n\tget innerConeAngle() {\n\t\treturn this._innerConeAngle;\n\t}\n\n\tset outerConeAngle(value) {\n\t\tif (this._outerConeAngle === value) return;\n\t\tthis._outerConeAngle = value;\n\t\tthis._outerConeAngleCos = Math.cos(value * Math.PI / 180);\n\t}\n\n\tget outerConeAngle() {\n\t\treturn this._outerConeAngle;\n\t}\n\n\tset intensity(value) {\n\t\tif (this._intensity !== value) {\n\t\t\tthis._intensity = value;\n\n\t\t\tthis._updateFinalColor();\n\t\t}\n\t}\n\n\tget intensity() {\n\t\treturn this._intensity;\n\t}\n\n\tget cookieMatrix() {\n\t\tif (!this._cookieMatrix) {\n\t\t\tthis._cookieMatrix = new Mat4();\n\t\t}\n\n\t\treturn this._cookieMatrix;\n\t}\n\n\tget atlasViewport() {\n\t\tif (!this._atlasViewport) {\n\t\t\tthis._atlasViewport = new Vec4(0, 0, 1, 1);\n\t\t}\n\n\t\treturn this._atlasViewport;\n\t}\n\n\tset cookie(value) {\n\t\tif (this._cookie === value) return;\n\t\tthis._cookie = value;\n\t\tthis.updateKey();\n\t}\n\n\tget cookie() {\n\t\treturn this._cookie;\n\t}\n\n\tset cookieFalloff(value) {\n\t\tif (this._cookieFalloff === value) return;\n\t\tthis._cookieFalloff = value;\n\t\tthis.updateKey();\n\t}\n\n\tget cookieFalloff() {\n\t\treturn this._cookieFalloff;\n\t}\n\n\tset cookieChannel(value) {\n\t\tif (this._cookieChannel === value) return;\n\n\t\tif (value.length < 3) {\n\t\t\tconst chr = value.charAt(value.length - 1);\n\t\t\tconst addLen = 3 - value.length;\n\n\t\t\tfor (let i = 0; i < addLen; i++) value += chr;\n\t\t}\n\n\t\tthis._cookieChannel = value;\n\t\tthis.updateKey();\n\t}\n\n\tget cookieChannel() {\n\t\treturn this._cookieChannel;\n\t}\n\n\tset cookieTransform(value) {\n\t\tif (this._cookieTransform === value) return;\n\t\tthis._cookieTransform = value;\n\t\tthis._cookieTransformSet = !!value;\n\n\t\tif (value && !this._cookieOffset) {\n\t\t\tthis.cookieOffset = new Vec2();\n\t\t\tthis._cookieOffsetSet = false;\n\t\t}\n\n\t\tthis.updateKey();\n\t}\n\n\tget cookieTransform() {\n\t\treturn this._cookieTransform;\n\t}\n\n\tset cookieOffset(value) {\n\t\tif (this._cookieOffset === value) return;\n\t\tconst xformNew = !!(this._cookieTransformSet || value);\n\n\t\tif (xformNew && !value && this._cookieOffset) {\n\t\t\tthis._cookieOffset.set(0, 0);\n\t\t} else {\n\t\t\tthis._cookieOffset = value;\n\t\t}\n\n\t\tthis._cookieOffsetSet = !!value;\n\n\t\tif (value && !this._cookieTransform) {\n\t\t\tthis.cookieTransform = new Vec4(1, 1, 0, 0);\n\t\t\tthis._cookieTransformSet = false;\n\t\t}\n\n\t\tthis.updateKey();\n\t}\n\n\tget cookieOffset() {\n\t\treturn this._cookieOffset;\n\t}\n\n\tbeginFrame() {\n\t\tthis.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;\n\t\tthis.maxScreenSize = 0;\n\t\tthis.atlasViewportAllocated = false;\n\t\tthis.atlasSlotUpdated = false;\n\t}\n\n\t_destroyShadowMap() {\n\t\tif (this._renderData) {\n\t\t\tthis._renderData.length = 0;\n\t\t}\n\n\t\tif (this._shadowMap) {\n\t\t\tif (!this._shadowMap.cached) {\n\t\t\t\tthis._shadowMap.destroy();\n\t\t\t}\n\n\t\t\tthis._shadowMap = null;\n\t\t}\n\n\t\tif (this.shadowUpdateMode === SHADOWUPDATE_NONE) {\n\t\t\tthis.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t}\n\t}\n\n\tgetRenderData(camera, face) {\n\t\tfor (let i = 0; i < this._renderData.length; i++) {\n\t\t\tconst current = this._renderData[i];\n\n\t\t\tif (current.camera === camera && current.face === face) {\n\t\t\t\treturn current;\n\t\t\t}\n\t\t}\n\n\t\tconst rd = new LightRenderData(this.device, camera, face, this);\n\n\t\tthis._renderData.push(rd);\n\n\t\treturn rd;\n\t}\n\n\tclone() {\n\t\tconst clone = new Light(this.device);\n\t\tclone.type = this._type;\n\t\tclone.setColor(this._color);\n\t\tclone.intensity = this._intensity;\n\t\tclone.castShadows = this.castShadows;\n\t\tclone._enabled = this._enabled;\n\t\tclone.attenuationStart = this.attenuationStart;\n\t\tclone.attenuationEnd = this.attenuationEnd;\n\t\tclone.falloffMode = this._falloffMode;\n\t\tclone.shadowType = this._shadowType;\n\t\tclone.vsmBlurSize = this._vsmBlurSize;\n\t\tclone.vsmBlurMode = this.vsmBlurMode;\n\t\tclone.vsmBias = this.vsmBias;\n\t\tclone.shadowUpdateMode = this.shadowUpdateMode;\n\t\tclone.mask = this.mask;\n\t\tclone.innerConeAngle = this._innerConeAngle;\n\t\tclone.outerConeAngle = this._outerConeAngle;\n\t\tclone.numCascades = this.numCascades;\n\t\tclone.cascadeDistribution = this.cascadeDistribution;\n\t\tclone.shape = this._shape;\n\t\tclone.shadowBias = this.shadowBias;\n\t\tclone.normalOffsetBias = this._normalOffsetBias;\n\t\tclone.shadowResolution = this._shadowResolution;\n\t\tclone.shadowDistance = this.shadowDistance;\n\t\treturn clone;\n\t}\n\n\t_getUniformBiasValues(lightRenderData) {\n\t\tconst farClip = lightRenderData.shadowCamera._farClip;\n\n\t\tswitch (this._type) {\n\t\t\tcase LIGHTTYPE_OMNI:\n\t\t\t\ttmpBiases.bias = this.shadowBias;\n\t\t\t\ttmpBiases.normalBias = this._normalOffsetBias;\n\t\t\t\tbreak;\n\n\t\t\tcase LIGHTTYPE_SPOT:\n\t\t\t\tif (this._isVsm) {\n\t\t\t\t\ttmpBiases.bias = -0.00001 * 20;\n\t\t\t\t} else {\n\t\t\t\t\ttmpBiases.bias = this.shadowBias * 20;\n\t\t\t\t\tif (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;\n\t\t\t\t}\n\n\t\t\t\ttmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;\n\t\t\t\tbreak;\n\n\t\t\tcase LIGHTTYPE_DIRECTIONAL:\n\t\t\t\tif (this._isVsm) {\n\t\t\t\t\ttmpBiases.bias = -0.00001 * 20;\n\t\t\t\t} else {\n\t\t\t\t\ttmpBiases.bias = this.shadowBias / farClip * 100;\n\t\t\t\t\tif (!this.device.webgl2 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;\n\t\t\t\t}\n\n\t\t\t\ttmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpBiases;\n\t}\n\n\tgetColor() {\n\t\treturn this._color;\n\t}\n\n\tgetBoundingSphere(sphere) {\n\t\tif (this._type === LIGHTTYPE_SPOT) {\n\t\t\tconst range = this.attenuationEnd;\n\t\t\tconst angle = this._outerConeAngle;\n\t\t\tconst f = Math.cos(angle * math.DEG_TO_RAD);\n\t\t\tconst node = this._node;\n\t\t\tspotCenter.copy(node.up);\n\t\t\tspotCenter.mulScalar(-range * 0.5 * f);\n\t\t\tspotCenter.add(node.getPosition());\n\t\t\tsphere.center = spotCenter;\n\t\t\tspotEndPoint.copy(node.up);\n\t\t\tspotEndPoint.mulScalar(-range);\n\t\t\ttmpVec.copy(node.right);\n\t\t\ttmpVec.mulScalar(Math.sin(angle * math.DEG_TO_RAD) * range);\n\t\t\tspotEndPoint.add(tmpVec);\n\t\t\tsphere.radius = spotEndPoint.length() * 0.5;\n\t\t} else if (this._type === LIGHTTYPE_OMNI) {\n\t\t\tsphere.center = this._node.getPosition();\n\t\t\tsphere.radius = this.attenuationEnd;\n\t\t}\n\t}\n\n\tgetBoundingBox(box) {\n\t\tif (this._type === LIGHTTYPE_SPOT) {\n\t\t\tconst range = this.attenuationEnd;\n\t\t\tconst angle = this._outerConeAngle;\n\t\t\tconst node = this._node;\n\t\t\tconst scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);\n\t\t\tbox.center.set(0, -range * 0.5, 0);\n\t\t\tbox.halfExtents.set(scl, range * 0.5, scl);\n\t\t\tbox.setFromTransformedAabb(box, node.getWorldTransform(), true);\n\t\t} else if (this._type === LIGHTTYPE_OMNI) {\n\t\t\tbox.center.copy(this._node.getPosition());\n\t\t\tbox.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);\n\t\t}\n\t}\n\n\t_updateFinalColor() {\n\t\tconst color = this._color;\n\t\tconst r = color.r;\n\t\tconst g = color.g;\n\t\tconst b = color.b;\n\t\tconst i = this._intensity;\n\t\tconst finalColor = this._finalColor;\n\t\tconst linearFinalColor = this._linearFinalColor;\n\t\tfinalColor[0] = r * i;\n\t\tfinalColor[1] = g * i;\n\t\tfinalColor[2] = b * i;\n\n\t\tif (i >= 1) {\n\t\t\tlinearFinalColor[0] = Math.pow(r, 2.2) * i;\n\t\t\tlinearFinalColor[1] = Math.pow(g, 2.2) * i;\n\t\t\tlinearFinalColor[2] = Math.pow(b, 2.2) * i;\n\t\t} else {\n\t\t\tlinearFinalColor[0] = Math.pow(finalColor[0], 2.2);\n\t\t\tlinearFinalColor[1] = Math.pow(finalColor[1], 2.2);\n\t\t\tlinearFinalColor[2] = Math.pow(finalColor[2], 2.2);\n\t\t}\n\t}\n\n\tsetColor() {\n\t\tif (arguments.length === 1) {\n\t\t\tthis._color.set(arguments[0].r, arguments[0].g, arguments[0].b);\n\t\t} else if (arguments.length === 3) {\n\t\t\tthis._color.set(arguments[0], arguments[1], arguments[2]);\n\t\t}\n\n\t\tthis._updateFinalColor();\n\t}\n\n\tupdateShadow() {\n\t\tif (this.shadowUpdateMode !== SHADOWUPDATE_REALTIME) {\n\t\t\tthis.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t}\n\t}\n\n\tlayersDirty() {\n\t\tvar _this$_scene;\n\n\t\tif ((_this$_scene = this._scene) != null && _this$_scene.layers) {\n\t\t\tthis._scene.layers._dirtyLights = true;\n\t\t}\n\t}\n\n\tupdateKey() {\n\t\tlet key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8;\n\n\t\tif (this._cookieChannel.length === 3) {\n\t\t\tkey |= chanId[this._cookieChannel.charAt(1)] << 16;\n\t\t\tkey |= chanId[this._cookieChannel.charAt(2)] << 14;\n\t\t}\n\n\t\tif (key !== this.key && this._scene !== null) {\n\t\t\tthis.layersDirty();\n\t\t}\n\n\t\tthis.key = key;\n\t}\n\n}\n\nclass LightingParams {\n\tconstructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {\n\t\tthis._maxTextureSize = maxTextureSize;\n\t\tthis._supportsAreaLights = supportsAreaLights;\n\t\tthis._dirtyLightsFnc = dirtyLightsFnc;\n\t\tthis._areaLightsEnabled = false;\n\t\tthis._cells = new Vec3(10, 3, 10);\n\t\tthis._maxLightsPerCell = 255;\n\t\tthis._shadowsEnabled = true;\n\t\tthis._shadowType = SHADOW_PCF3;\n\t\tthis._shadowAtlasResolution = 2048;\n\t\tthis._cookiesEnabled = false;\n\t\tthis._cookieAtlasResolution = 2048;\n\t\tthis.atlasSplit = null;\n\t\tthis.debugLayer = undefined;\n\t}\n\n\tset cells(value) {\n\t\tthis._cells.copy(value);\n\t}\n\n\tget cells() {\n\t\treturn this._cells;\n\t}\n\n\tset maxLightsPerCell(value) {\n\t\tthis._maxLightsPerCell = math.clamp(value, 1, 255);\n\t}\n\n\tget maxLightsPerCell() {\n\t\treturn this._maxLightsPerCell;\n\t}\n\n\tset cookieAtlasResolution(value) {\n\t\tthis._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);\n\t}\n\n\tget cookieAtlasResolution() {\n\t\treturn this._cookieAtlasResolution;\n\t}\n\n\tset shadowAtlasResolution(value) {\n\t\tthis._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);\n\t}\n\n\tget shadowAtlasResolution() {\n\t\treturn this._shadowAtlasResolution;\n\t}\n\n\tset shadowType(value) {\n\t\tif (this._shadowType !== value) {\n\t\t\tthis._shadowType = value;\n\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\n\tget shadowType() {\n\t\treturn this._shadowType;\n\t}\n\n\tset cookiesEnabled(value) {\n\t\tif (this._cookiesEnabled !== value) {\n\t\t\tthis._cookiesEnabled = value;\n\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\n\tget cookiesEnabled() {\n\t\treturn this._cookiesEnabled;\n\t}\n\n\tset areaLightsEnabled(value) {\n\t\tif (this._supportsAreaLights) {\n\t\t\tif (this._areaLightsEnabled !== value) {\n\t\t\t\tthis._areaLightsEnabled = value;\n\n\t\t\t\tthis._dirtyLightsFnc();\n\t\t\t}\n\t\t}\n\t}\n\n\tget areaLightsEnabled() {\n\t\treturn this._areaLightsEnabled;\n\t}\n\n\tset shadowsEnabled(value) {\n\t\tif (this._shadowsEnabled !== value) {\n\t\t\tthis._shadowsEnabled = value;\n\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\n\tget shadowsEnabled() {\n\t\treturn this._shadowsEnabled;\n\t}\n\n}\n\nconst tempSphere = new BoundingSphere();\n\nclass BakeLight {\n\tconstructor(scene, light) {\n\t\tthis.scene = scene;\n\t\tthis.light = light;\n\t\tthis.store();\n\t\tlight.numCascades = 1;\n\n\t\tif (light.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tlight._node.getWorldTransform();\n\n\t\t\tlight.getBoundingSphere(tempSphere);\n\t\t\tthis.lightBounds = new BoundingBox();\n\t\t\tthis.lightBounds.center.copy(tempSphere.center);\n\t\t\tthis.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);\n\t\t}\n\t}\n\n\tstore() {\n\t\tthis.mask = this.light.mask;\n\t\tthis.shadowUpdateMode = this.light.shadowUpdateMode;\n\t\tthis.enabled = this.light.enabled;\n\t\tthis.intensity = this.light.intensity;\n\t\tthis.rotation = this.light._node.getLocalRotation().clone();\n\t\tthis.numCascades = this.light.numCascades;\n\t}\n\n\trestore() {\n\t\tconst light = this.light;\n\t\tlight.mask = this.mask;\n\t\tlight.shadowUpdateMode = this.shadowUpdateMode;\n\t\tlight.enabled = this.enabled;\n\t\tlight.intensity = this.intensity;\n\n\t\tlight._node.setLocalRotation(this.rotation);\n\n\t\tlight.numCascades = this.numCascades;\n\t}\n\n\tstartBake() {\n\t\tthis.light.enabled = true;\n\n\t\tthis.light._destroyShadowMap();\n\t}\n\n\tendBake(shadowMapCache) {\n\t\tconst light = this.light;\n\t\tlight.enabled = false;\n\n\t\tif (light.shadowMap) {\n\t\t\tif (light.shadowMap.cached) shadowMapCache.add(light, light.shadowMap);\n\t\t\tlight.shadowMap = null;\n\t\t}\n\t}\n\n}\n\nconst _tempPoint$1 = new Vec2();\n\nclass BakeLightSimple extends BakeLight {\n\tget numVirtualLights() {\n\t\tif (this.light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\treturn this.light.bakeNumSamples;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tprepareVirtualLight(index, numVirtualLights) {\n\t\tconst light = this.light;\n\n\t\tlight._node.setLocalRotation(this.rotation);\n\n\t\tif (index > 0) {\n\t\t\tconst directionalSpreadAngle = light.bakeArea;\n\t\t\trandom.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);\n\n\t\t\t_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);\n\n\t\t\tlight._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);\n\t\t}\n\n\t\tlight._node.getWorldTransform();\n\n\t\tconst gamma = this.scene.gammaCorrection ? 2.2 : 1;\n\t\tconst linearIntensity = Math.pow(this.intensity, gamma);\n\t\tlight.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);\n\t}\n\n}\n\nclass AreaLightLuts {\n\tstatic createTexture(device, format, size) {\n\t\tconst tex = new Texture(device, {\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tformat: format,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tanisotropy: 1\n\t\t});\n\t\ttex.name = 'AreaLightLUT';\n\t\treturn tex;\n\t}\n\n\tstatic setUniforms(device, texture1, texture2) {\n\t\tdevice.scope.resolve('areaLightsLutTex1').setValue(texture1);\n\t\tdevice.scope.resolve('areaLightsLutTex2').setValue(texture2);\n\t}\n\n\tstatic createPlaceholder(device) {\n\t\tconst texture = AreaLightLuts.createTexture(device, PIXELFORMAT_R8_G8_B8_A8, 2);\n\t\tconst pixels = texture.lock();\n\t\tpixels.fill(0);\n\t\ttexture.unlock();\n\t\tAreaLightLuts.setUniforms(device, texture, texture);\n\t}\n\n\tstatic set(device, resource) {\n\t\tfunction buildTexture(device, data, format) {\n\t\t\tconst texture = AreaLightLuts.createTexture(device, format, 64);\n\t\t\ttexture.lock().set(data);\n\t\t\ttexture.unlock();\n\t\t\ttexture.upload();\n\t\t\treturn texture;\n\t\t}\n\n\t\tfunction offsetScale(data, offset, scale) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Float32Array(count);\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst n = i % 4;\n\t\t\t\tret[i] = (data[i] + offset[n]) * scale[n];\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tfunction convertToHalfFloat(data) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Uint16Array(count);\n\t\t\tconst float2Half = FloatPacking.float2Half;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tret[i] = float2Half(data[i]);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tfunction convertToUint(data) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Uint8ClampedArray(count);\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tret[i] = data[i] * 255;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tconst versions = new Int16Array(resource, 0, 2);\n\t\tconst majorVersion = versions[0];\n\t\tconst minorVersion = versions[1];\n\n\t\tif (majorVersion !== 0 || minorVersion !== 1) ; else {\n\t\t\tconst srcData1 = new Float32Array(resource, 4, 16384);\n\t\t\tconst srcData2 = new Float32Array(resource, 4 + 16384 * 4, 16384);\n\t\t\tlet data1, data2;\n\t\t\tconst format = device.areaLightLutFormat;\n\n\t\t\tif (format === PIXELFORMAT_RGBA32F) {\n\t\t\t\tdata1 = srcData1;\n\t\t\t\tdata2 = srcData2;\n\t\t\t} else if (format === PIXELFORMAT_RGBA16F) {\n\t\t\t\tdata1 = convertToHalfFloat(srcData1);\n\t\t\t\tdata2 = convertToHalfFloat(srcData2);\n\t\t\t} else {\n\t\t\t\tconst o1 = [0.0, 0.2976, 0.01381, 0.0];\n\t\t\t\tconst s1 = [0.999, 3.08737, 1.6546, 0.603249];\n\t\t\t\tconst o2 = [-0.306897, 0.0, 0.0, 0.0];\n\t\t\t\tconst s2 = [1.442787, 1.0, 1.0, 1.0];\n\t\t\t\tdata1 = convertToUint(offsetScale(srcData1, o1, s1));\n\t\t\t\tdata2 = convertToUint(offsetScale(srcData2, o2, s2));\n\t\t\t}\n\n\t\t\tconst tex1 = buildTexture(device, data1, format);\n\t\t\tconst tex2 = buildTexture(device, data2, format);\n\t\t\tAreaLightLuts.setUniforms(device, tex1, tex2);\n\t\t}\n\t}\n\n}\n\nlet nonUniformScale;\nlet uniformScale = 1;\nconst particleTexChannels$1 = 4;\nconst rotMat = new Mat4();\nconst rotMatInv = new Mat4();\nconst randomPosTformed = new Vec3();\nconst randomPos = new Vec3();\nconst rndFactor3Vec = new Vec3();\nconst particlePosPrev = new Vec3();\nconst velocityVec = new Vec3();\nconst localVelocityVec = new Vec3();\nconst velocityVec2 = new Vec3();\nconst localVelocityVec2 = new Vec3();\nconst radialVelocityVec = new Vec3();\nconst particlePos = new Vec3();\nconst particleFinalPos = new Vec3();\nconst moveDirVec = new Vec3();\nconst tmpVec3$1 = new Vec3();\n\nfunction frac(f) {\n\treturn f - Math.floor(f);\n}\n\nfunction saturate$1(x) {\n\treturn Math.max(Math.min(x, 1), 0);\n}\n\nfunction glMod(x, y) {\n\treturn x - y * Math.floor(x / y);\n}\n\nfunction encodeFloatRGBA(v) {\n\tlet encX = frac(v);\n\tlet encY = frac(255.0 * v);\n\tlet encZ = frac(65025.0 * v);\n\tlet encW = frac(160581375.0 * v);\n\tencX -= encY / 255.0;\n\tencY -= encZ / 255.0;\n\tencZ -= encW / 255.0;\n\tencW -= encW / 255.0;\n\treturn [encX, encY, encZ, encW];\n}\n\nfunction encodeFloatRG(v) {\n\tlet encX = frac(v);\n\tlet encY = frac(255.0 * v);\n\tencX -= encY / 255.0;\n\tencY -= encY / 255.0;\n\treturn [encX, encY];\n}\n\nclass ParticleCPUUpdater {\n\tconstructor(emitter) {\n\t\tthis._emitter = emitter;\n\t}\n\n\tcalcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {\n\t\tconst emitter = this._emitter;\n\t\tconst rX = Math.random();\n\t\tconst rY = Math.random();\n\t\tconst rZ = Math.random();\n\t\tconst rW = Math.random();\n\n\t\tif (emitter.useCpu) {\n\t\t\tparticleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;\n\t\t\tparticleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;\n\t\t\tparticleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;\n\t\t}\n\n\t\trandomPos.x = rX - 0.5;\n\t\trandomPos.y = rY - 0.5;\n\t\trandomPos.z = rZ - 0.5;\n\n\t\tif (emitter.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tconst max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));\n\t\t\tconst edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];\n\t\t\tconst edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];\n\t\t\tconst edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];\n\t\t\trandomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);\n\t\t\trandomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);\n\t\t\trandomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);\n\t\t\tif (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));else randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));\n\t\t} else {\n\t\t\trandomPos.normalize();\n\t\t\tconst spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;\n\t\t\tconst r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n\t\t\tif (!emitter.localSpace) randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));else randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));\n\t\t}\n\n\t\tconst particleRate = math.lerp(emitter.rate, emitter.rate2, rX);\n\t\tlet startSpawnTime = -particleRate * i;\n\n\t\tif (emitter.pack8) {\n\t\t\tconst packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;\n\t\t\tconst packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;\n\t\t\tconst packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;\n\t\t\tlet packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);\n\t\t\tpackA = packA % (Math.PI * 2) / (Math.PI * 2);\n\t\t\tconst rg0 = encodeFloatRG(packX);\n\t\t\tparticleTex[i * particleTexChannels$1] = rg0[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 1] = rg0[1];\n\t\t\tconst ba0 = encodeFloatRG(packY);\n\t\t\tparticleTex[i * particleTexChannels$1 + 2] = ba0[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 3] = ba0[1];\n\t\t\tconst rg1 = encodeFloatRG(packZ);\n\t\t\tparticleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];\n\t\t\tconst ba1 = encodeFloatRG(packA);\n\t\t\tparticleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];\n\t\t\tconst a2 = 1.0;\n\t\t\tparticleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;\n\t\t\tconst maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));\n\t\t\tconst maxPosLife = emitter.lifetime + 1.0;\n\t\t\tstartSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);\n\t\t\tconst rgba3 = encodeFloatRGBA(startSpawnTime);\n\t\t\tparticleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];\n\t\t\tparticleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];\n\t\t\tparticleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];\n\t\t\tparticleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];\n\t\t} else {\n\t\t\tparticleTex[i * particleTexChannels$1] = randomPosTformed.x;\n\t\t\tparticleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;\n\t\t\tparticleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;\n\t\t\tparticleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);\n\t\t\tparticleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;\n\t\t}\n\t}\n\n\tupdate(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {\n\t\tlet a, b, c;\n\t\tconst emitter = this._emitter;\n\n\t\tif (emitter.meshInstance.node) {\n\t\t\tconst fullMat = emitter.meshInstance.node.worldTransform;\n\n\t\t\tfor (let j = 0; j < 12; j++) {\n\t\t\t\trotMat.data[j] = fullMat.data[j];\n\t\t\t}\n\n\t\t\trotMatInv.copy(rotMat);\n\t\t\trotMatInv.invert();\n\t\t\tnonUniformScale = emitter.meshInstance.node.localScale;\n\t\t\tuniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);\n\t\t}\n\n\t\temitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();\n\t\tconst posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;\n\t\tconst vertSize = !emitter.useMesh ? 15 : 17;\n\t\tlet cf, cc;\n\t\tlet rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;\n\t\tconst precision1 = emitter.precision - 1;\n\n\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\tconst id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);\n\t\t\tconst rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];\n\t\t\trndFactor3Vec.x = rndFactor;\n\t\t\trndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];\n\t\t\trndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];\n\t\t\tconst particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;\n\t\t\tconst particleLifetime = emitter.lifetime;\n\t\t\tlet life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;\n\t\t\tconst nlife = saturate$1(life / particleLifetime);\n\t\t\tlet scale = 0;\n\t\t\tlet alphaDiv = 0;\n\t\t\tconst angle = 0;\n\t\t\tconst respawn = life - delta <= 0.0 || life >= particleLifetime;\n\n\t\t\tif (respawn) {\n\t\t\t\tthis.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);\n\t\t\t}\n\n\t\t\tlet particleEnabled = life > 0.0 && life < particleLifetime;\n\n\t\t\tif (particleEnabled) {\n\t\t\t\tc = nlife * precision1;\n\t\t\t\tcf = Math.floor(c);\n\t\t\t\tcc = Math.ceil(c);\n\t\t\t\tc %= 1;\n\t\t\t\ta = emitter.qRotSpeed[cf];\n\t\t\t\tb = emitter.qRotSpeed[cc];\n\t\t\t\trotSpeed = a + (b - a) * c;\n\t\t\t\ta = emitter.qRotSpeed2[cf];\n\t\t\t\tb = emitter.qRotSpeed2[cc];\n\t\t\t\trotSpeed2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qScale[cf];\n\t\t\t\tb = emitter.qScale[cc];\n\t\t\t\tscale = a + (b - a) * c;\n\t\t\t\ta = emitter.qScale2[cf];\n\t\t\t\tb = emitter.qScale2[cc];\n\t\t\t\tscale2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qAlpha[cf];\n\t\t\t\tb = emitter.qAlpha[cc];\n\t\t\t\talpha = a + (b - a) * c;\n\t\t\t\ta = emitter.qAlpha2[cf];\n\t\t\t\tb = emitter.qAlpha2[cc];\n\t\t\t\talpha2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qRadialSpeed[cf];\n\t\t\t\tb = emitter.qRadialSpeed[cc];\n\t\t\t\tradialSpeed = a + (b - a) * c;\n\t\t\t\ta = emitter.qRadialSpeed2[cf];\n\t\t\t\tb = emitter.qRadialSpeed2[cc];\n\t\t\t\tradialSpeed2 = a + (b - a) * c;\n\t\t\t\tradialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);\n\t\t\t\tparticlePosPrev.x = particleTex[id * particleTexChannels$1];\n\t\t\t\tparticlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];\n\t\t\t\tparticlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];\n\t\t\t\tif (!emitter.localSpace) radialVelocityVec.copy(particlePosPrev).sub(emitterPos);else radialVelocityVec.copy(particlePosPrev);\n\t\t\t\tradialVelocityVec.normalize().mulScalar(radialSpeed);\n\t\t\t\tcf *= 3;\n\t\t\t\tcc *= 3;\n\t\t\t\ta = emitter.qLocalVelocity[cf];\n\t\t\t\tb = emitter.qLocalVelocity[cc];\n\t\t\t\tlocalVelocityVec.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity[cf + 1];\n\t\t\t\tb = emitter.qLocalVelocity[cc + 1];\n\t\t\t\tlocalVelocityVec.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity[cf + 2];\n\t\t\t\tb = emitter.qLocalVelocity[cc + 2];\n\t\t\t\tlocalVelocityVec.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf];\n\t\t\t\tb = emitter.qLocalVelocity2[cc];\n\t\t\t\tlocalVelocityVec2.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf + 1];\n\t\t\t\tb = emitter.qLocalVelocity2[cc + 1];\n\t\t\t\tlocalVelocityVec2.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf + 2];\n\t\t\t\tb = emitter.qLocalVelocity2[cc + 2];\n\t\t\t\tlocalVelocityVec2.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf];\n\t\t\t\tb = emitter.qVelocity[cc];\n\t\t\t\tvelocityVec.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf + 1];\n\t\t\t\tb = emitter.qVelocity[cc + 1];\n\t\t\t\tvelocityVec.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf + 2];\n\t\t\t\tb = emitter.qVelocity[cc + 2];\n\t\t\t\tvelocityVec.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf];\n\t\t\t\tb = emitter.qVelocity2[cc];\n\t\t\t\tvelocityVec2.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf + 1];\n\t\t\t\tb = emitter.qVelocity2[cc + 1];\n\t\t\t\tvelocityVec2.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf + 2];\n\t\t\t\tb = emitter.qVelocity2[cc + 2];\n\t\t\t\tvelocityVec2.z = a + (b - a) * c;\n\t\t\t\tlocalVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;\n\t\t\t\tlocalVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;\n\t\t\t\tlocalVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;\n\n\t\t\t\tif (emitter.initialVelocity > 0) {\n\t\t\t\t\tif (emitter.emitterShape === EMITTERSHAPE_SPHERE) {\n\t\t\t\t\t\trandomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();\n\t\t\t\t\t\tlocalVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocalVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvelocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;\n\t\t\t\tvelocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;\n\t\t\t\tvelocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;\n\t\t\t\trotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;\n\t\t\t\tscale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;\n\t\t\t\talphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);\n\n\t\t\t\tif (emitter.meshInstance.node) {\n\t\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\t\trotMat.transformPoint(localVelocityVec, localVelocityVec);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocalVelocityVec.x /= nonUniformScale.x;\n\t\t\t\t\t\tlocalVelocityVec.y /= nonUniformScale.y;\n\t\t\t\t\t\tlocalVelocityVec.z /= nonUniformScale.z;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\tlocalVelocityVec.add(velocityVec.mul(nonUniformScale));\n\t\t\t\t\tlocalVelocityVec.add(radialVelocityVec.mul(nonUniformScale));\n\t\t\t\t} else {\n\t\t\t\t\trotMatInv.transformPoint(velocityVec, velocityVec);\n\t\t\t\t\tlocalVelocityVec.add(velocityVec).add(radialVelocityVec);\n\t\t\t\t}\n\n\t\t\t\tmoveDirVec.copy(localVelocityVec);\n\t\t\t\tparticlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));\n\t\t\t\tparticleFinalPos.copy(particlePos);\n\t\t\t\tparticleTex[id * particleTexChannels$1] = particleFinalPos.x;\n\t\t\t\tparticleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;\n\t\t\t\tparticleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;\n\t\t\t\tparticleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;\n\n\t\t\t\tif (emitter.wrap && emitter.wrapBounds) {\n\t\t\t\t\tif (!emitter.localSpace) particleFinalPos.sub(emitterPos);\n\t\t\t\t\tparticleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;\n\t\t\t\t\tparticleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;\n\t\t\t\t\tparticleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;\n\t\t\t\t\tif (!emitter.localSpace) particleFinalPos.add(emitterPos);\n\t\t\t\t}\n\n\t\t\t\tif (emitter.sort > 0) {\n\t\t\t\t\tif (emitter.sort === 1) {\n\t\t\t\t\t\ttmpVec3$1.copy(particleFinalPos).sub(posCam);\n\t\t\t\t\t\temitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);\n\t\t\t\t\t} else if (emitter.sort === 2) {\n\t\t\t\t\t\temitter.particleDistance[id] = life;\n\t\t\t\t\t} else if (emitter.sort === 3) {\n\t\t\t\t\t\temitter.particleDistance[id] = -life;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isOnStop) {\n\t\t\t\tif (life < 0) {\n\t\t\t\t\tparticleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (life >= particleLifetime) {\n\t\t\t\t\tlife -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);\n\t\t\t\t\tparticleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;\n\t\t\t\t}\n\n\t\t\t\tif (life < 0 && emitter.loop) {\n\t\t\t\t\tparticleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) particleEnabled = false;\n\t\t\tparticleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;\n\n\t\t\tfor (let v = 0; v < emitter.numParticleVerts; v++) {\n\t\t\t\tconst vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);\n\t\t\t\tlet quadX = emitter.vbCPU[vbOffset];\n\t\t\t\tlet quadY = emitter.vbCPU[vbOffset + 1];\n\t\t\t\tlet quadZ = emitter.vbCPU[vbOffset + 2];\n\n\t\t\t\tif (!particleEnabled) {\n\t\t\t\t\tquadX = quadY = quadZ = 0;\n\t\t\t\t}\n\n\t\t\t\tconst w = i * emitter.numParticleVerts * vertSize + v * vertSize;\n\t\t\t\tdata[w] = particleFinalPos.x;\n\t\t\t\tdata[w + 1] = particleFinalPos.y;\n\t\t\t\tdata[w + 2] = particleFinalPos.z;\n\t\t\t\tdata[w + 3] = nlife;\n\t\t\t\tdata[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];\n\t\t\t\tdata[w + 5] = scale;\n\t\t\t\tdata[w + 6] = alphaDiv;\n\t\t\t\tdata[w + 7] = moveDirVec.x;\n\t\t\t\tdata[w + 8] = quadX;\n\t\t\t\tdata[w + 9] = quadY;\n\t\t\t\tdata[w + 10] = quadZ;\n\t\t\t\tdata[w + 11] = moveDirVec.y;\n\t\t\t\tdata[w + 12] = id;\n\t\t\t\tdata[w + 13] = moveDirVec.z;\n\t\t\t\tdata[w + 14] = emitter.vbCPU[vbOffset + 3];\n\n\t\t\t\tif (emitter.useMesh) {\n\t\t\t\t\tdata[w + 15] = emitter.vbCPU[vbOffset + 4];\n\t\t\t\t\tdata[w + 16] = emitter.vbCPU[vbOffset + 5];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (emitter.sort > PARTICLESORT_NONE && emitter.camera) {\n\t\t\tconst vbStride = emitter.useMesh ? 6 : 4;\n\t\t\tconst particleDistance = emitter.particleDistance;\n\n\t\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\t\tvbToSort[i][0] = i;\n\t\t\t\tvbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])];\n\t\t\t}\n\n\t\t\temitter.vbOld.set(emitter.vbCPU);\n\t\t\tvbToSort.sort(function (p1, p2) {\n\t\t\t\treturn p1[1] - p2[1];\n\t\t\t});\n\n\t\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\t\tconst src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;\n\t\t\t\tconst dest = i * emitter.numParticleVerts * vbStride;\n\n\t\t\t\tfor (let j = 0; j < emitter.numParticleVerts * vbStride; j++) {\n\t\t\t\t\temitter.vbCPU[dest + j] = emitter.vbOld[src + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nconst spawnMatrix3 = new Mat3();\nconst emitterMatrix3 = new Mat3();\nconst emitterMatrix3Inv = new Mat3();\n\nclass ParticleGPUUpdater {\n\tconstructor(emitter, gd) {\n\t\tthis._emitter = emitter;\n\t\tthis.frameRandomUniform = new Float32Array(3);\n\t\tthis.emitterPosUniform = new Float32Array(3);\n\t\tthis.emitterScaleUniform = new Float32Array([1, 1, 1]);\n\t\tthis.worldBoundsMulUniform = new Float32Array(3);\n\t\tthis.worldBoundsAddUniform = new Float32Array(3);\n\t\tthis.inBoundsSizeUniform = new Float32Array(3);\n\t\tthis.inBoundsCenterUniform = new Float32Array(3);\n\t\tthis.constantParticleTexIN = gd.scope.resolve(\"particleTexIN\");\n\t\tthis.constantParticleTexOUT = gd.scope.resolve(\"particleTexOUT\");\n\t\tthis.constantEmitterPos = gd.scope.resolve(\"emitterPos\");\n\t\tthis.constantEmitterScale = gd.scope.resolve(\"emitterScale\");\n\t\tthis.constantSpawnBounds = gd.scope.resolve(\"spawnBounds\");\n\t\tthis.constantSpawnPosInnerRatio = gd.scope.resolve(\"spawnPosInnerRatio\");\n\t\tthis.constantSpawnBoundsSphere = gd.scope.resolve(\"spawnBoundsSphere\");\n\t\tthis.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve(\"spawnBoundsSphereInnerRatio\");\n\t\tthis.constantInitialVelocity = gd.scope.resolve(\"initialVelocity\");\n\t\tthis.constantFrameRandom = gd.scope.resolve(\"frameRandom\");\n\t\tthis.constantDelta = gd.scope.resolve(\"delta\");\n\t\tthis.constantRate = gd.scope.resolve(\"rate\");\n\t\tthis.constantRateDiv = gd.scope.resolve(\"rateDiv\");\n\t\tthis.constantLifetime = gd.scope.resolve(\"lifetime\");\n\t\tthis.constantGraphSampleSize = gd.scope.resolve(\"graphSampleSize\");\n\t\tthis.constantGraphNumSamples = gd.scope.resolve(\"graphNumSamples\");\n\t\tthis.constantInternalTex0 = gd.scope.resolve(\"internalTex0\");\n\t\tthis.constantInternalTex1 = gd.scope.resolve(\"internalTex1\");\n\t\tthis.constantInternalTex2 = gd.scope.resolve(\"internalTex2\");\n\t\tthis.constantInternalTex3 = gd.scope.resolve(\"internalTex3\");\n\t\tthis.constantEmitterMatrix = gd.scope.resolve(\"emitterMatrix\");\n\t\tthis.constantEmitterMatrixInv = gd.scope.resolve(\"emitterMatrixInv\");\n\t\tthis.constantNumParticles = gd.scope.resolve(\"numParticles\");\n\t\tthis.constantNumParticlesPot = gd.scope.resolve(\"numParticlesPot\");\n\t\tthis.constantLocalVelocityDivMult = gd.scope.resolve(\"localVelocityDivMult\");\n\t\tthis.constantVelocityDivMult = gd.scope.resolve(\"velocityDivMult\");\n\t\tthis.constantRotSpeedDivMult = gd.scope.resolve(\"rotSpeedDivMult\");\n\t\tthis.constantSeed = gd.scope.resolve(\"seed\");\n\t\tthis.constantStartAngle = gd.scope.resolve(\"startAngle\");\n\t\tthis.constantStartAngle2 = gd.scope.resolve(\"startAngle2\");\n\t\tthis.constantOutBoundsMul = gd.scope.resolve(\"outBoundsMul\");\n\t\tthis.constantOutBoundsAdd = gd.scope.resolve(\"outBoundsAdd\");\n\t\tthis.constantInBoundsSize = gd.scope.resolve(\"inBoundsSize\");\n\t\tthis.constantInBoundsCenter = gd.scope.resolve(\"inBoundsCenter\");\n\t\tthis.constantMaxVel = gd.scope.resolve(\"maxVel\");\n\t\tthis.constantFaceTangent = gd.scope.resolve(\"faceTangent\");\n\t\tthis.constantFaceBinorm = gd.scope.resolve(\"faceBinorm\");\n\t}\n\n\t_setInputBounds() {\n\t\tthis.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;\n\t\tthis.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;\n\t\tthis.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;\n\t\tthis.constantInBoundsSize.setValue(this.inBoundsSizeUniform);\n\t\tthis.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;\n\t\tthis.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;\n\t\tthis.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;\n\t\tthis.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);\n\t}\n\n\trandomize() {\n\t\tthis.frameRandomUniform[0] = Math.random();\n\t\tthis.frameRandomUniform[1] = Math.random();\n\t\tthis.frameRandomUniform[2] = Math.random();\n\t}\n\n\tupdate(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {\n\t\tconst emitter = this._emitter;\n\t\tdevice.setBlending(false);\n\t\tdevice.setColorWrite(true, true, true, true);\n\t\tdevice.setCullMode(CULLFACE_NONE);\n\t\tdevice.setDepthTest(false);\n\t\tdevice.setDepthWrite(false);\n\t\tthis.randomize();\n\t\tthis.constantGraphSampleSize.setValue(1.0 / emitter.precision);\n\t\tthis.constantGraphNumSamples.setValue(emitter.precision);\n\t\tthis.constantNumParticles.setValue(emitter.numParticles);\n\t\tthis.constantNumParticlesPot.setValue(emitter.numParticlesPot);\n\t\tthis.constantInternalTex0.setValue(emitter.internalTex0);\n\t\tthis.constantInternalTex1.setValue(emitter.internalTex1);\n\t\tthis.constantInternalTex2.setValue(emitter.internalTex2);\n\t\tthis.constantInternalTex3.setValue(emitter.internalTex3);\n\t\tconst node = emitter.meshInstance.node;\n\t\tconst emitterScale = node === null ? Vec3.ONE : node.localScale;\n\n\t\tif (emitter.pack8) {\n\t\t\tthis.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;\n\t\t\tthis.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;\n\t\t\tthis.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;\n\t\t\tthis.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);\n\t\t\tthis.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;\n\t\t\tthis.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;\n\t\t\tthis.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;\n\t\t\tthis.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);\n\n\t\t\tthis._setInputBounds();\n\n\t\t\tlet maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);\n\t\t\tmaxVel = Math.max(maxVel, 1);\n\t\t\tthis.constantMaxVel.setValue(maxVel);\n\t\t}\n\n\t\tconst emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();\n\t\tconst emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();\n\n\t\tif (emitter.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tspawnMatrix3.setFromMat4(spawnMatrix);\n\t\t\tthis.constantSpawnBounds.setValue(spawnMatrix3.data);\n\t\t\tthis.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);\n\t\t} else {\n\t\t\tthis.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);\n\t\t\tthis.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);\n\t\t}\n\n\t\tthis.constantInitialVelocity.setValue(emitter.initialVelocity);\n\t\temitterMatrix3.setFromMat4(emitterMatrix);\n\t\temitterMatrix.invertTo3x3(emitterMatrix3Inv);\n\t\tthis.emitterPosUniform[0] = emitterPos.x;\n\t\tthis.emitterPosUniform[1] = emitterPos.y;\n\t\tthis.emitterPosUniform[2] = emitterPos.z;\n\t\tthis.constantEmitterPos.setValue(this.emitterPosUniform);\n\t\tthis.constantFrameRandom.setValue(this.frameRandomUniform);\n\t\tthis.constantDelta.setValue(delta);\n\t\tthis.constantRate.setValue(emitter.rate);\n\t\tthis.constantRateDiv.setValue(emitter.rate2 - emitter.rate);\n\t\tthis.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);\n\t\tthis.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);\n\t\tthis.constantSeed.setValue(emitter.seed);\n\t\tthis.constantLifetime.setValue(emitter.lifetime);\n\t\tthis.emitterScaleUniform[0] = emitterScale.x;\n\t\tthis.emitterScaleUniform[1] = emitterScale.y;\n\t\tthis.emitterScaleUniform[2] = emitterScale.z;\n\t\tthis.constantEmitterScale.setValue(this.emitterScaleUniform);\n\t\tthis.constantEmitterMatrix.setValue(emitterMatrix3.data);\n\t\tthis.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);\n\t\tthis.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);\n\t\tthis.constantVelocityDivMult.setValue(emitter.velocityUMax);\n\t\tthis.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);\n\t\tlet texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;\n\t\ttexIN = emitter.beenReset ? emitter.particleTexStart : texIN;\n\t\tconst texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;\n\t\tthis.constantParticleTexIN.setValue(texIN);\n\t\tdrawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);\n\t\temitter.material.setParameter(\"particleTexOUT\", texIN);\n\t\temitter.material.setParameter(\"particleTexIN\", texOUT);\n\t\temitter.beenReset = false;\n\t\temitter.swapTex = !emitter.swapTex;\n\t\tdevice.setDepthTest(true);\n\t\tdevice.setDepthWrite(true);\n\t\temitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);\n\t\temitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);\n\t\tif (emitter.pack8) this._setInputBounds();\n\t}\n\n}\n\nconst particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];\n\nfunction _createTexture(device, width, height, pixelData, format = PIXELFORMAT_RGBA32F, mult8Bit, filter) {\n\tlet mipFilter = FILTER_NEAREST;\n\tif (filter && format === PIXELFORMAT_R8_G8_B8_A8) mipFilter = FILTER_LINEAR;\n\tconst texture = new Texture(device, {\n\t\twidth: width,\n\t\theight: height,\n\t\tformat: format,\n\t\tcubemap: false,\n\t\tmipmaps: false,\n\t\tminFilter: mipFilter,\n\t\tmagFilter: mipFilter,\n\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t});\n\ttexture.name = \"PSTexture\";\n\tconst pixels = texture.lock();\n\n\tif (format === PIXELFORMAT_R8_G8_B8_A8) {\n\t\tconst temp = new Uint8Array(pixelData.length);\n\n\t\tfor (let i = 0; i < pixelData.length; i++) {\n\t\t\ttemp[i] = pixelData[i] * mult8Bit * 255;\n\t\t}\n\n\t\tpixelData = temp;\n\t}\n\n\tpixels.set(pixelData);\n\ttexture.unlock();\n\treturn texture;\n}\n\nfunction saturate(x) {\n\treturn Math.max(Math.min(x, 1), 0);\n}\n\nconst default0Curve = new Curve([0, 0, 1, 0]);\nconst default1Curve = new Curve([0, 1, 1, 1]);\nconst default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);\nconst default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);\nlet particleTexHeight = 2;\nconst particleTexChannels = 4;\nconst extentsInnerRatioUniform = new Float32Array(3);\nconst spawnMatrix = new Mat4();\nconst tmpVec3 = new Vec3();\nconst bMin = new Vec3();\nconst bMax = new Vec3();\nlet setPropertyTarget;\nlet setPropertyOptions;\n\nfunction setProperty(pName, defaultVal) {\n\tif (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {\n\t\tsetPropertyTarget[pName] = setPropertyOptions[pName];\n\t} else {\n\t\tsetPropertyTarget[pName] = defaultVal;\n\t}\n}\n\nfunction pack3NFloats(a, b, c) {\n\tconst packed = a * 255 << 16 | b * 255 << 8 | c * 255;\n\treturn packed / (1 << 24);\n}\n\nfunction packTextureXYZ_NXYZ(qXYZ, qXYZ2) {\n\tconst num = qXYZ.length / 3;\n\tconst colors = new Array(num * 4);\n\n\tfor (let i = 0; i < num; i++) {\n\t\tcolors[i * 4] = qXYZ[i * 3];\n\t\tcolors[i * 4 + 1] = qXYZ[i * 3 + 1];\n\t\tcolors[i * 4 + 2] = qXYZ[i * 3 + 2];\n\t\tcolors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);\n\t}\n\n\treturn colors;\n}\n\nfunction packTextureRGBA(qRGB, qA) {\n\tconst colors = new Array(qA.length * 4);\n\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qRGB[i * 3];\n\t\tcolors[i * 4 + 1] = qRGB[i * 3 + 1];\n\t\tcolors[i * 4 + 2] = qRGB[i * 3 + 2];\n\t\tcolors[i * 4 + 3] = qA[i];\n\t}\n\n\treturn colors;\n}\n\nfunction packTexture5Floats(qA, qB, qC, qD, qE) {\n\tconst colors = new Array(qA.length * 4);\n\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qA[i];\n\t\tcolors[i * 4 + 1] = qB[i];\n\t\tcolors[i * 4 + 2] = 0;\n\t\tcolors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);\n\t}\n\n\treturn colors;\n}\n\nfunction packTexture2Floats(qA, qB) {\n\tconst colors = new Array(qA.length * 4);\n\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qA[i];\n\t\tcolors[i * 4 + 1] = qB[i];\n\t\tcolors[i * 4 + 2] = 0;\n\t\tcolors[i * 4 + 3] = 0;\n\t}\n\n\treturn colors;\n}\n\nfunction calcEndTime(emitter) {\n\tconst interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;\n\treturn Date.now() + interval * 1000;\n}\n\nfunction subGraph(A, B) {\n\tconst r = new Float32Array(A.length);\n\n\tfor (let i = 0; i < A.length; i++) {\n\t\tr[i] = A[i] - B[i];\n\t}\n\n\treturn r;\n}\n\nfunction maxUnsignedGraphValue(A, outUMax) {\n\tconst chans = outUMax.length;\n\tconst values = A.length / chans;\n\n\tfor (let i = 0; i < values; i++) {\n\t\tfor (let j = 0; j < chans; j++) {\n\t\t\tconst a = Math.abs(A[i * chans + j]);\n\t\t\toutUMax[j] = Math.max(outUMax[j], a);\n\t\t}\n\t}\n}\n\nfunction normalizeGraph(A, uMax) {\n\tconst chans = uMax.length;\n\tconst values = A.length / chans;\n\n\tfor (let i = 0; i < values; i++) {\n\t\tfor (let j = 0; j < chans; j++) {\n\t\t\tA[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];\n\t\t\tA[i * chans + j] *= 0.5;\n\t\t\tA[i * chans + j] += 0.5;\n\t\t}\n\t}\n}\n\nfunction divGraphFrom2Curves(curve1, curve2, outUMax) {\n\tconst sub = subGraph(curve2, curve1);\n\tmaxUnsignedGraphValue(sub, outUMax);\n\tnormalizeGraph(sub, outUMax);\n\treturn sub;\n}\n\nclass ParticleEmitter {\n\tconstructor(graphicsDevice, options) {\n\t\tthis.graphicsDevice = graphicsDevice;\n\t\tconst gd = graphicsDevice;\n\t\tconst precision = 32;\n\t\tthis.precision = precision;\n\t\tthis._addTimeTime = 0;\n\t\tParticleEmitter.staticInit(gd);\n\t\tsetPropertyTarget = this;\n\t\tsetPropertyOptions = options;\n\t\tsetProperty(\"numParticles\", 1);\n\n\t\tif (this.numParticles > graphicsDevice.maxTextureSize) {\n\t\t\tthis.numParticles = graphicsDevice.maxTextureSize;\n\t\t}\n\n\t\tsetProperty(\"rate\", 1);\n\t\tsetProperty(\"rate2\", this.rate);\n\t\tsetProperty(\"lifetime\", 50);\n\t\tsetProperty(\"emitterExtents\", new Vec3(0, 0, 0));\n\t\tsetProperty(\"emitterExtentsInner\", new Vec3(0, 0, 0));\n\t\tsetProperty(\"emitterRadius\", 0);\n\t\tsetProperty(\"emitterRadiusInner\", 0);\n\t\tsetProperty(\"emitterShape\", EMITTERSHAPE_BOX);\n\t\tsetProperty(\"initialVelocity\", 1);\n\t\tsetProperty(\"wrap\", false);\n\t\tsetProperty(\"localSpace\", false);\n\t\tsetProperty(\"screenSpace\", false);\n\t\tsetProperty(\"wrapBounds\", null);\n\t\tsetProperty(\"colorMap\", ParticleEmitter.DEFAULT_PARAM_TEXTURE);\n\t\tsetProperty(\"normalMap\", null);\n\t\tsetProperty(\"loop\", true);\n\t\tsetProperty(\"preWarm\", false);\n\t\tsetProperty(\"sort\", PARTICLESORT_NONE);\n\t\tsetProperty(\"mode\", PARTICLEMODE_GPU);\n\t\tsetProperty(\"scene\", null);\n\t\tsetProperty(\"lighting\", false);\n\t\tsetProperty(\"halfLambert\", false);\n\t\tsetProperty(\"intensity\", 1.0);\n\t\tsetProperty(\"stretch\", 0.0);\n\t\tsetProperty(\"alignToMotion\", false);\n\t\tsetProperty(\"depthSoftening\", 0);\n\t\tsetProperty(\"mesh\", null);\n\t\tsetProperty(\"particleNormal\", new Vec3(0, 1, 0));\n\t\tsetProperty(\"orientation\", PARTICLEORIENTATION_SCREEN);\n\t\tsetProperty(\"depthWrite\", false);\n\t\tsetProperty(\"noFog\", false);\n\t\tsetProperty(\"blendType\", BLEND_NORMAL);\n\t\tsetProperty(\"node\", null);\n\t\tsetProperty(\"startAngle\", 0);\n\t\tsetProperty(\"startAngle2\", this.startAngle);\n\t\tsetProperty(\"animTilesX\", 1);\n\t\tsetProperty(\"animTilesY\", 1);\n\t\tsetProperty(\"animStartFrame\", 0);\n\t\tsetProperty(\"animNumFrames\", 1);\n\t\tsetProperty(\"animNumAnimations\", 1);\n\t\tsetProperty(\"animIndex\", 0);\n\t\tsetProperty(\"randomizeAnimIndex\", false);\n\t\tsetProperty(\"animSpeed\", 1);\n\t\tsetProperty(\"animLoop\", true);\n\t\tthis._gpuUpdater = new ParticleGPUUpdater(this, gd);\n\t\tthis._cpuUpdater = new ParticleCPUUpdater(this);\n\t\tthis.constantLightCube = gd.scope.resolve(\"lightCube[0]\");\n\t\tthis.emitterPosUniform = new Float32Array(3);\n\t\tthis.wrapBoundsUniform = new Float32Array(3);\n\t\tthis.emitterScaleUniform = new Float32Array([1, 1, 1]);\n\t\tsetProperty(\"colorGraph\", default1Curve3);\n\t\tsetProperty(\"colorGraph2\", this.colorGraph);\n\t\tsetProperty(\"scaleGraph\", default1Curve);\n\t\tsetProperty(\"scaleGraph2\", this.scaleGraph);\n\t\tsetProperty(\"alphaGraph\", default1Curve);\n\t\tsetProperty(\"alphaGraph2\", this.alphaGraph);\n\t\tsetProperty(\"localVelocityGraph\", default0Curve3);\n\t\tsetProperty(\"localVelocityGraph2\", this.localVelocityGraph);\n\t\tsetProperty(\"velocityGraph\", default0Curve3);\n\t\tsetProperty(\"velocityGraph2\", this.velocityGraph);\n\t\tsetProperty(\"rotationSpeedGraph\", default0Curve);\n\t\tsetProperty(\"rotationSpeedGraph2\", this.rotationSpeedGraph);\n\t\tsetProperty(\"radialSpeedGraph\", default0Curve);\n\t\tsetProperty(\"radialSpeedGraph2\", this.radialSpeedGraph);\n\t\tthis.lightCube = new Float32Array(6 * 3);\n\t\tthis.lightCubeDir = new Array(6);\n\t\tthis.lightCubeDir[0] = new Vec3(-1, 0, 0);\n\t\tthis.lightCubeDir[1] = new Vec3(1, 0, 0);\n\t\tthis.lightCubeDir[2] = new Vec3(0, -1, 0);\n\t\tthis.lightCubeDir[3] = new Vec3(0, 1, 0);\n\t\tthis.lightCubeDir[4] = new Vec3(0, 0, -1);\n\t\tthis.lightCubeDir[5] = new Vec3(0, 0, 1);\n\t\tthis.animTilesParams = new Float32Array(2);\n\t\tthis.animParams = new Float32Array(4);\n\t\tthis.animIndexParams = new Float32Array(2);\n\t\tthis.internalTex0 = null;\n\t\tthis.internalTex1 = null;\n\t\tthis.internalTex2 = null;\n\t\tthis.colorParam = null;\n\t\tthis.vbToSort = null;\n\t\tthis.vbOld = null;\n\t\tthis.particleDistance = null;\n\t\tthis.camera = null;\n\t\tthis.swapTex = false;\n\t\tthis.useMesh = true;\n\t\tthis.useCpu = false;\n\t\tthis.pack8 = true;\n\t\tthis.localBounds = new BoundingBox();\n\t\tthis.worldBoundsNoTrail = new BoundingBox();\n\t\tthis.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];\n\t\tthis.worldBounds = new BoundingBox();\n\t\tthis.worldBoundsSize = new Vec3();\n\t\tthis.prevWorldBoundsSize = new Vec3();\n\t\tthis.prevWorldBoundsCenter = new Vec3();\n\t\tthis.prevEmitterExtents = this.emitterExtents;\n\t\tthis.prevEmitterRadius = this.emitterRadius;\n\t\tthis.worldBoundsMul = new Vec3();\n\t\tthis.worldBoundsAdd = new Vec3();\n\t\tthis.timeToSwitchBounds = 0;\n\t\tthis.shaderParticleUpdateRespawn = null;\n\t\tthis.shaderParticleUpdateNoRespawn = null;\n\t\tthis.shaderParticleUpdateOnStop = null;\n\t\tthis.numParticleVerts = 0;\n\t\tthis.numParticleIndices = 0;\n\t\tthis.material = null;\n\t\tthis.meshInstance = null;\n\t\tthis.drawOrder = 0;\n\t\tthis.seed = Math.random();\n\t\tthis.fixedTimeStep = 1.0 / 60;\n\t\tthis.maxSubSteps = 10;\n\t\tthis.simTime = 0;\n\t\tthis.simTimeTotal = 0;\n\t\tthis.beenReset = false;\n\t\tthis._layer = null;\n\t\tthis.rebuild();\n\t}\n\n\tstatic staticInit(device) {\n\t\tif (!ParticleEmitter.DEFAULT_PARAM_TEXTURE) {\n\t\t\tconst resolution = 16;\n\t\t\tconst centerPoint = resolution * 0.5 + 0.5;\n\t\t\tconst dtex = new Float32Array(resolution * resolution * 4);\n\n\t\t\tfor (let y = 0; y < resolution; y++) {\n\t\t\t\tfor (let x = 0; x < resolution; x++) {\n\t\t\t\t\tconst xgrad = x + 1 - centerPoint;\n\t\t\t\t\tconst ygrad = y + 1 - centerPoint;\n\t\t\t\t\tconst c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);\n\t\t\t\t\tconst p = y * resolution + x;\n\t\t\t\t\tdtex[p * 4] = 1;\n\t\t\t\t\tdtex[p * 4 + 1] = 1;\n\t\t\t\t\tdtex[p * 4 + 2] = 1;\n\t\t\t\t\tdtex[p * 4 + 3] = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE = _createTexture(device, resolution, resolution, dtex, PIXELFORMAT_R8_G8_B8_A8, 1.0, true);\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE.minFilter = FILTER_LINEAR;\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE.magFilter = FILTER_LINEAR;\n\t\t}\n\t}\n\n\tstatic staticDestroy() {\n\t\tif (ParticleEmitter.DEFAULT_PARAM_TEXTURE) {\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE.destroy();\n\t\t\tParticleEmitter.DEFAULT_PARAM_TEXTURE = null;\n\t\t}\n\t}\n\n\tonChangeCamera() {\n\t\tthis.regenShader();\n\t\tthis.resetMaterial();\n\t}\n\n\tcalculateBoundsMad() {\n\t\tthis.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;\n\t\tthis.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;\n\t\tthis.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;\n\t\tthis.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);\n\t\tthis.worldBoundsAdd.x += 0.5;\n\t\tthis.worldBoundsAdd.y += 0.5;\n\t\tthis.worldBoundsAdd.z += 0.5;\n\t}\n\n\tcalculateWorldBounds() {\n\t\tif (!this.node) return;\n\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\n\t\tif (!this.useCpu) {\n\t\t\tlet recalculateLocalBounds = false;\n\n\t\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\t\trecalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);\n\t\t\t} else {\n\t\t\t\trecalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);\n\t\t\t}\n\n\t\t\tif (recalculateLocalBounds) {\n\t\t\t\tthis.calculateLocalBounds();\n\t\t\t}\n\t\t}\n\n\t\tconst nodeWT = this.node.getWorldTransform();\n\n\t\tif (this.localSpace) {\n\t\t\tthis.worldBoundsNoTrail.copy(this.localBounds);\n\t\t} else {\n\t\t\tthis.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);\n\t\t}\n\n\t\tthis.worldBoundsTrail[0].add(this.worldBoundsNoTrail);\n\t\tthis.worldBoundsTrail[1].add(this.worldBoundsNoTrail);\n\t\tconst now = this.simTimeTotal;\n\n\t\tif (now >= this.timeToSwitchBounds) {\n\t\t\tthis.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);\n\t\t\tthis.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);\n\t\t\tthis.timeToSwitchBounds = now + this.lifetime;\n\t\t}\n\n\t\tthis.worldBounds.copy(this.worldBoundsTrail[0]);\n\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\n\t\tif (this.localSpace) {\n\t\t\tthis.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);\n\t\t\tthis.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);\n\t\t} else {\n\t\t\tthis.meshInstance.aabb.copy(this.worldBounds);\n\t\t\tthis.meshInstance.mesh.aabb.copy(this.worldBounds);\n\t\t}\n\n\t\tthis.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;\n\t\tif (this.pack8) this.calculateBoundsMad();\n\t}\n\n\tresetWorldBounds() {\n\t\tif (!this.node) return;\n\t\tthis.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());\n\t\tthis.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);\n\t\tthis.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);\n\t\tthis.worldBounds.copy(this.worldBoundsTrail[0]);\n\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\t\tthis.simTimeTotal = 0;\n\t\tthis.timeToSwitchBounds = 0;\n\t}\n\n\tcalculateLocalBounds() {\n\t\tlet minx = Number.MAX_VALUE;\n\t\tlet miny = Number.MAX_VALUE;\n\t\tlet minz = Number.MAX_VALUE;\n\t\tlet maxx = -Number.MAX_VALUE;\n\t\tlet maxy = -Number.MAX_VALUE;\n\t\tlet maxz = -Number.MAX_VALUE;\n\t\tlet maxR = 0;\n\t\tlet maxScale = 0;\n\t\tconst stepWeight = this.lifetime / this.precision;\n\t\tconst wVels = [this.qVelocity, this.qVelocity2];\n\t\tconst lVels = [this.qLocalVelocity, this.qLocalVelocity2];\n\t\tconst accumX = [0, 0];\n\t\tconst accumY = [0, 0];\n\t\tconst accumZ = [0, 0];\n\t\tconst accumR = [0, 0];\n\t\tconst accumW = [0, 0];\n\t\tlet x, y, z;\n\n\t\tfor (let i = 0; i < this.precision + 1; i++) {\n\t\t\tconst index = Math.min(i, this.precision - 1);\n\n\t\t\tfor (let j = 0; j < 2; j++) {\n\t\t\t\tx = lVels[j][index * 3 + 0] * stepWeight + accumX[j];\n\t\t\t\ty = lVels[j][index * 3 + 1] * stepWeight + accumY[j];\n\t\t\t\tz = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];\n\t\t\t\tminx = Math.min(x, minx);\n\t\t\t\tminy = Math.min(y, miny);\n\t\t\t\tminz = Math.min(z, minz);\n\t\t\t\tmaxx = Math.max(x, maxx);\n\t\t\t\tmaxy = Math.max(y, maxy);\n\t\t\t\tmaxz = Math.max(z, maxz);\n\t\t\t\taccumX[j] = x;\n\t\t\t\taccumY[j] = y;\n\t\t\t\taccumZ[j] = z;\n\t\t\t}\n\n\t\t\tfor (let j = 0; j < 2; j++) {\n\t\t\t\taccumW[j] += stepWeight * Math.sqrt(wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] + wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] + wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);\n\t\t\t}\n\n\t\t\taccumR[0] += this.qRadialSpeed[index] * stepWeight;\n\t\t\taccumR[1] += this.qRadialSpeed2[index] * stepWeight;\n\t\t\tmaxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));\n\t\t\tmaxScale = Math.max(maxScale, this.qScale[index]);\n\t\t}\n\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tx = this.emitterExtents.x * 0.5;\n\t\t\ty = this.emitterExtents.y * 0.5;\n\t\t\tz = this.emitterExtents.z * 0.5;\n\t\t} else {\n\t\t\tx = this.emitterRadius;\n\t\t\ty = this.emitterRadius;\n\t\t\tz = this.emitterRadius;\n\t\t}\n\n\t\tconst w = Math.max(accumW[0], accumW[1]);\n\t\tbMin.x = minx - maxScale - x - maxR - w;\n\t\tbMin.y = miny - maxScale - y - maxR - w;\n\t\tbMin.z = minz - maxScale - z - maxR - w;\n\t\tbMax.x = maxx + maxScale + x + maxR + w;\n\t\tbMax.y = maxy + maxScale + y + maxR + w;\n\t\tbMax.z = maxz + maxScale + z + maxR + w;\n\t\tthis.localBounds.setMinMax(bMin, bMax);\n\t}\n\n\trebuild() {\n\t\tconst gd = this.graphicsDevice;\n\t\tif (this.colorMap === null) this.colorMap = ParticleEmitter.DEFAULT_PARAM_TEXTURE;\n\t\tthis.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;\n\t\tthis.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;\n\n\t\tthis._destroyResources();\n\n\t\tthis.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;\n\t\tparticleTexHeight = this.useCpu || this.pack8 ? 4 : 2;\n\t\tthis.useMesh = false;\n\n\t\tif (this.mesh) {\n\t\t\tconst totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;\n\n\t\t\tif (totalVertCount > 65535) ; else {\n\t\t\t\tthis.useMesh = true;\n\t\t\t}\n\t\t}\n\n\t\tthis.numParticlesPot = math.nextPowerOfTwo(this.numParticles);\n\t\tthis.rebuildGraphs();\n\t\tthis.calculateLocalBounds();\n\t\tthis.resetWorldBounds();\n\n\t\tif (this.node) {\n\t\t\tthis.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());\n\t\t\tthis.worldBoundsTrail[0].copy(this.worldBounds);\n\t\t\tthis.worldBoundsTrail[1].copy(this.worldBounds);\n\t\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\t\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\t\t\tif (this.pack8) this.calculateBoundsMad();\n\t\t}\n\n\t\tthis.vbToSort = new Array(this.numParticles);\n\n\t\tfor (let iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];\n\n\t\tthis.particleDistance = new Float32Array(this.numParticles);\n\n\t\tthis._gpuUpdater.randomize();\n\n\t\tthis.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);\n\t\tconst emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();\n\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tif (this.node === null || this.localSpace) {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);\n\t\t\t} else {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));\n\t\t\t}\n\n\t\t\textentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;\n\t\t\textentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;\n\t\t\textentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;\n\t\t}\n\n\t\tfor (let i = 0; i < this.numParticles; i++) {\n\t\t\tthis._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);\n\n\t\t\tif (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;\n\t\t}\n\n\t\tthis.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);\n\n\t\tfor (let i = 0; i < this.particleTexStart.length; i++) {\n\t\t\tthis.particleTexStart[i] = this.particleTex[i];\n\t\t}\n\n\t\tif (!this.useCpu) {\n\t\t\tif (this.pack8) {\n\t\t\t\tthis.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);\n\t\t\t\tthis.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_R8_G8_B8_A8, 1, false);\n\t\t\t\tthis.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_R8_G8_B8_A8, 1, false);\n\t\t\t} else {\n\t\t\t\tthis.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);\n\t\t\t\tthis.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);\n\t\t\t\tthis.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);\n\t\t\t}\n\n\t\t\tthis.rtParticleTexIN = new RenderTarget({\n\t\t\t\tcolorBuffer: this.particleTexIN,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tthis.rtParticleTexOUT = new RenderTarget({\n\t\t\t\tcolorBuffer: this.particleTexOUT,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tthis.swapTex = false;\n\t\t}\n\n\t\tconst shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;\n\t\tconst shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst params = this.emitterShape + \"\" + this.pack8 + \"\" + this.localSpace;\n\t\tthis.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, \"fsQuad0\" + params);\n\t\tthis.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, \"fsQuad1\" + params);\n\t\tthis.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, \"fsQuad2\" + params);\n\t\tthis.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;\n\t\tthis.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;\n\n\t\tthis._allocate(this.numParticles);\n\n\t\tconst mesh = new Mesh(gd);\n\t\tmesh.vertexBuffer = this.vertexBuffer;\n\t\tmesh.indexBuffer[0] = this.indexBuffer;\n\t\tmesh.primitive[0].type = PRIMITIVE_TRIANGLES;\n\t\tmesh.primitive[0].base = 0;\n\t\tmesh.primitive[0].count = this.numParticles * this.numParticleIndices;\n\t\tmesh.primitive[0].indexed = true;\n\t\tthis.material = new Material();\n\t\tthis.material.name = this.node.name;\n\t\tthis.material.cull = CULLFACE_NONE;\n\t\tthis.material.alphaWrite = false;\n\t\tthis.material.blend = true;\n\t\tthis.material.blendType = this.blendType;\n\t\tthis.material.depthWrite = this.depthWrite;\n\t\tthis.material.emitter = this;\n\t\tthis.regenShader();\n\t\tthis.resetMaterial();\n\t\tconst wasVisible = this.meshInstance ? this.meshInstance.visible : true;\n\t\tthis.meshInstance = new MeshInstance(mesh, this.material, this.node);\n\t\tthis.meshInstance.pick = false;\n\t\tthis.meshInstance.updateKey();\n\t\tthis.meshInstance.cull = true;\n\t\tthis.meshInstance._noDepthDrawGl1 = true;\n\n\t\tif (this.localSpace) {\n\t\t\tthis.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());\n\t\t} else {\n\t\t\tthis.meshInstance.aabb.copy(this.worldBounds);\n\t\t}\n\n\t\tthis.meshInstance._updateAabb = false;\n\t\tthis.meshInstance.visible = wasVisible;\n\n\t\tthis._initializeTextures();\n\n\t\tthis.resetTime();\n\t\tthis.addTime(0, false);\n\t\tif (this.preWarm) this.prewarm(this.lifetime);\n\t}\n\n\t_isAnimated() {\n\t\treturn this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== ParticleEmitter.DEFAULT_PARAM_TEXTURE || this.normalMap);\n\t}\n\n\trebuildGraphs() {\n\t\tconst precision = this.precision;\n\t\tconst gd = this.graphicsDevice;\n\t\tthis.qLocalVelocity = this.localVelocityGraph.quantize(precision);\n\t\tthis.qVelocity = this.velocityGraph.quantize(precision);\n\t\tthis.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);\n\t\tthis.qRotSpeed = this.rotationSpeedGraph.quantize(precision);\n\t\tthis.qScale = this.scaleGraph.quantize(precision);\n\t\tthis.qAlpha = this.alphaGraph.quantize(precision);\n\t\tthis.qRadialSpeed = this.radialSpeedGraph.quantize(precision);\n\t\tthis.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);\n\t\tthis.qVelocity2 = this.velocityGraph2.quantize(precision);\n\t\tthis.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);\n\t\tthis.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);\n\t\tthis.qScale2 = this.scaleGraph2.quantize(precision);\n\t\tthis.qAlpha2 = this.alphaGraph2.quantize(precision);\n\t\tthis.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);\n\n\t\tfor (let i = 0; i < precision; i++) {\n\t\t\tthis.qRotSpeed[i] *= math.DEG_TO_RAD;\n\t\t\tthis.qRotSpeed2[i] *= math.DEG_TO_RAD;\n\t\t}\n\n\t\tthis.localVelocityUMax = new Float32Array(3);\n\t\tthis.velocityUMax = new Float32Array(3);\n\t\tthis.colorUMax = new Float32Array(3);\n\t\tthis.rotSpeedUMax = [0];\n\t\tthis.scaleUMax = [0];\n\t\tthis.alphaUMax = [0];\n\t\tthis.radialSpeedUMax = [0];\n\t\tthis.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);\n\t\tthis.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);\n\t\tthis.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);\n\t\tthis.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);\n\t\tthis.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);\n\t\tthis.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);\n\t\tthis.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);\n\n\t\tif (this.pack8) {\n\t\t\tconst umax = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qVelocity, umax);\n\t\t\tconst umax2 = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qVelocity2, umax2);\n\t\t\tconst lumax = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qLocalVelocity, lumax);\n\t\t\tconst lumax2 = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qLocalVelocity2, lumax2);\n\t\t\tconst rumax = [0];\n\t\t\tmaxUnsignedGraphValue(this.qRadialSpeed, rumax);\n\t\t\tconst rumax2 = [0];\n\t\t\tmaxUnsignedGraphValue(this.qRadialSpeed2, rumax2);\n\t\t\tlet maxVel = Math.max(umax[0], umax2[0]);\n\t\t\tmaxVel = Math.max(maxVel, umax[1]);\n\t\t\tmaxVel = Math.max(maxVel, umax2[1]);\n\t\t\tmaxVel = Math.max(maxVel, umax[2]);\n\t\t\tmaxVel = Math.max(maxVel, umax2[2]);\n\t\t\tlet lmaxVel = Math.max(lumax[0], lumax2[0]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax[1]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax2[1]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax[2]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax2[2]);\n\t\t\tconst maxRad = Math.max(rumax[0], rumax2[0]);\n\t\t\tthis.maxVel = maxVel + lmaxVel + maxRad;\n\t\t}\n\n\t\tif (!this.useCpu) {\n\t\t\tthis.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));\n\t\t\tthis.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));\n\t\t\tthis.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));\n\t\t\tthis.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));\n\t\t}\n\n\t\tthis.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_R8_G8_B8_A8, 1.0, true);\n\t}\n\n\t_initializeTextures() {\n\t\tif (this.colorMap) {\n\t\t\tthis.material.setParameter('colorMap', this.colorMap);\n\n\t\t\tif (this.lighting && this.normalMap) {\n\t\t\t\tthis.material.setParameter('normalMap', this.normalMap);\n\t\t\t}\n\t\t}\n\t}\n\n\tregenShader() {\n\t\tconst programLib = this.graphicsDevice.getProgramLibrary();\n\t\tconst hasNormal = this.normalMap !== null;\n\t\tthis.normalOption = 0;\n\n\t\tif (this.lighting) {\n\t\t\tthis.normalOption = hasNormal ? 2 : 1;\n\t\t}\n\n\t\tthis.material.updateShader = function () {\n\t\t\tif (this.emitter.scene) {\n\t\t\t\tif (this.emitter.camera !== this.emitter.scene._activeCamera) {\n\t\t\t\t\tthis.emitter.camera = this.emitter.scene._activeCamera;\n\t\t\t\t\tthis.emitter.onChangeCamera();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst inTools = this.emitter.inTools;\n\t\t\tconst shader = programLib.getProgram(\"particle\", {\n\t\t\t\tuseCpu: this.emitter.useCpu,\n\t\t\t\tnormal: this.emitter.normalOption,\n\t\t\t\thalflambert: this.emitter.halfLambert,\n\t\t\t\tstretch: this.emitter.stretch,\n\t\t\t\talignToMotion: this.emitter.alignToMotion,\n\t\t\t\tsoft: this.emitter.depthSoftening,\n\t\t\t\tmesh: this.emitter.useMesh,\n\t\t\t\tgamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,\n\t\t\t\ttoneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,\n\t\t\t\tfog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : \"none\",\n\t\t\t\twrap: this.emitter.wrap && this.emitter.wrapBounds,\n\t\t\t\tlocalSpace: this.emitter.localSpace,\n\t\t\t\tscreenSpace: inTools ? false : this.emitter.screenSpace,\n\t\t\t\tblend: this.blendType,\n\t\t\t\tanimTex: this.emitter._isAnimated(),\n\t\t\t\tanimTexLoop: this.emitter.animLoop,\n\t\t\t\tpack8: this.emitter.pack8,\n\t\t\t\tcustomFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN\n\t\t\t});\n\t\t\tthis.shader = shader;\n\t\t};\n\n\t\tthis.material.updateShader();\n\t}\n\n\tresetMaterial() {\n\t\tconst material = this.material;\n\t\tmaterial.setParameter('stretch', this.stretch);\n\n\t\tif (this._isAnimated()) {\n\t\t\tmaterial.setParameter('animTexTilesParams', this.animTilesParams);\n\t\t\tmaterial.setParameter('animTexParams', this.animParams);\n\t\t\tmaterial.setParameter('animTexIndexParams', this.animIndexParams);\n\t\t}\n\n\t\tmaterial.setParameter('colorMult', this.intensity);\n\n\t\tif (!this.useCpu) {\n\t\t\tmaterial.setParameter('internalTex0', this.internalTex0);\n\t\t\tmaterial.setParameter('internalTex1', this.internalTex1);\n\t\t\tmaterial.setParameter('internalTex2', this.internalTex2);\n\t\t\tmaterial.setParameter('internalTex3', this.internalTex3);\n\t\t}\n\n\t\tmaterial.setParameter('colorParam', this.colorParam);\n\t\tmaterial.setParameter('numParticles', this.numParticles);\n\t\tmaterial.setParameter('numParticlesPot', this.numParticlesPot);\n\t\tmaterial.setParameter('lifetime', this.lifetime);\n\t\tmaterial.setParameter('rate', this.rate);\n\t\tmaterial.setParameter('rateDiv', this.rate2 - this.rate);\n\t\tmaterial.setParameter('seed', this.seed);\n\t\tmaterial.setParameter('scaleDivMult', this.scaleUMax[0]);\n\t\tmaterial.setParameter('alphaDivMult', this.alphaUMax[0]);\n\t\tmaterial.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);\n\t\tmaterial.setParameter(\"graphNumSamples\", this.precision);\n\t\tmaterial.setParameter(\"graphSampleSize\", 1.0 / this.precision);\n\t\tmaterial.setParameter(\"emitterScale\", new Float32Array([1, 1, 1]));\n\n\t\tif (this.pack8) {\n\t\t\tthis._gpuUpdater._setInputBounds();\n\n\t\t\tmaterial.setParameter(\"inBoundsSize\", this._gpuUpdater.inBoundsSizeUniform);\n\t\t\tmaterial.setParameter(\"inBoundsCenter\", this._gpuUpdater.inBoundsCenterUniform);\n\t\t\tmaterial.setParameter(\"maxVel\", this.maxVel);\n\t\t}\n\n\t\tif (this.wrap && this.wrapBounds) {\n\t\t\tthis.wrapBoundsUniform[0] = this.wrapBounds.x;\n\t\t\tthis.wrapBoundsUniform[1] = this.wrapBounds.y;\n\t\t\tthis.wrapBoundsUniform[2] = this.wrapBounds.z;\n\t\t\tmaterial.setParameter('wrapBounds', this.wrapBoundsUniform);\n\t\t}\n\n\t\tif (this.colorMap) {\n\t\t\tmaterial.setParameter('colorMap', this.colorMap);\n\t\t}\n\n\t\tif (this.lighting) {\n\t\t\tif (this.normalMap) {\n\t\t\t\tmaterial.setParameter('normalMap', this.normalMap);\n\t\t\t}\n\t\t}\n\n\t\tif (this.depthSoftening > 0) {\n\t\t\tmaterial.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));\n\t\t}\n\n\t\tif (this.stretch > 0.0) material.cull = CULLFACE_NONE;\n\n\t\tthis._compParticleFaceParams();\n\t}\n\n\t_compParticleFaceParams() {\n\t\tlet tangent, binormal;\n\n\t\tif (this.orientation === PARTICLEORIENTATION_SCREEN) {\n\t\t\ttangent = new Float32Array([1, 0, 0]);\n\t\t\tbinormal = new Float32Array([0, 0, 1]);\n\t\t} else {\n\t\t\tlet n;\n\n\t\t\tif (this.orientation === PARTICLEORIENTATION_WORLD) {\n\t\t\t\tn = this.particleNormal.normalize();\n\t\t\t} else {\n\t\t\t\tconst emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();\n\t\t\t\tn = emitterMat.transformVector(this.particleNormal).normalize();\n\t\t\t}\n\n\t\t\tconst t = new Vec3(1, 0, 0);\n\t\t\tif (Math.abs(t.dot(n)) === 1) t.set(0, 0, 1);\n\t\t\tconst b = new Vec3().cross(n, t).normalize();\n\t\t\tt.cross(b, n).normalize();\n\t\t\ttangent = new Float32Array([t.x, t.y, t.z]);\n\t\t\tbinormal = new Float32Array([b.x, b.y, b.z]);\n\t\t}\n\n\t\tthis.material.setParameter(\"faceTangent\", tangent);\n\t\tthis.material.setParameter(\"faceBinorm\", binormal);\n\t}\n\n\t_allocate(numParticles) {\n\t\tconst psysVertCount = numParticles * this.numParticleVerts;\n\t\tconst psysIndexCount = numParticles * this.numParticleIndices;\n\n\t\tif (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {\n\t\t\tif (!this.useCpu) {\n\t\t\t\tconst elements = [{\n\t\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}];\n\n\t\t\t\tif (this.useMesh) {\n\t\t\t\t\telements.push({\n\t\t\t\t\t\tsemantic: SEMANTIC_ATTR1,\n\t\t\t\t\t\tcomponents: 2,\n\t\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst particleFormat = new VertexFormat(this.graphicsDevice, elements);\n\t\t\t\tthis.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);\n\t\t\t\tthis.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);\n\t\t\t} else {\n\t\t\t\tconst elements = [{\n\t\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR1,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR2,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR3,\n\t\t\t\t\tcomponents: 1,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR4,\n\t\t\t\t\tcomponents: this.useMesh ? 4 : 2,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}];\n\t\t\t\tconst particleFormat = new VertexFormat(this.graphicsDevice, elements);\n\t\t\t\tthis.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, BUFFER_DYNAMIC);\n\t\t\t\tthis.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);\n\t\t\t}\n\n\t\t\tconst data = new Float32Array(this.vertexBuffer.lock());\n\t\t\tlet meshData, stride, texCoordOffset;\n\n\t\t\tif (this.useMesh) {\n\t\t\t\tmeshData = new Float32Array(this.mesh.vertexBuffer.lock());\n\t\t\t\tstride = meshData.length / this.mesh.vertexBuffer.numVertices;\n\n\t\t\t\tfor (let elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {\n\t\t\t\t\tif (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {\n\t\t\t\t\t\ttexCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < psysVertCount; i++) {\n\t\t\t\tconst id = Math.floor(i / this.numParticleVerts);\n\n\t\t\t\tif (!this.useMesh) {\n\t\t\t\t\tconst vertID = i % 4;\n\t\t\t\t\tdata[i * 4] = particleVerts[vertID][0];\n\t\t\t\t\tdata[i * 4 + 1] = particleVerts[vertID][1];\n\t\t\t\t\tdata[i * 4 + 2] = 0;\n\t\t\t\t\tdata[i * 4 + 3] = id;\n\t\t\t\t} else {\n\t\t\t\t\tconst vert = i % this.numParticleVerts;\n\t\t\t\t\tdata[i * 6] = meshData[vert * stride];\n\t\t\t\t\tdata[i * 6 + 1] = meshData[vert * stride + 1];\n\t\t\t\t\tdata[i * 6 + 2] = meshData[vert * stride + 2];\n\t\t\t\t\tdata[i * 6 + 3] = id;\n\t\t\t\t\tdata[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];\n\t\t\t\t\tdata[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.useCpu) {\n\t\t\t\tthis.vbCPU = new Float32Array(data);\n\t\t\t\tthis.vbOld = new Float32Array(this.vbCPU.length);\n\t\t\t}\n\n\t\t\tthis.vertexBuffer.unlock();\n\n\t\t\tif (this.useMesh) {\n\t\t\t\tthis.mesh.vertexBuffer.unlock();\n\t\t\t}\n\n\t\t\tlet dst = 0;\n\t\t\tconst indices = new Uint16Array(this.indexBuffer.lock());\n\t\t\tif (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());\n\n\t\t\tfor (let i = 0; i < numParticles; i++) {\n\t\t\t\tif (!this.useMesh) {\n\t\t\t\t\tconst baseIndex = i * 4;\n\t\t\t\t\tindices[dst++] = baseIndex;\n\t\t\t\t\tindices[dst++] = baseIndex + 1;\n\t\t\t\t\tindices[dst++] = baseIndex + 2;\n\t\t\t\t\tindices[dst++] = baseIndex;\n\t\t\t\t\tindices[dst++] = baseIndex + 2;\n\t\t\t\t\tindices[dst++] = baseIndex + 3;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let j = 0; j < this.numParticleIndices; j++) {\n\t\t\t\t\t\tindices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.indexBuffer.unlock();\n\t\t\tif (this.useMesh) this.mesh.indexBuffer[0].unlock();\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.beenReset = true;\n\t\tthis.seed = Math.random();\n\t\tthis.material.setParameter('seed', this.seed);\n\n\t\tif (this.useCpu) {\n\t\t\tfor (let i = 0; i < this.particleTexStart.length; i++) {\n\t\t\t\tthis.particleTex[i] = this.particleTexStart[i];\n\t\t\t}\n\t\t} else {\n\t\t\tthis._initializeTextures();\n\t\t}\n\n\t\tthis.resetWorldBounds();\n\t\tthis.resetTime();\n\t\tconst origLoop = this.loop;\n\t\tthis.loop = true;\n\t\tthis.addTime(0, false);\n\t\tthis.loop = origLoop;\n\n\t\tif (this.preWarm) {\n\t\t\tthis.prewarm(this.lifetime);\n\t\t}\n\t}\n\n\tprewarm(time) {\n\t\tconst lifetimeFraction = time / this.lifetime;\n\t\tconst iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);\n\t\tconst stepDelta = time / iterations;\n\n\t\tfor (let i = 0; i < iterations; i++) {\n\t\t\tthis.addTime(stepDelta, false);\n\t\t}\n\t}\n\n\tresetTime() {\n\t\tthis.endTime = calcEndTime(this);\n\t}\n\n\tfinishFrame() {\n\t\tif (this.useCpu) this.vertexBuffer.unlock();\n\t}\n\n\taddTime(delta, isOnStop) {\n\t\tconst device = this.graphicsDevice;\n\t\tthis.simTimeTotal += delta;\n\t\tthis.calculateWorldBounds();\n\n\t\tif (this._isAnimated()) {\n\t\t\tconst tilesParams = this.animTilesParams;\n\t\t\ttilesParams[0] = 1.0 / this.animTilesX;\n\t\t\ttilesParams[1] = 1.0 / this.animTilesY;\n\t\t\tconst params = this.animParams;\n\t\t\tparams[0] = this.animStartFrame;\n\t\t\tparams[1] = this.animNumFrames * this.animSpeed;\n\t\t\tparams[2] = this.animNumFrames - 1;\n\t\t\tparams[3] = this.animNumAnimations - 1;\n\t\t\tconst animIndexParams = this.animIndexParams;\n\t\t\tanimIndexParams[0] = this.animIndex;\n\t\t\tanimIndexParams[1] = this.randomizeAnimIndex;\n\t\t}\n\n\t\tif (this.scene) {\n\t\t\tif (this.camera !== this.scene._activeCamera) {\n\t\t\t\tthis.camera = this.scene._activeCamera;\n\t\t\t\tthis.onChangeCamera();\n\t\t\t}\n\t\t}\n\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\textentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;\n\t\t\textentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;\n\t\t\textentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;\n\n\t\t\tif (this.meshInstance.node === null) {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);\n\t\t\t} else {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));\n\t\t\t}\n\t\t}\n\n\t\tlet emitterPos;\n\t\tconst emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;\n\t\tthis.emitterScaleUniform[0] = emitterScale.x;\n\t\tthis.emitterScaleUniform[1] = emitterScale.y;\n\t\tthis.emitterScaleUniform[2] = emitterScale.z;\n\t\tthis.material.setParameter(\"emitterScale\", this.emitterScaleUniform);\n\n\t\tif (this.localSpace && this.meshInstance.node) {\n\t\t\temitterPos = this.meshInstance.node.getPosition();\n\t\t\tthis.emitterPosUniform[0] = emitterPos.x;\n\t\t\tthis.emitterPosUniform[1] = emitterPos.y;\n\t\t\tthis.emitterPosUniform[2] = emitterPos.z;\n\t\t\tthis.material.setParameter(\"emitterPos\", this.emitterPosUniform);\n\t\t}\n\n\t\tthis._compParticleFaceParams();\n\n\t\tif (!this.useCpu) {\n\t\t\tthis._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);\n\t\t} else {\n\t\t\tconst data = new Float32Array(this.vertexBuffer.lock());\n\n\t\t\tthis._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);\n\t\t}\n\n\t\tif (!this.loop) {\n\t\t\tif (Date.now() > this.endTime) {\n\t\t\t\tif (this.onFinished) this.onFinished();\n\t\t\t\tthis.meshInstance.visible = false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.meshInstance) {\n\t\t\tthis.meshInstance.drawOrder = this.drawOrder;\n\t\t}\n\t}\n\n\t_destroyResources() {\n\t\tif (this.particleTexIN) {\n\t\t\tthis.particleTexIN.destroy();\n\t\t\tthis.particleTexIN = null;\n\t\t}\n\n\t\tif (this.particleTexOUT) {\n\t\t\tthis.particleTexOUT.destroy();\n\t\t\tthis.particleTexOUT = null;\n\t\t}\n\n\t\tif (this.particleTexStart && this.particleTexStart.destroy) {\n\t\t\tthis.particleTexStart.destroy();\n\t\t\tthis.particleTexStart = null;\n\t\t}\n\n\t\tif (this.rtParticleTexIN) {\n\t\t\tthis.rtParticleTexIN.destroy();\n\t\t\tthis.rtParticleTexIN = null;\n\t\t}\n\n\t\tif (this.rtParticleTexOUT) {\n\t\t\tthis.rtParticleTexOUT.destroy();\n\t\t\tthis.rtParticleTexOUT = null;\n\t\t}\n\n\t\tif (this.internalTex0) {\n\t\t\tthis.internalTex0.destroy();\n\t\t\tthis.internalTex0 = null;\n\t\t}\n\n\t\tif (this.internalTex1) {\n\t\t\tthis.internalTex1.destroy();\n\t\t\tthis.internalTex1 = null;\n\t\t}\n\n\t\tif (this.internalTex2) {\n\t\t\tthis.internalTex2.destroy();\n\t\t\tthis.internalTex2 = null;\n\t\t}\n\n\t\tif (this.internalTex3) {\n\t\t\tthis.internalTex3.destroy();\n\t\t\tthis.internalTex3 = null;\n\t\t}\n\n\t\tif (this.colorParam) {\n\t\t\tthis.colorParam.destroy();\n\t\t\tthis.colorParam = null;\n\t\t}\n\n\t\tif (this.vertexBuffer) {\n\t\t\tthis.vertexBuffer.destroy();\n\t\t\tthis.vertexBuffer = undefined;\n\t\t}\n\n\t\tif (this.indexBuffer) {\n\t\t\tthis.indexBuffer.destroy();\n\t\t\tthis.indexBuffer = undefined;\n\t\t}\n\n\t\tif (this.material) {\n\t\t\tthis.material.destroy();\n\t\t\tthis.material = null;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis.camera = null;\n\n\t\tthis._destroyResources();\n\t}\n\n}\n\nParticleEmitter.DEFAULT_PARAM_TEXTURE = null;\n\nconst _floatRounding = 0.2;\n\nclass Morph extends RefCountedObject {\n\tconstructor(targets, graphicsDevice) {\n\t\tsuper();\n\t\tthis.device = graphicsDevice || getApplication().graphicsDevice;\n\t\tthis._targets = targets;\n\n\t\tif (this.device.supportsMorphTargetTexturesCore) {\n\t\t\tif (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable) {\n\t\t\t\tthis._renderTextureFormat = Morph.FORMAT_HALF_FLOAT;\n\t\t\t} else if (this.device.extTextureFloat && this.device.textureFloatRenderable) {\n\t\t\t\tthis._renderTextureFormat = Morph.FORMAT_FLOAT;\n\t\t\t}\n\n\t\t\tif (this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable) {\n\t\t\t\tthis._textureFormat = Morph.FORMAT_HALF_FLOAT;\n\t\t\t} else if (this.device.extTextureFloat) {\n\t\t\t\tthis._textureFormat = Morph.FORMAT_FLOAT;\n\t\t\t}\n\n\t\t\tif (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {\n\t\t\t\tthis._useTextureMorph = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._init();\n\n\t\tthis._updateMorphFlags();\n\n\t\tthis._calculateAabb();\n\t}\n\n\tget morphPositions() {\n\t\treturn this._morphPositions;\n\t}\n\n\tget morphNormals() {\n\t\treturn this._morphNormals;\n\t}\n\n\tget maxActiveTargets() {\n\t\tif (this._useTextureMorph) return this._targets.length;\n\t\treturn this._morphPositions && this._morphNormals ? 4 : 8;\n\t}\n\n\tget useTextureMorph() {\n\t\treturn this._useTextureMorph;\n\t}\n\n\t_init() {\n\t\tif (this._useTextureMorph) {\n\t\t\tthis._useTextureMorph = this._initTextureBased();\n\t\t}\n\n\t\tif (!this._useTextureMorph) {\n\t\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\t\tthis._targets[i]._initVertexBuffers(this.device);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tthis._targets[i]._postInit();\n\t\t}\n\t}\n\n\t_initTextureBased() {\n\t\tconst deltaArrays = [],\n\t\t\t\t\tdeltaInfos = [];\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tconst target = this._targets[i];\n\n\t\t\tif (target.options.deltaPositions) {\n\t\t\t\tdeltaArrays.push(target.options.deltaPositions);\n\t\t\t\tdeltaInfos.push({\n\t\t\t\t\ttarget: target,\n\t\t\t\t\tname: 'texturePositions'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (target.options.deltaNormals) {\n\t\t\t\tdeltaArrays.push(target.options.deltaNormals);\n\t\t\t\tdeltaInfos.push({\n\t\t\t\t\ttarget: target,\n\t\t\t\t\tname: 'textureNormals'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tconst ids = [],\n\t\t\t\t\tusedDataIndices = [];\n\t\tlet freeIndex = 1;\n\t\tconst dataCount = deltaArrays[0].length;\n\n\t\tfor (let v = 0; v < dataCount; v += 3) {\n\t\t\tlet vertexUsed = false;\n\n\t\t\tfor (let i = 0; i < deltaArrays.length; i++) {\n\t\t\t\tconst data = deltaArrays[i];\n\n\t\t\t\tif (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {\n\t\t\t\t\tvertexUsed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vertexUsed) {\n\t\t\t\tids.push(freeIndex + _floatRounding);\n\t\t\t\tusedDataIndices.push(v / 3);\n\t\t\t\tfreeIndex++;\n\t\t\t} else {\n\t\t\t\tids.push(0 + _floatRounding);\n\t\t\t}\n\t\t}\n\n\t\tconst maxTextureSize = Math.min(this.device.maxTextureSize, 4096);\n\t\tlet morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));\n\t\tmorphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);\n\t\tconst morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);\n\n\t\tif (morphTextureHeight > maxTextureSize) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.morphTextureWidth = morphTextureWidth;\n\t\tthis.morphTextureHeight = morphTextureHeight;\n\t\tlet halfFloat = false;\n\t\tlet numComponents = 3;\n\t\tconst float2Half = FloatPacking.float2Half;\n\n\t\tif (this._textureFormat === Morph.FORMAT_HALF_FLOAT) {\n\t\t\thalfFloat = true;\n\t\t\tnumComponents = 4;\n\t\t}\n\n\t\tconst arraySize = this.morphTextureWidth * this.morphTextureHeight * numComponents;\n\t\tconst packedDeltas = halfFloat ? new Uint16Array(arraySize) : new Float32Array(arraySize);\n\n\t\tfor (let i = 0; i < deltaArrays.length; i++) {\n\t\t\tconst data = deltaArrays[i];\n\n\t\t\tfor (let v = 0; v < usedDataIndices.length; v++) {\n\t\t\t\tconst index = usedDataIndices[v];\n\n\t\t\t\tif (halfFloat) {\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents] = float2Half(data[index * 3]);\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents + 1] = float2Half(data[index * 3 + 1]);\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents + 2] = float2Half(data[index * 3 + 2]);\n\t\t\t\t} else {\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents] = data[index * 3];\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents + 1] = data[index * 3 + 1];\n\t\t\t\t\tpackedDeltas[v * numComponents + numComponents + 2] = data[index * 3 + 2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst target = deltaInfos[i].target;\n\t\t\tconst format = this._textureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGB32F : PIXELFORMAT_RGBA16F;\n\n\t\t\ttarget._setTexture(deltaInfos[i].name, this._createTexture(\"MorphTarget\", format, packedDeltas));\n\t\t}\n\n\t\tconst formatDesc = [{\n\t\t\tsemantic: SEMANTIC_ATTR15,\n\t\t\tcomponents: 1,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}];\n\t\tthis.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc), ids.length, BUFFER_STATIC, new Float32Array(ids));\n\t\treturn true;\n\t}\n\n\tdestroy() {\n\t\tif (this.vertexBufferIds) {\n\t\t\tthis.vertexBufferIds.destroy();\n\t\t\tthis.vertexBufferIds = null;\n\t\t}\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tthis._targets[i].destroy();\n\t\t}\n\n\t\tthis._targets.length = 0;\n\t}\n\n\tget targets() {\n\t\treturn this._targets;\n\t}\n\n\t_updateMorphFlags() {\n\t\tthis._morphPositions = false;\n\t\tthis._morphNormals = false;\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tconst target = this._targets[i];\n\n\t\t\tif (target.morphPositions) {\n\t\t\t\tthis._morphPositions = true;\n\t\t\t}\n\n\t\t\tif (target.morphNormals) {\n\t\t\t\tthis._morphNormals = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t_calculateAabb() {\n\t\tconst min = new Vec3();\n\t\tconst max = new Vec3();\n\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tconst targetAabb = this._targets[i].aabb;\n\t\t\tmin.min(targetAabb.getMin());\n\t\t\tmax.max(targetAabb.getMax());\n\t\t}\n\n\t\tthis.aabb = new BoundingBox();\n\t\tthis.aabb.setMinMax(min, max);\n\t}\n\n\t_createTexture(name, format, pixelData) {\n\t\tconst texture = new Texture(this.device, {\n\t\t\twidth: this.morphTextureWidth,\n\t\t\theight: this.morphTextureHeight,\n\t\t\tformat: format,\n\t\t\tcubemap: false,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\ttexture.name = name;\n\n\t\tif (pixelData) {\n\t\t\ttexture.lock().set(pixelData);\n\t\t\ttexture.unlock();\n\t\t}\n\n\t\treturn texture;\n\t}\n\n}\n\nMorph.FORMAT_FLOAT = 0;\nMorph.FORMAT_HALF_FLOAT = 1;\n\nconst textureMorphVertexShader = `\n\t\tattribute vec2 vertex_position;\n\t\tvarying vec2 uv0;\n\t\tvoid main(void) {\n\t\t\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\t\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t}\n\t\t`;\n\nclass MorphInstance {\n\tconstructor(morph) {\n\t\tthis.morph = morph;\n\t\tmorph.incRefCount();\n\t\tthis.device = morph.device;\n\t\tthis.meshInstance = null;\n\t\tthis._weights = [];\n\n\t\tfor (let v = 0; v < morph._targets.length; v++) {\n\t\t\tthis.setWeight(v, morph._targets[v].defaultWeight);\n\t\t}\n\n\t\tthis._activeTargets = [];\n\n\t\tif (morph.useTextureMorph) {\n\t\t\tthis.shaderCache = {};\n\t\t\tthis.maxSubmitCount = this.device.maxTextures;\n\t\t\tthis._shaderMorphWeights = new Float32Array(this.maxSubmitCount);\n\n\t\t\tconst createRT = (name, textureVar) => {\n\t\t\t\tconst format = morph._renderTextureFormat === Morph.FORMAT_FLOAT ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;\n\t\t\t\tthis[textureVar] = morph._createTexture(name, format);\n\t\t\t\treturn new RenderTarget({\n\t\t\t\t\tcolorBuffer: this[textureVar],\n\t\t\t\t\tdepth: false\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tif (morph.morphPositions) {\n\t\t\t\tthis.rtPositions = createRT(\"MorphRTPos\", \"texturePositions\");\n\t\t\t}\n\n\t\t\tif (morph.morphNormals) {\n\t\t\t\tthis.rtNormals = createRT(\"MorphRTNrm\", \"textureNormals\");\n\t\t\t}\n\n\t\t\tthis._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);\n\n\t\t\tfor (let i = 0; i < this.maxSubmitCount; i++) {\n\t\t\t\tthis[\"morphBlendTex\" + i] = this.device.scope.resolve(\"morphBlendTex\" + i);\n\t\t\t}\n\n\t\t\tthis.morphFactor = this.device.scope.resolve(\"morphFactor[0]\");\n\t\t\tthis.zeroTextures = false;\n\t\t} else {\n\t\t\tthis.maxSubmitCount = 8;\n\t\t\tthis._shaderMorphWeights = new Float32Array(this.maxSubmitCount);\n\t\t\tthis._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);\n\t\t\tthis._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);\n\t\t\tthis._activeVertexBuffers = new Array(this.maxSubmitCount);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis.meshInstance = null;\n\t\tthis.shader = null;\n\t\tconst morph = this.morph;\n\n\t\tif (morph) {\n\t\t\tthis.morph = null;\n\t\t\tmorph.decRefCount();\n\n\t\t\tif (morph.refCount < 1) {\n\t\t\t\tmorph.destroy();\n\t\t\t}\n\t\t}\n\n\t\tif (this.rtPositions) {\n\t\t\tthis.rtPositions.destroy();\n\t\t\tthis.rtPositions = null;\n\t\t}\n\n\t\tif (this.texturePositions) {\n\t\t\tthis.texturePositions.destroy();\n\t\t\tthis.texturePositions = null;\n\t\t}\n\n\t\tif (this.rtNormals) {\n\t\t\tthis.rtNormals.destroy();\n\t\t\tthis.rtNormals = null;\n\t\t}\n\n\t\tif (this.textureNormals) {\n\t\t\tthis.textureNormals.destroy();\n\t\t\tthis.textureNormals = null;\n\t\t}\n\t}\n\n\tclone() {\n\t\tconst clone = new MorphInstance(this.morph);\n\t\treturn clone;\n\t}\n\n\tgetWeight(index) {\n\t\treturn this._weights[index];\n\t}\n\n\tsetWeight(index, weight) {\n\t\tthis._weights[index] = weight;\n\t\tthis._dirty = true;\n\t}\n\n\t_getFragmentShader(numTextures) {\n\t\tlet fragmentShader = '';\n\n\t\tif (numTextures > 0) {\n\t\t\tfragmentShader += 'varying vec2 uv0;\\n' + 'uniform highp float morphFactor[' + numTextures + '];\\n';\n\t\t}\n\n\t\tfor (let i = 0; i < numTextures; i++) {\n\t\t\tfragmentShader += 'uniform highp sampler2D morphBlendTex' + i + ';\\n';\n\t\t}\n\n\t\tfragmentShader += 'void main (void) {\\n' + '\t\thighp vec4 color = vec4(0, 0, 0, 1);\\n';\n\n\t\tfor (let i = 0; i < numTextures; i++) {\n\t\t\tfragmentShader += '\t\tcolor.xyz += morphFactor[' + i + '] * texture2D(morphBlendTex' + i + ', uv0).xyz;\\n';\n\t\t}\n\n\t\tfragmentShader += '\t\tgl_FragColor = color;\\n' + '}\\n';\n\t\treturn fragmentShader;\n\t}\n\n\t_getShader(count) {\n\t\tlet shader = this.shaderCache[count];\n\n\t\tif (!shader) {\n\t\t\tconst fs = this._getFragmentShader(count);\n\n\t\t\tshader = createShaderFromCode(this.device, textureMorphVertexShader, fs, \"textureMorph\" + count);\n\t\t\tthis.shaderCache[count] = shader;\n\t\t}\n\n\t\treturn shader;\n\t}\n\n\t_updateTextureRenderTarget(renderTarget, srcTextureName) {\n\t\tconst device = this.device;\n\n\t\tconst submitBatch = (usedCount, blending) => {\n\t\t\tthis.morphFactor.setValue(this._shaderMorphWeights);\n\t\t\tdevice.setBlending(blending);\n\n\t\t\tif (blending) {\n\t\t\t\tdevice.setBlendFunction(BLENDMODE_ONE, BLENDMODE_ONE);\n\t\t\t\tdevice.setBlendEquation(BLENDEQUATION_ADD);\n\t\t\t}\n\n\t\t\tconst shader = this._getShader(usedCount);\n\n\t\t\tdrawQuadWithShader(device, renderTarget, shader, undefined, undefined, blending);\n\t\t};\n\n\t\tlet usedCount = 0;\n\t\tlet blending = false;\n\t\tconst count = this._activeTargets.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst activeTarget = this._activeTargets[i];\n\t\t\tconst tex = activeTarget.target[srcTextureName];\n\n\t\t\tif (tex) {\n\t\t\t\tthis[\"morphBlendTex\" + usedCount].setValue(tex);\n\t\t\t\tthis._shaderMorphWeights[usedCount] = activeTarget.weight;\n\t\t\t\tusedCount++;\n\n\t\t\t\tif (usedCount >= this.maxSubmitCount) {\n\t\t\t\t\tsubmitBatch(usedCount, blending);\n\t\t\t\t\tusedCount = 0;\n\t\t\t\t\tblending = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (usedCount > 0 || count === 0 && !this.zeroTextures) {\n\t\t\tsubmitBatch(usedCount, blending);\n\t\t}\n\t}\n\n\t_updateTextureMorph() {\n\t\tthis.device;\n\n\t\tif (this._activeTargets.length > 0 || !this.zeroTextures) {\n\t\t\tthis._updateTextureRenderTarget(this.rtPositions, 'texturePositions');\n\n\t\t\tthis._updateTextureRenderTarget(this.rtNormals, 'textureNormals');\n\n\t\t\tthis.zeroTextures = this._activeTargets.length === 0;\n\t\t}\n\t}\n\n\t_updateVertexMorph() {\n\t\tconst count = this.maxSubmitCount;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tthis._shaderMorphWeights[i] = 0;\n\t\t\tthis._activeVertexBuffers[i] = null;\n\t\t}\n\n\t\tlet posIndex = 0;\n\t\tlet nrmIndex = this.morph.morphPositions ? 4 : 0;\n\n\t\tfor (let i = 0; i < this._activeTargets.length; i++) {\n\t\t\tconst target = this._activeTargets[i].target;\n\n\t\t\tif (target._vertexBufferPositions) {\n\t\t\t\tthis._activeVertexBuffers[posIndex] = target._vertexBufferPositions;\n\t\t\t\tthis._shaderMorphWeights[posIndex] = this._activeTargets[i].weight;\n\t\t\t\tposIndex++;\n\t\t\t}\n\n\t\t\tif (target._vertexBufferNormals) {\n\t\t\t\tthis._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;\n\t\t\t\tthis._shaderMorphWeights[nrmIndex] = this._activeTargets[i].weight;\n\t\t\t\tnrmIndex++;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate() {\n\t\tthis._dirty = false;\n\t\tconst targets = this.morph._targets;\n\t\tlet activeCount = 0;\n\t\tconst epsilon = 0.00001;\n\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\tconst absWeight = Math.abs(this.getWeight(i));\n\n\t\t\tif (absWeight > epsilon) {\n\t\t\t\tif (this._activeTargets.length <= activeCount) {\n\t\t\t\t\tthis._activeTargets[activeCount] = {};\n\t\t\t\t}\n\n\t\t\t\tconst activeTarget = this._activeTargets[activeCount++];\n\t\t\t\tactiveTarget.absWeight = absWeight;\n\t\t\t\tactiveTarget.weight = this.getWeight(i);\n\t\t\t\tactiveTarget.target = targets[i];\n\t\t\t}\n\t\t}\n\n\t\tthis._activeTargets.length = activeCount;\n\t\tconst maxActiveTargets = this.morph.maxActiveTargets;\n\n\t\tif (this._activeTargets.length > maxActiveTargets) {\n\t\t\tthis._activeTargets.sort(function (l, r) {\n\t\t\t\treturn l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;\n\t\t\t});\n\n\t\t\tthis._activeTargets.length = maxActiveTargets;\n\t\t}\n\n\t\tif (this.morph.useTextureMorph) {\n\t\t\tthis._updateTextureMorph();\n\t\t} else {\n\t\t\tthis._updateVertexMorph();\n\t\t}\n\t}\n\n}\n\nclass Model {\n\tconstructor() {\n\t\tthis.graph = null;\n\t\tthis.meshInstances = [];\n\t\tthis.skinInstances = [];\n\t\tthis.morphInstances = [];\n\t\tthis.cameras = [];\n\t\tthis.lights = [];\n\t\tthis._shadersVersion = 0;\n\t\tthis._immutable = false;\n\t}\n\n\tgetGraph() {\n\t\treturn this.graph;\n\t}\n\n\tsetGraph(graph) {\n\t\tthis.graph = graph;\n\t}\n\n\tgetCameras() {\n\t\treturn this.cameras;\n\t}\n\n\tsetCameras(cameras) {\n\t\tthis.cameras = cameras;\n\t}\n\n\tgetLights() {\n\t\treturn this.lights;\n\t}\n\n\tsetLights(lights) {\n\t\tthis.lights = lights;\n\t}\n\n\tgetMaterials() {\n\t\tconst materials = [];\n\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\n\t\t\tif (materials.indexOf(meshInstance.material) === -1) {\n\t\t\t\tmaterials.push(meshInstance.material);\n\t\t\t}\n\t\t}\n\n\t\treturn materials;\n\t}\n\n\tclone() {\n\t\tconst srcNodes = [];\n\t\tconst cloneNodes = [];\n\n\t\tconst _duplicate = function _duplicate(node) {\n\t\t\tconst newNode = node.clone();\n\t\t\tsrcNodes.push(node);\n\t\t\tcloneNodes.push(newNode);\n\n\t\t\tfor (let idx = 0; idx < node._children.length; idx++) {\n\t\t\t\tnewNode.addChild(_duplicate(node._children[idx]));\n\t\t\t}\n\n\t\t\treturn newNode;\n\t\t};\n\n\t\tconst cloneGraph = _duplicate(this.graph);\n\n\t\tconst cloneMeshInstances = [];\n\t\tconst cloneSkinInstances = [];\n\t\tconst cloneMorphInstances = [];\n\n\t\tfor (let i = 0; i < this.skinInstances.length; i++) {\n\t\t\tconst skin = this.skinInstances[i].skin;\n\t\t\tconst cloneSkinInstance = new SkinInstance(skin);\n\t\t\tconst bones = [];\n\n\t\t\tfor (let j = 0; j < skin.boneNames.length; j++) {\n\t\t\t\tconst boneName = skin.boneNames[j];\n\t\t\t\tconst bone = cloneGraph.findByName(boneName);\n\t\t\t\tbones.push(bone);\n\t\t\t}\n\n\t\t\tcloneSkinInstance.bones = bones;\n\t\t\tcloneSkinInstances.push(cloneSkinInstance);\n\t\t}\n\n\t\tfor (let i = 0; i < this.morphInstances.length; i++) {\n\t\t\tconst morph = this.morphInstances[i].morph;\n\t\t\tconst cloneMorphInstance = new MorphInstance(morph);\n\t\t\tcloneMorphInstances.push(cloneMorphInstance);\n\t\t}\n\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\t\t\tconst nodeIndex = srcNodes.indexOf(meshInstance.node);\n\t\t\tconst cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);\n\n\t\t\tif (meshInstance.skinInstance) {\n\t\t\t\tconst skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);\n\t\t\t\tcloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];\n\t\t\t}\n\n\t\t\tif (meshInstance.morphInstance) {\n\t\t\t\tconst morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);\n\t\t\t\tcloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];\n\t\t\t}\n\n\t\t\tcloneMeshInstances.push(cloneMeshInstance);\n\t\t}\n\n\t\tconst clone = new Model();\n\t\tclone.graph = cloneGraph;\n\t\tclone.meshInstances = cloneMeshInstances;\n\t\tclone.skinInstances = cloneSkinInstances;\n\t\tclone.morphInstances = cloneMorphInstances;\n\t\tclone.getGraph().syncHierarchy();\n\t\treturn clone;\n\t}\n\n\tdestroy() {\n\t\tconst meshInstances = this.meshInstances;\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].destroy();\n\t\t}\n\n\t\tthis.meshInstances.length = 0;\n\t}\n\n\tgenerateWireframe() {\n\t\tMeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);\n\t}\n\n}\n\nconst identityGraphNode = new GraphNode();\nidentityGraphNode.worldTransform = Mat4.IDENTITY;\nidentityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;\n\nclass ImmediateBatch {\n\tconstructor(device, material, layer) {\n\t\tthis.material = material;\n\t\tthis.layer = layer;\n\t\tthis.positions = [];\n\t\tthis.colors = [];\n\t\tthis.mesh = new Mesh(device);\n\t\tthis.meshInstance = null;\n\t}\n\n\taddLines(positions, color) {\n\t\tconst destPos = this.positions;\n\t\tconst count = positions.length;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pos = positions[i];\n\t\t\tdestPos.push(pos.x, pos.y, pos.z);\n\t\t}\n\n\t\tconst destCol = this.colors;\n\n\t\tif (color.length) {\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst col = color[i];\n\t\t\t\tdestCol.push(col.r, col.g, col.b, col.a);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tdestCol.push(color.r, color.g, color.b, color.a);\n\t\t\t}\n\t\t}\n\t}\n\n\taddLinesArrays(positions, color) {\n\t\tthis.positions.push(...positions);\n\t\tconst destCol = this.colors;\n\n\t\tif (color.length) {\n\t\t\tdestCol.push(...color);\n\t\t} else {\n\t\t\tconst count = positions.length / 3;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tdestCol.push(color.r, color.g, color.b, color.a);\n\t\t\t}\n\t\t}\n\t}\n\n\tonPreRender(visibleList, transparent) {\n\t\tif (this.positions.length > 0 && this.material.transparent === transparent) {\n\t\t\tthis.mesh.setPositions(this.positions);\n\t\t\tthis.mesh.setColors(this.colors);\n\t\t\tthis.mesh.update(PRIMITIVE_LINES, false);\n\n\t\t\tif (!this.meshInstance) {\n\t\t\t\tthis.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);\n\t\t\t}\n\n\t\t\tthis.positions.length = 0;\n\t\t\tthis.colors.length = 0;\n\t\t\tvisibleList.list.push(this.meshInstance);\n\t\t\tvisibleList.length++;\n\t\t}\n\t}\n\n}\n\nclass ImmediateBatches {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.map = new Map();\n\t}\n\n\tgetBatch(material, layer) {\n\t\tlet batch = this.map.get(material);\n\n\t\tif (!batch) {\n\t\t\tbatch = new ImmediateBatch(this.device, material, layer);\n\t\t\tthis.map.set(material, batch);\n\t\t}\n\n\t\treturn batch;\n\t}\n\n\tonPreRender(visibleList, transparent) {\n\t\tthis.map.forEach(batch => {\n\t\t\tbatch.onPreRender(visibleList, transparent);\n\t\t});\n\t}\n\n}\n\nconst tempPoints = [];\n\nclass Immediate {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.quadMesh = null;\n\t\tthis.textureShader = null;\n\t\tthis.depthTextureShader = null;\n\t\tthis.cubeLocalPos = null;\n\t\tthis.cubeWorldPos = null;\n\t\tthis.batchesMap = new Map();\n\t\tthis.allBatches = new Set();\n\t\tthis.updatedLayers = new Set();\n\t\tthis._materialDepth = null;\n\t\tthis._materialNoDepth = null;\n\t\tthis.layerMeshInstances = new Map();\n\t}\n\n\tcreateMaterial(depthTest) {\n\t\tconst material = new BasicMaterial();\n\t\tmaterial.vertexColors = true;\n\t\tmaterial.blend = true;\n\t\tmaterial.blendType = BLEND_NORMAL;\n\t\tmaterial.depthTest = depthTest;\n\t\tmaterial.update();\n\t\treturn material;\n\t}\n\n\tget materialDepth() {\n\t\tif (!this._materialDepth) {\n\t\t\tthis._materialDepth = this.createMaterial(true);\n\t\t}\n\n\t\treturn this._materialDepth;\n\t}\n\n\tget materialNoDepth() {\n\t\tif (!this._materialNoDepth) {\n\t\t\tthis._materialNoDepth = this.createMaterial(false);\n\t\t}\n\n\t\treturn this._materialNoDepth;\n\t}\n\n\tgetBatch(layer, depthTest) {\n\t\tlet batches = this.batchesMap.get(layer);\n\n\t\tif (!batches) {\n\t\t\tbatches = new ImmediateBatches(this.device);\n\t\t\tthis.batchesMap.set(layer, batches);\n\t\t}\n\n\t\tthis.allBatches.add(batches);\n\t\tconst material = depthTest ? this.materialDepth : this.materialNoDepth;\n\t\treturn batches.getBatch(material, layer);\n\t}\n\n\tstatic getTextureVS() {\n\t\treturn `\n\t\t\t\t\t\tattribute vec2 aPosition;\n\t\t\t\t\t\tuniform mat4 matrix_model;\n\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\tvoid main(void) {\n\t\t\t\t\t\t\t\tgl_Position = matrix_model * vec4(aPosition, 0, 1);\n\t\t\t\t\t\t\t\tuv0 = aPosition.xy + 0.5;\n\t\t\t\t\t\t}\n\t\t\t\t`;\n\t}\n\n\tgetTextureShader() {\n\t\tif (!this.textureShader) {\n\t\t\tconst shaderDefinition = {\n\t\t\t\tattributes: {\n\t\t\t\t\taPosition: SEMANTIC_POSITION\n\t\t\t\t},\n\t\t\t\tvshader: Immediate.getTextureVS(),\n\t\t\t\tfshader: `\n\t\t\t\t\t\t\t\t\t\tprecision lowp float;\n\t\t\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\t\t\tuniform sampler2D colorMap;\n\t\t\t\t\t\t\t\t\t\tvoid main (void) {\n\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t`\n\t\t\t};\n\t\t\tthis.textureShader = new Shader(this.device, shaderDefinition);\n\t\t}\n\n\t\treturn this.textureShader;\n\t}\n\n\tgetDepthTextureShader() {\n\t\tif (!this.depthTextureShader) {\n\t\t\tconst gl2 = this.device.webgl2 ? \"#define GL2\" : \"\";\n\t\t\tconst shaderDefinition = {\n\t\t\t\tattributes: {\n\t\t\t\t\taPosition: SEMANTIC_POSITION\n\t\t\t\t},\n\t\t\t\tvshader: Immediate.getTextureVS(),\n\t\t\t\tfshader: `\n\t\t\t\t\t\t\t\t\t\tprecision ${this.device.precision} float;\n\t\t\t\t\t\t\t\t\t\t${gl2}\n\t\t\t\t\t\t\t\t\t\t${shaderChunks.screenDepthPS}\n\t\t\t\t\t\t\t\t\t\tvarying vec2 uv0;\n\t\t\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\t\t\t\tfloat depth = getLinearScreenDepth(uv0) * camera_params.x;\n\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t`\n\t\t\t};\n\t\t\tthis.depthTextureShader = new Shader(this.device, shaderDefinition);\n\t\t}\n\n\t\treturn this.depthTextureShader;\n\t}\n\n\tgetQuadMesh() {\n\t\tif (!this.quadMesh) {\n\t\t\tthis.quadMesh = new Mesh(this.device);\n\t\t\tthis.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);\n\t\t\tthis.quadMesh.update(PRIMITIVE_TRISTRIP);\n\t\t}\n\n\t\treturn this.quadMesh;\n\t}\n\n\tdrawMesh(material, matrix, mesh, meshInstance, layer) {\n\t\tif (!meshInstance) {\n\t\t\tconst graphNode = this.getGraphNode(matrix);\n\t\t\tmeshInstance = new MeshInstance(mesh, material, graphNode);\n\t\t}\n\n\t\tlet layerMeshInstances = this.layerMeshInstances.get(layer);\n\n\t\tif (!layerMeshInstances) {\n\t\t\tlayerMeshInstances = [];\n\t\t\tthis.layerMeshInstances.set(layer, layerMeshInstances);\n\t\t}\n\n\t\tlayerMeshInstances.push(meshInstance);\n\t}\n\n\tdrawWireAlignedBox(min, max, color, depthTest, layer) {\n\t\ttempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);\n\t\tconst batch = this.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(tempPoints, color);\n\t\ttempPoints.length = 0;\n\t}\n\n\tdrawWireSphere(center, radius, color, numSegments, depthTest, layer) {\n\t\tconst step = 2 * Math.PI / numSegments;\n\t\tlet angle = 0;\n\n\t\tfor (let i = 0; i < numSegments; i++) {\n\t\t\tconst sin0 = Math.sin(angle);\n\t\t\tconst cos0 = Math.cos(angle);\n\t\t\tangle += step;\n\t\t\tconst sin1 = Math.sin(angle);\n\t\t\tconst cos1 = Math.cos(angle);\n\t\t\ttempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);\n\t\t\ttempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);\n\t\t\ttempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);\n\t\t\ttempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);\n\t\t\ttempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);\n\t\t\ttempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);\n\t\t}\n\n\t\tconst batch = this.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(tempPoints, color);\n\t\ttempPoints.length = 0;\n\t}\n\n\tgetGraphNode(matrix) {\n\t\tconst graphNode = new GraphNode();\n\t\tgraphNode.worldTransform = matrix;\n\t\tgraphNode._dirtyWorld = graphNode._dirtyNormal = false;\n\t\treturn graphNode;\n\t}\n\n\tonPreRenderLayer(layer, visibleList, transparent) {\n\t\tthis.batchesMap.forEach((batches, batchLayer) => {\n\t\t\tif (batchLayer === layer) {\n\t\t\t\tbatches.onPreRender(visibleList, transparent);\n\t\t\t}\n\t\t});\n\n\t\tif (!this.updatedLayers.has(layer)) {\n\t\t\tthis.updatedLayers.add(layer);\n\t\t\tconst meshInstances = this.layerMeshInstances.get(layer);\n\n\t\t\tif (meshInstances) {\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tvisibleList.list[visibleList.length + i] = meshInstances[i];\n\t\t\t\t}\n\n\t\t\t\tvisibleList.length += meshInstances.length;\n\t\t\t\tmeshInstances.length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tonPostRender() {\n\t\tthis.allBatches.clear();\n\t\tthis.updatedLayers.clear();\n\t}\n\n}\n\nclass Scene extends EventHandler {\n\tconstructor(graphicsDevice) {\n\t\tsuper();\n\t\tthis.ambientBake = false;\n\t\tthis.ambientBakeOcclusionBrightness = 0;\n\t\tthis.ambientBakeOcclusionContrast = 0;\n\t\tthis.ambientLight = new Color(0, 0, 0);\n\t\tthis.exposure = 1;\n\t\tthis.fogColor = new Color(0, 0, 0);\n\t\tthis.fogDensity = 0;\n\t\tthis.fogEnd = 1000;\n\t\tthis.fogStart = 1;\n\t\tthis.lightmapSizeMultiplier = 1;\n\t\tthis.lightmapMaxResolution = 2048;\n\t\tthis.lightmapMode = BAKE_COLORDIR;\n\t\tthis.lightmapFilterEnabled = false;\n\t\tthis.root = null;\n\t\tthis.device = graphicsDevice || getApplication().graphicsDevice;\n\t\tthis._gravity = new Vec3(0, -9.8, 0);\n\t\tthis._layers = null;\n\t\tthis._fog = FOG_NONE;\n\t\tthis._gammaCorrection = GAMMA_SRGB;\n\t\tthis._toneMapping = 0;\n\t\tthis._skyboxCubeMap = null;\n\t\tthis._prefilteredCubemaps = [null, null, null, null, null, null];\n\t\tthis._envAtlas = null;\n\t\tthis._internalEnvAtlas = null;\n\t\tthis.skyboxModel = null;\n\t\tthis._skyboxIntensity = 1;\n\t\tthis._skyboxMip = 0;\n\t\tthis._skyboxRotation = new Quat();\n\t\tthis._skyboxRotationMat3 = null;\n\t\tthis._skyboxRotationMat4 = null;\n\t\tthis._ambientBakeNumSamples = 1;\n\t\tthis._ambientBakeSpherePart = 0.4;\n\t\tthis._lightmapFilterRange = 10;\n\t\tthis._lightmapFilterSmoothness = 0.2;\n\t\tthis._clusteredLightingEnabled = false;\n\t\tthis._lightingParams = new LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, () => {\n\t\t\tthis._layers._dirtyLights = true;\n\t\t});\n\t\tthis._stats = {\n\t\t\tmeshInstances: 0,\n\t\t\tlights: 0,\n\t\t\tdynamicLights: 0,\n\t\t\tbakedLights: 0,\n\t\t\tlastStaticPrepareFullTime: 0,\n\t\t\tlastStaticPrepareSearchTime: 0,\n\t\t\tlastStaticPrepareWriteTime: 0,\n\t\t\tlastStaticPrepareTriAabbTime: 0,\n\t\t\tlastStaticPrepareCombineTime: 0,\n\t\t\tupdateShadersTime: 0\n\t\t};\n\t\tthis.updateShaders = true;\n\t\tthis._shaderVersion = 0;\n\t\tthis._statsUpdated = false;\n\t\tthis._models = [];\n\t\tthis.immediate = new Immediate(this.device);\n\t}\n\n\tget defaultDrawLayer() {\n\t\treturn this.layers.getLayerById(LAYERID_IMMEDIATE);\n\t}\n\n\tset ambientBakeNumSamples(value) {\n\t\tthis._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);\n\t}\n\n\tget ambientBakeNumSamples() {\n\t\treturn this._ambientBakeNumSamples;\n\t}\n\n\tset ambientBakeSpherePart(value) {\n\t\tthis._ambientBakeSpherePart = math.clamp(value, 0.001, 1);\n\t}\n\n\tget ambientBakeSpherePart() {\n\t\treturn this._ambientBakeSpherePart;\n\t}\n\n\tset clusteredLightingEnabled(value) {\n\t\tif (this._clusteredLightingEnabled && !value) {\n\t\t\tconsole.error(\"Turning off enabled clustered lighting is not currently supported\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clusteredLightingEnabled = value;\n\t}\n\n\tget clusteredLightingEnabled() {\n\t\treturn this._clusteredLightingEnabled;\n\t}\n\n\tset drawCalls(value) {}\n\n\tget drawCalls() {\n\t\tlet drawCalls = this.layers._meshInstances;\n\n\t\tif (!drawCalls.length) {\n\t\t\tthis.layers._update(this.device, this.clusteredLightingEnabled);\n\n\t\t\tdrawCalls = this.layers._meshInstances;\n\t\t}\n\n\t\treturn drawCalls;\n\t}\n\n\tset envAtlas(value) {\n\t\tif (value !== this._envAtlas) {\n\t\t\tthis._envAtlas = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\n\tget envAtlas() {\n\t\treturn this._envAtlas;\n\t}\n\n\tset fog(type) {\n\t\tif (type !== this._fog) {\n\t\t\tthis._fog = type;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\n\tget fog() {\n\t\treturn this._fog;\n\t}\n\n\tset gammaCorrection(value) {\n\t\tif (value !== this._gammaCorrection) {\n\t\t\tthis._gammaCorrection = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\n\tget gammaCorrection() {\n\t\treturn this._gammaCorrection;\n\t}\n\n\tset layers(layers) {\n\t\tconst prev = this._layers;\n\t\tthis._layers = layers;\n\t\tthis.fire(\"set:layers\", prev, layers);\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tget lighting() {\n\t\treturn this._lightingParams;\n\t}\n\n\tset lightmapFilterRange(value) {\n\t\tthis._lightmapFilterRange = Math.max(value, 0.001);\n\t}\n\n\tget lightmapFilterRange() {\n\t\treturn this._lightmapFilterRange;\n\t}\n\n\tset lightmapFilterSmoothness(value) {\n\t\tthis._lightmapFilterSmoothness = Math.max(value, 0.001);\n\t}\n\n\tget lightmapFilterSmoothness() {\n\t\treturn this._lightmapFilterSmoothness;\n\t}\n\n\tset prefilteredCubemaps(value) {\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\t\tvalue = value || [];\n\t\tlet changed = false;\n\t\tlet complete = true;\n\n\t\tfor (let i = 0; i < 6; ++i) {\n\t\t\tconst v = value[i] || null;\n\n\t\t\tif (cubemaps[i] !== v) {\n\t\t\t\tcubemaps[i] = v;\n\t\t\t\tchanged = true;\n\t\t\t}\n\n\t\t\tcomplete = complete && !!cubemaps[i];\n\t\t}\n\n\t\tif (changed) {\n\t\t\tthis._resetSkyboxModel();\n\n\t\t\tif (complete) {\n\t\t\t\tthis._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {\n\t\t\t\t\ttarget: this._internalEnvAtlas\n\t\t\t\t});\n\n\t\t\t\tif (!this._envAtlas) {\n\t\t\t\t\tthis.envAtlas = this._internalEnvAtlas;\n\t\t\t\t}\n\t\t\t} else if (this._internalEnvAtlas) {\n\t\t\t\tif (this._envAtlas === this._internalEnvAtlas) {\n\t\t\t\t\tthis.envAtlas = null;\n\t\t\t\t}\n\n\t\t\t\tthis._internalEnvAtlas.destroy();\n\n\t\t\t\tthis._internalEnvAtlas = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget prefilteredCubemaps() {\n\t\treturn this._prefilteredCubemaps;\n\t}\n\n\tset skybox(value) {\n\t\tif (value !== this._skyboxCubeMap) {\n\t\t\tthis._skyboxCubeMap = value;\n\n\t\t\tthis._resetSkyboxModel();\n\t\t}\n\t}\n\n\tget skybox() {\n\t\treturn this._skyboxCubeMap;\n\t}\n\n\tset skyboxIntensity(value) {\n\t\tif (value !== this._skyboxIntensity) {\n\t\t\tthis._skyboxIntensity = value;\n\n\t\t\tthis._resetSkyboxModel();\n\t\t}\n\t}\n\n\tget skyboxIntensity() {\n\t\treturn this._skyboxIntensity;\n\t}\n\n\tset skyboxMip(value) {\n\t\tif (value !== this._skyboxMip) {\n\t\t\tthis._skyboxMip = value;\n\n\t\t\tthis._resetSkyboxModel();\n\t\t}\n\t}\n\n\tget skyboxMip() {\n\t\treturn this._skyboxMip;\n\t}\n\n\tset skyboxRotation(value) {\n\t\tif (!this._skyboxRotation.equals(value)) {\n\t\t\tthis._skyboxRotation.copy(value);\n\n\t\t\tthis._resetSkyboxModel();\n\t\t}\n\t}\n\n\tget skyboxRotation() {\n\t\treturn this._skyboxRotation;\n\t}\n\n\tset toneMapping(value) {\n\t\tif (value !== this._toneMapping) {\n\t\t\tthis._toneMapping = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\n\tget toneMapping() {\n\t\treturn this._toneMapping;\n\t}\n\n\tdestroy() {\n\t\tthis._resetSkyboxModel();\n\n\t\tthis.root = null;\n\t\tthis.off();\n\t}\n\n\tdrawLine(start, end, color = Color.WHITE, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLines([start, end], [color, color]);\n\t}\n\n\tdrawLines(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLines(positions, colors);\n\t}\n\n\tdrawLineArrays(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(positions, colors);\n\t}\n\n\tapplySettings(settings) {\n\t\tthis._gravity.set(settings.physics.gravity[0], settings.physics.gravity[1], settings.physics.gravity[2]);\n\n\t\tthis.ambientLight.set(settings.render.global_ambient[0], settings.render.global_ambient[1], settings.render.global_ambient[2]);\n\t\tthis._fog = settings.render.fog;\n\t\tthis.fogColor.set(settings.render.fog_color[0], settings.render.fog_color[1], settings.render.fog_color[2]);\n\t\tthis.fogStart = settings.render.fog_start;\n\t\tthis.fogEnd = settings.render.fog_end;\n\t\tthis.fogDensity = settings.render.fog_density;\n\t\tthis._gammaCorrection = settings.render.gamma_correction;\n\t\tthis._toneMapping = settings.render.tonemapping;\n\t\tthis.lightmapSizeMultiplier = settings.render.lightmapSizeMultiplier;\n\t\tthis.lightmapMaxResolution = settings.render.lightmapMaxResolution;\n\t\tthis.lightmapMode = settings.render.lightmapMode;\n\t\tthis.exposure = settings.render.exposure;\n\t\tthis._skyboxIntensity = settings.render.skyboxIntensity === undefined ? 1 : settings.render.skyboxIntensity;\n\t\tthis._skyboxMip = settings.render.skyboxMip === undefined ? 0 : settings.render.skyboxMip;\n\n\t\tif (settings.render.skyboxRotation) {\n\t\t\tthis._skyboxRotation.setFromEulerAngles(settings.render.skyboxRotation[0], settings.render.skyboxRotation[1], settings.render.skyboxRotation[2]);\n\t\t}\n\n\t\tthis._resetSkyboxModel();\n\t}\n\n\t_getSkyboxTex() {\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\n\t\tif (this._skyboxMip) {\n\t\t\tconst skyboxMapping = [0, 1, 3, 4, 5, 6];\n\t\t\treturn cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;\n\t\t}\n\n\t\treturn this._skyboxCubeMap || cubemaps[0] || this._envAtlas;\n\t}\n\n\t_updateSkybox(device) {\n\t\tif (this.skyboxModel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst skyboxTex = this._getSkyboxTex();\n\n\t\tif (!skyboxTex) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst material = new Material();\n\t\tconst scene = this;\n\n\t\tmaterial.updateShader = function (dev, sc, defs, staticLightList, pass) {\n\t\t\tconst library = device.getProgramLibrary();\n\n\t\t\tif (skyboxTex.cubemap) {\n\t\t\t\tthis.shader = library.getProgram('skybox', {\n\t\t\t\t\ttype: 'cubemap',\n\t\t\t\t\trgbm: skyboxTex.type === TEXTURETYPE_RGBM,\n\t\t\t\t\thdr: skyboxTex.type === TEXTURETYPE_RGBM || skyboxTex.format === PIXELFORMAT_RGBA32F,\n\t\t\t\t\tuseIntensity: scene.skyboxIntensity !== 1,\n\t\t\t\t\tmip: skyboxTex.fixCubemapSeams ? scene.skyboxMip : 0,\n\t\t\t\t\tfixSeams: skyboxTex.fixCubemapSeams,\n\t\t\t\t\tgamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,\n\t\t\t\t\ttoneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.shader = library.getProgram('skybox', {\n\t\t\t\t\ttype: 'envAtlas',\n\t\t\t\t\tencoding: skyboxTex.encoding,\n\t\t\t\t\tuseIntensity: scene.skyboxIntensity !== 1,\n\t\t\t\t\tgamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,\n\t\t\t\t\ttoneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tmaterial.updateShader();\n\n\t\tif (skyboxTex.cubemap) {\n\t\t\tmaterial.setParameter(\"texture_cubeMap\", skyboxTex);\n\t\t} else {\n\t\t\tmaterial.setParameter(\"texture_envAtlas\", skyboxTex);\n\t\t\tmaterial.setParameter(\"mipLevel\", this._skyboxMip);\n\t\t}\n\n\t\tif (!this.skyboxRotation.equals(Quat.IDENTITY)) {\n\t\t\tif (!this._skyboxRotationMat4) this._skyboxRotationMat4 = new Mat4();\n\t\t\tif (!this._skyboxRotationMat3) this._skyboxRotationMat3 = new Mat3();\n\n\t\t\tthis._skyboxRotationMat4.setTRS(Vec3.ZERO, this._skyboxRotation, Vec3.ONE);\n\n\t\t\tthis._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3);\n\n\t\t\tmaterial.setParameter(\"cubeMapRotationMatrix\", this._skyboxRotationMat3.data);\n\t\t} else {\n\t\t\tmaterial.setParameter(\"cubeMapRotationMatrix\", Mat3.IDENTITY.data);\n\t\t}\n\n\t\tmaterial.cull = CULLFACE_FRONT;\n\t\tmaterial.depthWrite = false;\n\t\tconst skyLayer = this.layers.getLayerById(LAYERID_SKYBOX);\n\n\t\tif (skyLayer) {\n\t\t\tconst node = new GraphNode(\"Skybox\");\n\t\t\tconst mesh = createBox(device);\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, node);\n\t\t\tmeshInstance.cull = false;\n\t\t\tmeshInstance._noDepthDrawGl1 = true;\n\t\t\tmeshInstance.pick = false;\n\t\t\tconst model = new Model();\n\t\t\tmodel.graph = node;\n\t\t\tmodel.meshInstances = [meshInstance];\n\t\t\tthis.skyboxModel = model;\n\t\t\tskyLayer.addMeshInstances(model.meshInstances);\n\t\t\tthis.skyLayer = skyLayer;\n\t\t\tthis.fire(\"set:skybox\", skyboxTex);\n\t\t}\n\t}\n\n\t_resetSkyboxModel() {\n\t\tif (this.skyboxModel) {\n\t\t\tthis.skyLayer.removeMeshInstances(this.skyboxModel.meshInstances);\n\t\t\tthis.skyboxModel.destroy();\n\t\t}\n\n\t\tthis.skyboxModel = null;\n\t\tthis.updateShaders = true;\n\t}\n\n\tsetSkybox(cubemaps) {\n\t\tif (!cubemaps) {\n\t\t\tthis.skybox = null;\n\t\t\tthis.prefilteredCubemaps = [null, null, null, null, null, null];\n\t\t} else {\n\t\t\tthis.skybox = cubemaps[0] || null;\n\t\t\tthis.prefilteredCubemaps = cubemaps.slice(1);\n\t\t}\n\t}\n\n\taddModel(model) {\n\t\tif (this.containsModel(model)) return;\n\t\tconst layer = this.layers.getLayerById(LAYERID_WORLD);\n\t\tif (!layer) return;\n\t\tlayer.addMeshInstances(model.meshInstances);\n\n\t\tthis._models.push(model);\n\t}\n\n\taddShadowCaster(model) {\n\t\tconst layer = this.layers.getLayerById(LAYERID_WORLD);\n\t\tif (!layer) return;\n\t\tlayer.addShadowCasters(model.meshInstances);\n\t}\n\n\tremoveModel(model) {\n\t\tconst index = this._models.indexOf(model);\n\n\t\tif (index !== -1) {\n\t\t\tconst layer = this.layers.getLayerById(LAYERID_WORLD);\n\t\t\tif (!layer) return;\n\t\t\tlayer.removeMeshInstances(model.meshInstances);\n\n\t\t\tthis._models.splice(index, 1);\n\t\t}\n\t}\n\n\tremoveShadowCasters(model) {\n\t\tconst layer = this.layers.getLayerById(LAYERID_WORLD);\n\t\tif (!layer) return;\n\t\tlayer.removeShadowCasters(model.meshInstances);\n\t}\n\n\tcontainsModel(model) {\n\t\treturn this._models.indexOf(model) >= 0;\n\t}\n\n\tgetModels(model) {\n\t\treturn this._models;\n\t}\n\n}\n\nfunction hasAudioContext() {\n\treturn !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');\n}\n\nclass Channel {\n\tconstructor(manager, sound, options = {}) {\n\t\tthis.volume = options.volume === undefined ? 1 : options.volume;\n\t\tthis.loop = options.loop === undefined ? false : options.loop;\n\t\tthis.pitch = options.pitch === undefined ? 1 : options.pitch;\n\t\tthis.sound = sound;\n\t\tthis.paused = false;\n\t\tthis.suspended = false;\n\t\tthis.manager = manager;\n\t\tthis.source = null;\n\n\t\tif (hasAudioContext()) {\n\t\t\tthis.startTime = 0;\n\t\t\tthis.startOffset = 0;\n\t\t\tconst context = manager.context;\n\t\t\tthis.gain = context.createGain();\n\t\t} else if (sound.audio) {\n\t\t\tthis.source = sound.audio.cloneNode(false);\n\t\t\tthis.source.pause();\n\t\t}\n\t}\n\n\tgetVolume() {\n\t\treturn this.volume;\n\t}\n\n\tgetLoop() {\n\t\treturn this.loop;\n\t}\n\n\tsetLoop(loop) {\n\t\tthis.loop = loop;\n\n\t\tif (this.source) {\n\t\t\tthis.source.loop = loop;\n\t\t}\n\t}\n\n\tgetPitch() {\n\t\treturn this.pitch;\n\t}\n\n\tonManagerVolumeChange() {\n\t\tthis.setVolume(this.getVolume());\n\t}\n\n\tonManagerSuspend() {\n\t\tif (this.isPlaying() && !this.suspended) {\n\t\t\tthis.suspended = true;\n\t\t\tthis.pause();\n\t\t}\n\t}\n\n\tonManagerResume() {\n\t\tif (this.suspended) {\n\t\t\tthis.suspended = false;\n\t\t\tthis.unpause();\n\t\t}\n\t}\n\n\tplay() {\n\t\tif (this.source) {\n\t\t\tthrow new Error('Call stop() before calling play()');\n\t\t}\n\n\t\tthis._createSource();\n\n\t\tif (!this.source) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.startTime = this.manager.context.currentTime;\n\t\tthis.source.start(0, this.startOffset % this.source.buffer.duration);\n\t\tthis.setVolume(this.volume);\n\t\tthis.setLoop(this.loop);\n\t\tthis.setPitch(this.pitch);\n\t\tthis.manager.on('volumechange', this.onManagerVolumeChange, this);\n\t\tthis.manager.on('suspend', this.onManagerSuspend, this);\n\t\tthis.manager.on('resume', this.onManagerResume, this);\n\t\tif (this.manager.suspended) this.onManagerSuspend();\n\t}\n\n\tpause() {\n\t\tif (this.source) {\n\t\t\tthis.paused = true;\n\t\t\tthis.startOffset += this.manager.context.currentTime - this.startTime;\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t}\n\t}\n\n\tunpause() {\n\t\tif (this.source || !this.paused) {\n\t\t\tconsole.warn('Call pause() before unpausing.');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._createSource();\n\n\t\tif (!this.source) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.startTime = this.manager.context.currentTime;\n\t\tthis.source.start(0, this.startOffset % this.source.buffer.duration);\n\t\tthis.setVolume(this.volume);\n\t\tthis.setLoop(this.loop);\n\t\tthis.setPitch(this.pitch);\n\t\tthis.paused = false;\n\t}\n\n\tstop() {\n\t\tif (this.source) {\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t}\n\n\t\tthis.manager.off('volumechange', this.onManagerVolumeChange, this);\n\t\tthis.manager.off('suspend', this.onManagerSuspend, this);\n\t\tthis.manager.off('resume', this.onManagerResume, this);\n\t}\n\n\tsetVolume(volume) {\n\t\tvolume = math.clamp(volume, 0, 1);\n\t\tthis.volume = volume;\n\n\t\tif (this.gain) {\n\t\t\tthis.gain.gain.value = volume * this.manager.volume;\n\t\t}\n\t}\n\n\tsetPitch(pitch) {\n\t\tthis.pitch = pitch;\n\n\t\tif (this.source) {\n\t\t\tthis.source.playbackRate.value = pitch;\n\t\t}\n\t}\n\n\tisPlaying() {\n\t\treturn !this.paused && this.source.playbackState === this.source.PLAYING_STATE;\n\t}\n\n\tgetDuration() {\n\t\treturn this.source ? this.source.buffer.duration : 0;\n\t}\n\n\t_createSource() {\n\t\tconst context = this.manager.context;\n\n\t\tif (this.sound.buffer) {\n\t\t\tthis.source = context.createBufferSource();\n\t\t\tthis.source.buffer = this.sound.buffer;\n\t\t\tthis.source.connect(this.gain);\n\t\t\tthis.gain.connect(context.destination);\n\n\t\t\tif (!this.loop) {\n\t\t\t\tthis.source.onended = this.pause.bind(this);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nif (!hasAudioContext()) {\n\tObject.assign(Channel.prototype, {\n\t\tplay: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.setVolume(this.volume);\n\t\t\t\tthis.setLoop(this.loop);\n\t\t\t\tthis.setPitch(this.pitch);\n\t\t\t\tthis.source.play();\n\t\t\t}\n\n\t\t\tthis.manager.on('volumechange', this.onManagerVolumeChange, this);\n\t\t\tthis.manager.on('suspend', this.onManagerSuspend, this);\n\t\t\tthis.manager.on('resume', this.onManagerResume, this);\n\t\t\tif (this.manager.suspended) this.onManagerSuspend();\n\t\t},\n\t\tpause: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = true;\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\t\t},\n\t\tunpause: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.source.play();\n\t\t\t}\n\t\t},\n\t\tstop: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\n\t\t\tthis.manager.off('volumechange', this.onManagerVolumeChange, this);\n\t\t\tthis.manager.off('suspend', this.onManagerSuspend, this);\n\t\t\tthis.manager.off('resume', this.onManagerResume, this);\n\t\t},\n\t\tsetVolume: function (volume) {\n\t\t\tvolume = math.clamp(volume, 0, 1);\n\t\t\tthis.volume = volume;\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.volume = volume * this.manager.volume;\n\t\t\t}\n\t\t},\n\t\tsetPitch: function (pitch) {\n\t\t\tthis.pitch = pitch;\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.playbackRate = pitch;\n\t\t\t}\n\t\t},\n\t\tgetDuration: function () {\n\t\t\treturn this.source && !isNaN(this.source.duration) ? this.source.duration : 0;\n\t\t},\n\t\tisPlaying: function () {\n\t\t\treturn !this.source.paused;\n\t\t}\n\t});\n}\n\nconst DISTANCE_LINEAR = 'linear';\nconst DISTANCE_INVERSE = 'inverse';\nconst DISTANCE_EXPONENTIAL = 'exponential';\n\nconst MAX_DISTANCE$1 = 10000;\n\nclass Channel3d extends Channel {\n\tconstructor(manager, sound, options) {\n\t\tsuper(manager, sound, options);\n\t\tthis.position = new Vec3();\n\t\tthis.velocity = new Vec3();\n\n\t\tif (hasAudioContext()) {\n\t\t\tthis.panner = manager.context.createPanner();\n\t\t} else {\n\t\t\tthis.maxDistance = MAX_DISTANCE$1;\n\t\t\tthis.minDistance = 1;\n\t\t\tthis.rollOffFactor = 1;\n\t\t\tthis.distanceModel = DISTANCE_INVERSE;\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\treturn this.position;\n\t}\n\n\tgetVelocity() {\n\t\treturn this.velocity;\n\t}\n\n\tsetPosition(position) {\n\t\tthis.position.copy(position);\n\t\tthis.panner.setPosition(position.x, position.y, position.z);\n\t}\n\n\tsetVelocity(velocity) {\n\t\tthis.velocity.copy(velocity);\n\t\tthis.panner.setVelocity(velocity.x, velocity.y, velocity.z);\n\t}\n\n\tgetMaxDistance() {\n\t\treturn this.panner.maxDistance;\n\t}\n\n\tsetMaxDistance(max) {\n\t\tthis.panner.maxDistance = max;\n\t}\n\n\tgetMinDistance() {\n\t\treturn this.panner.refDistance;\n\t}\n\n\tsetMinDistance(min) {\n\t\tthis.panner.refDistance = min;\n\t}\n\n\tgetRollOffFactor() {\n\t\treturn this.panner.rolloffFactor;\n\t}\n\n\tsetRollOffFactor(factor) {\n\t\tthis.panner.rolloffFactor = factor;\n\t}\n\n\tgetDistanceModel() {\n\t\treturn this.pannel.distanceModel;\n\t}\n\n\tsetDistanceModel(distanceModel) {\n\t\tthis.panner.distanceModel = distanceModel;\n\t}\n\n\t_createSource() {\n\t\tconst context = this.manager.context;\n\t\tthis.source = context.createBufferSource();\n\t\tthis.source.buffer = this.sound.buffer;\n\t\tthis.source.connect(this.panner);\n\t\tthis.panner.connect(this.gain);\n\t\tthis.gain.connect(context.destination);\n\n\t\tif (!this.loop) {\n\t\t\tthis.source.onended = this.pause.bind(this);\n\t\t}\n\t}\n\n}\n\nif (!hasAudioContext()) {\n\tlet offset = new Vec3();\n\n\tconst fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {\n\t\toffset = offset.sub2(posOne, posTwo);\n\t\tconst distance = offset.length();\n\n\t\tif (distance < refDistance) {\n\t\t\treturn 1;\n\t\t} else if (distance > maxDistance) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet result = 0;\n\n\t\tif (distanceModel === DISTANCE_LINEAR) {\n\t\t\tresult = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);\n\t\t} else if (distanceModel === DISTANCE_INVERSE) {\n\t\t\tresult = refDistance / (refDistance + rolloffFactor * (distance - refDistance));\n\t\t} else if (distanceModel === DISTANCE_EXPONENTIAL) {\n\t\t\tresult = Math.pow(distance / refDistance, -rolloffFactor);\n\t\t}\n\n\t\treturn math.clamp(result, 0, 1);\n\t};\n\n\tObject.assign(Channel3d.prototype, {\n\t\tsetPosition: function (position) {\n\t\t\tthis.position.copy(position);\n\n\t\t\tif (this.source) {\n\t\t\t\tconst listener = this.manager.listener;\n\t\t\t\tconst lpos = listener.getPosition();\n\t\t\t\tconst factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);\n\t\t\t\tconst v = this.getVolume();\n\t\t\t\tthis.source.volume = v * factor;\n\t\t\t}\n\t\t},\n\t\tsetVelocity: function (velocity) {\n\t\t\tthis.velocity.copy(velocity);\n\t\t},\n\t\tgetMaxDistance: function () {\n\t\t\treturn this.maxDistance;\n\t\t},\n\t\tsetMaxDistance: function (max) {\n\t\t\tthis.maxDistance = max;\n\t\t},\n\t\tgetMinDistance: function () {\n\t\t\treturn this.minDistance;\n\t\t},\n\t\tsetMinDistance: function (min) {\n\t\t\tthis.minDistance = min;\n\t\t},\n\t\tgetRollOffFactor: function () {\n\t\t\treturn this.rollOffFactor;\n\t\t},\n\t\tsetRollOffFactor: function (factor) {\n\t\t\tthis.rollOffFactor = factor;\n\t\t},\n\t\tgetDistanceModel: function () {\n\t\t\treturn this.distanceModel;\n\t\t},\n\t\tsetDistanceModel: function (distanceModel) {\n\t\t\tthis.distanceModel = distanceModel;\n\t\t}\n\t});\n}\n\nclass Listener {\n\tconstructor(manager) {\n\t\tthis._manager = manager;\n\t\tthis.position = new Vec3();\n\t\tthis.velocity = new Vec3();\n\t\tthis.orientation = new Mat4();\n\t}\n\n\tgetPosition() {\n\t\treturn this.position;\n\t}\n\n\tsetPosition(position) {\n\t\tthis.position.copy(position);\n\t\tconst listener = this.listener;\n\n\t\tif (listener) {\n\t\t\tlistener.setPosition(position.x, position.y, position.z);\n\t\t}\n\t}\n\n\tgetVelocity() {\n\t\treturn this.velocity;\n\t}\n\n\tsetVelocity(velocity) {\n\t\tthis.velocity.copy(velocity);\n\t\tconst listener = this.listener;\n\n\t\tif (listener) {\n\t\t\tlistener.setPosition(velocity.x, velocity.y, velocity.z);\n\t\t}\n\t}\n\n\tsetOrientation(orientation) {\n\t\tthis.orientation.copy(orientation);\n\t\tconst listener = this.listener;\n\n\t\tif (listener) {\n\t\t\tlistener.setOrientation(-orientation.data[8], -orientation.data[9], -orientation.data[10], orientation.data[4], orientation.data[5], orientation.data[6]);\n\t\t}\n\t}\n\n\tgetOrientation() {\n\t\treturn this.orientation;\n\t}\n\n\tget listener() {\n\t\tconst context = this._manager.context;\n\t\treturn context ? context.listener : null;\n\t}\n\n}\n\nclass SoundManager extends EventHandler {\n\tconstructor(options) {\n\t\tsuper();\n\t\tthis._context = null;\n\t\tthis._forceWebAudioApi = options.forceWebAudioApi;\n\t\tthis._resumeContext = null;\n\t\tthis._unlock = null;\n\n\t\tif (hasAudioContext() || this._forceWebAudioApi) {\n\t\t\tthis._resumeContext = () => {\n\t\t\t\twindow.removeEventListener('mousedown', this._resumeContext);\n\t\t\t\twindow.removeEventListener('touchend', this._resumeContext);\n\n\t\t\t\tif (this.context) {\n\t\t\t\t\tthis.context.resume();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twindow.addEventListener('mousedown', this._resumeContext);\n\t\t\twindow.addEventListener('touchend', this._resumeContext);\n\n\t\t\tif (platform.ios) {\n\t\t\t\tthis._unlock = () => {\n\t\t\t\t\twindow.removeEventListener('touchend', this._unlock);\n\t\t\t\t\tconst context = this.context;\n\n\t\t\t\t\tif (context) {\n\t\t\t\t\t\tconst buffer = context.createBuffer(1, 1, 44100);\n\t\t\t\t\t\tconst source = context.createBufferSource();\n\t\t\t\t\t\tsource.buffer = buffer;\n\t\t\t\t\t\tsource.connect(context.destination);\n\t\t\t\t\t\tsource.start(0);\n\t\t\t\t\t\tsource.disconnect();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\twindow.addEventListener('touchend', this._unlock);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn('No support for 3D audio found');\n\t\t}\n\n\t\tthis.listener = new Listener(this);\n\t\tthis._volume = 1;\n\t\tthis.suspended = false;\n\t}\n\n\tset volume(volume) {\n\t\tvolume = math.clamp(volume, 0, 1);\n\t\tthis._volume = volume;\n\t\tthis.fire('volumechange', volume);\n\t}\n\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\n\tget context() {\n\t\tif (!this._context) {\n\t\t\tif (hasAudioContext() || this._forceWebAudioApi) {\n\t\t\t\tif (typeof AudioContext !== 'undefined') {\n\t\t\t\t\tthis._context = new AudioContext();\n\t\t\t\t} else if (typeof webkitAudioContext !== 'undefined') {\n\t\t\t\t\tthis._context = new webkitAudioContext();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._context;\n\t}\n\n\tsuspend() {\n\t\tthis.suspended = true;\n\t\tthis.fire('suspend');\n\t}\n\n\tresume() {\n\t\tconst resumeFunction = () => {\n\t\t\tthis.suspended = false;\n\t\t\tthis.fire('resume');\n\t\t};\n\n\t\tif ((hasAudioContext() || this._forceWebAudioApi) && (this.context.state === 'interrupted' || this.context.state === 'suspended')) {\n\t\t\tthis.context.resume().then(resumeFunction);\n\t\t} else resumeFunction();\n\t}\n\n\tdestroy() {\n\t\tif (this._resumeContext) {\n\t\t\twindow.removeEventListener('mousedown', this._resumeContext);\n\t\t\twindow.removeEventListener('touchend', this._resumeContext);\n\t\t}\n\n\t\tif (this._unlock) {\n\t\t\twindow.removeEventListener('touchend', this._unlock);\n\t\t}\n\n\t\tthis.fire('destroy');\n\n\t\tif (this._context && this._context.close) {\n\t\t\tthis._context.close();\n\n\t\t\tthis._context = null;\n\t\t}\n\t}\n\n\tplaySound(sound, options = {}) {\n\t\tlet channel = null;\n\n\t\tif (Channel) {\n\t\t\tchannel = new Channel(this, sound, options);\n\t\t\tchannel.play();\n\t\t}\n\n\t\treturn channel;\n\t}\n\n\tplaySound3d(sound, position, options = {}) {\n\t\tlet channel = null;\n\n\t\tif (Channel3d) {\n\t\t\tchannel = new Channel3d(this, sound, options);\n\t\t\tchannel.setPosition(position);\n\n\t\t\tif (options.volume) {\n\t\t\t\tchannel.setVolume(options.volume);\n\t\t\t}\n\n\t\t\tif (options.loop) {\n\t\t\t\tchannel.setLoop(options.loop);\n\t\t\t}\n\n\t\t\tif (options.maxDistance) {\n\t\t\t\tchannel.setMaxDistance(options.maxDistance);\n\t\t\t}\n\n\t\t\tif (options.minDistance) {\n\t\t\t\tchannel.setMinDistance(options.minDistance);\n\t\t\t}\n\n\t\t\tif (options.rollOffFactor) {\n\t\t\t\tchannel.setRollOffFactor(options.rollOffFactor);\n\t\t\t}\n\n\t\t\tif (options.distanceModel) {\n\t\t\t\tchannel.setDistanceModel(options.distanceModel);\n\t\t\t}\n\n\t\t\tchannel.play();\n\t\t}\n\n\t\treturn channel;\n\t}\n\n}\n\nclass Key {\n\tconstructor(time, position, rotation, scale) {\n\t\tthis.time = time;\n\t\tthis.position = position;\n\t\tthis.rotation = rotation;\n\t\tthis.scale = scale;\n\t}\n\n}\n\nclass Node {\n\tconstructor() {\n\t\tthis._name = \"\";\n\t\tthis._keys = [];\n\t}\n\n}\n\nclass Animation {\n\tconstructor() {\n\t\tthis.name = '';\n\t\tthis.duration = 0;\n\t\tthis._nodes = [];\n\t\tthis._nodeDict = {};\n\t}\n\n\tgetNode(name) {\n\t\treturn this._nodeDict[name];\n\t}\n\n\taddNode(node) {\n\t\tthis._nodes.push(node);\n\n\t\tthis._nodeDict[node._name] = node;\n\t}\n\n\tget nodes() {\n\t\treturn this._nodes;\n\t}\n\n}\n\nclass MorphTarget {\n\tconstructor(options) {\n\t\tif (arguments.length === 2) {\n\t\t\toptions = arguments[1];\n\t\t}\n\n\t\tthis.options = options;\n\t\tthis._name = options.name;\n\t\tthis._defaultWeight = options.defaultWeight || 0;\n\t\tthis.aabb = options.aabb;\n\n\t\tif (!this.aabb) {\n\t\t\tthis.aabb = new BoundingBox();\n\t\t\tif (options.deltaPositions) this.aabb.compute(options.deltaPositions);\n\t\t}\n\n\t\tthis.deltaPositions = options.deltaPositions;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tget defaultWeight() {\n\t\treturn this._defaultWeight;\n\t}\n\n\tget morphPositions() {\n\t\treturn !!this._vertexBufferPositions || !!this.texturePositions;\n\t}\n\n\tget morphNormals() {\n\t\treturn !!this._vertexBufferNormals || !!this.textureNormals;\n\t}\n\n\t_postInit() {\n\t\tthis.options = null;\n\t}\n\n\t_initVertexBuffers(graphicsDevice) {\n\t\tconst options = this.options;\n\t\tthis._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);\n\t\tthis._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);\n\n\t\tif (this._vertexBufferPositions) {\n\t\t\tthis.deltaPositions = this._vertexBufferPositions.lock();\n\t\t}\n\t}\n\n\t_createVertexBuffer(device, data, dataType = TYPE_FLOAT32) {\n\t\tif (data) {\n\t\t\tconst formatDesc = [{\n\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\tcomponents: 3,\n\t\t\t\ttype: dataType\n\t\t\t}];\n\t\t\treturn new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, BUFFER_STATIC, data);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_setTexture(name, texture) {\n\t\tthis[name] = texture;\n\t}\n\n\tdestroy() {\n\t\tif (this._vertexBufferPositions) {\n\t\t\tthis._vertexBufferPositions.destroy();\n\n\t\t\tthis._vertexBufferPositions = null;\n\t\t}\n\n\t\tif (this._vertexBufferNormals) {\n\t\t\tthis._vertexBufferNormals.destroy();\n\n\t\t\tthis._vertexBufferNormals = null;\n\t\t}\n\n\t\tif (this.texturePositions) {\n\t\t\tthis.texturePositions.destroy();\n\t\t\tthis.texturePositions = null;\n\t\t}\n\n\t\tif (this.textureNormals) {\n\t\t\tthis.textureNormals.destroy();\n\t\t\tthis.textureNormals = null;\n\t\t}\n\t}\n\n}\n\nclass Skin {\n\tconstructor(graphicsDevice, ibp, boneNames) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.inverseBindPose = ibp;\n\t\tthis.boneNames = boneNames;\n\t}\n\n}\n\nclass Render extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._meshes = null;\n\t}\n\n\tset meshes(value) {\n\t\tthis.decRefMeshes();\n\t\tthis._meshes = value;\n\t\tthis.incRefMeshes();\n\t\tthis.fire('set:meshes', value);\n\t}\n\n\tget meshes() {\n\t\treturn this._meshes;\n\t}\n\n\tdestroy() {\n\t\tthis.meshes = null;\n\t}\n\n\tdecRefMeshes() {\n\t\tif (this._meshes) {\n\t\t\tconst count = this._meshes.length;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst mesh = this._meshes[i];\n\n\t\t\t\tif (mesh) {\n\t\t\t\t\tmesh.decRefCount();\n\n\t\t\t\t\tif (mesh.refCount < 1) {\n\t\t\t\t\t\tmesh.destroy();\n\t\t\t\t\t\tthis._meshes[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tincRefMeshes() {\n\t\tif (this._meshes) {\n\t\t\tconst count = this._meshes.length;\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tif (this._meshes[i]) {\n\t\t\t\t\tthis._meshes[i].incRefCount();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimCurve {\n\tconstructor(paths, input, output, interpolation) {\n\t\tthis._paths = paths;\n\t\tthis._input = input;\n\t\tthis._output = output;\n\t\tthis._interpolation = interpolation;\n\t}\n\n\tget paths() {\n\t\treturn this._paths;\n\t}\n\n\tget input() {\n\t\treturn this._input;\n\t}\n\n\tget output() {\n\t\treturn this._output;\n\t}\n\n\tget interpolation() {\n\t\treturn this._interpolation;\n\t}\n\n}\n\nclass AnimData {\n\tconstructor(components, data) {\n\t\tthis._components = components;\n\t\tthis._data = data;\n\t}\n\n\tget components() {\n\t\treturn this._components;\n\t}\n\n\tget data() {\n\t\treturn this._data;\n\t}\n\n}\n\nclass AnimEvents {\n\tconstructor(events) {\n\t\tthis._events = [...events];\n\n\t\tthis._events.sort((a, b) => a.time - b.time);\n\t}\n\n\tget events() {\n\t\treturn this._events;\n\t}\n\n}\n\nclass AnimTrack {\n\tconstructor(name, duration, inputs, outputs, curves, animEvents = new AnimEvents([])) {\n\t\tthis._name = name;\n\t\tthis._duration = duration;\n\t\tthis._inputs = inputs;\n\t\tthis._outputs = outputs;\n\t\tthis._curves = curves;\n\t\tthis._animEvents = animEvents;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\n\tget inputs() {\n\t\treturn this._inputs;\n\t}\n\n\tget outputs() {\n\t\treturn this._outputs;\n\t}\n\n\tget curves() {\n\t\treturn this._curves;\n\t}\n\n\tset events(animEvents) {\n\t\tthis._animEvents = animEvents;\n\t}\n\n\tget events() {\n\t\treturn this._animEvents.events;\n\t}\n\n\teval(time, snapshot) {\n\t\tsnapshot._time = time;\n\t\tconst inputs = this._inputs;\n\t\tconst outputs = this._outputs;\n\t\tconst curves = this._curves;\n\t\tconst cache = snapshot._cache;\n\t\tconst results = snapshot._results;\n\n\t\tfor (let i = 0; i < inputs.length; ++i) {\n\t\t\tcache[i].update(time, inputs[i]._data);\n\t\t}\n\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst output = outputs[curve._output];\n\t\t\tconst result = results[i];\n\n\t\t\tcache[curve._input].eval(result, curve._interpolation, output);\n\t\t}\n\t}\n\n}\n\nconst INTERPOLATION_STEP = 0;\nconst INTERPOLATION_LINEAR = 1;\nconst INTERPOLATION_CUBIC = 2;\n\nconst DEFAULT_LOCALE = 'en-US';\nconst DEFAULT_LOCALE_FALLBACKS = {\n\t'en': 'en-US',\n\t'es': 'en-ES',\n\t'zh': 'zh-CN',\n\t'zh-HK': 'zh-TW',\n\t'zh-TW': 'zh-HK',\n\t'zh-MO': 'zh-HK',\n\t'fr': 'fr-FR',\n\t'de': 'de-DE',\n\t'it': 'it-IT',\n\t'ru': 'ru-RU',\n\t'ja': 'ja-JP'\n};\n\nconst PLURALS = {};\n\nfunction definePluralFn(locales, fn) {\n\tfor (let i = 0, len = locales.length; i < len; i++) {\n\t\tPLURALS[locales[i]] = fn;\n\t}\n}\n\nfunction getLang(locale) {\n\tconst idx = locale.indexOf('-');\n\n\tif (idx !== -1) {\n\t\treturn locale.substring(0, idx);\n\t}\n\n\treturn locale;\n}\n\nfunction replaceLang(locale, desiredLang) {\n\tconst idx = locale.indexOf('-');\n\n\tif (idx !== -1) {\n\t\treturn desiredLang + locale.substring(idx);\n\t}\n\n\treturn desiredLang;\n}\n\nfunction findAvailableLocale(desiredLocale, availableLocales) {\n\tif (availableLocales[desiredLocale]) {\n\t\treturn desiredLocale;\n\t}\n\n\tlet fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];\n\n\tif (fallback && availableLocales[fallback]) {\n\t\treturn fallback;\n\t}\n\n\tconst lang = getLang(desiredLocale);\n\tfallback = DEFAULT_LOCALE_FALLBACKS[lang];\n\n\tif (availableLocales[fallback]) {\n\t\treturn fallback;\n\t}\n\n\tif (availableLocales[lang]) {\n\t\treturn lang;\n\t}\n\n\treturn DEFAULT_LOCALE;\n}\n\ndefinePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], function (n) {\n\treturn 0;\n});\ndefinePluralFn(['fa', 'hi'], function (n) {\n\tif (n >= 0 && n <= 1) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n});\ndefinePluralFn(['fr', 'pt'], function (n) {\n\tif (n >= 0 && n < 2) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n});\ndefinePluralFn(['da'], function (n) {\n\tif (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n});\ndefinePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], function (n) {\n\tif (n === 1) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n});\ndefinePluralFn(['ru', 'uk'], function (n) {\n\tif (Number.isInteger(n)) {\n\t\tconst mod10 = n % 10;\n\t\tconst mod100 = n % 100;\n\n\t\tif (mod10 === 1 && mod100 !== 11) {\n\t\t\treturn 0;\n\t\t} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {\n\t\t\treturn 1;\n\t\t} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\treturn 3;\n});\ndefinePluralFn(['pl'], function (n) {\n\tif (Number.isInteger(n)) {\n\t\tif (n === 1) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst mod10 = n % 10;\n\t\tconst mod100 = n % 100;\n\n\t\tif (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {\n\t\t\treturn 1;\n\t\t} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\treturn 3;\n});\ndefinePluralFn(['ar'], function (n) {\n\tif (n === 0) {\n\t\treturn 0;\n\t} else if (n === 1) {\n\t\treturn 1;\n\t} else if (n === 2) {\n\t\treturn 2;\n\t}\n\n\tif (Number.isInteger(n)) {\n\t\tconst mod100 = n % 100;\n\n\t\tif (mod100 >= 3 && mod100 <= 10) {\n\t\t\treturn 3;\n\t\t} else if (mod100 >= 11 && mod100 <= 99) {\n\t\t\treturn 4;\n\t\t}\n\t}\n\n\treturn 5;\n});\nconst DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];\n\nfunction getPluralFn(lang) {\n\treturn PLURALS[lang] || DEFAULT_PLURAL_FN;\n}\n\nconst ABSOLUTE_URL = new RegExp('^' + '\\\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\\\-\\\\+\\\\.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');\nconst ASSET_ANIMATION = 'animation';\nconst ASSET_AUDIO = 'audio';\nconst ASSET_IMAGE = 'image';\nconst ASSET_JSON = 'json';\nconst ASSET_MODEL = 'model';\nconst ASSET_MATERIAL = 'material';\nconst ASSET_TEXT = 'text';\nconst ASSET_TEXTURE = 'texture';\nconst ASSET_CUBEMAP = 'cubemap';\nconst ASSET_SHADER = 'shader';\nconst ASSET_CSS = 'css';\nconst ASSET_HTML = 'html';\nconst ASSET_SCRIPT = 'script';\nconst ASSET_CONTAINER = 'container';\n\nclass AssetFile {\n\tconstructor(url, filename, hash, size, opt, contents) {\n\t\tthis.url = url || '';\n\t\tthis.filename = filename || '';\n\t\tthis.hash = hash === undefined ? null : hash;\n\t\tthis.size = size === undefined ? null : size;\n\t\tthis.opt = opt === undefined ? null : opt;\n\t\tthis.contents = contents || null;\n\t}\n\n\tequals(other) {\n\t\treturn this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;\n\t}\n\n}\n\nlet assetIdCounter = -1;\nconst VARIANT_SUPPORT = {\n\tpvr: 'extCompressedTexturePVRTC',\n\tdxt: 'extCompressedTextureS3TC',\n\tetc2: 'extCompressedTextureETC',\n\tetc1: 'extCompressedTextureETC1',\n\tbasis: 'canvas'\n};\nconst VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];\n\nclass Asset extends EventHandler {\n\tconstructor(name, type, file, data, options) {\n\t\tsuper();\n\t\tthis._id = assetIdCounter--;\n\t\tthis.name = name || '';\n\t\tthis.type = type;\n\t\tthis.tags = new Tags(this);\n\t\tthis._preload = false;\n\t\tthis._file = null;\n\t\tthis._data = data || {};\n\t\tthis.options = options || {};\n\t\tthis._resources = [];\n\t\tthis._i18n = {};\n\t\tthis.loaded = false;\n\t\tthis.loading = false;\n\t\tthis.registry = null;\n\t\tif (file) this.file = file;\n\t}\n\n\tset id(value) {\n\t\tthis._id = value;\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tset file(value) {\n\t\tif (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {\n\t\t\tvar _this$registry, _this$registry$_loade;\n\n\t\t\tconst app = ((_this$registry = this.registry) == null ? void 0 : (_this$registry$_loade = _this$registry._loader) == null ? void 0 : _this$registry$_loade._app) || getApplication();\n\t\t\tconst device = app == null ? void 0 : app.graphicsDevice;\n\n\t\t\tif (device) {\n\t\t\t\tfor (let i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {\n\t\t\t\t\tconst variant = VARIANT_DEFAULT_PRIORITY[i];\n\n\t\t\t\t\tif (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {\n\t\t\t\t\t\tvalue = value.variants[variant];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (app.enableBundles) {\n\t\t\t\t\t\tconst bundles = app.bundles.listBundlesForAsset(this);\n\n\t\t\t\t\t\tif (bundles && bundles.find(b => {\n\t\t\t\t\t\t\tvar _b$file;\n\n\t\t\t\t\t\t\treturn b == null ? void 0 : (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];\n\t\t\t\t\t\t})) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst oldFile = this._file;\n\t\tconst newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;\n\n\t\tif (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {\n\t\t\tthis._file = newFile;\n\t\t\tthis.fire('change', this, 'file', newFile, oldFile);\n\t\t\tthis.reload();\n\t\t}\n\t}\n\n\tget file() {\n\t\treturn this._file;\n\t}\n\n\tset data(value) {\n\t\tconst old = this._data;\n\t\tthis._data = value;\n\n\t\tif (value !== old) {\n\t\t\tthis.fire('change', this, 'data', value, old);\n\t\t\tif (this.loaded) this.registry._loader.patch(this, this.registry);\n\t\t}\n\t}\n\n\tget data() {\n\t\treturn this._data;\n\t}\n\n\tset resource(value) {\n\t\tconst _old = this._resources[0];\n\t\tthis._resources[0] = value;\n\t\tthis.fire('change', this, 'resource', value, _old);\n\t}\n\n\tget resource() {\n\t\treturn this._resources[0];\n\t}\n\n\tset resources(value) {\n\t\tconst _old = this._resources;\n\t\tthis._resources = value;\n\t\tthis.fire('change', this, 'resources', value, _old);\n\t}\n\n\tget resources() {\n\t\treturn this._resources;\n\t}\n\n\tset preload(value) {\n\t\tvalue = !!value;\n\t\tif (this._preload === value) return;\n\t\tthis._preload = value;\n\t\tif (this._preload && !this.loaded && !this.loading && this.registry) this.registry.load(this);\n\t}\n\n\tget preload() {\n\t\treturn this._preload;\n\t}\n\n\tset loadFaces(value) {\n\t\tvalue = !!value;\n\n\t\tif (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {\n\t\t\tthis._loadFaces = value;\n\t\t\tif (this.loaded) this.registry._loader.patch(this, this.registry);\n\t\t}\n\t}\n\n\tget loadFaces() {\n\t\treturn this._loadFaces;\n\t}\n\n\tgetFileUrl() {\n\t\tconst file = this.file;\n\t\tif (!file || !file.url) return null;\n\t\tlet url = file.url;\n\t\tif (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) url = this.registry.prefix + url;\n\n\t\tif (this.type !== 'script' && file.hash) {\n\t\t\tconst separator = url.indexOf('?') !== -1 ? '&' : '?';\n\t\t\turl += separator + 't=' + file.hash;\n\t\t}\n\n\t\treturn url;\n\t}\n\n\tgetAbsoluteUrl(relativePath) {\n\t\tif (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {\n\t\t\treturn relativePath;\n\t\t}\n\n\t\tconst base = path.getDirectory(this.file.url);\n\t\treturn path.join(base, relativePath);\n\t}\n\n\tgetLocalizedAssetId(locale) {\n\t\tlocale = findAvailableLocale(locale, this._i18n);\n\t\treturn this._i18n[locale] || null;\n\t}\n\n\taddLocalizedAssetId(locale, assetId) {\n\t\tthis._i18n[locale] = assetId;\n\t\tthis.fire('add:localized', locale, assetId);\n\t}\n\n\tremoveLocalizedAssetId(locale) {\n\t\tconst assetId = this._i18n[locale];\n\n\t\tif (assetId) {\n\t\t\tdelete this._i18n[locale];\n\t\t\tthis.fire('remove:localized', locale, assetId);\n\t\t}\n\t}\n\n\tready(callback, scope) {\n\t\tscope = scope || this;\n\n\t\tif (this.resource) {\n\t\t\tcallback.call(scope, this);\n\t\t} else {\n\t\t\tthis.once(\"load\", function (asset) {\n\t\t\t\tcallback.call(scope, asset);\n\t\t\t});\n\t\t}\n\t}\n\n\treload() {\n\t\tif (this.loaded) {\n\t\t\tthis.loaded = false;\n\t\t\tthis.registry.load(this);\n\t\t}\n\t}\n\n\tunload() {\n\t\tif (!this.loaded && this._resources.length === 0) return;\n\t\tthis.fire('unload', this);\n\t\tthis.registry.fire('unload:' + this.id, this);\n\t\tconst old = this._resources;\n\t\tthis.resources = [];\n\t\tthis.loaded = false;\n\n\t\tif (this.file) {\n\t\t\tthis.registry._loader.clearCache(this.getFileUrl(), this.type);\n\t\t}\n\n\t\tfor (let i = 0; i < old.length; ++i) {\n\t\t\tconst resource = old[i];\n\n\t\t\tif (resource && resource.destroy) {\n\t\t\t\tresource.destroy();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic fetchArrayBuffer(loadUrl, callback, asset, maxRetries = 0) {\n\t\tvar _asset$file;\n\n\t\tif (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tcallback(null, asset.file.contents);\n\t\t\t});\n\t\t} else {\n\t\t\thttp.get(loadUrl, {\n\t\t\t\tcache: true,\n\t\t\t\tresponseType: 'arraybuffer',\n\t\t\t\tretry: maxRetries > 0,\n\t\t\t\tmaxRetries: maxRetries\n\t\t\t}, callback);\n\t\t}\n\t}\n\n}\n\nclass SkinInstanceCachedObject extends RefCountedObject {\n\tconstructor(skin, skinInstance) {\n\t\tsuper();\n\t\tthis.skin = skin;\n\t\tthis.skinInstance = skinInstance;\n\t}\n\n}\n\nclass SkinInstanceCache {\n\tstatic createCachedSkinInstance(skin, rootBone, entity) {\n\t\tlet skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);\n\n\t\tif (!skinInst) {\n\t\t\tskinInst = new SkinInstance(skin);\n\t\t\tskinInst.resolve(rootBone, entity);\n\t\t\tSkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);\n\t\t}\n\n\t\treturn skinInst;\n\t}\n\n\tstatic getCachedSkinInstance(skin, rootBone) {\n\t\tlet skinInstance = null;\n\n\t\tconst cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\n\t\tif (cachedObjArray) {\n\t\t\tconst cachedObj = cachedObjArray.find(element => element.skin === skin);\n\n\t\t\tif (cachedObj) {\n\t\t\t\tcachedObj.incRefCount();\n\t\t\t\tskinInstance = cachedObj.skinInstance;\n\t\t\t}\n\t\t}\n\n\t\treturn skinInstance;\n\t}\n\n\tstatic addCachedSkinInstance(skin, rootBone, skinInstance) {\n\t\tlet cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\n\t\tif (!cachedObjArray) {\n\t\t\tcachedObjArray = [];\n\n\t\t\tSkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);\n\t\t}\n\n\t\tlet cachedObj = cachedObjArray.find(element => element.skin === skin);\n\n\t\tif (!cachedObj) {\n\t\t\tcachedObj = new SkinInstanceCachedObject(skin, skinInstance);\n\t\t\tcachedObjArray.push(cachedObj);\n\t\t}\n\n\t\tcachedObj.incRefCount();\n\t}\n\n\tstatic removeCachedSkinInstance(skinInstance) {\n\t\tif (skinInstance) {\n\t\t\tconst rootBone = skinInstance.rootBone;\n\n\t\t\tif (rootBone) {\n\t\t\t\tconst cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\n\t\t\t\tif (cachedObjArray) {\n\t\t\t\t\tconst cachedObjIndex = cachedObjArray.findIndex(element => element.skinInstance === skinInstance);\n\n\t\t\t\t\tif (cachedObjIndex >= 0) {\n\t\t\t\t\t\tconst cachedObj = cachedObjArray[cachedObjIndex];\n\t\t\t\t\t\tcachedObj.decRefCount();\n\n\t\t\t\t\t\tif (cachedObj.refCount === 0) {\n\t\t\t\t\t\t\tcachedObjArray.splice(cachedObjIndex, 1);\n\n\t\t\t\t\t\t\tif (!cachedObjArray.length) {\n\t\t\t\t\t\t\t\tSkinInstanceCache._skinInstanceCache.delete(rootBone);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (skinInstance) {\n\t\t\t\t\t\t\t\tskinInstance.destroy();\n\t\t\t\t\t\t\t\tcachedObj.skinInstance = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nSkinInstanceCache._skinInstanceCache = new Map();\n\nclass GlbContainerResource {\n\tconstructor(data, asset, assets, defaultMaterial) {\n\t\tconst createAsset = function createAsset(type, resource, index) {\n\t\t\tconst subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);\n\t\t\tassets.add(subAsset);\n\t\t\treturn subAsset;\n\t\t};\n\n\t\tconst renders = [];\n\n\t\tfor (let i = 0; i < data.renders.length; ++i) {\n\t\t\trenders.push(createAsset('render', data.renders[i], i));\n\t\t}\n\n\t\tconst materials = [];\n\n\t\tfor (let i = 0; i < data.materials.length; ++i) {\n\t\t\tmaterials.push(createAsset('material', data.materials[i], i));\n\t\t}\n\n\t\tconst animations = [];\n\n\t\tfor (let i = 0; i < data.animations.length; ++i) {\n\t\t\tanimations.push(createAsset('animation', data.animations[i], i));\n\t\t}\n\n\t\tthis.data = data;\n\t\tthis._model = null;\n\t\tthis._assetName = asset.name;\n\t\tthis._assets = assets;\n\t\tthis._defaultMaterial = defaultMaterial;\n\t\tthis.renders = renders;\n\t\tthis.materials = materials;\n\t\tthis.textures = data.textures;\n\t\tthis.animations = animations;\n\t}\n\n\tget model() {\n\t\tif (!this._model) {\n\t\t\tconst model = GlbContainerResource.createModel(this.data, this._defaultMaterial);\n\t\t\tconst modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);\n\n\t\t\tthis._assets.add(modelAsset);\n\n\t\t\tthis._model = modelAsset;\n\t\t}\n\n\t\treturn this._model;\n\t}\n\n\tstatic createAsset(assetName, type, resource, index) {\n\t\tconst subAsset = new Asset(assetName + '/' + type + '/' + index, type, {\n\t\t\turl: ''\n\t\t});\n\t\tsubAsset.resource = resource;\n\t\tsubAsset.loaded = true;\n\t\treturn subAsset;\n\t}\n\n\tinstantiateModelEntity(options) {\n\t\tconst entity = new Entity();\n\t\tentity.addComponent(\"model\", Object.assign({\n\t\t\ttype: \"asset\",\n\t\t\tasset: this.model\n\t\t}, options));\n\t\treturn entity;\n\t}\n\n\tinstantiateRenderEntity(options) {\n\t\tconst defaultMaterial = this._defaultMaterial;\n\t\tconst skinnedMeshInstances = [];\n\n\t\tconst createMeshInstance = function createMeshInstance(root, entity, mesh, materials, skins, gltfNode) {\n\t\t\tconst material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];\n\t\t\tconst meshInstance = new MeshInstance(mesh, material);\n\n\t\t\tif (mesh.morph) {\n\t\t\t\tmeshInstance.morphInstance = new MorphInstance(mesh.morph);\n\t\t\t}\n\n\t\t\tif (gltfNode.hasOwnProperty('skin')) {\n\t\t\t\tskinnedMeshInstances.push({\n\t\t\t\t\tmeshInstance: meshInstance,\n\t\t\t\t\trootBone: root,\n\t\t\t\t\tentity: entity\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn meshInstance;\n\t\t};\n\n\t\tconst cloneHierarchy = function cloneHierarchy(root, node, glb) {\n\t\t\tconst entity = new Entity();\n\n\t\t\tnode._cloneInternal(entity);\n\n\t\t\tif (!root) root = entity;\n\t\t\tlet attachedMi = null;\n\n\t\t\tfor (let i = 0; i < glb.nodes.length; i++) {\n\t\t\t\tconst glbNode = glb.nodes[i];\n\n\t\t\t\tif (glbNode === node) {\n\t\t\t\t\tconst gltfNode = glb.gltf.nodes[i];\n\n\t\t\t\t\tif (gltfNode.hasOwnProperty('mesh')) {\n\t\t\t\t\t\tconst meshGroup = glb.renders[gltfNode.mesh].meshes;\n\n\t\t\t\t\t\tfor (var mi = 0; mi < meshGroup.length; mi++) {\n\t\t\t\t\t\t\tconst mesh = meshGroup[mi];\n\n\t\t\t\t\t\t\tif (mesh) {\n\t\t\t\t\t\t\t\tconst cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.skins, gltfNode);\n\n\t\t\t\t\t\t\t\tif (!attachedMi) {\n\t\t\t\t\t\t\t\t\tattachedMi = [];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tattachedMi.push(cloneMi);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (glb.lights) {\n\t\t\t\t\t\tconst lightEntity = glb.lights.get(gltfNode);\n\n\t\t\t\t\t\tif (lightEntity) {\n\t\t\t\t\t\t\tentity.addChild(lightEntity.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (glb.cameras) {\n\t\t\t\t\t\tconst cameraEntity = glb.cameras.get(gltfNode);\n\n\t\t\t\t\t\tif (cameraEntity) {\n\t\t\t\t\t\t\tcameraEntity.camera.system.cloneComponent(cameraEntity, entity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (attachedMi) {\n\t\t\t\tentity.addComponent(\"render\", Object.assign({\n\t\t\t\t\ttype: \"asset\",\n\t\t\t\t\tmeshInstances: attachedMi,\n\t\t\t\t\trootBone: root\n\t\t\t\t}, options));\n\t\t\t}\n\n\t\t\tconst children = node.children;\n\n\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\tconst childClone = cloneHierarchy(root, children[i], glb);\n\t\t\t\tentity.addChild(childClone);\n\t\t\t}\n\n\t\t\treturn entity;\n\t\t};\n\n\t\tconst sceneClones = [];\n\n\t\tfor (const scene of this.data.scenes) {\n\t\t\tsceneClones.push(cloneHierarchy(null, scene, this.data));\n\t\t}\n\n\t\tskinnedMeshInstances.forEach(data => {\n\t\t\tdata.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);\n\t\t});\n\t\treturn GlbContainerResource.createSceneHierarchy(sceneClones, \"Entity\");\n\t}\n\n\tstatic createSceneHierarchy(sceneNodes, nodeType) {\n\t\tlet root = null;\n\n\t\tif (sceneNodes.length === 1) {\n\t\t\troot = sceneNodes[0];\n\t\t} else {\n\t\t\troot = new nodeType('SceneGroup');\n\n\t\t\tfor (const scene of sceneNodes) {\n\t\t\t\troot.addChild(scene);\n\t\t\t}\n\t\t}\n\n\t\treturn root;\n\t}\n\n\tstatic createModel(glb, defaultMaterial) {\n\t\tconst createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {\n\t\t\tconst material = mesh.materialIndex === undefined ? defaultMaterial : materials[mesh.materialIndex];\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, node);\n\n\t\t\tif (mesh.morph) {\n\t\t\t\tconst morphInstance = new MorphInstance(mesh.morph);\n\t\t\t\tmeshInstance.morphInstance = morphInstance;\n\t\t\t\tmodel.morphInstances.push(morphInstance);\n\t\t\t}\n\n\t\t\tif (gltfNode.hasOwnProperty('skin')) {\n\t\t\t\tconst skinIndex = gltfNode.skin;\n\t\t\t\tconst skin = skins[skinIndex];\n\t\t\t\tmesh.skin = skin;\n\t\t\t\tconst skinInstance = skinInstances[skinIndex];\n\t\t\t\tmeshInstance.skinInstance = skinInstance;\n\t\t\t\tmodel.skinInstances.push(skinInstance);\n\t\t\t}\n\n\t\t\tmodel.meshInstances.push(meshInstance);\n\t\t};\n\n\t\tconst model = new Model();\n\t\tconst skinInstances = [];\n\n\t\tfor (const skin of glb.skins) {\n\t\t\tconst skinInstance = new SkinInstance(skin);\n\t\t\tskinInstance.bones = skin.bones;\n\t\t\tskinInstances.push(skinInstance);\n\t\t}\n\n\t\tmodel.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, \"GraphNode\");\n\n\t\tfor (let i = 0; i < glb.nodes.length; i++) {\n\t\t\tconst node = glb.nodes[i];\n\n\t\t\tif (node.root === model.graph) {\n\t\t\t\tconst gltfNode = glb.gltf.nodes[i];\n\n\t\t\t\tif (gltfNode.hasOwnProperty('mesh')) {\n\t\t\t\t\tconst meshGroup = glb.renders[gltfNode.mesh].meshes;\n\n\t\t\t\t\tfor (var mi = 0; mi < meshGroup.length; mi++) {\n\t\t\t\t\t\tconst mesh = meshGroup[mi];\n\n\t\t\t\t\t\tif (mesh) {\n\t\t\t\t\t\t\tcreateMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tdestroy() {\n\t\tconst registry = this._assets;\n\n\t\tconst destroyAsset = function destroyAsset(asset) {\n\t\t\tregistry.remove(asset);\n\t\t\tasset.unload();\n\t\t};\n\n\t\tconst destroyAssets = function destroyAssets(assets) {\n\t\t\tassets.forEach(function (asset) {\n\t\t\t\tdestroyAsset(asset);\n\t\t\t});\n\t\t};\n\n\t\tif (this.animations) {\n\t\t\tdestroyAssets(this.animations);\n\t\t\tthis.animations = null;\n\t\t}\n\n\t\tif (this.textures) {\n\t\t\tdestroyAssets(this.textures);\n\t\t\tthis.textures = null;\n\t\t}\n\n\t\tif (this.materials) {\n\t\t\tdestroyAssets(this.materials);\n\t\t\tthis.materials = null;\n\t\t}\n\n\t\tif (this.renders) {\n\t\t\tdestroyAssets(this.renders);\n\t\t\tthis.renders = null;\n\t\t}\n\n\t\tif (this._model) {\n\t\t\tdestroyAsset(this._model);\n\t\t\tthis._model = null;\n\t\t}\n\n\t\tthis.data = null;\n\t\tthis.assets = null;\n\t}\n\n}\n\nclass GlbResources {\n\tconstructor(gltf) {\n\t\tthis.gltf = gltf;\n\t\tthis.nodes = null;\n\t\tthis.scenes = null;\n\t\tthis.animations = null;\n\t\tthis.textures = null;\n\t\tthis.materials = null;\n\t\tthis.renders = null;\n\t\tthis.skins = null;\n\t\tthis.lights = null;\n\t\tthis.cameras = null;\n\t}\n\n\tdestroy() {\n\t\tif (this.renders) {\n\t\t\tthis.renders.forEach(render => {\n\t\t\t\trender.meshes = null;\n\t\t\t});\n\t\t}\n\t}\n\n}\n\nconst isDataURI = function isDataURI(uri) {\n\treturn /^data:.*,.*$/i.test(uri);\n};\n\nconst getDataURIMimeType = function getDataURIMimeType(uri) {\n\treturn uri.substring(uri.indexOf(\":\") + 1, uri.indexOf(\";\"));\n};\n\nconst getNumComponents = function getNumComponents(accessorType) {\n\tswitch (accessorType) {\n\t\tcase 'SCALAR':\n\t\t\treturn 1;\n\n\t\tcase 'VEC2':\n\t\t\treturn 2;\n\n\t\tcase 'VEC3':\n\t\t\treturn 3;\n\n\t\tcase 'VEC4':\n\t\t\treturn 4;\n\n\t\tcase 'MAT2':\n\t\t\treturn 4;\n\n\t\tcase 'MAT3':\n\t\t\treturn 9;\n\n\t\tcase 'MAT4':\n\t\t\treturn 16;\n\n\t\tdefault:\n\t\t\treturn 3;\n\t}\n};\n\nconst getComponentType = function getComponentType(componentType) {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn TYPE_INT8;\n\n\t\tcase 5121:\n\t\t\treturn TYPE_UINT8;\n\n\t\tcase 5122:\n\t\t\treturn TYPE_INT16;\n\n\t\tcase 5123:\n\t\t\treturn TYPE_UINT16;\n\n\t\tcase 5124:\n\t\t\treturn TYPE_INT32;\n\n\t\tcase 5125:\n\t\t\treturn TYPE_UINT32;\n\n\t\tcase 5126:\n\t\t\treturn TYPE_FLOAT32;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n};\n\nconst getComponentSizeInBytes = function getComponentSizeInBytes(componentType) {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn 1;\n\n\t\tcase 5121:\n\t\t\treturn 1;\n\n\t\tcase 5122:\n\t\t\treturn 2;\n\n\t\tcase 5123:\n\t\t\treturn 2;\n\n\t\tcase 5124:\n\t\t\treturn 4;\n\n\t\tcase 5125:\n\t\t\treturn 4;\n\n\t\tcase 5126:\n\t\t\treturn 4;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n};\n\nconst getComponentDataType = function getComponentDataType(componentType) {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn Int8Array;\n\n\t\tcase 5121:\n\t\t\treturn Uint8Array;\n\n\t\tcase 5122:\n\t\t\treturn Int16Array;\n\n\t\tcase 5123:\n\t\t\treturn Uint16Array;\n\n\t\tcase 5124:\n\t\t\treturn Int32Array;\n\n\t\tcase 5125:\n\t\t\treturn Uint32Array;\n\n\t\tcase 5126:\n\t\t\treturn Float32Array;\n\n\t\tdefault:\n\t\t\treturn null;\n\t}\n};\n\nconst gltfToEngineSemanticMap = {\n\t'POSITION': SEMANTIC_POSITION,\n\t'NORMAL': SEMANTIC_NORMAL,\n\t'TANGENT': SEMANTIC_TANGENT,\n\t'COLOR_0': SEMANTIC_COLOR,\n\t'JOINTS_0': SEMANTIC_BLENDINDICES,\n\t'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,\n\t'TEXCOORD_0': SEMANTIC_TEXCOORD0,\n\t'TEXCOORD_1': SEMANTIC_TEXCOORD1,\n\t'TEXCOORD_2': SEMANTIC_TEXCOORD2,\n\t'TEXCOORD_3': SEMANTIC_TEXCOORD3,\n\t'TEXCOORD_4': SEMANTIC_TEXCOORD4,\n\t'TEXCOORD_5': SEMANTIC_TEXCOORD5,\n\t'TEXCOORD_6': SEMANTIC_TEXCOORD6,\n\t'TEXCOORD_7': SEMANTIC_TEXCOORD7\n};\n\nconst getDequantizeFunc = srcType => {\n\tswitch (srcType) {\n\t\tcase TYPE_INT8:\n\t\t\treturn x => Math.max(x / 127.0, -1.0);\n\n\t\tcase TYPE_UINT8:\n\t\t\treturn x => x / 255.0;\n\n\t\tcase TYPE_INT16:\n\t\t\treturn x => Math.max(x / 32767.0, -1.0);\n\n\t\tcase TYPE_UINT16:\n\t\t\treturn x => x / 65535.0;\n\n\t\tdefault:\n\t\t\treturn x => x;\n\t}\n};\n\nconst dequantizeArray = function dequantizeArray(dstArray, srcArray, srcType) {\n\tconst convFunc = getDequantizeFunc(srcType);\n\tconst len = srcArray.length;\n\n\tfor (let i = 0; i < len; ++i) {\n\t\tdstArray[i] = convFunc(srcArray[i]);\n\t}\n\n\treturn dstArray;\n};\n\nconst getAccessorData = function getAccessorData(gltfAccessor, bufferViews, flatten = false) {\n\tconst numComponents = getNumComponents(gltfAccessor.type);\n\tconst dataType = getComponentDataType(gltfAccessor.componentType);\n\n\tif (!dataType) {\n\t\treturn null;\n\t}\n\n\tconst bufferView = bufferViews[gltfAccessor.bufferView];\n\tlet result;\n\n\tif (gltfAccessor.sparse) {\n\t\tconst sparse = gltfAccessor.sparse;\n\t\tconst indicesAccessor = {\n\t\t\tcount: sparse.count,\n\t\t\ttype: \"SCALAR\"\n\t\t};\n\t\tconst indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);\n\t\tconst valuesAccessor = {\n\t\t\tcount: sparse.count,\n\t\t\ttype: gltfAccessor.scalar,\n\t\t\tcomponentType: gltfAccessor.componentType\n\t\t};\n\t\tconst values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);\n\n\t\tif (gltfAccessor.hasOwnProperty('bufferView')) {\n\t\t\tconst baseAccessor = {\n\t\t\t\tbufferView: gltfAccessor.bufferView,\n\t\t\t\tbyteOffset: gltfAccessor.byteOffset,\n\t\t\t\tcomponentType: gltfAccessor.componentType,\n\t\t\t\tcount: gltfAccessor.count,\n\t\t\t\ttype: gltfAccessor.type\n\t\t\t};\n\t\t\tresult = getAccessorData(baseAccessor, bufferViews, true).slice();\n\t\t} else {\n\t\t\tresult = new dataType(gltfAccessor.count * numComponents);\n\t\t}\n\n\t\tfor (let i = 0; i < sparse.count; ++i) {\n\t\t\tconst targetIndex = indices[i];\n\n\t\t\tfor (let j = 0; j < numComponents; ++j) {\n\t\t\t\tresult[targetIndex * numComponents + j] = values[i * numComponents + j];\n\t\t\t}\n\t\t}\n\t} else if (flatten && bufferView.hasOwnProperty('byteStride')) {\n\t\tconst bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;\n\t\tconst storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);\n\t\tconst tmpArray = new Uint8Array(storage);\n\t\tlet dstOffset = 0;\n\n\t\tfor (let i = 0; i < gltfAccessor.count; ++i) {\n\t\t\tlet srcOffset = (gltfAccessor.byteOffset || 0) + i * bufferView.byteStride;\n\n\t\t\tfor (let b = 0; b < bytesPerElement; ++b) {\n\t\t\t\ttmpArray[dstOffset++] = bufferView[srcOffset++];\n\t\t\t}\n\t\t}\n\n\t\tresult = new dataType(storage);\n\t} else {\n\t\tresult = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);\n\t}\n\n\treturn result;\n};\n\nconst getAccessorDataFloat32 = function getAccessorDataFloat32(gltfAccessor, bufferViews) {\n\tconst data = getAccessorData(gltfAccessor, bufferViews, true);\n\n\tif (data instanceof Float32Array || !gltfAccessor.normalized) {\n\t\treturn data;\n\t}\n\n\tconst float32Data = new Float32Array(data.length);\n\tdequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));\n\treturn float32Data;\n};\n\nconst getAccessorBoundingBox = function getAccessorBoundingBox(gltfAccessor) {\n\tlet min = gltfAccessor.min;\n\tlet max = gltfAccessor.max;\n\n\tif (!min || !max) {\n\t\treturn null;\n\t}\n\n\tif (gltfAccessor.normalized) {\n\t\tconst ctype = getComponentType(gltfAccessor.componentType);\n\t\tmin = dequantizeArray([], min, ctype);\n\t\tmax = dequantizeArray([], max, ctype);\n\t}\n\n\treturn new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n};\n\nconst getPrimitiveType = function getPrimitiveType(primitive) {\n\tif (!primitive.hasOwnProperty('mode')) {\n\t\treturn PRIMITIVE_TRIANGLES;\n\t}\n\n\tswitch (primitive.mode) {\n\t\tcase 0:\n\t\t\treturn PRIMITIVE_POINTS;\n\n\t\tcase 1:\n\t\t\treturn PRIMITIVE_LINES;\n\n\t\tcase 2:\n\t\t\treturn PRIMITIVE_LINELOOP;\n\n\t\tcase 3:\n\t\t\treturn PRIMITIVE_LINESTRIP;\n\n\t\tcase 4:\n\t\t\treturn PRIMITIVE_TRIANGLES;\n\n\t\tcase 5:\n\t\t\treturn PRIMITIVE_TRISTRIP;\n\n\t\tcase 6:\n\t\t\treturn PRIMITIVE_TRIFAN;\n\n\t\tdefault:\n\t\t\treturn PRIMITIVE_TRIANGLES;\n\t}\n};\n\nconst generateIndices = function generateIndices(numVertices) {\n\tconst dummyIndices = new Uint16Array(numVertices);\n\n\tfor (let i = 0; i < numVertices; i++) {\n\t\tdummyIndices[i] = i;\n\t}\n\n\treturn dummyIndices;\n};\n\nconst generateNormals = function generateNormals(sourceDesc, indices) {\n\tconst p = sourceDesc[SEMANTIC_POSITION];\n\n\tif (!p || p.components !== 3) {\n\t\treturn;\n\t}\n\n\tlet positions;\n\n\tif (p.size !== p.stride) {\n\t\tconst srcStride = p.stride / typedArrayTypesByteSize[p.type];\n\t\tconst src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);\n\t\tpositions = new typedArrayTypes[p.type](p.count * 3);\n\n\t\tfor (let i = 0; i < p.count; ++i) {\n\t\t\tpositions[i * 3 + 0] = src[i * srcStride + 0];\n\t\t\tpositions[i * 3 + 1] = src[i * srcStride + 1];\n\t\t\tpositions[i * 3 + 2] = src[i * srcStride + 2];\n\t\t}\n\t} else {\n\t\tpositions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);\n\t}\n\n\tconst numVertices = p.count;\n\n\tif (!indices) {\n\t\tindices = generateIndices(numVertices);\n\t}\n\n\tconst normalsTemp = calculateNormals(positions, indices);\n\tconst normals = new Float32Array(normalsTemp.length);\n\tnormals.set(normalsTemp);\n\tsourceDesc[SEMANTIC_NORMAL] = {\n\t\tbuffer: normals.buffer,\n\t\tsize: 12,\n\t\toffset: 0,\n\t\tstride: 12,\n\t\tcount: numVertices,\n\t\tcomponents: 3,\n\t\ttype: TYPE_FLOAT32\n\t};\n};\n\nconst flipTexCoordVs = function flipTexCoordVs(vertexBuffer) {\n\tlet i, j;\n\tconst floatOffsets = [];\n\tconst shortOffsets = [];\n\tconst byteOffsets = [];\n\n\tfor (i = 0; i < vertexBuffer.format.elements.length; ++i) {\n\t\tconst element = vertexBuffer.format.elements[i];\n\n\t\tif (element.name === SEMANTIC_TEXCOORD0 || element.name === SEMANTIC_TEXCOORD1) {\n\t\t\tswitch (element.dataType) {\n\t\t\t\tcase TYPE_FLOAT32:\n\t\t\t\t\tfloatOffsets.push({\n\t\t\t\t\t\toffset: element.offset / 4 + 1,\n\t\t\t\t\t\tstride: element.stride / 4\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TYPE_UINT16:\n\t\t\t\t\tshortOffsets.push({\n\t\t\t\t\t\toffset: element.offset / 2 + 1,\n\t\t\t\t\t\tstride: element.stride / 2\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TYPE_UINT8:\n\t\t\t\t\tbyteOffsets.push({\n\t\t\t\t\t\toffset: element.offset + 1,\n\t\t\t\t\t\tstride: element.stride\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst flip = function flip(offsets, type, one) {\n\t\tconst typedArray = new type(vertexBuffer.storage);\n\n\t\tfor (i = 0; i < offsets.length; ++i) {\n\t\t\tlet index = offsets[i].offset;\n\t\t\tconst stride = offsets[i].stride;\n\n\t\t\tfor (j = 0; j < vertexBuffer.numVertices; ++j) {\n\t\t\t\ttypedArray[index] = one - typedArray[index];\n\t\t\t\tindex += stride;\n\t\t\t}\n\t\t}\n\t};\n\n\tif (floatOffsets.length > 0) {\n\t\tflip(floatOffsets, Float32Array, 1.0);\n\t}\n\n\tif (shortOffsets.length > 0) {\n\t\tflip(shortOffsets, Uint16Array, 65535);\n\t}\n\n\tif (byteOffsets.length > 0) {\n\t\tflip(byteOffsets, Uint8Array, 255);\n\t}\n};\n\nconst cloneTexture = function cloneTexture(texture) {\n\tconst shallowCopyLevels = function shallowCopyLevels(texture) {\n\t\tconst result = [];\n\n\t\tfor (let mip = 0; mip < texture._levels.length; ++mip) {\n\t\t\tlet level = [];\n\n\t\t\tif (texture.cubemap) {\n\t\t\t\tfor (let face = 0; face < 6; ++face) {\n\t\t\t\t\tlevel.push(texture._levels[mip][face]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlevel = texture._levels[mip];\n\t\t\t}\n\n\t\t\tresult.push(level);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tconst result = new Texture(texture.device, texture);\n\tresult._levels = shallowCopyLevels(texture);\n\treturn result;\n};\n\nconst cloneTextureAsset = function cloneTextureAsset(src) {\n\tconst result = new Asset(src.name + '_clone', src.type, src.file, src.data, src.options);\n\tresult.loaded = true;\n\tresult.resource = cloneTexture(src.resource);\n\tsrc.registry.add(result);\n\treturn result;\n};\n\nconst createVertexBufferInternal = function createVertexBufferInternal(device, sourceDesc, flipV) {\n\tconst positionDesc = sourceDesc[SEMANTIC_POSITION];\n\n\tif (!positionDesc) {\n\t\treturn null;\n\t}\n\n\tconst numVertices = positionDesc.count;\n\tconst vertexDesc = [];\n\n\tfor (const semantic in sourceDesc) {\n\t\tif (sourceDesc.hasOwnProperty(semantic)) {\n\t\t\tvertexDesc.push({\n\t\t\t\tsemantic: semantic,\n\t\t\t\tcomponents: sourceDesc[semantic].components,\n\t\t\t\ttype: sourceDesc[semantic].type,\n\t\t\t\tnormalize: !!sourceDesc[semantic].normalize\n\t\t\t});\n\t\t}\n\t}\n\n\tconst elementOrder = [SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_COLOR, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1];\n\tvertexDesc.sort(function (lhs, rhs) {\n\t\tconst lhsOrder = elementOrder.indexOf(lhs.semantic);\n\t\tconst rhsOrder = elementOrder.indexOf(rhs.semantic);\n\t\treturn lhsOrder < rhsOrder ? -1 : rhsOrder < lhsOrder ? 1 : 0;\n\t});\n\tlet i, j, k;\n\tlet source, target, sourceOffset;\n\tconst vertexFormat = new VertexFormat(device, vertexDesc);\n\tlet isCorrectlyInterleaved = true;\n\n\tfor (i = 0; i < vertexFormat.elements.length; ++i) {\n\t\ttarget = vertexFormat.elements[i];\n\t\tsource = sourceDesc[target.name];\n\t\tsourceOffset = source.offset - positionDesc.offset;\n\n\t\tif (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {\n\t\t\tisCorrectlyInterleaved = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, BUFFER_STATIC);\n\tconst vertexData = vertexBuffer.lock();\n\tconst targetArray = new Uint32Array(vertexData);\n\tlet sourceArray;\n\n\tif (isCorrectlyInterleaved) {\n\t\tsourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);\n\t\ttargetArray.set(sourceArray);\n\t} else {\n\t\tlet targetStride, sourceStride;\n\n\t\tfor (i = 0; i < vertexBuffer.format.elements.length; ++i) {\n\t\t\ttarget = vertexBuffer.format.elements[i];\n\t\t\ttargetStride = target.stride / 4;\n\t\t\tsource = sourceDesc[target.name];\n\t\t\tsourceStride = source.stride / 4;\n\t\t\tsourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);\n\t\t\tlet src = 0;\n\t\t\tlet dst = target.offset / 4;\n\t\t\tconst kend = Math.floor((source.size + 3) / 4);\n\n\t\t\tfor (j = 0; j < numVertices; ++j) {\n\t\t\t\tfor (k = 0; k < kend; ++k) {\n\t\t\t\t\ttargetArray[dst + k] = sourceArray[src + k];\n\t\t\t\t}\n\n\t\t\t\tsrc += sourceStride;\n\t\t\t\tdst += targetStride;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flipV) {\n\t\tflipTexCoordVs(vertexBuffer);\n\t}\n\n\tvertexBuffer.unlock();\n\treturn vertexBuffer;\n};\n\nconst createVertexBuffer = function createVertexBuffer(device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) {\n\tconst useAttributes = {};\n\tconst attribIds = [];\n\n\tfor (const attrib in attributes) {\n\t\tif (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {\n\t\t\tuseAttributes[attrib] = attributes[attrib];\n\t\t\tattribIds.push(attrib + \":\" + attributes[attrib]);\n\t\t}\n\t}\n\n\tattribIds.sort();\n\tconst vbKey = attribIds.join();\n\tlet vb = vertexBufferDict[vbKey];\n\n\tif (!vb) {\n\t\tconst sourceDesc = {};\n\n\t\tfor (const attrib in useAttributes) {\n\t\t\tconst accessor = accessors[attributes[attrib]];\n\t\t\tconst accessorData = getAccessorData(accessor, bufferViews);\n\t\t\tconst bufferView = bufferViews[accessor.bufferView];\n\t\t\tconst semantic = gltfToEngineSemanticMap[attrib];\n\t\t\tconst size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);\n\t\t\tconst stride = bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;\n\t\t\tsourceDesc[semantic] = {\n\t\t\t\tbuffer: accessorData.buffer,\n\t\t\t\tsize: size,\n\t\t\t\toffset: accessorData.byteOffset,\n\t\t\t\tstride: stride,\n\t\t\t\tcount: accessor.count,\n\t\t\t\tcomponents: getNumComponents(accessor.type),\n\t\t\t\ttype: getComponentType(accessor.componentType),\n\t\t\t\tnormalize: accessor.normalized\n\t\t\t};\n\t\t}\n\n\t\tif (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {\n\t\t\tgenerateNormals(sourceDesc, indices);\n\t\t}\n\n\t\tvb = createVertexBufferInternal(device, sourceDesc, flipV);\n\t\tvertexBufferDict[vbKey] = vb;\n\t}\n\n\treturn vb;\n};\n\nconst createVertexBufferDraco = function createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV) {\n\tconst numPoints = outputGeometry.num_points();\n\n\tconst extractDracoAttributeInfo = function extractDracoAttributeInfo(uniqueId) {\n\t\tconst attribute = decoder.GetAttributeByUniqueId(outputGeometry, uniqueId);\n\t\tconst numValues = numPoints * attribute.num_components();\n\t\tconst dracoFormat = attribute.data_type();\n\t\tlet ptr, values, componentSizeInBytes, storageType;\n\n\t\tswitch (dracoFormat) {\n\t\t\tcase decoderModule.DT_UINT8:\n\t\t\t\tstorageType = TYPE_UINT8;\n\t\t\t\tcomponentSizeInBytes = 1;\n\t\t\t\tptr = decoderModule._malloc(numValues * componentSizeInBytes);\n\t\t\t\tdecoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT8, numValues * componentSizeInBytes, ptr);\n\t\t\t\tvalues = new Uint8Array(decoderModule.HEAPU8.buffer, ptr, numValues).slice();\n\t\t\t\tbreak;\n\n\t\t\tcase decoderModule.DT_UINT16:\n\t\t\t\tstorageType = TYPE_UINT16;\n\t\t\t\tcomponentSizeInBytes = 2;\n\t\t\t\tptr = decoderModule._malloc(numValues * componentSizeInBytes);\n\t\t\t\tdecoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_UINT16, numValues * componentSizeInBytes, ptr);\n\t\t\t\tvalues = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numValues).slice();\n\t\t\t\tbreak;\n\n\t\t\tcase decoderModule.DT_FLOAT32:\n\t\t\tdefault:\n\t\t\t\tstorageType = TYPE_FLOAT32;\n\t\t\t\tcomponentSizeInBytes = 4;\n\t\t\t\tptr = decoderModule._malloc(numValues * componentSizeInBytes);\n\t\t\t\tdecoder.GetAttributeDataArrayForAllPoints(outputGeometry, attribute, decoderModule.DT_FLOAT32, numValues * componentSizeInBytes, ptr);\n\t\t\t\tvalues = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues).slice();\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdecoderModule._free(ptr);\n\n\t\treturn {\n\t\t\tvalues: values,\n\t\t\tnumComponents: attribute.num_components(),\n\t\t\tcomponentSizeInBytes: componentSizeInBytes,\n\t\t\tstorageType: storageType,\n\t\t\tnormalized: attribute.normalized()\n\t\t};\n\t};\n\n\tconst sourceDesc = {};\n\tconst attributes = extDraco.attributes;\n\n\tfor (const attrib in attributes) {\n\t\tif (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {\n\t\t\tconst semantic = gltfToEngineSemanticMap[attrib];\n\t\t\tconst attributeInfo = extractDracoAttributeInfo(attributes[attrib]);\n\t\t\tconst size = attributeInfo.numComponents * attributeInfo.componentSizeInBytes;\n\t\t\tsourceDesc[semantic] = {\n\t\t\t\tvalues: attributeInfo.values,\n\t\t\t\tbuffer: attributeInfo.values.buffer,\n\t\t\t\tsize: size,\n\t\t\t\toffset: 0,\n\t\t\t\tstride: size,\n\t\t\t\tcount: numPoints,\n\t\t\t\tcomponents: attributeInfo.numComponents,\n\t\t\t\ttype: attributeInfo.storageType,\n\t\t\t\tnormalize: attributeInfo.normalized\n\t\t\t};\n\t\t}\n\t}\n\n\tif (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {\n\t\tgenerateNormals(sourceDesc, indices);\n\t}\n\n\treturn createVertexBufferInternal(device, sourceDesc, flipV);\n};\n\nconst createSkin = function createSkin(device, gltfSkin, accessors, bufferViews, nodes, glbSkins) {\n\tlet i, j, bindMatrix;\n\tconst joints = gltfSkin.joints;\n\tconst numJoints = joints.length;\n\tconst ibp = [];\n\n\tif (gltfSkin.hasOwnProperty('inverseBindMatrices')) {\n\t\tconst inverseBindMatrices = gltfSkin.inverseBindMatrices;\n\t\tconst ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);\n\t\tconst ibmValues = [];\n\n\t\tfor (i = 0; i < numJoints; i++) {\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tibmValues[j] = ibmData[i * 16 + j];\n\t\t\t}\n\n\t\t\tbindMatrix = new Mat4();\n\t\t\tbindMatrix.set(ibmValues);\n\t\t\tibp.push(bindMatrix);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < numJoints; i++) {\n\t\t\tbindMatrix = new Mat4();\n\t\t\tibp.push(bindMatrix);\n\t\t}\n\t}\n\n\tconst boneNames = [];\n\n\tfor (i = 0; i < numJoints; i++) {\n\t\tboneNames[i] = nodes[joints[i]].name;\n\t}\n\n\tconst key = boneNames.join(\"#\");\n\tlet skin = glbSkins.get(key);\n\n\tif (!skin) {\n\t\tskin = new Skin(device, ibp, boneNames);\n\t\tglbSkins.set(key, skin);\n\t}\n\n\treturn skin;\n};\n\nconst tempMat = new Mat4();\nconst tempVec$1 = new Vec3();\n\nconst createMesh = function createMesh(device, gltfMesh, accessors, bufferViews, callback, flipV, vertexBufferDict) {\n\tconst meshes = [];\n\tgltfMesh.primitives.forEach(function (primitive) {\n\t\tlet primitiveType, vertexBuffer, numIndices;\n\t\tlet indices = null;\n\t\tlet canUseMorph = true;\n\n\t\tif (primitive.hasOwnProperty('extensions')) {\n\t\t\tconst extensions = primitive.extensions;\n\n\t\t\tif (extensions.hasOwnProperty('KHR_draco_mesh_compression')) {\n\t\t\t\tconst decoderModule = window.DracoDecoderModule;\n\n\t\t\t\tif (decoderModule) {\n\t\t\t\t\tconst extDraco = extensions.KHR_draco_mesh_compression;\n\n\t\t\t\t\tif (extDraco.hasOwnProperty('attributes')) {\n\t\t\t\t\t\tconst uint8Buffer = bufferViews[extDraco.bufferView];\n\t\t\t\t\t\tconst buffer = new decoderModule.DecoderBuffer();\n\t\t\t\t\t\tbuffer.Init(uint8Buffer, uint8Buffer.length);\n\t\t\t\t\t\tconst decoder = new decoderModule.Decoder();\n\t\t\t\t\t\tconst geometryType = decoder.GetEncodedGeometryType(buffer);\n\t\t\t\t\t\tlet outputGeometry, status;\n\n\t\t\t\t\t\tswitch (geometryType) {\n\t\t\t\t\t\t\tcase decoderModule.POINT_CLOUD:\n\t\t\t\t\t\t\t\tprimitiveType = PRIMITIVE_POINTS;\n\t\t\t\t\t\t\t\toutputGeometry = new decoderModule.PointCloud();\n\t\t\t\t\t\t\t\tstatus = decoder.DecodeBufferToPointCloud(buffer, outputGeometry);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase decoderModule.TRIANGULAR_MESH:\n\t\t\t\t\t\t\t\tprimitiveType = PRIMITIVE_TRIANGLES;\n\t\t\t\t\t\t\t\toutputGeometry = new decoderModule.Mesh();\n\t\t\t\t\t\t\t\tstatus = decoder.DecodeBufferToMesh(buffer, outputGeometry);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase decoderModule.INVALID_GEOMETRY_TYPE:\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!status || !status.ok() || outputGeometry.ptr == 0) {\n\t\t\t\t\t\t\tcallback(\"Failed to decode draco compressed asset: \" + (status ? status.error_msg() : 'Mesh asset - invalid draco compressed geometry type: ' + geometryType));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst numFaces = outputGeometry.num_faces();\n\n\t\t\t\t\t\tif (geometryType === decoderModule.TRIANGULAR_MESH) {\n\t\t\t\t\t\t\tconst bit32 = outputGeometry.num_points() > 65535;\n\t\t\t\t\t\t\tnumIndices = numFaces * 3;\n\t\t\t\t\t\t\tconst dataSize = numIndices * (bit32 ? 4 : 2);\n\n\t\t\t\t\t\t\tconst ptr = decoderModule._malloc(dataSize);\n\n\t\t\t\t\t\t\tif (bit32) {\n\t\t\t\t\t\t\t\tdecoder.GetTrianglesUInt32Array(outputGeometry, dataSize, ptr);\n\t\t\t\t\t\t\t\tindices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdecoder.GetTrianglesUInt16Array(outputGeometry, dataSize, ptr);\n\t\t\t\t\t\t\t\tindices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdecoderModule._free(ptr);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexBuffer = createVertexBufferDraco(device, outputGeometry, extDraco, decoder, decoderModule, indices, flipV);\n\t\t\t\t\t\tdecoderModule.destroy(outputGeometry);\n\t\t\t\t\t\tdecoderModule.destroy(decoder);\n\t\t\t\t\t\tdecoderModule.destroy(buffer);\n\t\t\t\t\t\tcanUseMorph = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!vertexBuffer) {\n\t\t\tindices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;\n\t\t\tvertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);\n\t\t\tprimitiveType = getPrimitiveType(primitive);\n\t\t}\n\n\t\tlet mesh = null;\n\n\t\tif (vertexBuffer) {\n\t\t\tmesh = new Mesh(device);\n\t\t\tmesh.vertexBuffer = vertexBuffer;\n\t\t\tmesh.primitive[0].type = primitiveType;\n\t\t\tmesh.primitive[0].base = 0;\n\t\t\tmesh.primitive[0].indexed = indices !== null;\n\n\t\t\tif (indices !== null) {\n\t\t\t\tlet indexFormat;\n\n\t\t\t\tif (indices instanceof Uint8Array) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT8;\n\t\t\t\t} else if (indices instanceof Uint16Array) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT16;\n\t\t\t\t} else {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT32;\n\t\t\t\t}\n\n\t\t\t\tif (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT16;\n\t\t\t\t\tindices = new Uint16Array(indices);\n\t\t\t\t}\n\n\t\t\t\tconst indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);\n\t\t\t\tmesh.indexBuffer[0] = indexBuffer;\n\t\t\t\tmesh.primitive[0].count = indices.length;\n\t\t\t} else {\n\t\t\t\tmesh.primitive[0].count = vertexBuffer.numVertices;\n\t\t\t}\n\n\t\t\tmesh.materialIndex = primitive.material;\n\t\t\tlet accessor = accessors[primitive.attributes.POSITION];\n\t\t\tmesh.aabb = getAccessorBoundingBox(accessor);\n\n\t\t\tif (canUseMorph && primitive.hasOwnProperty('targets')) {\n\t\t\t\tconst targets = [];\n\t\t\t\tprimitive.targets.forEach(function (target, index) {\n\t\t\t\t\tconst options = {};\n\n\t\t\t\t\tif (target.hasOwnProperty('POSITION')) {\n\t\t\t\t\t\taccessor = accessors[target.POSITION];\n\t\t\t\t\t\toptions.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);\n\t\t\t\t\t\toptions.deltaPositionsType = TYPE_FLOAT32;\n\t\t\t\t\t\toptions.aabb = getAccessorBoundingBox(accessor);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target.hasOwnProperty('NORMAL')) {\n\t\t\t\t\t\taccessor = accessors[target.NORMAL];\n\t\t\t\t\t\toptions.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);\n\t\t\t\t\t\toptions.deltaNormalsType = TYPE_FLOAT32;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {\n\t\t\t\t\t\toptions.name = gltfMesh.extras.targetNames[index];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.name = index.toString(10);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gltfMesh.hasOwnProperty('weights')) {\n\t\t\t\t\t\toptions.defaultWeight = gltfMesh.weights[index];\n\t\t\t\t\t}\n\n\t\t\t\t\ttargets.push(new MorphTarget(options));\n\t\t\t\t});\n\t\t\t\tmesh.morph = new Morph(targets, device);\n\t\t\t}\n\t\t}\n\n\t\tmeshes.push(mesh);\n\t});\n\treturn meshes;\n};\n\nconst createMaterial = function createMaterial(gltfMaterial, textures, flipV) {\n\tconst glossChunk = [\"#ifdef MAPFLOAT\", \"uniform float material_shininess;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"uniform sampler2D texture_glossMap;\", \"#endif\", \"\", \"void getGlossiness() {\", \"\t\tdGlossiness = 1.0;\", \"\", \"#ifdef MAPFLOAT\", \"\t\tdGlossiness *= material_shininess;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"\t\tdGlossiness *= texture2D(texture_glossMap, $UV).$CH;\", \"#endif\", \"\", \"#ifdef MAPVERTEX\", \"\t\tdGlossiness *= saturate(vVertexColor.$VC);\", \"#endif\", \"\", \"\t\tdGlossiness = 1.0 - dGlossiness;\", \"\", \"\t\tdGlossiness += 0.0000001;\", \"}\"].join('\\n');\n\tconst specularChunk = [\"#ifdef MAPCOLOR\", \"uniform vec3 material_specular;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"uniform sampler2D texture_specularMap;\", \"#endif\", \"\", \"void getSpecularity() {\", \"\t\tdSpecularity = vec3(1.0);\", \"\", \"\t\t#ifdef MAPCOLOR\", \"\t\t\t\tdSpecularity *= material_specular;\", \"\t\t#endif\", \"\", \"\t\t#ifdef MAPTEXTURE\", \"\t\t\t\tvec3 srgb = texture2D(texture_specularMap, $UV).$CH;\", \"\t\t\t\tdSpecularity *= vec3(pow(srgb.r, 2.2), pow(srgb.g, 2.2), pow(srgb.b, 2.2));\", \"\t\t#endif\", \"\", \"\t\t#ifdef MAPVERTEX\", \"\t\t\t\tdSpecularity *= saturate(vVertexColor.$VC);\", \"\t\t#endif\", \"}\"].join('\\n');\n\tconst clearCoatGlossChunk = [\"#ifdef MAPFLOAT\", \"uniform float material_clearCoatGlossiness;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"uniform sampler2D texture_clearCoatGlossMap;\", \"#endif\", \"\", \"void getClearCoatGlossiness() {\", \"\t\tccGlossiness = 1.0;\", \"\", \"#ifdef MAPFLOAT\", \"\t\tccGlossiness *= material_clearCoatGlossiness;\", \"#endif\", \"\", \"#ifdef MAPTEXTURE\", \"\t\tccGlossiness *= texture2D(texture_clearCoatGlossMap, $UV).$CH;\", \"#endif\", \"\", \"#ifdef MAPVERTEX\", \"\t\tccGlossiness *= saturate(vVertexColor.$VC);\", \"#endif\", \"\", \"\t\tccGlossiness = 1.0 - ccGlossiness;\", \"\", \"\t\tccGlossiness += 0.0000001;\", \"}\"].join('\\n');\n\tconst zeros = [0, 0];\n\tconst ones = [1, 1];\n\n\tconst extractTextureTransform = function extractTextureTransform(source, material, maps) {\n\t\tvar _source$extensions;\n\n\t\tlet map;\n\t\tconst texCoord = source.texCoord;\n\n\t\tif (texCoord) {\n\t\t\tfor (map = 0; map < maps.length; ++map) {\n\t\t\t\tmaterial[maps[map] + 'MapUv'] = texCoord;\n\t\t\t}\n\t\t}\n\n\t\tconst textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;\n\n\t\tif (textureTransform) {\n\t\t\tconst offset = textureTransform.offset || zeros;\n\t\t\tconst scale = textureTransform.scale || ones;\n\t\t\tconst rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;\n\t\t\tconst tilingVec = new Vec2(scale[0], scale[1]);\n\t\t\tconst offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);\n\n\t\t\tfor (map = 0; map < maps.length; ++map) {\n\t\t\t\tmaterial[`${maps[map]}MapTiling`] = tilingVec;\n\t\t\t\tmaterial[`${maps[map]}MapOffset`] = offsetVec;\n\t\t\t\tmaterial[`${maps[map]}MapRotation`] = rotation;\n\t\t\t}\n\t\t}\n\t};\n\n\tconst material = new StandardMaterial();\n\tmaterial.occludeSpecular = true;\n\tmaterial.diffuseTint = true;\n\tmaterial.diffuseVertexColor = true;\n\tmaterial.specularTint = true;\n\tmaterial.specularVertexColor = true;\n\n\tif (gltfMaterial.hasOwnProperty('name')) {\n\t\tmaterial.name = gltfMaterial.name;\n\t}\n\n\tlet color, texture;\n\n\tif (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_pbrSpecularGlossiness')) {\n\t\tconst specData = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;\n\n\t\tif (specData.hasOwnProperty('diffuseFactor')) {\n\t\t\tcolor = specData.diffuseFactor;\n\t\t\tmaterial.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\t\tmaterial.opacity = color[3];\n\t\t} else {\n\t\t\tmaterial.diffuse.set(1, 1, 1);\n\t\t\tmaterial.opacity = 1;\n\t\t}\n\n\t\tif (specData.hasOwnProperty('diffuseTexture')) {\n\t\t\tconst diffuseTexture = specData.diffuseTexture;\n\t\t\ttexture = textures[diffuseTexture.index];\n\t\t\tmaterial.diffuseMap = texture;\n\t\t\tmaterial.diffuseMapChannel = 'rgb';\n\t\t\tmaterial.opacityMap = texture;\n\t\t\tmaterial.opacityMapChannel = 'a';\n\t\t\textractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);\n\t\t}\n\n\t\tmaterial.useMetalness = false;\n\n\t\tif (specData.hasOwnProperty('specularFactor')) {\n\t\t\tcolor = specData.specularFactor;\n\t\t\tmaterial.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\t} else {\n\t\t\tmaterial.specular.set(1, 1, 1);\n\t\t}\n\n\t\tif (specData.hasOwnProperty('glossinessFactor')) {\n\t\t\tmaterial.shininess = 100 * specData.glossinessFactor;\n\t\t} else {\n\t\t\tmaterial.shininess = 100;\n\t\t}\n\n\t\tif (specData.hasOwnProperty('specularGlossinessTexture')) {\n\t\t\tconst specularGlossinessTexture = specData.specularGlossinessTexture;\n\t\t\tmaterial.specularMap = material.glossMap = textures[specularGlossinessTexture.index];\n\t\t\tmaterial.specularMapChannel = 'rgb';\n\t\t\tmaterial.glossMapChannel = 'a';\n\t\t\textractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);\n\t\t}\n\n\t\tmaterial.chunks.specularPS = specularChunk;\n\t} else if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {\n\t\tconst pbrData = gltfMaterial.pbrMetallicRoughness;\n\n\t\tif (pbrData.hasOwnProperty('baseColorFactor')) {\n\t\t\tcolor = pbrData.baseColorFactor;\n\t\t\tmaterial.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\t\tmaterial.opacity = color[3];\n\t\t} else {\n\t\t\tmaterial.diffuse.set(1, 1, 1);\n\t\t\tmaterial.opacity = 1;\n\t\t}\n\n\t\tif (pbrData.hasOwnProperty('baseColorTexture')) {\n\t\t\tconst baseColorTexture = pbrData.baseColorTexture;\n\t\t\ttexture = textures[baseColorTexture.index];\n\t\t\tmaterial.diffuseMap = texture;\n\t\t\tmaterial.diffuseMapChannel = 'rgb';\n\t\t\tmaterial.opacityMap = texture;\n\t\t\tmaterial.opacityMapChannel = 'a';\n\t\t\textractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);\n\t\t}\n\n\t\tmaterial.useMetalness = true;\n\n\t\tif (pbrData.hasOwnProperty('metallicFactor')) {\n\t\t\tmaterial.metalness = pbrData.metallicFactor;\n\t\t} else {\n\t\t\tmaterial.metalness = 1;\n\t\t}\n\n\t\tif (pbrData.hasOwnProperty('roughnessFactor')) {\n\t\t\tmaterial.shininess = 100 * pbrData.roughnessFactor;\n\t\t} else {\n\t\t\tmaterial.shininess = 100;\n\t\t}\n\n\t\tif (pbrData.hasOwnProperty('metallicRoughnessTexture')) {\n\t\t\tconst metallicRoughnessTexture = pbrData.metallicRoughnessTexture;\n\t\t\tmaterial.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];\n\t\t\tmaterial.metalnessMapChannel = 'b';\n\t\t\tmaterial.glossMapChannel = 'g';\n\t\t\textractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);\n\t\t}\n\n\t\tmaterial.chunks.glossPS = glossChunk;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('normalTexture')) {\n\t\tconst normalTexture = gltfMaterial.normalTexture;\n\t\tmaterial.normalMap = textures[normalTexture.index];\n\t\textractTextureTransform(normalTexture, material, ['normal']);\n\n\t\tif (normalTexture.hasOwnProperty('scale')) {\n\t\t\tmaterial.bumpiness = normalTexture.scale;\n\t\t}\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('occlusionTexture')) {\n\t\tconst occlusionTexture = gltfMaterial.occlusionTexture;\n\t\tmaterial.aoMap = textures[occlusionTexture.index];\n\t\tmaterial.aoMapChannel = 'r';\n\t\textractTextureTransform(occlusionTexture, material, ['ao']);\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('emissiveFactor')) {\n\t\tcolor = gltfMaterial.emissiveFactor;\n\t\tmaterial.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\tmaterial.emissiveTint = true;\n\t} else {\n\t\tmaterial.emissive.set(0, 0, 0);\n\t\tmaterial.emissiveTint = false;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('emissiveTexture')) {\n\t\tconst emissiveTexture = gltfMaterial.emissiveTexture;\n\t\tmaterial.emissiveMap = textures[emissiveTexture.index];\n\t\textractTextureTransform(emissiveTexture, material, ['emissive']);\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('alphaMode')) {\n\t\tswitch (gltfMaterial.alphaMode) {\n\t\t\tcase 'MASK':\n\t\t\t\tmaterial.blendType = BLEND_NONE;\n\n\t\t\t\tif (gltfMaterial.hasOwnProperty('alphaCutoff')) {\n\t\t\t\t\tmaterial.alphaTest = gltfMaterial.alphaCutoff;\n\t\t\t\t} else {\n\t\t\t\t\tmaterial.alphaTest = 0.5;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'BLEND':\n\t\t\t\tmaterial.blendType = BLEND_NORMAL;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tcase 'OPAQUE':\n\t\t\t\tmaterial.blendType = BLEND_NONE;\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmaterial.blendType = BLEND_NONE;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('doubleSided')) {\n\t\tmaterial.twoSidedLighting = gltfMaterial.doubleSided;\n\t\tmaterial.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;\n\t} else {\n\t\tmaterial.twoSidedLighting = false;\n\t\tmaterial.cull = CULLFACE_BACK;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_clearcoat')) {\n\t\tconst ccData = gltfMaterial.extensions.KHR_materials_clearcoat;\n\n\t\tif (ccData.hasOwnProperty('clearcoatFactor')) {\n\t\t\tmaterial.clearCoat = ccData.clearcoatFactor * 0.25;\n\t\t} else {\n\t\t\tmaterial.clearCoat = 0;\n\t\t}\n\n\t\tif (ccData.hasOwnProperty('clearcoatTexture')) {\n\t\t\tconst clearcoatTexture = ccData.clearcoatTexture;\n\t\t\tmaterial.clearCoatMap = textures[clearcoatTexture.index];\n\t\t\tmaterial.clearCoatMapChannel = 'r';\n\t\t\textractTextureTransform(clearcoatTexture, material, ['clearCoat']);\n\t\t}\n\n\t\tif (ccData.hasOwnProperty('clearcoatRoughnessFactor')) {\n\t\t\tmaterial.clearCoatGlossiness = ccData.clearcoatRoughnessFactor;\n\t\t} else {\n\t\t\tmaterial.clearCoatGlossiness = 0;\n\t\t}\n\n\t\tif (ccData.hasOwnProperty('clearcoatRoughnessTexture')) {\n\t\t\tconst clearcoatRoughnessTexture = ccData.clearcoatRoughnessTexture;\n\t\t\tmaterial.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];\n\t\t\tmaterial.clearCoatGlossMapChannel = 'g';\n\t\t\textractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);\n\t\t}\n\n\t\tif (ccData.hasOwnProperty('clearcoatNormalTexture')) {\n\t\t\tconst clearcoatNormalTexture = ccData.clearcoatNormalTexture;\n\t\t\tmaterial.clearCoatNormalMap = textures[clearcoatNormalTexture.index];\n\t\t\textractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);\n\n\t\t\tif (clearcoatNormalTexture.hasOwnProperty('scale')) {\n\t\t\t\tmaterial.clearCoatBumpiness = clearcoatNormalTexture.scale;\n\t\t\t}\n\t\t}\n\n\t\tmaterial.chunks.clearCoatGlossPS = clearCoatGlossChunk;\n\t}\n\n\tif (gltfMaterial.hasOwnProperty('extensions') && gltfMaterial.extensions.hasOwnProperty('KHR_materials_unlit')) {\n\t\tmaterial.useLighting = false;\n\t\tmaterial.emissive.copy(material.diffuse);\n\t\tmaterial.emissiveTint = material.diffuseTint;\n\t\tmaterial.emissiveMap = material.diffuseMap;\n\t\tmaterial.emissiveMapUv = material.diffuseMapUv;\n\t\tmaterial.emissiveMapTiling.copy(material.diffuseMapTiling);\n\t\tmaterial.emissiveMapOffset.copy(material.diffuseMapOffset);\n\t\tmaterial.emissiveMapChannel = material.diffuseMapChannel;\n\t\tmaterial.emissiveVertexColor = material.diffuseVertexColor;\n\t\tmaterial.emissiveVertexColorChannel = material.diffuseVertexColorChannel;\n\t\tmaterial.diffuse.set(0, 0, 0);\n\t\tmaterial.diffuseTint = false;\n\t\tmaterial.diffuseMap = null;\n\t\tmaterial.diffuseVertexColor = false;\n\t}\n\n\tmaterial.update();\n\treturn material;\n};\n\nconst createAnimation = function createAnimation(gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes) {\n\tconst createAnimData = function createAnimData(gltfAccessor) {\n\t\treturn new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));\n\t};\n\n\tconst interpMap = {\n\t\t\"STEP\": INTERPOLATION_STEP,\n\t\t\"LINEAR\": INTERPOLATION_LINEAR,\n\t\t\"CUBICSPLINE\": INTERPOLATION_CUBIC\n\t};\n\tconst inputMap = {};\n\tconst inputs = [];\n\tconst outputMap = {};\n\tconst outputs = [];\n\tconst curves = [];\n\tlet i;\n\n\tfor (i = 0; i < gltfAnimation.samplers.length; ++i) {\n\t\tconst sampler = gltfAnimation.samplers[i];\n\n\t\tif (!inputMap.hasOwnProperty(sampler.input)) {\n\t\t\tinputMap[sampler.input] = inputs.length;\n\t\t\tinputs.push(createAnimData(gltfAccessors[sampler.input]));\n\t\t}\n\n\t\tif (!outputMap.hasOwnProperty(sampler.output)) {\n\t\t\toutputMap[sampler.output] = outputs.length;\n\t\t\toutputs.push(createAnimData(gltfAccessors[sampler.output]));\n\t\t}\n\n\t\tconst interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;\n\t\tcurves.push(new AnimCurve([], inputMap[sampler.input], outputMap[sampler.output], interpolation));\n\t}\n\n\tconst quatArrays = [];\n\tconst transformSchema = {\n\t\t'translation': 'localPosition',\n\t\t'rotation': 'localRotation',\n\t\t'scale': 'localScale',\n\t\t'weights': 'weights'\n\t};\n\n\tconst constructNodePath = node => {\n\t\tconst path = [];\n\n\t\twhile (node) {\n\t\t\tpath.unshift(node.name);\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn path;\n\t};\n\n\tfor (i = 0; i < gltfAnimation.channels.length; ++i) {\n\t\tconst channel = gltfAnimation.channels[i];\n\t\tconst target = channel.target;\n\t\tconst curve = curves[channel.sampler];\n\t\tconst node = nodes[target.node];\n\t\tconst entityPath = constructNodePath(node);\n\n\t\tcurve._paths.push({\n\t\t\tentityPath: entityPath,\n\t\t\tcomponent: 'graph',\n\t\t\tpropertyPath: [transformSchema[target.path]]\n\t\t});\n\n\t\tif (target.path.startsWith('rotation') && curve.interpolation !== INTERPOLATION_CUBIC) {\n\t\t\tquatArrays.push(curve.output);\n\t\t} else if (target.path.startsWith('weights')) {\n\t\t\toutputs[curve.output]._components = outputs[curve.output].data.length / inputs[curve.input].data.length;\n\t\t}\n\t}\n\n\tquatArrays.sort();\n\tlet prevIndex = null;\n\tlet data;\n\n\tfor (i = 0; i < quatArrays.length; ++i) {\n\t\tconst index = quatArrays[i];\n\n\t\tif (i === 0 || index !== prevIndex) {\n\t\t\tdata = outputs[index];\n\n\t\t\tif (data.components === 4) {\n\t\t\t\tconst d = data.data;\n\t\t\t\tconst len = d.length - 4;\n\n\t\t\t\tfor (let j = 0; j < len; j += 4) {\n\t\t\t\t\tconst dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];\n\n\t\t\t\t\tif (dp < 0) {\n\t\t\t\t\t\td[j + 4] *= -1;\n\t\t\t\t\t\td[j + 5] *= -1;\n\t\t\t\t\t\td[j + 6] *= -1;\n\t\t\t\t\t\td[j + 7] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprevIndex = index;\n\t\t}\n\t}\n\n\tlet duration = 0;\n\n\tfor (i = 0; i < inputs.length; i++) {\n\t\tdata = inputs[i]._data;\n\t\tduration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);\n\t}\n\n\treturn new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : \"animation_\" + animationIndex, duration, inputs, outputs, curves);\n};\n\nconst createNode = function createNode(gltfNode, nodeIndex) {\n\tconst entity = new GraphNode();\n\n\tif (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {\n\t\tentity.name = gltfNode.name;\n\t} else {\n\t\tentity.name = \"node_\" + nodeIndex;\n\t}\n\n\tif (gltfNode.hasOwnProperty('matrix')) {\n\t\ttempMat.data.set(gltfNode.matrix);\n\t\ttempMat.getTranslation(tempVec$1);\n\t\tentity.setLocalPosition(tempVec$1);\n\t\ttempMat.getEulerAngles(tempVec$1);\n\t\tentity.setLocalEulerAngles(tempVec$1);\n\t\ttempMat.getScale(tempVec$1);\n\t\tentity.setLocalScale(tempVec$1);\n\t}\n\n\tif (gltfNode.hasOwnProperty('rotation')) {\n\t\tconst r = gltfNode.rotation;\n\t\tentity.setLocalRotation(r[0], r[1], r[2], r[3]);\n\t}\n\n\tif (gltfNode.hasOwnProperty('translation')) {\n\t\tconst t = gltfNode.translation;\n\t\tentity.setLocalPosition(t[0], t[1], t[2]);\n\t}\n\n\tif (gltfNode.hasOwnProperty('scale')) {\n\t\tconst s = gltfNode.scale;\n\t\tentity.setLocalScale(s[0], s[1], s[2]);\n\t}\n\n\treturn entity;\n};\n\nconst createCamera = function createCamera(gltfCamera, node) {\n\tconst projection = gltfCamera.type === \"orthographic\" ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;\n\tconst gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;\n\tconst componentData = {\n\t\tenabled: false,\n\t\tprojection: projection,\n\t\tnearClip: gltfProperties.znear,\n\t\taspectRatioMode: ASPECT_AUTO\n\t};\n\n\tif (gltfProperties.zfar) {\n\t\tcomponentData.farClip = gltfProperties.zfar;\n\t}\n\n\tif (projection === PROJECTION_ORTHOGRAPHIC) {\n\t\tcomponentData.orthoHeight = 0.5 * gltfProperties.ymag;\n\n\t\tif (gltfProperties.ymag) {\n\t\t\tcomponentData.aspectRatioMode = ASPECT_MANUAL;\n\t\t\tcomponentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;\n\t\t}\n\t} else {\n\t\tcomponentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;\n\n\t\tif (gltfProperties.aspectRatio) {\n\t\t\tcomponentData.aspectRatioMode = ASPECT_MANUAL;\n\t\t\tcomponentData.aspectRatio = gltfProperties.aspectRatio;\n\t\t}\n\t}\n\n\tconst cameraEntity = new Entity(gltfCamera.name);\n\tcameraEntity.addComponent(\"camera\", componentData);\n\treturn cameraEntity;\n};\n\nconst createLight = function createLight(gltfLight, node) {\n\tconst lightProps = {\n\t\tenabled: false,\n\t\ttype: gltfLight.type === \"point\" ? \"omni\" : gltfLight.type,\n\t\tcolor: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,\n\t\trange: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,\n\t\tfalloffMode: LIGHTFALLOFF_INVERSESQUARED,\n\t\tintensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1\n\t};\n\n\tif (gltfLight.hasOwnProperty('spot')) {\n\t\tlightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;\n\t\tlightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;\n\t}\n\n\tconst lightEntity = new Entity(node.name);\n\tlightEntity.rotateLocal(90, 0, 0);\n\tlightEntity.addComponent(\"light\", lightProps);\n\treturn lightEntity;\n};\n\nconst createSkins = function createSkins(device, gltf, nodes, bufferViews) {\n\tif (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst glbSkins = new Map();\n\treturn gltf.skins.map(function (gltfSkin) {\n\t\treturn createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);\n\t});\n};\n\nconst createMeshes = function createMeshes(device, gltf, bufferViews, callback, flipV) {\n\tif (!gltf.hasOwnProperty('meshes') || gltf.meshes.length === 0 || !gltf.hasOwnProperty('accessors') || gltf.accessors.length === 0 || !gltf.hasOwnProperty('bufferViews') || gltf.bufferViews.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst vertexBufferDict = {};\n\treturn gltf.meshes.map(function (gltfMesh) {\n\t\treturn createMesh(device, gltfMesh, gltf.accessors, bufferViews, callback, flipV, vertexBufferDict);\n\t});\n};\n\nconst createMaterials = function createMaterials(gltf, textures, options, flipV) {\n\tif (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst preprocess = options && options.material && options.material.preprocess;\n\tconst process = options && options.material && options.material.process || createMaterial;\n\tconst postprocess = options && options.material && options.material.postprocess;\n\treturn gltf.materials.map(function (gltfMaterial) {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfMaterial);\n\t\t}\n\n\t\tconst material = process(gltfMaterial, textures, flipV);\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfMaterial, material);\n\t\t}\n\n\t\treturn material;\n\t});\n};\n\nconst createAnimations = function createAnimations(gltf, nodes, bufferViews, options) {\n\tif (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst preprocess = options && options.animation && options.animation.preprocess;\n\tconst postprocess = options && options.animation && options.animation.postprocess;\n\treturn gltf.animations.map(function (gltfAnimation, index) {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfAnimation);\n\t\t}\n\n\t\tconst animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes);\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfAnimation, animation);\n\t\t}\n\n\t\treturn animation;\n\t});\n};\n\nconst createNodes = function createNodes(gltf, options) {\n\tif (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {\n\t\treturn [];\n\t}\n\n\tconst preprocess = options && options.node && options.node.preprocess;\n\tconst process = options && options.node && options.node.process || createNode;\n\tconst postprocess = options && options.node && options.node.postprocess;\n\tconst nodes = gltf.nodes.map(function (gltfNode, index) {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfNode);\n\t\t}\n\n\t\tconst node = process(gltfNode, index);\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfNode, node);\n\t\t}\n\n\t\treturn node;\n\t});\n\n\tfor (let i = 0; i < gltf.nodes.length; ++i) {\n\t\tconst gltfNode = gltf.nodes[i];\n\n\t\tif (gltfNode.hasOwnProperty('children')) {\n\t\t\tconst parent = nodes[i];\n\t\t\tconst uniqueNames = {};\n\n\t\t\tfor (let j = 0; j < gltfNode.children.length; ++j) {\n\t\t\t\tconst child = nodes[gltfNode.children[j]];\n\n\t\t\t\tif (!child.parent) {\n\t\t\t\t\tif (uniqueNames.hasOwnProperty(child.name)) {\n\t\t\t\t\t\tchild.name += uniqueNames[child.name]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuniqueNames[child.name] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tparent.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\nconst createScenes = function createScenes(gltf, nodes) {\n\tvar _gltf$scenes$0$nodes;\n\n\tconst scenes = [];\n\tconst count = gltf.scenes.length;\n\n\tif (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {\n\t\tconst nodeIndex = gltf.scenes[0].nodes[0];\n\t\tscenes.push(nodes[nodeIndex]);\n\t} else {\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst scene = gltf.scenes[i];\n\n\t\t\tif (scene.nodes) {\n\t\t\t\tconst sceneRoot = new GraphNode(scene.name);\n\n\t\t\t\tfor (let n = 0; n < scene.nodes.length; n++) {\n\t\t\t\t\tconst childNode = nodes[scene.nodes[n]];\n\t\t\t\t\tsceneRoot.addChild(childNode);\n\t\t\t\t}\n\n\t\t\t\tscenes.push(sceneRoot);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn scenes;\n};\n\nconst createCameras = function createCameras(gltf, nodes, options) {\n\tlet cameras = null;\n\n\tif (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {\n\t\tconst preprocess = options && options.camera && options.camera.preprocess;\n\t\tconst process = options && options.camera && options.camera.process || createCamera;\n\t\tconst postprocess = options && options.camera && options.camera.postprocess;\n\t\tgltf.nodes.forEach(function (gltfNode, nodeIndex) {\n\t\t\tif (gltfNode.hasOwnProperty('camera')) {\n\t\t\t\tconst gltfCamera = gltf.cameras[gltfNode.camera];\n\n\t\t\t\tif (gltfCamera) {\n\t\t\t\t\tif (preprocess) {\n\t\t\t\t\t\tpreprocess(gltfCamera);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst camera = process(gltfCamera, nodes[nodeIndex]);\n\n\t\t\t\t\tif (postprocess) {\n\t\t\t\t\t\tpostprocess(gltfCamera, camera);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (camera) {\n\t\t\t\t\t\tif (!cameras) cameras = new Map();\n\t\t\t\t\t\tcameras.set(gltfNode, camera);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn cameras;\n};\n\nconst createLights = function createLights(gltf, nodes, options) {\n\tlet lights = null;\n\n\tif (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {\n\t\tconst gltfLights = gltf.extensions.KHR_lights_punctual.lights;\n\n\t\tif (gltfLights.length) {\n\t\t\tconst preprocess = options && options.light && options.light.preprocess;\n\t\t\tconst process = options && options.light && options.light.process || createLight;\n\t\t\tconst postprocess = options && options.light && options.light.postprocess;\n\t\t\tgltf.nodes.forEach(function (gltfNode, nodeIndex) {\n\t\t\t\tif (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {\n\t\t\t\t\tconst lightIndex = gltfNode.extensions.KHR_lights_punctual.light;\n\t\t\t\t\tconst gltfLight = gltfLights[lightIndex];\n\n\t\t\t\t\tif (gltfLight) {\n\t\t\t\t\t\tif (preprocess) {\n\t\t\t\t\t\t\tpreprocess(gltfLight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst light = process(gltfLight, nodes[nodeIndex]);\n\n\t\t\t\t\t\tif (postprocess) {\n\t\t\t\t\t\t\tpostprocess(gltfLight, light);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (light) {\n\t\t\t\t\t\t\tif (!lights) lights = new Map();\n\t\t\t\t\t\t\tlights.set(gltfNode, light);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\treturn lights;\n};\n\nconst linkSkins = function linkSkins(gltf, renders, skins) {\n\tgltf.nodes.forEach(gltfNode => {\n\t\tif (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {\n\t\t\tconst meshGroup = renders[gltfNode.mesh].meshes;\n\t\t\tmeshGroup.forEach(mesh => {\n\t\t\t\tmesh.skin = skins[gltfNode.skin];\n\t\t\t});\n\t\t}\n\t});\n};\n\nconst createResources = function createResources(device, gltf, bufferViews, textureAssets, options, callback) {\n\tconst preprocess = options && options.global && options.global.preprocess;\n\tconst postprocess = options && options.global && options.global.postprocess;\n\n\tif (preprocess) {\n\t\tpreprocess(gltf);\n\t}\n\n\tconst flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';\n\tconst nodes = createNodes(gltf, options);\n\tconst scenes = createScenes(gltf, nodes);\n\tconst lights = createLights(gltf, nodes, options);\n\tconst cameras = createCameras(gltf, nodes, options);\n\tconst animations = createAnimations(gltf, nodes, bufferViews, options);\n\tconst materials = createMaterials(gltf, textureAssets.map(function (textureAsset) {\n\t\treturn textureAsset.resource;\n\t}), options, flipV);\n\tconst meshes = createMeshes(device, gltf, bufferViews, callback, flipV);\n\tconst skins = createSkins(device, gltf, nodes, bufferViews);\n\tconst renders = [];\n\n\tfor (let i = 0; i < meshes.length; i++) {\n\t\trenders[i] = new Render();\n\t\trenders[i].meshes = meshes[i];\n\t}\n\n\tlinkSkins(gltf, renders, skins);\n\tconst result = new GlbResources(gltf);\n\tresult.nodes = nodes;\n\tresult.scenes = scenes;\n\tresult.animations = animations;\n\tresult.textures = textureAssets;\n\tresult.materials = materials;\n\tresult.renders = renders;\n\tresult.skins = skins;\n\tresult.lights = lights;\n\tresult.cameras = cameras;\n\n\tif (postprocess) {\n\t\tpostprocess(gltf, result);\n\t}\n\n\tcallback(null, result);\n};\n\nconst applySampler = function applySampler(texture, gltfSampler) {\n\tconst getFilter = function getFilter(filter, defaultValue) {\n\t\tswitch (filter) {\n\t\t\tcase 9728:\n\t\t\t\treturn FILTER_NEAREST;\n\n\t\t\tcase 9729:\n\t\t\t\treturn FILTER_LINEAR;\n\n\t\t\tcase 9984:\n\t\t\t\treturn FILTER_NEAREST_MIPMAP_NEAREST;\n\n\t\t\tcase 9985:\n\t\t\t\treturn FILTER_LINEAR_MIPMAP_NEAREST;\n\n\t\t\tcase 9986:\n\t\t\t\treturn FILTER_NEAREST_MIPMAP_LINEAR;\n\n\t\t\tcase 9987:\n\t\t\t\treturn FILTER_LINEAR_MIPMAP_LINEAR;\n\n\t\t\tdefault:\n\t\t\t\treturn defaultValue;\n\t\t}\n\t};\n\n\tconst getWrap = function getWrap(wrap, defaultValue) {\n\t\tswitch (wrap) {\n\t\t\tcase 33071:\n\t\t\t\treturn ADDRESS_CLAMP_TO_EDGE;\n\n\t\t\tcase 33648:\n\t\t\t\treturn ADDRESS_MIRRORED_REPEAT;\n\n\t\t\tcase 10497:\n\t\t\t\treturn ADDRESS_REPEAT;\n\n\t\t\tdefault:\n\t\t\t\treturn defaultValue;\n\t\t}\n\t};\n\n\tif (texture) {\n\t\tgltfSampler = gltfSampler || {};\n\t\ttexture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);\n\t\ttexture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);\n\t\ttexture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);\n\t\ttexture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);\n\t}\n};\n\nlet gltfTextureUniqueId = 0;\n\nconst loadImageAsync = function loadImageAsync(gltfImage, index, bufferViews, urlBase, registry, options, callback) {\n\tconst preprocess = options && options.image && options.image.preprocess;\n\n\tconst processAsync = options && options.image && options.image.processAsync || function (gltfImage, callback) {\n\t\tcallback(null, null);\n\t};\n\n\tconst postprocess = options && options.image && options.image.postprocess;\n\n\tconst onLoad = function onLoad(textureAsset) {\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfImage, textureAsset);\n\t\t}\n\n\t\tcallback(null, textureAsset);\n\t};\n\n\tconst mimeTypeFileExtensions = {\n\t\t'image/png': 'png',\n\t\t'image/jpeg': 'jpg',\n\t\t'image/basis': 'basis',\n\t\t'image/ktx': 'ktx',\n\t\t'image/ktx2': 'ktx2',\n\t\t'image/vnd-ms.dds': 'dds'\n\t};\n\n\tconst loadTexture = function loadTexture(url, bufferView, mimeType, options) {\n\t\tconst name = (gltfImage.name || 'gltf-texture') + '-' + gltfTextureUniqueId++;\n\t\tconst file = {\n\t\t\turl: url || name\n\t\t};\n\n\t\tif (bufferView) {\n\t\t\tfile.contents = bufferView.slice(0).buffer;\n\t\t}\n\n\t\tif (mimeType) {\n\t\t\tconst extension = mimeTypeFileExtensions[mimeType];\n\n\t\t\tif (extension) {\n\t\t\t\tfile.filename = file.url + '.' + extension;\n\t\t\t}\n\t\t}\n\n\t\tconst asset = new Asset(name, 'texture', file, null, options);\n\t\tasset.on('load', onLoad);\n\t\tasset.on('error', callback);\n\t\tregistry.add(asset);\n\t\tregistry.load(asset);\n\t};\n\n\tif (preprocess) {\n\t\tpreprocess(gltfImage);\n\t}\n\n\tprocessAsync(gltfImage, function (err, textureAsset) {\n\t\tif (err) {\n\t\t\tcallback(err);\n\t\t} else if (textureAsset) {\n\t\t\tonLoad(textureAsset);\n\t\t} else {\n\t\t\tif (gltfImage.hasOwnProperty('uri')) {\n\t\t\t\tif (isDataURI(gltfImage.uri)) {\n\t\t\t\t\tloadTexture(gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);\n\t\t\t\t} else {\n\t\t\t\t\tloadTexture(path.join(urlBase, gltfImage.uri), null, null, {\n\t\t\t\t\t\tcrossOrigin: \"anonymous\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {\n\t\t\t\tloadTexture(null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);\n\t\t\t} else {\n\t\t\t\tcallback(\"Invalid image found in gltf (neither uri or bufferView found). index=\" + index);\n\t\t\t}\n\t\t}\n\t});\n};\n\nconst loadTexturesAsync = function loadTexturesAsync(gltf, bufferViews, urlBase, registry, options, callback) {\n\tif (!gltf.hasOwnProperty('images') || gltf.images.length === 0 || !gltf.hasOwnProperty('textures') || gltf.textures.length === 0) {\n\t\tcallback(null, []);\n\t\treturn;\n\t}\n\n\tconst preprocess = options && options.texture && options.texture.preprocess;\n\n\tconst processAsync = options && options.texture && options.texture.processAsync || function (gltfTexture, gltfImages, callback) {\n\t\tcallback(null, null);\n\t};\n\n\tconst postprocess = options && options.texture && options.texture.postprocess;\n\tconst assets = [];\n\tconst textures = [];\n\tlet remaining = gltf.textures.length;\n\n\tconst onLoad = function onLoad(textureIndex, imageIndex) {\n\t\tif (!textures[imageIndex]) {\n\t\t\ttextures[imageIndex] = [];\n\t\t}\n\n\t\ttextures[imageIndex].push(textureIndex);\n\n\t\tif (--remaining === 0) {\n\t\t\tconst result = [];\n\t\t\ttextures.forEach(function (textureList, imageIndex) {\n\t\t\t\ttextureList.forEach(function (textureIndex, index) {\n\t\t\t\t\tconst textureAsset = index === 0 ? assets[imageIndex] : cloneTextureAsset(assets[imageIndex]);\n\t\t\t\t\tapplySampler(textureAsset.resource, (gltf.samplers || [])[gltf.textures[textureIndex].sampler]);\n\t\t\t\t\tresult[textureIndex] = textureAsset;\n\n\t\t\t\t\tif (postprocess) {\n\t\t\t\t\t\tpostprocess(gltf.textures[textureIndex], textureAsset);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tcallback(null, result);\n\t\t}\n\t};\n\n\tfor (let i = 0; i < gltf.textures.length; ++i) {\n\t\tconst gltfTexture = gltf.textures[i];\n\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfTexture);\n\t\t}\n\n\t\tprocessAsync(gltfTexture, gltf.images, function (i, gltfTexture, err, gltfImageIndex) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tif (gltfImageIndex === undefined || gltfImageIndex === null) {\n\t\t\t\t\tvar _gltfTexture$extensio, _gltfTexture$extensio2;\n\n\t\t\t\t\tgltfImageIndex = gltfTexture == null ? void 0 : (_gltfTexture$extensio = gltfTexture.extensions) == null ? void 0 : (_gltfTexture$extensio2 = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio2.source;\n\n\t\t\t\t\tif (gltfImageIndex === undefined) {\n\t\t\t\t\t\tgltfImageIndex = gltfTexture.source;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (assets[gltfImageIndex]) {\n\t\t\t\t\tonLoad(i, gltfImageIndex);\n\t\t\t\t} else {\n\t\t\t\t\tconst gltfImage = gltf.images[gltfImageIndex];\n\t\t\t\t\tloadImageAsync(gltfImage, i, bufferViews, urlBase, registry, options, function (err, textureAsset) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassets[gltfImageIndex] = textureAsset;\n\t\t\t\t\t\t\tonLoad(i, gltfImageIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(null, i, gltfTexture));\n\t}\n};\n\nconst loadBuffersAsync = function loadBuffersAsync(gltf, binaryChunk, urlBase, options, callback) {\n\tconst result = [];\n\n\tif (!gltf.buffers || gltf.buffers.length === 0) {\n\t\tcallback(null, result);\n\t\treturn;\n\t}\n\n\tconst preprocess = options && options.buffer && options.buffer.preprocess;\n\n\tconst processAsync = options && options.buffer && options.buffer.processAsync || function (gltfBuffer, callback) {\n\t\tcallback(null, null);\n\t};\n\n\tconst postprocess = options && options.buffer && options.buffer.postprocess;\n\tlet remaining = gltf.buffers.length;\n\n\tconst onLoad = function onLoad(index, buffer) {\n\t\tresult[index] = buffer;\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltf.buffers[index], buffer);\n\t\t}\n\n\t\tif (--remaining === 0) {\n\t\t\tcallback(null, result);\n\t\t}\n\t};\n\n\tfor (let i = 0; i < gltf.buffers.length; ++i) {\n\t\tconst gltfBuffer = gltf.buffers[i];\n\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfBuffer);\n\t\t}\n\n\t\tprocessAsync(gltfBuffer, function (i, gltfBuffer, err, arrayBuffer) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else if (arrayBuffer) {\n\t\t\t\tonLoad(i, new Uint8Array(arrayBuffer));\n\t\t\t} else {\n\t\t\t\tif (gltfBuffer.hasOwnProperty('uri')) {\n\t\t\t\t\tif (isDataURI(gltfBuffer.uri)) {\n\t\t\t\t\t\tconst byteString = atob(gltfBuffer.uri.split(',')[1]);\n\t\t\t\t\t\tconst binaryArray = new Uint8Array(byteString.length);\n\n\t\t\t\t\t\tfor (let j = 0; j < byteString.length; j++) {\n\t\t\t\t\t\t\tbinaryArray[j] = byteString.charCodeAt(j);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tonLoad(i, binaryArray);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thttp.get(path.join(urlBase, gltfBuffer.uri), {\n\t\t\t\t\t\t\tcache: true,\n\t\t\t\t\t\t\tresponseType: 'arraybuffer',\n\t\t\t\t\t\t\tretry: false\n\t\t\t\t\t\t}, function (i, err, result) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tonLoad(i, new Uint8Array(result));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.bind(null, i));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tonLoad(i, binaryChunk);\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(null, i, gltfBuffer));\n\t}\n};\n\nconst parseGltf = function parseGltf(gltfChunk, callback) {\n\tconst decodeBinaryUtf8 = function decodeBinaryUtf8(array) {\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\treturn new TextDecoder().decode(array);\n\t\t}\n\n\t\tlet str = \"\";\n\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tstr += String.fromCharCode(array[i]);\n\t\t}\n\n\t\treturn decodeURIComponent(escape(str));\n\t};\n\n\tconst gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));\n\n\tif (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {\n\t\tcallback(`Invalid gltf version. Expected version 2.0 or above but found version '${gltf.asset.version}'.`);\n\t\treturn;\n\t}\n\n\tcallback(null, gltf);\n};\n\nconst parseGlb = function parseGlb(glbData, callback) {\n\tconst data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);\n\tconst magic = data.getUint32(0, true);\n\tconst version = data.getUint32(4, true);\n\tconst length = data.getUint32(8, true);\n\n\tif (magic !== 0x46546C67) {\n\t\tcallback(\"Invalid magic number found in glb header. Expected 0x46546C67, found 0x\" + magic.toString(16));\n\t\treturn;\n\t}\n\n\tif (version !== 2) {\n\t\tcallback(\"Invalid version number found in glb header. Expected 2, found \" + version);\n\t\treturn;\n\t}\n\n\tif (length <= 0 || length > data.byteLength) {\n\t\tcallback(\"Invalid length found in glb header. Found \" + length);\n\t\treturn;\n\t}\n\n\tconst chunks = [];\n\tlet offset = 12;\n\n\twhile (offset < length) {\n\t\tconst chunkLength = data.getUint32(offset, true);\n\n\t\tif (offset + chunkLength + 8 > data.byteLength) {\n\t\t\tthrow new Error(\"Invalid chunk length found in glb. Found \" + chunkLength);\n\t\t}\n\n\t\tconst chunkType = data.getUint32(offset + 4, true);\n\t\tconst chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);\n\t\tchunks.push({\n\t\t\tlength: chunkLength,\n\t\t\ttype: chunkType,\n\t\t\tdata: chunkData\n\t\t});\n\t\toffset += chunkLength + 8;\n\t}\n\n\tif (chunks.length !== 1 && chunks.length !== 2) {\n\t\tcallback(\"Invalid number of chunks found in glb file.\");\n\t\treturn;\n\t}\n\n\tif (chunks[0].type !== 0x4E4F534A) {\n\t\tcallback(\"Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x\" + chunks[0].type.toString(16));\n\t\treturn;\n\t}\n\n\tif (chunks.length > 1 && chunks[1].type !== 0x004E4942) {\n\t\tcallback(\"Invalid chunk type found in glb file. Expected 0x004E4942, found 0x\" + chunks[1].type.toString(16));\n\t\treturn;\n\t}\n\n\tcallback(null, {\n\t\tgltfChunk: chunks[0].data,\n\t\tbinaryChunk: chunks.length === 2 ? chunks[1].data : null\n\t});\n};\n\nconst parseChunk = function parseChunk(filename, data, callback) {\n\tif (filename && filename.toLowerCase().endsWith('.glb')) {\n\t\tparseGlb(data, callback);\n\t} else {\n\t\tcallback(null, {\n\t\t\tgltfChunk: data,\n\t\t\tbinaryChunk: null\n\t\t});\n\t}\n};\n\nconst parseBufferViewsAsync = function parseBufferViewsAsync(gltf, buffers, options, callback) {\n\tconst result = [];\n\tconst preprocess = options && options.bufferView && options.bufferView.preprocess;\n\n\tconst processAsync = options && options.bufferView && options.bufferView.processAsync || function (gltfBufferView, buffers, callback) {\n\t\tcallback(null, null);\n\t};\n\n\tconst postprocess = options && options.bufferView && options.bufferView.postprocess;\n\tlet remaining = gltf.bufferViews ? gltf.bufferViews.length : 0;\n\n\tif (!remaining) {\n\t\tcallback(null, null);\n\t\treturn;\n\t}\n\n\tconst onLoad = function onLoad(index, bufferView) {\n\t\tconst gltfBufferView = gltf.bufferViews[index];\n\n\t\tif (gltfBufferView.hasOwnProperty('byteStride')) {\n\t\t\tbufferView.byteStride = gltfBufferView.byteStride;\n\t\t}\n\n\t\tresult[index] = bufferView;\n\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfBufferView, bufferView);\n\t\t}\n\n\t\tif (--remaining === 0) {\n\t\t\tcallback(null, result);\n\t\t}\n\t};\n\n\tfor (let i = 0; i < gltf.bufferViews.length; ++i) {\n\t\tconst gltfBufferView = gltf.bufferViews[i];\n\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfBufferView);\n\t\t}\n\n\t\tprocessAsync(gltfBufferView, buffers, function (i, gltfBufferView, err, result) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else if (result) {\n\t\t\t\tonLoad(i, result);\n\t\t\t} else {\n\t\t\t\tconst buffer = buffers[gltfBufferView.buffer];\n\t\t\t\tconst typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);\n\t\t\t\tonLoad(i, typedArray);\n\t\t\t}\n\t\t}.bind(null, i, gltfBufferView));\n\t}\n};\n\nclass GlbParser {\n\tstatic parseAsync(filename, urlBase, data, device, registry, options, callback) {\n\t\tparseChunk(filename, data, function (err, chunks) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tparseGltf(chunks.gltfChunk, function (err, gltf) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tloadBuffersAsync(gltf, chunks.binaryChunk, urlBase, options, function (err, buffers) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tparseBufferViewsAsync(gltf, buffers, options, function (err, bufferViews) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadTexturesAsync(gltf, bufferViews, urlBase, registry, options, function (err, textureAssets) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcreateResources(device, gltf, bufferViews, textureAssets, options, callback);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tstatic parse(filename, data, device, options) {\n\t\tlet result = null;\n\t\toptions = options || {};\n\t\tparseChunk(filename, data, function (err, chunks) {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(err);\n\t\t\t} else {\n\t\t\t\tparseGltf(chunks.gltfChunk, function (err, gltf) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparseBufferViewsAsync(gltf, [chunks.binaryChunk], options, function (err, bufferViews) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcreateResources(device, gltf, bufferViews, [], options, function (err, result_) {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tresult = result_;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n\n\tconstructor(device, assets, maxRetries) {\n\t\tthis._device = device;\n\t\tthis._assets = assets;\n\t\tthis._defaultMaterial = DefaultMaterial.get(device);\n\t\tthis._maxRetries = maxRetries;\n\t}\n\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tGlbParser.parseAsync(this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(null, new GlbContainerResource(result, asset, this._assets, this._defaultMaterial));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, asset, this._maxRetries);\n\t}\n\n\topen(url, data, asset) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass AnimationHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:') || url.load.startsWith('data:')) {\n\t\t\tif (path.getExtension(url.original).toLowerCase() === '.glb') {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t} else {\n\t\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t\t}\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tcallback(null, response);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\tif (path.getExtension(url).toLowerCase() === '.glb') {\n\t\t\tconst glbResources = GlbParser.parse(\"filename.glb\", data, null);\n\n\t\t\tif (glbResources) {\n\t\t\t\tconst animations = glbResources.animations;\n\t\t\t\tglbResources.destroy();\n\t\t\t\treturn animations;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[\"_parseAnimationV\" + data.animation.version](data);\n\t}\n\n\tpatch(asset, assets) {}\n\n\t_parseAnimationV3(data) {\n\t\tconst animData = data.animation;\n\t\tconst anim = new Animation();\n\t\tanim.name = animData.name;\n\t\tanim.duration = animData.duration;\n\n\t\tfor (let i = 0; i < animData.nodes.length; i++) {\n\t\t\tconst node = new Node();\n\t\t\tconst n = animData.nodes[i];\n\t\t\tnode._name = n.name;\n\n\t\t\tfor (let j = 0; j < n.keys.length; j++) {\n\t\t\t\tconst k = n.keys[j];\n\t\t\t\tconst t = k.time;\n\t\t\t\tconst p = k.pos;\n\t\t\t\tconst r = k.rot;\n\t\t\t\tconst s = k.scale;\n\t\t\t\tconst pos = new Vec3(p[0], p[1], p[2]);\n\t\t\t\tconst rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);\n\t\t\t\tconst scl = new Vec3(s[0], s[1], s[2]);\n\t\t\t\tconst key = new Key(t, pos, rot, scl);\n\n\t\t\t\tnode._keys.push(key);\n\t\t\t}\n\n\t\t\tanim.addNode(node);\n\t\t}\n\n\t\treturn anim;\n\t}\n\n\t_parseAnimationV4(data) {\n\t\tconst animData = data.animation;\n\t\tconst anim = new Animation();\n\t\tanim.name = animData.name;\n\t\tanim.duration = animData.duration;\n\n\t\tfor (let i = 0; i < animData.nodes.length; i++) {\n\t\t\tconst node = new Node();\n\t\t\tconst n = animData.nodes[i];\n\t\t\tnode._name = n.name;\n\t\t\tconst defPos = n.defaults.p;\n\t\t\tconst defRot = n.defaults.r;\n\t\t\tconst defScl = n.defaults.s;\n\n\t\t\tfor (let j = 0; j < n.keys.length; j++) {\n\t\t\t\tconst k = n.keys[j];\n\t\t\t\tconst t = k.t;\n\t\t\t\tconst p = defPos ? defPos : k.p;\n\t\t\t\tconst r = defRot ? defRot : k.r;\n\t\t\t\tconst s = defScl ? defScl : k.s;\n\t\t\t\tconst pos = new Vec3(p[0], p[1], p[2]);\n\t\t\t\tconst rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);\n\t\t\t\tconst scl = new Vec3(s[0], s[1], s[2]);\n\t\t\t\tconst key = new Key(t, pos, rot, scl);\n\n\t\t\t\tnode._keys.push(key);\n\t\t\t}\n\n\t\t\tanim.addNode(node);\n\t\t}\n\n\t\treturn anim;\n\t}\n\n}\n\nclass AnimClipHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation clip resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tcallback(null, response);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\tconst name = data.name;\n\t\tconst duration = data.duration;\n\t\tconst inputs = data.inputs.map(function (input) {\n\t\t\treturn new AnimData(1, input);\n\t\t});\n\t\tconst outputs = data.outputs.map(function (output) {\n\t\t\treturn new AnimData(output.components, output.data);\n\t\t});\n\t\tconst curves = data.curves.map(function (curve) {\n\t\t\treturn new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);\n\t\t});\n\t\treturn new AnimTrack(name, duration, inputs, outputs, curves);\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass AnimStateGraph {\n\tconstructor(data) {\n\t\tthis._layers = [];\n\t\tthis._parameters = {};\n\n\t\tif (!Array.isArray(data.layers)) {\n\t\t\tfor (const layerId in data.layers) {\n\t\t\t\tconst dataLayer = data.layers[layerId];\n\t\t\t\tconst layer = {\n\t\t\t\t\tname: dataLayer.name,\n\t\t\t\t\tblendType: dataLayer.blendType,\n\t\t\t\t\tweight: dataLayer.weight,\n\t\t\t\t\tstates: [],\n\t\t\t\t\ttransitions: []\n\t\t\t\t};\n\n\t\t\t\tfor (let i = 0; i < dataLayer.states.length; i++) {\n\t\t\t\t\tlayer.states.push(data.states[dataLayer.states[i]]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < dataLayer.transitions.length; i++) {\n\t\t\t\t\tconst dataLayerTransition = data.transitions[dataLayer.transitions[i]];\n\n\t\t\t\t\tif (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {\n\t\t\t\t\t\tconst conditionKeys = Object.keys(dataLayerTransition.conditions);\n\t\t\t\t\t\tconst conditions = [];\n\n\t\t\t\t\t\tfor (let j = 0; j < conditionKeys.length; j++) {\n\t\t\t\t\t\t\tconst condition = dataLayerTransition.conditions[conditionKeys[j]];\n\n\t\t\t\t\t\t\tif (condition.parameterName) {\n\t\t\t\t\t\t\t\tconditions.push(condition);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataLayerTransition.conditions = conditions;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Number.isInteger(dataLayerTransition.from)) {\n\t\t\t\t\t\tdataLayerTransition.from = data.states[dataLayerTransition.from].name;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Number.isInteger(dataLayerTransition.to)) {\n\t\t\t\t\t\tdataLayerTransition.to = data.states[dataLayerTransition.to].name;\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer.transitions.push(dataLayerTransition);\n\t\t\t\t}\n\n\t\t\t\tthis._layers.push(layer);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._layers = data.layers;\n\t\t}\n\n\t\tfor (const paramId in data.parameters) {\n\t\t\tconst param = data.parameters[paramId];\n\t\t\tthis._parameters[param.name] = {\n\t\t\t\ttype: param.type,\n\t\t\t\tvalue: param.value\n\t\t\t};\n\t\t}\n\t}\n\n\tget parameters() {\n\t\treturn Object.assign({}, this._parameters);\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n}\n\nclass AnimStateGraphHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation state graph resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tcallback(null, response);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn new AnimStateGraph(data);\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass Sound {\n\tconstructor(resource) {\n\t\tif (resource instanceof Audio) {\n\t\t\tthis.audio = resource;\n\t\t} else {\n\t\t\tthis.buffer = resource;\n\t\t}\n\t}\n\n\tget duration() {\n\t\tlet duration = 0;\n\n\t\tif (this.buffer) {\n\t\t\tduration = this.buffer.duration;\n\t\t} else if (this.audio) {\n\t\t\tduration = this.audio.duration;\n\t\t}\n\n\t\treturn duration || 0;\n\t}\n\n}\n\nconst ie = function () {\n\tif (typeof window === 'undefined') {\n\t\treturn false;\n\t}\n\n\tconst ua = window.navigator.userAgent;\n\tconst msie = ua.indexOf('MSIE ');\n\n\tif (msie > 0) {\n\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t}\n\n\tconst trident = ua.indexOf('Trident/');\n\n\tif (trident > 0) {\n\t\tconst rv = ua.indexOf('rv:');\n\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t}\n\n\treturn false;\n}();\n\nconst toMIME = {\n\t'.ogg': 'audio/ogg',\n\t'.mp3': 'audio/mpeg',\n\t'.wav': 'audio/x-wav',\n\t'.mp4a': 'audio/mp4',\n\t'.m4a': 'audio/mp4',\n\t'.mp4': 'audio/mp4',\n\t'.aac': 'audio/aac'\n};\n\nclass AudioHandler {\n\tconstructor(manager) {\n\t\tthis.manager = manager;\n\t\tthis.maxRetries = 0;\n\t}\n\n\t_isSupported(url) {\n\t\tconst ext = path.getExtension(url);\n\n\t\tif (toMIME[ext]) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst success = function success(resource) {\n\t\t\tcallback(null, new Sound(resource));\n\t\t};\n\n\t\tconst error = function error(err) {\n\t\t\tlet msg = 'Error loading audio url: ' + url.original;\n\n\t\t\tif (err) {\n\t\t\t\tmsg += ': ' + (err.message || err);\n\t\t\t}\n\n\t\t\tconsole.warn(msg);\n\t\t\tcallback(msg);\n\t\t};\n\n\t\tif (this._createSound) {\n\t\t\tif (!this._isSupported(url.original)) {\n\t\t\t\terror(`Audio format for ${url.original} not supported`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._createSound(url.load, success, error);\n\t\t} else {\n\t\t\terror(null);\n\t\t}\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n\t_createSound(url, success, error) {\n\t\tif (hasAudioContext()) {\n\t\t\tconst manager = this.manager;\n\n\t\t\tif (!manager.context) {\n\t\t\t\terror('Audio manager has no audio context');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst options = {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t};\n\n\t\t\tif (url.startsWith('blob:') || url.startsWith('data:')) {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t}\n\n\t\t\thttp.get(url, options, function (err, response) {\n\t\t\t\tif (err) {\n\t\t\t\t\terror(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmanager.context.decodeAudioData(response, success, error);\n\t\t\t});\n\t\t} else {\n\t\t\tlet audio = null;\n\n\t\t\ttry {\n\t\t\t\taudio = new Audio();\n\t\t\t} catch (e) {\n\t\t\t\terror(\"No support for Audio element\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ie) {\n\t\t\t\tdocument.body.appendChild(audio);\n\t\t\t}\n\n\t\t\tconst onReady = function onReady() {\n\t\t\t\taudio.removeEventListener('canplaythrough', onReady);\n\n\t\t\t\tif (ie) {\n\t\t\t\t\tdocument.body.removeChild(audio);\n\t\t\t\t}\n\n\t\t\t\tsuccess(audio);\n\t\t\t};\n\n\t\t\taudio.onerror = function () {\n\t\t\t\taudio.onerror = null;\n\n\t\t\t\tif (ie) {\n\t\t\t\t\tdocument.body.removeChild(audio);\n\t\t\t\t}\n\n\t\t\t\terror();\n\t\t\t};\n\n\t\t\taudio.addEventListener('canplaythrough', onReady);\n\t\t\taudio.src = url;\n\t\t}\n\t}\n\n}\n\nclass BinaryHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tresponseType: Http.ResponseType.ARRAY_BUFFER,\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading binary resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass Bundle {\n\tconstructor(files) {\n\t\tthis._blobUrls = {};\n\n\t\tfor (let i = 0, len = files.length; i < len; i++) {\n\t\t\tif (files[i].url) {\n\t\t\t\tthis._blobUrls[files[i].name] = files[i].url;\n\t\t\t}\n\t\t}\n\t}\n\n\thasBlobUrl(url) {\n\t\treturn !!this._blobUrls[url];\n\t}\n\n\tgetBlobUrl(url) {\n\t\treturn this._blobUrls[url];\n\t}\n\n\tdestroy() {\n\t\tfor (const key in this._blobUrls) {\n\t\t\tURL.revokeObjectURL(this._blobUrls[key]);\n\t\t}\n\n\t\tthis._blobUrls = null;\n\t}\n\n}\n\nlet Untar;\n\nfunction UntarScope(isWorker) {\n\tlet utfDecoder;\n\tlet asciiDecoder;\n\n\tif (typeof TextDecoder !== 'undefined') {\n\t\ttry {\n\t\t\tutfDecoder = new TextDecoder('utf-8');\n\t\t\tasciiDecoder = new TextDecoder('windows-1252');\n\t\t} catch (e) {\n\t\t\tconsole.warn('TextDecoder not supported - pc.Untar module will not work');\n\t\t}\n\t} else {\n\t\tconsole.warn('TextDecoder not supported - pc.Untar module will not work');\n\t}\n\n\tfunction PaxHeader(fields) {\n\t\tthis._fields = fields;\n\t}\n\n\tPaxHeader.parse = function (buffer, start, length) {\n\t\tconst paxArray = new Uint8Array(buffer, start, length);\n\t\tlet bytesRead = 0;\n\t\tconst fields = [];\n\n\t\twhile (bytesRead < length) {\n\t\t\tlet spaceIndex;\n\n\t\t\tfor (spaceIndex = bytesRead; spaceIndex < length; spaceIndex++) {\n\t\t\t\tif (paxArray[spaceIndex] === 0x20) break;\n\t\t\t}\n\n\t\t\tif (spaceIndex >= length) {\n\t\t\t\tthrow new Error('Invalid PAX header data format.');\n\t\t\t}\n\n\t\t\tconst fieldLength = parseInt(utfDecoder.decode(new Uint8Array(buffer, start + bytesRead, spaceIndex - bytesRead)), 10);\n\t\t\tconst fieldText = utfDecoder.decode(new Uint8Array(buffer, start + spaceIndex + 1, fieldLength - (spaceIndex - bytesRead) - 2));\n\t\t\tconst field = fieldText.split('=');\n\n\t\t\tif (field.length !== 2) {\n\t\t\t\tthrow new Error('Invalid PAX header data format.');\n\t\t\t}\n\n\t\t\tif (field[1].length === 0) {\n\t\t\t\tfield[1] = null;\n\t\t\t}\n\n\t\t\tfields.push({\n\t\t\t\tname: field[0],\n\t\t\t\tvalue: field[1]\n\t\t\t});\n\t\t\tbytesRead += fieldLength;\n\t\t}\n\n\t\treturn new PaxHeader(fields);\n\t};\n\n\tPaxHeader.prototype.applyHeader = function (file) {\n\t\tfor (let i = 0; i < this._fields.length; i++) {\n\t\t\tlet fieldName = this._fields[i].name;\n\t\t\tconst fieldValue = this._fields[i].value;\n\n\t\t\tif (fieldName === 'path') {\n\t\t\t\tfieldName = 'name';\n\t\t\t}\n\n\t\t\tif (fieldValue === null) {\n\t\t\t\tdelete file[fieldName];\n\t\t\t} else {\n\t\t\t\tfile[fieldName] = fieldValue;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction UntarInternal(arrayBuffer) {\n\t\tthis._arrayBuffer = arrayBuffer || new ArrayBuffer(0);\n\t\tthis._bufferView = new DataView(this._arrayBuffer);\n\t\tthis._globalPaxHeader = null;\n\t\tthis._paxHeader = null;\n\t\tthis._bytesRead = 0;\n\t}\n\n\tif (!isWorker) {\n\t\tUntar = UntarInternal;\n\t}\n\n\tUntarInternal.prototype._hasNext = function () {\n\t\treturn this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;\n\t};\n\n\tUntarInternal.prototype._readNextFile = function () {\n\t\tconst headersDataView = new DataView(this._arrayBuffer, this._bytesRead, 512);\n\t\tconst headers = asciiDecoder.decode(headersDataView);\n\t\tthis._bytesRead += 512;\n\t\tlet name = headers.substr(0, 100).replace(/\\0/g, '');\n\t\tconst ustarFormat = headers.substr(257, 6);\n\t\tconst size = parseInt(headers.substr(124, 12), 8);\n\t\tconst type = headers.substr(156, 1);\n\t\tconst start = this._bytesRead;\n\t\tlet url = null;\n\t\tlet normalFile = false;\n\n\t\tswitch (type) {\n\t\t\tcase \"0\":\n\t\t\tcase \"\":\n\t\t\t\tnormalFile = true;\n\n\t\t\t\tif (!isWorker) {\n\t\t\t\t\tconst blob = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + size)]);\n\t\t\t\t\turl = URL.createObjectURL(blob);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"g\":\n\t\t\t\tthis._globalPaxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);\n\t\t\t\tbreak;\n\n\t\t\tcase \"x\":\n\t\t\t\tthis._paxHeader = PaxHeader.parse(this._arrayBuffer, this._bytesRead, size);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tthis._bytesRead += size;\n\t\tconst remainder = size % 512;\n\n\t\tif (remainder !== 0) {\n\t\t\tthis._bytesRead += 512 - remainder;\n\t\t}\n\n\t\tif (!normalFile) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (ustarFormat.indexOf(\"ustar\") !== -1) {\n\t\t\tconst namePrefix = headers.substr(345, 155).replace(/\\0/g, '');\n\n\t\t\tif (namePrefix.length > 0) {\n\t\t\t\tname = namePrefix.trim() + name.trim();\n\t\t\t}\n\t\t}\n\n\t\tconst file = {\n\t\t\tname: name,\n\t\t\tstart: start,\n\t\t\tsize: size,\n\t\t\turl: url\n\t\t};\n\n\t\tif (this._globalPaxHeader) {\n\t\t\tthis._globalPaxHeader.applyHeader(file);\n\t\t}\n\n\t\tif (this._paxHeader) {\n\t\t\tthis._paxHeader.applyHeader(file);\n\n\t\t\tthis._paxHeader = null;\n\t\t}\n\n\t\treturn file;\n\t};\n\n\tUntarInternal.prototype.untar = function (filenamePrefix) {\n\t\tif (!utfDecoder) {\n\t\t\tconsole.error('Cannot untar because TextDecoder interface is not available for this platform.');\n\t\t\treturn [];\n\t\t}\n\n\t\tconst files = [];\n\n\t\twhile (this._hasNext()) {\n\t\t\tconst file = this._readNextFile();\n\n\t\t\tif (!file) continue;\n\n\t\t\tif (filenamePrefix && file.name) {\n\t\t\t\tfile.name = filenamePrefix + file.name;\n\t\t\t}\n\n\t\t\tfiles.push(file);\n\t\t}\n\n\t\treturn files;\n\t};\n\n\tif (isWorker) {\n\t\tself.onmessage = function (e) {\n\t\t\tconst id = e.data.id;\n\n\t\t\ttry {\n\t\t\t\tconst archive = new UntarInternal(e.data.arrayBuffer);\n\t\t\t\tconst files = archive.untar(e.data.prefix);\n\t\t\t\tpostMessage({\n\t\t\t\t\tid: id,\n\t\t\t\t\tfiles: files,\n\t\t\t\t\tarrayBuffer: e.data.arrayBuffer\n\t\t\t\t}, [e.data.arrayBuffer]);\n\t\t\t} catch (err) {\n\t\t\t\tpostMessage({\n\t\t\t\t\tid: id,\n\t\t\t\t\terror: err.toString()\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n}\n\nlet workerUrl = null;\n\nfunction getWorkerUrl() {\n\tif (!workerUrl) {\n\t\tconst code = '(' + UntarScope.toString() + ')(true)\\n\\n';\n\t\tconst blob = new Blob([code], {\n\t\t\ttype: 'application/javascript'\n\t\t});\n\t\tworkerUrl = URL.createObjectURL(blob);\n\t}\n\n\treturn workerUrl;\n}\n\nclass UntarWorker {\n\tconstructor(filenamePrefix) {\n\t\tthis._requestId = 0;\n\t\tthis._pendingRequests = {};\n\t\tthis._filenamePrefix = filenamePrefix;\n\t\tthis._worker = new Worker(getWorkerUrl());\n\n\t\tthis._worker.addEventListener('message', this._onMessage.bind(this));\n\t}\n\n\t_onMessage(e) {\n\t\tconst id = e.data.id;\n\t\tif (!this._pendingRequests[id]) return;\n\t\tconst callback = this._pendingRequests[id];\n\t\tdelete this._pendingRequests[id];\n\n\t\tif (e.data.error) {\n\t\t\tcallback(e.data.error);\n\t\t} else {\n\t\t\tconst arrayBuffer = e.data.arrayBuffer;\n\n\t\t\tfor (let i = 0, len = e.data.files.length; i < len; i++) {\n\t\t\t\tconst file = e.data.files[i];\n\t\t\t\tconst blob = new Blob([arrayBuffer.slice(file.start, file.start + file.size)]);\n\t\t\t\tfile.url = URL.createObjectURL(blob);\n\t\t\t}\n\n\t\t\tcallback(null, e.data.files);\n\t\t}\n\t}\n\n\tuntar(arrayBuffer, callback) {\n\t\tconst id = this._requestId++;\n\t\tthis._pendingRequests[id] = callback;\n\n\t\tthis._worker.postMessage({\n\t\t\tid: id,\n\t\t\tprefix: this._filenamePrefix,\n\t\t\tarrayBuffer: arrayBuffer\n\t\t}, [arrayBuffer]);\n\t}\n\n\thasPendingRequests() {\n\t\treturn Object.keys(this._pendingRequests).length > 0;\n\t}\n\n\tdestroy() {\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\n\t\t\tthis._worker = null;\n\t\t\tthis._pendingRequests = null;\n\t\t}\n\t}\n\n}\n\nUntarScope();\n\nclass BundleHandler {\n\tconstructor(assets) {\n\t\tthis._assets = assets;\n\t\tthis._worker = null;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\t\thttp.get(url.load, {\n\t\t\tresponseType: Http.ResponseType.ARRAY_BUFFER,\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\ttry {\n\t\t\t\t\tself._untar(response, callback);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tcallback(\"Error loading bundle resource \" + url.original + \": \" + ex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcallback(\"Error loading bundle resource \" + url.original + \": \" + err);\n\t\t\t}\n\t\t});\n\t}\n\n\t_untar(response, callback) {\n\t\tconst self = this;\n\n\t\tif (platform.workers) {\n\t\t\tif (!self._worker) {\n\t\t\t\tself._worker = new UntarWorker(self._assets.prefix);\n\t\t\t}\n\n\t\t\tself._worker.untar(response, function (err, files) {\n\t\t\t\tcallback(err, files);\n\n\t\t\t\tif (!self._worker.hasPendingRequests()) {\n\t\t\t\t\tself._worker.destroy();\n\n\t\t\t\t\tself._worker = null;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst archive = new Untar(response);\n\t\t\tconst files = archive.untar(self._assets.prefix);\n\t\t\tcallback(null, files);\n\t\t}\n\t}\n\n\topen(url, data) {\n\t\treturn new Bundle(data);\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass ContainerResource {\n\tinstantiateModelEntity(options) {\n\t\treturn null;\n\t}\n\n\tinstantiateRenderEntity(options) {\n\t\treturn null;\n\t}\n\n}\n\nclass ContainerHandler {\n\tconstructor(device, assets) {\n\t\tthis.glbParser = new GlbParser(device, assets, 0);\n\t\tthis.parsers = {};\n\t}\n\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\n\t_getParser(url) {\n\t\tconst ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;\n\t\treturn this.parsers[ext] || this.glbParser;\n\t}\n\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tthis._getParser(url.original).load(url, callback, asset);\n\t}\n\n\topen(url, data, asset) {\n\t\treturn this._getParser(url).open(url, data, asset);\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass CssHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading css resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nfunction createStyle(cssString) {\n\tconst result = document.createElement('style');\n\tresult.type = 'text/css';\n\n\tif (result.styleSheet) {\n\t\tresult.styleSheet.cssText = cssString;\n\t} else {\n\t\tresult.appendChild(document.createTextNode(cssString));\n\t}\n\n\treturn result;\n}\n\nclass CubemapHandler {\n\tconstructor(device, assets, loader) {\n\t\tthis._device = device;\n\t\tthis._registry = assets;\n\t\tthis._loader = loader;\n\t}\n\n\tload(url, callback, asset) {\n\t\tthis.loadAssets(asset, callback);\n\t}\n\n\topen(url, data, asset) {\n\t\treturn asset ? asset.resource : null;\n\t}\n\n\tpatch(asset, registry) {\n\t\tthis.loadAssets(asset, function (err, result) {\n\t\t\tif (err) {\n\t\t\t\tregistry.fire('error', asset);\n\t\t\t\tregistry.fire('error:' + asset.id, err, asset);\n\t\t\t\tasset.fire('error', asset);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetAssetIds(cubemapAsset) {\n\t\tconst result = [];\n\t\tresult[0] = cubemapAsset.file;\n\n\t\tif ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {\n\t\t\tfor (let i = 0; i < 6; ++i) {\n\t\t\t\tresult[i + 1] = cubemapAsset.data.textures[i];\n\t\t\t}\n\t\t} else {\n\t\t\tresult[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tcompareAssetIds(assetIdA, assetIdB) {\n\t\tif (assetIdA && assetIdB) {\n\t\t\tif (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === \"string\") {\n\t\t\t\treturn assetIdA === assetIdB;\n\t\t\t}\n\n\t\t\treturn assetIdA.url === assetIdB.url;\n\t\t}\n\n\t\treturn assetIdA !== null === (assetIdB !== null);\n\t}\n\n\tupdate(cubemapAsset, assetIds, assets) {\n\t\tconst assetData = cubemapAsset.data || {};\n\t\tconst oldAssets = cubemapAsset._handlerState.assets;\n\t\tconst oldResources = cubemapAsset._resources;\n\t\tlet tex, mip, i;\n\t\tconst resources = [null, null, null, null, null, null, null];\n\n\t\tconst getType = function getType() {\n\t\t\tif (assetData.hasOwnProperty('type')) {\n\t\t\t\treturn assetData.type;\n\t\t\t}\n\n\t\t\tif (assetData.hasOwnProperty('rgbm')) {\n\t\t\t\treturn assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tif (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {\n\t\t\tif (assets[0]) {\n\t\t\t\ttex = assets[0].resource;\n\n\t\t\t\tfor (i = 0; i < 6; ++i) {\n\t\t\t\t\tresources[i + 1] = new Texture(this._device, {\n\t\t\t\t\t\tname: cubemapAsset.name + '_prelitCubemap' + (tex.width >> i),\n\t\t\t\t\t\tcubemap: true,\n\t\t\t\t\t\ttype: getType() || tex.type,\n\t\t\t\t\t\twidth: tex.width >> i,\n\t\t\t\t\t\theight: tex.height >> i,\n\t\t\t\t\t\tformat: tex.format,\n\t\t\t\t\t\tlevels: [tex._levels[i]],\n\t\t\t\t\t\tfixCubemapSeams: true,\n\t\t\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\t\tmipmaps: i === 0\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresources[1] = oldResources[1] || null;\n\t\t\tresources[2] = oldResources[2] || null;\n\t\t\tresources[3] = oldResources[3] || null;\n\t\t\tresources[4] = oldResources[4] || null;\n\t\t\tresources[5] = oldResources[5] || null;\n\t\t\tresources[6] = oldResources[6] || null;\n\t\t}\n\n\t\tconst faceAssets = assets.slice(1);\n\n\t\tif (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {\n\t\t\tif (faceAssets.indexOf(null) === -1) {\n\t\t\t\tconst faceTextures = faceAssets.map(function (asset) {\n\t\t\t\t\treturn asset.resource;\n\t\t\t\t});\n\t\t\t\tconst faceLevels = [];\n\n\t\t\t\tfor (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {\n\t\t\t\t\tfaceLevels.push(faceTextures.map(function (faceTexture) {\n\t\t\t\t\t\treturn faceTexture._levels[mip];\n\t\t\t\t\t}));\n\t\t\t\t}\n\n\t\t\t\tconst faces = new Texture(this._device, {\n\t\t\t\t\tname: cubemapAsset.name + '_faces',\n\t\t\t\t\tcubemap: true,\n\t\t\t\t\ttype: getType() || faceTextures[0].type,\n\t\t\t\t\twidth: faceTextures[0].width,\n\t\t\t\t\theight: faceTextures[0].height,\n\t\t\t\t\tformat: faceTextures[0].format,\n\t\t\t\t\tlevels: faceLevels,\n\t\t\t\t\tminFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,\n\t\t\t\t\tmagFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,\n\t\t\t\t\tanisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,\n\t\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\tfixCubemapSeams: !!assets[0]\n\t\t\t\t});\n\t\t\t\tresources[0] = faces;\n\t\t\t}\n\t\t} else {\n\t\t\tresources[0] = oldResources[0] || null;\n\t\t}\n\n\t\tif (!this.cmpArrays(resources, oldResources)) {\n\t\t\tcubemapAsset.resources = resources;\n\t\t\tcubemapAsset._handlerState.assetIds = assetIds;\n\t\t\tcubemapAsset._handlerState.assets = assets;\n\n\t\t\tfor (i = 0; i < oldResources.length; ++i) {\n\t\t\t\tif (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {\n\t\t\t\t\toldResources[i].destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < oldAssets.length; ++i) {\n\t\t\tif (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {\n\t\t\t\toldAssets[i].unload();\n\t\t\t}\n\t\t}\n\t}\n\n\tcmpArrays(arr1, arr2) {\n\t\tif (arr1.length !== arr2.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < arr1.length; ++i) {\n\t\t\tif (arr1[i] !== arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tresolveId(value) {\n\t\tconst valueInt = parseInt(value, 10);\n\t\treturn valueInt === value || valueInt.toString() === value ? valueInt : value;\n\t}\n\n\tloadAssets(cubemapAsset, callback) {\n\t\tif (!cubemapAsset.hasOwnProperty('_handlerState')) {\n\t\t\tcubemapAsset._handlerState = {\n\t\t\t\tassetIds: [null, null, null, null, null, null, null],\n\t\t\t\tassets: [null, null, null, null, null, null, null]\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\t\tconst assetIds = self.getAssetIds(cubemapAsset);\n\t\tconst assets = [null, null, null, null, null, null, null];\n\t\tconst loadedAssetIds = cubemapAsset._handlerState.assetIds;\n\t\tconst loadedAssets = cubemapAsset._handlerState.assets;\n\t\tconst registry = self._registry;\n\t\tlet awaiting = 7;\n\n\t\tconst onLoad = function onLoad(index, asset) {\n\t\t\tassets[index] = asset;\n\t\t\tawaiting--;\n\n\t\t\tif (awaiting === 0) {\n\t\t\t\tself.update(cubemapAsset, assetIds, assets);\n\t\t\t\tcallback(null, cubemapAsset.resources);\n\t\t\t}\n\t\t};\n\n\t\tconst onError = function onError(index, err, asset) {\n\t\t\tcallback(err);\n\t\t};\n\n\t\tconst processTexAsset = function processTexAsset(index, texAsset) {\n\t\t\tif (texAsset.loaded) {\n\t\t\t\tonLoad(index, texAsset);\n\t\t\t} else {\n\t\t\t\tregistry.once('load:' + texAsset.id, onLoad.bind(self, index));\n\t\t\t\tregistry.once('error:' + texAsset.id, onError.bind(self, index));\n\n\t\t\t\tif (!texAsset.loading) {\n\t\t\t\t\tregistry.load(texAsset);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet texAsset;\n\n\t\tfor (let i = 0; i < 7; ++i) {\n\t\t\tconst assetId = this.resolveId(assetIds[i]);\n\n\t\t\tif (!assetId) {\n\t\t\t\tonLoad(i, null);\n\t\t\t} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {\n\t\t\t\tonLoad(i, loadedAssets[i]);\n\t\t\t} else if (parseInt(assetId, 10) === assetId) {\n\t\t\t\ttexAsset = registry.get(assetId);\n\n\t\t\t\tif (texAsset) {\n\t\t\t\t\tprocessTexAsset(i, texAsset);\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(function (index, assetId_) {\n\t\t\t\t\t\tconst texAsset = registry.get(assetId_);\n\n\t\t\t\t\t\tif (texAsset) {\n\t\t\t\t\t\t\tprocessTexAsset(index, texAsset);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonError(index, \"failed to find dependent cubemap asset=\" + assetId_);\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(null, i, assetId));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst file = typeof assetId === \"string\" ? {\n\t\t\t\t\turl: assetId,\n\t\t\t\t\tfilename: assetId\n\t\t\t\t} : assetId;\n\t\t\t\ttexAsset = new Asset(cubemapAsset.name + \"_part_\" + i, \"texture\", file);\n\t\t\t\tregistry.add(texAsset);\n\t\t\t\tregistry.once('load:' + texAsset.id, onLoad.bind(self, i));\n\t\t\t\tregistry.once('error:' + texAsset.id, onError.bind(self, i));\n\t\t\t\tregistry.load(texAsset);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass FolderHandler {\n\tload(url, callback) {\n\t\tcallback(null, null);\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n}\n\nconst FONT_MSDF = 'msdf';\nconst FONT_BITMAP = 'bitmap';\n\nclass Font {\n\tconstructor(textures, data) {\n\t\tthis.type = data ? data.type || FONT_MSDF : FONT_MSDF;\n\t\tthis.em = 1;\n\t\tthis.textures = textures;\n\t\tthis.intensity = 0.0;\n\t\tthis._data = null;\n\t\tthis.data = data;\n\t}\n\n\tset data(value) {\n\t\tthis._data = value;\n\t\tif (!value) return;\n\n\t\tif (this._data.intensity !== undefined) {\n\t\t\tthis.intensity = this._data.intensity;\n\t\t}\n\n\t\tif (!this._data.info) this._data.info = {};\n\n\t\tif (!this._data.version || this._data.version < 2) {\n\t\t\tthis._data.info.maps = [{\n\t\t\t\twidth: this._data.info.width,\n\t\t\t\theight: this._data.info.height\n\t\t\t}];\n\n\t\t\tif (this._data.chars) {\n\t\t\t\tfor (const key in this._data.chars) {\n\t\t\t\t\tthis._data.chars[key].map = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget data() {\n\t\treturn this._data;\n\t}\n\n}\n\nfunction upgradeDataSchema(data) {\n\tif (data.version < 3) {\n\t\tif (data.version < 2) {\n\t\t\tdata.info.maps = data.info.maps || [{\n\t\t\t\twidth: data.info.width,\n\t\t\t\theight: data.info.height\n\t\t\t}];\n\t\t}\n\n\t\tdata.chars = Object.keys(data.chars || {}).reduce(function (newChars, key) {\n\t\t\tconst existing = data.chars[key];\n\t\t\tconst newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);\n\n\t\t\tif (data.version < 2) {\n\t\t\t\texisting.map = existing.map || 0;\n\t\t\t}\n\n\t\t\tnewChars[newKey] = existing;\n\t\t\treturn newChars;\n\t\t}, {});\n\t\tdata.version = 3;\n\t}\n\n\treturn data;\n}\n\nclass FontHandler {\n\tconstructor(loader) {\n\t\tthis._loader = loader;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, function (err, response) {\n\t\t\t\tif (!err) {\n\t\t\t\t\tconst data = upgradeDataSchema(response);\n\n\t\t\t\t\tself._loadTextures(url.load.replace('.json', '.png'), data, function (err, textures) {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\t\ttextures: textures\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(`Error loading font resource: ${url.original} [${err}]`);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tif (asset && asset.data) {\n\t\t\t\tasset.data = upgradeDataSchema(asset.data);\n\t\t\t}\n\n\t\t\tthis._loadTextures(url.load, asset && asset.data, callback);\n\t\t}\n\t}\n\n\t_loadTextures(url, data, callback) {\n\t\tconst numTextures = data.info.maps.length;\n\t\tlet numLoaded = 0;\n\t\tlet error = null;\n\t\tconst textures = new Array(numTextures);\n\t\tconst loader = this._loader;\n\n\t\tconst loadTexture = function loadTexture(index) {\n\t\t\tconst onLoaded = function onLoaded(err, texture) {\n\t\t\t\tif (error) return;\n\n\t\t\t\tif (err) {\n\t\t\t\t\terror = err;\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\ttexture.upload();\n\t\t\t\ttextures[index] = texture;\n\t\t\t\tnumLoaded++;\n\n\t\t\t\tif (numLoaded === numTextures) {\n\t\t\t\t\tcallback(null, textures);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (index === 0) {\n\t\t\t\tloader.load(url, \"texture\", onLoaded);\n\t\t\t} else {\n\t\t\t\tloader.load(url.replace('.png', index + '.png'), \"texture\", onLoaded);\n\t\t\t}\n\t\t};\n\n\t\tfor (let i = 0; i < numTextures; i++) loadTexture(i);\n\t}\n\n\topen(url, data, asset) {\n\t\tlet font;\n\n\t\tif (data.textures) {\n\t\t\tfont = new Font(data.textures, data.data);\n\t\t} else {\n\t\t\tfont = new Font(data, null);\n\t\t}\n\n\t\treturn font;\n\t}\n\n\tpatch(asset, assets) {\n\t\tconst font = asset.resource;\n\n\t\tif (!font.data && asset.data) {\n\t\t\tfont.data = asset.data;\n\t\t} else if (!asset.data && font.data) {\n\t\t\tasset.data = font.data;\n\t\t}\n\n\t\tif (asset.data) {\n\t\t\tasset.data = upgradeDataSchema(asset.data);\n\t\t}\n\t}\n\n}\n\nconst CompressUtils = {\n\tsetCompressedPRS: function (entity, data, compressed) {\n\t\tconst a = compressed.singleVecs;\n\t\tlet b, i;\n\t\tconst v = data.___1;\n\n\t\tif (!v) {\n\t\t\tb = compressed.tripleVecs;\n\t\t\ti = data.___2;\n\t\t}\n\n\t\tlet n = v ? v[0] : b[i];\n\t\tentity.setLocalPosition(a[n], a[n + 1], a[n + 2]);\n\t\tn = v ? v[1] : b[i + 1];\n\t\tentity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);\n\t\tn = v ? v[2] : b[i + 2];\n\t\tentity.setLocalScale(a[n], a[n + 1], a[n + 2]);\n\t},\n\toneCharToKey: function (s, data) {\n\t\tconst i = s.charCodeAt(0) - data.fieldFirstCode;\n\t\treturn data.fieldArray[i];\n\t},\n\tmultCharToKey: function (s, data) {\n\t\tlet ind = 0;\n\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\tind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;\n\t\t}\n\n\t\treturn data.fieldArray[ind];\n\t}\n};\n\nclass Decompress {\n\tconstructor(node, data) {\n\t\tthis._node = node;\n\t\tthis._data = data;\n\t}\n\n\trun() {\n\t\tconst type = Object.prototype.toString.call(this._node);\n\n\t\tif (type === '[object Object]') {\n\t\t\tthis._handleMap();\n\t\t} else if (type === '[object Array]') {\n\t\t\tthis._handleArray();\n\t\t} else {\n\t\t\tthis._result = this._node;\n\t\t}\n\n\t\treturn this._result;\n\t}\n\n\t_handleMap() {\n\t\tthis._result = {};\n\t\tconst a = Object.keys(this._node);\n\t\ta.forEach(this._handleKey, this);\n\t}\n\n\t_handleKey(origKey) {\n\t\tlet newKey = origKey;\n\t\tconst len = origKey.length;\n\n\t\tif (len === 1) {\n\t\t\tnewKey = CompressUtils.oneCharToKey(origKey, this._data);\n\t\t} else if (len === 2) {\n\t\t\tnewKey = CompressUtils.multCharToKey(origKey, this._data);\n\t\t}\n\n\t\tthis._result[newKey] = new Decompress(this._node[origKey], this._data).run();\n\t}\n\n\t_handleArray() {\n\t\tthis._result = [];\n\n\t\tthis._node.forEach(this._handleArElt, this);\n\t}\n\n\t_handleArElt(elt) {\n\t\tconst v = new Decompress(elt, this._data).run();\n\n\t\tthis._result.push(v);\n\t}\n\n}\n\nclass SceneParser {\n\tconstructor(app, isTemplate) {\n\t\tthis._app = app;\n\t\tthis._isTemplate = isTemplate;\n\t}\n\n\tparse(data) {\n\t\tconst entities = {};\n\t\tlet parent = null;\n\t\tconst compressed = data.compressedFormat;\n\n\t\tif (compressed && !data.entDecompressed) {\n\t\t\tdata.entDecompressed = true;\n\t\t\tdata.entities = new Decompress(data.entities, compressed).run();\n\t\t}\n\n\t\tfor (const id in data.entities) {\n\t\t\tconst curData = data.entities[id];\n\n\t\t\tconst curEnt = this._createEntity(curData, compressed);\n\n\t\t\tentities[id] = curEnt;\n\n\t\t\tif (curData.parent === null) {\n\t\t\t\tparent = curEnt;\n\t\t\t}\n\t\t}\n\n\t\tfor (const id in data.entities) {\n\t\t\tconst curEnt = entities[id];\n\t\t\tconst children = data.entities[id].children;\n\t\t\tconst len = children.length;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst childEnt = entities[children[i]];\n\n\t\t\t\tif (childEnt) {\n\t\t\t\t\tcurEnt.addChild(childEnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._openComponentData(parent, data.entities);\n\n\t\treturn parent;\n\t}\n\n\t_createEntity(data, compressed) {\n\t\tconst entity = new Entity();\n\t\tentity.name = data.name;\n\t\tentity.setGuid(data.resource_id);\n\n\t\tthis._setPosRotScale(entity, data, compressed);\n\n\t\tentity._enabled = data.enabled !== undefined ? data.enabled : true;\n\n\t\tif (this._isTemplate) {\n\t\t\tentity._template = true;\n\t\t} else {\n\t\t\tentity._enabledInHierarchy = entity._enabled;\n\t\t}\n\n\t\tentity.template = data.template;\n\n\t\tif (data.tags) {\n\t\t\tfor (let i = 0; i < data.tags.length; i++) {\n\t\t\t\tentity.tags.add(data.tags[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (data.labels) {\n\t\t\tdata.labels.forEach(function (label) {\n\t\t\t\tentity.addLabel(label);\n\t\t\t});\n\t\t}\n\n\t\treturn entity;\n\t}\n\n\t_setPosRotScale(entity, data, compressed) {\n\t\tif (compressed) {\n\t\t\tCompressUtils.setCompressedPRS(entity, data, compressed);\n\t\t} else {\n\t\t\tconst p = data.position;\n\t\t\tconst r = data.rotation;\n\t\t\tconst s = data.scale;\n\t\t\tentity.setLocalPosition(p[0], p[1], p[2]);\n\t\t\tentity.setLocalEulerAngles(r[0], r[1], r[2]);\n\t\t\tentity.setLocalScale(s[0], s[1], s[2]);\n\t\t}\n\t}\n\n\t_openComponentData(entity, entities) {\n\t\tconst systemsList = this._app.systems.list;\n\t\tlet len = systemsList.length;\n\t\tconst entityData = entities[entity.getGuid()];\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst system = systemsList[i];\n\t\t\tconst componentData = entityData.components[system.id];\n\n\t\t\tif (componentData) {\n\t\t\t\tsystem.addComponent(entity, componentData);\n\t\t\t}\n\t\t}\n\n\t\tlen = entityData.children.length;\n\t\tconst children = entity._children;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tchildren[i] = this._openComponentData(children[i], entities);\n\t\t}\n\n\t\treturn entity;\n\t}\n\n}\n\nconst SceneUtils = {\n\tload: function (url, maxRetries, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: maxRetries > 0,\n\t\t\tmaxRetries: maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(err, response);\n\t\t\t} else {\n\t\t\t\tlet errMsg = 'Error while loading scene JSON ' + url.original;\n\n\t\t\t\tif (err.message) {\n\t\t\t\t\terrMsg += ': ' + err.message;\n\n\t\t\t\t\tif (err.stack) {\n\t\t\t\t\t\terrMsg += '\\n' + err.stack;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrMsg += ': ' + err;\n\t\t\t\t}\n\n\t\t\t\tcallback(errMsg);\n\t\t\t}\n\t\t});\n\t}\n};\n\nclass HierarchyHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tSceneUtils.load(url, this.maxRetries, callback);\n\t}\n\n\topen(url, data) {\n\t\tthis._app.systems.script.preloading = true;\n\t\tconst parser = new SceneParser(this._app, false);\n\t\tconst parent = parser.parse(data);\n\t\tthis._app.systems.script.preloading = false;\n\t\treturn parent;\n\t}\n\n}\n\nclass HtmlHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading html resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass JsonHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading JSON resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass AssetReference {\n\tconstructor(propertyName, parent, registry, callbacks, scope) {\n\t\tthis.propertyName = propertyName;\n\t\tthis.parent = parent;\n\t\tthis._scope = scope;\n\t\tthis._registry = registry;\n\t\tthis.id = null;\n\t\tthis.url = null;\n\t\tthis.asset = null;\n\t\tthis._onAssetLoad = callbacks.load;\n\t\tthis._onAssetAdd = callbacks.add;\n\t\tthis._onAssetRemove = callbacks.remove;\n\t\tthis._onAssetUnload = callbacks.unload;\n\t}\n\n\tset id(value) {\n\t\tif (this.url) throw Error(\"Can't set id and url\");\n\n\t\tthis._unbind();\n\n\t\tthis._id = value;\n\t\tthis.asset = this._registry.get(this._id);\n\n\t\tthis._bind();\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tset url(value) {\n\t\tif (this.id) throw Error(\"Can't set id and url\");\n\n\t\tthis._unbind();\n\n\t\tthis._url = value;\n\t\tthis.asset = this._registry.getByUrl(this._url);\n\n\t\tthis._bind();\n\t}\n\n\tget url() {\n\t\treturn this._url;\n\t}\n\n\t_bind() {\n\t\tif (this.id) {\n\t\t\tif (this._onAssetLoad) this._registry.on(\"load:\" + this.id, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._registry.once(\"add:\" + this.id, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._registry.on(\"remove:\" + this.id, this._onRemove, this);\n\t\t\tif (this._onAssetUnload) this._registry.on(\"unload:\" + this.id, this._onUnload, this);\n\t\t}\n\n\t\tif (this.url) {\n\t\t\tif (this._onAssetLoad) this._registry.on(\"load:url:\" + this.url, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._registry.once(\"add:url:\" + this.url, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._registry.on(\"remove:url:\" + this.url, this._onRemove, this);\n\t\t}\n\t}\n\n\t_unbind() {\n\t\tif (this.id) {\n\t\t\tif (this._onAssetLoad) this._registry.off('load:' + this.id, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._registry.off('add:' + this.id, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._registry.off('remove:' + this.id, this._onRemove, this);\n\t\t\tif (this._onAssetUnload) this._registry.off(\"unload:\" + this.id, this._onUnload, this);\n\t\t}\n\n\t\tif (this.url) {\n\t\t\tif (this._onAssetLoad) this._registry.off('load:' + this.url, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._registry.off('add:' + this.url, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._registry.off('remove:' + this.url, this._onRemove, this);\n\t\t}\n\t}\n\n\t_onLoad(asset) {\n\t\tthis._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n\n\t_onAdd(asset) {\n\t\tthis.asset = asset;\n\n\t\tthis._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n\n\t_onRemove(asset) {\n\t\tthis._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);\n\n\t\tthis.asset = null;\n\t}\n\n\t_onUnload(asset) {\n\t\tthis._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nclass StandardMaterialValidator {\n\tconstructor() {\n\t\tthis.removeInvalid = true;\n\t\tthis.valid = true;\n\t\tthis.enumValidators = {\n\t\t\toccludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),\n\t\t\tcull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),\n\t\t\tblendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),\n\t\t\tshadingModel: this._createEnumValidator([SPECULAR_PHONG, SPECULAR_BLINN])\n\t\t};\n\t}\n\n\tsetInvalid(key, data) {\n\t\tthis.valid = false;\n\n\t\tif (this.removeInvalid) {\n\t\t\tdelete data[key];\n\t\t}\n\t}\n\n\tvalidate(data) {\n\t\tconst TYPES = standardMaterialParameterTypes;\n\t\tconst pathMapping = data.mappingFormat === \"path\";\n\n\t\tfor (const key in data) {\n\t\t\tconst type = TYPES[key];\n\n\t\t\tif (!type) {\n\t\t\t\tthis.valid = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type.startsWith(\"enum\")) {\n\t\t\t\tconst enumType = type.split(\":\")[1];\n\n\t\t\t\tif (this.enumValidators[enumType]) {\n\t\t\t\t\tif (!this.enumValidators[enumType](data[key])) {\n\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (typeof data[key] !== 'number') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\tif (typeof data[key] !== 'boolean') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'string') {\n\t\t\t\tif (typeof data[key] !== 'string') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'vec2') {\n\t\t\t\tif (!(data[key] instanceof Array && data[key].length === 2)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'rgb') {\n\t\t\t\tif (!(data[key] instanceof Array && data[key].length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'texture') {\n\t\t\t\tif (!pathMapping) {\n\t\t\t\t\tif (!(typeof data[key] === 'number' || data[key] === null)) {\n\t\t\t\t\t\tif (!(data[key] instanceof Texture)) {\n\t\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!(typeof data[key] === 'string' || data[key] === null)) {\n\t\t\t\t\t\tif (!(data[key] instanceof Texture)) {\n\t\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boundingbox') {\n\t\t\t\tif (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\n\t\t\t\tif (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'cubemap') {\n\t\t\t\tif (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {\n\t\t\t\t\tif (!(data[key] instanceof Texture && data[key].cubemap)) {\n\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'chunks') {\n\t\t\t\tconst chunkNames = Object.keys(data[key]);\n\n\t\t\t\tfor (let i = 0; i < chunkNames.length; i++) {\n\t\t\t\t\tif (typeof data[key][chunkNames[i]] !== 'string') {\n\t\t\t\t\t\tthis.setInvalid(chunkNames[i], data[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(\"Unknown material type: \" + type);\n\t\t\t}\n\t\t}\n\n\t\tdata.validated = true;\n\t\treturn this.valid;\n\t}\n\n\t_createEnumValidator(values) {\n\t\treturn function (value) {\n\t\t\treturn values.indexOf(value) >= 0;\n\t\t};\n\t}\n\n}\n\nclass JsonStandardMaterialParser {\n\tconstructor() {\n\t\tthis._validator = null;\n\t}\n\n\tparse(input) {\n\t\tconst migrated = this.migrate(input);\n\n\t\tconst validated = this._validate(migrated);\n\n\t\tconst material = new StandardMaterial();\n\t\tthis.initialize(material, validated);\n\t\treturn material;\n\t}\n\n\tinitialize(material, data) {\n\t\tif (!data.validated) {\n\t\t\tdata = this._validate(data);\n\t\t}\n\n\t\tif (data.chunks) {\n\t\t\tmaterial.chunks = _extends({}, data.chunks);\n\t\t}\n\n\t\tfor (const key in data) {\n\t\t\tconst type = standardMaterialParameterTypes[key];\n\t\t\tconst value = data[key];\n\n\t\t\tif (type === 'vec2') {\n\t\t\t\tmaterial[key] = new Vec2(value[0], value[1]);\n\t\t\t} else if (type === 'rgb') {\n\t\t\t\tmaterial[key] = new Color(value[0], value[1], value[2]);\n\t\t\t} else if (type === 'texture') {\n\t\t\t\tif (value instanceof Texture) {\n\t\t\t\t\tmaterial[key] = value;\n\t\t\t\t} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {\n\t\t\t\t\tmaterial[key] = null;\n\t\t\t\t}\n\t\t\t} else if (type === 'cubemap') {\n\t\t\t\tif (value instanceof Texture) {\n\t\t\t\t\tmaterial[key] = value;\n\t\t\t\t} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {\n\t\t\t\t\tmaterial[key] = null;\n\t\t\t\t}\n\n\t\t\t\tif (key === 'cubeMap' && !value) {\n\t\t\t\t\tmaterial.prefilteredCubemaps = null;\n\t\t\t\t}\n\t\t\t} else if (type === 'boundingbox') {\n\t\t\t\tconst center = new Vec3(value.center[0], value.center[1], value.center[2]);\n\t\t\t\tconst halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);\n\t\t\t\tmaterial[key] = new BoundingBox(center, halfExtents);\n\t\t\t} else {\n\t\t\t\tmaterial[key] = data[key];\n\t\t\t}\n\t\t}\n\n\t\tmaterial.update();\n\t}\n\n\tmigrate(data) {\n\t\tif (data.shadingModel === undefined) {\n\t\t\tif (data.shader === 'blinn') {\n\t\t\t\tdata.shadingModel = SPECULAR_BLINN;\n\t\t\t} else {\n\t\t\t\tdata.shadingModel = SPECULAR_PHONG;\n\t\t\t}\n\t\t}\n\n\t\tif (data.shader) delete data.shader;\n\n\t\tif (data.mapping_format) {\n\t\t\tdata.mappingFormat = data.mapping_format;\n\t\t\tdelete data.mapping_format;\n\t\t}\n\n\t\tlet i;\n\t\tconst RENAMED_PROPERTIES = [[\"bumpMapFactor\", \"bumpiness\"], [\"aoUvSet\", \"aoMapUv\"], [\"aoMapVertexColor\", \"aoVertexColor\"], [\"diffuseMapVertexColor\", \"diffuseVertexColor\"], [\"emissiveMapVertexColor\", \"emissiveVertexColor\"], [\"specularMapVertexColor\", \"specularVertexColor\"], [\"metalnessMapVertexColor\", \"metalnessVertexColor\"], [\"opacityMapVertexColor\", \"opacityVertexColor\"], [\"glossMapVertexColor\", \"glossVertexColor\"], [\"lightMapVertexColor\", \"lightVertexColor\"], [\"diffuseMapTint\", \"diffuseTint\"], [\"specularMapTint\", \"specularTint\"], [\"emissiveMapTint\", \"emissiveTint\"], [\"metalnessMapTint\", \"metalnessTint\"]];\n\n\t\tfor (i = 0; i < RENAMED_PROPERTIES.length; i++) {\n\t\t\tconst _old = RENAMED_PROPERTIES[i][0];\n\t\t\tconst _new = RENAMED_PROPERTIES[i][1];\n\n\t\t\tif (data[_old] !== undefined && !(data[_new] !== undefined)) {\n\t\t\t\tdata[_new] = data[_old];\n\t\t\t\tdelete data[_old];\n\t\t\t}\n\t\t}\n\n\t\tconst DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];\n\n\t\tfor (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {\n\t\t\tconst name = DEPRECATED_PROPERTIES[i];\n\n\t\t\tif (data.hasOwnProperty(name)) {\n\t\t\t\tdelete data[name];\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t_validate(data) {\n\t\tif (!data.validated) {\n\t\t\tif (!this._validator) {\n\t\t\t\tthis._validator = new StandardMaterialValidator();\n\t\t\t}\n\n\t\t\tthis._validator.validate(data);\n\t\t}\n\n\t\treturn data;\n\t}\n\n}\n\nconst PLACEHOLDER_MAP = {\n\taoMap: 'white',\n\tdiffuseMap: 'gray',\n\tspecularMap: 'gray',\n\tmetalnessMap: 'black',\n\tglossMap: 'gray',\n\temissiveMap: 'gray',\n\tnormalMap: 'normal',\n\theightMap: 'gray',\n\topacityMap: 'gray',\n\tsphereMap: 'gray',\n\tlightMap: 'white'\n};\n\nclass MaterialHandler {\n\tconstructor(app) {\n\t\tthis._assets = app.assets;\n\t\tthis._device = app.graphicsDevice;\n\t\tthis._placeholderTextures = null;\n\t\tthis._parser = new JsonStandardMaterialParser();\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tresponse._engine = true;\n\t\t\t\t\tcallback(null, response);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(`Error loading material: ${url.original} [${err}]`);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\tconst material = this._parser.parse(data);\n\n\t\tif (data._engine) {\n\t\t\tmaterial._data = data;\n\t\t\tdelete data._engine;\n\t\t}\n\n\t\treturn material;\n\t}\n\n\t_createPlaceholders() {\n\t\tthis._placeholderTextures = {};\n\t\tconst textures = {\n\t\t\twhite: [255, 255, 255, 255],\n\t\t\tgray: [128, 128, 128, 255],\n\t\t\tblack: [0, 0, 0, 255],\n\t\t\tnormal: [128, 128, 255, 255]\n\t\t};\n\n\t\tfor (const key in textures) {\n\t\t\tif (!textures.hasOwnProperty(key)) continue;\n\t\t\tthis._placeholderTextures[key] = new Texture(this._device, {\n\t\t\t\twidth: 2,\n\t\t\t\theight: 2,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8\n\t\t\t});\n\t\t\tthis._placeholderTextures[key].name = 'placeholder';\n\n\t\t\tconst pixels = this._placeholderTextures[key].lock();\n\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tfor (let c = 0; c < 4; c++) {\n\t\t\t\t\tpixels[i * 4 + c] = textures[key][c];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._placeholderTextures[key].unlock();\n\t\t}\n\t}\n\n\tpatch(asset, assets) {\n\t\tif (asset.resource._data) {\n\t\t\tasset._data = asset.resource._data;\n\t\t\tdelete asset.resource._data;\n\t\t}\n\n\t\tasset.data.name = asset.name;\n\t\tasset.resource.name = asset.name;\n\n\t\tthis._bindAndAssignAssets(asset, assets);\n\n\t\tasset.off('unload', this._onAssetUnload, this);\n\t\tasset.on('unload', this._onAssetUnload, this);\n\t}\n\n\t_onAssetUnload(asset) {\n\t\tdelete asset.data.parameters;\n\t\tdelete asset.data.chunks;\n\t\tdelete asset.data.name;\n\t}\n\n\t_assignTexture(parameterName, materialAsset, texture) {\n\t\tmaterialAsset.resource[parameterName] = texture;\n\t}\n\n\t_getPlaceholderTexture(parameterName) {\n\t\tif (!this._placeholderTextures) {\n\t\t\tthis._createPlaceholders();\n\t\t}\n\n\t\tconst placeholder = PLACEHOLDER_MAP[parameterName];\n\t\tconst texture = this._placeholderTextures[placeholder];\n\t\treturn texture;\n\t}\n\n\t_assignPlaceholderTexture(parameterName, materialAsset) {\n\t\tmaterialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName, materialAsset);\n\t}\n\n\t_onTextureLoad(parameterName, materialAsset, textureAsset) {\n\t\tthis._assignTexture(parameterName, materialAsset, textureAsset.resource);\n\n\t\tmaterialAsset.resource.update();\n\t}\n\n\t_onTextureAdd(parameterName, materialAsset, textureAsset) {\n\t\tthis._assets.load(textureAsset);\n\t}\n\n\t_onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {\n\t\tconst material = materialAsset.resource;\n\n\t\tif (material) {\n\t\t\tif (materialAsset.resource[parameterName] === textureAsset.resource) {\n\t\t\t\tthis._assignPlaceholderTexture(parameterName, materialAsset);\n\n\t\t\t\tmaterial.update();\n\t\t\t}\n\t\t}\n\t}\n\n\t_assignCubemap(parameterName, materialAsset, textures) {\n\t\tmaterialAsset.resource[parameterName] = textures[0];\n\n\t\tif (parameterName === 'cubeMap') {\n\t\t\tmaterialAsset.resource.prefilteredCubemaps = textures.slice(1);\n\t\t}\n\t}\n\n\t_onCubemapLoad(parameterName, materialAsset, cubemapAsset) {\n\t\tthis._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);\n\n\t\tthis._parser.initialize(materialAsset.resource, materialAsset.data);\n\t}\n\n\t_onCubemapAdd(parameterName, materialAsset, cubemapAsset) {\n\t\tif (materialAsset.data.shadingModel === SPECULAR_PHONG) {\n\t\t\tmaterialAsset.loadFaces = true;\n\t\t}\n\n\t\tthis._assets.load(cubemapAsset);\n\t}\n\n\t_onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {\n\t\tconst material = materialAsset.resource;\n\n\t\tif (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {\n\t\t\tthis._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);\n\n\t\t\tmaterial.update();\n\t\t}\n\t}\n\n\t_bindAndAssignAssets(materialAsset, assets) {\n\t\tconst data = this._parser.migrate(materialAsset.data);\n\n\t\tconst material = materialAsset.resource;\n\t\tconst pathMapping = data.mappingFormat === \"path\";\n\t\tconst TEXTURES = standardMaterialTextureParameters;\n\t\tlet i, name, assetReference;\n\n\t\tfor (i = 0; i < TEXTURES.length; i++) {\n\t\t\tname = TEXTURES[i];\n\t\t\tassetReference = material._assetReferences[name];\n\t\t\tconst dataAssetId = data[name];\n\t\t\tconst materialTexture = material[name];\n\n\t\t\tconst isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name, materialAsset);\n\n\t\t\tconst dataValidated = data.validated;\n\n\t\t\tif (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {\n\t\t\t\tif (!assetReference) {\n\t\t\t\t\tassetReference = new AssetReference(name, materialAsset, assets, {\n\t\t\t\t\t\tload: this._onTextureLoad,\n\t\t\t\t\t\tadd: this._onTextureAdd,\n\t\t\t\t\t\tremove: this._onTextureRemoveOrUnload,\n\t\t\t\t\t\tunload: this._onTextureRemoveOrUnload\n\t\t\t\t\t}, this);\n\t\t\t\t\tmaterial._assetReferences[name] = assetReference;\n\t\t\t\t}\n\n\t\t\t\tif (pathMapping) {\n\t\t\t\t\tassetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);\n\t\t\t\t} else {\n\t\t\t\t\tassetReference.id = dataAssetId;\n\t\t\t\t}\n\n\t\t\t\tif (assetReference.asset) {\n\t\t\t\t\tif (assetReference.asset.resource) {\n\t\t\t\t\t\tthis._assignTexture(name, materialAsset, assetReference.asset.resource);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._assignPlaceholderTexture(name, materialAsset);\n\t\t\t\t\t}\n\n\t\t\t\t\tassets.load(assetReference.asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (assetReference) {\n\t\t\t\t\tif (pathMapping) {\n\t\t\t\t\t\tassetReference.url = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassetReference.id = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst CUBEMAPS = standardMaterialCubemapParameters;\n\n\t\tfor (i = 0; i < CUBEMAPS.length; i++) {\n\t\t\tname = CUBEMAPS[i];\n\t\t\tassetReference = material._assetReferences[name];\n\n\t\t\tif (data[name] && !materialAsset.data.prefilteredCubeMap128) {\n\t\t\t\tif (!assetReference) {\n\t\t\t\t\tassetReference = new AssetReference(name, materialAsset, assets, {\n\t\t\t\t\t\tload: this._onCubemapLoad,\n\t\t\t\t\t\tadd: this._onCubemapAdd,\n\t\t\t\t\t\tremove: this._onCubemapRemoveOrUnload,\n\t\t\t\t\t\tunload: this._onCubemapRemoveOrUnload\n\t\t\t\t\t}, this);\n\t\t\t\t\tmaterial._assetReferences[name] = assetReference;\n\t\t\t\t}\n\n\t\t\t\tif (pathMapping) {\n\t\t\t\t\tassetReference.url = data[name];\n\t\t\t\t} else {\n\t\t\t\t\tassetReference.id = data[name];\n\t\t\t\t}\n\n\t\t\t\tif (assetReference.asset) {\n\t\t\t\t\tif (assetReference.asset.loaded) {\n\t\t\t\t\t\tthis._assignCubemap(name, materialAsset, assetReference.asset.resources);\n\t\t\t\t\t}\n\n\t\t\t\t\tassets.load(assetReference.asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._parser.initialize(material, data);\n\t}\n\n}\n\nclass GlbModelParser {\n\tconstructor(device, defaultMaterial) {\n\t\tthis._device = device;\n\t\tthis._defaultMaterial = defaultMaterial;\n\t}\n\n\tparse(data) {\n\t\tconst glbResources = GlbParser.parse(\"filename.glb\", data, this._device);\n\n\t\tif (glbResources) {\n\t\t\tconst model = GlbContainerResource.createModel(glbResources, this._defaultMaterial);\n\t\t\tglbResources.destroy();\n\t\t\treturn model;\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n\nclass PartitionedVertex {\n\tconstructor() {\n\t\tthis.index = 0;\n\t\tthis.boneIndices = [0, 0, 0, 0];\n\t}\n\n}\n\nclass SkinPartition {\n\tconstructor() {\n\t\tthis.partition = 0;\n\t\tthis.vertexStart = 0;\n\t\tthis.vertexCount = 0;\n\t\tthis.indexStart = 0;\n\t\tthis.indexCount = 0;\n\t\tthis.boneIndices = [];\n\t\tthis.vertices = [];\n\t\tthis.indices = [];\n\t\tthis.indexMap = {};\n\t\tthis.originalMesh = null;\n\t}\n\n\taddVertex(vertex, idx, vertexArray) {\n\t\tlet remappedIndex = -1;\n\n\t\tif (this.indexMap[idx] !== undefined) {\n\t\t\tremappedIndex = this.indexMap[idx];\n\t\t\tthis.indices.push(remappedIndex);\n\t\t} else {\n\t\t\tfor (let influence = 0; influence < 4; influence++) {\n\t\t\t\tif (vertexArray.blendWeight.data[idx * 4 + influence] === 0) continue;\n\t\t\t\tconst originalBoneIndex = vertexArray.blendIndices.data[vertex.index * 4 + influence];\n\t\t\t\tvertex.boneIndices[influence] = this.getBoneRemap(originalBoneIndex);\n\t\t\t}\n\n\t\t\tremappedIndex = this.vertices.length;\n\t\t\tthis.indices.push(remappedIndex);\n\t\t\tthis.vertices.push(vertex);\n\t\t\tthis.indexMap[idx] = remappedIndex;\n\t\t}\n\t}\n\n\taddPrimitive(vertices, vertexIndices, vertexArray, boneLimit) {\n\t\tconst bonesToAdd = [];\n\t\tlet bonesToAddCount = 0;\n\t\tconst vertexCount = vertices.length;\n\n\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\tconst vertex = vertices[i];\n\t\t\tconst idx = vertex.index;\n\n\t\t\tfor (let influence = 0; influence < 4; influence++) {\n\t\t\t\tif (vertexArray.blendWeight.data[idx * 4 + influence] > 0) {\n\t\t\t\t\tconst boneIndex = vertexArray.blendIndices.data[idx * 4 + influence];\n\t\t\t\t\tlet needToAdd = true;\n\n\t\t\t\t\tfor (let j = 0; j < bonesToAddCount; j++) {\n\t\t\t\t\t\tif (bonesToAdd[j] === boneIndex) {\n\t\t\t\t\t\t\tneedToAdd = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (needToAdd) {\n\t\t\t\t\t\tbonesToAdd[bonesToAddCount] = boneIndex;\n\t\t\t\t\t\tconst boneRemap = this.getBoneRemap(boneIndex);\n\t\t\t\t\t\tbonesToAddCount += boneRemap === -1 ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.boneIndices.length + bonesToAddCount > boneLimit) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < bonesToAddCount; i++) {\n\t\t\tthis.boneIndices.push(bonesToAdd[i]);\n\t\t}\n\n\t\tfor (let i = 0; i < vertexCount; i++) {\n\t\t\tthis.addVertex(vertices[i], vertexIndices[i], vertexArray);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tgetBoneRemap(boneIndex) {\n\t\tfor (let i = 0; i < this.boneIndices.length; i++) {\n\t\t\tif (this.boneIndices[i] === boneIndex) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n}\n\nfunction indicesToReferences(model) {\n\tconst vertices = model.vertices;\n\tconst skins = model.skins;\n\tconst meshes = model.meshes;\n\tconst meshInstances = model.meshInstances;\n\n\tfor (let i = 0; i < meshes.length; i++) {\n\t\tmeshes[i].vertices = vertices[meshes[i].vertices];\n\n\t\tif (meshes[i].skin !== undefined) {\n\t\t\tmeshes[i].skin = skins[meshes[i].skin];\n\t\t}\n\t}\n\n\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\tmeshInstances[i].mesh = meshes[meshInstances[i].mesh];\n\t}\n}\n\nfunction referencesToIndices(model) {\n\tconst vertices = model.vertices;\n\tconst skins = model.skins;\n\tconst meshes = model.meshes;\n\tconst meshInstances = model.meshInstances;\n\n\tfor (let i = 0; i < meshes.length; i++) {\n\t\tmeshes[i].vertices = vertices.indexOf(meshes[i].vertices);\n\n\t\tif (meshes[i].skin !== undefined) {\n\t\t\tmeshes[i].skin = skins.indexOf(meshes[i].skin);\n\t\t}\n\t}\n\n\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\tmeshInstances[i].mesh = meshes.indexOf(meshInstances[i].mesh);\n\t}\n}\n\nfunction partitionSkin(model, materialMappings, boneLimit) {\n\tlet i, j, k, index;\n\tindicesToReferences(model);\n\tconst vertexArrays = model.vertices;\n\tconst skins = model.skins;\n\tlet mesh;\n\tconst meshes = model.meshes;\n\tconst meshInstances = model.meshInstances;\n\n\tconst getVertex = function getVertex(idx) {\n\t\tconst vert = new PartitionedVertex();\n\t\tvert.index = idx;\n\t\treturn vert;\n\t};\n\n\tfor (i = skins.length - 1; i >= 0; i--) {\n\t\tif (skins[i].boneNames.length > boneLimit) {\n\t\t\tconst skin = skins.splice(i, 1)[0];\n\t\t\tconst meshesToSplit = [];\n\n\t\t\tfor (j = 0; j < meshes.length; j++) {\n\t\t\t\tif (meshes[j].skin === skin) {\n\t\t\t\t\tmeshesToSplit.push(meshes[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (j = 0; j < meshesToSplit.length; j++) {\n\t\t\t\tindex = meshes.indexOf(meshesToSplit[j]);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tmeshes.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (meshesToSplit.length === 0) {\n\t\t\t\tthrow new Error('partitionSkin: There should be at least one mesh that references a skin');\n\t\t\t}\n\n\t\t\tconst vertexArray = meshesToSplit[0].vertices;\n\n\t\t\tfor (j = 1; j < meshesToSplit.length; j++) {\n\t\t\t\tif (meshesToSplit[j].vertices !== vertexArray) {\n\t\t\t\t\tthrow new Error('partitionSkin: All meshes that share a skin should also share the same vertex buffer');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet partition;\n\t\t\tconst partitions = [];\n\t\t\tconst primitiveVertices = [];\n\t\t\tconst primitiveIndices = [];\n\t\t\tlet basePartition = 0;\n\n\t\t\tfor (j = 0; j < meshesToSplit.length; j++) {\n\t\t\t\tmesh = meshesToSplit[j];\n\t\t\t\tconst indices = mesh.indices;\n\n\t\t\t\tfor (let iIndex = mesh.base; iIndex < mesh.base + mesh.count;) {\n\t\t\t\t\tindex = indices[iIndex++];\n\t\t\t\t\tprimitiveVertices[0] = getVertex(index);\n\t\t\t\t\tprimitiveIndices[0] = index;\n\t\t\t\t\tindex = indices[iIndex++];\n\t\t\t\t\tprimitiveVertices[1] = getVertex(index);\n\t\t\t\t\tprimitiveIndices[1] = index;\n\t\t\t\t\tindex = indices[iIndex++];\n\t\t\t\t\tprimitiveVertices[2] = getVertex(index);\n\t\t\t\t\tprimitiveIndices[2] = index;\n\t\t\t\t\tlet added = false;\n\n\t\t\t\t\tfor (let iBonePartition = basePartition; iBonePartition < partitions.length; iBonePartition++) {\n\t\t\t\t\t\tpartition = partitions[iBonePartition];\n\n\t\t\t\t\t\tif (partition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit)) {\n\t\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!added) {\n\t\t\t\t\t\tpartition = new SkinPartition();\n\t\t\t\t\t\tpartition.originalMesh = mesh;\n\t\t\t\t\t\tpartition.addPrimitive(primitiveVertices, primitiveIndices, vertexArray, boneLimit);\n\t\t\t\t\t\tpartitions.push(partition);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbasePartition = partitions.length;\n\t\t\t}\n\n\t\t\tconst partitionedVertices = [];\n\t\t\tconst partitionedIndices = [];\n\n\t\t\tfor (j = 0; j < partitions.length; j++) {\n\t\t\t\tpartition = partitions[j];\n\n\t\t\t\tif (partition.vertices.length && partition.indices.length) {\n\t\t\t\t\tconst vertexStart = partitionedVertices.length;\n\t\t\t\t\tconst vertexCount = partition.vertices.length;\n\t\t\t\t\tconst indexStart = partitionedIndices.length;\n\t\t\t\t\tconst indexCount = partition.indices.length;\n\t\t\t\t\tpartition.partition = j;\n\t\t\t\t\tpartition.vertexStart = vertexStart;\n\t\t\t\t\tpartition.vertexCount = vertexCount;\n\t\t\t\t\tpartition.indexStart = indexStart;\n\t\t\t\t\tpartition.indexCount = indexCount;\n\t\t\t\t\tlet iSour;\n\t\t\t\t\tlet iDest;\n\t\t\t\t\tiSour = 0;\n\t\t\t\t\tiDest = vertexStart;\n\n\t\t\t\t\twhile (iSour < vertexCount) {\n\t\t\t\t\t\tpartitionedVertices[iDest++] = partition.vertices[iSour++];\n\t\t\t\t\t}\n\n\t\t\t\t\tiSour = 0;\n\t\t\t\t\tiDest = indexStart;\n\n\t\t\t\t\twhile (iSour < indexCount) {\n\t\t\t\t\t\tpartitionedIndices[iDest++] = partition.indices[iSour++] + vertexStart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst splitSkins = [];\n\n\t\t\tfor (j = 0; j < partitions.length; j++) {\n\t\t\t\tpartition = partitions[j];\n\t\t\t\tconst ibp = [];\n\t\t\t\tconst boneNames = [];\n\n\t\t\t\tfor (k = 0; k < partition.boneIndices.length; k++) {\n\t\t\t\t\tibp.push(skin.inverseBindMatrices[partition.boneIndices[k]]);\n\t\t\t\t\tboneNames.push(skin.boneNames[partition.boneIndices[k]]);\n\t\t\t\t}\n\n\t\t\t\tconst splitSkin = {\n\t\t\t\t\tinverseBindMatrices: ibp,\n\t\t\t\t\tboneNames: boneNames\n\t\t\t\t};\n\t\t\t\tsplitSkins.push(splitSkin);\n\t\t\t\tskins.push(splitSkin);\n\t\t\t}\n\n\t\t\tlet attrib, attribName, data, components;\n\t\t\tconst splitVertexArray = {};\n\n\t\t\tfor (attribName in vertexArray) {\n\t\t\t\tsplitVertexArray[attribName] = {\n\t\t\t\t\tcomponents: vertexArray[attribName].components,\n\t\t\t\t\tdata: [],\n\t\t\t\t\ttype: vertexArray[attribName].type\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfor (attribName in vertexArray) {\n\t\t\t\tif (attribName === 'blendIndices') {\n\t\t\t\t\tconst dstBoneIndices = splitVertexArray[attribName].data;\n\n\t\t\t\t\tfor (j = 0; j < partitionedVertices.length; j++) {\n\t\t\t\t\t\tconst srcBoneIndices = partitionedVertices[j].boneIndices;\n\t\t\t\t\t\tdstBoneIndices.push(srcBoneIndices[0], srcBoneIndices[1], srcBoneIndices[2], srcBoneIndices[3]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tattrib = vertexArray[attribName];\n\t\t\t\t\tdata = attrib.data;\n\t\t\t\t\tcomponents = attrib.components;\n\n\t\t\t\t\tfor (j = 0; j < partitionedVertices.length; j++) {\n\t\t\t\t\t\tindex = partitionedVertices[j].index;\n\n\t\t\t\t\t\tfor (k = 0; k < components; k++) {\n\t\t\t\t\t\t\tsplitVertexArray[attribName].data.push(data[index * components + k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvertexArrays[vertexArrays.indexOf(vertexArray)] = splitVertexArray;\n\n\t\t\tfor (j = 0; j < partitions.length; j++) {\n\t\t\t\tpartition = partitions[j];\n\t\t\t\tmesh = {\n\t\t\t\t\taabb: {\n\t\t\t\t\t\tmin: [0, 0, 0],\n\t\t\t\t\t\tmax: [0, 0, 0]\n\t\t\t\t\t},\n\t\t\t\t\tvertices: splitVertexArray,\n\t\t\t\t\tskin: splitSkins[j],\n\t\t\t\t\tindices: partitionedIndices.splice(0, partition.indexCount),\n\t\t\t\t\ttype: 'triangles',\n\t\t\t\t\tbase: 0,\n\t\t\t\t\tcount: partition.indexCount\n\t\t\t\t};\n\t\t\t\tmeshes.push(mesh);\n\n\t\t\t\tfor (k = meshInstances.length - 1; k >= 0; k--) {\n\t\t\t\t\tif (meshInstances[k].mesh === partition.originalMesh) {\n\t\t\t\t\t\tmeshInstances.push({\n\t\t\t\t\t\t\tmesh: mesh,\n\t\t\t\t\t\t\tnode: meshInstances[k].node\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (materialMappings) {\n\t\t\t\t\t\t\tmaterialMappings.push({\n\t\t\t\t\t\t\t\tmaterial: materialMappings[k].material,\n\t\t\t\t\t\t\t\tpath: materialMappings[k].path\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (j = 0; j < partitions.length; j++) {\n\t\t\t\tpartition = partitions[j];\n\n\t\t\t\tfor (k = meshInstances.length - 1; k >= 0; k--) {\n\t\t\t\t\tif (meshInstances[k].mesh === partition.originalMesh) {\n\t\t\t\t\t\tmeshInstances.splice(k, 1);\n\n\t\t\t\t\t\tif (materialMappings) {\n\t\t\t\t\t\t\tmaterialMappings.splice(k, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treferencesToIndices(model);\n}\n\nconst JSON_PRIMITIVE_TYPE = {\n\t\"points\": PRIMITIVE_POINTS,\n\t\"lines\": PRIMITIVE_LINES,\n\t\"lineloop\": PRIMITIVE_LINELOOP,\n\t\"linestrip\": PRIMITIVE_LINESTRIP,\n\t\"triangles\": PRIMITIVE_TRIANGLES,\n\t\"trianglestrip\": PRIMITIVE_TRISTRIP,\n\t\"trianglefan\": PRIMITIVE_TRIFAN\n};\nconst JSON_VERTEX_ELEMENT_TYPE = {\n\t\"int8\": TYPE_INT8,\n\t\"uint8\": TYPE_UINT8,\n\t\"int16\": TYPE_INT16,\n\t\"uint16\": TYPE_UINT16,\n\t\"int32\": TYPE_INT32,\n\t\"uint32\": TYPE_UINT32,\n\t\"float32\": TYPE_FLOAT32\n};\n\nclass JsonModelParser {\n\tconstructor(device, defaultMaterial) {\n\t\tthis._device = device;\n\t\tthis._defaultMaterial = defaultMaterial;\n\t}\n\n\tparse(data) {\n\t\tconst modelData = data.model;\n\n\t\tif (!modelData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (modelData.version <= 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst nodes = this._parseNodes(data);\n\n\t\tconst skins = this._parseSkins(data, nodes);\n\n\t\tconst vertexBuffers = this._parseVertexBuffers(data);\n\n\t\tconst indices = this._parseIndexBuffers(data, vertexBuffers);\n\n\t\tconst morphs = this._parseMorphs(data, nodes, vertexBuffers);\n\n\t\tconst meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);\n\n\t\tconst meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);\n\n\t\tconst model = new Model();\n\t\tmodel.graph = nodes[0];\n\t\tmodel.meshInstances = meshInstances;\n\t\tmodel.skinInstances = skins.instances;\n\t\tmodel.morphInstances = morphs.instances;\n\t\tmodel.getGraph().syncHierarchy();\n\t\treturn model;\n\t}\n\n\t_parseNodes(data) {\n\t\tconst modelData = data.model;\n\t\tconst nodes = [];\n\t\tlet i;\n\n\t\tfor (i = 0; i < modelData.nodes.length; i++) {\n\t\t\tconst nodeData = modelData.nodes[i];\n\t\t\tconst node = new GraphNode(nodeData.name);\n\t\t\tnode.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);\n\t\t\tnode.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);\n\t\t\tnode.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);\n\t\t\tnode.scaleCompensation = !!nodeData.scaleCompensation;\n\t\t\tnodes.push(node);\n\t\t}\n\n\t\tfor (i = 1; i < modelData.parents.length; i++) {\n\t\t\tnodes[modelData.parents[i]].addChild(nodes[i]);\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t_parseSkins(data, nodes) {\n\t\tconst modelData = data.model;\n\t\tconst skins = [];\n\t\tconst skinInstances = [];\n\t\tlet i, j;\n\n\t\tif (!this._device.supportsBoneTextures && modelData.skins.length > 0) {\n\t\t\tconst boneLimit = this._device.getBoneLimit();\n\n\t\t\tpartitionSkin(modelData, null, boneLimit);\n\t\t}\n\n\t\tfor (i = 0; i < modelData.skins.length; i++) {\n\t\t\tconst skinData = modelData.skins[i];\n\t\t\tconst inverseBindMatrices = [];\n\n\t\t\tfor (j = 0; j < skinData.inverseBindMatrices.length; j++) {\n\t\t\t\tconst ibm = skinData.inverseBindMatrices[j];\n\t\t\t\tinverseBindMatrices[j] = new Mat4().set(ibm);\n\t\t\t}\n\n\t\t\tconst skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);\n\t\t\tskins.push(skin);\n\t\t\tconst skinInstance = new SkinInstance(skin);\n\t\t\tconst bones = [];\n\n\t\t\tfor (j = 0; j < skin.boneNames.length; j++) {\n\t\t\t\tconst boneName = skin.boneNames[j];\n\t\t\t\tconst bone = nodes[0].findByName(boneName);\n\t\t\t\tbones.push(bone);\n\t\t\t}\n\n\t\t\tskinInstance.bones = bones;\n\t\t\tskinInstances.push(skinInstance);\n\t\t}\n\n\t\treturn {\n\t\t\tskins: skins,\n\t\t\tinstances: skinInstances\n\t\t};\n\t}\n\n\t_getMorphVertexCount(modelData, morphIndex, vertexBuffers) {\n\t\tfor (let i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\n\t\t\tif (meshData.morph === morphIndex) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[meshData.vertices];\n\t\t\t\treturn vertexBuffer.numVertices;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t_parseMorphs(data, nodes, vertexBuffers) {\n\t\tconst modelData = data.model;\n\t\tconst morphs = [];\n\t\tconst morphInstances = [];\n\t\tlet i, j, vertexCount;\n\t\tlet targets, morphTarget, morphTargetArray;\n\n\t\tif (modelData.morphs) {\n\t\t\tconst sparseToFull = function sparseToFull(data, indices, totalCount) {\n\t\t\t\tconst full = new Float32Array(totalCount * 3);\n\n\t\t\t\tfor (let s = 0; s < indices.length; s++) {\n\t\t\t\t\tconst dstIndex = indices[s] * 3;\n\t\t\t\t\tfull[dstIndex] = data[s * 3];\n\t\t\t\t\tfull[dstIndex + 1] = data[s * 3 + 1];\n\t\t\t\t\tfull[dstIndex + 2] = data[s * 3 + 2];\n\t\t\t\t}\n\n\t\t\t\treturn full;\n\t\t\t};\n\n\t\t\tfor (i = 0; i < modelData.morphs.length; i++) {\n\t\t\t\ttargets = modelData.morphs[i].targets;\n\t\t\t\tmorphTargetArray = [];\n\t\t\t\tvertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);\n\n\t\t\t\tfor (j = 0; j < targets.length; j++) {\n\t\t\t\t\tconst targetAabb = targets[j].aabb;\n\t\t\t\t\tconst min = targetAabb.min;\n\t\t\t\t\tconst max = targetAabb.max;\n\t\t\t\t\tconst aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n\t\t\t\t\tconst indices = targets[j].indices;\n\t\t\t\t\tlet deltaPositions = targets[j].deltaPositions;\n\t\t\t\t\tlet deltaNormals = targets[j].deltaNormals;\n\n\t\t\t\t\tif (indices) {\n\t\t\t\t\t\tdeltaPositions = sparseToFull(deltaPositions, indices, vertexCount);\n\t\t\t\t\t\tdeltaNormals = sparseToFull(deltaNormals, indices, vertexCount);\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphTarget = new MorphTarget({\n\t\t\t\t\t\tdeltaPositions: deltaPositions,\n\t\t\t\t\t\tdeltaNormals: deltaNormals,\n\t\t\t\t\t\tname: targets[j].name,\n\t\t\t\t\t\taabb: aabb\n\t\t\t\t\t});\n\t\t\t\t\tmorphTargetArray.push(morphTarget);\n\t\t\t\t}\n\n\t\t\t\tconst morph = new Morph(morphTargetArray, this._device);\n\t\t\t\tmorphs.push(morph);\n\t\t\t\tconst morphInstance = new MorphInstance(morph);\n\t\t\t\tmorphInstances.push(morphInstance);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmorphs: morphs,\n\t\t\tinstances: morphInstances\n\t\t};\n\t}\n\n\t_parseVertexBuffers(data) {\n\t\tconst modelData = data.model;\n\t\tconst vertexBuffers = [];\n\t\tconst attributeMap = {\n\t\t\tposition: SEMANTIC_POSITION,\n\t\t\tnormal: SEMANTIC_NORMAL,\n\t\t\ttangent: SEMANTIC_TANGENT,\n\t\t\tblendWeight: SEMANTIC_BLENDWEIGHT,\n\t\t\tblendIndices: SEMANTIC_BLENDINDICES,\n\t\t\tcolor: SEMANTIC_COLOR,\n\t\t\ttexCoord0: SEMANTIC_TEXCOORD0,\n\t\t\ttexCoord1: SEMANTIC_TEXCOORD1,\n\t\t\ttexCoord2: SEMANTIC_TEXCOORD2,\n\t\t\ttexCoord3: SEMANTIC_TEXCOORD3,\n\t\t\ttexCoord4: SEMANTIC_TEXCOORD4,\n\t\t\ttexCoord5: SEMANTIC_TEXCOORD5,\n\t\t\ttexCoord6: SEMANTIC_TEXCOORD6,\n\t\t\ttexCoord7: SEMANTIC_TEXCOORD7\n\t\t};\n\n\t\tfor (let i = 0; i < modelData.vertices.length; i++) {\n\t\t\tconst vertexData = modelData.vertices[i];\n\t\t\tconst formatDesc = [];\n\n\t\t\tfor (const attributeName in vertexData) {\n\t\t\t\tconst attribute = vertexData[attributeName];\n\t\t\t\tformatDesc.push({\n\t\t\t\t\tsemantic: attributeMap[attributeName],\n\t\t\t\t\tcomponents: attribute.components,\n\t\t\t\t\ttype: JSON_VERTEX_ELEMENT_TYPE[attribute.type],\n\t\t\t\t\tnormalize: attributeMap[attributeName] === SEMANTIC_COLOR\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst vertexFormat = new VertexFormat(this._device, formatDesc);\n\t\t\tconst numVertices = vertexData.position.data.length / vertexData.position.components;\n\t\t\tconst vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);\n\t\t\tconst iterator = new VertexIterator(vertexBuffer);\n\n\t\t\tfor (let j = 0; j < numVertices; j++) {\n\t\t\t\tfor (const attributeName in vertexData) {\n\t\t\t\t\tconst attribute = vertexData[attributeName];\n\n\t\t\t\t\tswitch (attribute.components) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j]);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 2], 1.0 - attribute.data[j * 2 + 1]);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titerator.next();\n\t\t\t}\n\n\t\t\titerator.end();\n\t\t\tvertexBuffers.push(vertexBuffer);\n\t\t}\n\n\t\treturn vertexBuffers;\n\t}\n\n\t_parseIndexBuffers(data, vertexBuffers) {\n\t\tconst modelData = data.model;\n\t\tlet indexBuffer = null;\n\t\tlet indexData = null;\n\t\tlet i;\n\t\tlet numIndices = 0;\n\n\t\tfor (i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\n\t\t\tif (meshData.indices !== undefined) {\n\t\t\t\tnumIndices += meshData.indices.length;\n\t\t\t}\n\t\t}\n\n\t\tlet maxVerts = 0;\n\n\t\tfor (i = 0; i < vertexBuffers.length; i++) {\n\t\t\tmaxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);\n\t\t}\n\n\t\tif (numIndices > 0) {\n\t\t\tif (maxVerts > 0xFFFF && this._device.extUintElement) {\n\t\t\t\tindexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);\n\t\t\t\tindexData = new Uint32Array(indexBuffer.lock());\n\t\t\t} else {\n\t\t\t\tindexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);\n\t\t\t\tindexData = new Uint16Array(indexBuffer.lock());\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: indexBuffer,\n\t\t\tdata: indexData\n\t\t};\n\t}\n\n\t_parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {\n\t\tconst modelData = data.model;\n\t\tconst meshes = [];\n\t\tlet indexBase = 0;\n\n\t\tfor (let i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\t\t\tconst meshAabb = meshData.aabb;\n\t\t\tconst min = meshAabb.min;\n\t\t\tconst max = meshAabb.max;\n\t\t\tconst aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n\t\t\tconst indexed = meshData.indices !== undefined;\n\t\t\tconst mesh = new Mesh(this._device);\n\t\t\tmesh.vertexBuffer = vertexBuffers[meshData.vertices];\n\t\t\tmesh.indexBuffer[0] = indexed ? indexBuffer : null;\n\t\t\tmesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];\n\t\t\tmesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;\n\t\t\tmesh.primitive[0].count = meshData.count;\n\t\t\tmesh.primitive[0].indexed = indexed;\n\t\t\tmesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;\n\t\t\tmesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;\n\t\t\tmesh.aabb = aabb;\n\n\t\t\tif (indexed) {\n\t\t\t\tindexData.set(meshData.indices, indexBase);\n\t\t\t\tindexBase += meshData.indices.length;\n\t\t\t}\n\n\t\t\tmeshes.push(mesh);\n\t\t}\n\n\t\tif (indexBuffer !== null) {\n\t\t\tindexBuffer.unlock();\n\t\t}\n\n\t\treturn meshes;\n\t}\n\n\t_parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {\n\t\tconst modelData = data.model;\n\t\tconst meshInstances = [];\n\t\tlet i;\n\n\t\tfor (i = 0; i < modelData.meshInstances.length; i++) {\n\t\t\tconst meshInstanceData = modelData.meshInstances[i];\n\t\t\tconst node = nodes[meshInstanceData.node];\n\t\t\tconst mesh = meshes[meshInstanceData.mesh];\n\t\t\tconst meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);\n\n\t\t\tif (mesh.skin) {\n\t\t\t\tconst skinIndex = skins.indexOf(mesh.skin);\n\t\t\t\tmeshInstance.skinInstance = skinInstances[skinIndex];\n\t\t\t}\n\n\t\t\tif (mesh.morph) {\n\t\t\t\tconst morphIndex = morphs.indexOf(mesh.morph);\n\t\t\t\tmeshInstance.morphInstance = morphInstances[morphIndex];\n\t\t\t}\n\n\t\t\tmeshInstances.push(meshInstance);\n\t\t}\n\n\t\treturn meshInstances;\n\t}\n\n}\n\nclass ModelHandler {\n\tconstructor(device) {\n\t\tthis._device = device;\n\t\tthis._parsers = [];\n\t\tthis._defaultMaterial = DefaultMaterial.get(device);\n\t\tthis.maxRetries = 0;\n\t\tthis.addParser(new JsonModelParser(this._device, this._defaultMaterial), function (url, data) {\n\t\t\treturn path.getExtension(url) === '.json';\n\t\t});\n\t\tthis.addParser(new GlbModelParser(this._device, this._defaultMaterial), function (url, data) {\n\t\t\treturn path.getExtension(url) === '.glb';\n\t\t});\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\n\t\tif (url.load.startsWith('blob:') || url.load.startsWith('data:')) {\n\t\t\tif (path.getExtension(url.original).toLowerCase() === '.glb') {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t} else {\n\t\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t\t}\n\t\t}\n\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (!callback) return;\n\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading model: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\tfor (let i = 0; i < this._parsers.length; i++) {\n\t\t\tconst p = this._parsers[i];\n\n\t\t\tif (p.decider(url, data)) {\n\t\t\t\treturn p.parser.parse(data);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpatch(asset, assets) {\n\t\tif (!asset.resource) return;\n\t\tconst data = asset.data;\n\t\tconst self = this;\n\t\tasset.resource.meshInstances.forEach(function (meshInstance, i) {\n\t\t\tif (data.mapping) {\n\t\t\t\tconst handleMaterial = function handleMaterial(asset) {\n\t\t\t\t\tif (asset.resource) {\n\t\t\t\t\t\tmeshInstance.material = asset.resource;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasset.once('load', handleMaterial);\n\t\t\t\t\t\tassets.load(asset);\n\t\t\t\t\t}\n\n\t\t\t\t\tasset.once('remove', function (asset) {\n\t\t\t\t\t\tif (meshInstance.material === asset.resource) {\n\t\t\t\t\t\t\tmeshInstance.material = self._defaultMaterial;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tif (!data.mapping[i]) {\n\t\t\t\t\tmeshInstance.material = self._defaultMaterial;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst id = data.mapping[i].material;\n\t\t\t\tconst url = data.mapping[i].path;\n\t\t\t\tlet material;\n\n\t\t\t\tif (id !== undefined) {\n\t\t\t\t\tif (!id) {\n\t\t\t\t\t\tmeshInstance.material = self._defaultMaterial;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmaterial = assets.get(id);\n\n\t\t\t\t\t\tif (material) {\n\t\t\t\t\t\t\thandleMaterial(material);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassets.once('add:' + id, handleMaterial);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (url) {\n\t\t\t\t\tconst path = asset.getAbsoluteUrl(data.mapping[i].path);\n\t\t\t\t\tmaterial = assets.getByUrl(path);\n\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\thandleMaterial(material);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassets.once('add:url:' + path, handleMaterial);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\taddParser(parser, decider) {\n\t\tthis._parsers.push({\n\t\t\tparser: parser,\n\t\t\tdecider: decider\n\t\t});\n\t}\n\n}\n\nfunction onContainerAssetLoaded(containerAsset) {\n\tconst renderAsset = this;\n\tif (!renderAsset.resource) return;\n\tconst containerResource = containerAsset.resource;\n\tconst render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];\n\n\tif (render) {\n\t\trenderAsset.resource.meshes = render.resource.meshes;\n\t}\n}\n\nfunction onContainerAssetAdded(containerAsset) {\n\tconst renderAsset = this;\n\trenderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n\trenderAsset.registry.on('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n\trenderAsset.registry.off('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);\n\trenderAsset.registry.once('remove:' + containerAsset.id, onContainerAssetRemoved, renderAsset);\n\n\tif (!containerAsset.resource) {\n\t\trenderAsset.registry.load(containerAsset);\n\t} else {\n\t\tonContainerAssetLoaded.call(renderAsset, containerAsset);\n\t}\n}\n\nfunction onContainerAssetRemoved(containerAsset) {\n\tconst renderAsset = this;\n\trenderAsset.registry.off('load:' + containerAsset.id, onContainerAssetLoaded, renderAsset);\n\n\tif (renderAsset.resource) {\n\t\trenderAsset.resource.destroy();\n\t}\n}\n\nclass RenderHandler {\n\tconstructor(assets) {\n\t\tthis._registry = assets;\n\t}\n\n\tload(url, callback, asset) {}\n\n\topen(url, data) {\n\t\treturn new Render();\n\t}\n\n\tpatch(asset, registry) {\n\t\tif (!asset.data.containerAsset) return;\n\t\tconst containerAsset = registry.get(asset.data.containerAsset);\n\n\t\tif (!containerAsset) {\n\t\t\tregistry.once('add:' + asset.data.containerAsset, onContainerAssetAdded, asset);\n\t\t\treturn;\n\t\t}\n\n\t\tonContainerAssetAdded.call(asset, containerAsset);\n\t}\n\n}\n\nclass ResourceLoader {\n\tconstructor(app) {\n\t\tthis._handlers = {};\n\t\tthis._requests = {};\n\t\tthis._cache = {};\n\t\tthis._app = app;\n\t}\n\n\taddHandler(type, handler) {\n\t\tthis._handlers[type] = handler;\n\t\thandler._loader = this;\n\t}\n\n\tremoveHandler(type) {\n\t\tdelete this._handlers[type];\n\t}\n\n\tgetHandler(type) {\n\t\treturn this._handlers[type];\n\t}\n\n\tload(url, type, callback, asset) {\n\t\tconst handler = this._handlers[type];\n\n\t\tif (!handler) {\n\t\t\tconst err = \"No handler for asset type: \" + type;\n\t\t\tcallback(err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!url) {\n\t\t\tthis._loadNull(handler, callback, asset);\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst key = url + type;\n\n\t\tif (this._cache[key] !== undefined) {\n\t\t\tcallback(null, this._cache[key]);\n\t\t} else if (this._requests[key]) {\n\t\t\tthis._requests[key].push(callback);\n\t\t} else {\n\t\t\tthis._requests[key] = [callback];\n\t\t\tconst self = this;\n\n\t\t\tconst handleLoad = function handleLoad(err, urlObj) {\n\t\t\t\tif (err) {\n\t\t\t\t\tself._onFailure(key, err);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\thandler.load(urlObj, function (err, data, extra) {\n\t\t\t\t\tif (!self._requests[key]) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tself._onFailure(key, err);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tself._onSuccess(key, handler.open(urlObj.original, data, asset), extra);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tself._onFailure(key, e);\n\t\t\t\t\t}\n\t\t\t\t}, asset);\n\t\t\t};\n\n\t\t\tconst normalizedUrl = url.split('?')[0];\n\n\t\t\tif (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {\n\t\t\t\tif (!this._app.bundles.canLoadUrl(normalizedUrl)) {\n\t\t\t\t\thandleLoad(`Bundle for ${url} not loaded yet`);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {\n\t\t\t\t\thandleLoad(err, {\n\t\t\t\t\t\tload: fileUrlFromBundle,\n\t\t\t\t\t\toriginal: normalizedUrl\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\thandleLoad(null, {\n\t\t\t\t\tload: url,\n\t\t\t\t\toriginal: asset && asset.file.filename || url\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t_loadNull(handler, callback, asset) {\n\t\tconst onLoad = function onLoad(err, data, extra) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(null, handler.open(null, data, asset), extra);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\thandler.load(null, onLoad, asset);\n\t}\n\n\t_onSuccess(key, result, extra) {\n\t\tthis._cache[key] = result;\n\n\t\tfor (let i = 0; i < this._requests[key].length; i++) {\n\t\t\tthis._requests[key][i](null, result, extra);\n\t\t}\n\n\t\tdelete this._requests[key];\n\t}\n\n\t_onFailure(key, err) {\n\t\tconsole.error(err);\n\n\t\tif (this._requests[key]) {\n\t\t\tfor (let i = 0; i < this._requests[key].length; i++) {\n\t\t\t\tthis._requests[key][i](err);\n\t\t\t}\n\n\t\t\tdelete this._requests[key];\n\t\t}\n\t}\n\n\topen(type, data) {\n\t\tconst handler = this._handlers[type];\n\n\t\tif (!handler) {\n\t\t\tconsole.warn(\"No resource handler found for: \" + type);\n\t\t\treturn data;\n\t\t}\n\n\t\treturn handler.open(null, data);\n\t}\n\n\tpatch(asset, assets) {\n\t\tconst handler = this._handlers[asset.type];\n\n\t\tif (!handler) {\n\t\t\tconsole.warn(\"No resource handler found for: \" + asset.type);\n\t\t\treturn;\n\t\t}\n\n\t\tif (handler.patch) {\n\t\t\thandler.patch(asset, assets);\n\t\t}\n\t}\n\n\tclearCache(url, type) {\n\t\tdelete this._cache[url + type];\n\t}\n\n\tgetFromCache(url, type) {\n\t\tif (this._cache[url + type]) {\n\t\t\treturn this._cache[url + type];\n\t\t}\n\t}\n\n\tenableRetry(maxRetries = 5) {\n\t\tmaxRetries = Math.max(0, maxRetries) || 0;\n\n\t\tfor (const key in this._handlers) {\n\t\t\tthis._handlers[key].maxRetries = maxRetries;\n\t\t}\n\t}\n\n\tdisableRetry() {\n\t\tfor (const key in this._handlers) {\n\t\t\tthis._handlers[key].maxRetries = 0;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._handlers = {};\n\t\tthis._requests = {};\n\t\tthis._cache = {};\n\t}\n\n}\n\nclass SceneHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tSceneUtils.load(url, this.maxRetries, callback);\n\t}\n\n\topen(url, data) {\n\t\tthis._app.systems.script.preloading = true;\n\t\tconst parser = new SceneParser(this._app, false);\n\t\tconst parent = parser.parse(data);\n\t\tconst scene = this._app.scene;\n\t\tscene.root = parent;\n\n\t\tthis._app.applySceneSettings(data.settings);\n\n\t\tthis._app.systems.script.preloading = false;\n\t\treturn scene;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nlet _legacy = false;\nlet _createdLoadingScreen = false;\nconst script = {\n\tapp: null,\n\tcreate: function (name, callback) {\n\t\tif (!_legacy) return;\n\t\tconst ScriptType = callback(script.app);\n\t\tScriptType._pcScriptName = name;\n\n\t\tScriptHandler._push(ScriptType);\n\n\t\tthis.fire(\"created\", name, callback);\n\t},\n\tattribute: function (name, type, defaultValue, options) {},\n\tcreateLoadingScreen: function (callback) {\n\t\tif (_createdLoadingScreen) return;\n\t\t_createdLoadingScreen = true;\n\t\tconst app = getApplication();\n\t\tcallback(app);\n\t}\n};\nObject.defineProperty(script, 'legacy', {\n\tget: function () {\n\t\treturn _legacy;\n\t},\n\tset: function (value) {\n\t\t_legacy = value;\n\t}\n});\nevents.attach(script);\n\nclass ScriptHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis._scripts = {};\n\t\tthis._cache = {};\n\t}\n\n\tstatic _push(Type) {\n\t\tif (script.legacy && ScriptHandler._types.length > 0) {\n\t\t\tconsole.assert(\"Script Ordering Error. Contact support@playcanvas.com\");\n\t\t} else {\n\t\t\tScriptHandler._types.push(Type);\n\t\t}\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\t\tscript.app = this._app;\n\n\t\tthis._loadScript(url.load, (err, url, extra) => {\n\t\t\tif (!err) {\n\t\t\t\tif (script.legacy) {\n\t\t\t\t\tlet Type = null;\n\n\t\t\t\t\tif (ScriptHandler._types.length) {\n\t\t\t\t\t\tType = ScriptHandler._types.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Type) {\n\t\t\t\t\t\tthis._scripts[url] = Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tType = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback(null, Type, extra);\n\t\t\t\t} else {\n\t\t\t\t\tconst obj = {};\n\n\t\t\t\t\tfor (let i = 0; i < ScriptHandler._types.length; i++) obj[ScriptHandler._types[i].name] = ScriptHandler._types[i];\n\n\t\t\t\t\tScriptHandler._types.length = 0;\n\t\t\t\t\tcallback(null, obj, extra);\n\t\t\t\t\tdelete self._loader._cache[url + 'script'];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcallback(err);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n\t_loadScript(url, callback) {\n\t\tconst head = document.head;\n\t\tconst element = document.createElement('script');\n\t\tthis._cache[url] = element;\n\t\telement.async = false;\n\t\telement.addEventListener('error', function (e) {\n\t\t\tcallback(`Script: ${e.target.src} failed to load`);\n\t\t}, false);\n\t\tlet done = false;\n\n\t\telement.onload = element.onreadystatechange = function () {\n\t\t\tif (!done && (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\")) {\n\t\t\t\tdone = true;\n\t\t\t\tcallback(null, url, element);\n\t\t\t}\n\t\t};\n\n\t\telement.src = url;\n\t\thead.appendChild(element);\n\t}\n\n}\n\nScriptHandler._types = [];\n\nclass ShaderHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading shader resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nconst spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\nconst spriteIndices = [0, 1, 3, 2, 3, 1];\n\nclass Sprite extends EventHandler {\n\tconstructor(device, options) {\n\t\tsuper();\n\t\tthis._device = device;\n\t\tthis._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;\n\t\tthis._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;\n\t\tthis._atlas = options && options.atlas !== undefined ? options.atlas : null;\n\t\tthis._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;\n\t\tthis._meshes = [];\n\t\tthis._updatingProperties = false;\n\t\tthis._meshesDirty = false;\n\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tthis._createMeshes();\n\t\t}\n\t}\n\n\tset frameKeys(value) {\n\t\tthis._frameKeys = value;\n\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('set:frameKeys', value);\n\t}\n\n\tget frameKeys() {\n\t\treturn this._frameKeys;\n\t}\n\n\tset atlas(value) {\n\t\tif (value === this._atlas) return;\n\n\t\tif (this._atlas) {\n\t\t\tthis._atlas.off('set:frames', this._onSetFrames, this);\n\n\t\t\tthis._atlas.off('set:frame', this._onFrameChanged, this);\n\n\t\t\tthis._atlas.off('remove:frame', this._onFrameRemoved, this);\n\t\t}\n\n\t\tthis._atlas = value;\n\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tthis._atlas.on('set:frames', this._onSetFrames, this);\n\n\t\t\tthis._atlas.on('set:frame', this._onFrameChanged, this);\n\n\t\t\tthis._atlas.on('remove:frame', this._onFrameRemoved, this);\n\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('set:atlas', value);\n\t}\n\n\tget atlas() {\n\t\treturn this._atlas;\n\t}\n\n\tset pixelsPerUnit(value) {\n\t\tif (this._pixelsPerUnit === value) return;\n\t\tthis._pixelsPerUnit = value;\n\t\tthis.fire('set:pixelsPerUnit', value);\n\n\t\tif (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\t}\n\n\tget pixelsPerUnit() {\n\t\treturn this._pixelsPerUnit;\n\t}\n\n\tset renderMode(value) {\n\t\tif (this._renderMode === value) return;\n\t\tconst prev = this._renderMode;\n\t\tthis._renderMode = value;\n\t\tthis.fire('set:renderMode', value);\n\n\t\tif (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\tif (this._atlas && this._frameKeys) {\n\t\t\t\tif (this._updatingProperties) {\n\t\t\t\t\tthis._meshesDirty = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._createMeshes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget renderMode() {\n\t\treturn this._renderMode;\n\t}\n\n\tget meshes() {\n\t\treturn this._meshes;\n\t}\n\n\t_createMeshes() {\n\t\tconst len = this._meshes.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst mesh = this._meshes[i];\n\n\t\t\tif (mesh) {\n\t\t\t\tmesh.destroy();\n\t\t\t}\n\t\t}\n\n\t\tconst count = this._frameKeys.length;\n\t\tthis._meshes = new Array(count);\n\t\tconst createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst frame = this._atlas.frames[this._frameKeys[i]];\n\t\t\tthis._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;\n\t\t}\n\n\t\tthis.fire('set:meshes');\n\t}\n\n\t_createSimpleMesh(frame) {\n\t\tconst rect = frame.rect;\n\t\tconst texWidth = this._atlas.texture.width;\n\t\tconst texHeight = this._atlas.texture.height;\n\t\tconst w = rect.z / this._pixelsPerUnit;\n\t\tconst h = rect.w / this._pixelsPerUnit;\n\t\tconst hp = frame.pivot.x;\n\t\tconst vp = frame.pivot.y;\n\t\tconst positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];\n\t\tconst lu = rect.x / texWidth;\n\t\tconst bv = 1.0 - rect.y / texHeight;\n\t\tconst ru = (rect.x + rect.z) / texWidth;\n\t\tconst tv = 1.0 - (rect.y + rect.w) / texHeight;\n\t\tconst uvs = [lu, bv, ru, bv, ru, tv, lu, tv];\n\t\tconst mesh = createMesh$1(this._device, positions, {\n\t\t\tuvs: uvs,\n\t\t\tnormals: spriteNormals,\n\t\t\tindices: spriteIndices\n\t\t});\n\t\treturn mesh;\n\t}\n\n\t_create9SliceMesh() {\n\t\tconst he = Vec2.ONE;\n\t\tconst ws = 3;\n\t\tconst ls = 3;\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\t\tlet vcounter = 0;\n\n\t\tfor (let i = 0; i <= ws; i++) {\n\t\t\tconst u = i === 0 || i === ws ? 0 : 1;\n\n\t\t\tfor (let j = 0; j <= ls; j++) {\n\t\t\t\tconst x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;\n\t\t\t\tconst y = 0.0;\n\t\t\t\tconst z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);\n\t\t\t\tconst v = j === 0 || j === ls ? 0 : 1;\n\t\t\t\tpositions.push(-x, y, z);\n\t\t\t\tnormals.push(0.0, 1.0, 0.0);\n\t\t\t\tuvs.push(u, v);\n\n\t\t\t\tif (i < ws && j < ls) {\n\t\t\t\t\tindices.push(vcounter + ls + 1, vcounter + 1, vcounter);\n\t\t\t\t\tindices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);\n\t\t\t\t}\n\n\t\t\t\tvcounter++;\n\t\t\t}\n\t\t}\n\n\t\tconst options = {\n\t\t\tnormals: normals,\n\t\t\tuvs: uvs,\n\t\t\tindices: indices\n\t\t};\n\t\treturn createMesh$1(this._device, positions, options);\n\t}\n\n\t_onSetFrames(frames) {\n\t\tif (this._updatingProperties) {\n\t\t\tthis._meshesDirty = true;\n\t\t} else {\n\t\t\tthis._createMeshes();\n\t\t}\n\t}\n\n\t_onFrameChanged(frameKey, frame) {\n\t\tconst idx = this._frameKeys.indexOf(frameKey);\n\n\t\tif (idx < 0) return;\n\n\t\tif (frame) {\n\t\t\tif (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\t\tthis._meshes[idx] = this._createSimpleMesh(frame);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._meshes[idx] = null;\n\t\t}\n\n\t\tthis.fire('set:meshes');\n\t}\n\n\t_onFrameRemoved(frameKey) {\n\t\tconst idx = this._frameKeys.indexOf(frameKey);\n\n\t\tif (idx < 0) return;\n\t\tthis._meshes[idx] = null;\n\t\tthis.fire('set:meshes');\n\t}\n\n\tstartUpdate() {\n\t\tthis._updatingProperties = true;\n\t\tthis._meshesDirty = false;\n\t}\n\n\tendUpdate() {\n\t\tthis._updatingProperties = false;\n\n\t\tif (this._meshesDirty && this._atlas && this._frameKeys) {\n\t\t\tthis._createMeshes();\n\t\t}\n\n\t\tthis._meshesDirty = false;\n\t}\n\n\tdestroy() {\n\t\tfor (const mesh of this._meshes) {\n\t\t\tif (mesh) mesh.destroy();\n\t\t}\n\n\t\tthis._meshes.length = 0;\n\t}\n\n}\n\nfunction onTextureAtlasLoaded(atlasAsset) {\n\tconst spriteAsset = this;\n\n\tif (spriteAsset.resource) {\n\t\tspriteAsset.resource.atlas = atlasAsset.resource;\n\t}\n}\n\nfunction onTextureAtlasAdded(atlasAsset) {\n\tconst spriteAsset = this;\n\tspriteAsset.registry.load(atlasAsset);\n}\n\nclass SpriteHandler {\n\tconstructor(assets, device) {\n\t\tthis._assets = assets;\n\t\tthis._device = device;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, function (err, response) {\n\t\t\t\tif (!err) {\n\t\t\t\t\tcallback(null, response);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\topen(url, data) {\n\t\tconst sprite = new Sprite(this._device);\n\n\t\tif (url) {\n\t\t\tsprite.__data = data;\n\t\t}\n\n\t\treturn sprite;\n\t}\n\n\tpatch(asset, assets) {\n\t\tconst sprite = asset.resource;\n\n\t\tif (sprite.__data) {\n\t\t\tasset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;\n\t\t\tasset.data.renderMode = sprite.__data.renderMode;\n\t\t\tasset.data.frameKeys = sprite.__data.frameKeys;\n\n\t\t\tif (sprite.__data.textureAtlasAsset) {\n\t\t\t\tconst atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);\n\n\t\t\t\tif (atlas) {\n\t\t\t\t\tasset.data.textureAtlasAsset = atlas.id;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(\"Could not find textureatlas with url: \" + sprite.__data.textureAtlasAsset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsprite.startUpdate();\n\t\tsprite.renderMode = asset.data.renderMode;\n\t\tsprite.pixelsPerUnit = asset.data.pixelsPerUnit;\n\t\tsprite.frameKeys = asset.data.frameKeys;\n\n\t\tthis._updateAtlas(asset);\n\n\t\tsprite.endUpdate();\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t}\n\n\t_updateAtlas(asset) {\n\t\tconst sprite = asset.resource;\n\n\t\tif (!asset.data.textureAtlasAsset) {\n\t\t\tsprite.atlas = null;\n\t\t\treturn;\n\t\t}\n\n\t\tthis._assets.off('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);\n\n\t\tthis._assets.on('load:' + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);\n\n\t\tconst atlasAsset = this._assets.get(asset.data.textureAtlasAsset);\n\n\t\tif (atlasAsset && atlasAsset.resource) {\n\t\t\tsprite.atlas = atlasAsset.resource;\n\t\t} else {\n\t\t\tif (!atlasAsset) {\n\t\t\t\tthis._assets.off('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);\n\n\t\t\t\tthis._assets.on('add:' + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);\n\t\t\t} else {\n\t\t\t\tthis._assets.load(atlasAsset);\n\t\t\t}\n\t\t}\n\t}\n\n\t_onAssetChange(asset, attribute, value, oldValue) {\n\t\tif (attribute === 'data') {\n\t\t\tif (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {\n\t\t\t\tthis._assets.off('load:' + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);\n\n\t\t\t\tthis._assets.off('add:' + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass Template {\n\tconstructor(app, data) {\n\t\tthis._app = app;\n\t\tthis._data = data;\n\t\tthis._templateRoot = null;\n\t}\n\n\tinstantiate() {\n\t\tif (!this._templateRoot) {\n\t\t\tthis._parseTemplate();\n\t\t}\n\n\t\treturn this._templateRoot.clone();\n\t}\n\n\t_parseTemplate() {\n\t\tconst parser = new SceneParser(this._app, true);\n\t\tthis._templateRoot = parser.parse(this._data);\n\t}\n\n}\n\nclass TemplateHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\thttp.get(url.load, options, function (err, response) {\n\t\t\tif (err) {\n\t\t\t\tcallback(\"Error requesting template: \" + url.original);\n\t\t\t} else {\n\t\t\t\tcallback(err, response);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn new Template(this._app, data);\n\t}\n\n}\n\nclass TextHandler {\n\tconstructor() {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, function (err, response) {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading text resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\n\topen(url, data) {\n\t\treturn data;\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass TextureAtlas extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._texture = null;\n\t\tthis._frames = null;\n\t}\n\n\tset texture(value) {\n\t\tthis._texture = value;\n\t\tthis.fire('set:texture', value);\n\t}\n\n\tget texture() {\n\t\treturn this._texture;\n\t}\n\n\tset frames(value) {\n\t\tthis._frames = value;\n\t\tthis.fire('set:frames', value);\n\t}\n\n\tget frames() {\n\t\treturn this._frames;\n\t}\n\n\tsetFrame(key, data) {\n\t\tlet frame = this._frames[key];\n\n\t\tif (!frame) {\n\t\t\tframe = {\n\t\t\t\trect: data.rect.clone(),\n\t\t\t\tpivot: data.pivot.clone(),\n\t\t\t\tborder: data.border.clone()\n\t\t\t};\n\t\t\tthis._frames[key] = frame;\n\t\t} else {\n\t\t\tframe.rect.copy(data.rect);\n\t\t\tframe.pivot.copy(data.pivot);\n\t\t\tframe.border.copy(data.border);\n\t\t}\n\n\t\tthis.fire('set:frame', key.toString(), frame);\n\t}\n\n\tremoveFrame(key) {\n\t\tconst frame = this._frames[key];\n\n\t\tif (frame) {\n\t\t\tdelete this._frames[key];\n\t\t\tthis.fire('remove:frame', key.toString(), frame);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this._texture) {\n\t\t\tthis._texture.destroy();\n\t\t}\n\t}\n\n}\n\nconst JSON_ADDRESS_MODE$1 = {\n\t\"repeat\": ADDRESS_REPEAT,\n\t\"clamp\": ADDRESS_CLAMP_TO_EDGE,\n\t\"mirror\": ADDRESS_MIRRORED_REPEAT\n};\nconst JSON_FILTER_MODE$1 = {\n\t\"nearest\": FILTER_NEAREST,\n\t\"linear\": FILTER_LINEAR,\n\t\"nearest_mip_nearest\": FILTER_NEAREST_MIPMAP_NEAREST,\n\t\"linear_mip_nearest\": FILTER_LINEAR_MIPMAP_NEAREST,\n\t\"nearest_mip_linear\": FILTER_NEAREST_MIPMAP_LINEAR,\n\t\"linear_mip_linear\": FILTER_LINEAR_MIPMAP_LINEAR\n};\nconst regexFrame = /^data\\.frames\\.(\\d+)$/;\n\nclass TextureAtlasHandler {\n\tconstructor(loader) {\n\t\tthis._loader = loader;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tconst self = this;\n\n\t\tconst handler = this._loader.getHandler(\"texture\");\n\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, function (err, response) {\n\t\t\t\tif (!err) {\n\t\t\t\t\tconst textureUrl = url.original.replace('.json', '.png');\n\n\t\t\t\t\tself._loader.load(textureUrl, \"texture\", function (err, texture) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\tdata: response,\n\t\t\t\t\t\t\t\ttexture: texture\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn handler.load(url, callback);\n\t\t}\n\t}\n\n\topen(url, data) {\n\t\tconst resource = new TextureAtlas();\n\n\t\tif (data.texture && data.data) {\n\t\t\tresource.texture = data.texture;\n\t\t\tresource.__data = data.data;\n\t\t} else {\n\t\t\tconst handler = this._loader.getHandler(\"texture\");\n\n\t\t\tconst texture = handler.open(url, data);\n\t\t\tif (!texture) return null;\n\t\t\tresource.texture = texture;\n\t\t}\n\n\t\treturn resource;\n\t}\n\n\tpatch(asset, assets) {\n\t\tif (asset.resource.__data) {\n\t\t\tif (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;\n\t\t\tif (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;\n\t\t\tif (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;\n\t\t\tif (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;\n\t\t\tif (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;\n\t\t\tif (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;\n\t\t\tif (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;\n\t\t\tasset.data.frames = asset.resource.__data.frames;\n\t\t\tdelete asset.resource.__data;\n\t\t}\n\n\t\tconst texture = asset.resource.texture;\n\n\t\tif (texture) {\n\t\t\ttexture.name = asset.name;\n\t\t\tif (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];\n\t\t\tif (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];\n\t\t\tif (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];\n\t\t\tif (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];\n\t\t\tif (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) texture.mipmaps = asset.data.mipmaps;\n\t\t\tif (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) texture.anisotropy = asset.data.anisotropy;\n\n\t\t\tif (asset.data.hasOwnProperty('rgbm')) {\n\t\t\t\tconst type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\n\t\t\t\tif (texture.type !== type) {\n\t\t\t\t\ttexture.type = type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasset.resource.texture = texture;\n\t\tconst frames = {};\n\n\t\tfor (const key in asset.data.frames) {\n\t\t\tconst frame = asset.data.frames[key];\n\t\t\tframes[key] = {\n\t\t\t\trect: new Vec4(frame.rect),\n\t\t\t\tpivot: new Vec2(frame.pivot),\n\t\t\t\tborder: new Vec4(frame.border)\n\t\t\t};\n\t\t}\n\n\t\tasset.resource.frames = frames;\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t}\n\n\t_onAssetChange(asset, attribute, value) {\n\t\tlet frame;\n\n\t\tif (attribute === 'data' || attribute === 'data.frames') {\n\t\t\tconst frames = {};\n\n\t\t\tfor (const key in value.frames) {\n\t\t\t\tframe = value.frames[key];\n\t\t\t\tframes[key] = {\n\t\t\t\t\trect: new Vec4(frame.rect),\n\t\t\t\t\tpivot: new Vec2(frame.pivot),\n\t\t\t\t\tborder: new Vec4(frame.border)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tasset.resource.frames = frames;\n\t\t} else {\n\t\t\tconst match = attribute.match(regexFrame);\n\n\t\t\tif (match) {\n\t\t\t\tconst frameKey = match[1];\n\n\t\t\t\tif (value) {\n\t\t\t\t\tif (!asset.resource.frames[frameKey]) {\n\t\t\t\t\t\tasset.resource.frames[frameKey] = {\n\t\t\t\t\t\t\trect: new Vec4(value.rect),\n\t\t\t\t\t\t\tpivot: new Vec2(value.pivot),\n\t\t\t\t\t\t\tborder: new Vec4(value.border)\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tframe = asset.resource.frames[frameKey];\n\t\t\t\t\t\tframe.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);\n\t\t\t\t\t\tframe.pivot.set(value.pivot[0], value.pivot[1]);\n\t\t\t\t\t\tframe.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);\n\t\t\t\t\t}\n\n\t\t\t\t\tasset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);\n\t\t\t\t} else {\n\t\t\t\t\tif (asset.resource.frames[frameKey]) {\n\t\t\t\t\t\tdelete asset.resource.frames[frameKey];\n\t\t\t\t\t\tasset.resource.fire('remove:frame', frameKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunction BasisWorker() {\n\tconst BASIS_FORMAT = {\n\t\tcTFETC1: 0,\n\t\tcTFETC2: 1,\n\t\tcTFBC1: 2,\n\t\tcTFBC3: 3,\n\t\tcTFPVRTC1_4_RGB: 8,\n\t\tcTFPVRTC1_4_RGBA: 9,\n\t\tcTFASTC_4x4: 10,\n\t\tcTFATC_RGB: 11,\n\t\tcTFATC_RGBA_INTERPOLATED_ALPHA: 12,\n\t\tcTFRGBA32: 13,\n\t\tcTFRGB565: 14,\n\t\tcTFRGBA4444: 16\n\t};\n\tconst opaqueMapping = {\n\t\tastc: BASIS_FORMAT.cTFASTC_4x4,\n\t\tdxt: BASIS_FORMAT.cTFBC1,\n\t\tetc1: BASIS_FORMAT.cTFETC1,\n\t\tetc2: BASIS_FORMAT.cTFETC1,\n\t\tpvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,\n\t\tatc: BASIS_FORMAT.cTFATC_RGB,\n\t\tnone: BASIS_FORMAT.cTFRGB565\n\t};\n\tconst alphaMapping = {\n\t\tastc: BASIS_FORMAT.cTFASTC_4x4,\n\t\tdxt: BASIS_FORMAT.cTFBC3,\n\t\tetc1: BASIS_FORMAT.cTFRGBA4444,\n\t\tetc2: BASIS_FORMAT.cTFETC2,\n\t\tpvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,\n\t\tatc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,\n\t\tnone: BASIS_FORMAT.cTFRGBA4444\n\t};\n\tconst PIXEL_FORMAT = {\n\t\tETC1: 21,\n\t\tETC2_RGB: 22,\n\t\tETC2_RGBA: 23,\n\t\tDXT1: 8,\n\t\tDXT5: 10,\n\t\tPVRTC_4BPP_RGB_1: 26,\n\t\tPVRTC_4BPP_RGBA_1: 27,\n\t\tASTC_4x4: 28,\n\t\tATC_RGB: 29,\n\t\tATC_RGBA: 30,\n\t\tR8_G8_B8_A8: 7,\n\t\tR5_G6_B5: 3,\n\t\tR4_G4_B4_A4: 5\n\t};\n\n\tconst basisToEngineMapping = (basisFormat, deviceDetails) => {\n\t\tswitch (basisFormat) {\n\t\t\tcase BASIS_FORMAT.cTFETC1:\n\t\t\t\treturn deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;\n\n\t\t\tcase BASIS_FORMAT.cTFETC2:\n\t\t\t\treturn PIXEL_FORMAT.ETC2_RGBA;\n\n\t\t\tcase BASIS_FORMAT.cTFBC1:\n\t\t\t\treturn PIXEL_FORMAT.DXT1;\n\n\t\t\tcase BASIS_FORMAT.cTFBC3:\n\t\t\t\treturn PIXEL_FORMAT.DXT5;\n\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGB:\n\t\t\t\treturn PIXEL_FORMAT.PVRTC_4BPP_RGB_1;\n\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGBA:\n\t\t\t\treturn PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;\n\n\t\t\tcase BASIS_FORMAT.cTFASTC_4x4:\n\t\t\t\treturn PIXEL_FORMAT.ASTC_4x4;\n\n\t\t\tcase BASIS_FORMAT.cTFATC_RGB:\n\t\t\t\treturn PIXEL_FORMAT.ATC_RGB;\n\n\t\t\tcase BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:\n\t\t\t\treturn PIXEL_FORMAT.ATC_RGBA;\n\n\t\t\tcase BASIS_FORMAT.cTFRGBA32:\n\t\t\t\treturn PIXEL_FORMAT.R8_G8_B8_A8;\n\n\t\t\tcase BASIS_FORMAT.cTFRGB565:\n\t\t\t\treturn PIXEL_FORMAT.R5_G6_B5;\n\n\t\t\tcase BASIS_FORMAT.cTFRGBA4444:\n\t\t\t\treturn PIXEL_FORMAT.R4_G4_B4_A4;\n\t\t}\n\t};\n\n\tconst unswizzleGGGR = data => {\n\t\tconst genB = function genB(R, G) {\n\t\t\tconst r = R * (2.0 / 255.0) - 1.0;\n\t\t\tconst g = G * (2.0 / 255.0) - 1.0;\n\t\t\tconst b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));\n\t\t\treturn Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));\n\t\t};\n\n\t\tfor (let offset = 0; offset < data.length; offset += 4) {\n\t\t\tconst R = data[offset + 3];\n\t\t\tconst G = data[offset + 1];\n\t\t\tdata[offset + 0] = R;\n\t\t\tdata[offset + 2] = genB(R, G);\n\t\t\tdata[offset + 3] = 255;\n\t\t}\n\n\t\treturn data;\n\t};\n\n\tconst pack565 = data => {\n\t\tconst result = new Uint16Array(data.length / 4);\n\n\t\tfor (let offset = 0; offset < data.length; offset += 4) {\n\t\t\tconst R = data[offset + 0];\n\t\t\tconst G = data[offset + 1];\n\t\t\tconst B = data[offset + 2];\n\t\t\tresult[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tconst isPOT = (width, height) => {\n\t\treturn (width & width - 1) === 0 && (height & height - 1) === 0;\n\t};\n\n\tconst performanceNow = () => {\n\t\treturn typeof performance !== 'undefined' ? performance.now() : 0;\n\t};\n\n\tlet basis;\n\tlet rgbPriority;\n\tlet rgbaPriority;\n\n\tconst chooseTargetFormat = (deviceDetails, hasAlpha, isUASTC) => {\n\t\tif (isUASTC) {\n\t\t\tif (deviceDetails.formats.astc) {\n\t\t\t\treturn 'astc';\n\t\t\t}\n\t\t} else {\n\t\t\tif (hasAlpha) {\n\t\t\t\tif (deviceDetails.formats.etc2) {\n\t\t\t\t\treturn 'etc2';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {\n\t\t\t\t\treturn 'etc1';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst testInOrder = priority => {\n\t\t\tfor (let i = 0; i < priority.length; ++i) {\n\t\t\t\tconst format = priority[i];\n\n\t\t\t\tif (deviceDetails.formats[format]) {\n\t\t\t\t\treturn format;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'none';\n\t\t};\n\n\t\treturn testInOrder(hasAlpha ? rgbaPriority : rgbPriority);\n\t};\n\n\tconst dimensionsValid = (width, height, format, webgl2) => {\n\t\tswitch (format) {\n\t\t\tcase BASIS_FORMAT.cTFETC1:\n\t\t\tcase BASIS_FORMAT.cTFETC2:\n\t\t\t\treturn true;\n\n\t\t\tcase BASIS_FORMAT.cTFBC1:\n\t\t\tcase BASIS_FORMAT.cTFBC3:\n\t\t\t\treturn (width & 0x3) === 0 && (height & 0x3) === 0;\n\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGB:\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGBA:\n\t\t\t\treturn isPOT(width, height) && (width === height || webgl2);\n\n\t\t\tcase BASIS_FORMAT.cTFASTC_4x4:\n\t\t\t\treturn true;\n\n\t\t\tcase BASIS_FORMAT.cTFATC_RGB:\n\t\t\tcase BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:\n\t\t\t\treturn true;\n\t\t}\n\t};\n\n\tconst transcodeKTX2 = (url, data, options) => {\n\t\tif (!basis.KTX2File) {\n\t\t\tthrow new Error('Basis transcoder module does not include support for KTX2.');\n\t\t}\n\n\t\tconst funcStart = performanceNow();\n\t\tconst basisFile = new basis.KTX2File(new Uint8Array(data));\n\t\tconst width = basisFile.getWidth();\n\t\tconst height = basisFile.getHeight();\n\t\tconst levels = basisFile.getLevels();\n\t\tconst hasAlpha = !!basisFile.getHasAlpha();\n\t\tconst isUASTC = basisFile.isUASTC && basisFile.isUASTC();\n\n\t\tif (!width || !height || !levels) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error(`Invalid image dimensions url=${url} width=${width} height=${height} levels=${levels}`);\n\t\t}\n\n\t\tconst format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);\n\t\tconst unswizzle = !!options.isGGGR && format === 'pvr';\n\t\tlet basisFormat;\n\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGBA32;\n\t\t} else {\n\t\t\tbasisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];\n\n\t\t\tif (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {\n\t\t\t\tbasisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;\n\t\t\t}\n\t\t}\n\n\t\tif (!basisFile.startTranscoding()) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error('Failed to start transcoding url=' + url);\n\t\t}\n\n\t\tlet i;\n\t\tconst levelData = [];\n\n\t\tfor (let mip = 0; mip < levels; ++mip) {\n\t\t\tconst dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);\n\t\t\tconst dst = new Uint8Array(dstSize);\n\n\t\t\tif (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {\n\t\t\t\tbasisFile.close();\n\t\t\t\tbasisFile.delete();\n\t\t\t\tthrow new Error('Failed to transcode image url=' + url);\n\t\t\t}\n\n\t\t\tconst is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;\n\t\t\tlevelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);\n\t\t}\n\n\t\tbasisFile.close();\n\t\tbasisFile.delete();\n\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGB565;\n\n\t\t\tfor (i = 0; i < levelData.length; ++i) {\n\t\t\t\tlevelData[i] = pack565(unswizzleGGGR(levelData[i]));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tformat: basisToEngineMapping(basisFormat, options.deviceDetails),\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: levelData,\n\t\t\tcubemap: false,\n\t\t\ttranscodeTime: performanceNow() - funcStart,\n\t\t\turl: url,\n\t\t\tunswizzledGGGR: unswizzle\n\t\t};\n\t};\n\n\tconst transcodeBasis = (url, data, options) => {\n\t\tconst funcStart = performanceNow();\n\t\tconst basisFile = new basis.BasisFile(new Uint8Array(data));\n\t\tconst width = basisFile.getImageWidth(0, 0);\n\t\tconst height = basisFile.getImageHeight(0, 0);\n\t\tconst images = basisFile.getNumImages();\n\t\tconst levels = basisFile.getNumLevels(0);\n\t\tconst hasAlpha = !!basisFile.getHasAlpha();\n\t\tconst isUASTC = basisFile.isUASTC && basisFile.isUASTC();\n\n\t\tif (!width || !height || !images || !levels) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error(`Invalid image dimensions url=${url} width=${width} height=${height} images=${images} levels=${levels}`);\n\t\t}\n\n\t\tconst format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);\n\t\tconst unswizzle = !!options.isGGGR && format === 'pvr';\n\t\tlet basisFormat;\n\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGBA32;\n\t\t} else {\n\t\t\tbasisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];\n\n\t\t\tif (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {\n\t\t\t\tbasisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;\n\t\t\t}\n\t\t}\n\n\t\tif (!basisFile.startTranscoding()) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error('Failed to start transcoding url=' + url);\n\t\t}\n\n\t\tlet i;\n\t\tconst levelData = [];\n\n\t\tfor (let mip = 0; mip < levels; ++mip) {\n\t\t\tconst dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);\n\t\t\tconst dst = new Uint8Array(dstSize);\n\n\t\t\tif (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {\n\t\t\t\tbasisFile.close();\n\t\t\t\tbasisFile.delete();\n\t\t\t\tthrow new Error('Failed to transcode image url=' + url);\n\t\t\t}\n\n\t\t\tconst is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;\n\t\t\tlevelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);\n\t\t}\n\n\t\tbasisFile.close();\n\t\tbasisFile.delete();\n\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGB565;\n\n\t\t\tfor (i = 0; i < levelData.length; ++i) {\n\t\t\t\tlevelData[i] = pack565(unswizzleGGGR(levelData[i]));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tformat: basisToEngineMapping(basisFormat, options.deviceDetails),\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: levelData,\n\t\t\tcubemap: false,\n\t\t\ttranscodeTime: performanceNow() - funcStart,\n\t\t\turl: url,\n\t\t\tunswizzledGGGR: unswizzle\n\t\t};\n\t};\n\n\tconst transcode = (url, data, options) => {\n\t\treturn options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);\n\t};\n\n\tconst workerTranscode = (url, data, options) => {\n\t\ttry {\n\t\t\tconst result = transcode(url, data, options);\n\t\t\tresult.levels = result.levels.map(v => v.buffer);\n\t\t\tself.postMessage({\n\t\t\t\turl: url,\n\t\t\t\tdata: result\n\t\t\t}, result.levels);\n\t\t} catch (err) {\n\t\t\tself.postMessage({\n\t\t\t\turl: url,\n\t\t\t\terr: err\n\t\t\t}, null);\n\t\t}\n\t};\n\n\tconst workerInit = (config, callback) => {\n\t\tself.importScripts(config.basisUrl);\n\n\t\tconst instantiateWasmFunc = (imports, successCallback) => {\n\t\t\tWebAssembly.instantiate(config.module, imports).then(result => {\n\t\t\t\tsuccessCallback(result);\n\t\t\t}).catch(reason => {\n\t\t\t\tconsole.error('instantiate failed + ' + reason);\n\t\t\t});\n\t\t\treturn {};\n\t\t};\n\n\t\tself.BASIS(config.module ? {\n\t\t\tinstantiateWasm: instantiateWasmFunc\n\t\t} : null).then(instance => {\n\t\t\tinstance.initializeBasis();\n\t\t\tbasis = instance;\n\t\t\trgbPriority = config.rgbPriority;\n\t\t\trgbaPriority = config.rgbaPriority;\n\t\t\tcallback(null);\n\t\t});\n\t};\n\n\tconst queue = [];\n\n\tself.onmessage = message => {\n\t\tconst data = message.data;\n\n\t\tswitch (data.type) {\n\t\t\tcase 'init':\n\t\t\t\tworkerInit(data.config, () => {\n\t\t\t\t\tfor (let i = 0; i < queue.length; ++i) {\n\t\t\t\t\t\tworkerTranscode(queue[i].url, queue[i].data, queue[i].options);\n\t\t\t\t\t}\n\n\t\t\t\t\tqueue.length = 0;\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\tcase 'transcode':\n\t\t\t\tif (basis) {\n\t\t\t\t\tworkerTranscode(data.url, data.data, data.options);\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(data);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\nconst getCompressionFormats = device => {\n\treturn {\n\t\tastc: !!device.extCompressedTextureASTC,\n\t\tatc: !!device.extCompressedTextureATC,\n\t\tdxt: !!device.extCompressedTextureS3TC,\n\t\tetc1: !!device.extCompressedTextureETC1,\n\t\tetc2: !!device.extCompressedTextureETC,\n\t\tpvr: !!device.extCompressedTexturePVRTC\n\t};\n};\n\nconst prepareWorkerModules = (config, callback) => {\n\tconst getWorkerBlob = () => {\n\t\tconst code = '(' + BasisWorker.toString() + ')()\\n\\n';\n\t\treturn new Blob([code], {\n\t\t\ttype: 'application/javascript'\n\t\t});\n\t};\n\n\tconst wasmSupported = () => {\n\t\ttry {\n\t\t\tif (typeof WebAssembly === \"object\" && typeof WebAssembly.instantiate === \"function\") {\n\t\t\t\tconst module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));\n\t\t\t\tif (module instanceof WebAssembly.Module) return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\n\t\t\t}\n\t\t} catch (e) {}\n\n\t\treturn false;\n\t};\n\n\tconst sendResponse = (basisCode, module) => {\n\t\tcallback(null, {\n\t\t\tworkerUrl: URL.createObjectURL(getWorkerBlob()),\n\t\t\tbasisUrl: URL.createObjectURL(basisCode),\n\t\t\tmodule: module,\n\t\t\trgbPriority: config.rgbPriority,\n\t\t\trgbaPriority: config.rgbaPriority\n\t\t});\n\t};\n\n\tif (config.glueUrl && config.wasmUrl && wasmSupported()) {\n\t\tlet basisCode = null;\n\t\tlet module = null;\n\t\thttp.get(config.glueUrl, {\n\t\t\tresponseType: 'blob'\n\t\t}, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tif (module) {\n\t\t\t\t\tsendResponse(response, module);\n\t\t\t\t} else {\n\t\t\t\t\tbasisCode = response;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tconst fetchPromise = fetch(config.wasmUrl);\n\n\t\tconst compileManual = () => {\n\t\t\tfetchPromise.then(result => result.arrayBuffer()).then(buffer => WebAssembly.compile(buffer)).then(module_ => {\n\t\t\t\tif (basisCode) {\n\t\t\t\t\tsendResponse(basisCode, module_);\n\t\t\t\t} else {\n\t\t\t\t\tmodule = module_;\n\t\t\t\t}\n\t\t\t}).catch(err => {\n\t\t\t\tcallback(err, null);\n\t\t\t});\n\t\t};\n\n\t\tif (WebAssembly.compileStreaming) {\n\t\t\tWebAssembly.compileStreaming(fetchPromise).then(module_ => {\n\t\t\t\tif (basisCode) {\n\t\t\t\t\tsendResponse(basisCode, module_);\n\t\t\t\t} else {\n\t\t\t\t\tmodule = module_;\n\t\t\t\t}\n\t\t\t}).catch(err => {\n\t\t\t\tcompileManual();\n\t\t\t});\n\t\t} else {\n\t\t\tcompileManual();\n\t\t}\n\t} else {\n\t\thttp.get(config.fallbackUrl, {\n\t\t\tresponseType: 'blob'\n\t\t}, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err, null);\n\t\t\t} else {\n\t\t\t\tsendResponse(response, null);\n\t\t\t}\n\t\t});\n\t}\n};\n\nclass BasisQueue {\n\tconstructor() {\n\t\tthis.callbacks = {};\n\t\tthis.queue = [];\n\t\tthis.clients = [];\n\t}\n\n\tenqueueJob(url, data, callback, options) {\n\t\tif (this.callbacks.hasOwnProperty(url)) {\n\t\t\tthis.callbacks[url].push(callback);\n\t\t} else {\n\t\t\tthis.callbacks[url] = [callback];\n\t\t\tconst job = {\n\t\t\t\turl: url,\n\t\t\t\tdata: data,\n\t\t\t\toptions: options\n\t\t\t};\n\n\t\t\tif (this.clients.length > 0) {\n\t\t\t\tthis.clients.shift().run(job);\n\t\t\t} else {\n\t\t\t\tthis.queue.push(job);\n\t\t\t}\n\t\t}\n\t}\n\n\tenqueueClient(client) {\n\t\tif (this.queue.length > 0) {\n\t\t\tclient.run(this.queue.shift());\n\t\t} else {\n\t\t\tthis.clients.push(client);\n\t\t}\n\t}\n\n\thandleResponse(url, err, data) {\n\t\tconst callback = this.callbacks[url];\n\n\t\tif (err) {\n\t\t\tfor (let i = 0; i < callback.length; ++i) {\n\t\t\t\tcallback[i](err);\n\t\t\t}\n\t\t} else {\n\t\t\tif (data.format === PIXELFORMAT_R5_G6_B5 || data.format === PIXELFORMAT_R4_G4_B4_A4) {\n\t\t\t\tdata.levels = data.levels.map(function (v) {\n\t\t\t\t\treturn new Uint16Array(v);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdata.levels = data.levels.map(function (v) {\n\t\t\t\t\treturn new Uint8Array(v);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < callback.length; ++i) {\n\t\t\t\tcallback[i](null, data);\n\t\t\t}\n\t\t}\n\n\t\tdelete this.callbacks[url];\n\t}\n\n}\n\nclass BasisClient {\n\tconstructor(queue, config, eager) {\n\t\tthis.queue = queue;\n\t\tthis.worker = new Worker(config.workerUrl);\n\t\tthis.worker.addEventListener('message', message => {\n\t\t\tconst data = message.data;\n\t\t\tthis.queue.handleResponse(data.url, data.err, data.data);\n\n\t\t\tif (!this.eager) {\n\t\t\t\tthis.queue.enqueueClient(this);\n\t\t\t}\n\t\t});\n\t\tthis.worker.postMessage({\n\t\t\ttype: 'init',\n\t\t\tconfig: config\n\t\t});\n\t\tthis.eager = eager;\n\t}\n\n\trun(job) {\n\t\tconst transfer = [];\n\n\t\tif (job.data instanceof ArrayBuffer) {\n\t\t\ttransfer.push(job.data);\n\t\t}\n\n\t\tthis.worker.postMessage({\n\t\t\ttype: 'transcode',\n\t\t\turl: job.url,\n\t\t\tformat: job.format,\n\t\t\tdata: job.data,\n\t\t\toptions: job.options\n\t\t}, transfer);\n\n\t\tif (this.eager) {\n\t\t\tthis.queue.enqueueClient(this);\n\t\t}\n\t}\n\n}\n\nconst defaultNumWorkers = 1;\nconst defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];\nconst defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];\nconst queue = new BasisQueue();\nlet lazyConfig = null;\nlet initializing = false;\n\nfunction basisInitialize(config) {\n\tif (initializing) {\n\t\treturn;\n\t}\n\n\tif (!config) {\n\t\tconfig = lazyConfig || {};\n\t} else if (config.lazyInit) {\n\t\tlazyConfig = config;\n\t\treturn;\n\t}\n\n\tif (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {\n\t\tconst modules = (window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || [];\n\t\tconst wasmModule = modules.find(function (m) {\n\t\t\treturn m.moduleName === 'BASIS';\n\t\t});\n\n\t\tif (wasmModule) {\n\t\t\tconst urlBase = window.ASSET_PREFIX || \"\";\n\n\t\t\tif (!config.glueUrl) {\n\t\t\t\tconfig.glueUrl = urlBase + wasmModule.glueUrl;\n\t\t\t}\n\n\t\t\tif (!config.wasmUrl) {\n\t\t\t\tconfig.wasmUrl = urlBase + wasmModule.wasmUrl;\n\t\t\t}\n\n\t\t\tif (!config.fallbackUrl) {\n\t\t\t\tconfig.fallbackUrl = urlBase + wasmModule.fallbackUrl;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (config.glueUrl || config.wasmUrl || config.fallbackUrl) {\n\t\tinitializing = true;\n\t\tconst numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));\n\t\tconst eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);\n\t\tconfig.rgbPriority = config.rgbPriority || defaultRgbPriority;\n\t\tconfig.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;\n\t\tprepareWorkerModules(config, (err, clientConfig) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(`failed to initialize basis worker: ${err}`);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < numWorkers; ++i) {\n\t\t\t\t\tqueue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nlet deviceDetails = null;\n\nfunction basisTranscode(device, url, data, callback, options) {\n\tbasisInitialize();\n\n\tif (!deviceDetails) {\n\t\tdeviceDetails = {\n\t\t\twebgl2: device.webgl2,\n\t\t\tformats: getCompressionFormats(device)\n\t\t};\n\t}\n\n\tqueue.enqueueJob(url, data, callback, {\n\t\tdeviceDetails: deviceDetails,\n\t\tisGGGR: !!(options != null && options.isGGGR),\n\t\tisKTX2: !!(options != null && options.isKTX2)\n\t});\n\treturn initializing;\n}\n\nclass BasisParser {\n\tconstructor(registry, device) {\n\t\tthis.device = device;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tconst device = this.device;\n\n\t\tconst transcode = data => {\n\t\t\tvar _asset$file, _asset$file$variants, _asset$file$variants$;\n\n\t\t\tconst basisModuleFound = basisTranscode(device, url.load, data, callback, {\n\t\t\t\tisGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0\n\t\t\t});\n\n\t\t\tif (!basisModuleFound) {\n\t\t\t\tcallback(`Basis module not found. Asset '${asset.name}' basis texture variant will not be loaded.`);\n\t\t\t}\n\t\t};\n\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\ttranscode(result);\n\t\t\t}\n\t\t}, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: data.format,\n\t\t\tcubemap: data.cubemap,\n\t\t\tlevels: data.levels\n\t\t});\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n}\n\nclass ImgParser {\n\tconstructor(registry) {\n\t\tthis.crossOrigin = registry.prefix ? 'anonymous' : null;\n\t\tthis.maxRetries = 0;\n\t\tthis.useImageBitmap = false  ;\n\t}\n\n\tload(url, callback, asset) {\n\t\tvar _asset$file;\n\n\t\tconst hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);\n\n\t\tif (hasContents) {\n\t\t\turl = {\n\t\t\t\tload: URL.createObjectURL(new Blob([asset.file.contents])),\n\t\t\t\toriginal: url.original\n\t\t\t};\n\t\t}\n\n\t\tconst handler = (err, result) => {\n\t\t\tif (hasContents) {\n\t\t\t\tURL.revokeObjectURL(url.load);\n\t\t\t}\n\n\t\t\tcallback(err, result);\n\t\t};\n\n\t\tlet crossOrigin;\n\n\t\tif (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {\n\t\t\tcrossOrigin = asset.options.crossOrigin;\n\t\t} else if (ABSOLUTE_URL.test(url.load)) {\n\t\t\tcrossOrigin = this.crossOrigin;\n\t\t}\n\n\t\tif (this.useImageBitmap) {\n\t\t\tthis._loadImageBitmap(url.load, url.original, crossOrigin, handler);\n\t\t} else {\n\t\t\tthis._loadImage(url.load, url.original, crossOrigin, handler);\n\t\t}\n\t}\n\n\topen(url, data, device) {\n\t\tconst ext = path.getExtension(url).toLowerCase();\n\t\tconst format = ext === \".jpg\" || ext === \".jpeg\" ? PIXELFORMAT_R8_G8_B8 : PIXELFORMAT_R8_G8_B8_A8;\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: format\n\t\t});\n\t\ttexture.setSource(data);\n\t\treturn texture;\n\t}\n\n\t_loadImage(url, originalUrl, crossOrigin, callback) {\n\t\tconst image = new Image();\n\n\t\tif (crossOrigin) {\n\t\t\timage.crossOrigin = crossOrigin;\n\t\t}\n\n\t\tlet retries = 0;\n\t\tconst maxRetries = this.maxRetries;\n\t\tlet retryTimeout;\n\n\t\timage.onload = function () {\n\t\t\tcallback(null, image);\n\t\t};\n\n\t\timage.onerror = function () {\n\t\t\tif (retryTimeout) return;\n\n\t\t\tif (maxRetries > 0 && ++retries <= maxRetries) {\n\t\t\t\tconst retryDelay = Math.pow(2, retries) * 100;\n\t\t\t\tconsole.log(`Error loading Texture from: '${originalUrl}' - Retrying in ${retryDelay}ms...`);\n\t\t\t\tconst idx = url.indexOf('?');\n\t\t\t\tconst separator = idx >= 0 ? '&' : '?';\n\t\t\t\tretryTimeout = setTimeout(function () {\n\t\t\t\t\timage.src = url + separator + 'retry=' + Date.now();\n\t\t\t\t\tretryTimeout = null;\n\t\t\t\t}, retryDelay);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading Texture from: '${originalUrl}'`);\n\t\t\t}\n\t\t};\n\n\t\timage.src = url;\n\t}\n\n\t_loadImageBitmap(url, originalUrl, crossOrigin, callback) {\n\t\tconst options = {\n\t\t\tcache: true,\n\t\t\tresponseType: \"blob\",\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\thttp.get(url, options, function (err, blob) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tcreateImageBitmap(blob, {\n\t\t\t\t\tpremultiplyAlpha: 'none'\n\t\t\t\t}).then(function (imageBitmap) {\n\t\t\t\t\tcallback(null, imageBitmap);\n\t\t\t\t}).catch(function (e) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n}\n\nconst IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];\nconst KNOWN_FORMATS = {\n\t0x83F0: PIXELFORMAT_DXT1,\n\t0x83F2: PIXELFORMAT_DXT3,\n\t0x83F3: PIXELFORMAT_DXT5,\n\t0x8D64: PIXELFORMAT_ETC1,\n\t0x9274: PIXELFORMAT_ETC2_RGB,\n\t0x9278: PIXELFORMAT_ETC2_RGBA,\n\t0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,\n\t0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,\n\t0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,\n\t0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,\n\t0x8051: PIXELFORMAT_R8_G8_B8,\n\t0x8058: PIXELFORMAT_R8_G8_B8_A8,\n\t0x8C41: PIXELFORMAT_SRGB,\n\t0x8C43: PIXELFORMAT_SRGBA,\n\t0x8C3A: PIXELFORMAT_111110F,\n\t0x881B: PIXELFORMAT_RGB16F,\n\t0x881A: PIXELFORMAT_RGBA16F\n};\n\nfunction createContainer(pixelFormat, buffer, byteOffset, byteSize) {\n\treturn pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);\n}\n\nclass KtxParser {\n\tconstructor(registry) {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst textureData = this.parse(data);\n\n\t\tif (!textureData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: textureData.width,\n\t\t\theight: textureData.height,\n\t\t\tformat: textureData.format,\n\t\t\tcubemap: textureData.cubemap,\n\t\t\tlevels: textureData.levels\n\t\t});\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n\tparse(data) {\n\t\tconst dataU32 = new Uint32Array(data);\n\n\t\tif (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst header = {\n\t\t\tendianness: dataU32[3],\n\t\t\tglType: dataU32[4],\n\t\t\tglTypeSize: dataU32[5],\n\t\t\tglFormat: dataU32[6],\n\t\t\tglInternalFormat: dataU32[7],\n\t\t\tglBaseInternalFormat: dataU32[8],\n\t\t\tpixelWidth: dataU32[9],\n\t\t\tpixelHeight: dataU32[10],\n\t\t\tpixelDepth: dataU32[11],\n\t\t\tnumberOfArrayElements: dataU32[12],\n\t\t\tnumberOfFaces: dataU32[13],\n\t\t\tnumberOfMipmapLevels: dataU32[14],\n\t\t\tbytesOfKeyValueData: dataU32[15]\n\t\t};\n\n\t\tif (header.pixelDepth > 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (header.numberOfArrayElements !== 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst format = KNOWN_FORMATS[header.glInternalFormat];\n\n\t\tif (format === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet offset = 16 + header.bytesOfKeyValueData / 4;\n\t\tconst isCubemap = header.numberOfFaces > 1;\n\t\tconst levels = [];\n\n\t\tfor (let mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {\n\t\t\tconst imageSizeInBytes = dataU32[offset++];\n\n\t\t\tif (isCubemap) {\n\t\t\t\tlevels.push([]);\n\t\t\t}\n\n\t\t\tconst target = isCubemap ? levels[mipmapLevel] : levels;\n\n\t\t\tfor (let face = 0; face < (isCubemap ? 6 : 1); ++face) {\n\t\t\t\ttarget.push(createContainer(format, data, offset * 4, imageSizeInBytes));\n\t\t\t\toffset += imageSizeInBytes + 3 >> 2;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tformat: format,\n\t\t\twidth: header.pixelWidth,\n\t\t\theight: header.pixelHeight,\n\t\t\tlevels: levels,\n\t\t\tcubemap: isCubemap\n\t\t};\n\t}\n\n}\n\nconst KHRConstants = {\n\tKHR_DF_MODEL_ETC1S: 163,\n\tKHR_DF_MODEL_UASTC: 166\n};\n\nclass Ktx2Parser {\n\tconstructor(registry, device) {\n\t\tthis.maxRetries = 0;\n\t\tthis.device = device;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err, result);\n\t\t\t} else {\n\t\t\t\tthis.parse(result, url, callback, asset);\n\t\t\t}\n\t\t}, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: data.format,\n\t\t\tcubemap: data.cubemap,\n\t\t\tlevels: data.levels\n\t\t});\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n\tparse(arraybuffer, url, callback, asset) {\n\t\tconst rs = new ReadStream(arraybuffer);\n\t\tconst magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];\n\n\t\tif (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst header = {\n\t\t\tvkFormat: rs.readU32(),\n\t\t\ttypeSize: rs.readU32(),\n\t\t\tpixelWidth: rs.readU32(),\n\t\t\tpixelHeight: rs.readU32(),\n\t\t\tpixelDepth: rs.readU32(),\n\t\t\tlayerCount: rs.readU32(),\n\t\t\tfaceCount: rs.readU32(),\n\t\t\tlevelCount: rs.readU32(),\n\t\t\tsupercompressionScheme: rs.readU32()\n\t\t};\n\t\tconst index = {\n\t\t\tdfdByteOffset: rs.readU32(),\n\t\t\tdfdByteLength: rs.readU32(),\n\t\t\tkvdByteOffset: rs.readU32(),\n\t\t\tkvdByteLength: rs.readU32(),\n\t\t\tsgdByteOffset: rs.readU64(),\n\t\t\tsgdByteLength: rs.readU64()\n\t\t};\n\t\tconst levels = [];\n\n\t\tfor (let i = 0; i < Math.max(1, header.levelCount); ++i) {\n\t\t\tlevels.push({\n\t\t\t\tbyteOffset: rs.readU64(),\n\t\t\t\tbyteLength: rs.readU64(),\n\t\t\t\tuncompressedByteLength: rs.readU64()\n\t\t\t});\n\t\t}\n\n\t\tconst dfdTotalSize = rs.readU32();\n\n\t\tif (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {\n\t\t\treturn null;\n\t\t}\n\n\t\trs.skip(8);\n\t\tconst colorModel = rs.readU8();\n\t\trs.skip(index.dfdByteLength - 9);\n\t\trs.skip(index.kvdByteLength);\n\n\t\tif (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {\n\t\t\tvar _asset$file, _asset$file$variants, _asset$file$variants$;\n\n\t\t\tconst basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {\n\t\t\t\tisGGGR: ((asset == null ? void 0 : (_asset$file = asset.file) == null ? void 0 : (_asset$file$variants = _asset$file.variants) == null ? void 0 : (_asset$file$variants$ = _asset$file$variants.basis) == null ? void 0 : _asset$file$variants$.opt) & 8) !== 0,\n\t\t\t\tisKTX2: true\n\t\t\t});\n\n\t\t\tif (!basisModuleFound) {\n\t\t\t\tcallback('Basis module not found. Asset \"' + asset.name + '\" basis texture variant will not be loaded.');\n\t\t\t}\n\t\t} else {\n\t\t\tcallback('unsupported KTX2 pixel format');\n\t\t}\n\t}\n\n}\n\nclass DdsParser {\n\tconstructor(registry) {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst header = new Uint32Array(data, 0, 128 / 4);\n\t\tconst width = header[4];\n\t\tconst height = header[3];\n\t\tconst mips = Math.max(header[7], 1);\n\t\tconst isFourCc = header[20] === 4;\n\t\tconst fcc = header[21];\n\t\tconst bpp = header[22];\n\t\tconst isCubemap = header[28] === 65024;\n\t\tconst FCC_DXT1 = 827611204;\n\t\tconst FCC_DXT5 = 894720068;\n\t\tconst FCC_FP16 = 113;\n\t\tconst FCC_FP32 = 116;\n\t\tconst FCC_ETC1 = 826496069;\n\t\tconst FCC_PVRTC_2BPP_RGB_1 = 825438800;\n\t\tconst FCC_PVRTC_2BPP_RGBA_1 = 825504336;\n\t\tconst FCC_PVRTC_4BPP_RGB_1 = 825439312;\n\t\tconst FCC_PVRTC_4BPP_RGBA_1 = 825504848;\n\t\tlet compressed = false;\n\t\tlet etc1 = false;\n\t\tlet pvrtc2 = false;\n\t\tlet pvrtc4 = false;\n\t\tlet format = null;\n\t\tlet componentSize = 1;\n\t\tlet texture;\n\n\t\tif (isFourCc) {\n\t\t\tif (fcc === FCC_DXT1) {\n\t\t\t\tformat = PIXELFORMAT_DXT1;\n\t\t\t\tcompressed = true;\n\t\t\t} else if (fcc === FCC_DXT5) {\n\t\t\t\tformat = PIXELFORMAT_DXT5;\n\t\t\t\tcompressed = true;\n\t\t\t} else if (fcc === FCC_FP16) {\n\t\t\t\tformat = PIXELFORMAT_RGBA16F;\n\t\t\t\tcomponentSize = 2;\n\t\t\t} else if (fcc === FCC_FP32) {\n\t\t\t\tformat = PIXELFORMAT_RGBA32F;\n\t\t\t\tcomponentSize = 4;\n\t\t\t} else if (fcc === FCC_ETC1) {\n\t\t\t\tformat = PIXELFORMAT_ETC1;\n\t\t\t\tcompressed = true;\n\t\t\t\tetc1 = true;\n\t\t\t} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {\n\t\t\t\tformat = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;\n\t\t\t\tcompressed = true;\n\t\t\t\tpvrtc2 = true;\n\t\t\t} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {\n\t\t\t\tformat = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;\n\t\t\t\tcompressed = true;\n\t\t\t\tpvrtc4 = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bpp === 32) {\n\t\t\t\tformat = PIXELFORMAT_R8_G8_B8_A8;\n\t\t\t}\n\t\t}\n\n\t\tif (!format) {\n\t\t\ttexture = new Texture(device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8\n\t\t\t});\n\t\t\ttexture.name = 'dds-legacy-empty';\n\t\t\treturn texture;\n\t\t}\n\n\t\ttexture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tformat: format,\n\t\t\tcubemap: isCubemap,\n\t\t\tmipmaps: mips > 1\n\t\t});\n\t\tlet offset = 128;\n\t\tconst faces = isCubemap ? 6 : 1;\n\t\tlet mipSize;\n\t\tconst DXT_BLOCK_WIDTH = 4;\n\t\tconst DXT_BLOCK_HEIGHT = 4;\n\t\tconst blockSize = fcc === FCC_DXT1 ? 8 : 16;\n\t\tlet numBlocksAcross, numBlocksDown, numBlocks;\n\n\t\tfor (let face = 0; face < faces; face++) {\n\t\t\tlet mipWidth = width;\n\t\t\tlet mipHeight = height;\n\n\t\t\tfor (let i = 0; i < mips; i++) {\n\t\t\t\tif (compressed) {\n\t\t\t\t\tif (etc1) {\n\t\t\t\t\t\tmipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;\n\t\t\t\t\t} else if (pvrtc2) {\n\t\t\t\t\t\tmipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;\n\t\t\t\t\t} else if (pvrtc4) {\n\t\t\t\t\t\tmipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);\n\t\t\t\t\t\tnumBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);\n\t\t\t\t\t\tnumBlocks = numBlocksAcross * numBlocksDown;\n\t\t\t\t\t\tmipSize = numBlocks * blockSize;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmipSize = mipWidth * mipHeight * 4;\n\t\t\t\t}\n\n\t\t\t\tconst mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);\n\n\t\t\t\tif (!isCubemap) {\n\t\t\t\t\ttexture._levels[i] = mipBuff;\n\t\t\t\t} else {\n\t\t\t\t\tif (!texture._levels[i]) texture._levels[i] = [];\n\t\t\t\t\ttexture._levels[i][face] = mipBuff;\n\t\t\t\t}\n\n\t\t\t\toffset += mipSize * componentSize;\n\t\t\t\tmipWidth = Math.max(mipWidth * 0.5, 1);\n\t\t\t\tmipHeight = Math.max(mipHeight * 0.5, 1);\n\t\t\t}\n\t\t}\n\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n}\n\nclass HdrParser {\n\tconstructor(registry) {\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\n\topen(url, data, device) {\n\t\tconst textureData = this.parse(data);\n\n\t\tif (!textureData) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst texture = new Texture(device, {\n\t\t\tname: url,\n\t\t\taddressU: ADDRESS_REPEAT,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tminFilter: FILTER_NEAREST_MIPMAP_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\twidth: textureData.width,\n\t\t\theight: textureData.height,\n\t\t\tlevels: textureData.levels,\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\ttype: TEXTURETYPE_RGBE,\n\t\t\tmipmaps: false\n\t\t});\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\n\tparse(data) {\n\t\tconst readStream = new ReadStream(data);\n\t\tconst magic = readStream.readLine();\n\n\t\tif (!magic.startsWith('#?RADIANCE')) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst variables = {};\n\n\t\twhile (true) {\n\t\t\tconst line = readStream.readLine();\n\n\t\t\tif (line.length === 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tconst parts = line.split('=');\n\n\t\t\t\tif (parts.length === 2) {\n\t\t\t\t\tvariables[parts[0]] = parts[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!variables.hasOwnProperty('FORMAT')) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst resolution = readStream.readLine().split(' ');\n\n\t\tif (resolution.length !== 4) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst height = parseInt(resolution[1], 10);\n\t\tconst width = parseInt(resolution[3], 10);\n\n\t\tconst pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');\n\n\t\tif (!pixels) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: [pixels]\n\t\t};\n\t}\n\n\t_readPixels(readStream, width, height, flipY) {\n\t\tif (width < 8 || width > 0x7fff) {\n\t\t\treturn this._readPixelsFlat(readStream, width, height);\n\t\t}\n\n\t\tconst rgbe = [0, 0, 0, 0];\n\t\treadStream.readArray(rgbe);\n\n\t\tif (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {\n\t\t\treadStream.skip(-4);\n\t\t\treturn this._readPixelsFlat(readStream, width, height);\n\t\t}\n\n\t\tconst buffer = new ArrayBuffer(width * height * 4);\n\t\tconst view = new Uint8Array(buffer);\n\t\tlet scanstart = flipY ? 0 : width * 4 * (height - 1);\n\t\tlet x, y, i, channel, count, value;\n\n\t\tfor (y = 0; y < height; ++y) {\n\t\t\tif (y) {\n\t\t\t\treadStream.readArray(rgbe);\n\t\t\t}\n\n\t\t\tif ((rgbe[2] << 8) + rgbe[3] !== width) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfor (channel = 0; channel < 4; ++channel) {\n\t\t\t\tx = 0;\n\n\t\t\t\twhile (x < width) {\n\t\t\t\t\tcount = readStream.readU8();\n\n\t\t\t\t\tif (count > 128) {\n\t\t\t\t\t\tcount -= 128;\n\n\t\t\t\t\t\tif (x + count > width) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalue = readStream.readU8();\n\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\t\t\tview[scanstart + channel + 4 * x++] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (count === 0 || x + count > width) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\t\t\tview[scanstart + channel + 4 * x++] = readStream.readU8();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanstart += width * 4 * (flipY ? 1 : -1);\n\t\t}\n\n\t\treturn view;\n\t}\n\n\t_readPixelsFlat(readStream, width, height) {\n\t\treturn readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;\n\t}\n\n}\n\nconst JSON_ADDRESS_MODE = {\n\t\"repeat\": ADDRESS_REPEAT,\n\t\"clamp\": ADDRESS_CLAMP_TO_EDGE,\n\t\"mirror\": ADDRESS_MIRRORED_REPEAT\n};\nconst JSON_FILTER_MODE = {\n\t\"nearest\": FILTER_NEAREST,\n\t\"linear\": FILTER_LINEAR,\n\t\"nearest_mip_nearest\": FILTER_NEAREST_MIPMAP_NEAREST,\n\t\"linear_mip_nearest\": FILTER_LINEAR_MIPMAP_NEAREST,\n\t\"nearest_mip_linear\": FILTER_NEAREST_MIPMAP_LINEAR,\n\t\"linear_mip_linear\": FILTER_LINEAR_MIPMAP_LINEAR\n};\nconst JSON_TEXTURE_TYPE = {\n\t\"default\": TEXTURETYPE_DEFAULT,\n\t\"rgbm\": TEXTURETYPE_RGBM,\n\t\"rgbe\": TEXTURETYPE_RGBE,\n\t\"swizzleGGGR\": TEXTURETYPE_SWIZZLEGGGR\n};\n\nclass TextureParser {\n\tload(url, callback, asset) {\n\t\tthrow new Error('not implemented');\n\t}\n\n\topen(url, data, device) {\n\t\tthrow new Error('not implemented');\n\t}\n\n}\n\nconst _completePartialMipmapChain = function _completePartialMipmapChain(texture) {\n\tconst requiredMipLevels = Math.log2(Math.max(texture._width, texture._height)) + 1;\n\n\tconst isHtmlElement = function isHtmlElement(object) {\n\t\treturn object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;\n\t};\n\n\tif (!(texture._format === PIXELFORMAT_R8_G8_B8_A8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {\n\t\treturn;\n\t}\n\n\tconst downsample = function downsample(width, height, data) {\n\t\tconst sampledWidth = Math.max(1, width >> 1);\n\t\tconst sampledHeight = Math.max(1, height >> 1);\n\t\tconst sampledData = new data.constructor(sampledWidth * sampledHeight * 4);\n\t\tconst xs = Math.floor(width / sampledWidth);\n\t\tconst ys = Math.floor(height / sampledHeight);\n\t\tconst xsys = xs * ys;\n\n\t\tfor (let y = 0; y < sampledHeight; ++y) {\n\t\t\tfor (let x = 0; x < sampledWidth; ++x) {\n\t\t\t\tfor (let e = 0; e < 4; ++e) {\n\t\t\t\t\tlet sum = 0;\n\n\t\t\t\t\tfor (let sy = 0; sy < ys; ++sy) {\n\t\t\t\t\t\tfor (let sx = 0; sx < xs; ++sx) {\n\t\t\t\t\t\t\tsum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sampledData;\n\t};\n\n\tfor (let level = texture._levels.length; level < requiredMipLevels; ++level) {\n\t\tconst width = Math.max(1, texture._width >> level - 1);\n\t\tconst height = Math.max(1, texture._height >> level - 1);\n\n\t\tif (texture._cubemap) {\n\t\t\tconst mips = [];\n\n\t\t\tfor (let face = 0; face < 6; ++face) {\n\t\t\t\tmips.push(downsample(width, height, texture._levels[level - 1][face]));\n\t\t\t}\n\n\t\t\ttexture._levels.push(mips);\n\t\t} else {\n\t\t\ttexture._levels.push(downsample(width, height, texture._levels[level - 1]));\n\t\t}\n\t}\n\n\ttexture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];\n};\n\nclass TextureHandler {\n\tconstructor(device, assets, loader) {\n\t\tthis._device = device;\n\t\tthis._assets = assets;\n\t\tthis._loader = loader;\n\t\tthis.imgParser = new ImgParser(assets);\n\t\tthis.parsers = {\n\t\t\tdds: new DdsParser(assets),\n\t\t\tktx: new KtxParser(assets),\n\t\t\tktx2: new Ktx2Parser(assets, device),\n\t\t\tbasis: new BasisParser(assets, device),\n\t\t\thdr: new HdrParser(assets)\n\t\t};\n\t}\n\n\tset crossOrigin(value) {\n\t\tthis.imgParser.crossOrigin = value;\n\t}\n\n\tget crossOrigin() {\n\t\treturn this.imgParser.crossOrigin;\n\t}\n\n\tset maxRetries(value) {\n\t\tthis.imgParser.maxRetries = value;\n\n\t\tfor (const parser in this.parsers) {\n\t\t\tif (this.parsers.hasOwnProperty(parser)) {\n\t\t\t\tthis.parsers[parser].maxRetries = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tget maxRetries() {\n\t\treturn this.imgParser.maxRetries;\n\t}\n\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\n\t_getParser(url) {\n\t\tconst ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');\n\t\treturn this.parsers[ext] || this.imgParser;\n\t}\n\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\n\t\tthis._getParser(url.original).load(url, callback, asset);\n\t}\n\n\topen(url, data, asset) {\n\t\tif (!url) return;\n\n\t\tlet texture = this._getParser(url).open(url, data, this._device);\n\n\t\tif (texture === null) {\n\t\t\ttexture = new Texture(this._device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8\n\t\t\t});\n\t\t} else {\n\t\t\t_completePartialMipmapChain(texture);\n\n\t\t\tif (data.unswizzledGGGR) {\n\t\t\t\tasset.file.variants.basis.opt &= ~8;\n\t\t\t}\n\t\t}\n\n\t\treturn texture;\n\t}\n\n\tpatch(asset, assets) {\n\t\tconst texture = asset.resource;\n\n\t\tif (!texture) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (asset.name && asset.name.length > 0) {\n\t\t\ttexture.name = asset.name;\n\t\t}\n\n\t\tconst assetData = asset.data;\n\n\t\tif (assetData.hasOwnProperty('minfilter')) {\n\t\t\ttexture.minFilter = JSON_FILTER_MODE[assetData.minfilter];\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('magfilter')) {\n\t\t\ttexture.magFilter = JSON_FILTER_MODE[assetData.magfilter];\n\t\t}\n\n\t\tif (!texture.cubemap) {\n\t\t\tif (assetData.hasOwnProperty('addressu')) {\n\t\t\t\ttexture.addressU = JSON_ADDRESS_MODE[assetData.addressu];\n\t\t\t}\n\n\t\t\tif (assetData.hasOwnProperty('addressv')) {\n\t\t\t\ttexture.addressV = JSON_ADDRESS_MODE[assetData.addressv];\n\t\t\t}\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('mipmaps')) {\n\t\t\ttexture.mipmaps = assetData.mipmaps;\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('anisotropy')) {\n\t\t\ttexture.anisotropy = assetData.anisotropy;\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('flipY')) {\n\t\t\ttexture.flipY = !!assetData.flipY;\n\t\t}\n\n\t\tif (assetData.hasOwnProperty('type')) {\n\t\t\ttexture.type = JSON_TEXTURE_TYPE[assetData.type];\n\t\t} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {\n\t\t\ttexture.type = TEXTURETYPE_RGBM;\n\t\t} else if (asset.file && (asset.file.opt & 8) !== 0) {\n\t\t\ttexture.type = TEXTURETYPE_SWIZZLEGGGR;\n\t\t}\n\t}\n\n}\n\nclass TagsCache {\n\tconstructor(key = null) {\n\t\tthis._index = {};\n\t\tthis._key = key;\n\t}\n\n\taddItem(item) {\n\t\tconst tags = item.tags._list;\n\n\t\tfor (const tag of tags) this.add(tag, item);\n\t}\n\n\tremoveItem(item) {\n\t\tconst tags = item.tags._list;\n\n\t\tfor (const tag of tags) this.remove(tag, item);\n\t}\n\n\tadd(tag, item) {\n\t\tif (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) return;\n\n\t\tif (!this._index[tag]) {\n\t\t\tthis._index[tag] = {\n\t\t\t\tlist: []\n\t\t\t};\n\t\t\tif (this._key) this._index[tag].keys = {};\n\t\t}\n\n\t\tthis._index[tag].list.push(item);\n\n\t\tif (this._key) this._index[tag].keys[item[this._key]] = item;\n\t}\n\n\tremove(tag, item) {\n\t\tif (!this._index[tag]) return;\n\n\t\tif (this._key) {\n\t\t\tif (!this._index[tag].keys[item[this._key]]) return;\n\t\t}\n\n\t\tconst ind = this._index[tag].list.indexOf(item);\n\n\t\tif (ind === -1) return;\n\n\t\tthis._index[tag].list.splice(ind, 1);\n\n\t\tif (this._key) delete this._index[tag].keys[item[this._key]];\n\t\tif (this._index[tag].list.length === 0) delete this._index[tag];\n\t}\n\n\tfind(args) {\n\t\tconst index = {};\n\t\tconst items = [];\n\t\tlet item, tag, tags, tagsRest, missingIndex;\n\n\t\tconst sort = (a, b) => {\n\t\t\treturn this._index[a].list.length - this._index[b].list.length;\n\t\t};\n\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\ttag = args[i];\n\n\t\t\tif (tag instanceof Array) {\n\t\t\t\tif (tag.length === 0) continue;\n\n\t\t\t\tif (tag.length === 1) {\n\t\t\t\t\ttag = tag[0];\n\t\t\t\t} else {\n\t\t\t\t\tmissingIndex = false;\n\n\t\t\t\t\tfor (let t = 0; t < tag.length; t++) {\n\t\t\t\t\t\tif (!this._index[tag[t]]) {\n\t\t\t\t\t\t\tmissingIndex = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (missingIndex) continue;\n\t\t\t\t\ttags = tag.slice(0).sort(sort);\n\t\t\t\t\ttagsRest = tags.slice(1);\n\t\t\t\t\tif (tagsRest.length === 1) tagsRest = tagsRest[0];\n\n\t\t\t\t\tfor (let n = 0; n < this._index[tags[0]].list.length; n++) {\n\t\t\t\t\t\titem = this._index[tags[0]].list[n];\n\n\t\t\t\t\t\tif ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {\n\t\t\t\t\t\t\tif (this._key) index[item[this._key]] = true;\n\t\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tag && typeof tag === 'string' && this._index[tag]) {\n\t\t\t\tfor (let n = 0; n < this._index[tag].list.length; n++) {\n\t\t\t\t\titem = this._index[tag].list[n];\n\n\t\t\t\t\tif (this._key) {\n\t\t\t\t\t\tif (!index[item[this._key]]) {\n\t\t\t\t\t\t\tindex[item[this._key]] = true;\n\t\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (items.indexOf(item) === -1) {\n\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn items;\n\t}\n\n}\n\nclass AssetRegistry extends EventHandler {\n\tconstructor(loader) {\n\t\tsuper();\n\t\tthis._loader = loader;\n\t\tthis._assets = [];\n\t\tthis._cache = {};\n\t\tthis._names = {};\n\t\tthis._tags = new TagsCache('_id');\n\t\tthis._urls = {};\n\t\tthis.prefix = null;\n\t}\n\n\tlist(filters) {\n\t\tfilters = filters || {};\n\t\treturn this._assets.filter(asset => {\n\t\t\tlet include = true;\n\n\t\t\tif (filters.preload !== undefined) {\n\t\t\t\tinclude = asset.preload === filters.preload;\n\t\t\t}\n\n\t\t\treturn include;\n\t\t});\n\t}\n\n\tadd(asset) {\n\t\tconst index = this._assets.push(asset) - 1;\n\t\tlet url;\n\t\tthis._cache[asset.id] = index;\n\t\tif (!this._names[asset.name]) this._names[asset.name] = [];\n\n\t\tthis._names[asset.name].push(index);\n\n\t\tif (asset.file) {\n\t\t\turl = asset.file.url;\n\t\t\tthis._urls[url] = index;\n\t\t}\n\n\t\tasset.registry = this;\n\n\t\tthis._tags.addItem(asset);\n\n\t\tasset.tags.on('add', this._onTagAdd, this);\n\t\tasset.tags.on('remove', this._onTagRemove, this);\n\t\tthis.fire(\"add\", asset);\n\t\tthis.fire(\"add:\" + asset.id, asset);\n\t\tif (url) this.fire(\"add:url:\" + url, asset);\n\t\tif (asset.preload) this.load(asset);\n\t}\n\n\tremove(asset) {\n\t\tconst idx = this._cache[asset.id];\n\t\tconst url = asset.file ? asset.file.url : null;\n\n\t\tif (idx !== undefined) {\n\t\t\tthis._assets.splice(idx, 1);\n\n\t\t\tdelete this._cache[asset.id];\n\t\t\tthis._names = {};\n\t\t\tthis._urls = [];\n\n\t\t\tfor (let i = 0, l = this._assets.length; i < l; i++) {\n\t\t\t\tconst a = this._assets[i];\n\t\t\t\tthis._cache[a.id] = i;\n\n\t\t\t\tif (!this._names[a.name]) {\n\t\t\t\t\tthis._names[a.name] = [];\n\t\t\t\t}\n\n\t\t\t\tthis._names[a.name].push(i);\n\n\t\t\t\tif (a.file) {\n\t\t\t\t\tthis._urls[a.file.url] = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._tags.removeItem(asset);\n\n\t\t\tasset.tags.off('add', this._onTagAdd, this);\n\t\t\tasset.tags.off('remove', this._onTagRemove, this);\n\t\t\tasset.fire(\"remove\", asset);\n\t\t\tthis.fire(\"remove\", asset);\n\t\t\tthis.fire(\"remove:\" + asset.id, asset);\n\t\t\tif (url) this.fire(\"remove:url:\" + url, asset);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget(id) {\n\t\tconst idx = this._cache[id];\n\t\treturn this._assets[idx];\n\t}\n\n\tgetByUrl(url) {\n\t\tconst idx = this._urls[url];\n\t\treturn this._assets[idx];\n\t}\n\n\tload(asset) {\n\t\tif (asset.loading || asset.loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst file = asset.file;\n\n\t\tconst _opened = resource => {\n\t\t\tif (resource instanceof Array) {\n\t\t\t\tasset.resources = resource;\n\t\t\t} else {\n\t\t\t\tasset.resource = resource;\n\t\t\t}\n\n\t\t\tthis._loader.patch(asset, this);\n\n\t\t\tthis.fire(\"load\", asset);\n\t\t\tthis.fire(\"load:\" + asset.id, asset);\n\t\t\tif (file && file.url) this.fire(\"load:url:\" + file.url, asset);\n\t\t\tasset.fire(\"load\", asset);\n\t\t};\n\n\t\tconst _loaded = (err, resource, extra) => {\n\t\t\tasset.loaded = true;\n\t\t\tasset.loading = false;\n\n\t\t\tif (err) {\n\t\t\t\tthis.fire(\"error\", err, asset);\n\t\t\t\tthis.fire(\"error:\" + asset.id, err, asset);\n\t\t\t\tasset.fire(\"error\", err, asset);\n\t\t\t} else {\n\t\t\t\tif (!script.legacy && asset.type === 'script') {\n\t\t\t\t\tconst handler = this._loader.getHandler('script');\n\n\t\t\t\t\tif (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {\n\t\t\t\t\t\tdocument.head.removeChild(handler._cache[asset.id]);\n\t\t\t\t\t}\n\n\t\t\t\t\thandler._cache[asset.id] = extra;\n\t\t\t\t}\n\n\t\t\t\t_opened(resource);\n\t\t\t}\n\t\t};\n\n\t\tif (file || asset.type === 'cubemap') {\n\t\t\tthis.fire(\"load:start\", asset);\n\t\t\tthis.fire(\"load:\" + asset.id + \":start\", asset);\n\t\t\tasset.loading = true;\n\n\t\t\tthis._loader.load(asset.getFileUrl(), asset.type, _loaded, asset);\n\t\t} else {\n\t\t\tconst resource = this._loader.open(asset.type, asset.data);\n\n\t\t\tasset.loaded = true;\n\n\t\t\t_opened(resource);\n\t\t}\n\t}\n\n\tloadFromUrl(url, type, callback) {\n\t\tthis.loadFromUrlAndFilename(url, null, type, callback);\n\t}\n\n\tloadFromUrlAndFilename(url, filename, type, callback) {\n\t\tconst name = path.getBasename(filename || url);\n\t\tconst file = {\n\t\t\tfilename: filename || name,\n\t\t\turl: url\n\t\t};\n\t\tlet asset = this.getByUrl(url);\n\n\t\tif (!asset) {\n\t\t\tasset = new Asset(name, type, file);\n\t\t\tthis.add(asset);\n\t\t} else if (asset.loaded) {\n\t\t\tcallback(asset.loadFromUrlError || null, asset);\n\t\t\treturn;\n\t\t}\n\n\t\tconst startLoad = asset => {\n\t\t\tasset.once(\"load\", loadedAsset => {\n\t\t\t\tif (type === 'material') {\n\t\t\t\t\tthis._loadTextures(loadedAsset, (err, textures) => {\n\t\t\t\t\t\tcallback(err, loadedAsset);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(null, loadedAsset);\n\t\t\t\t}\n\t\t\t});\n\t\t\tasset.once(\"error\", err => {\n\t\t\t\tif (err) {\n\t\t\t\t\tthis.loadFromUrlError = err;\n\t\t\t\t}\n\n\t\t\t\tcallback(err, asset);\n\t\t\t});\n\t\t\tthis.load(asset);\n\t\t};\n\n\t\tif (asset.resource) {\n\t\t\tcallback(null, asset);\n\t\t} else if (type === 'model') {\n\t\t\tthis._loadModel(asset, startLoad);\n\t\t} else {\n\t\t\tstartLoad(asset);\n\t\t}\n\t}\n\n\t_loadModel(modelAsset, continuation) {\n\t\tconst url = modelAsset.getFileUrl();\n\t\tconst ext = path.getExtension(url);\n\n\t\tif (ext === '.json' || ext === '.glb') {\n\t\t\tconst dir = path.getDirectory(url);\n\t\t\tconst basename = path.getBasename(url);\n\t\t\tconst mappingUrl = path.join(dir, basename.replace(ext, \".mapping.json\"));\n\n\t\t\tthis._loader.load(mappingUrl, 'json', (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tmodelAsset.data = {\n\t\t\t\t\t\tmapping: []\n\t\t\t\t\t};\n\t\t\t\t\tcontinuation(modelAsset);\n\t\t\t\t} else {\n\t\t\t\t\tthis._loadMaterials(modelAsset, data, (e, materials) => {\n\t\t\t\t\t\tmodelAsset.data = data;\n\t\t\t\t\t\tcontinuation(modelAsset);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tcontinuation(modelAsset);\n\t\t}\n\t}\n\n\t_loadMaterials(modelAsset, mapping, callback) {\n\t\tconst materials = [];\n\t\tlet count = 0;\n\n\t\tconst onMaterialLoaded = (err, materialAsset) => {\n\t\t\tthis._loadTextures(materialAsset, (err, textures) => {\n\t\t\t\tmaterials.push(materialAsset);\n\n\t\t\t\tif (materials.length === count) {\n\t\t\t\t\tcallback(null, materials);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tfor (let i = 0; i < mapping.mapping.length; i++) {\n\t\t\tconst path = mapping.mapping[i].path;\n\n\t\t\tif (path) {\n\t\t\t\tcount++;\n\t\t\t\tconst url = modelAsset.getAbsoluteUrl(path);\n\t\t\t\tthis.loadFromUrl(url, \"material\", onMaterialLoaded);\n\t\t\t}\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\tcallback(null, materials);\n\t\t}\n\t}\n\n\t_loadTextures(materialAsset, callback) {\n\t\tconst textures = [];\n\t\tlet count = 0;\n\t\tconst data = materialAsset.data;\n\n\t\tif (data.mappingFormat !== 'path') {\n\t\t\tcallback(null, textures);\n\t\t\treturn;\n\t\t}\n\n\t\tconst onTextureLoaded = (err, texture) => {\n\t\t\tif (err) console.error(err);\n\t\t\ttextures.push(texture);\n\n\t\t\tif (textures.length === count) {\n\t\t\t\tcallback(null, textures);\n\t\t\t}\n\t\t};\n\n\t\tconst texParams = standardMaterialTextureParameters;\n\n\t\tfor (let i = 0; i < texParams.length; i++) {\n\t\t\tconst path = data[texParams[i]];\n\n\t\t\tif (path && typeof path === 'string') {\n\t\t\t\tcount++;\n\t\t\t\tconst url = materialAsset.getAbsoluteUrl(path);\n\t\t\t\tthis.loadFromUrl(url, \"texture\", onTextureLoaded);\n\t\t\t}\n\t\t}\n\n\t\tif (count === 0) {\n\t\t\tcallback(null, textures);\n\t\t}\n\t}\n\n\tfindAll(name, type) {\n\t\tconst idxs = this._names[name];\n\n\t\tif (idxs) {\n\t\t\tconst assets = idxs.map(idx => {\n\t\t\t\treturn this._assets[idx];\n\t\t\t});\n\n\t\t\tif (type) {\n\t\t\t\treturn assets.filter(asset => {\n\t\t\t\t\treturn asset.type === type;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn assets;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\t_onTagAdd(tag, asset) {\n\t\tthis._tags.add(tag, asset);\n\t}\n\n\t_onTagRemove(tag, asset) {\n\t\tthis._tags.remove(tag, asset);\n\t}\n\n\tfindByTag() {\n\t\treturn this._tags.find(arguments);\n\t}\n\n\tfilter(callback) {\n\t\treturn this._assets.filter(asset => callback(asset));\n\t}\n\n\tfind(name, type) {\n\t\tconst asset = this.findAll(name, type);\n\t\treturn asset.length > 0 ? asset[0] : null;\n\t}\n\n}\n\nclass BundleRegistry {\n\tconstructor(assets) {\n\t\tthis._assets = assets;\n\t\tthis._bundleAssets = {};\n\t\tthis._assetsInBundles = {};\n\t\tthis._urlsInBundles = {};\n\t\tthis._fileRequests = {};\n\n\t\tthis._assets.on('add', this._onAssetAdded, this);\n\n\t\tthis._assets.on('remove', this._onAssetRemoved, this);\n\t}\n\n\t_onAssetAdded(asset) {\n\t\tif (asset.type === 'bundle') {\n\t\t\tthis._bundleAssets[asset.id] = asset;\n\n\t\t\tthis._registerBundleEventListeners(asset.id);\n\n\t\t\tfor (let i = 0, len = asset.data.assets.length; i < len; i++) {\n\t\t\t\tthis._indexAssetInBundle(asset.data.assets[i], asset);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._assetsInBundles[asset.id]) {\n\t\t\t\tthis._indexAssetFileUrls(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\t_registerBundleEventListeners(bundleAssetId) {\n\t\tthis._assets.on('load:' + bundleAssetId, this._onBundleLoaded, this);\n\n\t\tthis._assets.on('error:' + bundleAssetId, this._onBundleError, this);\n\t}\n\n\t_unregisterBundleEventListeners(bundleAssetId) {\n\t\tthis._assets.off('load:' + bundleAssetId, this._onBundleLoaded, this);\n\n\t\tthis._assets.off('error:' + bundleAssetId, this._onBundleError, this);\n\t}\n\n\t_indexAssetInBundle(assetId, bundleAsset) {\n\t\tif (!this._assetsInBundles[assetId]) {\n\t\t\tthis._assetsInBundles[assetId] = [bundleAsset];\n\t\t} else {\n\t\t\tconst bundles = this._assetsInBundles[assetId];\n\t\t\tconst idx = bundles.indexOf(bundleAsset);\n\n\t\t\tif (idx === -1) {\n\t\t\t\tbundles.push(bundleAsset);\n\t\t\t}\n\t\t}\n\n\t\tconst asset = this._assets.get(assetId);\n\n\t\tif (asset) {\n\t\t\tthis._indexAssetFileUrls(asset);\n\t\t}\n\t}\n\n\t_indexAssetFileUrls(asset) {\n\t\tconst urls = this._getAssetFileUrls(asset);\n\n\t\tif (!urls) return;\n\n\t\tfor (let i = 0, len = urls.length; i < len; i++) {\n\t\t\tconst url = urls[i];\n\t\t\tthis._urlsInBundles[url] = this._assetsInBundles[asset.id];\n\t\t}\n\t}\n\n\t_getAssetFileUrls(asset) {\n\t\tlet url = asset.getFileUrl();\n\t\tif (!url) return null;\n\t\turl = this._normalizeUrl(url);\n\t\tconst urls = [url];\n\n\t\tif (asset.type === 'font') {\n\t\t\tconst numFiles = asset.data.info.maps.length;\n\n\t\t\tfor (let i = 1; i < numFiles; i++) {\n\t\t\t\turls.push(url.replace('.png', i + '.png'));\n\t\t\t}\n\t\t}\n\n\t\treturn urls;\n\t}\n\n\t_normalizeUrl(url) {\n\t\treturn url && url.split('?')[0];\n\t}\n\n\t_onAssetRemoved(asset) {\n\t\tif (asset.type === 'bundle') {\n\t\t\tdelete this._bundleAssets[asset.id];\n\n\t\t\tthis._unregisterBundleEventListeners(asset.id);\n\n\t\t\tfor (const id in this._assetsInBundles) {\n\t\t\t\tconst array = this._assetsInBundles[id];\n\t\t\t\tconst idx = array.indexOf(asset);\n\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tarray.splice(idx, 1);\n\n\t\t\t\t\tif (!array.length) {\n\t\t\t\t\t\tdelete this._assetsInBundles[id];\n\n\t\t\t\t\t\tfor (const url in this._urlsInBundles) {\n\t\t\t\t\t\t\tif (this._urlsInBundles[url] === array) {\n\t\t\t\t\t\t\t\tdelete this._urlsInBundles[url];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._onBundleError(`Bundle ${asset.id} was removed`, asset);\n\t\t} else if (this._assetsInBundles[asset.id]) {\n\t\t\tdelete this._assetsInBundles[asset.id];\n\n\t\t\tconst urls = this._getAssetFileUrls(asset);\n\n\t\t\tfor (let i = 0, len = urls.length; i < len; i++) {\n\t\t\t\tdelete this._urlsInBundles[urls[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\t_onBundleLoaded(bundleAsset) {\n\t\tif (!bundleAsset.resource) {\n\t\t\tthis._onBundleError(`Bundle ${bundleAsset.id} failed to load`, bundleAsset);\n\n\t\t\treturn;\n\t\t}\n\n\t\trequestAnimationFrame(() => {\n\t\t\tif (!this._fileRequests) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (const url in this._fileRequests) {\n\t\t\t\tconst bundles = this._urlsInBundles[url];\n\t\t\t\tif (!bundles || bundles.indexOf(bundleAsset) === -1) continue;\n\t\t\t\tconst decodedUrl = decodeURIComponent(url);\n\t\t\t\tlet err = null;\n\n\t\t\t\tif (!bundleAsset.resource.hasBlobUrl(decodedUrl)) {\n\t\t\t\t\terr = `Bundle ${bundleAsset.id} does not contain URL ${url}`;\n\t\t\t\t}\n\n\t\t\t\tconst requests = this._fileRequests[url];\n\n\t\t\t\tfor (let i = 0, len = requests.length; i < len; i++) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\trequests[i](err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequests[i](null, bundleAsset.resource.getBlobUrl(decodedUrl));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdelete this._fileRequests[url];\n\t\t\t}\n\t\t});\n\t}\n\n\t_onBundleError(err, bundleAsset) {\n\t\tfor (const url in this._fileRequests) {\n\t\t\tconst bundle = this._findLoadedOrLoadingBundleForUrl(url);\n\n\t\t\tif (!bundle) {\n\t\t\t\tconst requests = this._fileRequests[url];\n\n\t\t\t\tfor (let i = 0, len = requests.length; i < len; i++) {\n\t\t\t\t\trequests[i](err);\n\t\t\t\t}\n\n\t\t\t\tdelete this._fileRequests[url];\n\t\t\t}\n\t\t}\n\t}\n\n\t_findLoadedOrLoadingBundleForUrl(url) {\n\t\tconst bundles = this._urlsInBundles[url];\n\t\tif (!bundles) return null;\n\t\tconst len = bundles.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (bundles[i].loaded && bundles[i].resource) {\n\t\t\t\treturn bundles[i];\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (bundles[i].loading) {\n\t\t\t\treturn bundles[i];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tlistBundlesForAsset(asset) {\n\t\treturn this._assetsInBundles[asset.id] || null;\n\t}\n\n\tlist() {\n\t\tconst result = [];\n\n\t\tfor (const id in this._bundleAssets) {\n\t\t\tresult.push(this._bundleAssets[id]);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\thasUrl(url) {\n\t\treturn !!this._urlsInBundles[url];\n\t}\n\n\tcanLoadUrl(url) {\n\t\treturn !!this._findLoadedOrLoadingBundleForUrl(url);\n\t}\n\n\tloadUrl(url, callback) {\n\t\tconst bundle = this._findLoadedOrLoadingBundleForUrl(url);\n\n\t\tif (!bundle) {\n\t\t\tcallback(`URL ${url} not found in any bundles`);\n\t\t\treturn;\n\t\t}\n\n\t\tif (bundle.loaded) {\n\t\t\tconst decodedUrl = decodeURIComponent(url);\n\n\t\t\tif (!bundle.resource.hasBlobUrl(decodedUrl)) {\n\t\t\t\tcallback(`Bundle ${bundle.id} does not contain URL ${url}`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallback(null, bundle.resource.getBlobUrl(decodedUrl));\n\t\t} else if (this._fileRequests.hasOwnProperty(url)) {\n\t\t\tthis._fileRequests[url].push(callback);\n\t\t} else {\n\t\t\tthis._fileRequests[url] = [callback];\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._assets.off('add', this._onAssetAdded, this);\n\n\t\tthis._assets.off('remove', this._onAssetRemoved, this);\n\n\t\tfor (const id in this._bundleAssets) {\n\t\t\tthis._unregisterBundleEventListeners(id);\n\t\t}\n\n\t\tthis._assets = null;\n\t\tthis._bundleAssets = null;\n\t\tthis._assetsInBundles = null;\n\t\tthis._urlsInBundles = null;\n\t\tthis._fileRequests = null;\n\t}\n\n}\n\nconst components = ['x', 'y', 'z', 'w'];\nconst vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];\n\nfunction rawToValue(app, args, value, old) {\n\tswitch (args.type) {\n\t\tcase 'boolean':\n\t\t\treturn !!value;\n\n\t\tcase 'number':\n\t\t\tif (typeof value === 'number') {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tconst v = parseInt(value, 10);\n\t\t\t\tif (isNaN(v)) return null;\n\t\t\t\treturn v;\n\t\t\t} else if (typeof value === 'boolean') {\n\t\t\t\treturn 0 + value;\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\tcase 'json':\n\t\t\t{\n\t\t\t\tconst result = {};\n\n\t\t\t\tif (Array.isArray(args.schema)) {\n\t\t\t\t\tif (!value || typeof value !== 'object') {\n\t\t\t\t\t\tvalue = {};\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < args.schema.length; i++) {\n\t\t\t\t\t\tconst field = args.schema[i];\n\t\t\t\t\t\tif (!field.name) continue;\n\n\t\t\t\t\t\tif (field.array) {\n\t\t\t\t\t\t\tresult[field.name] = [];\n\t\t\t\t\t\t\tconst arr = Array.isArray(value[field.name]) ? value[field.name] : [];\n\n\t\t\t\t\t\t\tfor (let j = 0; j < arr.length; j++) {\n\t\t\t\t\t\t\t\tresult[field.name].push(rawToValue(app, field, arr[j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;\n\t\t\t\t\t\t\tresult[field.name] = rawToValue(app, field, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\tcase 'asset':\n\t\t\tif (value instanceof Asset) {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'number') {\n\t\t\t\treturn app.assets.get(value) || null;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\treturn app.assets.get(parseInt(value, 10)) || null;\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\tcase 'entity':\n\t\t\tif (value instanceof GraphNode) {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\treturn app.getEntityFromIndex(value);\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\tcase 'rgb':\n\t\tcase 'rgba':\n\t\t\tif (value instanceof Color) {\n\t\t\t\tif (old instanceof Color) {\n\t\t\t\t\told.copy(value);\n\t\t\t\t\treturn old;\n\t\t\t\t}\n\n\t\t\t\treturn value.clone();\n\t\t\t} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {\n\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\tif (typeof value[i] !== 'number') return null;\n\t\t\t\t}\n\n\t\t\t\tif (!old) old = new Color();\n\t\t\t\told.r = value[0];\n\t\t\t\told.g = value[1];\n\t\t\t\told.b = value[2];\n\t\t\t\told.a = value.length === 3 ? 1 : value[3];\n\t\t\t\treturn old;\n\t\t\t} else if (typeof value === 'string' && /#([0-9abcdef]{2}){3,4}/i.test(value)) {\n\t\t\t\tif (!old) old = new Color();\n\t\t\t\told.fromString(value);\n\t\t\t\treturn old;\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\tcase 'vec2':\n\t\tcase 'vec3':\n\t\tcase 'vec4':\n\t\t\t{\n\t\t\t\tconst len = parseInt(args.type.slice(3), 10);\n\t\t\t\tconst vecType = vecLookup[len];\n\n\t\t\t\tif (value instanceof vecType) {\n\t\t\t\t\tif (old instanceof vecType) {\n\t\t\t\t\t\told.copy(value);\n\t\t\t\t\t\treturn old;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value.clone();\n\t\t\t\t} else if (value instanceof Array && value.length === len) {\n\t\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\t\tif (typeof value[i] !== 'number') return null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!old) old = new vecType();\n\n\t\t\t\t\tfor (let i = 0; i < len; i++) old[components[i]] = value[i];\n\n\t\t\t\t\treturn old;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\tcase 'curve':\n\t\t\tif (value) {\n\t\t\t\tlet curve;\n\n\t\t\t\tif (value instanceof Curve || value instanceof CurveSet) {\n\t\t\t\t\tcurve = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tconst CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;\n\t\t\t\t\tcurve = new CurveType(value.keys);\n\t\t\t\t\tcurve.type = value.type;\n\t\t\t\t}\n\n\t\t\t\treturn curve;\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nclass ScriptAttributes {\n\tconstructor(scriptType) {\n\t\tthis.scriptType = scriptType;\n\t\tthis.index = {};\n\t}\n\n\tadd(name, args) {\n\t\tif (this.index[name]) {\n\t\t\treturn;\n\t\t} else if (ScriptAttributes.reservedNames.has(name)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.index[name] = args;\n\t\tObject.defineProperty(this.scriptType.prototype, name, {\n\t\t\tget: function () {\n\t\t\t\treturn this.__attributes[name];\n\t\t\t},\n\t\t\tset: function (raw) {\n\t\t\t\tconst evt = 'attr';\n\t\t\t\tconst evtName = 'attr:' + name;\n\t\t\t\tconst old = this.__attributes[name];\n\t\t\t\tlet oldCopy = old;\n\n\t\t\t\tif (old && args.type !== 'json' && old.clone) {\n\t\t\t\t\tif (this._callbacks[evt] || this._callbacks[evtName]) {\n\t\t\t\t\t\toldCopy = old.clone();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (args.array) {\n\t\t\t\t\tthis.__attributes[name] = [];\n\n\t\t\t\t\tif (raw) {\n\t\t\t\t\t\tfor (let i = 0, len = raw.length; i < len; i++) {\n\t\t\t\t\t\t\tthis.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.__attributes[name] = rawToValue(this.app, args, raw, old);\n\t\t\t\t}\n\n\t\t\t\tthis.fire(evt, name, this.__attributes[name], oldCopy);\n\t\t\t\tthis.fire(evtName, this.__attributes[name], oldCopy);\n\t\t\t}\n\t\t});\n\t}\n\n\tremove(name) {\n\t\tif (!this.index[name]) return false;\n\t\tdelete this.index[name];\n\t\tdelete this.scriptType.prototype[name];\n\t\treturn true;\n\t}\n\n\thas(name) {\n\t\treturn !!this.index[name];\n\t}\n\n\tget(name) {\n\t\treturn this.index[name] || null;\n\t}\n\n}\n\nScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);\n\nclass Component extends EventHandler {\n\tconstructor(system, entity) {\n\t\tsuper();\n\t\tthis.system = system;\n\t\tthis.entity = entity;\n\n\t\tif (this.system.schema && !this._accessorsBuilt) {\n\t\t\tthis.buildAccessors(this.system.schema);\n\t\t}\n\n\t\tthis.on(\"set\", function (name, oldValue, newValue) {\n\t\t\tthis.fire(\"set_\" + name, name, oldValue, newValue);\n\t\t});\n\t\tthis.on('set_enabled', this.onSetEnabled, this);\n\t}\n\n\tstatic _buildAccessors(obj, schema) {\n\t\tschema.forEach(function (descriptor) {\n\t\t\tconst name = typeof descriptor === 'object' ? descriptor.name : descriptor;\n\t\t\tObject.defineProperty(obj, name, {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.data[name];\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\tconst data = this.data;\n\t\t\t\t\tconst oldValue = data[name];\n\t\t\t\t\tdata[name] = value;\n\t\t\t\t\tthis.fire('set', name, oldValue, value);\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t});\n\t\tobj._accessorsBuilt = true;\n\t}\n\n\tbuildAccessors(schema) {\n\t\tComponent._buildAccessors(this, schema);\n\t}\n\n\tonSetEnabled(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.entity.enabled) {\n\t\t\t\tif (newValue) {\n\t\t\t\t\tthis.onEnable();\n\t\t\t\t} else {\n\t\t\t\t\tthis.onDisable();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {}\n\n\tonDisable() {}\n\n\tonPostStateChange() {}\n\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\n}\n\nclass ScriptComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._scripts = [];\n\t\tthis._updateList = new SortedLoopArray({\n\t\t\tsortBy: '__executionOrder'\n\t\t});\n\t\tthis._postUpdateList = new SortedLoopArray({\n\t\t\tsortBy: '__executionOrder'\n\t\t});\n\t\tthis._scriptsIndex = {};\n\t\tthis._destroyedScripts = [];\n\t\tthis._destroyed = false;\n\t\tthis._scriptsData = null;\n\t\tthis._oldState = true;\n\t\tthis._enabled = true;\n\t\tthis._beingEnabled = false;\n\t\tthis._isLoopingThroughScripts = false;\n\t\tthis._executionOrder = -1;\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\n\tset enabled(value) {\n\t\tconst oldValue = this._enabled;\n\t\tthis._enabled = value;\n\t\tthis.fire('set', 'enabled', oldValue, value);\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tset scripts(value) {\n\t\tthis._scriptsData = value;\n\n\t\tfor (const key in value) {\n\t\t\tif (!value.hasOwnProperty(key)) continue;\n\t\t\tconst script = this._scriptsIndex[key];\n\n\t\t\tif (script) {\n\t\t\t\tif (typeof value[key].enabled === 'boolean') script.enabled = !!value[key].enabled;\n\n\t\t\t\tif (typeof value[key].attributes === 'object') {\n\t\t\t\t\tfor (const attr in value[key].attributes) {\n\t\t\t\t\t\tif (ScriptAttributes.reservedNames.has(attr)) continue;\n\n\t\t\t\t\t\tif (!script.__attributes.hasOwnProperty(attr)) {\n\t\t\t\t\t\t\tconst scriptType = this.system.app.scripts.get(key);\n\t\t\t\t\t\t\tif (scriptType) scriptType.attributes.add(attr, {});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscript[attr] = value[key].attributes[attr];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(this.order);\n\t\t\t}\n\t\t}\n\t}\n\n\tget scripts() {\n\t\treturn this._scripts;\n\t}\n\n\tonEnable() {\n\t\tthis._beingEnabled = true;\n\n\t\tthis._checkState();\n\n\t\tif (!this.entity._beingEnabled) {\n\t\t\tthis.onPostStateChange();\n\t\t}\n\n\t\tthis._beingEnabled = false;\n\t}\n\n\tonDisable() {\n\t\tthis._checkState();\n\t}\n\n\tonPostStateChange() {\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) {\n\t\t\tconst script = this.scripts[i];\n\n\t\t\tif (script._initialized && !script._postInitialized && script.enabled) {\n\t\t\t\tscript._postInitialized = true;\n\t\t\t\tif (script.postInitialize) this._scriptMethod(script, ScriptComponent.scriptMethods.postInitialize);\n\t\t\t}\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_beginLooping() {\n\t\tconst looping = this._isLoopingThroughScripts;\n\t\tthis._isLoopingThroughScripts = true;\n\t\treturn looping;\n\t}\n\n\t_endLooping(wasLoopingBefore) {\n\t\tthis._isLoopingThroughScripts = wasLoopingBefore;\n\n\t\tif (!this._isLoopingThroughScripts) {\n\t\t\tthis._removeDestroyedScripts();\n\t\t}\n\t}\n\n\t_onSetEnabled(prop, old, value) {\n\t\tthis._beingEnabled = true;\n\n\t\tthis._checkState();\n\n\t\tthis._beingEnabled = false;\n\t}\n\n\t_checkState() {\n\t\tconst state = this.enabled && this.entity.enabled;\n\t\tif (state === this._oldState) return;\n\t\tthis._oldState = state;\n\t\tthis.fire(state ? 'enable' : 'disable');\n\t\tthis.fire('state', state);\n\n\t\tif (state) {\n\t\t\tthis.system._addComponentToEnabled(this);\n\t\t} else {\n\t\t\tthis.system._removeComponentFromEnabled(this);\n\t\t}\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) {\n\t\t\tconst script = this.scripts[i];\n\t\t\tscript.enabled = script._enabled;\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (let i = 0; i < this.scripts.length; i++) {\n\t\t\tconst script = this.scripts[i];\n\t\t\tif (!script) continue;\n\t\t\tthis.destroy(script.__scriptType.__name);\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_removeDestroyedScripts() {\n\t\tconst len = this._destroyedScripts.length;\n\t\tif (!len) return;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst script = this._destroyedScripts[i];\n\n\t\t\tthis._removeScriptInstance(script);\n\t\t}\n\n\t\tthis._destroyedScripts.length = 0;\n\n\t\tthis._resetExecutionOrder(0, this._scripts.length);\n\t}\n\n\t_onInitializeAttributes() {\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) this.scripts[i].__initializeAttributes();\n\t}\n\n\t_scriptMethod(script, method, arg) {\n\t\tscript[method](arg);\n\t}\n\n\t_onInitialize() {\n\t\tconst scripts = this._scripts;\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (let i = 0, len = scripts.length; i < len; i++) {\n\t\t\tconst script = scripts[i];\n\n\t\t\tif (!script._initialized && script.enabled) {\n\t\t\t\tscript._initialized = true;\n\t\t\t\tif (script.initialize) this._scriptMethod(script, ScriptComponent.scriptMethods.initialize);\n\t\t\t}\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_onPostInitialize() {\n\t\tthis.onPostStateChange();\n\t}\n\n\t_onUpdate(dt) {\n\t\tconst list = this._updateList;\n\t\tif (!list.length) return;\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {\n\t\t\tconst script = list.items[list.loopIndex];\n\n\t\t\tif (script.enabled) {\n\t\t\t\tthis._scriptMethod(script, ScriptComponent.scriptMethods.update, dt);\n\t\t\t}\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_onPostUpdate(dt) {\n\t\tconst list = this._postUpdateList;\n\t\tif (!list.length) return;\n\n\t\tconst wasLooping = this._beginLooping();\n\n\t\tfor (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {\n\t\t\tconst script = list.items[list.loopIndex];\n\n\t\t\tif (script.enabled) {\n\t\t\t\tthis._scriptMethod(script, ScriptComponent.scriptMethods.postUpdate, dt);\n\t\t\t}\n\t\t}\n\n\t\tthis._endLooping(wasLooping);\n\t}\n\n\t_insertScriptInstance(scriptInstance, index, scriptsLength) {\n\t\tif (index === -1) {\n\t\t\tthis._scripts.push(scriptInstance);\n\n\t\t\tscriptInstance.__executionOrder = scriptsLength;\n\n\t\t\tif (scriptInstance.update) {\n\t\t\t\tthis._updateList.append(scriptInstance);\n\t\t\t}\n\n\t\t\tif (scriptInstance.postUpdate) {\n\t\t\t\tthis._postUpdateList.append(scriptInstance);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._scripts.splice(index, 0, scriptInstance);\n\n\t\t\tscriptInstance.__executionOrder = index;\n\n\t\t\tthis._resetExecutionOrder(index + 1, scriptsLength + 1);\n\n\t\t\tif (scriptInstance.update) {\n\t\t\t\tthis._updateList.insert(scriptInstance);\n\t\t\t}\n\n\t\t\tif (scriptInstance.postUpdate) {\n\t\t\t\tthis._postUpdateList.insert(scriptInstance);\n\t\t\t}\n\t\t}\n\t}\n\n\t_removeScriptInstance(scriptInstance) {\n\t\tconst idx = this._scripts.indexOf(scriptInstance);\n\n\t\tif (idx === -1) return idx;\n\n\t\tthis._scripts.splice(idx, 1);\n\n\t\tif (scriptInstance.update) {\n\t\t\tthis._updateList.remove(scriptInstance);\n\t\t}\n\n\t\tif (scriptInstance.postUpdate) {\n\t\t\tthis._postUpdateList.remove(scriptInstance);\n\t\t}\n\n\t\treturn idx;\n\t}\n\n\t_resetExecutionOrder(startIndex, scriptsLength) {\n\t\tfor (let i = startIndex; i < scriptsLength; i++) {\n\t\t\tthis._scripts[i].__executionOrder = i;\n\t\t}\n\t}\n\n\t_resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {\n\t\tif (attribute.array) {\n\t\t\tconst len = oldValue.length;\n\n\t\t\tif (!len) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newGuidArray = oldValue.slice();\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];\n\n\t\t\t\tif (duplicatedIdsMap[guid]) {\n\t\t\t\t\tnewGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnewAttributes[attributeName] = newGuidArray;\n\t\t} else {\n\t\t\tif (oldValue instanceof Entity) {\n\t\t\t\toldValue = oldValue.getGuid();\n\t\t\t} else if (typeof oldValue !== 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (duplicatedIdsMap[oldValue]) {\n\t\t\t\tnewAttributes[attributeName] = duplicatedIdsMap[oldValue];\n\t\t\t}\n\t\t}\n\t}\n\n\thas(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\treturn !!this._scriptsIndex[nameOrType];\n\t\t}\n\n\t\tif (!nameOrType) return false;\n\t\tconst scriptType = nameOrType;\n\t\tconst scriptName = scriptType.__name;\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tconst scriptInstance = scriptData && scriptData.instance;\n\t\treturn scriptInstance instanceof scriptType;\n\t}\n\n\tget(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\tconst data = this._scriptsIndex[nameOrType];\n\t\t\treturn data ? data.instance : null;\n\t\t}\n\n\t\tif (!nameOrType) return null;\n\t\tconst scriptType = nameOrType;\n\t\tconst scriptName = scriptType.__name;\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tconst scriptInstance = scriptData && scriptData.instance;\n\t\treturn scriptInstance instanceof scriptType ? scriptInstance : null;\n\t}\n\n\tcreate(nameOrType, args = {}) {\n\t\tconst self = this;\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tscriptName = scriptType.__name;\n\t\t}\n\n\t\tif (scriptType) {\n\t\t\tif (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {\n\t\t\t\tconst scriptInstance = new scriptType({\n\t\t\t\t\tapp: this.system.app,\n\t\t\t\t\tentity: this.entity,\n\t\t\t\t\tenabled: args.hasOwnProperty('enabled') ? args.enabled : true,\n\t\t\t\t\tattributes: args.attributes\n\t\t\t\t});\n\t\t\t\tconst len = this._scripts.length;\n\t\t\t\tlet ind = -1;\n\t\t\t\tif (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) ind = args.ind;\n\n\t\t\t\tthis._insertScriptInstance(scriptInstance, ind, len);\n\n\t\t\t\tthis._scriptsIndex[scriptName] = {\n\t\t\t\t\tinstance: scriptInstance,\n\t\t\t\t\tonSwap: function () {\n\t\t\t\t\t\tself.swap(scriptName);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis[scriptName] = scriptInstance;\n\t\t\t\tif (!args.preloading) scriptInstance.__initializeAttributes();\n\t\t\t\tthis.fire('create', scriptName, scriptInstance);\n\t\t\t\tthis.fire('create:' + scriptName, scriptInstance);\n\t\t\t\tthis.system.app.scripts.on('swap:' + scriptName, this._scriptsIndex[scriptName].onSwap);\n\n\t\t\t\tif (!args.preloading) {\n\t\t\t\t\tif (scriptInstance.enabled && !scriptInstance._initialized) {\n\t\t\t\t\t\tscriptInstance._initialized = true;\n\t\t\t\t\t\tif (scriptInstance.initialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.initialize);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scriptInstance.enabled && !scriptInstance._postInitialized) {\n\t\t\t\t\t\tscriptInstance._postInitialized = true;\n\t\t\t\t\t\tif (scriptInstance.postInitialize) this._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.postInitialize);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn scriptInstance;\n\t\t\t}\n\n\t\t\tconsole.warn(`script '${scriptName}' is already added to entity '${this.entity.name}'`);\n\t\t} else {\n\t\t\tthis._scriptsIndex[scriptName] = {\n\t\t\t\tawaiting: true,\n\t\t\t\tind: this._scripts.length\n\t\t\t};\n\t\t\tconsole.warn(`script '${scriptName}' is not found, awaiting it to be added to registry`);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdestroy(nameOrType) {\n\t\tlet scriptName = nameOrType;\n\t\tlet scriptType = nameOrType;\n\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tscriptName = scriptType.__name;\n\t\t}\n\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tdelete this._scriptsIndex[scriptName];\n\t\tif (!scriptData) return false;\n\t\tconst scriptInstance = scriptData.instance;\n\n\t\tif (scriptInstance && !scriptInstance._destroyed) {\n\t\t\tscriptInstance.enabled = false;\n\t\t\tscriptInstance._destroyed = true;\n\n\t\t\tif (!this._isLoopingThroughScripts) {\n\t\t\t\tconst ind = this._removeScriptInstance(scriptInstance);\n\n\t\t\t\tif (ind >= 0) {\n\t\t\t\t\tthis._resetExecutionOrder(ind, this._scripts.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._destroyedScripts.push(scriptInstance);\n\t\t\t}\n\t\t}\n\n\t\tthis.system.app.scripts.off('swap:' + scriptName, scriptData.onSwap);\n\t\tdelete this[scriptName];\n\t\tthis.fire('destroy', scriptName, scriptInstance || null);\n\t\tthis.fire('destroy:' + scriptName, scriptInstance || null);\n\t\tif (scriptInstance) scriptInstance.fire('destroy');\n\t\treturn true;\n\t}\n\n\tswap(nameOrType) {\n\t\tlet scriptName = nameOrType;\n\t\tlet scriptType = nameOrType;\n\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tscriptName = scriptType.__name;\n\t\t}\n\n\t\tconst old = this._scriptsIndex[scriptName];\n\t\tif (!old || !old.instance) return false;\n\t\tconst scriptInstanceOld = old.instance;\n\n\t\tconst ind = this._scripts.indexOf(scriptInstanceOld);\n\n\t\tconst scriptInstance = new scriptType({\n\t\t\tapp: this.system.app,\n\t\t\tentity: this.entity,\n\t\t\tenabled: scriptInstanceOld.enabled,\n\t\t\tattributes: scriptInstanceOld.__attributes\n\t\t});\n\t\tif (!scriptInstance.swap) return false;\n\n\t\tscriptInstance.__initializeAttributes();\n\n\t\tthis._scripts[ind] = scriptInstance;\n\t\tthis._scriptsIndex[scriptName].instance = scriptInstance;\n\t\tthis[scriptName] = scriptInstance;\n\t\tscriptInstance.__executionOrder = ind;\n\n\t\tif (scriptInstanceOld.update) {\n\t\t\tthis._updateList.remove(scriptInstanceOld);\n\t\t}\n\n\t\tif (scriptInstanceOld.postUpdate) {\n\t\t\tthis._postUpdateList.remove(scriptInstanceOld);\n\t\t}\n\n\t\tif (scriptInstance.update) {\n\t\t\tthis._updateList.insert(scriptInstance);\n\t\t}\n\n\t\tif (scriptInstance.postUpdate) {\n\t\t\tthis._postUpdateList.insert(scriptInstance);\n\t\t}\n\n\t\tthis._scriptMethod(scriptInstance, ScriptComponent.scriptMethods.swap, scriptInstanceOld);\n\n\t\tthis.fire('swap', scriptName, scriptInstance);\n\t\tthis.fire('swap:' + scriptName, scriptInstance);\n\t\treturn true;\n\t}\n\n\tresolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {\n\t\tconst newScriptComponent = this.entity.script;\n\n\t\tfor (const scriptName in oldScriptComponent._scriptsIndex) {\n\t\t\tconst scriptType = this.system.app.scripts.get(scriptName);\n\n\t\t\tif (!scriptType) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst script = oldScriptComponent._scriptsIndex[scriptName];\n\n\t\t\tif (!script || !script.instance) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;\n\t\t\tconst newAttributes = newScriptComponent[scriptName].__attributes;\n\n\t\t\tif (!newAttributesRaw && !newAttributes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst useGuid = !!newAttributesRaw;\n\t\t\tconst oldAttributes = script.instance.__attributes;\n\n\t\t\tfor (const attributeName in oldAttributes) {\n\t\t\t\tif (!oldAttributes[attributeName]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst attribute = scriptType.attributes.get(attributeName);\n\n\t\t\t\tif (!attribute) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (attribute.type === 'entity') {\n\t\t\t\t\tthis._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);\n\t\t\t\t} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {\n\t\t\t\t\tconst oldValue = oldAttributes[attributeName];\n\t\t\t\t\tconst newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];\n\n\t\t\t\t\tfor (let i = 0; i < attribute.schema.length; i++) {\n\t\t\t\t\t\tconst field = attribute.schema[i];\n\n\t\t\t\t\t\tif (field.type !== 'entity') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (attribute.array) {\n\t\t\t\t\t\t\tfor (let j = 0; j < oldValue.length; j++) {\n\t\t\t\t\t\t\t\tthis._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmove(nameOrType, ind) {\n\t\tconst len = this._scripts.length;\n\t\tif (ind >= len || ind < 0) return false;\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\n\t\tif (typeof scriptName !== 'string') {\n\t\t\tscriptName = nameOrType.__name;\n\t\t} else {\n\t\t\tscriptType = null;\n\t\t}\n\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tif (!scriptData || !scriptData.instance) return false;\n\t\tconst scriptInstance = scriptData.instance;\n\t\tif (scriptType && !(scriptInstance instanceof scriptType)) return false;\n\n\t\tconst indOld = this._scripts.indexOf(scriptInstance);\n\n\t\tif (indOld === -1 || indOld === ind) return false;\n\n\t\tthis._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);\n\n\t\tthis._resetExecutionOrder(0, len);\n\n\t\tthis._updateList.sort();\n\n\t\tthis._postUpdateList.sort();\n\n\t\tthis.fire('move', scriptName, scriptInstance, ind, indOld);\n\t\tthis.fire('move:' + scriptName, scriptInstance, ind, indOld);\n\t\treturn true;\n\t}\n\n}\n\nScriptComponent.scriptMethods = {\n\tinitialize: 'initialize',\n\tpostInitialize: 'postInitialize',\n\tupdate: 'update',\n\tpostUpdate: 'postUpdate',\n\tswap: 'swap'\n};\n\nconst funcNameRegex = new RegExp('^\\\\s*function(?:\\\\s|\\\\s*\\\\/\\\\*.*\\\\*\\\\/\\\\s*)+([^\\\\(\\\\s\\\\/]*)\\\\s*');\n\nclass ScriptType extends EventHandler {\n\tconstructor(args) {\n\t\tsuper();\n\t\tthis.initialize = void 0;\n\t\tthis.postInitialize = void 0;\n\t\tthis.update = void 0;\n\t\tthis.postUpdate = void 0;\n\t\tthis.swap = void 0;\n\t\tthis.initScriptType(args);\n\t}\n\n\tset enabled(value) {\n\t\tthis._enabled = !!value;\n\t\tif (this.enabled === this._enabledOld) return;\n\t\tthis._enabledOld = this.enabled;\n\t\tthis.fire(this.enabled ? 'enable' : 'disable');\n\t\tthis.fire('state', this.enabled);\n\n\t\tif (!this._initialized && this.enabled) {\n\t\t\tthis._initialized = true;\n\n\t\t\tthis.__initializeAttributes(true);\n\n\t\t\tif (this.initialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.initialize);\n\t\t}\n\n\t\tif (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {\n\t\t\tthis._postInitialized = true;\n\t\t\tif (this.postInitialize) this.entity.script._scriptMethod(this, ScriptComponent.scriptMethods.postInitialize);\n\t\t}\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;\n\t}\n\n\tinitScriptType(args) {\n\t\tconst script = this.constructor;\n\t\tthis.app = args.app;\n\t\tthis.entity = args.entity;\n\t\tthis._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;\n\t\tthis._enabledOld = this.enabled;\n\t\tthis.__destroyed = false;\n\t\tthis.__attributes = {};\n\t\tthis.__attributesRaw = args.attributes || {};\n\t\tthis.__scriptType = script;\n\t\tthis.__executionOrder = -1;\n\t}\n\n\tstatic __getScriptName(constructorFn) {\n\t\tif (typeof constructorFn !== 'function') return undefined;\n\t\tif ('name' in Function.prototype) return constructorFn.name;\n\t\tif (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';\n\t\tconst match = (\"\" + constructorFn).match(funcNameRegex);\n\t\treturn match ? match[1] : undefined;\n\t}\n\n\tstatic get scriptName() {\n\t\treturn this.__name;\n\t}\n\n\tstatic get attributes() {\n\t\tif (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);\n\t\treturn this.__attributes;\n\t}\n\n\t__initializeAttributes(force) {\n\t\tif (!force && !this.__attributesRaw) return;\n\n\t\tfor (const key in this.__scriptType.attributes.index) {\n\t\t\tif (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {\n\t\t\t\tthis[key] = this.__attributesRaw[key];\n\t\t\t} else if (!this.__attributes.hasOwnProperty(key)) {\n\t\t\t\tif (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {\n\t\t\t\t\tthis[key] = this.__scriptType.attributes.index[key].default;\n\t\t\t\t} else {\n\t\t\t\t\tthis[key] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.__attributesRaw = null;\n\t}\n\n\tstatic extend(methods) {\n\t\tfor (const key in methods) {\n\t\t\tif (!methods.hasOwnProperty(key)) continue;\n\t\t\tthis.prototype[key] = methods[key];\n\t\t}\n\t}\n\n}\n\nScriptType.__name = null;\n\nclass ScriptRegistry extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.app = app;\n\t\tthis._scripts = {};\n\t\tthis._list = [];\n\t}\n\n\tdestroy() {\n\t\tthis.app = null;\n\t\tthis.off();\n\t}\n\n\tadd(script) {\n\t\tconst scriptName = script.__name;\n\n\t\tif (this._scripts.hasOwnProperty(scriptName)) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (script.prototype.swap) {\n\t\t\t\t\tconst old = this._scripts[scriptName];\n\n\t\t\t\t\tconst ind = this._list.indexOf(old);\n\n\t\t\t\t\tthis._list[ind] = script;\n\t\t\t\t\tthis._scripts[scriptName] = script;\n\t\t\t\t\tthis.fire('swap', scriptName, script);\n\t\t\t\t\tthis.fire('swap:' + scriptName, script);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`script registry already has '${scriptName}' script, define 'swap' method for new script type to enable code hot swapping`);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._scripts[scriptName] = script;\n\n\t\tthis._list.push(script);\n\n\t\tthis.fire('add', scriptName, script);\n\t\tthis.fire('add:' + scriptName, script);\n\t\tsetTimeout(() => {\n\t\t\tif (!this._scripts.hasOwnProperty(scriptName)) return;\n\n\t\t\tif (!this.app || !this.app.systems || !this.app.systems.script) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst components = this.app.systems.script._components;\n\t\t\tlet attributes;\n\t\t\tconst scriptInstances = [];\n\t\t\tconst scriptInstancesInitialized = [];\n\n\t\t\tfor (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {\n\t\t\t\tconst component = components.items[components.loopIndex];\n\n\t\t\t\tif (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {\n\t\t\t\t\tif (component._scriptsData && component._scriptsData[scriptName]) attributes = component._scriptsData[scriptName].attributes;\n\t\t\t\t\tconst scriptInstance = component.create(scriptName, {\n\t\t\t\t\t\tpreloading: true,\n\t\t\t\t\t\tind: component._scriptsIndex[scriptName].ind,\n\t\t\t\t\t\tattributes: attributes\n\t\t\t\t\t});\n\t\t\t\t\tif (scriptInstance) scriptInstances.push(scriptInstance);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < scriptInstances.length; i++) scriptInstances[i].__initializeAttributes();\n\n\t\t\tfor (let i = 0; i < scriptInstances.length; i++) {\n\t\t\t\tif (scriptInstances[i].enabled) {\n\t\t\t\t\tscriptInstances[i]._initialized = true;\n\t\t\t\t\tscriptInstancesInitialized.push(scriptInstances[i]);\n\t\t\t\t\tif (scriptInstances[i].initialize) scriptInstances[i].initialize();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < scriptInstancesInitialized.length; i++) {\n\t\t\t\tif (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tscriptInstancesInitialized[i]._postInitialized = true;\n\t\t\t\tif (scriptInstancesInitialized[i].postInitialize) scriptInstancesInitialized[i].postInitialize();\n\t\t\t}\n\t\t});\n\t\treturn true;\n\t}\n\n\tremove(nameOrType) {\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\n\t\tif (typeof scriptName !== 'string') {\n\t\t\tscriptName = scriptType.__name;\n\t\t} else {\n\t\t\tscriptType = this.get(scriptName);\n\t\t}\n\n\t\tif (this.get(scriptName) !== scriptType) return false;\n\t\tdelete this._scripts[scriptName];\n\n\t\tconst ind = this._list.indexOf(scriptType);\n\n\t\tthis._list.splice(ind, 1);\n\n\t\tthis.fire('remove', scriptName, scriptType);\n\t\tthis.fire('remove:' + scriptName, scriptType);\n\t\treturn true;\n\t}\n\n\tget(name) {\n\t\treturn this._scripts[name] || null;\n\t}\n\n\thas(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\treturn this._scripts.hasOwnProperty(nameOrType);\n\t\t}\n\n\t\tif (!nameOrType) return false;\n\t\tconst scriptName = nameOrType.__name;\n\t\treturn this._scripts[scriptName] === nameOrType;\n\t}\n\n\tlist() {\n\t\treturn this._list;\n\t}\n\n}\n\nclass I18nParser {\n\t_validate(data) {\n\t\tif (!data.header) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"header\" field');\n\t\t}\n\n\t\tif (!data.header.version) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"header.version\" field');\n\t\t}\n\n\t\tif (data.header.version !== 1) {\n\t\t\tthrow new Error('pc.I18n#addData: Invalid \"header.version\" field');\n\t\t}\n\n\t\tif (!data.data) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"data\" field');\n\t\t} else if (!Array.isArray(data.data)) {\n\t\t\tthrow new Error('pc.I18n#addData: \"data\" field must be an array');\n\t\t}\n\n\t\tfor (let i = 0, len = data.data.length; i < len; i++) {\n\t\t\tconst entry = data.data[i];\n\n\t\t\tif (!entry.info) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].info\" field`);\n\t\t\t}\n\n\t\t\tif (!entry.info.locale) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].info.locale\" field`);\n\t\t\t}\n\n\t\t\tif (typeof entry.info.locale !== 'string') {\n\t\t\t\tthrow new Error(`pc.I18n#addData: \"data[${i}].info.locale\" must be a string`);\n\t\t\t}\n\n\t\t\tif (!entry.messages) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].messages\" field`);\n\t\t\t}\n\t\t}\n\t}\n\n\tparse(data) {\n\t\treturn data.data;\n\t}\n\n}\n\nclass I18n extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.locale = DEFAULT_LOCALE;\n\t\tthis._translations = {};\n\t\tthis._availableLangs = {};\n\t\tthis._app = app;\n\t\tthis._assets = [];\n\t\tthis._parser = new I18nParser();\n\t}\n\n\tset assets(value) {\n\t\tconst index = {};\n\n\t\tfor (let _i = 0, len = value.length; _i < len; _i++) {\n\t\t\tconst id = value[_i] instanceof Asset ? value[_i].id : value[_i];\n\t\t\tindex[id] = true;\n\t\t}\n\n\t\tlet i = this._assets.length;\n\n\t\twhile (i--) {\n\t\t\tconst id = this._assets[i];\n\n\t\t\tif (!index[id]) {\n\t\t\t\tthis._app.assets.off('add:' + id, this._onAssetAdd, this);\n\n\t\t\t\tconst asset = this._app.assets.get(id);\n\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis._onAssetRemove(asset);\n\t\t\t\t}\n\n\t\t\t\tthis._assets.splice(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tfor (const id in index) {\n\t\t\tconst idNum = parseInt(id, 10);\n\t\t\tif (this._assets.indexOf(idNum) !== -1) continue;\n\n\t\t\tthis._assets.push(idNum);\n\n\t\t\tconst asset = this._app.assets.get(idNum);\n\n\t\t\tif (!asset) {\n\t\t\t\tthis._app.assets.once('add:' + idNum, this._onAssetAdd, this);\n\t\t\t} else {\n\t\t\t\tthis._onAssetAdd(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\tget assets() {\n\t\treturn this._assets;\n\t}\n\n\tset locale(value) {\n\t\tif (this._locale === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet lang = getLang(value);\n\n\t\tif (lang === 'in') {\n\t\t\tlang = 'id';\n\t\t\tvalue = replaceLang(value, lang);\n\n\t\t\tif (this._locale === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst old = this._locale;\n\t\tthis._locale = value;\n\t\tthis._lang = lang;\n\t\tthis._pluralFn = getPluralFn(this._lang);\n\t\tthis.fire('set:locale', value, old);\n\t}\n\n\tget locale() {\n\t\treturn this._locale;\n\t}\n\n\tstatic findAvailableLocale(desiredLocale, availableLocales) {\n\t\treturn findAvailableLocale(desiredLocale, availableLocales);\n\t}\n\n\tfindAvailableLocale(desiredLocale) {\n\t\tif (this._translations[desiredLocale]) {\n\t\t\treturn desiredLocale;\n\t\t}\n\n\t\tconst lang = getLang(desiredLocale);\n\t\treturn this._findFallbackLocale(desiredLocale, lang);\n\t}\n\n\tgetText(key, locale) {\n\t\tlet result = key;\n\t\tlet lang;\n\n\t\tif (!locale) {\n\t\t\tlocale = this._locale;\n\t\t\tlang = this._lang;\n\t\t}\n\n\t\tlet translations = this._translations[locale];\n\n\t\tif (!translations) {\n\t\t\tif (!lang) {\n\t\t\t\tlang = getLang(locale);\n\t\t\t}\n\n\t\t\tlocale = this._findFallbackLocale(locale, lang);\n\t\t\ttranslations = this._translations[locale];\n\t\t}\n\n\t\tif (translations && translations.hasOwnProperty(key)) {\n\t\t\tresult = translations[key];\n\n\t\t\tif (Array.isArray(result)) {\n\t\t\t\tresult = result[0];\n\t\t\t}\n\n\t\t\tif (result === null || result === undefined) {\n\t\t\t\tresult = key;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tgetPluralText(key, n, locale) {\n\t\tlet result = key;\n\t\tlet lang;\n\t\tlet pluralFn;\n\n\t\tif (!locale) {\n\t\t\tlocale = this._locale;\n\t\t\tlang = this._lang;\n\t\t\tpluralFn = this._pluralFn;\n\t\t} else {\n\t\t\tlang = getLang(locale);\n\t\t\tpluralFn = getPluralFn(lang);\n\t\t}\n\n\t\tlet translations = this._translations[locale];\n\n\t\tif (!translations) {\n\t\t\tlocale = this._findFallbackLocale(locale, lang);\n\t\t\tlang = getLang(locale);\n\t\t\tpluralFn = getPluralFn(lang);\n\t\t\ttranslations = this._translations[locale];\n\t\t}\n\n\t\tif (translations && translations[key] && pluralFn) {\n\t\t\tconst index = pluralFn(n);\n\t\t\tresult = translations[key][index];\n\n\t\t\tif (result === null || result === undefined) {\n\t\t\t\tresult = key;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\taddData(data) {\n\t\tlet parsed;\n\n\t\ttry {\n\t\t\tparsed = this._parser.parse(data);\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0, len = parsed.length; i < len; i++) {\n\t\t\tconst entry = parsed[i];\n\t\t\tconst locale = entry.info.locale;\n\t\t\tconst messages = entry.messages;\n\n\t\t\tif (!this._translations[locale]) {\n\t\t\t\tthis._translations[locale] = {};\n\t\t\t\tconst lang = getLang(locale);\n\n\t\t\t\tif (!this._availableLangs[lang]) {\n\t\t\t\t\tthis._availableLangs[lang] = locale;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject.assign(this._translations[locale], messages);\n\t\t\tthis.fire('data:add', locale, messages);\n\t\t}\n\t}\n\n\tremoveData(data) {\n\t\tlet parsed;\n\n\t\ttry {\n\t\t\tparsed = this._parser.parse(data);\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0, len = parsed.length; i < len; i++) {\n\t\t\tconst entry = parsed[i];\n\t\t\tconst locale = entry.info.locale;\n\t\t\tconst translations = this._translations[locale];\n\t\t\tif (!translations) continue;\n\t\t\tconst messages = entry.messages;\n\n\t\t\tfor (const key in messages) {\n\t\t\t\tdelete translations[key];\n\t\t\t}\n\n\t\t\tif (Object.keys(translations).length === 0) {\n\t\t\t\tdelete this._translations[locale];\n\t\t\t\tdelete this._availableLangs[getLang(locale)];\n\t\t\t}\n\n\t\t\tthis.fire('data:remove', locale, messages);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._translations = null;\n\t\tthis._availableLangs = null;\n\t\tthis._assets = null;\n\t\tthis._parser = null;\n\t\tthis.off();\n\t}\n\n\t_findFallbackLocale(locale, lang) {\n\t\tlet result = DEFAULT_LOCALE_FALLBACKS[locale];\n\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = DEFAULT_LOCALE_FALLBACKS[lang];\n\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this._availableLangs[lang];\n\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn DEFAULT_LOCALE;\n\t}\n\n\t_onAssetAdd(asset) {\n\t\tasset.on('load', this._onAssetLoad, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t\tasset.on('remove', this._onAssetRemove, this);\n\t\tasset.on('unload', this._onAssetUnload, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onAssetLoad(asset);\n\t\t}\n\t}\n\n\t_onAssetLoad(asset) {\n\t\tthis.addData(asset.resource);\n\t}\n\n\t_onAssetChange(asset) {\n\t\tif (asset.resource) {\n\t\t\tthis.addData(asset.resource);\n\t\t}\n\t}\n\n\t_onAssetRemove(asset) {\n\t\tasset.off('load', this._onAssetLoad, this);\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.off('remove', this._onAssetRemove, this);\n\t\tasset.off('unload', this._onAssetUnload, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis.removeData(asset.resource);\n\t\t}\n\n\t\tthis._app.assets.once('add:' + asset.id, this._onAssetAdd, this);\n\t}\n\n\t_onAssetUnload(asset) {\n\t\tif (asset.resource) {\n\t\t\tthis.removeData(asset.resource);\n\t\t}\n\t}\n\n}\n\nconst FILLMODE_NONE = 'NONE';\nconst FILLMODE_FILL_WINDOW = 'FILL_WINDOW';\nconst FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';\nconst RESOLUTION_AUTO = 'AUTO';\nconst RESOLUTION_FIXED = 'FIXED';\n\nclass VrDisplay extends EventHandler {\n\tconstructor(app, display) {\n\t\tsuper();\n\t\tthis._app = app;\n\t\tthis._device = app.graphicsDevice;\n\t\tthis.id = display.displayId;\n\t\tthis._frameData = null;\n\n\t\tif (window.VRFrameData) {\n\t\t\tthis._frameData = new window.VRFrameData();\n\t\t}\n\n\t\tthis.display = display;\n\t\tthis._camera = null;\n\t\tthis.sitToStandInv = new Mat4();\n\t\tthis.leftView = new Mat4();\n\t\tthis.leftProj = new Mat4();\n\t\tthis.leftViewInv = new Mat4();\n\t\tthis.leftPos = new Vec3();\n\t\tthis.rightView = new Mat4();\n\t\tthis.rightProj = new Mat4();\n\t\tthis.rightViewInv = new Mat4();\n\t\tthis.rightPos = new Vec3();\n\t\tthis.combinedPos = new Vec3();\n\t\tthis.combinedView = new Mat4();\n\t\tthis.combinedProj = new Mat4();\n\t\tthis.combinedViewInv = new Mat4();\n\t\tthis.combinedFov = 0;\n\t\tthis.combinedAspect = 0;\n\t\tthis.presenting = false;\n\n\t\tthis._presentChange = event => {\n\t\t\tlet display;\n\n\t\t\tif (event.display) {\n\t\t\t\tdisplay = event.display;\n\t\t\t} else if (event.detail && event.detail.display) {\n\t\t\t\tdisplay = event.detail.display;\n\t\t\t} else if (event.detail && event.detail.vrdisplay) {\n\t\t\t\tdisplay = event.detail.vrdisplay;\n\t\t\t} else {\n\t\t\t\tdisplay = this.display;\n\t\t\t}\n\n\t\t\tif (display === this.display) {\n\t\t\t\tthis.presenting = this.display && this.display.isPresenting;\n\n\t\t\t\tif (this.presenting) {\n\t\t\t\t\tconst leftEye = this.display.getEyeParameters(\"left\");\n\t\t\t\t\tconst rightEye = this.display.getEyeParameters(\"right\");\n\t\t\t\t\tconst w = Math.max(leftEye.renderWidth, rightEye.renderWidth) * 2;\n\t\t\t\t\tconst h = Math.max(leftEye.renderHeight, rightEye.renderHeight);\n\n\t\t\t\t\tthis._app.graphicsDevice.setResolution(w, h);\n\n\t\t\t\t\tthis._app._allowResize = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis._app.setCanvasResolution(RESOLUTION_AUTO);\n\n\t\t\t\t\tthis._app._allowResize = true;\n\t\t\t\t}\n\n\t\t\t\tthis.fire('beforepresentchange', this);\n\t\t\t\tthis.fire('presentchange', this);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener('vrdisplaypresentchange', this._presentChange, false);\n\t}\n\n\tdestroy() {\n\t\twindow.removeEventListener('vrdisplaypresentchange', this._presentChange);\n\t\tif (this._camera) this._camera.vrDisplay = null;\n\t\tthis._camera = null;\n\t}\n\n\tpoll() {\n\t\tif (this.display) {\n\t\t\tthis.display.getFrameData(this._frameData);\n\t\t\tthis.leftProj.data = this._frameData.leftProjectionMatrix;\n\t\t\tthis.rightProj.data = this._frameData.rightProjectionMatrix;\n\t\t\tconst stage = this.display.stageParameters;\n\n\t\t\tif (stage) {\n\t\t\t\tthis.sitToStandInv.set(stage.sittingToStandingTransform).invert();\n\t\t\t\tthis.combinedView.set(this._frameData.leftViewMatrix);\n\t\t\t\tthis.leftView.mul2(this.combinedView, this.sitToStandInv);\n\t\t\t\tthis.combinedView.set(this._frameData.rightViewMatrix);\n\t\t\t\tthis.rightView.mul2(this.combinedView, this.sitToStandInv);\n\t\t\t} else {\n\t\t\t\tthis.leftView.set(this._frameData.leftViewMatrix);\n\t\t\t\tthis.rightView.set(this._frameData.rightViewMatrix);\n\t\t\t}\n\n\t\t\tlet nx = this.leftProj.data[3] + this.leftProj.data[0];\n\t\t\tlet nz = this.leftProj.data[11] + this.leftProj.data[8];\n\t\t\tlet l = 1.0 / Math.sqrt(nx * nx + nz * nz);\n\t\t\tnx *= l;\n\t\t\tnz *= l;\n\t\t\tlet maxFov = -Math.atan2(nz, nx);\n\t\t\tnx = this.rightProj.data[3] + this.rightProj.data[0];\n\t\t\tnz = this.rightProj.data[11] + this.rightProj.data[8];\n\t\t\tl = 1.0 / Math.sqrt(nx * nx + nz * nz);\n\t\t\tnx *= l;\n\t\t\tnz *= l;\n\t\t\tmaxFov = Math.max(maxFov, -Math.atan2(nz, nx));\n\t\t\tmaxFov *= 2.0;\n\t\t\tthis.combinedFov = maxFov;\n\t\t\tconst aspect = this.rightProj.data[5] / this.rightProj.data[0];\n\t\t\tthis.combinedAspect = aspect;\n\t\t\tconst view = this.combinedView;\n\t\t\tview.copy(this.leftView);\n\t\t\tview.invert();\n\t\t\tthis.leftViewInv.copy(view);\n\t\t\tconst pos = this.combinedPos;\n\t\t\tpos.x = this.leftPos.x = view.data[12];\n\t\t\tpos.y = this.leftPos.y = view.data[13];\n\t\t\tpos.z = this.leftPos.z = view.data[14];\n\t\t\tview.copy(this.rightView);\n\t\t\tview.invert();\n\t\t\tthis.rightViewInv.copy(view);\n\t\t\tconst deltaX = pos.x - view.data[12];\n\t\t\tconst deltaY = pos.y - view.data[13];\n\t\t\tconst deltaZ = pos.z - view.data[14];\n\t\t\tconst dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);\n\t\t\tthis.rightPos.x = view.data[12];\n\t\t\tthis.rightPos.y = view.data[13];\n\t\t\tthis.rightPos.z = view.data[14];\n\t\t\tpos.x += view.data[12];\n\t\t\tpos.y += view.data[13];\n\t\t\tpos.z += view.data[14];\n\t\t\tpos.x *= 0.5;\n\t\t\tpos.y *= 0.5;\n\t\t\tpos.z *= 0.5;\n\t\t\tconst b = Math.PI * 0.5;\n\t\t\tconst c = maxFov * 0.5;\n\t\t\tconst a = Math.PI - (b + c);\n\t\t\tconst offset = dist * 0.5 * Math.sin(a);\n\t\t\tconst fwdX = view.data[8];\n\t\t\tconst fwdY = view.data[9];\n\t\t\tconst fwdZ = view.data[10];\n\t\t\tview.data[12] = pos.x + fwdX * offset;\n\t\t\tview.data[13] = pos.y + fwdY * offset;\n\t\t\tview.data[14] = pos.z + fwdZ * offset;\n\t\t\tthis.combinedViewInv.copy(view);\n\t\t\tview.invert();\n\t\t\tthis.combinedProj.setPerspective(maxFov * math.RAD_TO_DEG, aspect, this.display.depthNear + offset, this.display.depthFar + offset, true);\n\t\t}\n\t}\n\n\trequestPresent(callback) {\n\t\tif (!this.display) {\n\t\t\tif (callback) callback(new Error(\"No VrDisplay to requestPresent\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.presenting) {\n\t\t\tif (callback) callback(new Error(\"VrDisplay already presenting\"));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.display.requestPresent([{\n\t\t\tsource: this._device.canvas\n\t\t}]).then(function () {\n\t\t\tif (callback) callback();\n\t\t}, function (err) {\n\t\t\tif (callback) callback(err);\n\t\t});\n\t}\n\n\texitPresent(callback) {\n\t\tif (!this.display) {\n\t\t\tif (callback) callback(new Error(\"No VrDisplay to exitPresent\"));\n\t\t}\n\n\t\tif (!this.presenting) {\n\t\t\tif (callback) callback(new Error(\"VrDisplay not presenting\"));\n\t\t\treturn;\n\t\t}\n\n\t\tthis.display.exitPresent().then(function () {\n\t\t\tif (callback) callback();\n\t\t}, function () {\n\t\t\tif (callback) callback(new Error(\"exitPresent failed\"));\n\t\t});\n\t}\n\n\trequestAnimationFrame(fn) {\n\t\tif (this.display) this.display.requestAnimationFrame(fn);\n\t}\n\n\tsubmitFrame() {\n\t\tif (this.display) this.display.submitFrame();\n\t}\n\n\treset() {\n\t\tif (this.display) this.display.resetPose();\n\t}\n\n\tsetClipPlanes(n, f) {\n\t\tif (this.display) {\n\t\t\tthis.display.depthNear = n;\n\t\t\tthis.display.depthFar = f;\n\t\t}\n\t}\n\n\tgetFrameData() {\n\t\tif (this.display) return this._frameData;\n\t}\n\n\tget capabilities() {\n\t\tif (this.display) return this.display.capabilities;\n\t\treturn {};\n\t}\n\n}\n\nclass VrManager extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.isSupported = VrManager.isSupported;\n\t\tthis._index = {};\n\t\tthis.displays = [];\n\t\tthis.display = null;\n\t\tthis._app = app;\n\t\tthis._onDisplayConnect = this._onDisplayConnect.bind(this);\n\t\tthis._onDisplayDisconnect = this._onDisplayDisconnect.bind(this);\n\n\t\tthis._attach();\n\n\t\tthis._getDisplays((err, displays) => {\n\t\t\tif (err) {\n\t\t\t\tthis.fire('error', err);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < displays.length; i++) {\n\t\t\t\t\tthis._addDisplay(displays[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.fire('ready', this.displays);\n\t\t\t}\n\t\t});\n\t}\n\n\t_attach() {\n\t\twindow.addEventListener('vrdisplayconnect', this._onDisplayConnect);\n\t\twindow.addEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);\n\t}\n\n\t_detach() {\n\t\twindow.removeEventListener('vrdisplayconnect', this._onDisplayConnect);\n\t\twindow.removeEventListener('vrdisplaydisconnect', this._onDisplayDisconnect);\n\t}\n\n\tdestroy() {\n\t\tthis._detach();\n\t}\n\n\tpoll() {\n\t\tconst l = this.displays.length;\n\t\tif (!l) return;\n\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tif (this.displays[i]._camera) this.displays[i].poll();\n\t\t}\n\t}\n\n\t_getDisplays(callback) {\n\t\tif (navigator.getVRDisplays) {\n\t\t\tnavigator.getVRDisplays().then(function (displays) {\n\t\t\t\tif (callback) callback(null, displays);\n\t\t\t});\n\t\t} else {\n\t\t\tif (callback) callback(new Error('WebVR not supported'));\n\t\t}\n\t}\n\n\t_addDisplay(vrDisplay) {\n\t\tif (this._index[vrDisplay.displayId]) return;\n\t\tconst display = new VrDisplay(this._app, vrDisplay);\n\t\tthis._index[display.id] = display;\n\t\tthis.displays.push(display);\n\t\tif (!this.display) this.display = display;\n\t\tthis.fire('displayconnect', display);\n\t}\n\n\t_onDisplayConnect(e) {\n\t\tif (e.detail && e.detail.display) {\n\t\t\tthis._addDisplay(e.detail.display);\n\t\t} else {\n\t\t\tthis._addDisplay(e.display);\n\t\t}\n\t}\n\n\t_onDisplayDisconnect(e) {\n\t\tlet id;\n\n\t\tif (e.detail && e.detail.display) {\n\t\t\tid = e.detail.display.displayId;\n\t\t} else {\n\t\t\tid = e.display.displayId;\n\t\t}\n\n\t\tconst display = this._index[id];\n\t\tif (!display) return;\n\t\tdisplay.destroy();\n\t\tdelete this._index[display.id];\n\t\tconst ind = this.displays.indexOf(display);\n\t\tthis.displays.splice(ind, 1);\n\n\t\tif (this.display === display) {\n\t\t\tif (this.displays.length) {\n\t\t\t\tthis.display = this.displays[0];\n\t\t\t} else {\n\t\t\t\tthis.display = null;\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('displaydisconnect', display);\n\t}\n\n}\n\nVrManager.isSupported = typeof navigator !== 'undefined' ? !!navigator.getVRDisplays : false;\n\nconst XRTYPE_INLINE = 'inline';\nconst XRTYPE_VR = 'immersive-vr';\nconst XRTYPE_AR = 'immersive-ar';\nconst XRSPACE_VIEWER = 'viewer';\nconst XRSPACE_LOCAL = 'local';\nconst XRSPACE_LOCALFLOOR = 'local-floor';\nconst XRSPACE_BOUNDEDFLOOR = 'bounded-floor';\nconst XRSPACE_UNBOUNDED = 'unbounded';\nconst XRTARGETRAY_GAZE = 'gaze';\nconst XRTARGETRAY_SCREEN = 'screen';\nconst XRTARGETRAY_POINTER = 'tracked-pointer';\nconst XRHAND_NONE = 'none';\nconst XRHAND_LEFT = 'left';\nconst XRHAND_RIGHT = 'right';\nconst XRTRACKABLE_POINT = 'point';\nconst XRTRACKABLE_PLANE = 'plane';\nconst XRTRACKABLE_MESH = 'mesh';\nconst XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';\nconst XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';\nconst XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';\nconst XRDEPTHSENSINGFORMAT_F32 = 'float32';\n\nconst poolVec3 = [];\nconst poolQuat = [];\n\nclass XrHitTestSource extends EventHandler {\n\tconstructor(manager, xrHitTestSource, transient) {\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis._xrHitTestSource = xrHitTestSource;\n\t\tthis._transient = transient;\n\t}\n\n\tremove() {\n\t\tif (!this._xrHitTestSource) return;\n\t\tconst sources = this.manager.hitTest.sources;\n\t\tconst ind = sources.indexOf(this);\n\t\tif (ind !== -1) sources.splice(ind, 1);\n\t\tthis.onStop();\n\t}\n\n\tonStop() {\n\t\tthis._xrHitTestSource.cancel();\n\n\t\tthis._xrHitTestSource = null;\n\t\tthis.fire('remove');\n\t\tthis.manager.hitTest.fire('remove', this);\n\t}\n\n\tupdate(frame) {\n\t\tif (this._transient) {\n\t\t\tconst transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);\n\n\t\t\tfor (let i = 0; i < transientResults.length; i++) {\n\t\t\t\tconst transientResult = transientResults[i];\n\t\t\t\tlet inputSource;\n\t\t\t\tif (transientResult.inputSource) inputSource = this.manager.input._getByInputSource(transientResult.inputSource);\n\t\t\t\tthis.updateHitResults(transientResult.results, inputSource);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.updateHitResults(frame.getHitTestResults(this._xrHitTestSource));\n\t\t}\n\t}\n\n\tupdateHitResults(results, inputSource) {\n\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\tconst pose = results[i].getPose(this.manager._referenceSpace);\n\t\t\tlet position = poolVec3.pop();\n\t\t\tif (!position) position = new Vec3();\n\t\t\tposition.copy(pose.transform.position);\n\t\t\tlet rotation = poolQuat.pop();\n\t\t\tif (!rotation) rotation = new Quat();\n\t\t\trotation.copy(pose.transform.orientation);\n\t\t\tthis.fire('result', position, rotation, inputSource);\n\t\t\tthis.manager.hitTest.fire('result', this, position, rotation, inputSource);\n\t\t\tpoolVec3.push(position);\n\t\t\tpoolQuat.push(rotation);\n\t\t}\n\t}\n\n}\n\nclass XrHitTest extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);\n\t\tthis._session = null;\n\t\tthis.sources = [];\n\n\t\tif (this._supported) {\n\t\t\tthis.manager.on('start', this._onSessionStart, this);\n\t\t\tthis.manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\n\t_onSessionStart() {\n\t\tif (this.manager.type !== XRTYPE_AR) return;\n\t\tthis._session = this.manager.session;\n\t}\n\n\t_onSessionEnd() {\n\t\tif (!this._session) return;\n\t\tthis._session = null;\n\n\t\tfor (let i = 0; i < this.sources.length; i++) {\n\t\t\tthis.sources[i].onStop();\n\t\t}\n\n\t\tthis.sources = [];\n\t}\n\n\tisAvailable(callback, fireError) {\n\t\tlet err;\n\t\tif (!this._supported) err = new Error('XR HitTest is not supported');\n\t\tif (!this._session) err = new Error('XR Session is not started (1)');\n\t\tif (this.manager.type !== XRTYPE_AR) err = new Error('XR HitTest is available only for AR');\n\n\t\tif (err) {\n\t\t\tif (callback) callback(err);\n\t\t\tif (fireError) fireError.fire('error', err);\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstart(options) {\n\t\toptions = options || {};\n\t\tif (!this.isAvailable(options.callback, this)) return;\n\t\tif (!options.profile && !options.spaceType) options.spaceType = XRSPACE_VIEWER;\n\t\tlet xrRay;\n\t\tconst offsetRay = options.offsetRay;\n\t\tif (offsetRay) xrRay = new XRRay(new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z), new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z));\n\t\tconst callback = options.callback;\n\n\t\tif (options.spaceType) {\n\t\t\tthis._session.requestReferenceSpace(options.spaceType).then(referenceSpace => {\n\t\t\t\tif (!this._session) {\n\t\t\t\t\tconst err = new Error('XR Session is not started (2)');\n\t\t\t\t\tif (callback) callback(err);\n\t\t\t\t\tthis.fire('error', err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._session.requestHitTestSource({\n\t\t\t\t\tspace: referenceSpace,\n\t\t\t\t\tentityTypes: options.entityTypes || undefined,\n\t\t\t\t\toffsetRay: xrRay\n\t\t\t\t}).then(xrHitTestSource => {\n\t\t\t\t\tthis._onHitTestSource(xrHitTestSource, false, callback);\n\t\t\t\t}).catch(ex => {\n\t\t\t\t\tif (callback) callback(ex);\n\t\t\t\t\tthis.fire('error', ex);\n\t\t\t\t});\n\t\t\t}).catch(ex => {\n\t\t\t\tif (callback) callback(ex);\n\t\t\t\tthis.fire('error', ex);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._session.requestHitTestSourceForTransientInput({\n\t\t\t\tprofile: options.profile,\n\t\t\t\tentityTypes: options.entityTypes || undefined,\n\t\t\t\toffsetRay: xrRay\n\t\t\t}).then(xrHitTestSource => {\n\t\t\t\tthis._onHitTestSource(xrHitTestSource, true, callback);\n\t\t\t}).catch(ex => {\n\t\t\t\tif (callback) callback(ex);\n\t\t\t\tthis.fire('error', ex);\n\t\t\t});\n\t\t}\n\t}\n\n\t_onHitTestSource(xrHitTestSource, transient, callback) {\n\t\tif (!this._session) {\n\t\t\txrHitTestSource.cancel();\n\t\t\tconst err = new Error('XR Session is not started (3)');\n\t\t\tif (callback) callback(err);\n\t\t\tthis.fire('error', err);\n\t\t\treturn;\n\t\t}\n\n\t\tconst hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient);\n\t\tthis.sources.push(hitTestSource);\n\t\tif (callback) callback(null, hitTestSource);\n\t\tthis.fire('add', hitTestSource);\n\t}\n\n\tupdate(frame) {\n\t\tfor (let i = 0; i < this.sources.length; i++) {\n\t\t\tthis.sources[i].update(frame);\n\t\t}\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n}\n\nclass XrFinger {\n\tconstructor(index, hand) {\n\t\tthis._index = index;\n\t\tthis._hand = hand;\n\n\t\tthis._hand._fingers.push(this);\n\n\t\tthis._joints = [];\n\t\tthis._tip = null;\n\t}\n\n\tget index() {\n\t\treturn this._index;\n\t}\n\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\n\tget joints() {\n\t\treturn this._joints;\n\t}\n\n\tget tip() {\n\t\treturn this._tip;\n\t}\n\n}\n\nconst tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];\nconst tipJointIdsIndex = {};\n\nfor (let i = 0; i < tipJointIds.length; i++) {\n\ttipJointIdsIndex[tipJointIds[i]] = true;\n}\n\nclass XrJoint {\n\tconstructor(index, id, hand, finger = null) {\n\t\tthis._index = index;\n\t\tthis._id = id;\n\t\tthis._hand = hand;\n\t\tthis._finger = finger;\n\t\tthis._wrist = id === 'wrist';\n\t\tthis._tip = this._finger && !!tipJointIdsIndex[id];\n\t\tthis._radius = null;\n\t\tthis._localTransform = new Mat4();\n\t\tthis._worldTransform = new Mat4();\n\t\tthis._localPosition = new Vec3();\n\t\tthis._localRotation = new Quat();\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._dirtyLocal = true;\n\t}\n\n\tupdate(pose) {\n\t\tthis._dirtyLocal = true;\n\t\tthis._radius = pose.radius;\n\n\t\tthis._localPosition.copy(pose.transform.position);\n\n\t\tthis._localRotation.copy(pose.transform.orientation);\n\t}\n\n\t_updateTransforms() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = false;\n\n\t\t\tthis._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);\n\t\t}\n\n\t\tconst manager = this._hand._manager;\n\t\tconst parent = manager.camera.parent;\n\n\t\tif (parent) {\n\t\t\tthis._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);\n\t\t} else {\n\t\t\tthis._worldTransform.copy(this._localTransform);\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\tthis._updateTransforms();\n\n\t\tthis._worldTransform.getTranslation(this._position);\n\n\t\treturn this._position;\n\t}\n\n\tgetRotation() {\n\t\tthis._updateTransforms();\n\n\t\tthis._rotation.setFromMat4(this._worldTransform);\n\n\t\treturn this._rotation;\n\t}\n\n\tget index() {\n\t\treturn this._index;\n\t}\n\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\n\tget finger() {\n\t\treturn this._finger;\n\t}\n\n\tget wrist() {\n\t\treturn this._wrist;\n\t}\n\n\tget tip() {\n\t\treturn this._tip;\n\t}\n\n\tget radius() {\n\t\treturn this._radius || 0.005;\n\t}\n\n}\n\nlet fingerJointIds = [];\nconst vecA$2 = new Vec3();\nconst vecB$2 = new Vec3();\nconst vecC = new Vec3();\n\nif (platform.browser && window.XRHand) {\n\tfingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];\n}\n\nclass XrHand extends EventHandler {\n\tconstructor(inputSource) {\n\t\tsuper();\n\t\tconst xrHand = inputSource._xrInputSource.hand;\n\t\tthis._manager = inputSource._manager;\n\t\tthis._inputSource = inputSource;\n\t\tthis._tracking = false;\n\t\tthis._fingers = [];\n\t\tthis._joints = [];\n\t\tthis._jointsById = {};\n\t\tthis._tips = [];\n\t\tthis._wrist = null;\n\n\t\tif (xrHand.get('wrist')) {\n\t\t\tconst joint = new XrJoint(0, 'wrist', this, null);\n\t\t\tthis._wrist = joint;\n\n\t\t\tthis._joints.push(joint);\n\n\t\t\tthis._jointsById.wrist = joint;\n\t\t}\n\n\t\tfor (let f = 0; f < fingerJointIds.length; f++) {\n\t\t\tconst finger = new XrFinger(f, this);\n\n\t\t\tfor (let j = 0; j < fingerJointIds[f].length; j++) {\n\t\t\t\tconst jointId = fingerJointIds[f][j];\n\t\t\t\tif (!xrHand.get(jointId)) continue;\n\t\t\t\tconst joint = new XrJoint(j, jointId, this, finger);\n\n\t\t\t\tthis._joints.push(joint);\n\n\t\t\t\tthis._jointsById[jointId] = joint;\n\n\t\t\t\tif (joint.tip) {\n\t\t\t\t\tthis._tips.push(joint);\n\n\t\t\t\t\tfinger._tip = joint;\n\t\t\t\t}\n\n\t\t\t\tfinger._joints.push(joint);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate(frame) {\n\t\tconst xrInputSource = this._inputSource._xrInputSource;\n\n\t\tfor (let j = 0; j < this._joints.length; j++) {\n\t\t\tconst joint = this._joints[j];\n\t\t\tconst jointSpace = xrInputSource.hand.get(joint._id);\n\n\t\t\tif (jointSpace) {\n\t\t\t\tlet pose;\n\t\t\t\tif (frame.session.visibilityState !== 'hidden') pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);\n\n\t\t\t\tif (pose) {\n\t\t\t\t\tjoint.update(pose);\n\n\t\t\t\t\tif (joint.wrist && !this._tracking) {\n\t\t\t\t\t\tthis._tracking = true;\n\t\t\t\t\t\tthis.fire('tracking');\n\t\t\t\t\t}\n\t\t\t\t} else if (joint.wrist) {\n\t\t\t\t\tif (this._tracking) {\n\t\t\t\t\t\tthis._tracking = false;\n\t\t\t\t\t\tthis.fire('trackinglost');\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst j1 = this._jointsById['thumb-metacarpal'];\n\t\tconst j4 = this._jointsById['thumb-tip'];\n\t\tconst j6 = this._jointsById['index-finger-phalanx-proximal'];\n\t\tconst j9 = this._jointsById['index-finger-tip'];\n\t\tconst j16 = this._jointsById['ring-finger-phalanx-proximal'];\n\t\tconst j21 = this._jointsById['pinky-finger-phalanx-proximal'];\n\n\t\tif (j1 && j4 && j6 && j9 && j16 && j21) {\n\t\t\tthis._inputSource._dirtyRay = true;\n\n\t\t\tthis._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);\n\n\t\t\tlet jointL = j1;\n\t\t\tlet jointR = j21;\n\n\t\t\tif (this._inputSource.handedness === XRHAND_LEFT) {\n\t\t\t\tconst t = jointL;\n\t\t\t\tjointL = jointR;\n\t\t\t\tjointR = t;\n\t\t\t}\n\n\t\t\tvecA$2.sub2(jointL._localPosition, this._wrist._localPosition);\n\t\t\tvecB$2.sub2(jointR._localPosition, this._wrist._localPosition);\n\t\t\tvecC.cross(vecA$2, vecB$2).normalize();\n\t\t\tvecA$2.lerp(j6._localPosition, j16._localPosition, 0.5);\n\t\t\tvecA$2.sub(this._wrist._localPosition).normalize();\n\n\t\t\tthis._inputSource._rayLocal.direction.lerp(vecC, vecA$2, 0.5).normalize();\n\t\t}\n\n\t\tconst squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);\n\n\t\tif (squeezing) {\n\t\t\tif (!this._inputSource._squeezing) {\n\t\t\t\tthis._inputSource._squeezing = true;\n\n\t\t\t\tthis._inputSource.fire('squeezestart');\n\n\t\t\t\tthis._manager.input.fire('squeezestart', this._inputSource);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._inputSource._squeezing) {\n\t\t\t\tthis._inputSource._squeezing = false;\n\n\t\t\t\tthis._inputSource.fire('squeeze');\n\n\t\t\t\tthis._manager.input.fire('squeeze', this._inputSource);\n\n\t\t\t\tthis._inputSource.fire('squeezeend');\n\n\t\t\t\tthis._manager.input.fire('squeezeend', this._inputSource);\n\t\t\t}\n\t\t}\n\t}\n\n\t_fingerIsClosed(index) {\n\t\tconst finger = this._fingers[index];\n\t\tvecA$2.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();\n\t\tvecB$2.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();\n\t\treturn vecA$2.dot(vecB$2) < -0.8;\n\t}\n\n\tgetJointById(id) {\n\t\treturn this._jointsById[id] || null;\n\t}\n\n\tget fingers() {\n\t\treturn this._fingers;\n\t}\n\n\tget joints() {\n\t\treturn this._joints;\n\t}\n\n\tget tips() {\n\t\treturn this._tips;\n\t}\n\n\tget wrist() {\n\t\treturn this._wrist;\n\t}\n\n\tget tracking() {\n\t\treturn this._tracking;\n\t}\n\n}\n\nconst quat$1 = new Quat();\nlet ids$1 = 0;\n\nclass XrInputSource extends EventHandler {\n\tconstructor(manager, xrInputSource) {\n\t\tsuper();\n\t\tthis._id = ++ids$1;\n\t\tthis._manager = manager;\n\t\tthis._xrInputSource = xrInputSource;\n\t\tthis._ray = new Ray();\n\t\tthis._rayLocal = new Ray();\n\t\tthis._grip = false;\n\t\tthis._hand = null;\n\t\tif (xrInputSource.hand) this._hand = new XrHand(this);\n\t\tthis._localTransform = null;\n\t\tthis._worldTransform = null;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._localPosition = null;\n\t\tthis._localRotation = null;\n\t\tthis._dirtyLocal = true;\n\t\tthis._selecting = false;\n\t\tthis._squeezing = false;\n\t\tthis._elementInput = true;\n\t\tthis._elementEntity = null;\n\t\tthis._hitTestSources = [];\n\t}\n\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tget inputSource() {\n\t\treturn this._xrInputSource;\n\t}\n\n\tget targetRayMode() {\n\t\treturn this._xrInputSource.targetRayMode;\n\t}\n\n\tget handedness() {\n\t\treturn this._xrInputSource.handedness;\n\t}\n\n\tget profiles() {\n\t\treturn this._xrInputSource.profiles;\n\t}\n\n\tget grip() {\n\t\treturn this._grip;\n\t}\n\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\n\tget gamepad() {\n\t\treturn this._xrInputSource.gamepad || null;\n\t}\n\n\tget selecting() {\n\t\treturn this._selecting;\n\t}\n\n\tget squeezing() {\n\t\treturn this._squeezing;\n\t}\n\n\tset elementInput(value) {\n\t\tif (this._elementInput === value) return;\n\t\tthis._elementInput = value;\n\t\tif (!this._elementInput) this._elementEntity = null;\n\t}\n\n\tget elementInput() {\n\t\treturn this._elementInput;\n\t}\n\n\tget elementEntity() {\n\t\treturn this._elementEntity;\n\t}\n\n\tget hitTestSources() {\n\t\treturn this._hitTestSources;\n\t}\n\n\tupdate(frame) {\n\t\tif (this._hand) {\n\t\t\tthis._hand.update(frame);\n\t\t} else {\n\t\t\tif (this._xrInputSource.gripSpace) {\n\t\t\t\tconst gripPose = frame.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);\n\n\t\t\t\tif (gripPose) {\n\t\t\t\t\tif (!this._grip) {\n\t\t\t\t\t\tthis._grip = true;\n\t\t\t\t\t\tthis._localTransform = new Mat4();\n\t\t\t\t\t\tthis._worldTransform = new Mat4();\n\t\t\t\t\t\tthis._localPosition = new Vec3();\n\t\t\t\t\t\tthis._localRotation = new Quat();\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._dirtyLocal = true;\n\n\t\t\t\t\tthis._localPosition.copy(gripPose.transform.position);\n\n\t\t\t\t\tthis._localRotation.copy(gripPose.transform.orientation);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);\n\n\t\t\tif (targetRayPose) {\n\t\t\t\tthis._dirtyRay = true;\n\n\t\t\t\tthis._rayLocal.origin.copy(targetRayPose.transform.position);\n\n\t\t\t\tthis._rayLocal.direction.set(0, 0, -1);\n\n\t\t\t\tquat$1.copy(targetRayPose.transform.orientation);\n\t\t\t\tquat$1.transformVector(this._rayLocal.direction, this._rayLocal.direction);\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateTransforms() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = false;\n\n\t\t\tthis._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);\n\t\t}\n\n\t\tconst parent = this._manager.camera.parent;\n\n\t\tif (parent) {\n\t\t\tthis._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);\n\t\t} else {\n\t\t\tthis._worldTransform.copy(this._localTransform);\n\t\t}\n\t}\n\n\t_updateRayTransforms() {\n\t\tconst dirty = this._dirtyRay;\n\t\tthis._dirtyRay = false;\n\t\tconst parent = this._manager.camera.parent;\n\n\t\tif (parent) {\n\t\t\tconst parentTransform = this._manager.camera.parent.getWorldTransform();\n\n\t\t\tparentTransform.getTranslation(this._position);\n\n\t\t\tthis._rotation.setFromMat4(parentTransform);\n\n\t\t\tthis._rotation.transformVector(this._rayLocal.origin, this._ray.origin);\n\n\t\t\tthis._ray.origin.add(this._position);\n\n\t\t\tthis._rotation.transformVector(this._rayLocal.direction, this._ray.direction);\n\t\t} else if (dirty) {\n\t\t\tthis._ray.origin.copy(this._rayLocal.origin);\n\n\t\t\tthis._ray.direction.copy(this._rayLocal.direction);\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\tif (!this._position) return null;\n\n\t\tthis._updateTransforms();\n\n\t\tthis._worldTransform.getTranslation(this._position);\n\n\t\treturn this._position;\n\t}\n\n\tgetLocalPosition() {\n\t\treturn this._localPosition;\n\t}\n\n\tgetRotation() {\n\t\tif (!this._rotation) return null;\n\n\t\tthis._updateTransforms();\n\n\t\tthis._rotation.setFromMat4(this._worldTransform);\n\n\t\treturn this._rotation;\n\t}\n\n\tgetLocalRotation() {\n\t\treturn this._localRotation;\n\t}\n\n\tgetOrigin() {\n\t\tthis._updateRayTransforms();\n\n\t\treturn this._ray.origin;\n\t}\n\n\tgetDirection() {\n\t\tthis._updateRayTransforms();\n\n\t\treturn this._ray.direction;\n\t}\n\n\thitTestStart(options = {}) {\n\t\toptions.profile = this._xrInputSource.profiles[0];\n\t\tconst callback = options.callback;\n\n\t\toptions.callback = (err, hitTestSource) => {\n\t\t\tif (hitTestSource) this.onHitTestSourceAdd(hitTestSource);\n\t\t\tif (callback) callback(err, hitTestSource);\n\t\t};\n\n\t\tthis._manager.hitTest.start(options);\n\t}\n\n\tonHitTestSourceAdd(hitTestSource) {\n\t\tthis._hitTestSources.push(hitTestSource);\n\n\t\tthis.fire('hittest:add', hitTestSource);\n\t\thitTestSource.on('result', function (position, rotation, inputSource) {\n\t\t\tif (inputSource !== this) return;\n\t\t\tthis.fire('hittest:result', hitTestSource, position, rotation);\n\t\t}, this);\n\t\thitTestSource.once('remove', function () {\n\t\t\tthis.onHitTestSourceRemove(hitTestSource);\n\t\t\tthis.fire('hittest:remove', hitTestSource);\n\t\t}, this);\n\t}\n\n\tonHitTestSourceRemove(hitTestSource) {\n\t\tconst ind = this._hitTestSources.indexOf(hitTestSource);\n\n\t\tif (ind !== -1) this._hitTestSources.splice(ind, 1);\n\t}\n\n}\n\nclass XrInput extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis.manager = manager;\n\t\tthis._session = null;\n\t\tthis._inputSources = [];\n\n\t\tthis._onInputSourcesChangeEvt = evt => {\n\t\t\tthis._onInputSourcesChange(evt);\n\t\t};\n\n\t\tthis.manager.on('start', this._onSessionStart, this);\n\t\tthis.manager.on('end', this._onSessionEnd, this);\n\t}\n\n\t_onSessionStart() {\n\t\tthis._session = this.manager.session;\n\n\t\tthis._session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);\n\n\t\tthis._session.addEventListener('select', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource.fire('select', evt);\n\t\t\tthis.fire('select', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('selectstart', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._selecting = true;\n\t\t\tinputSource.fire('selectstart', evt);\n\t\t\tthis.fire('selectstart', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('selectend', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._selecting = false;\n\t\t\tinputSource.fire('selectend', evt);\n\t\t\tthis.fire('selectend', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('squeeze', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource.fire('squeeze', evt);\n\t\t\tthis.fire('squeeze', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('squeezestart', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._squeezing = true;\n\t\t\tinputSource.fire('squeezestart', evt);\n\t\t\tthis.fire('squeezestart', inputSource, evt);\n\t\t});\n\n\t\tthis._session.addEventListener('squeezeend', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._squeezing = false;\n\t\t\tinputSource.fire('squeezeend', evt);\n\t\t\tthis.fire('squeezeend', inputSource, evt);\n\t\t});\n\n\t\tconst inputSources = this._session.inputSources;\n\n\t\tfor (let i = 0; i < inputSources.length; i++) {\n\t\t\tthis._addInputSource(inputSources[i]);\n\t\t}\n\t}\n\n\t_onSessionEnd() {\n\t\tlet i = this._inputSources.length;\n\n\t\twhile (i--) {\n\t\t\tconst inputSource = this._inputSources[i];\n\n\t\t\tthis._inputSources.splice(i, 1);\n\n\t\t\tinputSource.fire('remove');\n\t\t\tthis.fire('remove', inputSource);\n\t\t}\n\n\t\tthis._session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);\n\n\t\tthis._session = null;\n\t}\n\n\t_onInputSourcesChange(evt) {\n\t\tfor (let i = 0; i < evt.removed.length; i++) {\n\t\t\tthis._removeInputSource(evt.removed[i]);\n\t\t}\n\n\t\tfor (let i = 0; i < evt.added.length; i++) {\n\t\t\tthis._addInputSource(evt.added[i]);\n\t\t}\n\t}\n\n\t_getByInputSource(xrInputSource) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tif (this._inputSources[i].inputSource === xrInputSource) {\n\t\t\t\treturn this._inputSources[i];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_addInputSource(xrInputSource) {\n\t\tif (this._getByInputSource(xrInputSource)) return;\n\t\tconst inputSource = new XrInputSource(this.manager, xrInputSource);\n\n\t\tthis._inputSources.push(inputSource);\n\n\t\tthis.fire('add', inputSource);\n\t}\n\n\t_removeInputSource(xrInputSource) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tif (this._inputSources[i].inputSource !== xrInputSource) continue;\n\t\t\tconst inputSource = this._inputSources[i];\n\n\t\t\tthis._inputSources.splice(i, 1);\n\n\t\t\tlet h = inputSource.hitTestSources.length;\n\n\t\t\twhile (h--) {\n\t\t\t\tinputSource.hitTestSources[h].remove();\n\t\t\t}\n\n\t\t\tinputSource.fire('remove');\n\t\t\tthis.fire('remove', inputSource);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tupdate(frame) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tthis._inputSources[i].update(frame);\n\t\t}\n\t}\n\n\tget inputSources() {\n\t\treturn this._inputSources;\n\t}\n\n}\n\nconst vec3A = new Vec3();\nconst vec3B = new Vec3();\nconst mat4A = new Mat4();\nconst mat4B = new Mat4();\n\nclass XrLightEstimation extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._supported = false;\n\t\tthis._available = false;\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t\tthis._intensity = 0;\n\t\tthis._rotation = new Quat();\n\t\tthis._color = new Color();\n\t\tthis._sphericalHarmonics = new Float32Array(27);\n\n\t\tthis._manager.on('start', this._onSessionStart, this);\n\n\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t}\n\n\t_onSessionStart() {\n\t\tconst supported = !!this._manager.session.requestLightProbe;\n\t\tif (!supported) return;\n\t\tthis._supported = true;\n\t}\n\n\t_onSessionEnd() {\n\t\tthis._supported = false;\n\t\tthis._available = false;\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t}\n\n\tstart() {\n\t\tlet err;\n\t\tif (!this._manager.session) err = new Error('XR session is not running');\n\t\tif (!err && this._manager.type !== XRTYPE_AR) err = new Error('XR session type is not AR');\n\t\tif (!err && !this._supported) err = new Error('light-estimation is not supported');\n\t\tif (!err && this._lightProbe || this._lightProbeRequested) err = new Error('light estimation is already requested');\n\n\t\tif (err) {\n\t\t\tthis.fire('error', err);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._lightProbeRequested = true;\n\n\t\tthis._manager.session.requestLightProbe().then(lightProbe => {\n\t\t\tconst wasRequested = this._lightProbeRequested;\n\t\t\tthis._lightProbeRequested = false;\n\n\t\t\tif (this._manager.active) {\n\t\t\t\tif (wasRequested) {\n\t\t\t\t\tthis._lightProbe = lightProbe;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.fire('error', new Error('XR session is not active'));\n\t\t\t}\n\t\t}).catch(ex => {\n\t\t\tthis._lightProbeRequested = false;\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\n\tend() {\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t\tthis._available = false;\n\t}\n\n\tupdate(frame) {\n\t\tif (!this._lightProbe) return;\n\t\tconst lightEstimate = frame.getLightEstimate(this._lightProbe);\n\t\tif (!lightEstimate) return;\n\n\t\tif (!this._available) {\n\t\t\tthis._available = true;\n\t\t\tthis.fire('available');\n\t\t}\n\n\t\tconst pli = lightEstimate.primaryLightIntensity;\n\t\tthis._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));\n\t\tvec3A.copy(pli).mulScalar(1 / this._intensity);\n\n\t\tthis._color.set(vec3A.x, vec3A.y, vec3A.z);\n\n\t\tvec3A.set(0, 0, 0);\n\t\tvec3B.copy(lightEstimate.primaryLightDirection);\n\t\tmat4A.setLookAt(vec3B, vec3A, Vec3.UP);\n\t\tmat4B.setFromAxisAngle(Vec3.RIGHT, 90);\n\t\tmat4A.mul(mat4B);\n\n\t\tthis._rotation.setFromMat4(mat4A);\n\n\t\tthis._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget available() {\n\t\treturn this._available;\n\t}\n\n\tget intensity() {\n\t\treturn this._available ? this._intensity : null;\n\t}\n\n\tget color() {\n\t\treturn this._available ? this._color : null;\n\t}\n\n\tget rotation() {\n\t\treturn this._available ? this._rotation : null;\n\t}\n\n\tget sphericalHarmonics() {\n\t\treturn this._available ? this._sphericalHarmonics : null;\n\t}\n\n}\n\nclass XrTrackedImage extends EventHandler {\n\tconstructor(image, width) {\n\t\tsuper();\n\t\tthis._image = image;\n\t\tthis._bitmap = null;\n\t\tthis._width = width;\n\t\tthis._measuredWidth = 0;\n\t\tthis._trackable = false;\n\t\tthis._tracking = false;\n\t\tthis._emulated = false;\n\t\tthis._pose = null;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t}\n\n\tget image() {\n\t\treturn this._image;\n\t}\n\n\tset width(value) {\n\t\tthis._width = value;\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\n\tget trackable() {\n\t\treturn this._trackable;\n\t}\n\n\tget tracking() {\n\t\treturn this._tracking;\n\t}\n\n\tget emulated() {\n\t\treturn this._emulated;\n\t}\n\n\tprepare() {\n\t\tif (this._bitmap) {\n\t\t\treturn {\n\t\t\t\timage: this._bitmap,\n\t\t\t\twidthInMeters: this._width\n\t\t\t};\n\t\t}\n\n\t\treturn createImageBitmap(this._image).then(bitmap => {\n\t\t\tthis._bitmap = bitmap;\n\t\t\treturn {\n\t\t\t\timage: this._bitmap,\n\t\t\t\twidthInMeters: this._width\n\t\t\t};\n\t\t});\n\t}\n\n\tdestroy() {\n\t\tthis._image = null;\n\t\tthis._pose = null;\n\n\t\tif (this._bitmap) {\n\t\t\tthis._bitmap.close();\n\n\t\t\tthis._bitmap = null;\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\tif (this._pose) this._position.copy(this._pose.transform.position);\n\t\treturn this._position;\n\t}\n\n\tgetRotation() {\n\t\tif (this._pose) this._rotation.copy(this._pose.transform.orientation);\n\t\treturn this._rotation;\n\t}\n\n}\n\nclass XrImageTracking extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._supported = platform.browser && !!window.XRImageTrackingResult;\n\t\tthis._available = false;\n\t\tthis._images = [];\n\n\t\tif (this._supported) {\n\t\t\tthis._manager.on('start', this._onSessionStart, this);\n\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\n\tadd(image, width) {\n\t\tif (!this._supported || this._manager.active) return null;\n\t\tconst trackedImage = new XrTrackedImage(image, width);\n\n\t\tthis._images.push(trackedImage);\n\n\t\treturn trackedImage;\n\t}\n\n\tremove(trackedImage) {\n\t\tif (this._manager.active) return;\n\n\t\tconst ind = this._images.indexOf(trackedImage);\n\n\t\tif (ind !== -1) {\n\t\t\ttrackedImage.destroy();\n\n\t\t\tthis._images.splice(ind, 1);\n\t\t}\n\t}\n\n\t_onSessionStart() {\n\t\tthis._manager.session.getTrackedImageScores().then(images => {\n\t\t\tthis._available = true;\n\n\t\t\tfor (let i = 0; i < images.length; i++) {\n\t\t\t\tthis._images[i]._trackable = images[i] === 'trackable';\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('error', err);\n\t\t});\n\t}\n\n\t_onSessionEnd() {\n\t\tthis._available = false;\n\n\t\tfor (let i = 0; i < this._images.length; i++) {\n\t\t\tthis._images[i]._pose = null;\n\t\t\tthis._images[i]._measuredWidth = 0;\n\n\t\t\tif (this._images[i]._tracking) {\n\t\t\t\tthis._images[i]._tracking = false;\n\n\t\t\t\tthis._images[i].fire('untracked');\n\t\t\t}\n\t\t}\n\t}\n\n\tprepareImages(callback) {\n\t\tif (this._images.length) {\n\t\t\tPromise.all(this._images.map(function (trackedImage) {\n\t\t\t\treturn trackedImage.prepare();\n\t\t\t})).then(function (bitmaps) {\n\t\t\t\tcallback(null, bitmaps);\n\t\t\t}).catch(function (err) {\n\t\t\t\tcallback(err, null);\n\t\t\t});\n\t\t} else {\n\t\t\tcallback(null, null);\n\t\t}\n\t}\n\n\tupdate(frame) {\n\t\tif (!this._available) return;\n\t\tconst results = frame.getImageTrackingResults();\n\t\tconst index = {};\n\n\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\tindex[results[i].index] = results[i];\n\t\t\tconst trackedImage = this._images[results[i].index];\n\t\t\ttrackedImage._emulated = results[i].trackingState === 'emulated';\n\t\t\ttrackedImage._measuredWidth = results[i].measuredWidthInMeters;\n\t\t\ttrackedImage._dirtyTransform = true;\n\t\t\ttrackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);\n\t\t}\n\n\t\tfor (let i = 0; i < this._images.length; i++) {\n\t\t\tif (this._images[i]._tracking && !index[i]) {\n\t\t\t\tthis._images[i]._tracking = false;\n\n\t\t\t\tthis._images[i].fire('untracked');\n\t\t\t} else if (!this._images[i]._tracking && index[i]) {\n\t\t\t\tthis._images[i]._tracking = true;\n\n\t\t\t\tthis._images[i].fire('tracked');\n\t\t\t}\n\t\t}\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget available() {\n\t\treturn this._available;\n\t}\n\n\tget images() {\n\t\treturn this._images;\n\t}\n\n}\n\nclass XrDomOverlay {\n\tconstructor(manager) {\n\t\tthis._manager = manager;\n\t\tthis._supported = platform.browser && !!window.XRDOMOverlayState;\n\t\tthis._root = null;\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget available() {\n\t\treturn this._supported && this._manager.active && this._manager._session.domOverlayState !== null;\n\t}\n\n\tget state() {\n\t\tif (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) return null;\n\t\treturn this._manager._session.domOverlayState.type;\n\t}\n\n\tset root(value) {\n\t\tif (!this._supported || this._manager.active) return;\n\t\tthis._root = value;\n\t}\n\n\tget root() {\n\t\treturn this._root;\n\t}\n\n}\n\nclass XrDepthSensing extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._available = false;\n\t\tthis._depthInfoCpu = null;\n\t\tthis._depthInfoGpu = null;\n\t\tthis._usage = null;\n\t\tthis._dataFormat = null;\n\t\tthis._matrixDirty = false;\n\t\tthis._matrix = new Mat4();\n\t\tthis._emptyBuffer = new Uint8Array(32);\n\t\tthis._depthBuffer = null;\n\t\tthis._texture = new Texture(this._manager.app.graphicsDevice, {\n\t\t\tformat: PIXELFORMAT_L8_A8,\n\t\t\tmipmaps: false,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tminFilter: FILTER_LINEAR,\n\t\t\tmagFilter: FILTER_LINEAR\n\t\t});\n\n\t\tif (this.supported) {\n\t\t\tthis._manager.on('start', this._onSessionStart, this);\n\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\n\t_onSessionStart() {\n\t\tconst session = this._manager.session;\n\n\t\ttry {\n\t\t\tthis._usage = session.depthUsage;\n\t\t\tthis._dataFormat = session.depthDataFormat;\n\t\t} catch (ex) {\n\t\t\tthis._usage = null;\n\t\t\tthis._dataFormat = null;\n\t\t\tthis._available = false;\n\t\t\tthis.fire('error', ex);\n\t\t}\n\t}\n\n\t_onSessionEnd() {\n\t\tthis._depthInfoCpu = null;\n\t\tthis._depthInfoGpu = null;\n\t\tthis._usage = null;\n\t\tthis._dataFormat = null;\n\n\t\tif (this._available) {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('unavailable');\n\t\t}\n\n\t\tthis._depthBuffer = null;\n\t\tthis._texture._width = 4;\n\t\tthis._texture._height = 4;\n\t\tthis._texture._levels[0] = this._emptyBuffer;\n\n\t\tthis._texture.upload();\n\t}\n\n\t_updateTexture() {\n\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\n\t\tif (depthInfo) {\n\t\t\tlet resized = false;\n\n\t\t\tif (depthInfo.width !== this._texture.width || depthInfo.height !== this._texture.height) {\n\t\t\t\tthis._texture._width = depthInfo.width;\n\t\t\t\tthis._texture._height = depthInfo.height;\n\t\t\t\tthis._matrixDirty = true;\n\t\t\t\tresized = true;\n\t\t\t}\n\n\t\t\tif (this._depthInfoCpu) {\n\t\t\t\tconst dataBuffer = this._depthInfoCpu.data;\n\t\t\t\tthis._depthBuffer = new Uint8Array(dataBuffer);\n\t\t\t\tthis._texture._levels[0] = this._depthBuffer;\n\n\t\t\t\tthis._texture.upload();\n\t\t\t} else if (this._depthInfoGpu) {\n\t\t\t\tthis._texture._levels[0] = this._depthInfoGpu.texture;\n\n\t\t\t\tthis._texture.upload();\n\t\t\t}\n\n\t\t\tif (resized) this.fire('resize', depthInfo.width, depthInfo.height);\n\t\t} else if (this._depthBuffer) {\n\t\t\tthis._depthBuffer = null;\n\t\t\tthis._texture._width = 4;\n\t\t\tthis._texture._height = 4;\n\t\t\tthis._texture._levels[0] = this._emptyBuffer;\n\n\t\t\tthis._texture.upload();\n\t\t}\n\t}\n\n\tupdate(frame, view) {\n\t\tif (!this._usage) return;\n\t\tlet depthInfoCpu = null;\n\t\tlet depthInfoGpu = null;\n\n\t\tif (this._usage === XRDEPTHSENSINGUSAGE_CPU && view) {\n\t\t\tdepthInfoCpu = frame.getDepthInformation(view);\n\t\t} else if (this._usage === XRDEPTHSENSINGUSAGE_GPU && view) {\n\t\t\tdepthInfoGpu = frame.getDepthInformation(view);\n\t\t}\n\n\t\tif (this._depthInfoCpu && !depthInfoCpu || !this._depthInfoCpu && depthInfoCpu || this.depthInfoGpu && !depthInfoGpu || !this._depthInfoGpu && depthInfoGpu) {\n\t\t\tthis._matrixDirty = true;\n\t\t}\n\n\t\tthis._depthInfoCpu = depthInfoCpu;\n\t\tthis._depthInfoGpu = depthInfoGpu;\n\n\t\tthis._updateTexture();\n\n\t\tif (this._matrixDirty) {\n\t\t\tthis._matrixDirty = false;\n\t\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\n\t\t\tif (depthInfo) {\n\t\t\t\tthis._matrix.data.set(depthInfo.normDepthBufferFromNormView.matrix);\n\t\t\t} else {\n\t\t\t\tthis._matrix.setIdentity();\n\t\t\t}\n\t\t}\n\n\t\tif ((this._depthInfoCpu || this._depthInfoGpu) && !this._available) {\n\t\t\tthis._available = true;\n\t\t\tthis.fire('available');\n\t\t} else if (!this._depthInfoCpu && !this._depthInfoGpu && this._available) {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('unavailable');\n\t\t}\n\t}\n\n\tgetDepth(u, v) {\n\t\tif (!this._depthInfoCpu) return null;\n\t\treturn this._depthInfoCpu.getDepthInMeters(u, v);\n\t}\n\n\tget supported() {\n\t\treturn platform.browser && !!window.XRDepthInformation;\n\t}\n\n\tget available() {\n\t\treturn this._available;\n\t}\n\n\tget usage() {\n\t\treturn this._usage;\n\t}\n\n\tget dataFormat() {\n\t\treturn this._dataFormat;\n\t}\n\n\tget width() {\n\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\t\treturn depthInfo && depthInfo.width || 0;\n\t}\n\n\tget height() {\n\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\t\treturn depthInfo && depthInfo.height || 0;\n\t}\n\n\tget texture() {\n\t\treturn this._texture;\n\t}\n\n\tget uvMatrix() {\n\t\treturn this._matrix;\n\t}\n\n\tget rawValueToMeters() {\n\t\tconst depthInfo = this._depthInfoCpu || this._depthInfoGpu;\n\t\treturn depthInfo && depthInfo.rawValueToMeters || 0;\n\t}\n\n}\n\nlet ids = 0;\n\nclass XrPlane extends EventHandler {\n\tconstructor(planeDetection, xrPlane) {\n\t\tsuper();\n\t\tthis._id = ++ids;\n\t\tthis._planeDetection = planeDetection;\n\t\tthis._manager = this._planeDetection._manager;\n\t\tthis._xrPlane = xrPlane;\n\t\tthis._lastChangedTime = this._xrPlane.lastChangedTime;\n\t\tthis._orientation = this._xrPlane.orientation;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t}\n\n\tdestroy() {\n\t\tthis.fire('remove');\n\t}\n\n\tupdate(frame) {\n\t\tconst pose = frame.getPose(this._xrPlane.planeSpace, this._manager._referenceSpace);\n\n\t\tif (pose) {\n\t\t\tthis._position.copy(pose.transform.position);\n\n\t\t\tthis._rotation.copy(pose.transform.orientation);\n\t\t}\n\n\t\tif (this._lastChangedTime !== this._xrPlane.lastChangedTime) {\n\t\t\tthis._lastChangedTime = this._xrPlane.lastChangedTime;\n\t\t\tthis.fire('change');\n\t\t}\n\t}\n\n\tgetPosition() {\n\t\treturn this._position;\n\t}\n\n\tgetRotation() {\n\t\treturn this._rotation;\n\t}\n\n\tget id() {\n\t\treturn this.id;\n\t}\n\n\tget orientation() {\n\t\treturn this._orientation;\n\t}\n\n\tget points() {\n\t\treturn this._xrPlane.polygon;\n\t}\n\n}\n\nclass XrPlaneDetection extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._supported = platform.browser && !!window.XRPlane;\n\t\tthis._available = false;\n\t\tthis._planesIndex = new Map();\n\t\tthis._planes = null;\n\n\t\tif (this._supported) {\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\n\t_onSessionEnd() {\n\t\tif (this._planes) {\n\t\t\tfor (let i = 0; i < this._planes.length; i++) {\n\t\t\t\tthis._planes[i].destroy();\n\t\t\t}\n\t\t}\n\n\t\tthis._planesIndex.clear();\n\n\t\tthis._planes = null;\n\n\t\tif (this._available) {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('unavailable');\n\t\t}\n\t}\n\n\tupdate(frame) {\n\t\tlet detectedPlanes;\n\n\t\tif (!this._available) {\n\t\t\ttry {\n\t\t\t\tdetectedPlanes = frame.detectedPlanes;\n\t\t\t\tthis._planes = [];\n\t\t\t\tthis._available = true;\n\t\t\t\tthis.fire('available');\n\t\t\t} catch (ex) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tdetectedPlanes = frame.detectedPlanes;\n\t\t}\n\n\t\tfor (const [xrPlane, plane] of this._planesIndex) {\n\t\t\tif (detectedPlanes.has(xrPlane)) continue;\n\n\t\t\tthis._planesIndex.delete(xrPlane);\n\n\t\t\tthis._planes.splice(this._planes.indexOf(plane), 1);\n\n\t\t\tplane.destroy();\n\t\t\tthis.fire('remove', plane);\n\t\t}\n\n\t\tfor (const xrPlane of detectedPlanes) {\n\t\t\tlet plane = this._planesIndex.get(xrPlane);\n\n\t\t\tif (!plane) {\n\t\t\t\tplane = new XrPlane(this, xrPlane);\n\n\t\t\t\tthis._planesIndex.set(xrPlane, plane);\n\n\t\t\t\tthis._planes.push(plane);\n\n\t\t\t\tplane.update(frame);\n\t\t\t\tthis.fire('add', plane);\n\t\t\t} else {\n\t\t\t\tplane.update(frame);\n\t\t\t}\n\t\t}\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget available() {\n\t\treturn this._available;\n\t}\n\n\tget planes() {\n\t\treturn this._planes;\n\t}\n\n}\n\nclass XrManager extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.app = app;\n\t\tthis._supported = platform.browser && !!navigator.xr;\n\t\tthis._available = {};\n\t\tthis._available[XRTYPE_INLINE] = false;\n\t\tthis._available[XRTYPE_VR] = false;\n\t\tthis._available[XRTYPE_AR] = false;\n\t\tthis._type = null;\n\t\tthis._spaceType = null;\n\t\tthis._session = null;\n\t\tthis._baseLayer = null;\n\t\tthis._referenceSpace = null;\n\t\tthis.depthSensing = new XrDepthSensing(this);\n\t\tthis.domOverlay = new XrDomOverlay(this);\n\t\tthis.hitTest = new XrHitTest(this);\n\t\tthis.imageTracking = new XrImageTracking(this);\n\t\tthis.planeDetection = new XrPlaneDetection(this);\n\t\tthis.input = new XrInput(this);\n\t\tthis.lightEstimation = new XrLightEstimation(this);\n\t\tthis._camera = null;\n\t\tthis.views = [];\n\t\tthis.viewsPool = [];\n\t\tthis._localPosition = new Vec3();\n\t\tthis._localRotation = new Quat();\n\t\tthis._depthNear = 0.1;\n\t\tthis._depthFar = 1000;\n\t\tthis._width = 0;\n\t\tthis._height = 0;\n\n\t\tif (this._supported) {\n\t\t\tnavigator.xr.addEventListener('devicechange', () => {\n\t\t\t\tthis._deviceAvailabilityCheck();\n\t\t\t});\n\n\t\t\tthis._deviceAvailabilityCheck();\n\t\t}\n\t}\n\n\tstart(camera, type, spaceType, options) {\n\t\tlet callback = options;\n\t\tif (typeof options === 'object') callback = options.callback;\n\n\t\tif (!this._available[type]) {\n\t\t\tif (callback) callback(new Error('XR is not available'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._session) {\n\t\t\tif (callback) callback(new Error('XR session is already started'));\n\t\t\treturn;\n\t\t}\n\n\t\tthis._camera = camera;\n\t\tthis._camera.camera.xr = this;\n\t\tthis._type = type;\n\t\tthis._spaceType = spaceType;\n\n\t\tthis._setClipPlanes(camera.nearClip, camera.farClip);\n\n\t\tconst opts = {\n\t\t\trequiredFeatures: [spaceType],\n\t\t\toptionalFeatures: []\n\t\t};\n\n\t\tif (type === XRTYPE_AR) {\n\t\t\topts.optionalFeatures.push('light-estimation');\n\t\t\topts.optionalFeatures.push('hit-test');\n\n\t\t\tif (options) {\n\t\t\t\tif (options.imageTracking && this.imageTracking.supported) opts.optionalFeatures.push('image-tracking');\n\t\t\t\tif (options.planeDetection) opts.optionalFeatures.push('plane-detection');\n\t\t\t}\n\n\t\t\tif (this.domOverlay.supported && this.domOverlay.root) {\n\t\t\t\topts.optionalFeatures.push('dom-overlay');\n\t\t\t\topts.domOverlay = {\n\t\t\t\t\troot: this.domOverlay.root\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (options && options.depthSensing && this.depthSensing.supported) {\n\t\t\t\topts.optionalFeatures.push('depth-sensing');\n\t\t\t\tconst usagePreference = [XRDEPTHSENSINGUSAGE_CPU];\n\t\t\t\tconst dataFormatPreference = [XRDEPTHSENSINGFORMAT_L8A8];\n\n\t\t\t\tif (options.depthSensing.usagePreference) {\n\t\t\t\t\tconst ind = usagePreference.indexOf(options.depthSensing.usagePreference);\n\t\t\t\t\tif (ind !== -1) usagePreference.splice(ind, 1);\n\t\t\t\t\tusagePreference.unshift(options.depthSensing.usagePreference);\n\t\t\t\t}\n\n\t\t\t\tif (options.depthSensing.dataFormatPreference) {\n\t\t\t\t\tconst ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);\n\t\t\t\t\tif (ind !== -1) dataFormatPreference.splice(ind, 1);\n\t\t\t\t\tdataFormatPreference.unshift(options.depthSensing.dataFormatPreference);\n\t\t\t\t}\n\n\t\t\t\topts.depthSensing = {\n\t\t\t\t\tusagePreference: usagePreference,\n\t\t\t\t\tdataFormatPreference: dataFormatPreference\n\t\t\t\t};\n\t\t\t}\n\t\t} else if (type === XRTYPE_VR) {\n\t\t\topts.optionalFeatures.push('hand-tracking');\n\t\t}\n\n\t\tif (options && options.optionalFeatures) opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);\n\n\t\tif (this.imageTracking.supported && this.imageTracking.images.length) {\n\t\t\tthis.imageTracking.prepareImages((err, trackedImages) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (callback) callback(err);\n\t\t\t\t\tthis.fire('error', err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (trackedImages !== null) opts.trackedImages = trackedImages;\n\n\t\t\t\tthis._onStartOptionsReady(type, spaceType, opts, callback);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._onStartOptionsReady(type, spaceType, opts, callback);\n\t\t}\n\t}\n\n\t_onStartOptionsReady(type, spaceType, options, callback) {\n\t\tnavigator.xr.requestSession(type, options).then(session => {\n\t\t\tthis._onSessionStart(session, spaceType, callback);\n\t\t}).catch(ex => {\n\t\t\tthis._camera.camera.xr = null;\n\t\t\tthis._camera = null;\n\t\t\tthis._type = null;\n\t\t\tthis._spaceType = null;\n\t\t\tif (callback) callback(ex);\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\n\tend(callback) {\n\t\tif (!this._session) {\n\t\t\tif (callback) callback(new Error('XR Session is not initialized'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (callback) this.once('end', callback);\n\n\t\tthis._session.end();\n\t}\n\n\tisAvailable(type) {\n\t\treturn this._available[type];\n\t}\n\n\t_deviceAvailabilityCheck() {\n\t\tfor (const key in this._available) {\n\t\t\tthis._sessionSupportCheck(key);\n\t\t}\n\t}\n\n\t_sessionSupportCheck(type) {\n\t\tnavigator.xr.isSessionSupported(type).then(available => {\n\t\t\tif (this._available[type] === available) return;\n\t\t\tthis._available[type] = available;\n\t\t\tthis.fire('available', type, available);\n\t\t\tthis.fire('available:' + type, available);\n\t\t}).catch(ex => {\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\n\t_onSessionStart(session, spaceType, callback) {\n\t\tlet failed = false;\n\t\tthis._session = session;\n\n\t\tconst onVisibilityChange = () => {\n\t\t\tthis.fire('visibility:change', session.visibilityState);\n\t\t};\n\n\t\tconst onClipPlanesChange = () => {\n\t\t\tthis._setClipPlanes(this._camera.nearClip, this._camera.farClip);\n\t\t};\n\n\t\tconst onEnd = () => {\n\t\t\tthis._session = null;\n\t\t\tthis._referenceSpace = null;\n\t\t\tthis.views = [];\n\t\t\tthis._width = 0;\n\t\t\tthis._height = 0;\n\t\t\tthis._type = null;\n\t\t\tthis._spaceType = null;\n\n\t\t\tif (this._camera) {\n\t\t\t\tthis._camera.off('set_nearClip', onClipPlanesChange);\n\n\t\t\t\tthis._camera.off('set_farClip', onClipPlanesChange);\n\n\t\t\t\tthis._camera.camera.xr = null;\n\t\t\t\tthis._camera = null;\n\t\t\t}\n\n\t\t\tsession.removeEventListener('end', onEnd);\n\t\t\tsession.removeEventListener('visibilitychange', onVisibilityChange);\n\t\t\tif (!failed) this.fire('end');\n\t\t\tthis.app.tick();\n\t\t};\n\n\t\tsession.addEventListener('end', onEnd);\n\t\tsession.addEventListener('visibilitychange', onVisibilityChange);\n\n\t\tthis._camera.on('set_nearClip', onClipPlanesChange);\n\n\t\tthis._camera.on('set_farClip', onClipPlanesChange);\n\n\t\tthis._baseLayer = new XRWebGLLayer(session, this.app.graphicsDevice.gl);\n\t\tsession.updateRenderState({\n\t\t\tbaseLayer: this._baseLayer,\n\t\t\tdepthNear: this._depthNear,\n\t\t\tdepthFar: this._depthFar\n\t\t});\n\t\tsession.requestReferenceSpace(spaceType).then(referenceSpace => {\n\t\t\tthis._referenceSpace = referenceSpace;\n\t\t\tthis.app.tick();\n\t\t\tif (callback) callback(null);\n\t\t\tthis.fire('start');\n\t\t}).catch(ex => {\n\t\t\tfailed = true;\n\t\t\tsession.end();\n\t\t\tif (callback) callback(ex);\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\n\t_setClipPlanes(near, far) {\n\t\tif (this._depthNear === near && this._depthFar === far) return;\n\t\tthis._depthNear = near;\n\t\tthis._depthFar = far;\n\t\tif (!this._session) return;\n\n\t\tthis._session.updateRenderState({\n\t\t\tdepthNear: this._depthNear,\n\t\t\tdepthFar: this._depthFar\n\t\t});\n\t}\n\n\tupdate(frame) {\n\t\tif (!this._session) return;\n\t\tconst width = frame.session.renderState.baseLayer.framebufferWidth;\n\t\tconst height = frame.session.renderState.baseLayer.framebufferHeight;\n\n\t\tif (this._width !== width || this._height !== height) {\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\t\t\tthis.app.graphicsDevice.setResolution(width, height);\n\t\t}\n\n\t\tconst pose = frame.getViewerPose(this._referenceSpace);\n\t\tconst lengthNew = pose ? pose.views.length : 0;\n\n\t\tif (lengthNew > this.views.length) {\n\t\t\tfor (let i = 0; i <= lengthNew - this.views.length; i++) {\n\t\t\t\tlet view = this.viewsPool.pop();\n\n\t\t\t\tif (!view) {\n\t\t\t\t\tview = {\n\t\t\t\t\t\tviewport: new Vec4(),\n\t\t\t\t\t\tprojMat: new Mat4(),\n\t\t\t\t\t\tviewMat: new Mat4(),\n\t\t\t\t\t\tviewOffMat: new Mat4(),\n\t\t\t\t\t\tviewInvMat: new Mat4(),\n\t\t\t\t\t\tviewInvOffMat: new Mat4(),\n\t\t\t\t\t\tprojViewOffMat: new Mat4(),\n\t\t\t\t\t\tviewMat3: new Mat3(),\n\t\t\t\t\t\tposition: new Float32Array(3),\n\t\t\t\t\t\trotation: new Quat()\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tthis.views.push(view);\n\t\t\t}\n\t\t} else if (lengthNew <= this.views.length) {\n\t\t\tfor (let i = 0; i < this.views.length - lengthNew; i++) {\n\t\t\t\tthis.viewsPool.push(this.views.pop());\n\t\t\t}\n\t\t}\n\n\t\tif (pose) {\n\t\t\tconst posePosition = pose.transform.position;\n\t\t\tconst poseOrientation = pose.transform.orientation;\n\n\t\t\tthis._localPosition.set(posePosition.x, posePosition.y, posePosition.z);\n\n\t\t\tthis._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);\n\n\t\t\tconst layer = frame.session.renderState.baseLayer;\n\n\t\t\tfor (let i = 0; i < pose.views.length; i++) {\n\t\t\t\tconst viewRaw = pose.views[i];\n\t\t\t\tconst view = this.views[i];\n\t\t\t\tconst viewport = layer.getViewport(viewRaw);\n\t\t\t\tview.viewport.x = viewport.x;\n\t\t\t\tview.viewport.y = viewport.y;\n\t\t\t\tview.viewport.z = viewport.width;\n\t\t\t\tview.viewport.w = viewport.height;\n\t\t\t\tview.projMat.set(viewRaw.projectionMatrix);\n\t\t\t\tview.viewMat.set(viewRaw.transform.inverse.matrix);\n\t\t\t\tview.viewInvMat.set(viewRaw.transform.matrix);\n\t\t\t}\n\t\t}\n\n\t\tthis._camera.camera._node.setLocalPosition(this._localPosition);\n\n\t\tthis._camera.camera._node.setLocalRotation(this._localRotation);\n\n\t\tthis.input.update(frame);\n\n\t\tif (this._type === XRTYPE_AR) {\n\t\t\tif (this.hitTest.supported) this.hitTest.update(frame);\n\t\t\tif (this.lightEstimation.supported) this.lightEstimation.update(frame);\n\t\t\tif (this.depthSensing.supported) this.depthSensing.update(frame, pose && pose.views[0]);\n\t\t\tif (this.imageTracking.supported) this.imageTracking.update(frame);\n\t\t\tif (this.planeDetection.supported) this.planeDetection.update(frame);\n\t\t}\n\n\t\tthis.fire('update', frame);\n\t}\n\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\n\tget active() {\n\t\treturn !!this._session;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget spaceType() {\n\t\treturn this._spaceType;\n\t}\n\n\tget session() {\n\t\treturn this._session;\n\t}\n\n\tget camera() {\n\t\treturn this._camera ? this._camera.entity : null;\n\t}\n\n\tget visibilityState() {\n\t\tif (!this._session) return null;\n\t\treturn this._session.visibilityState;\n\t}\n\n}\n\nclass ComponentSystem extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.app = app;\n\t\tthis.store = {};\n\t\tthis.schema = [];\n\t}\n\n\taddComponent(entity, data = {}) {\n\t\tconst component = new this.ComponentType(this, entity);\n\t\tconst componentData = new this.DataType();\n\t\tthis.store[entity.getGuid()] = {\n\t\t\tentity: entity,\n\t\t\tdata: componentData\n\t\t};\n\t\tentity[this.id] = component;\n\t\tentity.c[this.id] = component;\n\t\tthis.initializeComponentData(component, data, []);\n\t\tthis.fire('add', entity, component);\n\t\treturn component;\n\t}\n\n\tremoveComponent(entity) {\n\t\tconst record = this.store[entity.getGuid()];\n\t\tconst component = entity.c[this.id];\n\t\tthis.fire('beforeremove', entity, component);\n\t\tdelete this.store[entity.getGuid()];\n\t\tentity[this.id] = undefined;\n\t\tdelete entity.c[this.id];\n\t\tthis.fire('remove', entity, record.data);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst src = this.store[entity.getGuid()];\n\t\treturn this.addComponent(clone, src.data);\n\t}\n\n\tinitializeComponentData(component, data = {}, properties) {\n\t\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\t\tconst descriptor = properties[i];\n\t\t\tlet name, type;\n\n\t\t\tif (typeof descriptor === 'object') {\n\t\t\t\tname = descriptor.name;\n\t\t\t\ttype = descriptor.type;\n\t\t\t} else {\n\t\t\t\tname = descriptor;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\n\t\t\tlet value = data[name];\n\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (type !== undefined) {\n\t\t\t\t\tvalue = convertValue(value, type);\n\t\t\t\t}\n\n\t\t\t\tcomponent[name] = value;\n\t\t\t} else {\n\t\t\t\tcomponent[name] = component.data[name];\n\t\t\t}\n\t\t}\n\n\t\tif (component.enabled && component.entity.enabled) {\n\t\t\tcomponent.onEnable();\n\t\t}\n\t}\n\n\tgetPropertiesOfType(type) {\n\t\tconst matchingProperties = [];\n\t\tconst schema = this.schema || [];\n\t\tschema.forEach(function (descriptor) {\n\t\t\tif (descriptor && typeof descriptor === 'object' && descriptor.type === type) {\n\t\t\t\tmatchingProperties.push(descriptor);\n\t\t\t}\n\t\t});\n\t\treturn matchingProperties;\n\t}\n\n\tdestroy() {\n\t\tthis.off();\n\t}\n\n}\n\nfunction convertValue(value, type) {\n\tif (!value) {\n\t\treturn value;\n\t}\n\n\tswitch (type) {\n\t\tcase 'rgb':\n\t\t\tif (value instanceof Color) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Color(value[0], value[1], value[2]);\n\n\t\tcase 'rgba':\n\t\t\tif (value instanceof Color) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Color(value[0], value[1], value[2], value[3]);\n\n\t\tcase 'vec2':\n\t\t\tif (value instanceof Vec2) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Vec2(value[0], value[1]);\n\n\t\tcase 'vec3':\n\t\t\tif (value instanceof Vec3) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Vec3(value[0], value[1], value[2]);\n\n\t\tcase 'vec4':\n\t\t\tif (value instanceof Vec4) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\n\t\t\treturn new Vec4(value[0], value[1], value[2], value[3]);\n\n\t\tcase 'boolean':\n\t\tcase 'number':\n\t\tcase 'string':\n\t\t\treturn value;\n\n\t\tcase 'entity':\n\t\t\treturn value;\n\n\t\tdefault:\n\t\t\tthrow new Error('Could not convert unhandled type: ' + type);\n\t}\n}\n\nclass AnimCache {\n\tconstructor() {\n\t\tthis._left = Infinity;\n\t\tthis._right = -Infinity;\n\t\tthis._len = 0;\n\t\tthis._recip = 0;\n\t\tthis._p0 = 0;\n\t\tthis._p1 = 0;\n\t\tthis._t = 0;\n\t\tthis._hermite = {\n\t\t\tvalid: false,\n\t\t\tp0: 0,\n\t\t\tm0: 0,\n\t\t\tp1: 0,\n\t\t\tm1: 0\n\t\t};\n\t}\n\n\tupdate(time, input) {\n\t\tif (time < this._left || time >= this._right) {\n\t\t\tconst len = input.length;\n\n\t\t\tif (!len) {\n\t\t\t\tthis._left = -Infinity;\n\t\t\t\tthis._right = Infinity;\n\t\t\t\tthis._len = 0;\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = 0;\n\t\t\t} else {\n\t\t\t\tif (time < input[0]) {\n\t\t\t\t\tthis._left = -Infinity;\n\t\t\t\t\tthis._right = input[0];\n\t\t\t\t\tthis._len = 0;\n\t\t\t\t\tthis._recip = 0;\n\t\t\t\t\tthis._p0 = this._p1 = 0;\n\t\t\t\t} else if (time >= input[len - 1]) {\n\t\t\t\t\tthis._left = input[len - 1];\n\t\t\t\t\tthis._right = Infinity;\n\t\t\t\t\tthis._len = 0;\n\t\t\t\t\tthis._recip = 0;\n\t\t\t\t\tthis._p0 = this._p1 = len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tconst index = this._findKey(time, input);\n\n\t\t\t\t\tthis._left = input[index];\n\t\t\t\t\tthis._right = input[index + 1];\n\t\t\t\t\tthis._len = this._right - this._left;\n\t\t\t\t\tconst diff = 1.0 / this._len;\n\t\t\t\t\tthis._recip = isFinite(diff) ? diff : 0;\n\t\t\t\t\tthis._p0 = index;\n\t\t\t\t\tthis._p1 = index + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;\n\t\tthis._hermite.valid = false;\n\t}\n\n\t_findKey(time, input) {\n\t\tlet index = 0;\n\n\t\twhile (time >= input[index + 1]) {\n\t\t\tindex++;\n\t\t}\n\n\t\treturn index;\n\t}\n\n\teval(result, interpolation, output) {\n\t\tconst data = output._data;\n\t\tconst comp = output._components;\n\t\tconst idx0 = this._p0 * comp;\n\n\t\tif (interpolation === INTERPOLATION_STEP) {\n\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\tresult[i] = data[idx0 + i];\n\t\t\t}\n\t\t} else {\n\t\t\tconst t = this._t;\n\t\t\tconst idx1 = this._p1 * comp;\n\n\t\t\tswitch (interpolation) {\n\t\t\t\tcase INTERPOLATION_LINEAR:\n\t\t\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\t\t\tresult[i] = math.lerp(data[idx0 + i], data[idx1 + i], t);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase INTERPOLATION_CUBIC:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst hermite = this._hermite;\n\n\t\t\t\t\t\tif (!hermite.valid) {\n\t\t\t\t\t\t\tconst t2 = t * t;\n\t\t\t\t\t\t\tconst twot = t + t;\n\t\t\t\t\t\t\tconst omt = 1 - t;\n\t\t\t\t\t\t\tconst omt2 = omt * omt;\n\t\t\t\t\t\t\thermite.valid = true;\n\t\t\t\t\t\t\thermite.p0 = (1 + twot) * omt2;\n\t\t\t\t\t\t\thermite.m0 = t * omt2;\n\t\t\t\t\t\t\thermite.p1 = t2 * (3 - twot);\n\t\t\t\t\t\t\thermite.m1 = t2 * (t - 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst p0 = (this._p0 * 3 + 1) * comp;\n\t\t\t\t\t\tconst m0 = (this._p0 * 3 + 2) * comp;\n\t\t\t\t\t\tconst p1 = (this._p1 * 3 + 1) * comp;\n\t\t\t\t\t\tconst m1 = (this._p1 * 3 + 0) * comp;\n\n\t\t\t\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\t\t\t\tresult[i] = hermite.p0 * data[p0 + i] + hermite.m0 * data[m0 + i] * this._len + hermite.p1 * data[p1 + i] + hermite.m1 * data[m1 + i] * this._len;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimSnapshot {\n\tconstructor(animTrack) {\n\t\tthis._name = animTrack.name + 'Snapshot';\n\t\tthis._time = -1;\n\t\tthis._cache = [];\n\t\tthis._results = [];\n\n\t\tfor (let i = 0; i < animTrack._inputs.length; ++i) {\n\t\t\tthis._cache[i] = new AnimCache();\n\t\t}\n\n\t\tconst curves = animTrack._curves;\n\t\tconst outputs = animTrack._outputs;\n\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst output = outputs[curve._output];\n\t\t\tconst storage = [];\n\n\t\t\tfor (let j = 0; j < output._components; ++j) {\n\t\t\t\tstorage[j] = 0;\n\t\t\t}\n\n\t\t\tthis._results[i] = storage;\n\t\t}\n\t}\n\n}\n\nclass AnimClip {\n\tconstructor(track, time, speed, playing, loop, eventHandler) {\n\t\tthis._name = track.name;\n\t\tthis._track = track;\n\t\tthis._snapshot = new AnimSnapshot(track);\n\t\tthis._playing = playing;\n\t\tthis._time = time;\n\t\tthis._speed = speed;\n\t\tthis._loop = loop;\n\t\tthis._blendWeight = 1.0;\n\t\tthis._blendOrder = 0.0;\n\t\tthis._eventHandler = eventHandler;\n\t\tthis._eventCursor = 0;\n\n\t\twhile (this._track.events[this._eventCursor] && this._track.events[this._eventCursor].time < this.time) {\n\t\t\tthis._eventCursor++;\n\t\t}\n\t}\n\n\tset name(name) {\n\t\tthis._name = name;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tget track() {\n\t\treturn this._track;\n\t}\n\n\tget snapshot() {\n\t\treturn this._snapshot;\n\t}\n\n\tset time(time) {\n\t\tthis._time = time;\n\t}\n\n\tget time() {\n\t\treturn this._time;\n\t}\n\n\tset speed(speed) {\n\t\tthis._speed = speed;\n\t}\n\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t}\n\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\n\tset blendWeight(blendWeight) {\n\t\tthis._blendWeight = blendWeight;\n\t}\n\n\tget blendWeight() {\n\t\treturn this._blendWeight;\n\t}\n\n\tset blendOrder(blendOrder) {\n\t\tthis._blendOrder = blendOrder;\n\t}\n\n\tget blendOrder() {\n\t\treturn this._blendOrder;\n\t}\n\n\tset eventCursor(value) {\n\t\tthis._eventCursor = value;\n\t}\n\n\tget eventCursor() {\n\t\treturn this._eventCursor;\n\t}\n\n\tactiveEventsForFrame(frameStartTime, frameEndTime) {\n\t\tif (frameStartTime === 0) {\n\t\t\tthis.eventCursor = 0;\n\t\t}\n\n\t\tlet clippedFrameDuration;\n\n\t\tif (frameEndTime > this.track.duration) {\n\t\t\tclippedFrameDuration = frameEndTime - this.track.duration;\n\t\t\tframeEndTime = this.track.duration;\n\t\t}\n\n\t\twhile (this.track.events[this.eventCursor] && this.track.events[this.eventCursor].time >= frameStartTime && (frameEndTime === this.track.duration ? this.track.events[this.eventCursor].time <= frameEndTime : this.track.events[this.eventCursor].time < frameEndTime)) {\n\t\t\tconst event = this.track.events[this.eventCursor];\n\n\t\t\tthis._eventHandler.fire(event.name, _extends({\n\t\t\t\ttrack: this.track\n\t\t\t}, event));\n\n\t\t\tthis.eventCursor++;\n\t\t}\n\n\t\tif (Number.isFinite(clippedFrameDuration)) {\n\t\t\tthis.activeEventsForFrame(0, clippedFrameDuration);\n\t\t}\n\t}\n\n\t_update(deltaTime) {\n\t\tif (this._playing) {\n\t\t\tlet time = this._time;\n\t\t\tconst duration = this._track.duration;\n\t\t\tconst speed = this._speed;\n\t\t\tconst loop = this._loop;\n\n\t\t\tif (this._track.events.length > 0 && duration > 0) {\n\t\t\t\tthis.activeEventsForFrame(time, time + speed * deltaTime);\n\t\t\t}\n\n\t\t\ttime += speed * deltaTime;\n\n\t\t\tif (speed >= 0) {\n\t\t\t\tif (time > duration) {\n\t\t\t\t\tif (loop) {\n\t\t\t\t\t\ttime = time % duration || 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime = this._track.duration;\n\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (time < 0) {\n\t\t\t\t\tif (loop) {\n\t\t\t\t\t\ttime = duration + (time % duration || 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime = 0;\n\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._time = time;\n\t\t}\n\n\t\tif (this._time !== this._snapshot._time) {\n\t\t\tthis._track.eval(this._time, this._snapshot);\n\t\t}\n\t}\n\n\tplay() {\n\t\tthis._playing = true;\n\t\tthis._time = 0;\n\t}\n\n\tstop() {\n\t\tthis._playing = false;\n\t\tthis._time = 0;\n\t}\n\n\tpause() {\n\t\tthis._playing = false;\n\t}\n\n\tresume() {\n\t\tthis._playing = true;\n\t}\n\n\treset() {\n\t\tthis._time = 0;\n\t}\n\n}\n\nconst ANIM_INTERRUPTION_NONE = 'NONE';\nconst ANIM_INTERRUPTION_PREV = 'PREV_STATE';\nconst ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';\nconst ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';\nconst ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';\nconst ANIM_GREATER_THAN = 'GREATER_THAN';\nconst ANIM_LESS_THAN = 'LESS_THAN';\nconst ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';\nconst ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';\nconst ANIM_EQUAL_TO = 'EQUAL_TO';\nconst ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';\nconst ANIM_PARAMETER_INTEGER = 'INTEGER';\nconst ANIM_PARAMETER_FLOAT = 'FLOAT';\nconst ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';\nconst ANIM_PARAMETER_TRIGGER = 'TRIGGER';\nconst ANIM_BLEND_1D = '1D';\nconst ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';\nconst ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';\nconst ANIM_BLEND_DIRECT = 'DIRECT';\nconst ANIM_STATE_START = 'START';\nconst ANIM_STATE_END = 'END';\nconst ANIM_STATE_ANY = 'ANY';\nconst ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];\nconst ANIM_LAYER_OVERWRITE = 'OVERWRITE';\nconst ANIM_LAYER_ADDITIVE = 'ADDITIVE';\n\nclass AnimTargetValue {\n\tconstructor(component, type) {\n\t\tthis._component = component;\n\t\tthis.mask = new Int8Array(component.layers.length);\n\t\tthis.weights = new Float32Array(component.layers.length);\n\t\tthis.totalWeight = 0;\n\t\tthis.counter = 0;\n\t\tthis.layerCounter = 0;\n\t\tthis.valueType = type;\n\t\tthis.dirty = true;\n\t\tthis.value = [0, 0, 0, 1];\n\t}\n\n\tgetWeight(index) {\n\t\tif (this.dirty) this.updateWeights();\n\n\t\tif (this.totalWeight === 0 || !this.mask[index]) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.weights[index] / this.totalWeight;\n\t}\n\n\tsetMask(index, value) {\n\t\tthis.mask[index] = value;\n\n\t\tif (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {\n\t\t\tthis.mask = this.mask.fill(0, 0, index);\n\t\t}\n\n\t\tthis.dirty = true;\n\t}\n\n\tupdateWeights() {\n\t\tthis.totalWeight = 0;\n\n\t\tfor (let i = 0; i < this.weights.length; i++) {\n\t\t\tthis.weights[i] = this._component.layers[i].weight;\n\t\t\tthis.totalWeight += this.mask[i] * this.weights[i];\n\t\t}\n\n\t\tthis.dirty = false;\n\t}\n\n\tupdateValue(index, value) {\n\t\tif (this.counter === 0) {\n\t\t\tthis.value[0] = 0;\n\t\t\tthis.value[1] = 0;\n\t\t\tthis.value[2] = 0;\n\t\t\tthis.value[3] = 1;\n\t\t}\n\n\t\tif (!this.mask[index]) return;\n\n\t\tif (this.counter === 0) {\n\t\t\tAnimEvaluator._set(this.value, value, this.valueType);\n\t\t} else {\n\t\t\tAnimEvaluator._blend(this.value, value, this.getWeight(index), this.valueType);\n\t\t}\n\t}\n\n}\n\nAnimTargetValue.TYPE_QUAT = 'quaternion';\nAnimTargetValue.TYPE_VEC3 = 'vector3';\n\nclass AnimEvaluator {\n\tconstructor(binder) {\n\t\tthis._binder = binder;\n\t\tthis._clips = [];\n\t\tthis._inputs = [];\n\t\tthis._outputs = [];\n\t\tthis._targets = {};\n\t}\n\n\tget clips() {\n\t\treturn this._clips;\n\t}\n\n\tstatic _dot(a, b) {\n\t\tconst len = a.length;\n\t\tlet result = 0;\n\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\tresult += a[i] * b[i];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstatic _normalize(a) {\n\t\tlet l = AnimEvaluator._dot(a, a);\n\n\t\tif (l > 0) {\n\t\t\tl = 1.0 / Math.sqrt(l);\n\t\t\tconst len = a.length;\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] *= l;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic _set(a, b, type) {\n\t\tconst len = a.length;\n\n\t\tif (type === 'quaternion') {\n\t\t\tlet l = AnimEvaluator._dot(b, b);\n\n\t\t\tif (l > 0) {\n\t\t\t\tl = 1.0 / Math.sqrt(l);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] = b[i] * l;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] = b[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic _blendVec(a, b, t) {\n\t\tconst it = 1.0 - t;\n\t\tconst len = a.length;\n\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\ta[i] = a[i] * it + b[i] * t;\n\t\t}\n\t}\n\n\tstatic _blendQuat(a, b, t) {\n\t\tconst len = a.length;\n\t\tconst it = 1.0 - t;\n\n\t\tif (AnimEvaluator._dot(a, b) < 0) {\n\t\t\tt = -t;\n\t\t}\n\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\ta[i] = a[i] * it + b[i] * t;\n\t\t}\n\n\t\tAnimEvaluator._normalize(a);\n\t}\n\n\tstatic _blend(a, b, t, type) {\n\t\tif (type === 'quaternion') {\n\t\t\tAnimEvaluator._blendQuat(a, b, t);\n\t\t} else {\n\t\t\tAnimEvaluator._blendVec(a, b, t);\n\t\t}\n\t}\n\n\tstatic _stableSort(a, lessFunc) {\n\t\tconst len = a.length;\n\n\t\tfor (let i = 0; i < len - 1; ++i) {\n\t\t\tfor (let j = i + 1; j < len; ++j) {\n\t\t\t\tif (lessFunc(a[j], a[i])) {\n\t\t\t\t\tconst tmp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taddClip(clip) {\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\t\tconst curves = clip.track.curves;\n\t\tconst snapshot = clip.snapshot;\n\t\tconst inputs = [];\n\t\tconst outputs = [];\n\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst paths = curve.paths;\n\n\t\t\tfor (let j = 0; j < paths.length; ++j) {\n\t\t\t\tconst path = paths[j];\n\t\t\t\tconst resolved = binder.resolve(path);\n\t\t\t\tlet target = targets[resolved && resolved.targetPath || null];\n\n\t\t\t\tif (!target && resolved) {\n\t\t\t\t\ttarget = {\n\t\t\t\t\t\ttarget: resolved,\n\t\t\t\t\t\tvalue: [],\n\t\t\t\t\t\tcurves: 0,\n\t\t\t\t\t\tblendCounter: 0\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (let k = 0; k < target.target.components; ++k) {\n\t\t\t\t\t\ttarget.value.push(0);\n\t\t\t\t\t}\n\n\t\t\t\t\ttargets[resolved.targetPath] = target;\n\n\t\t\t\t\tif (binder.animComponent) {\n\t\t\t\t\t\tif (!binder.animComponent.targets[resolved.targetPath]) {\n\t\t\t\t\t\t\tlet type;\n\n\t\t\t\t\t\t\tif (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {\n\t\t\t\t\t\t\t\ttype = AnimTargetValue.TYPE_QUAT;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttype = AnimTargetValue.TYPE_VEC3;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath].layerCounter++;\n\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target) {\n\t\t\t\t\ttarget.curves++;\n\t\t\t\t\tinputs.push(snapshot._results[i]);\n\t\t\t\t\toutputs.push(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._clips.push(clip);\n\n\t\tthis._inputs.push(inputs);\n\n\t\tthis._outputs.push(outputs);\n\t}\n\n\tremoveClip(index) {\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\t\tconst clips = this._clips;\n\t\tconst clip = clips[index];\n\t\tconst curves = clip.track.curves;\n\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst paths = curve.paths;\n\n\t\t\tfor (let j = 0; j < paths.length; ++j) {\n\t\t\t\tconst path = paths[j];\n\n\t\t\t\tconst target = this._binder.resolve(path);\n\n\t\t\t\tif (target) {\n\t\t\t\t\ttarget.curves--;\n\n\t\t\t\t\tif (target.curves === 0) {\n\t\t\t\t\t\tbinder.unresolve(path);\n\t\t\t\t\t\tdelete targets[target.targetPath];\n\n\t\t\t\t\t\tif (binder.animComponent) {\n\t\t\t\t\t\t\tbinder.animComponent.targets[target.targetPath].layerCounter--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclips.splice(index, 1);\n\n\t\tthis._inputs.splice(index, 1);\n\n\t\tthis._outputs.splice(index, 1);\n\t}\n\n\tremoveClips() {\n\t\twhile (this._clips.length > 0) {\n\t\t\tthis.removeClip(0);\n\t\t}\n\t}\n\n\tfindClip(name) {\n\t\tconst clips = this._clips;\n\n\t\tfor (let i = 0; i < clips.length; ++i) {\n\t\t\tconst clip = clips[i];\n\n\t\t\tif (clip.name === name) {\n\t\t\t\treturn clip;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\trebind() {\n\t\tthis._binder.rebind();\n\n\t\tthis._targets = {};\n\t\tconst clips = [...this.clips];\n\t\tthis.removeClips();\n\t\tclips.forEach(clip => {\n\t\t\tthis.addClip(clip);\n\t\t});\n\t}\n\n\tassignMask(mask) {\n\t\treturn this._binder.assignMask(mask);\n\t}\n\n\tupdate(deltaTime) {\n\t\tconst clips = this._clips;\n\t\tconst order = clips.map(function (c, i) {\n\t\t\treturn i;\n\t\t});\n\n\t\tAnimEvaluator._stableSort(order, function (a, b) {\n\t\t\treturn clips[a].blendOrder < clips[b].blendOrder;\n\t\t});\n\n\t\tfor (let i = 0; i < order.length; ++i) {\n\t\t\tconst index = order[i];\n\t\t\tconst clip = clips[index];\n\t\t\tconst inputs = this._inputs[index];\n\t\t\tconst outputs = this._outputs[index];\n\t\t\tconst blendWeight = clip.blendWeight;\n\n\t\t\tif (blendWeight > 0.0) {\n\t\t\t\tclip._update(deltaTime);\n\t\t\t}\n\n\t\t\tlet input;\n\t\t\tlet output;\n\t\t\tlet value;\n\n\t\t\tif (blendWeight >= 1.0) {\n\t\t\t\tfor (let j = 0; j < inputs.length; ++j) {\n\t\t\t\t\tinput = inputs[j];\n\t\t\t\t\toutput = outputs[j];\n\t\t\t\t\tvalue = output.value;\n\n\t\t\t\t\tAnimEvaluator._set(value, input, output.target.type);\n\n\t\t\t\t\toutput.blendCounter++;\n\t\t\t\t}\n\t\t\t} else if (blendWeight > 0.0) {\n\t\t\t\tfor (let j = 0; j < inputs.length; ++j) {\n\t\t\t\t\tinput = inputs[j];\n\t\t\t\t\toutput = outputs[j];\n\t\t\t\t\tvalue = output.value;\n\n\t\t\t\t\tif (output.blendCounter === 0) {\n\t\t\t\t\t\tAnimEvaluator._set(value, input, output.target.type);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAnimEvaluator._blend(value, input, blendWeight, output.target.type);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.blendCounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\n\t\tfor (const path in targets) {\n\t\t\tif (targets.hasOwnProperty(path)) {\n\t\t\t\tconst target = targets[path];\n\n\t\t\t\tif (binder.animComponent && target.target.isTransform) {\n\t\t\t\t\tconst animTarget = binder.animComponent.targets[path];\n\n\t\t\t\t\tif (animTarget.counter === animTarget.layerCounter) {\n\t\t\t\t\t\tanimTarget.counter = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tanimTarget.updateValue(binder.layerIndex, target.value);\n\t\t\t\t\ttarget.target.func(animTarget.value);\n\t\t\t\t\tanimTarget.counter++;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.target.func(target.value);\n\t\t\t\t}\n\n\t\t\t\ttarget.blendCounter = 0;\n\t\t\t}\n\t\t}\n\n\t\tbinder.update(deltaTime);\n\t}\n\n}\n\nclass AnimBinder {\n\tstatic joinPath(pathSegments, character) {\n\t\tcharacter = character || '.';\n\n\t\tconst escape = function escape(string) {\n\t\t\treturn string.replace(/\\\\/g, '\\\\\\\\').replace(new RegExp('\\\\' + character, 'g'), '\\\\' + character);\n\t\t};\n\n\t\treturn pathSegments.map(escape).join(character);\n\t}\n\n\tstatic splitPath(path, character) {\n\t\tcharacter = character || '.';\n\t\tconst result = [];\n\t\tlet curr = \"\";\n\t\tlet i = 0;\n\n\t\twhile (i < path.length) {\n\t\t\tlet c = path[i++];\n\n\t\t\tif (c === '\\\\' && i < path.length) {\n\t\t\t\tc = path[i++];\n\n\t\t\t\tif (c === '\\\\' || c === character) {\n\t\t\t\t\tcurr += c;\n\t\t\t\t} else {\n\t\t\t\t\tcurr += '\\\\' + c;\n\t\t\t\t}\n\t\t\t} else if (c === character) {\n\t\t\t\tresult.push(curr);\n\t\t\t\tcurr = '';\n\t\t\t} else {\n\t\t\t\tcurr += c;\n\t\t\t}\n\t\t}\n\n\t\tif (curr.length > 0) {\n\t\t\tresult.push(curr);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstatic encode(entityPath, component, propertyPath) {\n\t\treturn `${Array.isArray(entityPath) ? entityPath.join('/') : entityPath}/${component}/${Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath}`;\n\t}\n\n\tresolve(path) {\n\t\treturn null;\n\t}\n\n\tunresolve(path) {}\n\n\tupdate(deltaTime) {}\n\n}\n\nclass AnimTarget {\n\tconstructor(func, type, components, targetPath) {\n\t\tthis._func = func;\n\t\tthis._type = type;\n\t\tthis._components = components;\n\t\tthis._targetPath = targetPath;\n\t\tthis._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';\n\t}\n\n\tget func() {\n\t\treturn this._func;\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tget components() {\n\t\treturn this._components;\n\t}\n\n\tget targetPath() {\n\t\treturn this._targetPath;\n\t}\n\n\tget isTransform() {\n\t\treturn this._isTransform;\n\t}\n\n}\n\nclass DefaultAnimBinder {\n\tconstructor(graph) {\n\t\tthis._isPathInMask = (path, checkMaskValue) => {\n\t\t\tconst maskItem = this._mask[path];\n\t\t\tif (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;\n\t\t\treturn false;\n\t\t};\n\n\t\tthis.graph = graph;\n\t\tif (!graph) return;\n\t\tthis._mask = null;\n\t\tconst nodes = {};\n\n\t\tconst flatten = function flatten(node) {\n\t\t\tnodes[node.name] = node;\n\n\t\t\tfor (let i = 0; i < node.children.length; ++i) {\n\t\t\t\tflatten(node.children[i]);\n\t\t\t}\n\t\t};\n\n\t\tflatten(graph);\n\t\tthis.nodes = nodes;\n\t\tthis.targetCache = {};\n\n\t\tconst findMeshInstances = function findMeshInstances(node) {\n\t\t\tlet object = node;\n\n\t\t\twhile (object && !(object instanceof Entity)) {\n\t\t\t\tobject = object.parent;\n\t\t\t}\n\n\t\t\tlet meshInstances;\n\n\t\t\tif (object) {\n\t\t\t\tif (object.render) {\n\t\t\t\t\tmeshInstances = object.render.meshInstances;\n\t\t\t\t} else if (object.model) {\n\t\t\t\t\tmeshInstances = object.model.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn meshInstances;\n\t\t};\n\n\t\tthis.nodeCounts = {};\n\t\tthis.activeNodes = [];\n\t\tthis.handlers = {\n\t\t\t'localPosition': function (node) {\n\t\t\t\tconst object = node.localPosition;\n\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');\n\t\t\t},\n\t\t\t'localRotation': function (node) {\n\t\t\t\tconst object = node.localRotation;\n\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');\n\t\t\t},\n\t\t\t'localScale': function (node) {\n\t\t\t\tconst object = node.localScale;\n\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');\n\t\t\t},\n\t\t\t'weights': function (node) {\n\t\t\t\tconst meshInstances = findMeshInstances(node);\n\n\t\t\t\tif (meshInstances) {\n\t\t\t\t\tconst morphInstances = [];\n\n\t\t\t\t\tfor (let i = 0; i < meshInstances.length; ++i) {\n\t\t\t\t\t\tif (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {\n\t\t\t\t\t\t\tmorphInstances.push(meshInstances[i].morphInstance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (morphInstances.length > 0) {\n\t\t\t\t\t\tconst func = function func(value) {\n\t\t\t\t\t\t\tfor (let i = 0; i < value.length; ++i) {\n\t\t\t\t\t\t\t\tfor (let j = 0; j < morphInstances.length; j++) {\n\t\t\t\t\t\t\t\t\tmorphInstances[j].setWeight(i, value[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', morphInstances[0].morph._targets.length, node, 'weights');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\t'materialTexture': (node, textureName) => {\n\t\t\t\tconst meshInstances = findMeshInstances(node);\n\n\t\t\t\tif (meshInstances) {\n\t\t\t\t\tlet meshInstance;\n\n\t\t\t\t\tfor (let i = 0; i < meshInstances.length; ++i) {\n\t\t\t\t\t\tif (meshInstances[i].node.name === node.name) {\n\t\t\t\t\t\t\tmeshInstance = meshInstances[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meshInstance) {\n\t\t\t\t\t\tconst func = value => {\n\t\t\t\t\t\t\tconst textureAsset = this.animComponent.system.app.assets.get(value[0]);\n\n\t\t\t\t\t\t\tif (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {\n\t\t\t\t\t\t\t\tmeshInstance.material[textureName] = textureAsset.resource;\n\t\t\t\t\t\t\t\tmeshInstance.material.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\n\t_isPathActive(path) {\n\t\tif (!this._mask) return true;\n\t\tconst rootNodeNames = [path.entityPath[0], this.graph.name];\n\n\t\tfor (let j = 0; j < rootNodeNames.length; ++j) {\n\t\t\tlet currEntityPath = rootNodeNames[j];\n\t\t\tif (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;\n\n\t\t\tfor (let i = 1; i < path.entityPath.length; i++) {\n\t\t\t\tcurrEntityPath += '/' + path.entityPath[i];\n\t\t\t\tif (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfindNode(path) {\n\t\tif (!this._isPathActive(path)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet node;\n\n\t\tif (this.graph) {\n\t\t\tnode = this.graph.findByPath(path.entityPath);\n\t\t}\n\n\t\tif (!node) {\n\t\t\tnode = this.nodes[path.entityPath[path.entityPath.length - 1] || \"\"];\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tstatic createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {\n\t\tconst targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);\n\t\treturn new AnimTarget(func, type, valueCount, targetPath);\n\t}\n\n\tresolve(path) {\n\t\tconst encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);\n\t\tlet target = this.targetCache[encodedPath];\n\t\tif (target) return target;\n\t\tconst node = this.findNode(path);\n\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst handler = this.handlers[path.propertyPath];\n\n\t\tif (!handler) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttarget = handler(node);\n\n\t\tif (!target) {\n\t\t\treturn null;\n\t\t}\n\n\t\tthis.targetCache[encodedPath] = target;\n\n\t\tif (!this.nodeCounts[node.path]) {\n\t\t\tthis.activeNodes.push(node);\n\t\t\tthis.nodeCounts[node.path] = 1;\n\t\t} else {\n\t\t\tthis.nodeCounts[node.path]++;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tunresolve(path) {\n\t\tif (path.component !== 'graph') return;\n\t\tconst node = this.nodes[path.entityPath[path.entityPath.length - 1] || \"\"];\n\t\tthis.nodeCounts[node.path]--;\n\n\t\tif (this.nodeCounts[node.path] === 0) {\n\t\t\tconst activeNodes = this.activeNodes;\n\t\t\tconst i = activeNodes.indexOf(node.node);\n\t\t\tconst len = activeNodes.length;\n\n\t\t\tif (i < len - 1) {\n\t\t\t\tactiveNodes[i] = activeNodes[len - 1];\n\t\t\t}\n\n\t\t\tactiveNodes.pop();\n\t\t}\n\t}\n\n\tupdate(deltaTime) {\n\t\tconst activeNodes = this.activeNodes;\n\n\t\tfor (let i = 0; i < activeNodes.length; ++i) {\n\t\t\tactiveNodes[i]._dirtifyLocal();\n\t\t}\n\t}\n\n\tassignMask(mask) {\n\t\tif (mask !== this._mask) {\n\t\t\tthis._mask = mask;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nclass InterpolatedKey {\n\tconstructor() {\n\t\tthis._written = false;\n\t\tthis._name = \"\";\n\t\tthis._keyFrames = [];\n\t\tthis._quat = new Quat();\n\t\tthis._pos = new Vec3();\n\t\tthis._scale = new Vec3();\n\t\tthis._targetNode = null;\n\t}\n\n\tgetTarget() {\n\t\treturn this._targetNode;\n\t}\n\n\tsetTarget(node) {\n\t\tthis._targetNode = node;\n\t}\n\n}\n\nclass Skeleton {\n\tconstructor(graph) {\n\t\tthis.looping = true;\n\t\tthis._animation = null;\n\t\tthis._time = 0;\n\t\tthis._interpolatedKeys = [];\n\t\tthis._interpolatedKeyDict = {};\n\t\tthis._currKeyIndices = {};\n\t\tthis.graph = null;\n\n\t\tconst addInterpolatedKeys = node => {\n\t\t\tconst interpKey = new InterpolatedKey();\n\t\t\tinterpKey._name = node.name;\n\n\t\t\tthis._interpolatedKeys.push(interpKey);\n\n\t\t\tthis._interpolatedKeyDict[node.name] = interpKey;\n\t\t\tthis._currKeyIndices[node.name] = 0;\n\n\t\t\tfor (let i = 0; i < node._children.length; i++) addInterpolatedKeys(node._children[i]);\n\t\t};\n\n\t\taddInterpolatedKeys(graph);\n\t}\n\n\tset animation(value) {\n\t\tthis._animation = value;\n\t\tthis.currentTime = 0;\n\t}\n\n\tget animation() {\n\t\treturn this._animation;\n\t}\n\n\tset currentTime(value) {\n\t\tthis._time = value;\n\t\tconst numNodes = this._interpolatedKeys.length;\n\n\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\tconst node = this._interpolatedKeys[i];\n\t\t\tconst nodeName = node._name;\n\t\t\tthis._currKeyIndices[nodeName] = 0;\n\t\t}\n\n\t\tthis.addTime(0);\n\t\tthis.updateGraph();\n\t}\n\n\tget currentTime() {\n\t\treturn this._time;\n\t}\n\n\tget numNodes() {\n\t\treturn this._interpolatedKeys.length;\n\t}\n\n\taddTime(delta) {\n\t\tif (this._animation !== null) {\n\t\t\tconst nodes = this._animation._nodes;\n\t\t\tconst duration = this._animation.duration;\n\n\t\t\tif (this._time === duration && !this.looping) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._time += delta;\n\n\t\t\tif (this._time > duration) {\n\t\t\t\tthis._time = this.looping ? 0.0 : duration;\n\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tconst node = nodes[i];\n\t\t\t\t\tconst nodeName = node._name;\n\t\t\t\t\tthis._currKeyIndices[nodeName] = 0;\n\t\t\t\t}\n\t\t\t} else if (this._time < 0) {\n\t\t\t\tthis._time = this.looping ? duration : 0.0;\n\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tconst node = nodes[i];\n\t\t\t\t\tconst nodeName = node._name;\n\t\t\t\t\tthis._currKeyIndices[nodeName] = node._keys.length - 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst offset = delta >= 0 ? 1 : -1;\n\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tconst node = nodes[i];\n\t\t\t\tconst nodeName = node._name;\n\t\t\t\tconst keys = node._keys;\n\t\t\t\tconst interpKey = this._interpolatedKeyDict[nodeName];\n\n\t\t\t\tif (interpKey === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet foundKey = false;\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tfor (let currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {\n\t\t\t\t\t\tconst k1 = keys[currKeyIndex];\n\t\t\t\t\t\tconst k2 = keys[currKeyIndex + 1];\n\n\t\t\t\t\t\tif (k1.time <= this._time && k2.time >= this._time) {\n\t\t\t\t\t\t\tconst alpha = (this._time - k1.time) / (k2.time - k1.time);\n\n\t\t\t\t\t\t\tinterpKey._pos.lerp(k1.position, k2.position, alpha);\n\n\t\t\t\t\t\t\tinterpKey._quat.slerp(k1.rotation, k2.rotation, alpha);\n\n\t\t\t\t\t\t\tinterpKey._scale.lerp(k1.scale, k2.scale, alpha);\n\n\t\t\t\t\t\t\tinterpKey._written = true;\n\t\t\t\t\t\t\tthis._currKeyIndices[nodeName] = currKeyIndex;\n\t\t\t\t\t\t\tfoundKey = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {\n\t\t\t\t\tinterpKey._pos.copy(keys[0].position);\n\n\t\t\t\t\tinterpKey._quat.copy(keys[0].rotation);\n\n\t\t\t\t\tinterpKey._scale.copy(keys[0].scale);\n\n\t\t\t\t\tinterpKey._written = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblend(skel1, skel2, alpha) {\n\t\tconst numNodes = this._interpolatedKeys.length;\n\n\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\tconst key1 = skel1._interpolatedKeys[i];\n\t\t\tconst key2 = skel2._interpolatedKeys[i];\n\t\t\tconst dstKey = this._interpolatedKeys[i];\n\n\t\t\tif (key1._written && key2._written) {\n\t\t\t\tdstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);\n\n\t\t\t\tdstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);\n\n\t\t\t\tdstKey._scale.lerp(key1._scale, key2._scale, alpha);\n\n\t\t\t\tdstKey._written = true;\n\t\t\t} else if (key1._written) {\n\t\t\t\tdstKey._quat.copy(key1._quat);\n\n\t\t\t\tdstKey._pos.copy(key1._pos);\n\n\t\t\t\tdstKey._scale.copy(key1._scale);\n\n\t\t\t\tdstKey._written = true;\n\t\t\t} else if (key2._written) {\n\t\t\t\tdstKey._quat.copy(key2._quat);\n\n\t\t\t\tdstKey._pos.copy(key2._pos);\n\n\t\t\t\tdstKey._scale.copy(key2._scale);\n\n\t\t\t\tdstKey._written = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetGraph(graph) {\n\t\tthis.graph = graph;\n\n\t\tif (graph) {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tconst interpKey = this._interpolatedKeys[i];\n\t\t\t\tconst graphNode = graph.findByName(interpKey._name);\n\n\t\t\t\tthis._interpolatedKeys[i].setTarget(graphNode);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tthis._interpolatedKeys[i].setTarget(null);\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateGraph() {\n\t\tif (this.graph) {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tconst interpKey = this._interpolatedKeys[i];\n\n\t\t\t\tif (interpKey._written) {\n\t\t\t\t\tconst transform = interpKey.getTarget();\n\t\t\t\t\ttransform.localPosition.copy(interpKey._pos);\n\t\t\t\t\ttransform.localRotation.copy(interpKey._quat);\n\t\t\t\t\ttransform.localScale.copy(interpKey._scale);\n\t\t\t\t\tif (!transform._dirtyLocal) transform._dirtifyLocal();\n\t\t\t\t\tinterpKey._written = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimationComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.animationsIndex = {};\n\t\tthis.on('set_animations', this.onSetAnimations, this);\n\t\tthis.on('set_assets', this.onSetAssets, this);\n\t\tthis.on('set_loop', this.onSetLoop, this);\n\t}\n\n\tset currentTime(currentTime) {\n\t\tconst data = this.data;\n\n\t\tif (data.skeleton) {\n\t\t\tconst skeleton = data.skeleton;\n\t\t\tskeleton.currentTime = currentTime;\n\t\t\tskeleton.addTime(0);\n\t\t\tskeleton.updateGraph();\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tconst animEvaluator = data.animEvaluator;\n\n\t\t\tfor (let i = 0; i < animEvaluator.clips.length; ++i) {\n\t\t\t\tanimEvaluator.clips[i].time = currentTime;\n\t\t\t}\n\t\t}\n\t}\n\n\tget currentTime() {\n\t\tconst data = this.data;\n\n\t\tif (data.skeleton) {\n\t\t\treturn this.data.skeleton._time;\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tconst clips = data.animEvaluator.clips;\n\n\t\t\tif (clips.length > 0) {\n\t\t\t\treturn clips[clips.length - 1].time;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tget duration() {\n\t\treturn this.data.animations[this.data.currAnim].duration;\n\t}\n\n\tplay(name, blendTime = 0) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst data = this.data;\n\n\t\tif (!data.animations[name]) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata.prevAnim = data.currAnim;\n\t\tdata.currAnim = name;\n\n\t\tif (data.model) {\n\t\t\tif (!data.skeleton && !data.animEvaluator) {\n\t\t\t\tthis._createAnimationController();\n\t\t\t}\n\n\t\t\tconst prevAnim = data.animations[data.prevAnim];\n\t\t\tconst currAnim = data.animations[data.currAnim];\n\t\t\tdata.blending = blendTime > 0 && data.prevAnim;\n\n\t\t\tif (data.blending) {\n\t\t\t\tdata.blend = 0;\n\t\t\t\tdata.blendSpeed = 1.0 / blendTime;\n\t\t\t}\n\n\t\t\tif (data.skeleton) {\n\t\t\t\tif (data.blending) {\n\t\t\t\t\tdata.fromSkel.animation = prevAnim;\n\t\t\t\t\tdata.fromSkel.addTime(data.skeleton._time);\n\t\t\t\t\tdata.toSkel.animation = currAnim;\n\t\t\t\t} else {\n\t\t\t\t\tdata.skeleton.animation = currAnim;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.animEvaluator) {\n\t\t\t\tconst animEvaluator = data.animEvaluator;\n\n\t\t\t\tif (data.blending) {\n\t\t\t\t\twhile (animEvaluator.clips.length > 1) {\n\t\t\t\t\t\tanimEvaluator.removeClip(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata.animEvaluator.removeClips();\n\t\t\t\t}\n\n\t\t\t\tconst clip = new AnimClip(data.animations[data.currAnim], 0, 1.0, true, data.loop);\n\t\t\t\tclip.name = data.currAnim;\n\t\t\t\tclip.blendWeight = data.blending ? 0 : 1;\n\t\t\t\tclip.reset();\n\t\t\t\tdata.animEvaluator.addClip(clip);\n\t\t\t}\n\t\t}\n\n\t\tdata.playing = true;\n\t}\n\n\tgetAnimation(name) {\n\t\treturn this.data.animations[name];\n\t}\n\n\tsetModel(model) {\n\t\tconst data = this.data;\n\n\t\tif (model !== data.model) {\n\t\t\tthis._resetAnimationController();\n\n\t\t\tdata.model = model;\n\n\t\t\tif (data.animations && data.currAnim && data.animations[data.currAnim]) {\n\t\t\t\tthis.play(data.currAnim);\n\t\t\t}\n\t\t}\n\t}\n\n\t_resetAnimationController() {\n\t\tconst data = this.data;\n\t\tdata.skeleton = null;\n\t\tdata.fromSkel = null;\n\t\tdata.toSkel = null;\n\t\tdata.animEvaluator = null;\n\t}\n\n\t_createAnimationController() {\n\t\tconst data = this.data;\n\t\tconst model = data.model;\n\t\tconst animations = data.animations;\n\t\tlet hasJson = false;\n\t\tlet hasGlb = false;\n\n\t\tfor (const animation in animations) {\n\t\t\tif (animations.hasOwnProperty(animation)) {\n\t\t\t\tconst anim = animations[animation];\n\n\t\t\t\tif (anim.constructor === AnimTrack) {\n\t\t\t\t\thasGlb = true;\n\t\t\t\t} else {\n\t\t\t\t\thasJson = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst graph = model.getGraph();\n\n\t\tif (hasJson) {\n\t\t\tdata.fromSkel = new Skeleton(graph);\n\t\t\tdata.toSkel = new Skeleton(graph);\n\t\t\tdata.skeleton = new Skeleton(graph);\n\t\t\tdata.skeleton.looping = data.loop;\n\t\t\tdata.skeleton.setGraph(graph);\n\t\t} else if (hasGlb) {\n\t\t\tdata.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));\n\t\t}\n\t}\n\n\tloadAnimationAssets(ids) {\n\t\tif (!ids || !ids.length) return;\n\t\tconst assets = this.system.app.assets;\n\n\t\tconst onAssetReady = asset => {\n\t\t\tif (asset.resources.length > 1) {\n\t\t\t\tfor (let i = 0; i < asset.resources.length; i++) {\n\t\t\t\t\tthis.animations[asset.resources[i].name] = asset.resources[i];\n\t\t\t\t\tthis.animationsIndex[asset.id] = asset.resources[i].name;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.animations[asset.name] = asset.resource;\n\t\t\t\tthis.animationsIndex[asset.id] = asset.name;\n\t\t\t}\n\n\t\t\tthis.animations = this.animations;\n\t\t};\n\n\t\tconst onAssetAdd = asset => {\n\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\tasset.on('change', this.onAssetChanged, this);\n\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\n\t\t\tif (asset.resource) {\n\t\t\t\tonAssetReady(asset);\n\t\t\t} else {\n\t\t\t\tasset.once('load', onAssetReady, this);\n\t\t\t\tif (this.enabled && this.entity.enabled) assets.load(asset);\n\t\t\t}\n\t\t};\n\n\t\tfor (let i = 0, l = ids.length; i < l; i++) {\n\t\t\tconst asset = assets.get(ids[i]);\n\n\t\t\tif (asset) {\n\t\t\t\tonAssetAdd(asset);\n\t\t\t} else {\n\t\t\t\tassets.on('add:' + ids[i], onAssetAdd);\n\t\t\t}\n\t\t}\n\t}\n\n\tonAssetChanged(asset, attribute, newValue, oldValue) {\n\t\tif (attribute === 'resource' || attribute === 'resources') {\n\t\t\tif (attribute === 'resources' && newValue && newValue.length === 0) {\n\t\t\t\tnewValue = null;\n\t\t\t}\n\n\t\t\tif (newValue) {\n\t\t\t\tlet restarted = false;\n\n\t\t\t\tif (newValue.length > 1) {\n\t\t\t\t\tif (oldValue && oldValue.length > 1) {\n\t\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this.animations[asset.name];\n\t\t\t\t\t}\n\n\t\t\t\t\trestarted = false;\n\n\t\t\t\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\t\t\t\tthis.animations[newValue[i].name] = newValue[i];\n\n\t\t\t\t\t\tif (!restarted && this.data.currAnim === newValue[i].name) {\n\t\t\t\t\t\t\tif (this.data.playing && this.data.enabled && this.entity.enabled) {\n\t\t\t\t\t\t\t\trestarted = true;\n\t\t\t\t\t\t\t\tthis.play(newValue[i].name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!restarted) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\n\t\t\t\t\t\tthis.onSetAnimations();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (oldValue && oldValue.length > 1) {\n\t\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.animations[asset.name] = newValue[0] || newValue;\n\t\t\t\t\trestarted = false;\n\n\t\t\t\t\tif (this.data.currAnim === asset.name) {\n\t\t\t\t\t\tif (this.data.playing && this.data.enabled && this.entity.enabled) {\n\t\t\t\t\t\t\trestarted = true;\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!restarted) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\n\t\t\t\t\t\tthis.onSetAnimations();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.animationsIndex[asset.id] = asset.name;\n\t\t\t} else {\n\t\t\t\tif (oldValue.length > 1) {\n\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\n\t\t\t\t\t\tif (this.data.currAnim === oldValue[i].name) {\n\t\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.animations[asset.name];\n\n\t\t\t\t\tif (this.data.currAnim === asset.name) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdelete this.animationsIndex[asset.id];\n\t\t\t}\n\t\t}\n\t}\n\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\n\t\tif (this.animations) {\n\t\t\tif (asset.resources.length > 1) {\n\t\t\t\tfor (let i = 0; i < asset.resources.length; i++) {\n\t\t\t\t\tdelete this.animations[asset.resources[i].name];\n\t\t\t\t\tif (this.data.currAnim === asset.resources[i].name) this._stopCurrentAnimation();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete this.animations[asset.name];\n\t\t\t\tif (this.data.currAnim === asset.name) this._stopCurrentAnimation();\n\t\t\t}\n\n\t\t\tdelete this.animationsIndex[asset.id];\n\t\t}\n\t}\n\n\t_stopCurrentAnimation() {\n\t\tconst data = this.data;\n\t\tdata.currAnim = null;\n\t\tdata.playing = false;\n\n\t\tif (data.skeleton) {\n\t\t\tdata.skeleton.currentTime = 0;\n\t\t\tdata.skeleton.animation = null;\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tfor (let i = 0; i < data.animEvaluator.clips.length; ++i) {\n\t\t\t\tdata.animEvaluator.clips[i].stop();\n\t\t\t}\n\n\t\t\tdata.animEvaluator.update(0);\n\t\t\tdata.animEvaluator.removeClips();\n\t\t}\n\t}\n\n\tonSetAnimations(name, oldValue, newValue) {\n\t\tconst data = this.data;\n\t\tconst modelComponent = this.entity.model;\n\n\t\tif (modelComponent) {\n\t\t\tconst m = modelComponent.model;\n\n\t\t\tif (m && m !== data.model) {\n\t\t\t\tthis.setModel(m);\n\t\t\t}\n\t\t}\n\n\t\tif (!data.currAnim && data.activate && data.enabled && this.entity.enabled) {\n\t\t\tconst animationNames = Object.keys(data.animations);\n\n\t\t\tif (animationNames.length > 0) {\n\t\t\t\tthis.play(animationNames[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetAssets(name, oldValue, newValue) {\n\t\tif (oldValue && oldValue.length) {\n\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\tif (oldValue[i]) {\n\t\t\t\t\tconst asset = this.system.app.assets.get(oldValue[i]);\n\n\t\t\t\t\tif (asset) {\n\t\t\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\t\t\tconst animName = this.animationsIndex[asset.id];\n\t\t\t\t\t\tif (this.data.currAnim === animName) this._stopCurrentAnimation();\n\t\t\t\t\t\tdelete this.animations[animName];\n\t\t\t\t\t\tdelete this.animationsIndex[asset.id];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst ids = newValue.map(value => {\n\t\t\treturn value instanceof Asset ? value.id : value;\n\t\t});\n\t\tthis.loadAnimationAssets(ids);\n\t}\n\n\tonSetLoop(name, oldValue, newValue) {\n\t\tconst data = this.data;\n\n\t\tif (data.skeleton) {\n\t\t\tdata.skeleton.looping = data.loop;\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tfor (let i = 0; i < data.animEvaluator.clips.length; ++i) {\n\t\t\t\tdata.animEvaluator.clips[i].loop = data.loop;\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetCurrentTime(name, oldValue, newValue) {\n\t\tconst data = this.data;\n\n\t\tif (data.skeleton) {\n\t\t\tconst skeleton = data.skeleton;\n\t\t\tskeleton.currentTime = newValue;\n\t\t\tskeleton.addTime(0);\n\t\t\tskeleton.updateGraph();\n\t\t}\n\n\t\tif (data.animEvaluator) {\n\t\t\tconst animEvaluator = data.animEvaluator;\n\n\t\t\tfor (let i = 0; i < animEvaluator.clips.length; ++i) {\n\t\t\t\tanimEvaluator.clips[i].time = newValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tsuper.onEnable();\n\t\tconst data = this.data;\n\t\tconst assets = data.assets;\n\t\tconst registry = this.system.app.assets;\n\n\t\tif (assets) {\n\t\t\tfor (let i = 0, len = assets.length; i < len; i++) {\n\t\t\t\tlet asset = assets[i];\n\t\t\t\tif (!(asset instanceof Asset)) asset = registry.get(asset);\n\t\t\t\tif (asset && !asset.resource) registry.load(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (data.activate && !data.currAnim) {\n\t\t\tconst animationNames = Object.keys(data.animations);\n\n\t\t\tif (animationNames.length > 0) {\n\t\t\t\tthis.play(animationNames[0]);\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeRemove() {\n\t\tfor (let i = 0; i < this.assets.length; i++) {\n\t\t\tlet asset = this.assets[i];\n\n\t\t\tif (typeof asset === 'number') {\n\t\t\t\tasset = this.system.app.assets.get(asset);\n\t\t\t}\n\n\t\t\tif (!asset) continue;\n\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t}\n\n\t\tconst data = this.data;\n\t\tdelete data.animation;\n\t\tdelete data.skeleton;\n\t\tdelete data.fromSkel;\n\t\tdelete data.toSkel;\n\t\tdelete data.animEvaluator;\n\t}\n\n}\n\nclass AnimationComponentData {\n\tconstructor() {\n\t\tthis.assets = [];\n\t\tthis.speed = 1.0;\n\t\tthis.loop = true;\n\t\tthis.activate = true;\n\t\tthis.enabled = true;\n\t\tthis.animations = {};\n\t\tthis.model = null;\n\t\tthis.prevAnim = null;\n\t\tthis.currAnim = null;\n\t\tthis.blending = false;\n\t\tthis.blend = 0;\n\t\tthis.blendSpeed = 0;\n\t\tthis.playing = false;\n\t\tthis.skeleton = null;\n\t\tthis.fromSkel = null;\n\t\tthis.toSkel = null;\n\t\tthis.animEvaluator = null;\n\t}\n\n}\n\nconst _schema$l = ['enabled', 'assets', 'speed', 'loop', 'activate', 'animations', 'skeleton', 'model', 'prevAnim', 'currAnim', 'fromSkel', 'toSkel', 'blending', 'blendTimeRemaining', 'playing'];\n\nclass AnimationComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'animation';\n\t\tthis.ComponentType = AnimationComponent;\n\t\tthis.DataType = AnimationComponentData;\n\t\tthis.schema = _schema$l;\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['activate', 'enabled', 'loop', 'speed', 'assets'];\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tthis.addComponent(clone, {});\n\t\tclone.animation.assets = entity.animation.assets.slice();\n\t\tclone.animation.data.speed = entity.animation.speed;\n\t\tclone.animation.data.loop = entity.animation.loop;\n\t\tclone.animation.data.activate = entity.animation.activate;\n\t\tclone.animation.data.enabled = entity.animation.enabled;\n\t\tconst clonedAnimations = {};\n\t\tconst animations = entity.animation.animations;\n\n\t\tfor (const key in animations) {\n\t\t\tif (animations.hasOwnProperty(key)) {\n\t\t\t\tclonedAnimations[key] = animations[key];\n\t\t\t}\n\t\t}\n\n\t\tclone.animation.animations = clonedAnimations;\n\t\tconst clonedAnimationsIndex = {};\n\t\tconst animationsIndex = entity.animation.animationsIndex;\n\n\t\tfor (const key in animationsIndex) {\n\t\t\tif (animationsIndex.hasOwnProperty(key)) {\n\t\t\t\tclonedAnimationsIndex[key] = animationsIndex[key];\n\t\t\t}\n\t\t}\n\n\t\tclone.animation.animationsIndex = clonedAnimationsIndex;\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tconst componentData = component.data;\n\n\t\t\t\tif (componentData.enabled && component.entity.enabled) {\n\t\t\t\t\tif (componentData.blending) {\n\t\t\t\t\t\tcomponentData.blend += dt * componentData.blendSpeed;\n\n\t\t\t\t\t\tif (componentData.blend >= 1.0) {\n\t\t\t\t\t\t\tcomponentData.blend = 1.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (componentData.playing) {\n\t\t\t\t\t\tconst skeleton = componentData.skeleton;\n\n\t\t\t\t\t\tif (skeleton !== null && componentData.model !== null) {\n\t\t\t\t\t\t\tif (componentData.blending) {\n\t\t\t\t\t\t\t\tskeleton.blend(componentData.fromSkel, componentData.toSkel, componentData.blend);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst delta = dt * componentData.speed;\n\t\t\t\t\t\t\t\tskeleton.addTime(delta);\n\n\t\t\t\t\t\t\t\tif (componentData.speed > 0 && skeleton._time === skeleton._animation.duration && !componentData.loop) {\n\t\t\t\t\t\t\t\t\tcomponentData.playing = false;\n\t\t\t\t\t\t\t\t} else if (componentData.speed < 0 && skeleton._time === 0 && !componentData.loop) {\n\t\t\t\t\t\t\t\t\tcomponentData.playing = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (componentData.blending && componentData.blend === 1.0) {\n\t\t\t\t\t\t\t\tskeleton.animation = componentData.toSkel._animation;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tskeleton.updateGraph();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst animEvaluator = componentData.animEvaluator;\n\n\t\t\t\t\tif (animEvaluator) {\n\t\t\t\t\t\tfor (let i = 0; i < animEvaluator.clips.length; ++i) {\n\t\t\t\t\t\t\tconst clip = animEvaluator.clips[i];\n\t\t\t\t\t\t\tclip.speed = componentData.speed;\n\n\t\t\t\t\t\t\tif (!componentData.playing) {\n\t\t\t\t\t\t\t\tclip.pause();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclip.resume();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (componentData.blending && animEvaluator.clips.length > 1) {\n\t\t\t\t\t\t\tanimEvaluator.clips[1].blendWeight = componentData.blend;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tanimEvaluator.update(dt);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (componentData.blending && componentData.blend === 1.0) {\n\t\t\t\t\t\tcomponentData.blending = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(AnimationComponent.prototype, _schema$l);\n\nclass AnimNode {\n\tconstructor(state, parent, name, point, speed = 1) {\n\t\tthis._state = state;\n\t\tthis._parent = parent;\n\t\tthis._name = name;\n\n\t\tif (Array.isArray(point)) {\n\t\t\tthis._point = new Vec2(point[0], point[1]);\n\t\t\tthis._pointLength = this._point.length();\n\t\t} else {\n\t\t\tthis._point = point;\n\t\t\tthis._pointLength = point;\n\t\t}\n\n\t\tthis._speed = speed;\n\t\tthis._weightedSpeed = 1.0;\n\t\tthis._weight = 1.0;\n\t\tthis._animTrack = null;\n\t}\n\n\tget parent() {\n\t\treturn this._parent;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tget path() {\n\t\treturn this._parent ? this._parent.path + '.' + this._name : this._name;\n\t}\n\n\tget point() {\n\t\treturn this._point;\n\t}\n\n\tget pointLength() {\n\t\treturn this._pointLength;\n\t}\n\n\tset weight(value) {\n\t\tthis._weight = value;\n\t}\n\n\tget weight() {\n\t\treturn this._parent ? this._parent.weight * this._weight : this._weight;\n\t}\n\n\tget normalizedWeight() {\n\t\tconst totalWeight = this._state.totalWeight;\n\t\tif (totalWeight === 0.0) return 0.0;\n\t\treturn this.weight / totalWeight;\n\t}\n\n\tget speed() {\n\t\treturn this._weightedSpeed * this._speed;\n\t}\n\n\tget absoluteSpeed() {\n\t\treturn Math.abs(this._speed);\n\t}\n\n\tset weightedSpeed(weightedSpeed) {\n\t\tthis._weightedSpeed = weightedSpeed;\n\t}\n\n\tget weightedSpeed() {\n\t\treturn this._weightedSpeed;\n\t}\n\n\tset animTrack(value) {\n\t\tthis._animTrack = value;\n\t}\n\n\tget animTrack() {\n\t\treturn this._animTrack;\n\t}\n\n}\n\nclass AnimBlendTree extends AnimNode {\n\tconstructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tsuper(state, parent, name, point);\n\t\tthis._parameters = parameters;\n\t\tthis._parameterValues = new Array(parameters.length);\n\t\tthis._children = [];\n\t\tthis._findParameter = findParameter;\n\t\tthis._syncAnimations = syncAnimations !== false;\n\t\tthis._pointCache = {};\n\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst child = children[i];\n\n\t\t\tif (child.children) {\n\t\t\t\tthis._children.push(createTree(child.type, this, null, name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, createTree, findParameter));\n\t\t\t} else {\n\t\t\t\tthis._children.push(new AnimNode(state, this, child.name, child.point, child.speed));\n\t\t\t}\n\t\t}\n\t}\n\n\tget weight() {\n\t\tthis.calculateWeights();\n\t\treturn this._parent ? this._parent.weight * this._weight : this._weight;\n\t}\n\n\tget syncAnimations() {\n\t\treturn this._syncAnimations;\n\t}\n\n\tgetChild(name) {\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tif (this._children[i].name === name) return this._children[i];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tupdateParameterValues() {\n\t\tlet paramsEqual = true;\n\n\t\tfor (let i = 0; i < this._parameterValues.length; i++) {\n\t\t\tconst updatedParameter = this._findParameter(this._parameters[i]).value;\n\n\t\t\tif (this._parameterValues[i] !== updatedParameter) {\n\t\t\t\tthis._parameterValues[i] = updatedParameter;\n\t\t\t\tparamsEqual = false;\n\t\t\t}\n\t\t}\n\n\t\treturn paramsEqual;\n\t}\n\n\tgetNodeWeightedDuration(i) {\n\t\treturn this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;\n\t}\n\n\tgetNodeCount() {\n\t\tlet count = 0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\n\t\t\tif (child.constructor === AnimBlendTree) {\n\t\t\t\tcount += this._children[i].getNodeCount();\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n}\n\nclass AnimBlendTree1D extends AnimBlendTree {\n\tconstructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tchildren.sort((a, b) => a.point - b.point);\n\t\tsuper(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t}\n\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightedDurationSum = 0.0;\n\t\tthis._children[0].weight = 0.0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst c1 = this._children[i];\n\n\t\t\tif (i !== this._children.length - 1) {\n\t\t\t\tconst c2 = this._children[i + 1];\n\n\t\t\t\tif (c1.point === c2.point) {\n\t\t\t\t\tc1.weight = 0.5;\n\t\t\t\t\tc2.weight = 0.5;\n\t\t\t\t} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {\n\t\t\t\t\tconst child2Distance = Math.abs(c1.point - c2.point);\n\t\t\t\t\tconst parameterDistance = Math.abs(c1.point - this._parameterValues[0]);\n\t\t\t\t\tconst weight = (child2Distance - parameterDistance) / child2Distance;\n\t\t\t\t\tc1.weight = weight;\n\t\t\t\t\tc2.weight = 1.0 - weight;\n\t\t\t\t} else {\n\t\t\t\t\tc2.weight = 0.0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;\n\t\t\t}\n\t\t}\n\n\t\tif (this._syncAnimations) {\n\t\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\t\tconst child = this._children[i];\n\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimBlendTreeCartesian2D extends AnimBlendTree {\n\tpointDistanceCache(i, j) {\n\t\tconst pointKey = `${i}${j}`;\n\n\t\tif (!this._pointCache[pointKey]) {\n\t\t\tthis._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);\n\t\t}\n\n\t\treturn this._pointCache[pointKey];\n\t}\n\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum, weightedDurationSum;\n\n\t\tAnimBlendTreeCartesian2D._p.set(...this._parameterValues);\n\n\t\tweightSum = 0.0;\n\t\tweightedDurationSum = 0.0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tconst pi = child.point;\n\n\t\t\tAnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);\n\n\t\t\tlet minj = Number.MAX_VALUE;\n\n\t\t\tfor (let j = 0; j < this._children.length; j++) {\n\t\t\t\tif (i === j) continue;\n\t\t\t\tconst pipj = this.pointDistanceCache(i, j);\n\t\t\t\tconst result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);\n\t\t\t\tif (result < minj) minj = result;\n\t\t\t}\n\n\t\t\tchild.weight = minj;\n\t\t\tweightSum += minj;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tchild.weight = child._weight / weightSum;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nAnimBlendTreeCartesian2D._p = new Vec2();\nAnimBlendTreeCartesian2D._pip = new Vec2();\n\nclass AnimBlendTreeDirectional2D extends AnimBlendTree {\n\tpointCache(i, j) {\n\t\tconst pointKey = `${i}${j}`;\n\n\t\tif (!this._pointCache[pointKey]) {\n\t\t\tthis._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);\n\t\t}\n\n\t\treturn this._pointCache[pointKey];\n\t}\n\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum, weightedDurationSum;\n\n\t\tAnimBlendTreeDirectional2D._p.set(...this._parameterValues);\n\n\t\tconst pLength = AnimBlendTreeDirectional2D._p.length();\n\n\t\tweightSum = 0.0;\n\t\tweightedDurationSum = 0.0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tconst pi = child.point;\n\t\t\tconst piLength = child.pointLength;\n\t\t\tlet minj = Number.MAX_VALUE;\n\n\t\t\tfor (let j = 0; j < this._children.length; j++) {\n\t\t\t\tif (i === j) continue;\n\t\t\t\tconst pipj = this.pointCache(i, j);\n\t\t\t\tconst pjLength = this._children[j].pointLength;\n\n\t\t\t\tAnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);\n\n\t\t\t\tconst result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);\n\t\t\t\tif (result < minj) minj = result;\n\t\t\t}\n\n\t\t\tchild.weight = minj;\n\t\t\tweightSum += minj;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tchild.weight = child._weight / weightSum;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tconst weightedChildDuration = child.animTrack.duration / weightedDurationSum * weightSum;\n\t\t\t\tchild.weightedSpeed = child.absoluteSpeed * weightedChildDuration;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nAnimBlendTreeDirectional2D._p = new Vec2();\nAnimBlendTreeDirectional2D._pip = new Vec2();\n\nclass AnimBlendTreeDirect extends AnimBlendTree {\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum = 0.0;\n\t\tlet weightedDurationSum = 0.0;\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tweightSum += Math.max(this._parameterValues[i], 0.0);\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tconst child = this._children[i];\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tchild.weight = Math.max(this._parameterValues[i], 0.0) / weightSum;\n\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass AnimState {\n\tconstructor(controller, name, speed, loop, blendTree) {\n\t\tthis._controller = controller;\n\t\tthis._name = name;\n\t\tthis._animations = {};\n\t\tthis._animationList = [];\n\t\tthis._speed = speed || 1.0;\n\t\tthis._loop = loop === undefined ? true : loop;\n\n\t\tconst findParameter = this._controller.findParameter.bind(this._controller);\n\n\t\tif (blendTree) {\n\t\t\tthis._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, findParameter);\n\t\t} else {\n\t\t\tthis._blendTree = new AnimNode(this, null, name, 1.0, speed);\n\t\t}\n\t}\n\n\t_createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tswitch (type) {\n\t\t\tcase ANIM_BLEND_1D:\n\t\t\t\treturn new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\n\t\t\tcase ANIM_BLEND_2D_CARTESIAN:\n\t\t\t\treturn new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\n\t\t\tcase ANIM_BLEND_2D_DIRECTIONAL:\n\t\t\t\treturn new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\n\t\t\tcase ANIM_BLEND_DIRECT:\n\t\t\t\treturn new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t\t}\n\t}\n\n\t_getNodeFromPath(path) {\n\t\tlet currNode = this._blendTree;\n\n\t\tfor (let i = 1; i < path.length; i++) {\n\t\t\tcurrNode = currNode.getChild(path[i]);\n\t\t}\n\n\t\treturn currNode;\n\t}\n\n\taddAnimation(path, animTrack) {\n\t\tconst pathString = path.join('.');\n\n\t\tconst indexOfAnimation = this._animationList.findIndex(function (animation) {\n\t\t\treturn animation.path === pathString;\n\t\t});\n\n\t\tif (indexOfAnimation >= 0) {\n\t\t\tthis._animationList[indexOfAnimation].animTrack = animTrack;\n\t\t} else {\n\t\t\tconst node = this._getNodeFromPath(path);\n\n\t\t\tnode.animTrack = animTrack;\n\n\t\t\tthis._animationList.push(node);\n\t\t}\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tset animations(value) {\n\t\tthis._animationList = value;\n\t}\n\n\tget animations() {\n\t\treturn this._animationList;\n\t}\n\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\n\tset loop(value) {\n\t\tthis._loop = value;\n\t}\n\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\n\tget nodeCount() {\n\t\tif (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;\n\t\treturn this._blendTree.getNodeCount();\n\t}\n\n\tget playable() {\n\t\treturn ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;\n\t}\n\n\tget looping() {\n\t\tif (this.animations.length > 0) {\n\t\t\tconst trackClipName = this.name + '.' + this.animations[0].animTrack.name;\n\n\t\t\tconst trackClip = this._controller.animEvaluator.findClip(trackClipName);\n\n\t\t\tif (trackClip) {\n\t\t\t\treturn trackClip.loop;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget totalWeight() {\n\t\tlet sum = 0;\n\n\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\tsum += this.animations[i].weight;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\tget timelineDuration() {\n\t\tlet duration = 0;\n\n\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\tconst animation = this.animations[i];\n\n\t\t\tif (animation.animTrack.duration > duration) {\n\t\t\t\tduration = animation.animTrack.duration;\n\t\t\t}\n\t\t}\n\n\t\treturn duration;\n\t}\n\n}\n\nclass AnimTransition {\n\tconstructor({\n\t\tfrom,\n\t\tto,\n\t\ttime = 0,\n\t\tpriority = 0,\n\t\tconditions = [],\n\t\texitTime = null,\n\t\ttransitionOffset = null,\n\t\tinterruptionSource = ANIM_INTERRUPTION_NONE\n\t}) {\n\t\tthis._from = from;\n\t\tthis._to = to;\n\t\tthis._time = time;\n\t\tthis._priority = priority;\n\t\tthis._conditions = conditions;\n\t\tthis._exitTime = exitTime;\n\t\tthis._transitionOffset = transitionOffset;\n\t\tthis._interruptionSource = interruptionSource;\n\t}\n\n\tget from() {\n\t\treturn this._from;\n\t}\n\n\tset to(value) {\n\t\tthis._to = value;\n\t}\n\n\tget to() {\n\t\treturn this._to;\n\t}\n\n\tget time() {\n\t\treturn this._time;\n\t}\n\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\n\tget conditions() {\n\t\treturn this._conditions;\n\t}\n\n\tget exitTime() {\n\t\treturn this._exitTime;\n\t}\n\n\tget transitionOffset() {\n\t\treturn this._transitionOffset;\n\t}\n\n\tget interruptionSource() {\n\t\treturn this._interruptionSource;\n\t}\n\n\tget hasExitTime() {\n\t\treturn !!this.exitTime;\n\t}\n\n}\n\nclass AnimController {\n\tconstructor(animEvaluator, states, transitions, parameters, activate, eventHandler, consumedTriggers) {\n\t\tthis._animEvaluator = animEvaluator;\n\t\tthis._states = {};\n\t\tthis._stateNames = [];\n\t\tthis._eventHandler = eventHandler;\n\t\tthis._consumedTriggers = consumedTriggers;\n\n\t\tfor (let i = 0; i < states.length; i++) {\n\t\t\tthis._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);\n\n\t\t\tthis._stateNames.push(states[i].name);\n\t\t}\n\n\t\tthis._transitions = transitions.map(transition => {\n\t\t\treturn new AnimTransition(_extends({}, transition));\n\t\t});\n\t\tthis._findTransitionsFromStateCache = {};\n\t\tthis._findTransitionsBetweenStatesCache = {};\n\t\tthis._parameters = parameters;\n\t\tthis._previousStateName = null;\n\t\tthis._activeStateName = ANIM_STATE_START;\n\t\tthis._playing = false;\n\t\tthis._activate = activate;\n\t\tthis._currTransitionTime = 1.0;\n\t\tthis._totalTransitionTime = 1.0;\n\t\tthis._isTransitioning = false;\n\t\tthis._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;\n\t\tthis._transitionPreviousStates = [];\n\t\tthis._timeInState = 0;\n\t\tthis._timeInStateBefore = 0;\n\t}\n\n\tget animEvaluator() {\n\t\treturn this._animEvaluator;\n\t}\n\n\tset activeState(stateName) {\n\t\tthis._activeStateName = stateName;\n\t}\n\n\tget activeState() {\n\t\treturn this._findState(this._activeStateName);\n\t}\n\n\tget activeStateName() {\n\t\treturn this._activeStateName;\n\t}\n\n\tget activeStateAnimations() {\n\t\treturn this.activeState.animations;\n\t}\n\n\tset previousState(stateName) {\n\t\tthis._previousStateName = stateName;\n\t}\n\n\tget previousState() {\n\t\treturn this._findState(this._previousStateName);\n\t}\n\n\tget previousStateName() {\n\t\treturn this._previousStateName;\n\t}\n\n\tget playable() {\n\t\tlet playable = true;\n\n\t\tfor (let i = 0; i < this._stateNames.length; i++) {\n\t\t\tif (!this._states[this._stateNames[i]].playable) {\n\t\t\t\tplayable = false;\n\t\t\t}\n\t\t}\n\n\t\treturn playable;\n\t}\n\n\tset playing(value) {\n\t\tthis._playing = value;\n\t}\n\n\tget playing() {\n\t\treturn this._playing;\n\t}\n\n\tget activeStateProgress() {\n\t\treturn this._getActiveStateProgressForTime(this._timeInState);\n\t}\n\n\tget activeStateDuration() {\n\t\tif (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END) return 0.0;\n\t\tlet maxDuration = 0.0;\n\n\t\tfor (let i = 0; i < this.activeStateAnimations.length; i++) {\n\t\t\tconst activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);\n\n\t\t\tif (activeClip) {\n\t\t\t\tmaxDuration = Math.max(maxDuration, activeClip.track.duration);\n\t\t\t}\n\t\t}\n\n\t\treturn maxDuration;\n\t}\n\n\tset activeStateCurrentTime(time) {\n\t\tthis._timeInStateBefore = time;\n\t\tthis._timeInState = time;\n\n\t\tfor (let i = 0; i < this.activeStateAnimations.length; i++) {\n\t\t\tconst clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);\n\n\t\t\tif (clip) {\n\t\t\t\tclip.time = time;\n\t\t\t}\n\t\t}\n\t}\n\n\tget activeStateCurrentTime() {\n\t\treturn this._timeInState;\n\t}\n\n\tget transitioning() {\n\t\treturn this._isTransitioning;\n\t}\n\n\tget transitionProgress() {\n\t\treturn this._currTransitionTime / this._totalTransitionTime;\n\t}\n\n\tget states() {\n\t\treturn this._stateNames;\n\t}\n\n\tassignMask(mask) {\n\t\treturn this._animEvaluator.assignMask(mask);\n\t}\n\n\t_findState(stateName) {\n\t\treturn this._states[stateName];\n\t}\n\n\t_getActiveStateProgressForTime(time) {\n\t\tif (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) return 1.0;\n\n\t\tconst activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);\n\n\t\tif (activeClip) {\n\t\t\treturn time / activeClip.track.duration;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_findTransitionsFromState(stateName) {\n\t\tlet transitions = this._findTransitionsFromStateCache[stateName];\n\n\t\tif (!transitions) {\n\t\t\ttransitions = this._transitions.filter(function (transition) {\n\t\t\t\treturn transition.from === stateName;\n\t\t\t});\n\t\t\ttransitions.sort(function (a, b) {\n\t\t\t\treturn a.priority < b.priority;\n\t\t\t});\n\t\t\tthis._findTransitionsFromStateCache[stateName] = transitions;\n\t\t}\n\n\t\treturn transitions;\n\t}\n\n\t_findTransitionsBetweenStates(sourceStateName, destinationStateName) {\n\t\tlet transitions = this._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName];\n\n\t\tif (!transitions) {\n\t\t\ttransitions = this._transitions.filter(function (transition) {\n\t\t\t\treturn transition.from === sourceStateName && transition.to === destinationStateName;\n\t\t\t});\n\t\t\ttransitions.sort(function (a, b) {\n\t\t\t\treturn a.priority < b.priority;\n\t\t\t});\n\t\t\tthis._findTransitionsBetweenStatesCache[sourceStateName + '->' + destinationStateName] = transitions;\n\t\t}\n\n\t\treturn transitions;\n\t}\n\n\t_transitionHasConditionsMet(transition) {\n\t\tconst conditions = transition.conditions;\n\n\t\tfor (let i = 0; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\t\t\tconst parameter = this.findParameter(condition.parameterName);\n\n\t\t\tswitch (condition.predicate) {\n\t\t\t\tcase ANIM_GREATER_THAN:\n\t\t\t\t\tif (!(parameter.value > condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_LESS_THAN:\n\t\t\t\t\tif (!(parameter.value < condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_GREATER_THAN_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value >= condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_LESS_THAN_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value <= condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value === condition.value)) return false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIM_NOT_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value !== condition.value)) return false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t_findTransition(from, to) {\n\t\tlet transitions = [];\n\n\t\tif (from && to) {\n\t\t\ttransitions = transitions.concat(this._findTransitionsBetweenStates(from, to));\n\t\t} else {\n\t\t\tif (!this._isTransitioning) {\n\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t} else {\n\t\t\t\tswitch (this._transitionInterruptionSource) {\n\t\t\t\t\tcase ANIM_INTERRUPTION_PREV:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ANIM_INTERRUPTION_NEXT:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ANIM_INTERRUPTION_PREV_NEXT:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ANIM_INTERRUPTION_NEXT_PREV:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttransitions = transitions.filter(transition => {\n\t\t\tif (transition.to === this.activeStateName) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (transition.hasExitTime) {\n\t\t\t\tlet progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);\n\n\t\t\t\tlet progress = this._getActiveStateProgressForTime(this._timeInState);\n\n\t\t\t\tif (transition.exitTime < 1.0 && this.activeState.loop) {\n\t\t\t\t\tprogressBefore -= Math.floor(progressBefore);\n\t\t\t\t\tprogress -= Math.floor(progress);\n\t\t\t\t}\n\n\t\t\t\tif (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this._transitionHasConditionsMet(transition);\n\t\t});\n\n\t\tif (transitions.length > 0) {\n\t\t\tconst transition = transitions[0];\n\n\t\t\tif (transition.to === ANIM_STATE_END) {\n\t\t\t\tconst startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];\n\n\t\t\t\ttransition.to = startTransition.to;\n\t\t\t}\n\n\t\t\treturn transition;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tupdateStateFromTransition(transition) {\n\t\tlet state;\n\t\tlet animation;\n\t\tlet clip;\n\t\tthis.previousState = transition.from ? this.activeStateName : null;\n\t\tthis.activeState = transition.to;\n\n\t\tfor (let i = 0; i < transition.conditions.length; i++) {\n\t\t\tconst condition = transition.conditions[i];\n\t\t\tconst parameter = this.findParameter(condition.parameterName);\n\n\t\t\tif (parameter.type === ANIM_PARAMETER_TRIGGER) {\n\t\t\t\tthis._consumedTriggers.add(condition.parameterName);\n\t\t\t}\n\t\t}\n\n\t\tif (this.previousState) {\n\t\t\tif (!this._isTransitioning) {\n\t\t\t\tthis._transitionPreviousStates = [];\n\t\t\t}\n\n\t\t\tthis._transitionPreviousStates.push({\n\t\t\t\tname: this._previousStateName,\n\t\t\t\tweight: 1\n\t\t\t});\n\n\t\t\tconst interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);\n\n\t\t\tfor (let i = 0; i < this._transitionPreviousStates.length; i++) {\n\t\t\t\tif (!this._isTransitioning) {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight = 1.0;\n\t\t\t\t} else if (i !== this._transitionPreviousStates.length - 1) {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight *= 1.0 - interpolatedTime;\n\t\t\t\t} else {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight = interpolatedTime;\n\t\t\t\t}\n\n\t\t\t\tstate = this._findState(this._transitionPreviousStates[i].name);\n\n\t\t\t\tfor (let j = 0; j < state.animations.length; j++) {\n\t\t\t\t\tanimation = state.animations[j];\n\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name + '.previous.' + i);\n\n\t\t\t\t\tif (!clip) {\n\t\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\t\t\t\t\t\tclip.name = animation.name + '.previous.' + i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i !== this._transitionPreviousStates.length - 1) {\n\t\t\t\t\t\tclip.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._isTransitioning = true;\n\t\tthis._totalTransitionTime = transition.time;\n\t\tthis._currTransitionTime = 0;\n\t\tthis._transitionInterruptionSource = transition.interruptionSource;\n\t\tconst activeState = this.activeState;\n\t\tconst hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;\n\t\tlet timeInState = 0;\n\t\tlet timeInStateBefore = 0;\n\n\t\tif (hasTransitionOffset) {\n\t\t\tconst offsetTime = activeState.timelineDuration * transition.transitionOffset;\n\t\t\ttimeInState = offsetTime;\n\t\t\ttimeInStateBefore = offsetTime;\n\t\t}\n\n\t\tthis._timeInState = timeInState;\n\t\tthis._timeInStateBefore = timeInStateBefore;\n\n\t\tfor (let i = 0; i < activeState.animations.length; i++) {\n\t\t\tclip = this._animEvaluator.findClip(activeState.animations[i].name);\n\n\t\t\tif (!clip) {\n\t\t\t\tconst speed = Number.isFinite(activeState.animations[i].speed) ? activeState.animations[i].speed : activeState.speed;\n\t\t\t\tclip = new AnimClip(activeState.animations[i].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);\n\t\t\t\tclip.name = activeState.animations[i].name;\n\n\t\t\t\tthis._animEvaluator.addClip(clip);\n\t\t\t} else {\n\t\t\t\tclip.reset();\n\t\t\t}\n\n\t\t\tif (transition.time > 0) {\n\t\t\t\tclip.blendWeight = 0.0;\n\t\t\t} else {\n\t\t\t\tclip.blendWeight = activeState.animations[i].normalizedWeight;\n\t\t\t}\n\n\t\t\tclip.play();\n\n\t\t\tif (hasTransitionOffset) {\n\t\t\t\tclip.time = activeState.timelineDuration * transition.transitionOffset;\n\t\t\t} else {\n\t\t\t\tconst startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;\n\t\t\t\tclip.time = startTime;\n\t\t\t}\n\t\t}\n\t}\n\n\t_transitionToState(newStateName) {\n\t\tif (!this._findState(newStateName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet transition = this._findTransition(this._activeStateName, newStateName);\n\n\t\tif (!transition) {\n\t\t\tthis._animEvaluator.removeClips();\n\n\t\t\ttransition = new AnimTransition({\n\t\t\t\tfrom: null,\n\t\t\t\tto: newStateName\n\t\t\t});\n\t\t}\n\n\t\tthis.updateStateFromTransition(transition);\n\t}\n\n\tassignAnimation(pathString, animTrack, speed, loop) {\n\t\tconst path = pathString.split('.');\n\n\t\tlet state = this._findState(path[0]);\n\n\t\tif (!state) {\n\t\t\tstate = new AnimState(this, path[0], 1.0);\n\t\t\tthis._states[path[0]] = state;\n\n\t\t\tthis._stateNames.push(path[0]);\n\t\t}\n\n\t\tstate.addAnimation(path, animTrack);\n\n\t\tif (speed !== undefined) {\n\t\t\tstate.speed = speed;\n\t\t}\n\n\t\tif (loop !== undefined) {\n\t\t\tstate.loop = loop;\n\t\t}\n\n\t\tif (!this._playing && this._activate && this.playable) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\n\tremoveNodeAnimations(nodeName) {\n\t\tif (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst state = this._findState(nodeName);\n\n\t\tif (!state) {\n\t\t\treturn;\n\t\t}\n\n\t\tstate.animations = [];\n\t\treturn true;\n\t}\n\n\tplay(stateName) {\n\t\tif (stateName) {\n\t\t\tthis._transitionToState(stateName);\n\t\t}\n\n\t\tthis._playing = true;\n\t}\n\n\tpause() {\n\t\tthis._playing = false;\n\t}\n\n\treset() {\n\t\tthis._previousStateName = null;\n\t\tthis._activeStateName = ANIM_STATE_START;\n\t\tthis._playing = false;\n\t\tthis._currTransitionTime = 1.0;\n\t\tthis._totalTransitionTime = 1.0;\n\t\tthis._isTransitioning = false;\n\t\tthis._timeInState = 0;\n\t\tthis._timeInStateBefore = 0;\n\n\t\tthis._animEvaluator.removeClips();\n\t}\n\n\trebind() {\n\t\tthis._animEvaluator.rebind();\n\t}\n\n\tupdate(dt) {\n\t\tif (!this._playing) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet state;\n\t\tlet animation;\n\t\tlet clip;\n\t\tthis._timeInStateBefore = this._timeInState;\n\t\tthis._timeInState += dt;\n\n\t\tconst transition = this._findTransition(this._activeStateName);\n\n\t\tif (transition) this.updateStateFromTransition(transition);\n\n\t\tif (this._isTransitioning) {\n\t\t\tthis._currTransitionTime += dt;\n\n\t\t\tif (this._currTransitionTime <= this._totalTransitionTime) {\n\t\t\t\tconst interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;\n\n\t\t\t\tfor (let i = 0; i < this._transitionPreviousStates.length; i++) {\n\t\t\t\t\tstate = this._findState(this._transitionPreviousStates[i].name);\n\t\t\t\t\tconst stateWeight = this._transitionPreviousStates[i].weight;\n\n\t\t\t\t\tfor (let j = 0; j < state.animations.length; j++) {\n\t\t\t\t\t\tanimation = state.animations[j];\n\t\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name + '.previous.' + i);\n\n\t\t\t\t\t\tif (clip) {\n\t\t\t\t\t\t\tclip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate = this.activeState;\n\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tthis._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._isTransitioning = false;\n\t\t\t\tconst activeClips = this.activeStateAnimations.length;\n\t\t\t\tconst totalClips = this._animEvaluator.clips.length;\n\n\t\t\t\tfor (let i = 0; i < totalClips - activeClips; i++) {\n\t\t\t\t\tthis._animEvaluator.removeClip(0);\n\t\t\t\t}\n\n\t\t\t\tthis._transitionPreviousStates = [];\n\t\t\t\tstate = this.activeState;\n\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\n\t\t\t\t\tif (clip) {\n\t\t\t\t\t\tclip.blendWeight = animation.normalizedWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.activeState._blendTree.constructor !== AnimNode) {\n\t\t\t\tstate = this.activeState;\n\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\n\t\t\t\t\tif (clip) {\n\t\t\t\t\t\tclip.blendWeight = animation.normalizedWeight;\n\n\t\t\t\t\t\tif (animation.parent.syncAnimations) {\n\t\t\t\t\t\t\tclip.speed = animation.speed;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._animEvaluator.update(dt);\n\t}\n\n\tfindParameter(name) {\n\t\treturn this._parameters[name];\n\t}\n\n}\n\nconst v2 = new Vec2();\nconst v3 = new Vec3();\nconst v4 = new Vec4();\nconst c = new Color();\nconst q = new Quat();\n\nclass AnimComponentBinder extends DefaultAnimBinder {\n\tconstructor(animComponent, graph, layerName, mask, layerIndex) {\n\t\tsuper(graph);\n\t\tthis.animComponent = animComponent;\n\t\tthis._mask = mask;\n\t\tthis.layerName = layerName;\n\t\tthis.layerIndex = layerIndex;\n\t}\n\n\tstatic _packFloat(values) {\n\t\treturn values[0];\n\t}\n\n\tstatic _packBoolean(values) {\n\t\treturn !!values[0];\n\t}\n\n\tstatic _packVec2(values) {\n\t\tv2.x = values[0];\n\t\tv2.y = values[1];\n\t\treturn v2;\n\t}\n\n\tstatic _packVec3(values) {\n\t\tv3.x = values[0];\n\t\tv3.y = values[1];\n\t\tv3.z = values[2];\n\t\treturn v3;\n\t}\n\n\tstatic _packVec4(values) {\n\t\tv4.x = values[0];\n\t\tv4.y = values[1];\n\t\tv4.z = values[2];\n\t\tv4.w = values[3];\n\t\treturn v4;\n\t}\n\n\tstatic _packColor(values) {\n\t\tc.r = values[0];\n\t\tc.g = values[1];\n\t\tc.b = values[2];\n\t\tc.a = values[3];\n\t\treturn c;\n\t}\n\n\tstatic _packQuat(values) {\n\t\tq.x = values[0];\n\t\tq.y = values[1];\n\t\tq.z = values[2];\n\t\tq.w = values[3];\n\t\treturn q;\n\t}\n\n\tresolve(path) {\n\t\tconst encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);\n\t\tlet target = this.targetCache[encodedPath];\n\t\tif (target) return target;\n\t\tlet entity;\n\t\tlet propertyComponent;\n\t\tlet targetPath;\n\n\t\tswitch (path.component) {\n\t\t\tcase 'entity':\n\t\t\t\tentity = this._getEntityFromHierarchy(path.entityPath);\n\t\t\t\ttargetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);\n\t\t\t\tpropertyComponent = entity;\n\t\t\t\tbreak;\n\n\t\t\tcase 'graph':\n\t\t\t\tpropertyComponent = this.findNode(path);\n\t\t\t\tif (!propertyComponent) return null;\n\t\t\t\ttargetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tentity = this._getEntityFromHierarchy(path.entityPath);\n\t\t\t\tpropertyComponent = entity.findComponent(path.component);\n\t\t\t\tif (!propertyComponent) return null;\n\t\t\t\ttargetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttarget = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);\n\t\tthis.targetCache[encodedPath] = target;\n\t\treturn target;\n\t}\n\n\tupdate(deltaTime) {\n\t\tconst activeNodes = this.activeNodes;\n\n\t\tif (activeNodes) {\n\t\t\tfor (let i = 0; i < activeNodes.length; i++) {\n\t\t\t\tactiveNodes[i]._dirtifyLocal();\n\t\t\t}\n\t\t}\n\t}\n\n\t_getEntityFromHierarchy(entityHierarchy) {\n\t\tif (!this.animComponent.entity.name === entityHierarchy[0]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst currEntity = this.animComponent.entity;\n\n\t\tif (entityHierarchy.length === 1) {\n\t\t\treturn currEntity;\n\t\t}\n\n\t\treturn currEntity._parent.findByPath(entityHierarchy);\n\t}\n\n\t_resolvePath(object, path, resolveLeaf) {\n\t\tconst steps = path.length - (resolveLeaf ? 0 : 1);\n\n\t\tfor (let i = 0; i < steps; i++) {\n\t\t\tobject = object[path[i]];\n\t\t}\n\n\t\treturn object;\n\t}\n\n\t_setter(object, path, packFunc) {\n\t\tconst obj = this._resolvePath(object, path);\n\n\t\tconst key = path[path.length - 1];\n\t\tconst setterFunc = \"set\" + key.substring(0, 1).toUpperCase() + key.substring(1);\n\n\t\tif (obj[setterFunc]) {\n\t\t\tconst func = obj[setterFunc].bind(obj);\n\t\t\treturn function (values) {\n\t\t\t\tfunc(packFunc(values));\n\t\t\t};\n\t\t}\n\n\t\tconst prop = obj[key];\n\n\t\tif (typeof prop === 'object' && prop.hasOwnProperty('copy')) {\n\t\t\treturn function (values) {\n\t\t\t\tprop.copy(packFunc(values));\n\t\t\t};\n\t\t}\n\n\t\tif ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {\n\t\t\tconst parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;\n\t\t\tconst objKey = path[path.length - 2];\n\t\t\treturn function (values) {\n\t\t\t\tobj[key] = packFunc(values);\n\t\t\t\tparent[objKey] = obj;\n\t\t\t};\n\t\t}\n\n\t\treturn function (values) {\n\t\t\tobj[key] = packFunc(values);\n\t\t};\n\t}\n\n\t_createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {\n\t\tif (this.handlers && propertyHierarchy[0] === 'weights') {\n\t\t\treturn this.handlers.weights(propertyComponent);\n\t\t} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {\n\t\t\tconst materialPropertyName = propertyHierarchy[1];\n\n\t\t\tif (materialPropertyName.endsWith('Map')) {\n\t\t\t\treturn this.handlers.materialTexture(propertyComponent, materialPropertyName);\n\t\t\t}\n\t\t}\n\n\t\tconst property = this._resolvePath(propertyComponent, propertyHierarchy, true);\n\n\t\tif (typeof property === 'undefined') return null;\n\t\tlet setter;\n\t\tlet animDataType;\n\t\tlet animDataComponents;\n\n\t\tif (typeof property === 'number') {\n\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);\n\t\t\tanimDataType = 'vector';\n\t\t\tanimDataComponents = 1;\n\t\t} else if (typeof property === 'boolean') {\n\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);\n\t\t\tanimDataType = 'vector';\n\t\t\tanimDataComponents = 1;\n\t\t} else if (typeof property === 'object') {\n\t\t\tswitch (property.constructor) {\n\t\t\t\tcase Vec2:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Vec3:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Vec4:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Color:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Quat:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);\n\t\t\t\t\tanimDataType = 'quaternion';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (propertyHierarchy.indexOf('material') !== -1) {\n\t\t\treturn new AnimTarget(function (values) {\n\t\t\t\tsetter(values);\n\t\t\t\tpropertyComponent.material.update();\n\t\t\t}, animDataType, animDataComponents, targetPath);\n\t\t}\n\n\t\treturn new AnimTarget(setter, animDataType, animDataComponents, targetPath);\n\t}\n\n\trebind() {\n\t\tthis.targetCache = {};\n\n\t\tif (this.animComponent.rootBone) {\n\t\t\tthis.graph = this.animComponent.rootBone;\n\t\t} else {\n\t\t\tthis.graph = this.animComponent.entity;\n\t\t}\n\n\t\tconst nodes = {};\n\n\t\tconst flatten = function flatten(node) {\n\t\t\tnodes[node.name] = node;\n\n\t\t\tfor (let i = 0; i < node.children.length; ++i) {\n\t\t\t\tflatten(node.children[i]);\n\t\t\t}\n\t\t};\n\n\t\tflatten(this.graph);\n\t\tthis.nodes = nodes;\n\t}\n\n}\n\nclass AnimComponentLayer {\n\tconstructor(name, controller, component, weight = 1, blendType = ANIM_LAYER_OVERWRITE) {\n\t\tthis._name = name;\n\t\tthis._controller = controller;\n\t\tthis._component = component;\n\t\tthis._weight = weight;\n\t\tthis._blendType = blendType;\n\t\tthis._mask = null;\n\t}\n\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\tset playing(value) {\n\t\tthis._controller.playing = value;\n\t}\n\n\tget playing() {\n\t\treturn this._controller.playing;\n\t}\n\n\tget playable() {\n\t\treturn this._controller.playable;\n\t}\n\n\tget activeState() {\n\t\treturn this._controller.activeStateName;\n\t}\n\n\tget previousState() {\n\t\treturn this._controller.previousStateName;\n\t}\n\n\tget activeStateProgress() {\n\t\treturn this._controller.activeStateProgress;\n\t}\n\n\tget activeStateDuration() {\n\t\treturn this._controller.activeStateDuration;\n\t}\n\n\tset activeStateCurrentTime(time) {\n\t\tconst controller = this._controller;\n\t\tconst layerPlaying = controller.playing;\n\t\tcontroller.playing = true;\n\t\tcontroller.activeStateCurrentTime = time;\n\n\t\tif (!layerPlaying) {\n\t\t\tcontroller.update(0);\n\t\t}\n\n\t\tcontroller.playing = layerPlaying;\n\t}\n\n\tget activeStateCurrentTime() {\n\t\treturn this._controller.activeStateCurrentTime;\n\t}\n\n\tget transitioning() {\n\t\treturn this._controller.transitioning;\n\t}\n\n\tget transitionProgress() {\n\t\tif (this.transitioning) {\n\t\t\treturn this._controller.transitionProgress;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tget states() {\n\t\treturn this._controller.states;\n\t}\n\n\tset weight(value) {\n\t\tthis._weight = value;\n\n\t\tthis._component.dirtifyTargets();\n\t}\n\n\tget weight() {\n\t\treturn this._weight;\n\t}\n\n\tset blendType(value) {\n\t\tif (value !== this._blendType) {\n\t\t\tthis._blendType = value;\n\n\t\t\tthis._component.rebind();\n\t\t}\n\t}\n\n\tget blendType() {\n\t\treturn this._blendType;\n\t}\n\n\tset mask(value) {\n\t\tif (this._controller.assignMask(value)) {\n\t\t\tthis._component.rebind();\n\t\t}\n\n\t\tthis._mask = value;\n\t}\n\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\n\tplay(name) {\n\t\tthis._controller.play(name);\n\t}\n\n\tpause() {\n\t\tthis._controller.pause();\n\t}\n\n\treset() {\n\t\tthis._controller.reset();\n\t}\n\n\trebind() {\n\t\tthis._controller.rebind();\n\t}\n\n\tupdate(dt) {\n\t\tthis._controller.update(dt);\n\t}\n\n\tassignMask(mask) {\n\t\tif (this._controller.assignMask(mask)) {\n\t\t\tthis._component.rebind();\n\t\t}\n\n\t\tthis._mask = mask;\n\t}\n\n\tassignAnimation(nodePath, animTrack, speed, loop) {\n\t\tif (animTrack.constructor !== AnimTrack) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._controller.assignAnimation(nodePath, animTrack, speed, loop);\n\n\t\tif (this._controller._transitions.length === 0) {\n\t\t\tthis._controller._transitions.push(new AnimTransition({\n\t\t\t\tfrom: 'START',\n\t\t\t\tto: nodePath\n\t\t\t}));\n\t\t}\n\n\t\tif (this._component.activate && this._component.playable) {\n\t\t\tthis._component.playing = true;\n\t\t}\n\t}\n\n\tremoveNodeAnimations(nodeName) {\n\t\tif (this._controller.removeNodeAnimations(nodeName)) {\n\t\t\tthis._component.playing = false;\n\t\t}\n\t}\n\n\tgetAnimationAsset(stateName) {\n\t\treturn this._component.animationAssets[`${this.name}:${stateName}`];\n\t}\n\n\ttransition(to, time = 0, transitionOffset = null) {\n\t\tthis._controller.updateStateFromTransition(new AnimTransition({\n\t\t\tfrom: this._controller.activeStateName,\n\t\t\tto,\n\t\t\ttime,\n\t\t\ttransitionOffset\n\t\t}));\n\t}\n\n}\n\nclass AnimComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._stateGraphAsset = null;\n\t\tthis._animationAssets = {};\n\t\tthis._speed = 1.0;\n\t\tthis._activate = true;\n\t\tthis._playing = false;\n\t\tthis._rootBone = null;\n\t\tthis._stateGraph = null;\n\t\tthis._layers = [];\n\t\tthis._layerIndices = {};\n\t\tthis._parameters = {};\n\t\tthis._targets = {};\n\t\tthis._consumedTriggers = new Set();\n\t}\n\n\tset stateGraphAsset(value) {\n\t\tif (value === null) {\n\t\t\tthis.removeStateGraph();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._stateGraphAsset) {\n\t\t\tconst stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);\n\t\t\tstateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);\n\t\t}\n\n\t\tlet _id;\n\n\t\tlet _asset;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t\t_asset = this.system.app.assets.get(_id);\n\n\t\t\tif (!_asset) {\n\t\t\t\tthis.system.app.assets.add(value);\n\t\t\t\t_asset = this.system.app.assets.get(_id);\n\t\t\t}\n\t\t} else {\n\t\t\t_id = value;\n\t\t\t_asset = this.system.app.assets.get(_id);\n\t\t}\n\n\t\tif (!_asset || this._stateGraphAsset === _id) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_asset.resource) {\n\t\t\tthis._stateGraph = _asset.resource;\n\t\t\tthis.loadStateGraph(this._stateGraph);\n\n\t\t\t_asset.on('change', this._onStateGraphAssetChangeEvent, this);\n\t\t} else {\n\t\t\t_asset.once('load', asset => {\n\t\t\t\tthis._stateGraph = asset.resource;\n\t\t\t\tthis.loadStateGraph(this._stateGraph);\n\t\t\t});\n\n\t\t\t_asset.on('change', this._onStateGraphAssetChangeEvent, this);\n\n\t\t\tthis.system.app.assets.load(_asset);\n\t\t}\n\n\t\tthis._stateGraphAsset = _id;\n\t}\n\n\tget stateGraphAsset() {\n\t\treturn this._stateGraphAsset;\n\t}\n\n\tset animationAssets(value) {\n\t\tthis._animationAssets = value;\n\t\tthis.loadAnimationAssets();\n\t}\n\n\tget animationAssets() {\n\t\treturn this._animationAssets;\n\t}\n\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\n\tset activate(value) {\n\t\tthis._activate = value;\n\t}\n\n\tget activate() {\n\t\treturn this._activate;\n\t}\n\n\tset playing(value) {\n\t\tthis._playing = value;\n\t}\n\n\tget playing() {\n\t\treturn this._playing;\n\t}\n\n\tset rootBone(value) {\n\t\tif (typeof value === 'string') {\n\t\t\tconst entity = this.entity.root.findByGuid(value);\n\t\t\tthis._rootBone = entity;\n\t\t} else if (value instanceof Entity) {\n\t\t\tthis._rootBone = value;\n\t\t} else {\n\t\t\tthis._rootBone = null;\n\t\t}\n\n\t\tthis.rebind();\n\t}\n\n\tget rootBone() {\n\t\treturn this._rootBone;\n\t}\n\n\tset stateGraph(value) {\n\t\tthis._stateGraph = value;\n\t}\n\n\tget stateGraph() {\n\t\treturn this._stateGraph;\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset layerIndices(value) {\n\t\tthis._layerIndices = value;\n\t}\n\n\tget layerIndices() {\n\t\treturn this._layerIndices;\n\t}\n\n\tset parameters(value) {\n\t\tthis._parameters = value;\n\t}\n\n\tget parameters() {\n\t\treturn this._parameters;\n\t}\n\n\tset targets(value) {\n\t\tthis._targets = value;\n\t}\n\n\tget targets() {\n\t\treturn this._targets;\n\t}\n\n\tget playable() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tif (!this._layers[i].playable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget baseLayer() {\n\t\tif (this._layers.length > 0) {\n\t\t\treturn this._layers[0];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_onStateGraphAssetChangeEvent(asset) {\n\t\tconst prevAnimationAssets = this.animationAssets;\n\t\tconst prevMasks = this.layers.map(layer => layer.mask);\n\t\tthis.removeStateGraph();\n\t\tthis._stateGraph = new AnimStateGraph(asset._data);\n\t\tthis.loadStateGraph(this._stateGraph);\n\t\tthis.animationAssets = prevAnimationAssets;\n\t\tthis.loadAnimationAssets();\n\t\tthis.layers.forEach((layer, i) => {\n\t\t\tlayer.mask = prevMasks[i];\n\t\t});\n\t\tthis.rebind();\n\t}\n\n\tdirtifyTargets() {\n\t\tconst targets = Object.values(this._targets);\n\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\ttargets[i].dirty = true;\n\t\t}\n\t}\n\n\t_addLayer({\n\t\tname,\n\t\tstates,\n\t\ttransitions,\n\t\tweight,\n\t\tmask,\n\t\tblendType\n\t}) {\n\t\tlet graph;\n\n\t\tif (this.rootBone) {\n\t\t\tgraph = this.rootBone;\n\t\t} else {\n\t\t\tgraph = this.entity;\n\t\t}\n\n\t\tconst layerIndex = this._layers.length;\n\t\tconst animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);\n\t\tconst animEvaluator = new AnimEvaluator(animBinder);\n\t\tconst controller = new AnimController(animEvaluator, states, transitions, this._parameters, this._activate, this, this._consumedTriggers);\n\n\t\tthis._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));\n\n\t\tthis._layerIndices[name] = layerIndex;\n\t\treturn this._layers[layerIndex];\n\t}\n\n\taddLayer(name, weight, mask, blendType) {\n\t\tconst layer = this.findAnimationLayer(name);\n\t\tif (layer) return layer;\n\t\tconst states = [{\n\t\t\t\"name\": \"START\",\n\t\t\t\"speed\": 1\n\t\t}];\n\t\tconst transitions = [];\n\t\treturn this._addLayer({\n\t\t\tname,\n\t\t\tstates,\n\t\t\ttransitions,\n\t\t\tweight,\n\t\t\tmask,\n\t\t\tblendType\n\t\t});\n\t}\n\n\tloadStateGraph(stateGraph) {\n\t\tthis._stateGraph = stateGraph;\n\t\tthis._parameters = {};\n\t\tconst paramKeys = Object.keys(stateGraph.parameters);\n\n\t\tfor (let i = 0; i < paramKeys.length; i++) {\n\t\t\tconst paramKey = paramKeys[i];\n\t\t\tthis._parameters[paramKey] = {\n\t\t\t\ttype: stateGraph.parameters[paramKey].type,\n\t\t\t\tvalue: stateGraph.parameters[paramKey].value\n\t\t\t};\n\t\t}\n\n\t\tthis._layers = [];\n\n\t\tfor (let i = 0; i < stateGraph.layers.length; i++) {\n\t\t\tconst layer = stateGraph.layers[i];\n\n\t\t\tthis._addLayer.bind(this)(_extends({}, layer));\n\t\t}\n\n\t\tthis.setupAnimationAssets();\n\t}\n\n\tsetupAnimationAssets() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this._layers[i];\n\t\t\tconst layerName = layer.name;\n\n\t\t\tfor (let j = 0; j < layer.states.length; j++) {\n\t\t\t\tconst stateName = layer.states[j];\n\n\t\t\t\tif (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {\n\t\t\t\t\tconst stateKey = layerName + ':' + stateName;\n\n\t\t\t\t\tif (!this._animationAssets[stateKey]) {\n\t\t\t\t\t\tthis._animationAssets[stateKey] = {\n\t\t\t\t\t\t\tasset: null\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.loadAnimationAssets();\n\t}\n\n\tloadAnimationAssets() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this._layers[i];\n\n\t\t\tfor (let j = 0; j < layer.states.length; j++) {\n\t\t\t\tconst stateName = layer.states[j];\n\t\t\t\tif (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;\n\t\t\t\tconst animationAsset = this._animationAssets[layer.name + ':' + stateName];\n\n\t\t\t\tif (!animationAsset || !animationAsset.asset) {\n\t\t\t\t\tthis.removeNodeAnimations(stateName, layer.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst assetId = animationAsset.asset;\n\t\t\t\tconst asset = this.system.app.assets.get(assetId);\n\n\t\t\t\tif (asset) {\n\t\t\t\t\tif (asset.resource) {\n\t\t\t\t\t\tthis.onAnimationAssetLoaded(layer.name, stateName, asset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasset.once('load', function (layerName, stateName) {\n\t\t\t\t\t\t\treturn function (asset) {\n\t\t\t\t\t\t\t\tthis.onAnimationAssetLoaded(layerName, stateName, asset);\n\t\t\t\t\t\t\t}.bind(this);\n\t\t\t\t\t\t}.bind(this)(layer.name, stateName));\n\t\t\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonAnimationAssetLoaded(layerName, stateName, asset) {\n\t\tconst animTrack = asset.resource;\n\n\t\tif (asset.data.events) {\n\t\t\tanimTrack.events = new AnimEvents(Object.values(asset.data.events));\n\t\t}\n\n\t\tthis.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);\n\t}\n\n\tremoveStateGraph() {\n\t\tthis._stateGraph = null;\n\t\tthis._stateGraphAsset = null;\n\t\tthis._animationAssets = {};\n\t\tthis._layers = [];\n\t\tthis._layerIndices = {};\n\t\tthis._parameters = {};\n\t\tthis._playing = false;\n\t}\n\n\tresetStateGraph() {\n\t\tif (this.stateGraphAsset) {\n\t\t\tconst stateGraph = this.system.app.assets.get(this.stateGraphAsset).resource;\n\t\t\tthis.loadStateGraph(stateGraph);\n\t\t} else {\n\t\t\tthis.removeStateGraph();\n\t\t}\n\t}\n\n\treset() {\n\t\tthis._parameters = Object.assign({}, this._stateGraph.parameters);\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layerPlaying = this._layers[i].playing;\n\n\t\t\tthis._layers[i].reset();\n\n\t\t\tthis._layers[i].playing = layerPlaying;\n\t\t}\n\t}\n\n\trebind() {\n\t\tthis._targets = {};\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tthis._layers[i].rebind();\n\t\t}\n\t}\n\n\tfindAnimationLayer(name) {\n\t\tconst layerIndex = this._layerIndices[name];\n\t\treturn this._layers[layerIndex] || null;\n\t}\n\n\taddAnimationState(nodeName, animTrack, speed = 1, loop = true, layerName = 'Base') {\n\t\tif (!this._stateGraph) {\n\t\t\tthis.loadStateGraph(new AnimStateGraph({\n\t\t\t\t\"layers\": [{\n\t\t\t\t\t\"name\": layerName,\n\t\t\t\t\t\"states\": [{\n\t\t\t\t\t\t\"name\": \"START\",\n\t\t\t\t\t\t\"speed\": 1\n\t\t\t\t\t}, {\n\t\t\t\t\t\t\"name\": nodeName,\n\t\t\t\t\t\t\"speed\": speed,\n\t\t\t\t\t\t\"loop\": loop,\n\t\t\t\t\t\t\"defaultState\": true\n\t\t\t\t\t}],\n\t\t\t\t\t\"transitions\": [{\n\t\t\t\t\t\t\"from\": 'START',\n\t\t\t\t\t\t\"to\": nodeName\n\t\t\t\t\t}]\n\t\t\t\t}],\n\t\t\t\t\"parameters\": {}\n\t\t\t}));\n\t\t}\n\n\t\tconst layer = this.findAnimationLayer(layerName);\n\n\t\tif (layer) {\n\t\t\tlayer.assignAnimation(nodeName, animTrack, speed, loop);\n\t\t} else {\n\t\t\tvar _this$addLayer;\n\n\t\t\t(_this$addLayer = this.addLayer(layerName)) == null ? void 0 : _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);\n\t\t}\n\t}\n\n\tassignAnimation(nodePath, animTrack, layerName, speed = 1, loop = true) {\n\t\tif (!this._stateGraph && nodePath.indexOf('.') === -1) {\n\t\t\tthis.loadStateGraph(new AnimStateGraph({\n\t\t\t\t\"layers\": [{\n\t\t\t\t\t\"name\": \"Base\",\n\t\t\t\t\t\"states\": [{\n\t\t\t\t\t\t\"name\": \"START\",\n\t\t\t\t\t\t\"speed\": 1\n\t\t\t\t\t}, {\n\t\t\t\t\t\t\"name\": nodePath,\n\t\t\t\t\t\t\"speed\": speed,\n\t\t\t\t\t\t\"loop\": loop,\n\t\t\t\t\t\t\"defaultState\": true\n\t\t\t\t\t}],\n\t\t\t\t\t\"transitions\": [{\n\t\t\t\t\t\t\"from\": 'START',\n\t\t\t\t\t\t\"to\": nodePath\n\t\t\t\t\t}]\n\t\t\t\t}],\n\t\t\t\t\"parameters\": {}\n\t\t\t}));\n\t\t\tthis.baseLayer.assignAnimation(nodePath, animTrack);\n\t\t\treturn;\n\t\t}\n\n\t\tconst layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;\n\n\t\tif (!layer) {\n\t\t\treturn;\n\t\t}\n\n\t\tlayer.assignAnimation(nodePath, animTrack, speed, loop);\n\t}\n\n\tremoveNodeAnimations(nodeName, layerName) {\n\t\tconst layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;\n\n\t\tif (!layer) {\n\t\t\treturn;\n\t\t}\n\n\t\tlayer.removeNodeAnimations(nodeName);\n\t}\n\n\tgetParameterValue(name, type) {\n\t\tconst param = this._parameters[name];\n\n\t\tif (param && param.type === type) {\n\t\t\treturn param.value;\n\t\t}\n\t}\n\n\tsetParameterValue(name, type, value) {\n\t\tconst param = this._parameters[name];\n\n\t\tif (param && param.type === type) {\n\t\t\tparam.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgetFloat(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_FLOAT);\n\t}\n\n\tsetFloat(name, value) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);\n\t}\n\n\tgetInteger(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_INTEGER);\n\t}\n\n\tsetInteger(name, value) {\n\t\tif (typeof value === 'number' && value % 1 === 0) {\n\t\t\tthis.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);\n\t\t}\n\t}\n\n\tgetBoolean(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);\n\t}\n\n\tsetBoolean(name, value) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);\n\t}\n\n\tgetTrigger(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);\n\t}\n\n\tsetTrigger(name, singleFrame = false) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);\n\n\t\tif (singleFrame) {\n\t\t\tthis._consumedTriggers.add(name);\n\t\t}\n\t}\n\n\tresetTrigger(name) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);\n\t}\n\n\tonBeforeRemove() {\n\t\tif (Number.isFinite(this._stateGraphAsset)) {\n\t\t\tconst stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);\n\t\t\tstateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);\n\t\t}\n\t}\n\n\tupdate(dt) {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tthis.layers[i].update(dt * this.speed);\n\t\t}\n\n\t\tthis._consumedTriggers.forEach(trigger => {\n\t\t\tthis.parameters[trigger].value = false;\n\t\t});\n\n\t\tthis._consumedTriggers.clear();\n\t}\n\n\tresolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {\n\t\tif (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {\n\t\t\tthis.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];\n\t\t} else {\n\t\t\tthis.rebind();\n\t\t}\n\t}\n\n}\n\nclass AnimComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$k = ['enabled'];\n\nclass AnimComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'anim';\n\t\tthis.ComponentType = AnimComponent;\n\t\tthis.DataType = AnimComponentData;\n\t\tthis.schema = _schema$k;\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('animationUpdate', this.onAnimationUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tsuper.initializeComponentData(component, data, _schema$k);\n\t\tconst complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];\n\t\tObject.keys(data).forEach(key => {\n\t\t\tif (complexProperties.includes(key)) return;\n\t\t\tcomponent[key] = data[key];\n\t\t});\n\n\t\tif (data.stateGraph) {\n\t\t\tcomponent.stateGraph = data.stateGraph;\n\t\t\tcomponent.loadStateGraph(component.stateGraph);\n\t\t}\n\n\t\tif (data.layers) {\n\t\t\tdata.layers.forEach((layer, i) => {\n\t\t\t\tlayer._controller.states.forEach(stateKey => {\n\t\t\t\t\tlayer._controller._states[stateKey]._animationList.forEach(node => {\n\t\t\t\t\t\tcomponent.layers[i].assignAnimation(node.name, node.animTrack);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} else if (data.animationAssets) {\n\t\t\tcomponent.animationAssets = Object.assign(component.animationAssets, data.animationAssets);\n\t\t}\n\n\t\tif (data.masks) {\n\t\t\tObject.keys(data.masks).forEach(key => {\n\t\t\t\tif (component.layers[key]) {\n\t\t\t\t\tconst maskData = data.masks[key].mask;\n\t\t\t\t\tconst mask = {};\n\t\t\t\t\tObject.keys(maskData).forEach(maskKey => {\n\t\t\t\t\t\tmask[decodeURI(maskKey)] = maskData[maskKey];\n\t\t\t\t\t});\n\t\t\t\t\tcomponent.layers[key].mask = mask;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tonAnimationUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id].entity.anim;\n\t\t\t\tconst componentData = component.data;\n\n\t\t\t\tif (componentData.enabled && component.entity.enabled && component.playing) {\n\t\t\t\t\tcomponent.update(dt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst data = {\n\t\t\tstateGraphAsset: entity.anim.stateGraphAsset,\n\t\t\tanimationAssets: entity.anim.animationAssets,\n\t\t\tspeed: entity.anim.speed,\n\t\t\tactivate: entity.anim.activate,\n\t\t\tplaying: entity.anim.playing,\n\t\t\trootBone: entity.anim.rootBone,\n\t\t\tstateGraph: entity.anim.stateGraph,\n\t\t\tlayers: entity.anim.layers,\n\t\t\tlayerIndices: entity.anim.layerIndices,\n\t\t\tparameters: entity.anim.parameters\n\t\t};\n\t\tthis.addComponent(clone, data);\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('animationUpdate', this.onAnimationUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(AnimComponent.prototype, _schema$k);\n\nclass AudioListenerComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t}\n\n\tsetCurrentListener() {\n\t\tif (this.enabled && this.entity.audiolistener && this.entity.enabled) {\n\t\t\tthis.system.current = this.entity;\n\t\t\tconst position = this.system.current.getPosition();\n\t\t\tthis.system.manager.listener.setPosition(position);\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tthis.setCurrentListener();\n\t}\n\n\tonDisable() {\n\t\tif (this.system.current === this.entity) {\n\t\t\tthis.system.current = null;\n\t\t}\n\t}\n\n}\n\nclass AudioListenerComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$j = ['enabled'];\n\nclass AudioListenerComponentSystem extends ComponentSystem {\n\tconstructor(app, manager) {\n\t\tsuper(app);\n\t\tthis.id = \"audiolistener\";\n\t\tthis.ComponentType = AudioListenerComponent;\n\t\tthis.DataType = AudioListenerComponentData;\n\t\tthis.schema = _schema$j;\n\t\tthis.manager = manager;\n\t\tthis.current = null;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['enabled'];\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tonUpdate(dt) {\n\t\tif (this.current) {\n\t\t\tconst position = this.current.getPosition();\n\t\t\tthis.manager.listener.setPosition(position);\n\t\t\tconst wtm = this.current.getWorldTransform();\n\t\t\tthis.manager.listener.setOrientation(wtm);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(AudioListenerComponent.prototype, _schema$j);\n\nclass AudioSourceComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.on(\"set_assets\", this.onSetAssets, this);\n\t\tthis.on(\"set_loop\", this.onSetLoop, this);\n\t\tthis.on(\"set_volume\", this.onSetVolume, this);\n\t\tthis.on(\"set_pitch\", this.onSetPitch, this);\n\t\tthis.on(\"set_minDistance\", this.onSetMinDistance, this);\n\t\tthis.on(\"set_maxDistance\", this.onSetMaxDistance, this);\n\t\tthis.on(\"set_rollOffFactor\", this.onSetRollOffFactor, this);\n\t\tthis.on(\"set_distanceModel\", this.onSetDistanceModel, this);\n\t\tthis.on(\"set_3d\", this.onSet3d, this);\n\t}\n\n\tplay(name) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.channel) {\n\t\t\tthis.stop();\n\t\t}\n\n\t\tlet channel;\n\t\tconst componentData = this.data;\n\n\t\tif (componentData.sources[name]) {\n\t\t\tif (!componentData['3d']) {\n\t\t\t\tchannel = this.system.manager.playSound(componentData.sources[name], componentData);\n\t\t\t\tcomponentData.currentSource = name;\n\t\t\t\tcomponentData.channel = channel;\n\t\t\t} else {\n\t\t\t\tconst pos = this.entity.getPosition();\n\t\t\t\tchannel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);\n\t\t\t\tcomponentData.currentSource = name;\n\t\t\t\tcomponentData.channel = channel;\n\t\t\t}\n\t\t}\n\t}\n\n\tpause() {\n\t\tif (this.channel) {\n\t\t\tthis.channel.pause();\n\t\t}\n\t}\n\n\tunpause() {\n\t\tif (this.channel && this.channel.paused) {\n\t\t\tthis.channel.unpause();\n\t\t}\n\t}\n\n\tstop() {\n\t\tif (this.channel) {\n\t\t\tthis.channel.stop();\n\t\t\tthis.channel = null;\n\t\t}\n\t}\n\n\tonSetAssets(name, oldValue, newValue) {\n\t\tconst newAssets = [];\n\t\tconst len = newValue.length;\n\n\t\tif (oldValue && oldValue.length) {\n\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\tif (oldValue[i]) {\n\t\t\t\t\tconst asset = this.system.app.assets.get(oldValue[i]);\n\n\t\t\t\t\tif (asset) {\n\t\t\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\n\t\t\t\t\t\tif (this.currentSource === asset.name) {\n\t\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (len) {\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tif (oldValue.indexOf(newValue[i]) < 0) {\n\t\t\t\t\tif (newValue[i] instanceof Asset) {\n\t\t\t\t\t\tnewAssets.push(newValue[i].id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewAssets.push(newValue[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.system._inTools && newAssets.length) {\n\t\t\tthis.loadAudioSourceAssets(newAssets);\n\t\t}\n\t}\n\n\tonAssetChanged(asset, attribute, newValue, oldValue) {\n\t\tif (attribute === 'resource') {\n\t\t\tconst sources = this.data.sources;\n\n\t\t\tif (sources) {\n\t\t\t\tthis.data.sources[asset.name] = newValue;\n\n\t\t\t\tif (this.data.currentSource === asset.name) {\n\t\t\t\t\tif (this.channel) {\n\t\t\t\t\t\tif (this.channel.paused) {\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\n\t\tif (this.data.sources[asset.name]) {\n\t\t\tdelete this.data.sources[asset.name];\n\n\t\t\tif (this.data.currentSource === asset.name) {\n\t\t\t\tthis.stop();\n\t\t\t\tthis.data.currentSource = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetLoop(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setLoop(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetVolume(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setVolume(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetPitch(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setPitch(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetMaxDistance(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setMaxDistance(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetMinDistance(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setMinDistance(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetRollOffFactor(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setRollOffFactor(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetDistanceModel(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setDistanceModel(newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tonSet3d(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.system.initialized && this.currentSource) {\n\t\t\t\tlet paused = false;\n\t\t\t\tlet suspended = false;\n\n\t\t\t\tif (this.channel) {\n\t\t\t\t\tpaused = this.channel.paused;\n\t\t\t\t\tsuspended = this.channel.suspended;\n\t\t\t\t}\n\n\t\t\t\tthis.play(this.currentSource);\n\n\t\t\t\tif (this.channel) {\n\t\t\t\t\tthis.channel.paused = paused;\n\t\t\t\t\tthis.channel.suspended = suspended;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tconst assets = this.data.assets;\n\n\t\tif (assets) {\n\t\t\tconst registry = this.system.app.assets;\n\n\t\t\tfor (let i = 0, len = assets.length; i < len; i++) {\n\t\t\t\tlet asset = assets[i];\n\t\t\t\tif (!(asset instanceof Asset)) asset = registry.get(asset);\n\n\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\tregistry.load(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.system.initialized) {\n\t\t\tif (this.data.activate && !this.channel) {\n\t\t\t\tthis.play(this.currentSource);\n\t\t\t} else {\n\t\t\t\tthis.unpause();\n\t\t\t}\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tthis.pause();\n\t}\n\n\tloadAudioSourceAssets(ids) {\n\t\tconst assets = ids.map(id => {\n\t\t\treturn this.system.app.assets.get(id);\n\t\t});\n\t\tconst sources = {};\n\t\tlet currentSource = null;\n\t\tlet count = assets.length;\n\n\t\tconst _error = e => {\n\t\t\tcount--;\n\t\t};\n\n\t\tconst _done = () => {\n\t\t\tthis.data.sources = sources;\n\t\t\tthis.data.currentSource = currentSource;\n\n\t\t\tif (this.enabled && this.activate && currentSource) {\n\t\t\t\tthis.onEnable();\n\t\t\t}\n\t\t};\n\n\t\tassets.forEach((asset, index) => {\n\t\t\tif (asset) {\n\t\t\t\tcurrentSource = currentSource || asset.name;\n\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\tasset.on('change', this.onAssetChanged, this);\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.off('error', _error, this);\n\t\t\t\tasset.on('error', _error, this);\n\t\t\t\tasset.ready(asset => {\n\t\t\t\t\tsources[asset.name] = asset.resource;\n\t\t\t\t\tcount--;\n\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\t_done();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (!asset.resource && this.enabled && this.entity.enabled) this.system.app.assets.load(asset);\n\t\t\t} else {\n\t\t\t\tcount--;\n\n\t\t\t\tif (count === 0) {\n\t\t\t\t\t_done();\n\t\t\t\t}\n\n\t\t\t\tthis.system.app.assets.on(\"add:\" + ids[index], asset => {\n\t\t\t\t\tasset.ready(asset => {\n\t\t\t\t\t\tthis.data.sources[asset.name] = asset.resource;\n\t\t\t\t\t});\n\t\t\t\t\tif (!asset.resource) this.system.app.assets.load(asset);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n}\n\nclass AudioSourceComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.assets = [];\n\t\tthis.activate = true;\n\t\tthis.volume = 1;\n\t\tthis.pitch = 1;\n\t\tthis.loop = false;\n\t\tthis['3d'] = true;\n\t\tthis.minDistance = 1;\n\t\tthis.maxDistance = 10000;\n\t\tthis.rollOffFactor = 1;\n\t\tthis.distanceModel = DISTANCE_INVERSE;\n\t\tthis.paused = true;\n\t\tthis.sources = {};\n\t\tthis.currentSource = null;\n\t\tthis.channel = null;\n\t}\n\n}\n\nconst _schema$i = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];\n\nclass AudioSourceComponentSystem extends ComponentSystem {\n\tconstructor(app, manager) {\n\t\tsuper(app);\n\t\tthis.id = \"audiosource\";\n\t\tthis.ComponentType = AudioSourceComponent;\n\t\tthis.DataType = AudioSourceComponentData;\n\t\tthis.schema = _schema$i;\n\t\tthis.manager = manager;\n\t\tthis.initialized = false;\n\t\tthis.app.systems.on('initialize', this.onInitialize, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('remove', this.onRemove, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\tcomponent.paused = !(component.enabled && component.activate);\n\t}\n\n\tonInitialize(root) {\n\t\tif (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {\n\t\t\troot.audiosource.play(root.audiosource.currentSource);\n\t\t}\n\n\t\tconst children = root._children;\n\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\tthis.onInitialize(children[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.initialized = true;\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tconst entity = component.entity;\n\t\t\t\tconst componentData = component.data;\n\n\t\t\t\tif (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {\n\t\t\t\t\tconst pos = entity.getPosition();\n\t\t\t\t\tcomponentData.channel.setPosition(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonRemove(entity, data) {\n\t\tif (data.channel) {\n\t\t\tdata.channel.stop();\n\t\t\tdata.channel = null;\n\t\t}\n\t}\n\n\tsetVolume(volume) {\n\t\tthis.manager.setVolume(volume);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('initialize', this.onInitialize, this);\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(AudioSourceComponent.prototype, _schema$i);\n\nclass EntityReference extends EventHandler {\n\tconstructor(parentComponent, entityPropertyName, eventConfig) {\n\t\tsuper();\n\n\t\tif (!parentComponent || !(parentComponent instanceof Component)) {\n\t\t\tthrow new Error('The parentComponent argument is required and must be a Component');\n\t\t} else if (!entityPropertyName || typeof entityPropertyName !== 'string') {\n\t\t\tthrow new Error('The propertyName argument is required and must be a string');\n\t\t} else if (eventConfig && typeof eventConfig !== 'object') {\n\t\t\tthrow new Error('If provided, the eventConfig argument must be an object');\n\t\t}\n\n\t\tthis._parentComponent = parentComponent;\n\t\tthis._entityPropertyName = entityPropertyName;\n\t\tthis._entity = null;\n\t\tthis._app = parentComponent.system.app;\n\n\t\tthis._configureEventListeners(eventConfig || {}, {\n\t\t\t'entity#destroy': this._onEntityDestroy\n\t\t});\n\n\t\tthis._toggleLifecycleListeners('on');\n\t}\n\n\t_configureEventListeners(externalEventConfig, internalEventConfig) {\n\t\tconst externalEventListenerConfigs = this._parseEventListenerConfig(externalEventConfig, 'external', this._parentComponent);\n\n\t\tconst internalEventListenerConfigs = this._parseEventListenerConfig(internalEventConfig, 'internal', this);\n\n\t\tthis._eventListenerConfigs = externalEventListenerConfigs.concat(internalEventListenerConfigs);\n\t\tthis._listenerStatusFlags = {};\n\t\tthis._gainListeners = {};\n\t\tthis._loseListeners = {};\n\t}\n\n\t_parseEventListenerConfig(eventConfig, prefix, scope) {\n\t\treturn Object.keys(eventConfig).map(function (listenerDescription, index) {\n\t\t\tconst listenerDescriptionParts = listenerDescription.split('#');\n\t\t\tconst sourceName = listenerDescriptionParts[0];\n\t\t\tconst eventName = listenerDescriptionParts[1];\n\t\t\tconst callback = eventConfig[listenerDescription];\n\n\t\t\tif (listenerDescriptionParts.length !== 2 || typeof sourceName !== 'string' || sourceName.length === 0 || typeof eventName !== 'string' || eventName.length === 0) {\n\t\t\t\tthrow new Error('Invalid event listener description: `' + listenerDescription + '`');\n\t\t\t}\n\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new Error('Invalid or missing callback for event listener `' + listenerDescription + '`');\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tid: prefix + '_' + index + '_' + listenerDescription,\n\t\t\t\tsourceName: sourceName,\n\t\t\t\teventName: eventName,\n\t\t\t\tcallback: callback,\n\t\t\t\tscope: scope\n\t\t\t};\n\t\t}, this);\n\t}\n\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis._parentComponent[onOrOff]('set_' + this._entityPropertyName, this._onSetEntity, this);\n\n\t\tthis._parentComponent.system[onOrOff]('beforeremove', this._onParentComponentRemove, this);\n\n\t\tthis._app.systems[onOrOff]('postPostInitialize', this._updateEntityReference, this);\n\n\t\tthis._app[onOrOff]('tools:sceneloaded', this._onSceneLoaded, this);\n\n\t\tconst allComponentSystems = [];\n\n\t\tfor (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n\t\t\tconst config = this._eventListenerConfigs[i];\n\t\t\tconst componentSystem = this._app.systems[config.sourceName];\n\n\t\t\tif (componentSystem) {\n\t\t\t\tif (allComponentSystems.indexOf(componentSystem) === -1) {\n\t\t\t\t\tallComponentSystems.push(componentSystem);\n\t\t\t\t}\n\n\t\t\t\tif (componentSystem && config.eventName === 'gain') {\n\t\t\t\t\tthis._gainListeners[config.sourceName] = config;\n\t\t\t\t}\n\n\t\t\t\tif (componentSystem && config.eventName === 'lose') {\n\t\t\t\t\tthis._loseListeners[config.sourceName] = config;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < allComponentSystems.length; ++i) {\n\t\t\tallComponentSystems[i][onOrOff]('add', this._onComponentAdd, this);\n\t\t\tallComponentSystems[i][onOrOff]('beforeremove', this._onComponentRemove, this);\n\t\t}\n\t}\n\n\t_onSetEntity(name, oldValue, newValue) {\n\t\tif (newValue instanceof Entity) {\n\t\t\tthis._updateEntityReference();\n\t\t} else {\n\t\t\tif (newValue !== null && newValue !== undefined && typeof newValue !== 'string') {\n\t\t\t\tconsole.warn(\"Entity field `\" + this._entityPropertyName + \"` was set to unexpected type '\" + typeof newValue + \"'\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (oldValue !== newValue) {\n\t\t\t\tthis._updateEntityReference();\n\t\t\t}\n\t\t}\n\t}\n\n\tonParentComponentEnable() {\n\t\tif (!this._entity) {\n\t\t\tthis._updateEntityReference();\n\t\t}\n\t}\n\n\t_onSceneLoaded() {\n\t\tthis._updateEntityReference();\n\t}\n\n\t_updateEntityReference() {\n\t\tlet nextEntityGuid = this._parentComponent.data[this._entityPropertyName];\n\t\tlet nextEntity;\n\n\t\tif (nextEntityGuid instanceof Entity) {\n\t\t\tnextEntity = nextEntityGuid;\n\t\t\tnextEntityGuid = nextEntity.getGuid();\n\t\t\tthis._parentComponent.data[this._entityPropertyName] = nextEntityGuid;\n\t\t} else {\n\t\t\tconst root = this._parentComponent.system.app.root;\n\n\t\t\tconst isOnSceneGraph = this._parentComponent.entity.isDescendantOf(root);\n\n\t\t\tnextEntity = isOnSceneGraph && nextEntityGuid ? root.findByGuid(nextEntityGuid) : null;\n\t\t}\n\n\t\tconst hasChanged = this._entity !== nextEntity;\n\n\t\tif (hasChanged) {\n\t\t\tif (this._entity) {\n\t\t\t\tthis._onBeforeEntityChange();\n\t\t\t}\n\n\t\t\tthis._entity = nextEntity;\n\n\t\t\tif (this._entity) {\n\t\t\t\tthis._onAfterEntityChange();\n\t\t\t}\n\n\t\t\tthis.fire('set:entity', this._entity);\n\t\t}\n\t}\n\n\t_onBeforeEntityChange() {\n\t\tthis._toggleEntityListeners('off');\n\n\t\tthis._callAllGainOrLoseListeners(this._loseListeners);\n\t}\n\n\t_onAfterEntityChange() {\n\t\tthis._toggleEntityListeners('on');\n\n\t\tthis._callAllGainOrLoseListeners(this._gainListeners);\n\t}\n\n\t_onComponentAdd(entity, component) {\n\t\tconst componentName = component.system.id;\n\n\t\tif (entity === this._entity) {\n\t\t\tthis._callGainOrLoseListener(componentName, this._gainListeners);\n\n\t\t\tthis._toggleComponentListeners('on', componentName);\n\t\t}\n\t}\n\n\t_onComponentRemove(entity, component) {\n\t\tconst componentName = component.system.id;\n\n\t\tif (entity === this._entity) {\n\t\t\tthis._callGainOrLoseListener(componentName, this._loseListeners);\n\n\t\t\tthis._toggleComponentListeners('off', componentName, true);\n\t\t}\n\t}\n\n\t_callAllGainOrLoseListeners(listenerMap) {\n\t\tfor (const componentName in this._entity.c) {\n\t\t\tthis._callGainOrLoseListener(componentName, listenerMap);\n\t\t}\n\t}\n\n\t_callGainOrLoseListener(componentName, listenerMap) {\n\t\tif (this._entity.c.hasOwnProperty(componentName) && listenerMap[componentName]) {\n\t\t\tconst config = listenerMap[componentName];\n\t\t\tconfig.callback.call(config.scope);\n\t\t}\n\t}\n\n\t_toggleEntityListeners(onOrOff, isDestroying) {\n\t\tif (this._entity) {\n\t\t\tfor (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n\t\t\t\tthis._safeToggleListener(onOrOff, this._eventListenerConfigs[i], isDestroying);\n\t\t\t}\n\t\t}\n\t}\n\n\t_toggleComponentListeners(onOrOff, componentName, isDestroying) {\n\t\tfor (let i = 0; i < this._eventListenerConfigs.length; ++i) {\n\t\t\tconst config = this._eventListenerConfigs[i];\n\n\t\t\tif (config.sourceName === componentName) {\n\t\t\t\tthis._safeToggleListener(onOrOff, config, isDestroying);\n\t\t\t}\n\t\t}\n\t}\n\n\t_safeToggleListener(onOrOff, config, isDestroying) {\n\t\tconst isAdding = onOrOff === 'on';\n\n\t\tif (isAdding && this._listenerStatusFlags[config.id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst source = this._getEventSource(config.sourceName, isDestroying);\n\n\t\tif (source) {\n\t\t\tsource[onOrOff](config.eventName, config.callback, config.scope);\n\t\t\tthis._listenerStatusFlags[config.id] = isAdding;\n\t\t}\n\t}\n\n\t_getEventSource(sourceName, isDestroying) {\n\t\tif (sourceName === 'entity') {\n\t\t\treturn this._entity;\n\t\t}\n\n\t\tconst component = this._entity[sourceName];\n\n\t\tif (component) {\n\t\t\treturn component;\n\t\t}\n\n\t\tif (!isDestroying) {\n\t\t\tconsole.warn('Entity has no component with name ' + sourceName);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_onEntityDestroy(entity) {\n\t\tif (this._entity === entity) {\n\t\t\tthis._toggleEntityListeners('off', true);\n\n\t\t\tthis._entity = null;\n\t\t}\n\t}\n\n\t_onParentComponentRemove(entity, component) {\n\t\tif (component === this._parentComponent) {\n\t\t\tthis._toggleLifecycleListeners('off');\n\n\t\t\tthis._toggleEntityListeners('off', true);\n\t\t}\n\t}\n\n\thasComponent(componentName) {\n\t\treturn this._entity && this._entity.c ? !!this._entity.c[componentName] : false;\n\t}\n\n\tget entity() {\n\t\treturn this._entity;\n\t}\n\n}\n\nconst BUTTON_TRANSITION_MODE_TINT = 0;\nconst BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;\n\nconst ELEMENTTYPE_GROUP = 'group';\nconst ELEMENTTYPE_IMAGE = 'image';\nconst ELEMENTTYPE_TEXT = 'text';\n\nconst VisualState = {\n\tDEFAULT: 'DEFAULT',\n\tHOVER: 'HOVER',\n\tPRESSED: 'PRESSED',\n\tINACTIVE: 'INACTIVE'\n};\nconst STATES_TO_TINT_NAMES = {};\nSTATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';\nSTATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';\nSTATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';\nSTATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';\nconst STATES_TO_SPRITE_ASSET_NAMES = {};\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';\nconst STATES_TO_SPRITE_FRAME_NAMES = {};\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';\n\nclass ButtonComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._visualState = VisualState.DEFAULT;\n\t\tthis._isHovering = false;\n\t\tthis._hoveringCounter = 0;\n\t\tthis._isPressed = false;\n\t\tthis._defaultTint = new Color(1, 1, 1, 1);\n\t\tthis._defaultSpriteAsset = null;\n\t\tthis._defaultSpriteFrame = 0;\n\t\tthis._imageReference = new EntityReference(this, 'imageEntity', {\n\t\t\t'element#gain': this._onImageElementGain,\n\t\t\t'element#lose': this._onImageElementLose,\n\t\t\t'element#set:color': this._onSetColor,\n\t\t\t'element#set:opacity': this._onSetOpacity,\n\t\t\t'element#set:spriteAsset': this._onSetSpriteAsset,\n\t\t\t'element#set:spriteFrame': this._onSetSpriteFrame\n\t\t});\n\n\t\tthis._toggleLifecycleListeners('on', system);\n\t}\n\n\t_toggleLifecycleListeners(onOrOff, system) {\n\t\tthis[onOrOff]('set_active', this._onSetActive, this);\n\t\tthis[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);\n\t\tthis[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);\n\t\tsystem.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);\n\t\tsystem.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);\n\t}\n\n\t_onSetActive(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._updateVisualState();\n\t\t}\n\t}\n\n\t_onSetTransitionMode(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._cancelTween();\n\n\t\t\tthis._resetToDefaultVisualState(oldValue);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onSetTransitionValue(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onElementComponentRemove(entity) {\n\t\tif (this.entity === entity) {\n\t\t\tthis._toggleHitElementListeners('off');\n\t\t}\n\t}\n\n\t_onElementComponentAdd(entity) {\n\t\tif (this.entity === entity) {\n\t\t\tthis._toggleHitElementListeners('on');\n\t\t}\n\t}\n\n\t_onImageElementLose() {\n\t\tthis._cancelTween();\n\n\t\tthis._resetToDefaultVisualState(this.transitionMode);\n\t}\n\n\t_onImageElementGain() {\n\t\tthis._storeDefaultVisualState();\n\n\t\tthis._forceReapplyVisualState();\n\t}\n\n\t_toggleHitElementListeners(onOrOff) {\n\t\tif (this.entity.element) {\n\t\t\tconst isAdding = onOrOff === 'on';\n\n\t\t\tif (isAdding && this._hasHitElementListeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);\n\t\t\tthis.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);\n\t\t\tthis.entity.element[onOrOff]('mousedown', this._onMouseDown, this);\n\t\t\tthis.entity.element[onOrOff]('mouseup', this._onMouseUp, this);\n\t\t\tthis.entity.element[onOrOff]('touchstart', this._onTouchStart, this);\n\t\t\tthis.entity.element[onOrOff]('touchend', this._onTouchEnd, this);\n\t\t\tthis.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);\n\t\t\tthis.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);\n\t\t\tthis.entity.element[onOrOff]('selectstart', this._onSelectStart, this);\n\t\t\tthis.entity.element[onOrOff]('selectend', this._onSelectEnd, this);\n\t\t\tthis.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);\n\t\t\tthis.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);\n\t\t\tthis.entity.element[onOrOff]('click', this._onClick, this);\n\t\t\tthis._hasHitElementListeners = isAdding;\n\t\t}\n\t}\n\n\t_storeDefaultVisualState() {\n\t\tif (this._imageReference.hasComponent('element')) {\n\t\t\tconst element = this._imageReference.entity.element;\n\n\t\t\tif (element.type !== ELEMENTTYPE_GROUP) {\n\t\t\t\tthis._storeDefaultColor(element.color);\n\n\t\t\t\tthis._storeDefaultOpacity(element.opacity);\n\n\t\t\t\tthis._storeDefaultSpriteAsset(element.spriteAsset);\n\n\t\t\t\tthis._storeDefaultSpriteFrame(element.spriteFrame);\n\t\t\t}\n\t\t}\n\t}\n\n\t_storeDefaultColor(color) {\n\t\tthis._defaultTint.r = color.r;\n\t\tthis._defaultTint.g = color.g;\n\t\tthis._defaultTint.b = color.b;\n\t}\n\n\t_storeDefaultOpacity(opacity) {\n\t\tthis._defaultTint.a = opacity;\n\t}\n\n\t_storeDefaultSpriteAsset(spriteAsset) {\n\t\tthis._defaultSpriteAsset = spriteAsset;\n\t}\n\n\t_storeDefaultSpriteFrame(spriteFrame) {\n\t\tthis._defaultSpriteFrame = spriteFrame;\n\t}\n\n\t_onSetColor(color) {\n\t\tif (!this._isApplyingTint) {\n\t\t\tthis._storeDefaultColor(color);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onSetOpacity(opacity) {\n\t\tif (!this._isApplyingTint) {\n\t\t\tthis._storeDefaultOpacity(opacity);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onSetSpriteAsset(spriteAsset) {\n\t\tif (!this._isApplyingSprite) {\n\t\t\tthis._storeDefaultSpriteAsset(spriteAsset);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onSetSpriteFrame(spriteFrame) {\n\t\tif (!this._isApplyingSprite) {\n\t\t\tthis._storeDefaultSpriteFrame(spriteFrame);\n\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\n\t_onMouseEnter(event) {\n\t\tthis._isHovering = true;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('mouseenter', event);\n\t}\n\n\t_onMouseLeave(event) {\n\t\tthis._isHovering = false;\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('mouseleave', event);\n\t}\n\n\t_onMouseDown(event) {\n\t\tthis._isPressed = true;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('mousedown', event);\n\t}\n\n\t_onMouseUp(event) {\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('mouseup', event);\n\t}\n\n\t_onTouchStart(event) {\n\t\tthis._isPressed = true;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('touchstart', event);\n\t}\n\n\t_onTouchEnd(event) {\n\t\tevent.event.preventDefault();\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('touchend', event);\n\t}\n\n\t_onTouchLeave(event) {\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('touchleave', event);\n\t}\n\n\t_onTouchCancel(event) {\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('touchcancel', event);\n\t}\n\n\t_onSelectStart(event) {\n\t\tthis._isPressed = true;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('selectstart', event);\n\t}\n\n\t_onSelectEnd(event) {\n\t\tthis._isPressed = false;\n\n\t\tthis._updateVisualState();\n\n\t\tthis._fireIfActive('selectend', event);\n\t}\n\n\t_onSelectEnter(event) {\n\t\tthis._hoveringCounter++;\n\n\t\tif (this._hoveringCounter === 1) {\n\t\t\tthis._isHovering = true;\n\n\t\t\tthis._updateVisualState();\n\t\t}\n\n\t\tthis._fireIfActive('selectenter', event);\n\t}\n\n\t_onSelectLeave(event) {\n\t\tthis._hoveringCounter--;\n\n\t\tif (this._hoveringCounter === 0) {\n\t\t\tthis._isHovering = false;\n\t\t\tthis._isPressed = false;\n\n\t\t\tthis._updateVisualState();\n\t\t}\n\n\t\tthis._fireIfActive('selectleave', event);\n\t}\n\n\t_onClick(event) {\n\t\tthis._fireIfActive('click', event);\n\t}\n\n\t_fireIfActive(name, event) {\n\t\tif (this.data.active) {\n\t\t\tthis.fire(name, event);\n\t\t}\n\t}\n\n\t_updateVisualState(force) {\n\t\tconst oldVisualState = this._visualState;\n\n\t\tconst newVisualState = this._determineVisualState();\n\n\t\tif ((oldVisualState !== newVisualState || force) && this.enabled) {\n\t\t\tthis._visualState = newVisualState;\n\n\t\t\tif (oldVisualState === VisualState.HOVER) {\n\t\t\t\tthis._fireIfActive('hoverend');\n\t\t\t}\n\n\t\t\tif (oldVisualState === VisualState.PRESSED) {\n\t\t\t\tthis._fireIfActive('pressedend');\n\t\t\t}\n\n\t\t\tif (newVisualState === VisualState.HOVER) {\n\t\t\t\tthis._fireIfActive('hoverstart');\n\t\t\t}\n\n\t\t\tif (newVisualState === VisualState.PRESSED) {\n\t\t\t\tthis._fireIfActive('pressedstart');\n\t\t\t}\n\n\t\t\tswitch (this.transitionMode) {\n\t\t\t\tcase BUTTON_TRANSITION_MODE_TINT:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst tintName = STATES_TO_TINT_NAMES[this._visualState];\n\t\t\t\t\t\tconst tintColor = this[tintName];\n\n\t\t\t\t\t\tthis._applyTint(tintColor);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase BUTTON_TRANSITION_MODE_SPRITE_CHANGE:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];\n\t\t\t\t\t\tconst spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];\n\t\t\t\t\t\tconst spriteAsset = this[spriteAssetName];\n\t\t\t\t\t\tconst spriteFrame = this[spriteFrameName];\n\n\t\t\t\t\t\tthis._applySprite(spriteAsset, spriteFrame);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_forceReapplyVisualState() {\n\t\tthis._updateVisualState(true);\n\t}\n\n\t_resetToDefaultVisualState(transitionMode) {\n\t\tif (this._imageReference.hasComponent('element')) {\n\t\t\tswitch (transitionMode) {\n\t\t\t\tcase BUTTON_TRANSITION_MODE_TINT:\n\t\t\t\t\tthis._cancelTween();\n\n\t\t\t\t\tthis._applyTintImmediately(this._defaultTint);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BUTTON_TRANSITION_MODE_SPRITE_CHANGE:\n\t\t\t\t\tthis._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_determineVisualState() {\n\t\tif (!this.active) {\n\t\t\treturn VisualState.INACTIVE;\n\t\t} else if (this._isPressed) {\n\t\t\treturn VisualState.PRESSED;\n\t\t} else if (this._isHovering) {\n\t\t\treturn VisualState.HOVER;\n\t\t}\n\n\t\treturn VisualState.DEFAULT;\n\t}\n\n\t_applySprite(spriteAsset, spriteFrame) {\n\t\tspriteFrame = spriteFrame || 0;\n\n\t\tif (this._imageReference.hasComponent('element')) {\n\t\t\tthis._isApplyingSprite = true;\n\n\t\t\tif (this._imageReference.entity.element.spriteAsset !== spriteAsset) {\n\t\t\t\tthis._imageReference.entity.element.spriteAsset = spriteAsset;\n\t\t\t}\n\n\t\t\tif (this._imageReference.entity.element.spriteFrame !== spriteFrame) {\n\t\t\t\tthis._imageReference.entity.element.spriteFrame = spriteFrame;\n\t\t\t}\n\n\t\t\tthis._isApplyingSprite = false;\n\t\t}\n\t}\n\n\t_applyTint(tintColor) {\n\t\tthis._cancelTween();\n\n\t\tif (this.fadeDuration === 0) {\n\t\t\tthis._applyTintImmediately(tintColor);\n\t\t} else {\n\t\t\tthis._applyTintWithTween(tintColor);\n\t\t}\n\t}\n\n\t_applyTintImmediately(tintColor) {\n\t\tif (!tintColor || !this._imageReference.hasComponent('element')) return;\n\t\tconst color3 = toColor3(tintColor);\n\t\tthis._isApplyingTint = true;\n\t\tif (!color3.equals(this._imageReference.entity.element.color)) this._imageReference.entity.element.color = color3;\n\t\tif (this._imageReference.entity.element.opacity != tintColor.a) this._imageReference.entity.element.opacity = tintColor.a;\n\t\tthis._isApplyingTint = false;\n\t}\n\n\t_applyTintWithTween(tintColor) {\n\t\tif (!tintColor || !this._imageReference.hasComponent('element')) return;\n\t\tconst color3 = toColor3(tintColor);\n\t\tconst color = this._imageReference.entity.element.color;\n\t\tconst opacity = this._imageReference.entity.element.opacity;\n\t\tif (color3.equals(color) && tintColor.a == opacity) return;\n\t\tthis._tweenInfo = {\n\t\t\tstartTime: now(),\n\t\t\tfrom: new Color(color.r, color.g, color.b, opacity),\n\t\t\tto: tintColor.clone(),\n\t\t\tlerpColor: new Color()\n\t\t};\n\t}\n\n\t_updateTintTween() {\n\t\tconst elapsedTime = now() - this._tweenInfo.startTime;\n\n\t\tlet elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;\n\t\telapsedProportion = math.clamp(elapsedProportion, 0, 1);\n\n\t\tif (Math.abs(elapsedProportion - 1) > 1e-5) {\n\t\t\tconst lerpColor = this._tweenInfo.lerpColor;\n\t\t\tlerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);\n\n\t\t\tthis._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));\n\t\t} else {\n\t\t\tthis._applyTintImmediately(this._tweenInfo.to);\n\n\t\t\tthis._cancelTween();\n\t\t}\n\t}\n\n\t_cancelTween() {\n\t\tdelete this._tweenInfo;\n\t}\n\n\tonUpdate() {\n\t\tif (this._tweenInfo) {\n\t\t\tthis._updateTintTween();\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tthis._isHovering = false;\n\t\tthis._hoveringCounter = 0;\n\t\tthis._isPressed = false;\n\n\t\tthis._imageReference.onParentComponentEnable();\n\n\t\tthis._toggleHitElementListeners('on');\n\n\t\tthis._forceReapplyVisualState();\n\t}\n\n\tonDisable() {\n\t\tthis._toggleHitElementListeners('off');\n\n\t\tthis._resetToDefaultVisualState(this.transitionMode);\n\t}\n\n\tonRemove() {\n\t\tthis._toggleLifecycleListeners('off', this.system);\n\n\t\tthis.onDisable();\n\t}\n\n}\n\nfunction toColor3(color4) {\n\treturn new Color(color4.r, color4.g, color4.b);\n}\n\nclass ButtonComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.active = true;\n\t\tthis.imageEntity = null;\n\t\tthis.hitPadding = new Vec4();\n\t\tthis.transitionMode = BUTTON_TRANSITION_MODE_TINT;\n\t\tthis.hoverTint = new Color(0.75, 0.75, 0.75);\n\t\tthis.pressedTint = new Color(0.5, 0.5, 0.5);\n\t\tthis.inactiveTint = new Color(0.25, 0.25, 0.25);\n\t\tthis.fadeDuration = 0;\n\t\tthis.hoverSpriteAsset = null;\n\t\tthis.hoverSpriteFrame = 0;\n\t\tthis.pressedSpriteAsset = null;\n\t\tthis.pressedSpriteFrame = 0;\n\t\tthis.inactiveSpriteAsset = null;\n\t\tthis.inactiveSpriteFrame = 0;\n\t}\n\n}\n\nconst _schema$h = ['enabled', 'active', {\n\tname: 'imageEntity',\n\ttype: 'entity'\n}, {\n\tname: 'hitPadding',\n\ttype: 'vec4'\n}, 'transitionMode', {\n\tname: 'hoverTint',\n\ttype: 'rgba'\n}, {\n\tname: 'pressedTint',\n\ttype: 'rgba'\n}, {\n\tname: 'inactiveTint',\n\ttype: 'rgba'\n}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];\n\nclass ButtonComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'button';\n\t\tthis.ComponentType = ButtonComponent;\n\t\tthis.DataType = ButtonComponentData;\n\t\tthis.schema = _schema$h;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tsuper.initializeComponentData(component, data, _schema$h);\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tconst entity = components[id].entity;\n\t\t\tconst component = entity.button;\n\n\t\t\tif (component.enabled && entity.enabled) {\n\t\t\t\tcomponent.onUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(ButtonComponent.prototype, _schema$h);\n\nlet depthLayer$1;\n\nclass PostEffect {\n\tconstructor(effect, inputTarget) {\n\t\tthis.effect = effect;\n\t\tthis.inputTarget = inputTarget;\n\t\tthis.outputTarget = null;\n\t\tthis.name = effect.constructor.name;\n\t}\n\n}\n\nclass PostEffectQueue {\n\tconstructor(app, camera) {\n\t\tthis.app = app;\n\t\tthis.camera = camera;\n\t\tthis.destinationRenderTarget = null;\n\t\tthis.effects = [];\n\t\tthis.enabled = false;\n\t\tthis.depthTarget = null;\n\t\tthis.renderTargetScale = 1;\n\t\tthis.resizeTimeout = null;\n\t\tthis.resizeLast = 0;\n\n\t\tthis._resizeTimeoutCallback = () => {\n\t\t\tthis.resizeRenderTargets();\n\t\t};\n\n\t\tcamera.on('set:rect', this.onCameraRectChanged, this);\n\t}\n\n\t_allocateColorBuffer(format, name) {\n\t\tconst rect = this.camera.rect;\n\t\tconst width = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);\n\t\tconst height = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);\n\t\tconst colorBuffer = new Texture(this.app.graphicsDevice, {\n\t\t\tformat: format,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tcolorBuffer.name = name;\n\t\treturn colorBuffer;\n\t}\n\n\t_createOffscreenTarget(useDepth, hdr) {\n\t\tconst device = this.app.graphicsDevice;\n\t\tconst format = hdr ? device.getHdrFormat() : PIXELFORMAT_R8_G8_B8_A8;\n\t\tconst name = this.camera.entity.name + '-posteffect-' + this.effects.length;\n\n\t\tconst colorBuffer = this._allocateColorBuffer(format, name);\n\n\t\tconst useStencil = this.app.graphicsDevice.supportsStencil;\n\t\tconst samples = useDepth ? device.samples : 1;\n\t\treturn new RenderTarget({\n\t\t\tcolorBuffer: colorBuffer,\n\t\t\tdepth: useDepth,\n\t\t\tstencil: useStencil,\n\t\t\tsamples: samples\n\t\t});\n\t}\n\n\t_resizeOffscreenTarget(rt) {\n\t\tconst format = rt.colorBuffer.format;\n\t\tconst name = rt.colorBuffer.name;\n\t\trt.destroyFrameBuffers();\n\t\trt.destroyTextureBuffers();\n\t\trt._colorBuffer = this._allocateColorBuffer(format, name);\n\t}\n\n\t_destroyOffscreenTarget(rt) {\n\t\trt.destroyTextureBuffers();\n\t\trt.destroy();\n\t}\n\n\tsetRenderTargetScale(scale) {\n\t\tthis.renderTargetScale = scale;\n\t\tthis.resizeRenderTargets();\n\t}\n\n\taddEffect(effect) {\n\t\tconst effects = this.effects;\n\t\tconst isFirstEffect = effects.length === 0;\n\n\t\tconst inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);\n\n\t\tconst newEntry = new PostEffect(effect, inputTarget);\n\t\teffects.push(newEntry);\n\t\tthis._sourceTarget = newEntry.inputTarget;\n\n\t\tif (effects.length > 1) {\n\t\t\teffects[effects.length - 2].outputTarget = newEntry.inputTarget;\n\t\t}\n\n\t\tthis._newPostEffect = effect;\n\n\t\tif (effect.needsDepthBuffer) {\n\t\t\tthis._requestDepthMap();\n\t\t}\n\n\t\tthis.enable();\n\t\tthis._newPostEffect = undefined;\n\t}\n\n\tremoveEffect(effect) {\n\t\tlet index = -1;\n\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tif (this.effects[i].effect === effect) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (index >= 0) {\n\t\t\tif (index > 0) {\n\t\t\t\tthis.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;\n\t\t\t} else {\n\t\t\t\tif (this.effects.length > 1) {\n\t\t\t\t\tif (!this.effects[1].inputTarget._depth) {\n\t\t\t\t\t\tthis._destroyOffscreenTarget(this.effects[1].inputTarget);\n\n\t\t\t\t\t\tthis.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);\n\t\t\t\t\t\tthis._sourceTarget = this.effects[1].inputTarget;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.camera.renderTarget = this.effects[1].inputTarget;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._destroyOffscreenTarget(this.effects[index].inputTarget);\n\n\t\t\tthis.effects.splice(index, 1);\n\t\t}\n\n\t\tif (this.enabled) {\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._releaseDepthMap();\n\t\t\t}\n\t\t}\n\n\t\tif (this.effects.length === 0) {\n\t\t\tthis.disable();\n\t\t}\n\t}\n\n\t_requestDepthMaps() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tconst effect = this.effects[i].effect;\n\t\t\tif (this._newPostEffect === effect) continue;\n\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._requestDepthMap();\n\t\t\t}\n\t\t}\n\t}\n\n\t_releaseDepthMaps() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tconst effect = this.effects[i].effect;\n\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._releaseDepthMap();\n\t\t\t}\n\t\t}\n\t}\n\n\t_requestDepthMap() {\n\t\tif (!depthLayer$1) depthLayer$1 = this.app.scene.layers.getLayerById(LAYERID_DEPTH);\n\t\tif (depthLayer$1) depthLayer$1.incrementCounter();\n\t}\n\n\t_releaseDepthMap() {\n\t\tif (depthLayer$1) depthLayer$1.decrementCounter();\n\t}\n\n\tdestroy() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tthis.effects[i].inputTarget.destroy();\n\t\t}\n\n\t\tthis.effects.length = 0;\n\t\tthis.disable();\n\t}\n\n\tenable() {\n\t\tif (!this.enabled && this.effects.length) {\n\t\t\tthis.enabled = true;\n\n\t\t\tthis._requestDepthMaps();\n\n\t\t\tthis.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);\n\t\t\tthis.destinationRenderTarget = this.camera.renderTarget;\n\t\t\tthis.camera.renderTarget = this.effects[0].inputTarget;\n\n\t\t\tthis.camera.onPostprocessing = () => {\n\t\t\t\tif (this.enabled) {\n\t\t\t\t\tlet rect = null;\n\t\t\t\t\tconst len = this.effects.length;\n\n\t\t\t\t\tif (len) {\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tconst fx = this.effects[i];\n\t\t\t\t\t\t\tlet destTarget = fx.outputTarget;\n\n\t\t\t\t\t\t\tif (i === len - 1) {\n\t\t\t\t\t\t\t\trect = this.camera.rect;\n\n\t\t\t\t\t\t\t\tif (this.destinationRenderTarget) {\n\t\t\t\t\t\t\t\t\tdestTarget = this.destinationRenderTarget;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfx.effect.render(fx.inputTarget, destTarget, rect);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tdisable() {\n\t\tif (this.enabled) {\n\t\t\tthis.enabled = false;\n\t\t\tthis.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);\n\n\t\t\tthis._releaseDepthMaps();\n\n\t\t\tthis._destroyOffscreenTarget(this._sourceTarget);\n\n\t\t\tthis.camera.renderTarget = null;\n\t\t\tthis.camera.onPostprocessing = null;\n\t\t}\n\t}\n\n\t_onCanvasResized(width, height) {\n\t\tconst rect = this.camera.rect;\n\t\tconst device = this.app.graphicsDevice;\n\t\tthis.camera.camera.aspectRatio = device.width * rect.z / (device.height * rect.w);\n\t\tif (this.resizeTimeout) return;\n\n\t\tif (now() - this.resizeLast > 100) {\n\t\t\tthis.resizeRenderTargets();\n\t\t} else {\n\t\t\tthis.resizeTimeout = setTimeout(this._resizeTimeoutCallback, 100);\n\t\t}\n\t}\n\n\tresizeRenderTargets() {\n\t\tif (this.resizeTimeout) {\n\t\t\tclearTimeout(this.resizeTimeout);\n\t\t\tthis.resizeTimeout = null;\n\t\t}\n\n\t\tthis.resizeLast = now();\n\t\tconst rect = this.camera.rect;\n\t\tconst desiredWidth = Math.floor(rect.z * this.app.graphicsDevice.width * this.renderTargetScale);\n\t\tconst desiredHeight = Math.floor(rect.w * this.app.graphicsDevice.height * this.renderTargetScale);\n\t\tconst effects = this.effects;\n\n\t\tfor (let i = 0, len = effects.length; i < len; i++) {\n\t\t\tconst fx = effects[i];\n\n\t\t\tif (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {\n\t\t\t\tthis._resizeOffscreenTarget(fx.inputTarget);\n\t\t\t}\n\t\t}\n\t}\n\n\tonCameraRectChanged(name, oldValue, newValue) {\n\t\tif (this.enabled) {\n\t\t\tthis.resizeRenderTargets();\n\t\t}\n\t}\n\n}\n\nconst properties$1 = [{\n\tname: 'aspectRatio',\n\treadonly: false\n}, {\n\tname: 'aspectRatioMode',\n\treadonly: false\n}, {\n\tname: 'calculateProjection',\n\treadonly: false\n}, {\n\tname: 'calculateTransform',\n\treadonly: false\n}, {\n\tname: 'clearColor',\n\treadonly: false\n}, {\n\tname: 'cullFaces',\n\treadonly: false\n}, {\n\tname: 'farClip',\n\treadonly: false\n}, {\n\tname: 'flipFaces',\n\treadonly: false\n}, {\n\tname: 'fov',\n\treadonly: false\n}, {\n\tname: 'frustumCulling',\n\treadonly: false\n}, {\n\tname: 'horizontalFov',\n\treadonly: false\n}, {\n\tname: 'nearClip',\n\treadonly: false\n}, {\n\tname: 'orthoHeight',\n\treadonly: false\n}, {\n\tname: 'projection',\n\treadonly: false\n}, {\n\tname: 'scissorRect',\n\treadonly: false\n}, {\n\tname: 'vrDisplay',\n\treadonly: false\n}];\n\nclass CameraComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.onPostprocessing = null;\n\t\tthis.onPreRender = null;\n\t\tthis.onPostRender = null;\n\t\tthis._camera = new Camera();\n\t\tthis._camera.node = entity;\n\t\tthis._priority = 0;\n\t\tthis._disablePostEffectsLayer = LAYERID_UI;\n\t\tthis._postEffects = new PostEffectQueue(system.app, this);\n\t}\n\n\tget camera() {\n\t\treturn this._camera;\n\t}\n\n\tset clearColorBuffer(value) {\n\t\tthis._camera.clearColorBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget clearColorBuffer() {\n\t\treturn this._camera.clearColorBuffer;\n\t}\n\n\tset clearDepthBuffer(value) {\n\t\tthis._camera.clearDepthBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget clearDepthBuffer() {\n\t\treturn this._camera.clearDepthBuffer;\n\t}\n\n\tset clearStencilBuffer(value) {\n\t\tthis._camera.clearStencilBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget clearStencilBuffer() {\n\t\treturn this._camera.clearStencilBuffer;\n\t}\n\n\tset disablePostEffectsLayer(layer) {\n\t\tthis._disablePostEffectsLayer = layer;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget disablePostEffectsLayer() {\n\t\treturn this._disablePostEffectsLayer;\n\t}\n\n\tget frustum() {\n\t\treturn this._camera.frustum;\n\t}\n\n\tset layers(newValue) {\n\t\tconst layers = this._camera.layers;\n\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeCamera(this);\n\t\t}\n\n\t\tthis._camera.layers = newValue;\n\t\tif (!this.enabled || !this.entity.enabled) return;\n\n\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addCamera(this);\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._camera.layers;\n\t}\n\n\tget postEffectsEnabled() {\n\t\treturn this._postEffects.enabled;\n\t}\n\n\tget postEffects() {\n\t\treturn this._postEffects;\n\t}\n\n\tset priority(newValue) {\n\t\tthis._priority = newValue;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\n\tget projectionMatrix() {\n\t\treturn this._camera.projectionMatrix;\n\t}\n\n\tset rect(value) {\n\t\tthis._camera.rect = value;\n\t\tthis.fire('set:rect', this._camera.rect);\n\t}\n\n\tget rect() {\n\t\treturn this._camera.rect;\n\t}\n\n\tset renderTarget(value) {\n\t\tthis._camera.renderTarget = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\n\tget renderTarget() {\n\t\treturn this._camera.renderTarget;\n\t}\n\n\tget viewMatrix() {\n\t\treturn this._camera.viewMatrix;\n\t}\n\n\tdirtyLayerCompositionCameras() {\n\t\tconst layerComp = this.system.app.scene.layers;\n\t\tlayerComp._dirtyCameras = true;\n\t}\n\n\tscreenToWorld(screenx, screeny, cameraz, worldCoord) {\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst w = device.clientRect.width;\n\t\tconst h = device.clientRect.height;\n\t\treturn this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);\n\t}\n\n\tworldToScreen(worldCoord, screenCoord) {\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst w = device.clientRect.width;\n\t\tconst h = device.clientRect.height;\n\t\treturn this._camera.worldToScreen(worldCoord, w, h, screenCoord);\n\t}\n\n\tonAppPrerender() {\n\t\tthis._camera._viewMatDirty = true;\n\t\tthis._camera._viewProjMatDirty = true;\n\t}\n\n\taddCameraToLayers() {\n\t\tconst layers = this.layers;\n\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addCamera(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveCameraFromLayers() {\n\t\tconst layers = this.layers;\n\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeCamera(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addCameraToLayers();\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addCamera(this);\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeCamera(this);\n\t}\n\n\tonEnable() {\n\t\tconst system = this.system;\n\t\tconst scene = system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tsystem.addCamera(this);\n\t\tscene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (layers) {\n\t\t\tlayers.on(\"add\", this.onLayerAdded, this);\n\t\t\tlayers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addCameraToLayers();\n\t\t}\n\n\t\tthis.postEffects.enable();\n\t}\n\n\tonDisable() {\n\t\tconst system = this.system;\n\t\tconst scene = system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tthis.postEffects.disable();\n\t\tthis.removeCameraFromLayers();\n\t\tscene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (layers) {\n\t\t\tlayers.off(\"add\", this.onLayerAdded, this);\n\t\t\tlayers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tsystem.removeCamera(this);\n\t}\n\n\tonRemove() {\n\t\tthis.onDisable();\n\t\tthis.off();\n\t}\n\n\tcalculateAspectRatio(rt) {\n\t\tconst src = rt ? rt : this.system.app.graphicsDevice;\n\t\tconst rect = this.rect;\n\t\treturn src.width * rect.z / (src.height * rect.w);\n\t}\n\n\tframeBegin(rt) {\n\t\tif (this.aspectRatioMode === ASPECT_AUTO) {\n\t\t\tthis.aspectRatio = this.calculateAspectRatio(rt);\n\t\t}\n\t}\n\n\tframeEnd() {}\n\n\tenterVr(display, callback) {\n\t\tif (display instanceof Function && !callback) {\n\t\t\tcallback = display;\n\t\t\tdisplay = null;\n\t\t}\n\n\t\tif (!this.system.app.vr) {\n\t\t\tcallback(\"VrManager not created. Enable VR in project settings.\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!display) {\n\t\t\tdisplay = this.system.app.vr.display;\n\t\t}\n\n\t\tif (display) {\n\t\t\tconst self = this;\n\n\t\t\tif (display.capabilities.canPresent) {\n\t\t\t\tdisplay.requestPresent(function (err) {\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tself.vrDisplay = display;\n\t\t\t\t\t\tself.vrDisplay.once('beforepresentchange', function (display) {\n\t\t\t\t\t\t\tif (!display.presenting) {\n\t\t\t\t\t\t\t\tself.vrDisplay = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback(err);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tself.vrDisplay = display;\n\t\t\t\tcallback();\n\t\t\t}\n\t\t} else {\n\t\t\tcallback(\"No pc.VrDisplay to present\");\n\t\t}\n\t}\n\n\texitVr(callback) {\n\t\tif (this.vrDisplay) {\n\t\t\tif (this.vrDisplay.capabilities.canPresent) {\n\t\t\t\tconst display = this.vrDisplay;\n\t\t\t\tthis.vrDisplay = null;\n\t\t\t\tdisplay.exitPresent(callback);\n\t\t\t} else {\n\t\t\t\tthis.vrDisplay = null;\n\t\t\t\tcallback();\n\t\t\t}\n\t\t} else {\n\t\t\tcallback(\"Not presenting VR\");\n\t\t}\n\t}\n\n\tstartXr(type, spaceType, options) {\n\t\tthis.system.app.xr.start(this, type, spaceType, options);\n\t}\n\n\tendXr(callback) {\n\t\tif (!this._camera.xr) {\n\t\t\tif (callback) callback(new Error(\"Camera is not in XR\"));\n\t\t\treturn;\n\t\t}\n\n\t\tthis._camera.xr.end(callback);\n\t}\n\n\tcopy(source) {\n\t\tproperties$1.forEach(property => {\n\t\t\tif (!property.readonly) {\n\t\t\t\tconst name = property.name;\n\t\t\t\tthis[name] = source[name];\n\t\t\t}\n\t\t});\n\t\tthis.clearColorBuffer = source.clearColorBuffer;\n\t\tthis.clearDepthBuffer = source.clearDepthBuffer;\n\t\tthis.clearStencilBuffer = source.clearStencilBuffer;\n\t\tthis.disablePostEffectsLayer = source.disablePostEffectsLayer;\n\t\tthis.layers = source.layers;\n\t\tthis.priority = source.priority;\n\t\tthis.renderTarget = source.renderTarget;\n\t\tthis.rect = source.rect;\n\t}\n\n}\n\nproperties$1.forEach(function (property) {\n\tconst name = property.name;\n\tconst options = {};\n\n\toptions.get = function () {\n\t\treturn this._camera[name];\n\t};\n\n\tif (!property.readonly) {\n\t\toptions.set = function (newValue) {\n\t\t\tthis._camera[name] = newValue;\n\t\t};\n\t}\n\n\tObject.defineProperty(CameraComponent.prototype, name, options);\n});\n\nclass CameraComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$g = ['enabled'];\n\nclass CameraComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'camera';\n\t\tthis.ComponentType = CameraComponent;\n\t\tthis.DataType = CameraComponentData;\n\t\tthis.schema = _schema$g;\n\t\tthis.cameras = [];\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.on('prerender', this.onAppPrerender, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect'];\n\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tconst property = properties[i];\n\n\t\t\tif (data.hasOwnProperty(property)) {\n\t\t\t\tconst value = data[property];\n\n\t\t\t\tswitch (property) {\n\t\t\t\t\tcase 'rect':\n\t\t\t\t\tcase 'scissorRect':\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tcomponent[property] = new Vec4(value[0], value[1], value[2], value[3]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'clearColor':\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tcomponent[property] = new Color(value[0], value[1], value[2], value[3]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst c = entity.camera;\n\t\tthis.addComponent(clone, {\n\t\t\taspectRatio: c.aspectRatio,\n\t\t\taspectRatioMode: c.aspectRatioMode,\n\t\t\tcalculateProjection: c.calculateProjection,\n\t\t\tcalculateTransform: c.calculateTransform,\n\t\t\tclearColor: c.clearColor,\n\t\t\tclearColorBuffer: c.clearColorBuffer,\n\t\t\tclearDepthBuffer: c.clearDepthBuffer,\n\t\t\tclearStencilBuffer: c.clearStencilBuffer,\n\t\t\tcullFaces: c.cullFaces,\n\t\t\tenabled: c.enabled,\n\t\t\tfarClip: c.farClip,\n\t\t\tflipFaces: c.flipFaces,\n\t\t\tfov: c.fov,\n\t\t\tfrustumCulling: c.frustumCulling,\n\t\t\thorizontalFov: c.horizontalFov,\n\t\t\tlayers: c.layers,\n\t\t\trenderTarget: c.renderTarget,\n\t\t\tnearClip: c.nearClip,\n\t\t\torthoHeight: c.orthoHeight,\n\t\t\tprojection: c.projection,\n\t\t\tpriority: c.priority,\n\t\t\trect: c.rect,\n\t\t\tscissorRect: c.scissorRect\n\t\t});\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tthis.removeCamera(component);\n\t}\n\n\tonUpdate(dt) {\n\t\tif (this.app.vr) {\n\t\t\tconst components = this.store;\n\n\t\t\tfor (const id in components) {\n\t\t\t\tconst component = components[id];\n\n\t\t\t\tif (component.data.enabled && component.entity.enabled) {\n\t\t\t\t\tconst cameraComponent = component.entity.camera;\n\t\t\t\t\tconst vrDisplay = cameraComponent.vrDisplay;\n\n\t\t\t\t\tif (vrDisplay) {\n\t\t\t\t\t\tvrDisplay.setClipPlanes(cameraComponent.nearClip, cameraComponent.farClip);\n\n\t\t\t\t\t\tif (component.entity) {\n\t\t\t\t\t\t\tcomponent.entity.localTransform.copy(vrDisplay.combinedViewInv);\n\t\t\t\t\t\t\tcomponent.entity._dirtyLocal = false;\n\n\t\t\t\t\t\t\tcomponent.entity._dirtifyWorld();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonAppPrerender() {\n\t\tfor (let i = 0, len = this.cameras.length; i < len; i++) {\n\t\t\tthis.cameras[i].onAppPrerender();\n\t\t}\n\t}\n\n\taddCamera(camera) {\n\t\tthis.cameras.push(camera);\n\t\tthis.sortCamerasByPriority();\n\t}\n\n\tremoveCamera(camera) {\n\t\tconst index = this.cameras.indexOf(camera);\n\n\t\tif (index >= 0) {\n\t\t\tthis.cameras.splice(index, 1);\n\t\t\tthis.sortCamerasByPriority();\n\t\t}\n\t}\n\n\tsortCamerasByPriority() {\n\t\tthis.cameras.sort(function (a, b) {\n\t\t\treturn a.priority - b.priority;\n\t\t});\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(CameraComponent.prototype, _schema$g);\n\nclass CollisionComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._compoundParent = null;\n\t\tthis.entity.on('insert', this._onInsert, this);\n\t\tthis.on('set_type', this.onSetType, this);\n\t\tthis.on('set_halfExtents', this.onSetHalfExtents, this);\n\t\tthis.on('set_radius', this.onSetRadius, this);\n\t\tthis.on('set_height', this.onSetHeight, this);\n\t\tthis.on('set_axis', this.onSetAxis, this);\n\t\tthis.on(\"set_asset\", this.onSetAsset, this);\n\t\tthis.on(\"set_renderAsset\", this.onSetRenderAsset, this);\n\t\tthis.on(\"set_model\", this.onSetModel, this);\n\t\tthis.on(\"set_render\", this.onSetRender, this);\n\t}\n\n\tonSetType(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis.system.changeType(this, oldValue, newValue);\n\t\t}\n\t}\n\n\tonSetHalfExtents(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\n\t\tif (this.data.initialized && t === 'box') {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetRadius(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\n\t\tif (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetHeight(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\n\t\tif (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetAxis(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\n\t\tif (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.asset = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(this.data.asset);\n\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tif (!newValue) {\n\t\t\t\tthis.data.model = null;\n\t\t\t}\n\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetRenderAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.renderAsset = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(this.data.renderAsset);\n\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onRenderAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tif (!newValue) {\n\t\t\t\tthis.data.render = null;\n\t\t\t}\n\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\n\tonSetModel(name, oldValue, newValue) {\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tthis.system.implementations.mesh.doRecreatePhysicalShape(this);\n\t\t}\n\t}\n\n\tonSetRender(name, oldValue, newValue) {\n\t\tthis.onSetModel(name, oldValue, newValue);\n\t}\n\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\n\t\tif (this.data.asset === asset.id) {\n\t\t\tthis.asset = null;\n\t\t}\n\t}\n\n\tonRenderAssetRemoved(asset) {\n\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\n\t\tif (this.data.renderAsset === asset.id) {\n\t\t\tthis.renderAsset = null;\n\t\t}\n\t}\n\n\t_getCompoundChildShapeIndex(shape) {\n\t\tconst compound = this.data.shape;\n\t\tconst shapes = compound.getNumChildShapes();\n\n\t\tfor (let i = 0; i < shapes; i++) {\n\t\t\tconst childShape = compound.getChildShape(i);\n\n\t\t\tif (childShape.ptr === shape.ptr) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_onInsert(parent) {\n\t\tif (typeof Ammo === 'undefined') return;\n\n\t\tif (this._compoundParent) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t} else if (!this.entity.rigidbody) {\n\t\t\tlet ancestor = this.entity.parent;\n\n\t\t\twhile (ancestor) {\n\t\t\t\tif (ancestor.collision && ancestor.collision.type === 'compound') {\n\t\t\t\t\tif (ancestor.collision.shape.getNumChildShapes() === 0) {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(ancestor.collision);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tancestor = ancestor.parent;\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateCompound() {\n\t\tconst entity = this.entity;\n\n\t\tif (entity._dirtyWorld) {\n\t\t\tlet dirty = entity._dirtyLocal;\n\t\t\tlet parent = entity;\n\n\t\t\twhile (parent && !dirty) {\n\t\t\t\tif (parent.collision && parent.collision === this._compoundParent) break;\n\t\t\t\tif (parent._dirtyLocal) dirty = true;\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\n\t\t\tif (dirty) {\n\t\t\t\tentity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);\n\t\t\t\tconst bodyComponent = this._compoundParent.entity.rigidbody;\n\t\t\t\tif (bodyComponent) bodyComponent.activate();\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tif (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {\n\t\t\tconst asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);\n\n\t\t\tif (asset && (!asset.resource || !this.data.shape)) {\n\t\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this.entity.rigidbody) {\n\t\t\tif (this.entity.rigidbody.enabled) {\n\t\t\t\tthis.entity.rigidbody.enableSimulation();\n\t\t\t}\n\t\t} else if (this._compoundParent && this !== this._compoundParent) {\n\t\t\tif (this._compoundParent.shape.getNumChildShapes() === 0) {\n\t\t\t\tthis.system.recreatePhysicalShapes(this._compoundParent);\n\t\t\t} else {\n\t\t\t\tconst transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);\n\n\t\t\t\tthis._compoundParent.shape.addChildShape(transform, this.data.shape);\n\n\t\t\t\tAmmo.destroy(transform);\n\t\t\t\tif (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();\n\t\t\t}\n\t\t} else if (this.entity.trigger) {\n\t\t\tthis.entity.trigger.enable();\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tif (this.entity.rigidbody) {\n\t\t\tthis.entity.rigidbody.disableSimulation();\n\t\t} else if (this._compoundParent && this !== this._compoundParent) {\n\t\t\tif (!this._compoundParent.entity._destroying) {\n\t\t\t\tthis.system._removeCompoundChild(this._compoundParent, this.data.shape);\n\n\t\t\t\tif (this._compoundParent.entity.rigidbody) this._compoundParent.entity.rigidbody.activate();\n\t\t\t}\n\t\t} else if (this.entity.trigger) {\n\t\t\tthis.entity.trigger.disable();\n\t\t}\n\t}\n\n\tonBeforeRemove() {\n\t\tif (this.asset) {\n\t\t\tthis.asset = null;\n\t\t}\n\n\t\tif (this.renderAsset) {\n\t\t\tthis.renderAsset = null;\n\t\t}\n\n\t\tthis.entity.off('insert', this._onInsert, this);\n\t\tthis.off();\n\t}\n\n}\n\nclass CollisionComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.type = 'box';\n\t\tthis.halfExtents = new Vec3(0.5, 0.5, 0.5);\n\t\tthis.radius = 0.5;\n\t\tthis.axis = 1;\n\t\tthis.height = 2;\n\t\tthis.asset = null;\n\t\tthis.renderAsset = null;\n\t\tthis.shape = null;\n\t\tthis.model = null;\n\t\tthis.render = null;\n\t\tthis.initialized = false;\n\t}\n\n}\n\nconst BODYTYPE_STATIC = 'static';\nconst BODYTYPE_DYNAMIC = 'dynamic';\nconst BODYTYPE_KINEMATIC = 'kinematic';\nconst BODYFLAG_STATIC_OBJECT = 1;\nconst BODYFLAG_KINEMATIC_OBJECT = 2;\nconst BODYFLAG_NORESPONSE_OBJECT = 4;\nconst BODYSTATE_ACTIVE_TAG = 1;\nconst BODYSTATE_ISLAND_SLEEPING = 2;\nconst BODYSTATE_WANTS_DEACTIVATION = 3;\nconst BODYSTATE_DISABLE_DEACTIVATION = 4;\nconst BODYSTATE_DISABLE_SIMULATION = 5;\nconst BODYGROUP_NONE = 0;\nconst BODYGROUP_DEFAULT = 1;\nconst BODYGROUP_DYNAMIC = 1;\nconst BODYGROUP_STATIC = 2;\nconst BODYGROUP_KINEMATIC = 4;\nconst BODYGROUP_ENGINE_1 = 8;\nconst BODYGROUP_TRIGGER = 16;\nconst BODYGROUP_ENGINE_2 = 32;\nconst BODYGROUP_ENGINE_3 = 64;\nconst BODYGROUP_USER_1 = 128;\nconst BODYGROUP_USER_2 = 256;\nconst BODYGROUP_USER_3 = 512;\nconst BODYGROUP_USER_4 = 1024;\nconst BODYGROUP_USER_5 = 2048;\nconst BODYGROUP_USER_6 = 4096;\nconst BODYGROUP_USER_7 = 8192;\nconst BODYGROUP_USER_8 = 16384;\nconst BODYMASK_NONE = 0;\nconst BODYMASK_ALL = 65535;\nconst BODYMASK_STATIC = 2;\nconst BODYMASK_NOT_STATIC = 65535 ^ 2;\nconst BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);\n\nlet ammoVec1$1, ammoQuat$1, ammoTransform$1;\n\nclass Trigger {\n\tconstructor(app, component, data) {\n\t\tthis.entity = component.entity;\n\t\tthis.component = component;\n\t\tthis.app = app;\n\n\t\tif (typeof Ammo !== 'undefined' && !ammoVec1$1) {\n\t\t\tammoVec1$1 = new Ammo.btVector3();\n\t\t\tammoQuat$1 = new Ammo.btQuaternion();\n\t\t\tammoTransform$1 = new Ammo.btTransform();\n\t\t}\n\n\t\tthis.initialize(data);\n\t}\n\n\tinitialize(data) {\n\t\tconst entity = this.entity;\n\t\tconst shape = data.shape;\n\n\t\tif (shape && typeof Ammo !== 'undefined') {\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t}\n\n\t\t\tconst mass = 1;\n\t\t\tconst pos = entity.getPosition();\n\t\t\tconst rot = entity.getRotation();\n\t\t\tammoVec1$1.setValue(pos.x, pos.y, pos.z);\n\t\t\tammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\t\tammoTransform$1.setOrigin(ammoVec1$1);\n\t\t\tammoTransform$1.setRotation(ammoQuat$1);\n\t\t\tconst body = this.app.systems.rigidbody.createBody(mass, shape, ammoTransform$1);\n\t\t\tbody.setRestitution(0);\n\t\t\tbody.setFriction(0);\n\t\t\tbody.setDamping(0, 0);\n\t\t\tammoVec1$1.setValue(0, 0, 0);\n\t\t\tbody.setLinearFactor(ammoVec1$1);\n\t\t\tbody.setAngularFactor(ammoVec1$1);\n\t\t\tbody.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);\n\t\t\tbody.entity = entity;\n\t\t\tthis.body = body;\n\n\t\t\tif (this.component.enabled && entity.enabled) {\n\t\t\t\tthis.enable();\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tthis.disable();\n\t\tthis.app.systems.rigidbody.destroyBody(body);\n\t}\n\n\t_getEntityTransform(transform) {\n\t\tconst pos = this.entity.getPosition();\n\t\tconst rot = this.entity.getRotation();\n\t\tammoVec1$1.setValue(pos.x, pos.y, pos.z);\n\t\tammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\ttransform.setOrigin(ammoVec1$1);\n\t\ttransform.setRotation(ammoQuat$1);\n\t}\n\n\tupdateTransform() {\n\t\tthis._getEntityTransform(ammoTransform$1);\n\n\t\tconst body = this.body;\n\t\tbody.setWorldTransform(ammoTransform$1);\n\t\tbody.activate();\n\t}\n\n\tenable() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tconst systems = this.app.systems;\n\t\tsystems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);\n\n\t\tsystems.rigidbody._triggers.push(this);\n\n\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\tthis.updateTransform();\n\t}\n\n\tdisable() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tconst systems = this.app.systems;\n\n\t\tconst idx = systems.rigidbody._triggers.indexOf(this);\n\n\t\tif (idx > -1) {\n\t\t\tsystems.rigidbody._triggers.splice(idx, 1);\n\t\t}\n\n\t\tsystems.rigidbody.removeBody(body);\n\t\tbody.forceActivationState(BODYSTATE_DISABLE_SIMULATION);\n\t}\n\n}\n\nconst mat4 = new Mat4();\nconst vec3 = new Vec3();\nconst quat = new Quat();\nconst tempGraphNode = new GraphNode();\nconst _schema$f = ['enabled', 'type', 'halfExtents', 'radius', 'axis', 'height', 'asset', 'renderAsset', 'shape', 'model', 'render'];\n\nclass CollisionSystemImpl {\n\tconstructor(system) {\n\t\tthis.system = system;\n\t}\n\n\tbeforeInitialize(component, data) {\n\t\tdata.shape = null;\n\t\tdata.model = new Model();\n\t\tdata.model.graph = new GraphNode();\n\t}\n\n\tafterInitialize(component, data) {\n\t\tthis.recreatePhysicalShapes(component);\n\t\tcomponent.data.initialized = true;\n\t}\n\n\treset(component, data) {\n\t\tthis.beforeInitialize(component, data);\n\t\tthis.afterInitialize(component, data);\n\t}\n\n\trecreatePhysicalShapes(component) {\n\t\tconst entity = component.entity;\n\t\tconst data = component.data;\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t\tdelete entity.trigger;\n\t\t\t}\n\n\t\t\tif (data.shape) {\n\t\t\t\tif (component._compoundParent) {\n\t\t\t\t\tthis.system._removeCompoundChild(component._compoundParent, data.shape);\n\n\t\t\t\t\tif (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n\t\t\t\t}\n\n\t\t\t\tAmmo.destroy(data.shape);\n\t\t\t\tdata.shape = null;\n\t\t\t}\n\n\t\t\tdata.shape = this.createPhysicalShape(component.entity, data);\n\t\t\tconst firstCompoundChild = !component._compoundParent;\n\n\t\t\tif (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {\n\t\t\t\tcomponent._compoundParent = component;\n\t\t\t\tentity.forEach(this._addEachDescendant, component);\n\t\t\t} else if (data.type !== 'compound') {\n\t\t\t\tif (component._compoundParent && component === component._compoundParent) {\n\t\t\t\t\tentity.forEach(this.system.implementations.compound._updateEachDescendant, component);\n\t\t\t\t}\n\n\t\t\t\tif (!component.rigidbody) {\n\t\t\t\t\tcomponent._compoundParent = null;\n\t\t\t\t\tlet parent = entity.parent;\n\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.collision && parent.collision.type === 'compound') {\n\t\t\t\t\t\t\tcomponent._compoundParent = parent.collision;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (component._compoundParent) {\n\t\t\t\tif (component !== component._compoundParent) {\n\t\t\t\t\tif (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(component._compoundParent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.system.updateCompoundChildTransform(entity);\n\t\t\t\t\t\tif (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (entity.rigidbody) {\n\t\t\t\tentity.rigidbody.disableSimulation();\n\t\t\t\tentity.rigidbody.createBody();\n\n\t\t\t\tif (entity.enabled && entity.rigidbody.enabled) {\n\t\t\t\t\tentity.rigidbody.enableSimulation();\n\t\t\t\t}\n\t\t\t} else if (!component._compoundParent) {\n\t\t\t\tif (!entity.trigger) {\n\t\t\t\t\tentity.trigger = new Trigger(this.system.app, component, data);\n\t\t\t\t} else {\n\t\t\t\t\tentity.trigger.initialize(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcreatePhysicalShape(entity, data) {\n\t\treturn undefined;\n\t}\n\n\tupdateTransform(component, position, rotation, scale) {\n\t\tif (component.entity.trigger) {\n\t\t\tcomponent.entity.trigger.updateTransform();\n\t\t}\n\t}\n\n\tbeforeRemove(entity, component) {\n\t\tif (component.data.shape) {\n\t\t\tif (component._compoundParent && !component._compoundParent.entity._destroying) {\n\t\t\t\tthis.system._removeCompoundChild(component._compoundParent, component.data.shape);\n\n\t\t\t\tif (component._compoundParent.entity.rigidbody) component._compoundParent.entity.rigidbody.activate();\n\t\t\t}\n\n\t\t\tcomponent._compoundParent = null;\n\t\t\tAmmo.destroy(component.data.shape);\n\t\t\tcomponent.data.shape = null;\n\t\t}\n\t}\n\n\tremove(entity, data) {\n\t\tconst app = this.system.app;\n\n\t\tif (entity.rigidbody && entity.rigidbody.body) {\n\t\t\tentity.rigidbody.disableSimulation();\n\t\t}\n\n\t\tif (entity.trigger) {\n\t\t\tentity.trigger.destroy();\n\t\t\tdelete entity.trigger;\n\t\t}\n\n\t\tif (app.scene.containsModel(data.model)) {\n\t\t\tapp.root.removeChild(data.model.graph);\n\t\t\tapp.scene.removeModel(data.model);\n\t\t}\n\t}\n\n\tclone(entity, clone) {\n\t\tconst src = this.system.store[entity.getGuid()];\n\t\tconst data = {\n\t\t\tenabled: src.data.enabled,\n\t\t\ttype: src.data.type,\n\t\t\thalfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],\n\t\t\tradius: src.data.radius,\n\t\t\taxis: src.data.axis,\n\t\t\theight: src.data.height,\n\t\t\tasset: src.data.asset,\n\t\t\trenderAsset: src.data.renderAsset,\n\t\t\tmodel: src.data.model,\n\t\t\trender: src.data.render\n\t\t};\n\t\treturn this.system.addComponent(clone, data);\n\t}\n\n}\n\nclass CollisionBoxSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tconst he = data.halfExtents;\n\t\t\tconst ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);\n\t\t\tconst shape = new Ammo.btBoxShape(ammoHe);\n\t\t\tAmmo.destroy(ammoHe);\n\t\t\treturn shape;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n}\n\nclass CollisionSphereSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\treturn new Ammo.btSphereShape(data.radius);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n}\n\nclass CollisionCapsuleSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tconst axis = data.axis !== undefined ? data.axis : 1;\n\t\tconst radius = data.radius || 0.5;\n\t\tconst height = Math.max((data.height || 2) - 2 * radius, 0);\n\t\tlet shape = null;\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\tshape = new Ammo.btCapsuleShapeX(radius, height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tshape = new Ammo.btCapsuleShape(radius, height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tshape = new Ammo.btCapsuleShapeZ(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn shape;\n\t}\n\n}\n\nclass CollisionCylinderSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tconst axis = data.axis !== undefined ? data.axis : 1;\n\t\tconst radius = data.radius !== undefined ? data.radius : 0.5;\n\t\tconst height = data.height !== undefined ? data.height : 1;\n\t\tlet halfExtents = null;\n\t\tlet shape = null;\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(height * 0.5, radius, radius);\n\t\t\t\t\tshape = new Ammo.btCylinderShapeX(halfExtents);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(radius, height * 0.5, radius);\n\t\t\t\t\tshape = new Ammo.btCylinderShape(halfExtents);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(radius, radius, height * 0.5);\n\t\t\t\t\tshape = new Ammo.btCylinderShapeZ(halfExtents);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (halfExtents) Ammo.destroy(halfExtents);\n\t\treturn shape;\n\t}\n\n}\n\nclass CollisionConeSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tconst axis = data.axis !== undefined ? data.axis : 1;\n\t\tconst radius = data.radius !== undefined ? data.radius : 0.5;\n\t\tconst height = data.height !== undefined ? data.height : 1;\n\t\tlet shape = null;\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\tshape = new Ammo.btConeShapeX(radius, height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tshape = new Ammo.btConeShape(radius, height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tshape = new Ammo.btConeShapeZ(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn shape;\n\t}\n\n}\n\nclass CollisionMeshSystemImpl extends CollisionSystemImpl {\n\tbeforeInitialize(component, data) {}\n\n\tcreateAmmoMesh(mesh, node, shape) {\n\t\tlet triMesh;\n\n\t\tif (this.system._triMeshCache[mesh.id]) {\n\t\t\ttriMesh = this.system._triMeshCache[mesh.id];\n\t\t} else {\n\t\t\tconst vb = mesh.vertexBuffer;\n\t\t\tconst format = vb.getFormat();\n\t\t\tlet stride;\n\t\t\tlet positions;\n\n\t\t\tfor (let i = 0; i < format.elements.length; i++) {\n\t\t\t\tconst element = format.elements[i];\n\n\t\t\t\tif (element.name === SEMANTIC_POSITION) {\n\t\t\t\t\tpositions = new Float32Array(vb.lock(), element.offset);\n\t\t\t\t\tstride = element.stride / 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst indices = [];\n\t\t\tmesh.getIndices(indices);\n\t\t\tconst numTriangles = mesh.primitive[0].count / 3;\n\t\t\tconst v1 = new Ammo.btVector3();\n\t\t\tconst v2 = new Ammo.btVector3();\n\t\t\tconst v3 = new Ammo.btVector3();\n\t\t\tlet i1, i2, i3;\n\t\t\tconst base = mesh.primitive[0].base;\n\t\t\ttriMesh = new Ammo.btTriangleMesh();\n\t\t\tthis.system._triMeshCache[mesh.id] = triMesh;\n\n\t\t\tfor (let i = 0; i < numTriangles; i++) {\n\t\t\t\ti1 = indices[base + i * 3] * stride;\n\t\t\t\ti2 = indices[base + i * 3 + 1] * stride;\n\t\t\t\ti3 = indices[base + i * 3 + 2] * stride;\n\t\t\t\tv1.setValue(positions[i1], positions[i1 + 1], positions[i1 + 2]);\n\t\t\t\tv2.setValue(positions[i2], positions[i2 + 1], positions[i2 + 2]);\n\t\t\t\tv3.setValue(positions[i3], positions[i3 + 1], positions[i3 + 2]);\n\t\t\t\ttriMesh.addTriangle(v1, v2, v3, true);\n\t\t\t}\n\n\t\t\tAmmo.destroy(v1);\n\t\t\tAmmo.destroy(v2);\n\t\t\tAmmo.destroy(v3);\n\t\t}\n\n\t\tconst useQuantizedAabbCompression = true;\n\t\tconst triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, useQuantizedAabbCompression);\n\n\t\tconst scaling = this.system._getNodeScaling(node);\n\n\t\ttriMeshShape.setLocalScaling(scaling);\n\t\tAmmo.destroy(scaling);\n\n\t\tconst transform = this.system._getNodeTransform(node);\n\n\t\tshape.addChildShape(transform, triMeshShape);\n\t\tAmmo.destroy(transform);\n\t}\n\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo === 'undefined') return;\n\n\t\tif (data.model || data.render) {\n\t\t\tconst shape = new Ammo.btCompoundShape();\n\n\t\t\tif (data.model) {\n\t\t\t\tconst meshInstances = data.model.meshInstances;\n\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tthis.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape);\n\t\t\t\t}\n\t\t\t} else if (data.render) {\n\t\t\t\tconst meshes = data.render.meshes;\n\n\t\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\t\tthis.createAmmoMesh(meshes[i], tempGraphNode, shape);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst entityTransform = entity.getWorldTransform();\n\t\t\tconst scale = entityTransform.getScale();\n\t\t\tconst vec = new Ammo.btVector3(scale.x, scale.y, scale.z);\n\t\t\tshape.setLocalScaling(vec);\n\t\t\tAmmo.destroy(vec);\n\t\t\treturn shape;\n\t\t}\n\t}\n\n\trecreatePhysicalShapes(component) {\n\t\tconst data = component.data;\n\n\t\tif (data.renderAsset || data.asset) {\n\t\t\tif (component.enabled && component.entity.enabled) {\n\t\t\t\tthis.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tthis.doRecreatePhysicalShape(component);\n\t}\n\n\tloadAsset(component, id, property) {\n\t\tconst data = component.data;\n\t\tconst assets = this.system.app.assets;\n\t\tconst asset = assets.get(id);\n\n\t\tif (asset) {\n\t\t\tasset.ready(asset => {\n\t\t\t\tdata[property] = asset.resource;\n\t\t\t\tthis.doRecreatePhysicalShape(component);\n\t\t\t});\n\t\t\tassets.load(asset);\n\t\t} else {\n\t\t\tassets.once(\"add:\" + id, asset => {\n\t\t\t\tasset.ready(asset => {\n\t\t\t\t\tdata[property] = asset.resource;\n\t\t\t\t\tthis.doRecreatePhysicalShape(component);\n\t\t\t\t});\n\t\t\t\tassets.load(asset);\n\t\t\t});\n\t\t}\n\t}\n\n\tdoRecreatePhysicalShape(component) {\n\t\tconst entity = component.entity;\n\t\tconst data = component.data;\n\n\t\tif (data.model || data.render) {\n\t\t\tthis.destroyShape(data);\n\t\t\tdata.shape = this.createPhysicalShape(entity, data);\n\n\t\t\tif (entity.rigidbody) {\n\t\t\t\tentity.rigidbody.disableSimulation();\n\t\t\t\tentity.rigidbody.createBody();\n\n\t\t\t\tif (entity.enabled && entity.rigidbody.enabled) {\n\t\t\t\t\tentity.rigidbody.enableSimulation();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!entity.trigger) {\n\t\t\t\t\tentity.trigger = new Trigger(this.system.app, component, data);\n\t\t\t\t} else {\n\t\t\t\t\tentity.trigger.initialize(data);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.beforeRemove(entity, component);\n\t\t\tthis.remove(entity, data);\n\t\t}\n\t}\n\n\tupdateTransform(component, position, rotation, scale) {\n\t\tif (component.shape) {\n\t\t\tconst entityTransform = component.entity.getWorldTransform();\n\t\t\tconst worldScale = entityTransform.getScale();\n\t\t\tconst previousScale = component.shape.getLocalScaling();\n\n\t\t\tif (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {\n\t\t\t\tthis.doRecreatePhysicalShape(component);\n\t\t\t}\n\t\t}\n\n\t\tsuper.updateTransform(component, position, rotation, scale);\n\t}\n\n\tdestroyShape(data) {\n\t\tif (!data.shape) return;\n\t\tconst numShapes = data.shape.getNumChildShapes();\n\n\t\tfor (let i = 0; i < numShapes; i++) {\n\t\t\tconst shape = data.shape.getChildShape(i);\n\t\t\tAmmo.destroy(shape);\n\t\t}\n\n\t\tAmmo.destroy(data.shape);\n\t\tdata.shape = null;\n\t}\n\n\tremove(entity, data) {\n\t\tthis.destroyShape(data);\n\t\tsuper.remove(entity, data);\n\t}\n\n}\n\nclass CollisionCompoundSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\treturn new Ammo.btCompoundShape();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t_addEachDescendant(entity) {\n\t\tif (!entity.collision || entity.rigidbody) return;\n\t\tentity.collision._compoundParent = this;\n\n\t\tif (entity !== this.entity) {\n\t\t\tentity.collision.system.recreatePhysicalShapes(entity.collision);\n\t\t}\n\t}\n\n\t_updateEachDescendant(entity) {\n\t\tif (!entity.collision) return;\n\t\tif (entity.collision._compoundParent !== this) return;\n\t\tentity.collision._compoundParent = null;\n\n\t\tif (entity !== this.entity && !entity.rigidbody) {\n\t\t\tentity.collision.system.recreatePhysicalShapes(entity.collision);\n\t\t}\n\t}\n\n\t_updateEachDescendantTransform(entity) {\n\t\tif (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) return;\n\t\tthis.collision.system.updateCompoundChildTransform(entity);\n\t}\n\n}\n\nclass CollisionComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = \"collision\";\n\t\tthis.ComponentType = CollisionComponent;\n\t\tthis.DataType = CollisionComponentData;\n\t\tthis.schema = _schema$f;\n\t\tthis.implementations = {};\n\t\tthis._triMeshCache = {};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.on('remove', this.onRemove, this);\n\t}\n\n\tinitializeComponentData(component, _data, properties) {\n\t\tproperties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled'];\n\t\tconst data = {};\n\n\t\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\t\tconst property = properties[i];\n\t\t\tdata[property] = _data[property];\n\t\t}\n\n\t\tlet idx;\n\n\t\tif (_data.hasOwnProperty('asset')) {\n\t\t\tidx = properties.indexOf('model');\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\n\t\t\tidx = properties.indexOf('render');\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\t\t} else if (_data.hasOwnProperty('model')) {\n\t\t\tidx = properties.indexOf('asset');\n\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!data.type) {\n\t\t\tdata.type = component.data.type;\n\t\t}\n\n\t\tcomponent.data.type = data.type;\n\n\t\tif (data.halfExtents && Array.isArray(data.halfExtents)) {\n\t\t\tdata.halfExtents = new Vec3(data.halfExtents[0], data.halfExtents[1], data.halfExtents[2]);\n\t\t}\n\n\t\tconst impl = this._createImplementation(data.type);\n\n\t\timpl.beforeInitialize(component, data);\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\timpl.afterInitialize(component, data);\n\t}\n\n\t_createImplementation(type) {\n\t\tif (this.implementations[type] === undefined) {\n\t\t\tlet impl;\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'box':\n\t\t\t\t\timpl = new CollisionBoxSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'sphere':\n\t\t\t\t\timpl = new CollisionSphereSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'capsule':\n\t\t\t\t\timpl = new CollisionCapsuleSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'cylinder':\n\t\t\t\t\timpl = new CollisionCylinderSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'cone':\n\t\t\t\t\timpl = new CollisionConeSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\timpl = new CollisionMeshSystemImpl(this);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'compound':\n\t\t\t\t\timpl = new CollisionCompoundSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.implementations[type] = impl;\n\t\t}\n\n\t\treturn this.implementations[type];\n\t}\n\n\t_getImplementation(entity) {\n\t\treturn this.implementations[entity.collision.data.type];\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\treturn this._getImplementation(entity).clone(entity, clone);\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tthis.implementations[component.data.type].beforeRemove(entity, component);\n\t\tcomponent.onBeforeRemove();\n\t}\n\n\tonRemove(entity, data) {\n\t\tthis.implementations[data.type].remove(entity, data);\n\t}\n\n\tupdateCompoundChildTransform(entity) {\n\t\tthis._removeCompoundChild(entity.collision._compoundParent, entity.collision.data.shape);\n\n\t\tif (entity.enabled && entity.collision.enabled) {\n\t\t\tconst transform = this._getNodeTransform(entity, entity.collision._compoundParent.entity);\n\n\t\t\tentity.collision._compoundParent.shape.addChildShape(transform, entity.collision.data.shape);\n\n\t\t\tAmmo.destroy(transform);\n\t\t}\n\t}\n\n\t_removeCompoundChild(collision, shape) {\n\t\tif (collision.shape.removeChildShape) {\n\t\t\tcollision.shape.removeChildShape(shape);\n\t\t} else {\n\t\t\tconst ind = collision._getCompoundChildShapeIndex(shape);\n\n\t\t\tif (ind !== null) {\n\t\t\t\tcollision.shape.removeChildShapeByIndex(ind);\n\t\t\t}\n\t\t}\n\t}\n\n\tonTransformChanged(component, position, rotation, scale) {\n\t\tthis.implementations[component.data.type].updateTransform(component, position, rotation, scale);\n\t}\n\n\tchangeType(component, previousType, newType) {\n\t\tthis.implementations[previousType].beforeRemove(component.entity, component);\n\t\tthis.implementations[previousType].remove(component.entity, component.data);\n\n\t\tthis._createImplementation(newType).reset(component, component.data);\n\t}\n\n\trecreatePhysicalShapes(component) {\n\t\tthis.implementations[component.data.type].recreatePhysicalShapes(component);\n\t}\n\n\t_calculateNodeRelativeTransform(node, relative) {\n\t\tif (node === relative) {\n\t\t\tconst scale = node.getWorldTransform().getScale();\n\t\t\tmat4.setScale(scale.x, scale.y, scale.z);\n\t\t} else {\n\t\t\tthis._calculateNodeRelativeTransform(node.parent, relative);\n\n\t\t\tmat4.mul(node.getLocalTransform());\n\t\t}\n\t}\n\n\t_getNodeScaling(node) {\n\t\tconst wtm = node.getWorldTransform();\n\t\tconst scl = wtm.getScale();\n\t\treturn new Ammo.btVector3(scl.x, scl.y, scl.z);\n\t}\n\n\t_getNodeTransform(node, relative) {\n\t\tlet pos, rot;\n\n\t\tif (relative) {\n\t\t\tthis._calculateNodeRelativeTransform(node, relative);\n\n\t\t\tpos = vec3;\n\t\t\trot = quat;\n\t\t\tmat4.getTranslation(pos);\n\t\t\trot.setFromMat4(mat4);\n\t\t} else {\n\t\t\tpos = node.getPosition();\n\t\t\trot = node.getRotation();\n\t\t}\n\n\t\tconst transform = new Ammo.btTransform();\n\t\ttransform.setIdentity();\n\t\tconst origin = transform.getOrigin();\n\t\torigin.setValue(pos.x, pos.y, pos.z);\n\t\tconst ammoQuat = new Ammo.btQuaternion();\n\t\tammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\ttransform.setRotation(ammoQuat);\n\t\tAmmo.destroy(ammoQuat);\n\t\tAmmo.destroy(origin);\n\t\treturn transform;\n\t}\n\n\tdestroy() {\n\t\tfor (const key in this._triMeshCache) {\n\t\t\tAmmo.destroy(this._triMeshCache[key]);\n\t\t}\n\n\t\tthis._triMeshCache = null;\n\t\tsuper.destroy();\n\t}\n\n}\n\nComponent._buildAccessors(CollisionComponent.prototype, _schema$f);\n\nclass ComponentSystemRegistry extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.anim = void 0;\n\t\tthis.animation = void 0;\n\t\tthis.audiolistener = void 0;\n\t\tthis.audiosource = void 0;\n\t\tthis.button = void 0;\n\t\tthis.camera = void 0;\n\t\tthis.collision = void 0;\n\t\tthis.element = void 0;\n\t\tthis.joint = void 0;\n\t\tthis.layoutchild = void 0;\n\t\tthis.layoutgroup = void 0;\n\t\tthis.light = void 0;\n\t\tthis.model = void 0;\n\t\tthis.particlesystem = void 0;\n\t\tthis.render = void 0;\n\t\tthis.rigidbody = void 0;\n\t\tthis.screen = void 0;\n\t\tthis.script = void 0;\n\t\tthis.scrollbar = void 0;\n\t\tthis.scrollview = void 0;\n\t\tthis.sound = void 0;\n\t\tthis.sprite = void 0;\n\t\tthis.zone = void 0;\n\t\tthis.list = [];\n\t}\n\n\tadd(system) {\n\t\tconst id = system.id;\n\n\t\tif (this[id]) {\n\t\t\tthrow new Error(`ComponentSystem name '${id}' already registered or not allowed`);\n\t\t}\n\n\t\tthis[id] = system;\n\t\tthis.list.push(system);\n\t}\n\n\tremove(system) {\n\t\tconst id = system.id;\n\n\t\tif (!this[id]) {\n\t\t\tthrow new Error(`No ComponentSystem named '${id}' registered`);\n\t\t}\n\n\t\tdelete this[id];\n\t\tconst index = this.list.indexOf(this[id]);\n\n\t\tif (index !== -1) {\n\t\t\tthis.list.splice(index, 1);\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis.off();\n\n\t\tfor (let i = 0; i < this.list.length; i++) {\n\t\t\tthis.list[i].destroy();\n\t\t}\n\t}\n\n}\n\nclass StencilParameters {\n\tconstructor(options) {\n\t\tthis.func = options.func === undefined ? FUNC_ALWAYS : options.func;\n\t\tthis.ref = options.ref || 0;\n\t\tthis.readMask = options.readMask === undefined ? 0xFF : options.readMask;\n\t\tthis.writeMask = options.writeMask === undefined ? 0xFF : options.writeMask;\n\t\tthis.fail = options.fail || STENCILOP_KEEP;\n\t\tthis.zfail = options.zfail || STENCILOP_KEEP;\n\t\tthis.zpass = options.zpass || STENCILOP_KEEP;\n\t}\n\n\tclone() {\n\t\treturn new StencilParameters({\n\t\t\tfunc: this.func,\n\t\t\tref: this.ref,\n\t\t\treadMask: this.readMask,\n\t\t\twriteMask: this.writeMask,\n\t\t\tfail: this.fail,\n\t\t\tzfail: this.zfail,\n\t\t\tzpass: this.zpass\n\t\t});\n\t}\n\n}\n\nclass ImageRenderable {\n\tconstructor(entity, mesh, material) {\n\t\tthis._entity = entity;\n\t\tthis._element = entity.element;\n\t\tthis.model = new Model();\n\t\tthis.node = new GraphNode();\n\t\tthis.model.graph = this.node;\n\t\tthis.mesh = mesh;\n\t\tthis.meshInstance = new MeshInstance(this.mesh, material, this.node);\n\t\tthis.meshInstance.name = 'ImageElement: ' + entity.name;\n\t\tthis.meshInstance.castShadow = false;\n\t\tthis.meshInstance.receiveShadow = false;\n\t\tthis._meshDirty = false;\n\t\tthis.model.meshInstances.push(this.meshInstance);\n\n\t\tthis._entity.addChild(this.model.graph);\n\n\t\tthis.model._entity = this._entity;\n\t\tthis.unmaskMeshInstance = null;\n\t}\n\n\tdestroy() {\n\t\tthis.setMaterial(null);\n\n\t\tthis._element.removeModelFromLayers(this.model);\n\n\t\tthis.model.destroy();\n\t\tthis.model = null;\n\t\tthis.node = null;\n\t\tthis.mesh = null;\n\t\tthis.meshInstance = null;\n\t\tthis._entity = null;\n\t\tthis._element = null;\n\t}\n\n\tsetMesh(mesh) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.mesh = mesh;\n\t\tthis.meshInstance.mesh = mesh;\n\t\tthis.meshInstance.visible = !!mesh;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.mesh = mesh;\n\t\t}\n\n\t\tthis.forceUpdateAabb();\n\t}\n\n\tsetMask(mask) {\n\t\tif (!this.meshInstance) return;\n\n\t\tif (mask) {\n\t\t\tthis.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);\n\t\t\tthis.unmaskMeshInstance.name = 'Unmask: ' + this._entity.name;\n\t\t\tthis.unmaskMeshInstance.castShadow = false;\n\t\t\tthis.unmaskMeshInstance.receiveShadow = false;\n\t\t\tthis.unmaskMeshInstance.pick = false;\n\t\t\tthis.model.meshInstances.push(this.unmaskMeshInstance);\n\n\t\t\tfor (const name in this.meshInstance.parameters) {\n\t\t\t\tthis.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);\n\t\t\t}\n\t\t} else {\n\t\t\tconst idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);\n\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis.model.meshInstances.splice(idx, 1);\n\t\t\t}\n\n\t\t\tthis.unmaskMeshInstance = null;\n\t\t}\n\n\t\tif (this._entity.enabled && this._element.enabled) {\n\t\t\tthis._element.removeModelFromLayers(this.model);\n\n\t\t\tthis._element.addModelToLayers(this.model);\n\t\t}\n\t}\n\n\tsetMaterial(material) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.material = material;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.material = material;\n\t\t}\n\t}\n\n\tsetParameter(name, value) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.setParameter(name, value);\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.setParameter(name, value);\n\t\t}\n\t}\n\n\tdeleteParameter(name) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.deleteParameter(name);\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.deleteParameter(name);\n\t\t}\n\t}\n\n\tsetUnmaskDrawOrder() {\n\t\tif (!this.meshInstance) return;\n\n\t\tconst getLastChild = function getLastChild(e) {\n\t\t\tlet last;\n\t\t\tconst c = e.children;\n\t\t\tconst l = c.length;\n\n\t\t\tif (l) {\n\t\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\t\tif (c[i].element) {\n\t\t\t\t\t\tlast = c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!last) return null;\n\t\t\t\tconst child = getLastChild(last);\n\n\t\t\t\tif (child) {\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\n\t\t\t\treturn last;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tconst lastChild = getLastChild(this._entity);\n\n\t\t\tif (lastChild && lastChild.element) {\n\t\t\t\tthis.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();\n\t\t\t} else {\n\t\t\t\tthis.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();\n\t\t\t}\n\t\t}\n\t}\n\n\tsetDrawOrder(drawOrder) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.drawOrder = drawOrder;\n\t}\n\n\tsetCull(cull) {\n\t\tif (!this.meshInstance) return;\n\t\tconst element = this._element;\n\t\tlet visibleFn = null;\n\n\t\tif (cull && element._isScreenCulled()) {\n\t\t\tvisibleFn = function (camera) {\n\t\t\t\treturn element.isVisibleForCamera(camera);\n\t\t\t};\n\t\t}\n\n\t\tthis.meshInstance.cull = cull;\n\t\tthis.meshInstance.isVisibleFunc = visibleFn;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.cull = cull;\n\t\t\tthis.unmaskMeshInstance.isVisibleFunc = visibleFn;\n\t\t}\n\t}\n\n\tsetScreenSpace(screenSpace) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.screenSpace = screenSpace;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.screenSpace = screenSpace;\n\t\t}\n\t}\n\n\tsetLayer(layer) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.layer = layer;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.layer = layer;\n\t\t}\n\t}\n\n\tforceUpdateAabb(mask) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance._aabbVer = -1;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance._aabbVer = -1;\n\t\t}\n\t}\n\n\tsetAabbFunc(fn) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance._updateAabbFunc = fn;\n\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance._updateAabbFunc = fn;\n\t\t}\n\t}\n\n}\n\nclass ImageElement {\n\tconstructor(element) {\n\t\tthis._element = element;\n\t\tthis._entity = element.entity;\n\t\tthis._system = element.system;\n\t\tthis._textureAsset = null;\n\t\tthis._texture = null;\n\t\tthis._materialAsset = null;\n\t\tthis._material = null;\n\t\tthis._spriteAsset = null;\n\t\tthis._sprite = null;\n\t\tthis._spriteFrame = 0;\n\t\tthis._pixelsPerUnit = null;\n\t\tthis._rect = new Vec4(0, 0, 1, 1);\n\t\tthis._mask = false;\n\t\tthis._maskRef = 0;\n\t\tthis._outerScale = new Vec2();\n\t\tthis._outerScaleUniform = new Float32Array(2);\n\t\tthis._innerOffset = new Vec4();\n\t\tthis._innerOffsetUniform = new Float32Array(4);\n\t\tthis._atlasRect = new Vec4();\n\t\tthis._atlasRectUniform = new Float32Array(4);\n\t\tthis._defaultMesh = this._createMesh();\n\t\tthis._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array([1, 1, 1]);\n\n\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\n\t\tthis._renderable.setParameter('material_opacity', 1);\n\n\t\tthis._updateAabbFunc = this._updateAabb.bind(this);\n\n\t\tthis._onScreenChange(this._element.screen);\n\n\t\tthis._element.on('resize', this._onParentResizeOrPivotChange, this);\n\n\t\tthis._element.on('set:pivot', this._onParentResizeOrPivotChange, this);\n\n\t\tthis._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);\n\n\t\tthis._element.on('set:screen', this._onScreenChange, this);\n\n\t\tthis._element.on('set:draworder', this._onDrawOrderChange, this);\n\n\t\tthis._element.on('screen:set:resolution', this._onResolutionChange, this);\n\t}\n\n\tdestroy() {\n\t\tthis.textureAsset = null;\n\t\tthis.spriteAsset = null;\n\t\tthis.materialAsset = null;\n\n\t\tthis._renderable.setMesh(this._defaultMesh);\n\n\t\tthis._renderable.destroy();\n\n\t\tthis._defaultMesh = null;\n\n\t\tthis._element.off('resize', this._onParentResizeOrPivotChange, this);\n\n\t\tthis._element.off('set:pivot', this._onParentResizeOrPivotChange, this);\n\n\t\tthis._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);\n\n\t\tthis._element.off('set:screen', this._onScreenChange, this);\n\n\t\tthis._element.off('set:draworder', this._onDrawOrderChange, this);\n\n\t\tthis._element.off('screen:set:resolution', this._onResolutionChange, this);\n\t}\n\n\t_onResolutionChange(res) {}\n\n\t_onParentResizeOrPivotChange() {\n\t\tif (this._renderable.mesh) {\n\t\t\tthis._updateMesh(this._renderable.mesh);\n\t\t}\n\t}\n\n\t_onScreenSpaceChange(value) {\n\t\tthis._updateMaterial(value);\n\t}\n\n\t_onScreenChange(screen, previous) {\n\t\tif (screen) {\n\t\t\tthis._updateMaterial(screen.screen.screenSpace);\n\t\t} else {\n\t\t\tthis._updateMaterial(false);\n\t\t}\n\t}\n\n\t_onDrawOrderChange(order) {\n\t\tthis._renderable.setDrawOrder(order);\n\n\t\tif (this.mask && this._element.screen) {\n\t\t\tthis._element.screen.screen.once('syncdraworder', function () {\n\t\t\t\tthis._renderable.setUnmaskDrawOrder();\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t_hasUserMaterial() {\n\t\treturn !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;\n\t}\n\n\t_use9Slicing() {\n\t\treturn this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);\n\t}\n\n\t_updateMaterial(screenSpace) {\n\t\tconst mask = !!this._mask;\n\t\tconst nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);\n\t\tconst nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);\n\n\t\tif (!this._hasUserMaterial()) {\n\t\t\tthis._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);\n\t\t}\n\n\t\tif (this._renderable) {\n\t\t\tthis._renderable.setCull(true);\n\n\t\t\tthis._renderable.setMaterial(this._material);\n\n\t\t\tthis._renderable.setScreenSpace(screenSpace);\n\n\t\t\tthis._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);\n\t\t}\n\t}\n\n\t_createMesh() {\n\t\tconst element = this._element;\n\t\tconst w = element.calculatedWidth;\n\t\tconst h = element.calculatedHeight;\n\t\tconst r = this._rect;\n\t\tconst vertexData = new ArrayBuffer(4 * 8 * 4);\n\t\tconst vertexDataF32 = new Float32Array(vertexData);\n\t\tvertexDataF32[5] = 1;\n\t\tvertexDataF32[6] = r.x;\n\t\tvertexDataF32[7] = 1.0 - r.y;\n\t\tvertexDataF32[8] = w;\n\t\tvertexDataF32[13] = 1;\n\t\tvertexDataF32[14] = r.x + r.z;\n\t\tvertexDataF32[15] = 1.0 - r.y;\n\t\tvertexDataF32[16] = w;\n\t\tvertexDataF32[17] = h;\n\t\tvertexDataF32[21] = 1;\n\t\tvertexDataF32[22] = r.x + r.z;\n\t\tvertexDataF32[23] = 1.0 - (r.y + r.w);\n\t\tvertexDataF32[25] = h;\n\t\tvertexDataF32[29] = 1;\n\t\tvertexDataF32[30] = r.x;\n\t\tvertexDataF32[31] = 1.0 - (r.y + r.w);\n\t\tconst vertexDesc = [{\n\t\t\tsemantic: SEMANTIC_POSITION,\n\t\t\tcomponents: 3,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_NORMAL,\n\t\t\tcomponents: 3,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}, {\n\t\t\tsemantic: SEMANTIC_TEXCOORD0,\n\t\t\tcomponents: 2,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}];\n\t\tconst device = this._system.app.graphicsDevice;\n\t\tconst vertexFormat = new VertexFormat(device, vertexDesc);\n\t\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, 4, BUFFER_STATIC, vertexData);\n\t\tconst mesh = new Mesh(device);\n\t\tmesh.vertexBuffer = vertexBuffer;\n\t\tmesh.primitive[0].type = PRIMITIVE_TRIFAN;\n\t\tmesh.primitive[0].base = 0;\n\t\tmesh.primitive[0].count = 4;\n\t\tmesh.primitive[0].indexed = false;\n\t\tmesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));\n\n\t\tthis._updateMesh(mesh);\n\n\t\treturn mesh;\n\t}\n\n\t_updateMesh(mesh) {\n\t\tconst element = this._element;\n\t\tconst w = element.calculatedWidth;\n\t\tconst h = element.calculatedHeight;\n\n\t\tconst screenSpace = element._isScreenSpace();\n\n\t\tthis._updateMaterial(screenSpace);\n\n\t\tif (this._renderable) this._renderable.forceUpdateAabb();\n\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tconst frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n\t\t\tconst borderWidthScale = 2 / frameData.rect.z;\n\t\t\tconst borderHeightScale = 2 / frameData.rect.w;\n\n\t\t\tthis._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);\n\n\t\t\tconst tex = this.sprite.atlas.texture;\n\n\t\t\tthis._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);\n\n\t\t\tconst ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;\n\t\t\tconst scaleMulX = frameData.rect.z / ppu;\n\t\t\tconst scaleMulY = frameData.rect.w / ppu;\n\n\t\t\tthis._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));\n\n\t\t\tlet scaleX = scaleMulX;\n\t\t\tlet scaleY = scaleMulY;\n\t\t\tthis._outerScale.x /= scaleMulX;\n\t\t\tthis._outerScale.y /= scaleMulY;\n\t\t\tscaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);\n\t\t\tscaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);\n\n\t\t\tif (this._renderable) {\n\t\t\t\tthis._innerOffsetUniform[0] = this._innerOffset.x;\n\t\t\t\tthis._innerOffsetUniform[1] = this._innerOffset.y;\n\t\t\t\tthis._innerOffsetUniform[2] = this._innerOffset.z;\n\t\t\t\tthis._innerOffsetUniform[3] = this._innerOffset.w;\n\n\t\t\t\tthis._renderable.setParameter('innerOffset', this._innerOffsetUniform);\n\n\t\t\t\tthis._atlasRectUniform[0] = this._atlasRect.x;\n\t\t\t\tthis._atlasRectUniform[1] = this._atlasRect.y;\n\t\t\t\tthis._atlasRectUniform[2] = this._atlasRect.z;\n\t\t\t\tthis._atlasRectUniform[3] = this._atlasRect.w;\n\n\t\t\t\tthis._renderable.setParameter('atlasRect', this._atlasRectUniform);\n\n\t\t\t\tthis._outerScaleUniform[0] = this._outerScale.x;\n\t\t\t\tthis._outerScaleUniform[1] = this._outerScale.y;\n\n\t\t\t\tthis._renderable.setParameter('outerScale', this._outerScaleUniform);\n\n\t\t\t\tthis._renderable.setAabbFunc(this._updateAabbFunc);\n\n\t\t\t\tthis._renderable.node.setLocalScale(scaleX, scaleY, 1);\n\n\t\t\t\tthis._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tconst vb = mesh.vertexBuffer;\n\t\t\tconst vertexDataF32 = new Float32Array(vb.lock());\n\t\t\tconst hp = element.pivot.x;\n\t\t\tconst vp = element.pivot.y;\n\t\t\tvertexDataF32[0] = 0 - hp * w;\n\t\t\tvertexDataF32[1] = 0 - vp * h;\n\t\t\tvertexDataF32[8] = w - hp * w;\n\t\t\tvertexDataF32[9] = 0 - vp * h;\n\t\t\tvertexDataF32[16] = w - hp * w;\n\t\t\tvertexDataF32[17] = h - vp * h;\n\t\t\tvertexDataF32[24] = 0 - hp * w;\n\t\t\tvertexDataF32[25] = h - vp * h;\n\t\t\tlet atlasTextureWidth = 1;\n\t\t\tlet atlasTextureHeight = 1;\n\t\t\tlet rect = this._rect;\n\n\t\t\tif (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {\n\t\t\t\tconst frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n\n\t\t\t\tif (frame) {\n\t\t\t\t\trect = frame.rect;\n\t\t\t\t\tatlasTextureWidth = this._sprite.atlas.texture.width;\n\t\t\t\t\tatlasTextureHeight = this._sprite.atlas.texture.height;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvertexDataF32[6] = rect.x / atlasTextureWidth;\n\t\t\tvertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;\n\t\t\tvertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;\n\t\t\tvertexDataF32[15] = 1.0 - rect.y / atlasTextureHeight;\n\t\t\tvertexDataF32[22] = (rect.x + rect.z) / atlasTextureWidth;\n\t\t\tvertexDataF32[23] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;\n\t\t\tvertexDataF32[30] = rect.x / atlasTextureWidth;\n\t\t\tvertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;\n\t\t\tvb.unlock();\n\t\t\tconst min = new Vec3(0 - hp * w, 0 - vp * h, 0);\n\t\t\tconst max = new Vec3(w - hp * w, h - vp * h, 0);\n\t\t\tmesh.aabb.setMinMax(min, max);\n\n\t\t\tif (this._renderable) {\n\t\t\t\tthis._renderable.node.setLocalScale(1, 1, 1);\n\n\t\t\t\tthis._renderable.node.setLocalPosition(0, 0, 0);\n\n\t\t\t\tthis._renderable.setAabbFunc(null);\n\t\t\t}\n\t\t}\n\n\t\tthis._meshDirty = false;\n\t}\n\n\t_updateSprite() {\n\t\tlet nineSlice = false;\n\t\tlet mesh = null;\n\n\t\tif (this._sprite && this._sprite.atlas) {\n\t\t\tmesh = this._sprite.meshes[this.spriteFrame];\n\t\t\tnineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;\n\t\t}\n\n\t\tthis.mesh = nineSlice ? mesh : this._defaultMesh;\n\n\t\tif (this.mesh) {\n\t\t\tif (!this._element._beingInitialized) {\n\t\t\t\tthis._updateMesh(this.mesh);\n\t\t\t} else {\n\t\t\t\tthis._meshDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateAabb(aabb) {\n\t\taabb.center.set(0, 0, 0);\n\t\taabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);\n\t\taabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());\n\t\treturn aabb;\n\t}\n\n\t_toggleMask() {\n\t\tthis._element._dirtifyMask();\n\n\t\tconst screenSpace = this._element._isScreenSpace();\n\n\t\tthis._updateMaterial(screenSpace);\n\n\t\tthis._renderable.setMask(!!this._mask);\n\t}\n\n\t_onMaterialLoad(asset) {\n\t\tthis.material = asset.resource;\n\t}\n\n\t_onMaterialAdded(asset) {\n\t\tthis._system.app.assets.off('add:' + asset.id, this._onMaterialAdded, this);\n\n\t\tif (this._materialAsset === asset.id) {\n\t\t\tthis._bindMaterialAsset(asset);\n\t\t}\n\t}\n\n\t_bindMaterialAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on(\"load\", this._onMaterialLoad, this);\n\t\tasset.on(\"change\", this._onMaterialChange, this);\n\t\tasset.on(\"remove\", this._onMaterialRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindMaterialAsset(asset) {\n\t\tasset.off(\"load\", this._onMaterialLoad, this);\n\t\tasset.off(\"change\", this._onMaterialChange, this);\n\t\tasset.off(\"remove\", this._onMaterialRemove, this);\n\t}\n\n\t_onMaterialChange() {}\n\n\t_onMaterialRemove() {}\n\n\t_onTextureAdded(asset) {\n\t\tthis._system.app.assets.off('add:' + asset.id, this._onTextureAdded, this);\n\n\t\tif (this._textureAsset === asset.id) {\n\t\t\tthis._bindTextureAsset(asset);\n\t\t}\n\t}\n\n\t_bindTextureAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on(\"load\", this._onTextureLoad, this);\n\t\tasset.on(\"change\", this._onTextureChange, this);\n\t\tasset.on(\"remove\", this._onTextureRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onTextureLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindTextureAsset(asset) {\n\t\tasset.off(\"load\", this._onTextureLoad, this);\n\t\tasset.off(\"change\", this._onTextureChange, this);\n\t\tasset.off(\"remove\", this._onTextureRemove, this);\n\t}\n\n\t_onTextureLoad(asset) {\n\t\tthis.texture = asset.resource;\n\t}\n\n\t_onTextureChange(asset) {}\n\n\t_onTextureRemove(asset) {}\n\n\t_onSpriteAssetAdded(asset) {\n\t\tthis._system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);\n\n\t\tif (this._spriteAsset === asset.id) {\n\t\t\tthis._bindSpriteAsset(asset);\n\t\t}\n\t}\n\n\t_bindSpriteAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on(\"load\", this._onSpriteAssetLoad, this);\n\t\tasset.on(\"change\", this._onSpriteAssetChange, this);\n\t\tasset.on(\"remove\", this._onSpriteAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onSpriteAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindSpriteAsset(asset) {\n\t\tasset.off(\"load\", this._onSpriteAssetLoad, this);\n\t\tasset.off(\"change\", this._onSpriteAssetChange, this);\n\t\tasset.off(\"remove\", this._onSpriteAssetRemove, this);\n\n\t\tif (asset.data.textureAtlasAsset) {\n\t\t\tthis._system.app.assets.off(\"load:\" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);\n\t\t}\n\t}\n\n\t_onSpriteAssetLoad(asset) {\n\t\tif (!asset || !asset.resource) {\n\t\t\tthis.sprite = null;\n\t\t} else {\n\t\t\tif (!asset.resource.atlas) {\n\t\t\t\tconst atlasAssetId = asset.data.textureAtlasAsset;\n\n\t\t\t\tif (atlasAssetId) {\n\t\t\t\t\tconst assets = this._system.app.assets;\n\t\t\t\t\tassets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n\t\t\t\t\tassets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = asset.resource;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSpriteAssetChange(asset) {\n\t\tthis._onSpriteAssetLoad(asset);\n\t}\n\n\t_onSpriteAssetRemove(asset) {}\n\n\t_bindSprite(sprite) {\n\t\tsprite.on('set:meshes', this._onSpriteMeshesChange, this);\n\t\tsprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);\n\t\tsprite.on('set:atlas', this._onAtlasTextureChange, this);\n\n\t\tif (sprite.atlas) {\n\t\t\tsprite.atlas.on('set:texture', this._onAtlasTextureChange, this);\n\t\t}\n\t}\n\n\t_unbindSprite(sprite) {\n\t\tsprite.off('set:meshes', this._onSpriteMeshesChange, this);\n\t\tsprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);\n\t\tsprite.off('set:atlas', this._onAtlasTextureChange, this);\n\n\t\tif (sprite.atlas) {\n\t\t\tsprite.atlas.off('set:texture', this._onAtlasTextureChange, this);\n\t\t}\n\t}\n\n\t_onSpriteMeshesChange() {\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);\n\t\t}\n\n\t\tthis._updateSprite();\n\t}\n\n\t_onSpritePpuChange() {\n\t\tif (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {\n\t\t\tthis._updateSprite();\n\t\t}\n\t}\n\n\t_onAtlasTextureChange() {\n\t\tif (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {\n\t\t\tthis._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);\n\n\t\t\tthis._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter('texture_emissiveMap');\n\n\t\t\tthis._renderable.deleteParameter('texture_opacityMap');\n\t\t}\n\t}\n\n\t_onTextureAtlasLoad(atlasAsset) {\n\t\tconst spriteAsset = this._spriteAsset;\n\n\t\tif (spriteAsset instanceof Asset) {\n\t\t\tthis._onSpriteAssetLoad(spriteAsset);\n\t\t} else {\n\t\t\tthis._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tif (this._materialAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._materialAsset);\n\n\t\t\tif (asset && asset.resource !== this._material) {\n\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (this._textureAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._textureAsset);\n\n\t\t\tif (asset && asset.resource !== this._texture) {\n\t\t\t\tthis._bindTextureAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (this._spriteAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._spriteAsset);\n\n\t\t\tif (asset && asset.resource !== this._sprite) {\n\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tthis._element.addModelToLayers(this._renderable.model);\n\t}\n\n\tonDisable() {\n\t\tthis._element.removeModelFromLayers(this._renderable.model);\n\t}\n\n\t_setStencil(stencilParams) {\n\t\tthis._renderable.meshInstance.stencilFront = stencilParams;\n\t\tthis._renderable.meshInstance.stencilBack = stencilParams;\n\t\tlet ref = 0;\n\n\t\tif (this._element.maskedBy) {\n\t\t\tref = this._element.maskedBy.element._image._maskRef;\n\t\t}\n\n\t\tif (this._renderable.unmaskMeshInstance) {\n\t\t\tconst sp = new StencilParameters({\n\t\t\t\tref: ref + 1,\n\t\t\t\tfunc: FUNC_EQUAL,\n\t\t\t\tzpass: STENCILOP_DECREMENT\n\t\t\t});\n\t\t\tthis._renderable.unmaskMeshInstance.stencilFront = sp;\n\t\t\tthis._renderable.unmaskMeshInstance.stencilBack = sp;\n\t\t}\n\t}\n\n\tset color(value) {\n\t\tconst r = value.r;\n\t\tconst g = value.g;\n\t\tconst b = value.b;\n\n\t\tif (this._color.r !== r || this._color.g !== g || this._color.b !== b) {\n\t\t\tthis._color.r = r;\n\t\t\tthis._color.g = g;\n\t\t\tthis._color.b = b;\n\t\t\tthis._colorUniform[0] = r;\n\t\t\tthis._colorUniform[1] = g;\n\t\t\tthis._colorUniform[2] = b;\n\n\t\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:color', this._color);\n\t\t}\n\t}\n\n\tget color() {\n\t\treturn this._color;\n\t}\n\n\tset opacity(value) {\n\t\tif (value !== this._color.a) {\n\t\t\tthis._color.a = value;\n\n\t\t\tthis._renderable.setParameter('material_opacity', value);\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:opacity', value);\n\t\t}\n\t}\n\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\n\tset rect(value) {\n\t\tlet x, y, z, w;\n\n\t\tif (value instanceof Vec4) {\n\t\t\tx = value.x;\n\t\t\ty = value.y;\n\t\t\tz = value.z;\n\t\t\tw = value.w;\n\t\t} else {\n\t\t\tx = value[0];\n\t\t\ty = value[1];\n\t\t\tz = value[2];\n\t\t\tw = value[3];\n\t\t}\n\n\t\tif (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._rect.set(x, y, z, w);\n\n\t\tif (this._renderable.mesh) {\n\t\t\tif (!this._element._beingInitialized) {\n\t\t\t\tthis._updateMesh(this._renderable.mesh);\n\t\t\t} else {\n\t\t\t\tthis._meshDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tget rect() {\n\t\treturn this._rect;\n\t}\n\n\tset material(value) {\n\t\tif (this._material === value) return;\n\n\t\tif (!value) {\n\t\t\tconst screenSpace = this._element._isScreenSpace();\n\n\t\t\tif (this.mask) {\n\t\t\t\tvalue = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;\n\t\t\t} else {\n\t\t\t\tvalue = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;\n\t\t\t}\n\t\t}\n\n\t\tthis._material = value;\n\n\t\tif (value) {\n\t\t\tthis._renderable.setMaterial(value);\n\n\t\t\tif (this._hasUserMaterial()) {\n\t\t\t\tthis._renderable.deleteParameter('material_opacity');\n\n\t\t\t\tthis._renderable.deleteParameter('material_emissive');\n\t\t\t} else {\n\t\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\n\t\t\t\tthis._renderable.setParameter('material_opacity', this._color.a);\n\t\t\t}\n\t\t}\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset materialAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tif (this._materialAsset !== _id) {\n\t\t\tif (this._materialAsset) {\n\t\t\t\tassets.off('add:' + this._materialAsset, this._onMaterialAdded, this);\n\n\t\t\t\tconst _prev = assets.get(this._materialAsset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\t_prev.off(\"load\", this._onMaterialLoad, this);\n\n\t\t\t\t\t_prev.off(\"change\", this._onMaterialChange, this);\n\n\t\t\t\t\t_prev.off(\"remove\", this._onMaterialRemove, this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._materialAsset = _id;\n\n\t\t\tif (this._materialAsset) {\n\t\t\t\tconst asset = assets.get(this._materialAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.material = null;\n\t\t\t\t\tassets.on('add:' + this._materialAsset, this._onMaterialAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.material = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget materialAsset() {\n\t\treturn this._materialAsset;\n\t}\n\n\tset texture(value) {\n\t\tif (this._texture === value) return;\n\n\t\tif (this._textureAsset) {\n\t\t\tconst textureAsset = this._system.app.assets.get(this._textureAsset);\n\n\t\t\tif (textureAsset && textureAsset.resource !== value) {\n\t\t\t\tthis.textureAsset = null;\n\t\t\t}\n\t\t}\n\n\t\tthis._texture = value;\n\n\t\tif (value) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tthis.spriteAsset = null;\n\t\t\t}\n\n\t\t\tthis._renderable.setParameter(\"texture_emissiveMap\", this._texture);\n\n\t\t\tthis._renderable.setParameter(\"texture_opacityMap\", this._texture);\n\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\tthis._renderable.setParameter(\"material_emissive\", this._colorUniform);\n\n\t\t\tthis._renderable.setParameter(\"material_opacity\", this._color.a);\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter(\"texture_emissiveMap\");\n\n\t\t\tthis._renderable.deleteParameter(\"texture_opacityMap\");\n\t\t}\n\t}\n\n\tget texture() {\n\t\treturn this._texture;\n\t}\n\n\tset textureAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tif (this._textureAsset !== _id) {\n\t\t\tif (this._textureAsset) {\n\t\t\t\tassets.off('add:' + this._textureAsset, this._onTextureAdded, this);\n\n\t\t\t\tconst _prev = assets.get(this._textureAsset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\t_prev.off(\"load\", this._onTextureLoad, this);\n\n\t\t\t\t\t_prev.off(\"change\", this._onTextureChange, this);\n\n\t\t\t\t\t_prev.off(\"remove\", this._onTextureRemove, this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._textureAsset = _id;\n\n\t\t\tif (this._textureAsset) {\n\t\t\t\tconst asset = assets.get(this._textureAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.texture = null;\n\t\t\t\t\tassets.on('add:' + this._textureAsset, this._onTextureAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindTextureAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.texture = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget textureAsset() {\n\t\treturn this._textureAsset;\n\t}\n\n\tset spriteAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tif (this._spriteAsset !== _id) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tassets.off('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n\n\t\t\t\tconst _prev = assets.get(this._spriteAsset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindSpriteAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._spriteAsset = _id;\n\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst asset = assets.get(this._spriteAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.sprite = null;\n\t\t\t\t\tassets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:spriteAsset', _id);\n\t\t}\n\t}\n\n\tget spriteAsset() {\n\t\treturn this._spriteAsset;\n\t}\n\n\tset sprite(value) {\n\t\tif (this._sprite === value) return;\n\n\t\tif (this._sprite) {\n\t\t\tthis._unbindSprite(this._sprite);\n\t\t}\n\n\t\tif (this._spriteAsset) {\n\t\t\tconst spriteAsset = this._system.app.assets.get(this._spriteAsset);\n\n\t\t\tif (spriteAsset && spriteAsset.resource !== value) {\n\t\t\t\tthis.spriteAsset = null;\n\t\t\t}\n\t\t}\n\n\t\tthis._sprite = value;\n\n\t\tif (this._sprite) {\n\t\t\tthis._bindSprite(this._sprite);\n\n\t\t\tif (this._textureAsset) {\n\t\t\t\tthis.textureAsset = null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {\n\t\t\tthis._renderable.setParameter(\"texture_emissiveMap\", this._sprite.atlas.texture);\n\n\t\t\tthis._renderable.setParameter(\"texture_opacityMap\", this._sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter(\"texture_emissiveMap\");\n\n\t\t\tthis._renderable.deleteParameter(\"texture_opacityMap\");\n\t\t}\n\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);\n\t\t}\n\n\t\tthis._updateSprite();\n\t}\n\n\tget sprite() {\n\t\treturn this._sprite;\n\t}\n\n\tset spriteFrame(value) {\n\t\tconst oldValue = this._spriteFrame;\n\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);\n\t\t} else {\n\t\t\tthis._spriteFrame = value;\n\t\t}\n\n\t\tif (this._spriteFrame !== oldValue) {\n\t\t\tthis._updateSprite();\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:spriteFrame', value);\n\t\t}\n\t}\n\n\tget spriteFrame() {\n\t\treturn this._spriteFrame;\n\t}\n\n\tset mesh(value) {\n\t\tthis._renderable.setMesh(value);\n\n\t\tif (this._defaultMesh === value) {\n\t\t\tthis._renderable.setAabbFunc(null);\n\t\t} else {\n\t\t\tthis._renderable.setAabbFunc(this._updateAabbFunc);\n\t\t}\n\t}\n\n\tget mesh() {\n\t\treturn this._renderable.mesh;\n\t}\n\n\tset mask(value) {\n\t\tif (this._mask !== value) {\n\t\t\tthis._mask = value;\n\n\t\t\tthis._toggleMask();\n\t\t}\n\t}\n\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\n\tset pixelsPerUnit(value) {\n\t\tif (this._pixelsPerUnit === value) return;\n\t\tthis._pixelsPerUnit = value;\n\n\t\tif (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tthis._updateSprite();\n\t\t}\n\t}\n\n\tget pixelsPerUnit() {\n\t\treturn this._pixelsPerUnit;\n\t}\n\n\tget aabb() {\n\t\tif (this._renderable.meshInstance) {\n\t\t\treturn this._renderable.meshInstance.aabb;\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n\nclass LocalizedAsset extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis._app = app;\n\t\tapp.i18n.on('set:locale', this._onSetLocale, this);\n\t\tthis._autoLoad = false;\n\t\tthis._disableLocalization = false;\n\t\tthis._defaultAsset = null;\n\t\tthis._localizedAsset = null;\n\t}\n\n\tset defaultAsset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\t\tif (this._defaultAsset === id) return;\n\n\t\tif (this._defaultAsset) {\n\t\t\tthis._unbindDefaultAsset();\n\t\t}\n\n\t\tthis._defaultAsset = id;\n\n\t\tif (this._defaultAsset) {\n\t\t\tthis._bindDefaultAsset();\n\t\t}\n\n\t\tthis._onSetLocale(this._app.i18n.locale);\n\t}\n\n\tget defaultAsset() {\n\t\treturn this._defaultAsset;\n\t}\n\n\tset localizedAsset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\n\t\tif (this._localizedAsset === id) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._localizedAsset) {\n\t\t\tthis._app.assets.off('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);\n\n\t\t\tthis._unbindLocalizedAsset();\n\n\t\t\tthis._localizedAsset = null;\n\t\t}\n\n\t\tthis._localizedAsset = id;\n\n\t\tif (this._localizedAsset) {\n\t\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\n\t\t\tif (!asset) {\n\t\t\t\tthis._app.assets.once('add:' + this._localizedAsset, this._onLocalizedAssetAdd, this);\n\t\t\t} else {\n\t\t\t\tthis._bindLocalizedAsset();\n\t\t\t}\n\t\t}\n\t}\n\n\tget localizedAsset() {\n\t\treturn this._localizedAsset;\n\t}\n\n\tset autoLoad(value) {\n\t\tif (this._autoLoad === value) return;\n\t\tthis._autoLoad = value;\n\n\t\tif (this._autoLoad && this._localizedAsset) {\n\t\t\tthis._unbindLocalizedAsset();\n\n\t\t\tthis._bindLocalizedAsset();\n\t\t}\n\t}\n\n\tget autoLoad() {\n\t\treturn this._autoLoad;\n\t}\n\n\tset disableLocalization(value) {\n\t\tif (this._disableLocalization === value) return;\n\t\tthis._disableLocalization = value;\n\n\t\tthis._onSetLocale(this._app.i18n.locale);\n\t}\n\n\tget disableLocalization() {\n\t\treturn this._disableLocalization;\n\t}\n\n\t_bindDefaultAsset() {\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\n\t\tif (!asset) {\n\t\t\tthis._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n\t\t} else {\n\t\t\tthis._onDefaultAssetAdd(asset);\n\t\t}\n\t}\n\n\t_unbindDefaultAsset() {\n\t\tif (!this._defaultAsset) return;\n\n\t\tthis._app.assets.off('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\n\t\tif (!asset) return;\n\t\tasset.off('add:localized', this._onLocaleAdd, this);\n\t\tasset.off('remove:localized', this._onLocaleRemove, this);\n\t\tasset.off('remove', this._onDefaultAssetRemove, this);\n\t}\n\n\t_onDefaultAssetAdd(asset) {\n\t\tif (this._defaultAsset !== asset.id) return;\n\t\tasset.on('add:localized', this._onLocaleAdd, this);\n\t\tasset.on('remove:localized', this._onLocaleRemove, this);\n\t\tasset.once('remove', this._onDefaultAssetRemove, this);\n\t}\n\n\t_onDefaultAssetRemove(asset) {\n\t\tif (this._defaultAsset !== asset.id) return;\n\t\tasset.off('add:localized', this._onLocaleAdd, this);\n\t\tasset.off('remove:localized', this._onLocaleAdd, this);\n\n\t\tthis._app.assets.once('add:' + this._defaultAsset, this._onDefaultAssetAdd, this);\n\t}\n\n\t_bindLocalizedAsset() {\n\t\tif (!this._autoLoad) return;\n\n\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\n\t\tif (!asset) return;\n\t\tasset.on(\"load\", this._onLocalizedAssetLoad, this);\n\t\tasset.on(\"change\", this._onLocalizedAssetChange, this);\n\t\tasset.on(\"remove\", this._onLocalizedAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onLocalizedAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindLocalizedAsset() {\n\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\n\t\tif (!asset) return;\n\t\tasset.off(\"load\", this._onLocalizedAssetLoad, this);\n\t\tasset.off(\"change\", this._onLocalizedAssetChange, this);\n\t\tasset.off(\"remove\", this._onLocalizedAssetRemove, this);\n\t}\n\n\t_onLocalizedAssetAdd(asset) {\n\t\tif (this._localizedAsset !== asset.id) return;\n\n\t\tthis._bindLocalizedAsset();\n\t}\n\n\t_onLocalizedAssetLoad(asset) {\n\t\tthis.fire('load', asset);\n\t}\n\n\t_onLocalizedAssetChange(asset, name, newValue, oldValue) {\n\t\tthis.fire('change', asset, name, newValue, oldValue);\n\t}\n\n\t_onLocalizedAssetRemove(asset) {\n\t\tif (this._localizedAsset === asset.id) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t}\n\n\t\tthis.fire('remove', asset);\n\t}\n\n\t_onLocaleAdd(locale, assetId) {\n\t\tif (this._app.i18n.locale !== locale) return;\n\n\t\tthis._onSetLocale(locale);\n\t}\n\n\t_onLocaleRemove(locale, assetId) {\n\t\tif (this._app.i18n.locale !== locale) return;\n\n\t\tthis._onSetLocale(locale);\n\t}\n\n\t_onSetLocale(locale) {\n\t\tif (!this._defaultAsset) {\n\t\t\tthis.localizedAsset = null;\n\t\t\treturn;\n\t\t}\n\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\n\t\tif (!asset || this._disableLocalization) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t\treturn;\n\t\t}\n\n\t\tconst localizedAssetId = asset.getLocalizedAssetId(locale);\n\n\t\tif (!localizedAssetId) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.localizedAsset = localizedAssetId;\n\t}\n\n\tdestroy() {\n\t\tthis.defaultAsset = null;\n\n\t\tthis._app.i18n.off('set:locale', this._onSetLocale, this);\n\n\t\tthis.off();\n\t}\n\n}\n\nconst EOF_TOKEN = 0;\nconst ERROR_TOKEN = 1;\nconst TEXT_TOKEN = 2;\nconst OPEN_BRACKET_TOKEN = 3;\nconst CLOSE_BRACKET_TOKEN = 4;\nconst EQUALS_TOKEN = 5;\nconst STRING_TOKEN = 6;\nconst IDENTIFIER_TOKEN = 7;\nconst WHITESPACE_TOKEN = 8;\nconst WHITESPACE_CHARS = \" \\t\\n\\r\\v\\f\";\nconst IDENTIFIER_REGEX = /[A-Z|a-z|0-9|_|-|/]/;\n\nclass Scanner {\n\tconstructor(symbols) {\n\t\tthis._symbols = symbols;\n\t\tthis._index = 0;\n\t\tthis._last = 0;\n\t\tthis._cur = this._symbols.length > 0 ? this._symbols[0] : null;\n\t\tthis._buf = [];\n\t\tthis._mode = \"text\";\n\t\tthis._error = null;\n\t}\n\n\tread() {\n\t\tlet token = this._read();\n\n\t\twhile (token === WHITESPACE_TOKEN) {\n\t\t\ttoken = this._read();\n\t\t}\n\n\t\tif (token !== EOF_TOKEN && token !== ERROR_TOKEN) {\n\t\t\tthis._last = this._index;\n\t\t}\n\n\t\treturn token;\n\t}\n\n\tbuf() {\n\t\treturn this._buf;\n\t}\n\n\tlast() {\n\t\treturn this._last;\n\t}\n\n\terror() {\n\t\treturn this._error;\n\t}\n\n\tdebugPrint() {\n\t\tconst tokenStrings = [\"EOF\", \"ERROR\", \"TEXT\", \"OPEN_BRACKET\", \"CLOSE_BRACKET\", \"EQUALS\", \"STRING\", \"IDENTIFIER\", \"WHITESPACE\"];\n\t\tlet token = this.read();\n\t\tlet result = \"\";\n\n\t\twhile (true) {\n\t\t\tresult += (result.length > 0 ? \"\\n\" : \"\") + tokenStrings[token] + \" '\" + this.buf().join(\"\") + \"'\";\n\n\t\t\tif (token === EOF_TOKEN || token === ERROR_TOKEN) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttoken = this.read();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_read() {\n\t\tthis._buf = [];\n\n\t\tif (this._eof()) {\n\t\t\treturn EOF_TOKEN;\n\t\t}\n\n\t\treturn this._mode === \"text\" ? this._text() : this._tag();\n\t}\n\n\t_text() {\n\t\twhile (true) {\n\t\t\tswitch (this._cur) {\n\t\t\t\tcase null:\n\t\t\t\t\treturn this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;\n\n\t\t\t\tcase \"[\":\n\t\t\t\t\tthis._mode = \"tag\";\n\t\t\t\t\treturn this._buf.length > 0 ? TEXT_TOKEN : this._tag();\n\n\t\t\t\tcase \"\\\\\":\n\t\t\t\t\tthis._next();\n\n\t\t\t\t\tswitch (this._cur) {\n\t\t\t\t\t\tcase \"[\":\n\t\t\t\t\t\t\tthis._store();\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis._output(\"\\\\\");\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._store();\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_tag() {\n\t\tswitch (this._cur) {\n\t\t\tcase null:\n\t\t\t\tthis._error = \"unexpected end of input reading tag\";\n\t\t\t\treturn ERROR_TOKEN;\n\n\t\t\tcase \"[\":\n\t\t\t\tthis._store();\n\n\t\t\t\treturn OPEN_BRACKET_TOKEN;\n\n\t\t\tcase \"]\":\n\t\t\t\tthis._store();\n\n\t\t\t\tthis._mode = \"text\";\n\t\t\t\treturn CLOSE_BRACKET_TOKEN;\n\n\t\t\tcase \"=\":\n\t\t\t\tthis._store();\n\n\t\t\t\treturn EQUALS_TOKEN;\n\n\t\t\tcase \" \":\n\t\t\tcase \"\\t\":\n\t\t\tcase \"\\n\":\n\t\t\tcase \"\\r\":\n\t\t\tcase \"\\v\":\n\t\t\tcase \"\\f\":\n\t\t\t\treturn this._whitespace();\n\n\t\t\tcase \"\\\"\":\n\t\t\t\treturn this._string();\n\n\t\t\tdefault:\n\t\t\t\tif (!this._isIdentifierSymbol(this._cur)) {\n\t\t\t\t\tthis._error = \"unrecognized character\";\n\t\t\t\t\treturn ERROR_TOKEN;\n\t\t\t\t}\n\n\t\t\t\treturn this._identifier();\n\t\t}\n\t}\n\n\t_whitespace() {\n\t\tthis._store();\n\n\t\twhile (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {\n\t\t\tthis._store();\n\t\t}\n\n\t\treturn WHITESPACE_TOKEN;\n\t}\n\n\t_string() {\n\t\tthis._next();\n\n\t\twhile (true) {\n\t\t\tswitch (this._cur) {\n\t\t\t\tcase null:\n\t\t\t\t\tthis._error = \"unexpected end of input reading string\";\n\t\t\t\t\treturn ERROR_TOKEN;\n\n\t\t\t\tcase \"\\\"\":\n\t\t\t\t\tthis._next();\n\n\t\t\t\t\treturn STRING_TOKEN;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._store();\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_identifier() {\n\t\tthis._store();\n\n\t\twhile (this._cur !== null && this._isIdentifierSymbol(this._cur)) {\n\t\t\tthis._store();\n\t\t}\n\n\t\treturn IDENTIFIER_TOKEN;\n\t}\n\n\t_isIdentifierSymbol(s) {\n\t\treturn s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;\n\t}\n\n\t_eof() {\n\t\treturn this._cur === null;\n\t}\n\n\t_next() {\n\t\tif (!this._eof()) {\n\t\t\tthis._index++;\n\t\t\tthis._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;\n\t\t}\n\n\t\treturn this._cur;\n\t}\n\n\t_store() {\n\t\tthis._buf.push(this._cur);\n\n\t\treturn this._next();\n\t}\n\n\t_output(c) {\n\t\tthis._buf.push(c);\n\t}\n\n}\n\nclass Parser {\n\tconstructor(symbols) {\n\t\tthis._scanner = new Scanner(symbols);\n\t\tthis._error = null;\n\t}\n\n\tparse(symbols, tags) {\n\t\twhile (true) {\n\t\t\tconst token = this._scanner.read();\n\n\t\t\tswitch (token) {\n\t\t\t\tcase EOF_TOKEN:\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase ERROR_TOKEN:\n\t\t\t\t\treturn false;\n\n\t\t\t\tcase TEXT_TOKEN:\n\t\t\t\t\tArray.prototype.push.apply(symbols, this._scanner.buf());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase OPEN_BRACKET_TOKEN:\n\t\t\t\t\tif (!this._parseTag(symbols, tags)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\terror() {\n\t\treturn \"Error evaluating markup at #\" + this._scanner.last().toString() + \" (\" + (this._scanner.error() || this._error) + \")\";\n\t}\n\n\t_parseTag(symbols, tags) {\n\t\tlet token = this._scanner.read();\n\n\t\tif (token !== IDENTIFIER_TOKEN) {\n\t\t\tthis._error = \"expected identifier\";\n\t\t\treturn false;\n\t\t}\n\n\t\tconst name = this._scanner.buf().join(\"\");\n\n\t\tif (name[0] === \"/\") {\n\t\t\tfor (let index = tags.length - 1; index >= 0; --index) {\n\t\t\t\tif (name === \"/\" + tags[index].name && tags[index].end === null) {\n\t\t\t\t\ttags[index].end = symbols.length;\n\t\t\t\t\ttoken = this._scanner.read();\n\n\t\t\t\t\tif (token !== CLOSE_BRACKET_TOKEN) {\n\t\t\t\t\t\tthis._error = \"expected close bracket\";\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._error = \"failed to find matching tag\";\n\t\t\treturn false;\n\t\t}\n\n\t\tconst tag = {\n\t\t\tname: name,\n\t\t\tvalue: null,\n\t\t\tattributes: {},\n\t\t\tstart: symbols.length,\n\t\t\tend: null\n\t\t};\n\t\ttoken = this._scanner.read();\n\n\t\tif (token === EQUALS_TOKEN) {\n\t\t\ttoken = this._scanner.read();\n\n\t\t\tif (token !== STRING_TOKEN) {\n\t\t\t\tthis._error = \"expected string\";\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttag.value = this._scanner.buf().join(\"\");\n\t\t\ttoken = this._scanner.read();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tswitch (token) {\n\t\t\t\tcase CLOSE_BRACKET_TOKEN:\n\t\t\t\t\ttags.push(tag);\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase IDENTIFIER_TOKEN:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst identifier = this._scanner.buf().join(\"\");\n\n\t\t\t\t\t\ttoken = this._scanner.read();\n\n\t\t\t\t\t\tif (token !== EQUALS_TOKEN) {\n\t\t\t\t\t\t\tthis._error = \"expected equals\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttoken = this._scanner.read();\n\n\t\t\t\t\t\tif (token !== STRING_TOKEN) {\n\t\t\t\t\t\t\tthis._error = \"expected string\";\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst value = this._scanner.buf().join(\"\");\n\n\t\t\t\t\t\ttag.attributes[identifier] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis._error = \"expected close bracket or identifier\";\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttoken = this._scanner.read();\n\t\t}\n\t}\n\n}\n\nfunction merge(target, source) {\n\tfor (const key in source) {\n\t\tif (!source.hasOwnProperty(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = source[key];\n\n\t\tif (value instanceof Object) {\n\t\t\tif (!target.hasOwnProperty(key)) {\n\t\t\t\ttarget[key] = {};\n\t\t\t}\n\n\t\t\tmerge(target[key], source[key]);\n\t\t} else {\n\t\t\ttarget[key] = value;\n\t\t}\n\t}\n}\n\nfunction combineTags(tags) {\n\tif (tags.length === 0) {\n\t\treturn null;\n\t}\n\n\tconst result = {};\n\n\tfor (let index = 0; index < tags.length; ++index) {\n\t\tconst tag = tags[index];\n\t\tconst tmp = {};\n\t\ttmp[tag.name] = {\n\t\t\tvalue: tag.value,\n\t\t\tattributes: tag.attributes\n\t\t};\n\t\tmerge(result, tmp);\n\t}\n\n\treturn result;\n}\n\nfunction resolveMarkupTags(tags, numSymbols) {\n\tif (tags.length === 0) {\n\t\treturn null;\n\t}\n\n\tconst edges = {};\n\n\tfor (let index = 0; index < tags.length; ++index) {\n\t\tconst tag = tags[index];\n\n\t\tif (!edges.hasOwnProperty(tag.start)) {\n\t\t\tedges[tag.start] = {\n\t\t\t\topen: [tag],\n\t\t\t\tclose: null\n\t\t\t};\n\t\t} else {\n\t\t\tif (edges[tag.start].open === null) {\n\t\t\t\tedges[tag.start].open = [tag];\n\t\t\t} else {\n\t\t\t\tedges[tag.start].open.push(tag);\n\t\t\t}\n\t\t}\n\n\t\tif (!edges.hasOwnProperty(tag.end)) {\n\t\t\tedges[tag.end] = {\n\t\t\t\topen: null,\n\t\t\t\tclose: [tag]\n\t\t\t};\n\t\t} else {\n\t\t\tif (edges[tag.end].close === null) {\n\t\t\t\tedges[tag.end].close = [tag];\n\t\t\t} else {\n\t\t\t\tedges[tag.end].close.push(tag);\n\t\t\t}\n\t\t}\n\t}\n\n\tlet tagStack = [];\n\n\tfunction removeTags(tags) {\n\t\ttagStack = tagStack.filter(function (tag) {\n\t\t\treturn tags.find(function (t) {\n\t\t\t\treturn t === tag;\n\t\t\t}) === undefined;\n\t\t});\n\t}\n\n\tfunction addTags(tags) {\n\t\tfor (let index = 0; index < tags.length; ++index) {\n\t\t\ttagStack.push(tags[index]);\n\t\t}\n\t}\n\n\tconst edgeKeys = Object.keys(edges).sort(function (a, b) {\n\t\treturn a - b;\n\t});\n\tconst resolvedTags = [];\n\n\tfor (let index = 0; index < edgeKeys.length; ++index) {\n\t\tconst edge = edges[edgeKeys[index]];\n\n\t\tif (edge.close !== null) {\n\t\t\tremoveTags(edge.close);\n\t\t}\n\n\t\tif (edge.open !== null) {\n\t\t\taddTags(edge.open);\n\t\t}\n\n\t\tresolvedTags.push({\n\t\t\tstart: edgeKeys[index],\n\t\t\ttags: combineTags(tagStack)\n\t\t});\n\t}\n\n\tconst result = [];\n\tlet prevTag = null;\n\n\tfor (let index = 0; index < resolvedTags.length; ++index) {\n\t\tconst resolvedTag = resolvedTags[index];\n\n\t\twhile (result.length < resolvedTag.start) {\n\t\t\tresult.push(prevTag ? prevTag.tags : null);\n\t\t}\n\n\t\tprevTag = resolvedTag;\n\t}\n\n\twhile (result.length < numSymbols) {\n\t\tresult.push(null);\n\t}\n\n\treturn result;\n}\n\nfunction evaluateMarkup(symbols) {\n\tconst parser = new Parser(symbols);\n\tconst stripped_symbols = [];\n\tconst tags = [];\n\n\tif (!parser.parse(stripped_symbols, tags)) {\n\t\tconsole.warn(parser.error());\n\t\treturn {\n\t\t\tsymbols: symbols,\n\t\t\ttags: null\n\t\t};\n\t}\n\n\tconst invalidTag = tags.find(function (t) {\n\t\treturn t.end === null;\n\t});\n\n\tif (invalidTag) {\n\t\tconsole.warn(`Markup error: found unclosed tag='${invalidTag.name}'`);\n\t\treturn {\n\t\t\tsymbols: symbols,\n\t\t\ttags: null\n\t\t};\n\t}\n\n\tconst resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);\n\treturn {\n\t\tsymbols: stripped_symbols,\n\t\ttags: resolved_tags\n\t};\n}\n\nclass Markup {\n\tstatic evaluate(symbols) {\n\t\treturn evaluateMarkup(symbols);\n\t}\n\n}\n\nclass MeshInfo {\n\tconstructor() {\n\t\tthis.count = 0;\n\t\tthis.quad = 0;\n\t\tthis.lines = {};\n\t\tthis.positions = [];\n\t\tthis.normals = [];\n\t\tthis.uvs = [];\n\t\tthis.colors = [];\n\t\tthis.indices = [];\n\t\tthis.meshInstance = null;\n\t}\n\n}\n\nconst LINE_BREAK_CHAR = /^[\\r\\n]$/;\nconst WHITESPACE_CHAR = /^[ \\t]$/;\nconst WORD_BOUNDARY_CHAR = /^[ \\t\\-]|[\\u200b]$/;\nconst ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;\nconst CJK_CHAR = /^[\\u1100-\\u11ff]|[\\u3000-\\u9fff]|[\\ua960-\\ua97f]|[\\uac00-\\ud7ff]$/;\nconst NO_LINE_BREAK_CJK_CHAR = /^[]$/;\nconst CONTROL_CHARS = ['\\u200B', '\\u061C', '\\u200E', '\\u200F', '\\u202A', '\\u202B', '\\u202C', '\\u202D', '\\u202E', '\\u2066', '\\u2067', '\\u2068', '\\u2069'];\nconst CONTROL_GLYPH_DATA = {\n\twidth: 0,\n\theight: 0,\n\txadvance: 0,\n\txoffset: 0,\n\tyoffset: 0\n};\n\nclass TextElement {\n\tconstructor(element) {\n\t\tthis._element = element;\n\t\tthis._system = element.system;\n\t\tthis._entity = element.entity;\n\t\tthis._text = \"\";\n\t\tthis._symbols = [];\n\t\tthis._colorPalette = [];\n\t\tthis._symbolColors = null;\n\t\tthis._i18nKey = null;\n\t\tthis._fontAsset = new LocalizedAsset(this._system.app);\n\t\tthis._fontAsset.disableLocalization = true;\n\n\t\tthis._fontAsset.on('load', this._onFontLoad, this);\n\n\t\tthis._fontAsset.on('change', this._onFontChange, this);\n\n\t\tthis._fontAsset.on('remove', this._onFontRemove, this);\n\n\t\tthis._font = null;\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array(3);\n\t\tthis._spacing = 1;\n\t\tthis._fontSize = 32;\n\t\tthis._fontMinY = 0;\n\t\tthis._fontMaxY = 0;\n\t\tthis._originalFontSize = 32;\n\t\tthis._maxFontSize = 32;\n\t\tthis._minFontSize = 8;\n\t\tthis._autoFitWidth = false;\n\t\tthis._autoFitHeight = false;\n\t\tthis._maxLines = -1;\n\t\tthis._lineHeight = 32;\n\t\tthis._scaledLineHeight = 32;\n\t\tthis._wrapLines = false;\n\t\tthis._drawOrder = 0;\n\t\tthis._alignment = new Vec2(0.5, 0.5);\n\t\tthis._autoWidth = true;\n\t\tthis._autoHeight = true;\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\tthis._node = new GraphNode();\n\t\tthis._model = new Model();\n\t\tthis._model.graph = this._node;\n\n\t\tthis._entity.addChild(this._node);\n\n\t\tthis._meshInfo = [];\n\t\tthis._material = null;\n\t\tthis._aabbDirty = true;\n\t\tthis._aabb = new BoundingBox();\n\t\tthis._noResize = false;\n\t\tthis._currentMaterialType = null;\n\t\tthis._maskedMaterialSrc = null;\n\t\tthis._rtlReorder = false;\n\t\tthis._unicodeConverter = false;\n\t\tthis._rtl = false;\n\t\tthis._outlineColor = new Color(0, 0, 0, 1);\n\t\tthis._outlineColorUniform = new Float32Array(4);\n\t\tthis._outlineThicknessScale = 0.2;\n\t\tthis._outlineThickness = 0.0;\n\t\tthis._shadowColor = new Color(0, 0, 0, 1);\n\t\tthis._shadowColorUniform = new Float32Array(4);\n\t\tthis._shadowOffsetScale = 0.005;\n\t\tthis._shadowOffset = new Vec2(0, 0);\n\t\tthis._shadowOffsetUniform = new Float32Array(2);\n\t\tthis._enableMarkup = false;\n\n\t\tthis._onScreenChange(this._element.screen);\n\n\t\telement.on('resize', this._onParentResize, this);\n\t\telement.on('set:screen', this._onScreenChange, this);\n\t\telement.on('screen:set:screenspace', this._onScreenSpaceChange, this);\n\t\telement.on('set:draworder', this._onDrawOrderChange, this);\n\t\telement.on('set:pivot', this._onPivotChange, this);\n\n\t\tthis._system.app.i18n.on('set:locale', this._onLocaleSet, this);\n\n\t\tthis._system.app.i18n.on('data:add', this._onLocalizationData, this);\n\n\t\tthis._system.app.i18n.on('data:remove', this._onLocalizationData, this);\n\n\t\tthis._rangeStart = 0;\n\t\tthis._rangeEnd = 0;\n\t}\n\n\tdestroy() {\n\t\tthis._setMaterial(null);\n\n\t\tif (this._model) {\n\t\t\tthis._element.removeModelFromLayers(this._model);\n\n\t\t\tthis._model.destroy();\n\n\t\t\tthis._model = null;\n\t\t}\n\n\t\tthis._fontAsset.destroy();\n\n\t\tthis.font = null;\n\n\t\tthis._element.off('resize', this._onParentResize, this);\n\n\t\tthis._element.off('set:screen', this._onScreenChange, this);\n\n\t\tthis._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);\n\n\t\tthis._element.off('set:draworder', this._onDrawOrderChange, this);\n\n\t\tthis._element.off('set:pivot', this._onPivotChange, this);\n\n\t\tthis._system.app.i18n.off('set:locale', this._onLocaleSet, this);\n\n\t\tthis._system.app.i18n.off('data:add', this._onLocalizationData, this);\n\n\t\tthis._system.app.i18n.off('data:remove', this._onLocalizationData, this);\n\t}\n\n\t_onParentResize(width, height) {\n\t\tif (this._noResize) return;\n\t\tif (this._font) this._updateText();\n\t}\n\n\t_onScreenChange(screen) {\n\t\tif (screen) {\n\t\t\tthis._updateMaterial(screen.screen.screenSpace);\n\t\t} else {\n\t\t\tthis._updateMaterial(false);\n\t\t}\n\t}\n\n\t_onScreenSpaceChange(value) {\n\t\tthis._updateMaterial(value);\n\t}\n\n\t_onDrawOrderChange(order) {\n\t\tthis._drawOrder = order;\n\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tthis._model.meshInstances[i].drawOrder = order;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onPivotChange(pivot) {\n\t\tif (this._font) this._updateText();\n\t}\n\n\t_onLocaleSet(locale) {\n\t\tif (!this._i18nKey) return;\n\n\t\tif (this.fontAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this.fontAsset);\n\n\t\t\tif (!asset || !asset.resource || asset.resource !== this._font) {\n\t\t\t\tthis.font = null;\n\t\t\t}\n\t\t}\n\n\t\tthis._resetLocalizedText();\n\t}\n\n\t_onLocalizationData(locale, messages) {\n\t\tif (this._i18nKey && messages[this._i18nKey]) {\n\t\t\tthis._resetLocalizedText();\n\t\t}\n\t}\n\n\t_resetLocalizedText() {\n\t\tthis._setText(this._system.app.i18n.getText(this._i18nKey));\n\t}\n\n\t_setText(text) {\n\t\tif (this.unicodeConverter) {\n\t\t\tconst unicodeConverterFunc = this._system.getUnicodeConverter();\n\n\t\t\tif (unicodeConverterFunc) {\n\t\t\t\ttext = unicodeConverterFunc(text);\n\t\t\t} else {\n\t\t\t\tconsole.warn('Element created with unicodeConverter option but no unicodeConverter function registered');\n\t\t\t}\n\t\t}\n\n\t\tif (this._text !== text) {\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText(text);\n\t\t\t}\n\n\t\t\tthis._text = text;\n\t\t}\n\t}\n\n\t_updateText(text) {\n\t\tlet tags;\n\t\tif (text === undefined) text = this._text;\n\t\tthis._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);\n\n\t\tif (this._symbols.length === 0) {\n\t\t\tthis._symbols = [\" \"];\n\t\t}\n\n\t\tif (this._enableMarkup) {\n\t\t\tconst results = Markup.evaluate(this._symbols);\n\t\t\tthis._symbols = results.symbols;\n\t\t\ttags = results.tags;\n\t\t}\n\n\t\tif (this._rtlReorder) {\n\t\t\tconst rtlReorderFunc = this._system.app.systems.element.getRtlReorder();\n\n\t\t\tif (rtlReorderFunc) {\n\t\t\t\tconst results = rtlReorderFunc(this._symbols);\n\t\t\t\tthis._rtl = results.rtl;\n\t\t\t\tthis._symbols = results.mapping.map(function (v) {\n\t\t\t\t\treturn this._symbols[v];\n\t\t\t\t}, this);\n\n\t\t\t\tif (tags) {\n\t\t\t\t\ttags = results.mapping.map(function (v) {\n\t\t\t\t\t\treturn tags[v];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn('Element created with rtlReorder option but no rtlReorder function registered');\n\t\t\t}\n\t\t} else {\n\t\t\tthis._rtl = false;\n\t\t}\n\n\t\tif (tags) {\n\t\t\tconst paletteMap = {};\n\t\t\tthis._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];\n\t\t\tthis._symbolColors = [];\n\t\t\tpaletteMap[this._color.toString(false).toLowerCase()] = 0;\n\n\t\t\tfor (let i = 0, len = this._symbols.length; i < len; ++i) {\n\t\t\t\tconst tag = tags[i];\n\t\t\t\tlet color = 0;\n\n\t\t\t\tif (tag && tag.color && tag.color.value) {\n\t\t\t\t\tconst c = tag.color.value;\n\n\t\t\t\t\tif (c.length === 7 && c[0] === \"#\") {\n\t\t\t\t\t\tconst hex = c.substring(1).toLowerCase();\n\n\t\t\t\t\t\tif (paletteMap.hasOwnProperty(hex)) {\n\t\t\t\t\t\t\tcolor = paletteMap[hex];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (/^([0-9a-f]{2}){3}$/.test(hex)) {\n\t\t\t\t\t\t\t\tcolor = this._colorPalette.length / 3;\n\t\t\t\t\t\t\t\tpaletteMap[hex] = color;\n\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(0, 2), 16));\n\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(2, 4), 16));\n\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(4, 6), 16));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._symbolColors.push(color);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._colorPalette = [];\n\t\t\tthis._symbolColors = null;\n\t\t}\n\n\t\tconst charactersPerTexture = this._calculateCharsPerTexture();\n\n\t\tlet removedModel = false;\n\t\tconst element = this._element;\n\n\t\tconst screenSpace = element._isScreenSpace();\n\n\t\tconst screenCulled = element._isScreenCulled();\n\n\t\tconst visibleFn = function visibleFn(camera) {\n\t\t\treturn element.isVisibleForCamera(camera);\n\t\t};\n\n\t\tfor (let i = 0, len = this._meshInfo.length; i < len; i++) {\n\t\t\tconst l = charactersPerTexture[i] || 0;\n\t\t\tconst meshInfo = this._meshInfo[i];\n\n\t\t\tif (meshInfo.count !== l) {\n\t\t\t\tif (!removedModel) {\n\t\t\t\t\telement.removeModelFromLayers(this._model);\n\t\t\t\t\tremovedModel = true;\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.count = l;\n\t\t\t\tmeshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;\n\t\t\t\tmeshInfo.indices.length = l * 3 * 2;\n\t\t\t\tmeshInfo.uvs.length = l * 2 * 4;\n\t\t\t\tmeshInfo.colors.length = l * 4 * 4;\n\n\t\t\t\tif (meshInfo.meshInstance) {\n\t\t\t\t\tthis._removeMeshInstance(meshInfo.meshInstance);\n\t\t\t\t}\n\n\t\t\t\tif (l === 0) {\n\t\t\t\t\tmeshInfo.meshInstance = null;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (let v = 0; v < l; v++) {\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 0] = v * 4;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 0] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 1] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 2] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 3] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 4] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 5] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 6] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 7] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 8] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 9] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 10] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 11] = -1;\n\t\t\t\t}\n\n\t\t\t\tconst mesh = createMesh$1(this._system.app.graphicsDevice, meshInfo.positions, {\n\t\t\t\t\tuvs: meshInfo.uvs,\n\t\t\t\t\tnormals: meshInfo.normals,\n\t\t\t\t\tcolors: meshInfo.colors,\n\t\t\t\t\tindices: meshInfo.indices\n\t\t\t\t});\n\t\t\t\tconst mi = new MeshInstance(mesh, this._material, this._node);\n\t\t\t\tmi.name = \"Text Element: \" + this._entity.name;\n\t\t\t\tmi.castShadow = false;\n\t\t\t\tmi.receiveShadow = false;\n\t\t\t\tmi.cull = !screenSpace;\n\t\t\t\tmi.screenSpace = screenSpace;\n\t\t\t\tmi.drawOrder = this._drawOrder;\n\n\t\t\t\tif (screenCulled) {\n\t\t\t\t\tmi.cull = true;\n\t\t\t\t\tmi.isVisibleFunc = visibleFn;\n\t\t\t\t}\n\n\t\t\t\tthis._setTextureParams(mi, this._font.textures[i]);\n\n\t\t\t\tif (this._symbolColors) {\n\t\t\t\t\tthis._colorUniform[0] = 1;\n\t\t\t\t\tthis._colorUniform[1] = 1;\n\t\t\t\t\tthis._colorUniform[2] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\t\t\tthis._colorUniform[2] = this._color.b;\n\t\t\t\t}\n\n\t\t\t\tmi.setParameter(\"material_emissive\", this._colorUniform);\n\t\t\t\tmi.setParameter(\"material_opacity\", this._color.a);\n\t\t\t\tmi.setParameter(\"font_sdfIntensity\", this._font.intensity);\n\t\t\t\tmi.setParameter(\"font_pxrange\", this._getPxRange(this._font));\n\t\t\t\tmi.setParameter(\"font_textureWidth\", this._font.data.info.maps[i].width);\n\t\t\t\tthis._outlineColorUniform[0] = this._outlineColor.r;\n\t\t\t\tthis._outlineColorUniform[1] = this._outlineColor.g;\n\t\t\t\tthis._outlineColorUniform[2] = this._outlineColor.b;\n\t\t\t\tthis._outlineColorUniform[3] = this._outlineColor.a;\n\t\t\t\tmi.setParameter(\"outline_color\", this._outlineColorUniform);\n\t\t\t\tmi.setParameter(\"outline_thickness\", this._outlineThicknessScale * this._outlineThickness);\n\t\t\t\tthis._shadowColorUniform[0] = this._shadowColor.r;\n\t\t\t\tthis._shadowColorUniform[1] = this._shadowColor.g;\n\t\t\t\tthis._shadowColorUniform[2] = this._shadowColor.b;\n\t\t\t\tthis._shadowColorUniform[3] = this._shadowColor.a;\n\t\t\t\tmi.setParameter(\"shadow_color\", this._shadowColorUniform);\n\t\t\t\tconst ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;\n\t\t\t\tthis._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;\n\t\t\t\tthis._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;\n\t\t\t\tmi.setParameter(\"shadow_offset\", this._shadowOffsetUniform);\n\t\t\t\tmeshInfo.meshInstance = mi;\n\n\t\t\t\tthis._model.meshInstances.push(mi);\n\t\t\t}\n\t\t}\n\n\t\tif (this._element.maskedBy) {\n\t\t\tthis._element._setMaskedBy(this._element.maskedBy);\n\t\t}\n\n\t\tif (removedModel && this._element.enabled && this._entity.enabled) {\n\t\t\tthis._element.addModelToLayers(this._model);\n\t\t}\n\n\t\tthis._updateMeshes();\n\n\t\tthis._rangeStart = 0;\n\t\tthis._rangeEnd = this._symbols.length;\n\n\t\tthis._updateRenderRange();\n\t}\n\n\t_removeMeshInstance(meshInstance) {\n\t\tmeshInstance.destroy();\n\n\t\tconst idx = this._model.meshInstances.indexOf(meshInstance);\n\n\t\tif (idx !== -1) this._model.meshInstances.splice(idx, 1);\n\t}\n\n\t_setMaterial(material) {\n\t\tthis._material = material;\n\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.material = material;\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateMaterial(screenSpace) {\n\t\tconst element = this._element;\n\n\t\tconst screenCulled = element._isScreenCulled();\n\n\t\tconst visibleFn = function visibleFn(camera) {\n\t\t\treturn element.isVisibleForCamera(camera);\n\t\t};\n\n\t\tconst msdf = this._font && this._font.type === FONT_MSDF;\n\t\tthis._material = this._system.getTextElementMaterial(screenSpace, msdf);\n\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.cull = !screenSpace;\n\t\t\t\tmi.material = this._material;\n\t\t\t\tmi.screenSpace = screenSpace;\n\n\t\t\t\tif (screenCulled) {\n\t\t\t\t\tmi.cull = true;\n\t\t\t\t\tmi.isVisibleFunc = visibleFn;\n\t\t\t\t} else {\n\t\t\t\t\tmi.isVisibleFunc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_isWordBoundary(char) {\n\t\treturn WORD_BOUNDARY_CHAR.test(char);\n\t}\n\n\t_isValidNextChar(nextchar) {\n\t\treturn nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);\n\t}\n\n\t_isNextCJKBoundary(char, nextchar) {\n\t\treturn CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));\n\t}\n\n\t_isNextCJKWholeWord(nextchar) {\n\t\treturn CJK_CHAR.test(nextchar);\n\t}\n\n\t_updateMeshes() {\n\t\tconst json = this._font.data;\n\t\tconst self = this;\n\t\tconst minFont = Math.min(this._minFontSize, this._maxFontSize);\n\t\tconst maxFont = this._maxFontSize;\n\n\t\tconst autoFit = this._shouldAutoFit();\n\n\t\tif (autoFit) {\n\t\t\tthis._fontSize = this._maxFontSize;\n\t\t}\n\n\t\tconst MAGIC = 32;\n\t\tconst l = this._symbols.length;\n\t\tlet _x = 0;\n\t\tlet _y = 0;\n\t\tlet _z = 0;\n\t\tlet _xMinusTrailingWhitespace = 0;\n\t\tlet lines = 1;\n\t\tlet wordStartX = 0;\n\t\tlet wordStartIndex = 0;\n\t\tlet lineStartIndex = 0;\n\t\tlet numWordsThisLine = 0;\n\t\tlet numCharsThisLine = 0;\n\t\tlet numBreaksThisLine = 0;\n\t\tconst splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;\n\t\tlet maxLineWidth = this._element.calculatedWidth;\n\n\t\tif (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {\n\t\t\tmaxLineWidth = Number.POSITIVE_INFINITY;\n\t\t}\n\n\t\tlet fontMinY = 0;\n\t\tlet fontMaxY = 0;\n\t\tlet char, data, quad, nextchar;\n\n\t\tfunction breakLine(symbols, lineBreakIndex, lineBreakX) {\n\t\t\tself._lineWidths.push(Math.abs(lineBreakX));\n\n\t\t\tconst sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;\n\t\t\tconst sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;\n\t\t\tconst chars = symbols.slice(sliceStart, sliceEnd);\n\n\t\t\tif (numBreaksThisLine) {\n\t\t\t\tlet i = chars.length;\n\n\t\t\t\twhile (i-- && numBreaksThisLine > 0) {\n\t\t\t\t\tif (LINE_BREAK_CHAR.test(chars[i])) {\n\t\t\t\t\t\tchars.splice(i, 1);\n\t\t\t\t\t\tnumBreaksThisLine--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tself._lineContents.push(chars.join(''));\n\n\t\t\t_x = 0;\n\t\t\t_y -= self._scaledLineHeight;\n\t\t\tlines++;\n\t\t\tnumWordsThisLine = 0;\n\t\t\tnumCharsThisLine = 0;\n\t\t\tnumBreaksThisLine = 0;\n\t\t\twordStartX = 0;\n\t\t\tlineStartIndex = lineBreakIndex;\n\t\t}\n\n\t\tlet retryUpdateMeshes = true;\n\n\t\twhile (retryUpdateMeshes) {\n\t\t\tretryUpdateMeshes = false;\n\n\t\t\tif (autoFit) {\n\t\t\t\tthis._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);\n\t\t\t} else {\n\t\t\t\tthis._scaledLineHeight = this._lineHeight;\n\t\t\t}\n\n\t\t\tthis.width = 0;\n\t\t\tthis.height = 0;\n\t\t\tthis._lineWidths = [];\n\t\t\tthis._lineContents = [];\n\t\t\t_x = 0;\n\t\t\t_y = 0;\n\t\t\t_z = 0;\n\t\t\t_xMinusTrailingWhitespace = 0;\n\t\t\tlines = 1;\n\t\t\twordStartX = 0;\n\t\t\twordStartIndex = 0;\n\t\t\tlineStartIndex = 0;\n\t\t\tnumWordsThisLine = 0;\n\t\t\tnumCharsThisLine = 0;\n\t\t\tnumBreaksThisLine = 0;\n\t\t\tconst scale = this._fontSize / MAGIC;\n\t\t\tfontMinY = this._fontMinY * scale;\n\t\t\tfontMaxY = this._fontMaxY * scale;\n\n\t\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\t\tthis._meshInfo[i].quad = 0;\n\t\t\t\tthis._meshInfo[i].lines = {};\n\t\t\t}\n\n\t\t\tlet color_r = 255;\n\t\t\tlet color_g = 255;\n\t\t\tlet color_b = 255;\n\n\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\tchar = this._symbols[i];\n\t\t\t\tnextchar = i + 1 >= l ? null : this._symbols[i + 1];\n\t\t\t\tconst isLineBreak = LINE_BREAK_CHAR.test(char);\n\n\t\t\t\tif (isLineBreak) {\n\t\t\t\t\tnumBreaksThisLine++;\n\n\t\t\t\t\tif (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {\n\t\t\t\t\t\tbreakLine(this._symbols, i, _xMinusTrailingWhitespace);\n\t\t\t\t\t\twordStartIndex = i + 1;\n\t\t\t\t\t\tlineStartIndex = i + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet x = 0;\n\t\t\t\tlet y = 0;\n\t\t\t\tlet advance = 0;\n\t\t\t\tlet quadsize = 1;\n\t\t\t\tlet dataScale, size;\n\t\t\t\tdata = json.chars[char];\n\n\t\t\t\tif (!data) {\n\t\t\t\t\tif (CONTROL_CHARS.indexOf(char) !== -1) {\n\t\t\t\t\t\tdata = CONTROL_GLYPH_DATA;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (json.chars[' ']) {\n\t\t\t\t\t\t\tdata = json.chars[' '];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (const key in json.chars) {\n\t\t\t\t\t\t\t\tdata = json.chars[key];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (data) {\n\t\t\t\t\tlet kerning = 0;\n\n\t\t\t\t\tif (numCharsThisLine > 0) {\n\t\t\t\t\t\tconst kernTable = this._font.data.kerning;\n\n\t\t\t\t\t\tif (kernTable) {\n\t\t\t\t\t\t\tconst kernLeft = kernTable[string.getCodePoint(this._symbols[i - 1]) || 0];\n\n\t\t\t\t\t\t\tif (kernLeft) {\n\t\t\t\t\t\t\t\tkerning = kernLeft[string.getCodePoint(this._symbols[i]) || 0] || 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdataScale = data.scale || 1;\n\t\t\t\t\tsize = (data.width + data.height) / 2;\n\t\t\t\t\tquadsize = scale * size / dataScale;\n\t\t\t\t\tadvance = (data.xadvance + kerning) * scale;\n\t\t\t\t\tx = (data.xoffset - kerning) * scale;\n\t\t\t\t\ty = data.yoffset * scale;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`Couldn't substitute missing character: '${char}'`);\n\t\t\t\t}\n\n\t\t\t\tconst isWhitespace = WHITESPACE_CHAR.test(char);\n\t\t\t\tconst meshInfo = this._meshInfo[data && data.map || 0];\n\t\t\t\tconst candidateLineWidth = _x + this._spacing * advance;\n\n\t\t\t\tif (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {\n\t\t\t\t\tif (this._maxLines < 0 || lines < this._maxLines) {\n\t\t\t\t\t\tif (numWordsThisLine === 0) {\n\t\t\t\t\t\t\twordStartIndex = i;\n\t\t\t\t\t\t\tbreakLine(this._symbols, i, _xMinusTrailingWhitespace);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst backtrack = Math.max(i - wordStartIndex, 0);\n\n\t\t\t\t\t\t\tif (this._meshInfo.length <= 1) {\n\t\t\t\t\t\t\t\tmeshInfo.lines[lines - 1] -= backtrack;\n\t\t\t\t\t\t\t\tmeshInfo.quad -= backtrack;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst backtrackStart = wordStartIndex;\n\t\t\t\t\t\t\t\tconst backtrackEnd = i;\n\n\t\t\t\t\t\t\t\tfor (let j = backtrackStart; j < backtrackEnd; j++) {\n\t\t\t\t\t\t\t\t\tconst backChar = this._symbols[j];\n\t\t\t\t\t\t\t\t\tconst backCharData = json.chars[backChar];\n\t\t\t\t\t\t\t\t\tconst backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];\n\t\t\t\t\t\t\t\t\tbackMeshInfo.lines[lines - 1] -= 1;\n\t\t\t\t\t\t\t\t\tbackMeshInfo.quad -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ti -= backtrack + 1;\n\t\t\t\t\t\t\tbreakLine(this._symbols, wordStartIndex, wordStartX);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tquad = meshInfo.quad;\n\t\t\t\tmeshInfo.lines[lines - 1] = quad;\n\t\t\t\tlet left = _x - x;\n\t\t\t\tlet right = left + quadsize;\n\t\t\t\tconst bottom = _y - y;\n\t\t\t\tconst top = bottom + quadsize;\n\n\t\t\t\tif (this._rtl) {\n\t\t\t\t\tconst shift = quadsize - x - this._spacing * advance - x;\n\t\t\t\t\tleft -= shift;\n\t\t\t\t\tright -= shift;\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 0] = left;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 1] = bottom;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 2] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 3] = right;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 4] = bottom;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 5] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 6] = right;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 7] = top;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 8] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 9] = left;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 10] = top;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 11] = _z;\n\t\t\t\tthis.width = Math.max(this.width, candidateLineWidth);\n\t\t\t\tlet fontSize;\n\n\t\t\t\tif (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {\n\t\t\t\t\tfontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));\n\t\t\t\t\tfontSize = math.clamp(fontSize, minFont, maxFont);\n\n\t\t\t\t\tif (fontSize !== this._element.fontSize) {\n\t\t\t\t\t\tthis._fontSize = fontSize;\n\t\t\t\t\t\tretryUpdateMeshes = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.height = Math.max(this.height, fontMaxY - (_y + fontMinY));\n\n\t\t\t\tif (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {\n\t\t\t\t\tfontSize = math.clamp(this._fontSize - 1, minFont, maxFont);\n\n\t\t\t\t\tif (fontSize !== this._element.fontSize) {\n\t\t\t\t\t\tthis._fontSize = fontSize;\n\t\t\t\t\t\tretryUpdateMeshes = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_x += this._spacing * advance;\n\n\t\t\t\tif (!isWhitespace) {\n\t\t\t\t\t_xMinusTrailingWhitespace = _x;\n\t\t\t\t}\n\n\t\t\t\tif (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {\n\t\t\t\t\tnumWordsThisLine++;\n\t\t\t\t\twordStartX = _xMinusTrailingWhitespace;\n\t\t\t\t\twordStartIndex = i + 1;\n\t\t\t\t}\n\n\t\t\t\tnumCharsThisLine++;\n\n\t\t\t\tconst uv = this._getUv(char);\n\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 0] = uv[0];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 2] = uv[2];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 4] = uv[2];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 6] = uv[0];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];\n\n\t\t\t\tif (this._symbolColors) {\n\t\t\t\t\tconst colorIdx = this._symbolColors[i] * 3;\n\t\t\t\t\tcolor_r = this._colorPalette[colorIdx];\n\t\t\t\t\tcolor_g = this._colorPalette[colorIdx + 1];\n\t\t\t\t\tcolor_b = this._colorPalette[colorIdx + 2];\n\t\t\t\t}\n\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 0] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 1] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 2] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 3] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 4] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 5] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 6] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 7] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 8] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 9] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 10] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 11] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 12] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 13] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 14] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 15] = 255;\n\t\t\t\tmeshInfo.quad++;\n\t\t\t}\n\n\t\t\tif (retryUpdateMeshes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (lineStartIndex < l) {\n\t\t\t\tbreakLine(this._symbols, l, _x);\n\t\t\t}\n\t\t}\n\n\t\tthis._noResize = true;\n\t\tthis.autoWidth = this._autoWidth;\n\t\tthis.autoHeight = this._autoHeight;\n\t\tthis._noResize = false;\n\t\tconst hp = this._element.pivot.x;\n\t\tconst vp = this._element.pivot.y;\n\t\tconst ha = this._alignment.x;\n\t\tconst va = this._alignment.y;\n\n\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\tif (this._meshInfo[i].count === 0) continue;\n\t\t\tlet prevQuad = 0;\n\n\t\t\tfor (const line in this._meshInfo[i].lines) {\n\t\t\t\tconst index = this._meshInfo[i].lines[line];\n\n\t\t\t\tconst lw = this._lineWidths[parseInt(line, 10)];\n\n\t\t\t\tconst hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);\n\t\t\t\tconst voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);\n\n\t\t\t\tfor (let _quad = prevQuad; _quad <= index; _quad++) {\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 3] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 6] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 9] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 1] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 4] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 7] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 10] += voffset;\n\t\t\t\t}\n\n\t\t\t\tif (this._rtl) {\n\t\t\t\t\tfor (let _quad2 = prevQuad; _quad2 <= index; _quad2++) {\n\t\t\t\t\t\tconst idx = _quad2 * 4 * 3;\n\n\t\t\t\t\t\tfor (let vert = 0; vert < 4; ++vert) {\n\t\t\t\t\t\t\tthis._meshInfo[i].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst tmp0 = this._meshInfo[i].positions[idx + 3];\n\t\t\t\t\t\tconst tmp1 = this._meshInfo[i].positions[idx + 6];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 0] = tmp0;\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 9] = tmp1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprevQuad = index + 1;\n\t\t\t}\n\n\t\t\tconst numVertices = this._meshInfo[i].count * 4;\n\t\t\tconst vertMax = this._meshInfo[i].quad * 4;\n\t\t\tconst it = new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);\n\n\t\t\tfor (let v = 0; v < numVertices; v++) {\n\t\t\t\tif (v >= vertMax) {\n\t\t\t\t\tit.element[SEMANTIC_POSITION].set(0, 0, 0);\n\t\t\t\t\tit.element[SEMANTIC_TEXCOORD0].set(0, 0);\n\t\t\t\t\tit.element[SEMANTIC_COLOR].set(0, 0, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tit.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);\n\t\t\t\t\tit.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);\n\t\t\t\t\tit.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0], this._meshInfo[i].colors[v * 4 + 1], this._meshInfo[i].colors[v * 4 + 2], this._meshInfo[i].colors[v * 4 + 3]);\n\t\t\t\t}\n\n\t\t\t\tit.next();\n\t\t\t}\n\n\t\t\tit.end();\n\n\t\t\tthis._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);\n\n\t\t\tthis._meshInfo[i].meshInstance._aabbVer = -1;\n\t\t}\n\n\t\tthis._aabbDirty = true;\n\t}\n\n\t_onFontRender() {\n\t\tthis.font = this._font;\n\t}\n\n\t_onFontLoad(asset) {\n\t\tif (this.font !== asset.resource) {\n\t\t\tthis.font = asset.resource;\n\t\t}\n\t}\n\n\t_onFontChange(asset, name, _new, _old) {\n\t\tif (name === 'data') {\n\t\t\tthis._font.data = _new;\n\t\t\tconst maps = this._font.data.info.maps.length;\n\n\t\t\tfor (let i = 0; i < maps; i++) {\n\t\t\t\tif (!this._meshInfo[i]) continue;\n\t\t\t\tconst mi = this._meshInfo[i].meshInstance;\n\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.setParameter(\"font_sdfIntensity\", this._font.intensity);\n\t\t\t\t\tmi.setParameter(\"font_pxrange\", this._getPxRange(this._font));\n\t\t\t\t\tmi.setParameter(\"font_textureWidth\", this._font.data.info.maps[i].width);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onFontRemove(asset) {}\n\n\t_setTextureParams(mi, texture) {\n\t\tif (this._font) {\n\t\t\tif (this._font.type === FONT_MSDF) {\n\t\t\t\tmi.deleteParameter(\"texture_emissiveMap\");\n\t\t\t\tmi.deleteParameter(\"texture_opacityMap\");\n\t\t\t\tmi.setParameter(\"texture_msdfMap\", texture);\n\t\t\t} else if (this._font.type === FONT_BITMAP) {\n\t\t\t\tmi.deleteParameter(\"texture_msdfMap\");\n\t\t\t\tmi.setParameter(\"texture_emissiveMap\", texture);\n\t\t\t\tmi.setParameter(\"texture_opacityMap\", texture);\n\t\t\t}\n\t\t}\n\t}\n\n\t_getPxRange(font) {\n\t\tconst keys = Object.keys(this._font.data.chars);\n\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst char = this._font.data.chars[keys[i]];\n\n\t\t\tif (char.range) {\n\t\t\t\treturn (char.scale || 1) * char.range;\n\t\t\t}\n\t\t}\n\n\t\treturn 2;\n\t}\n\n\t_getUv(char) {\n\t\tconst data = this._font.data;\n\n\t\tif (!data.chars[char]) {\n\t\t\tconst space = ' ';\n\n\t\t\tif (data.chars[space]) {\n\t\t\t\treturn this._getUv(space);\n\t\t\t}\n\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\n\t\tconst map = data.chars[char].map;\n\t\tconst width = data.info.maps[map].width;\n\t\tconst height = data.info.maps[map].height;\n\t\tconst x = data.chars[char].x;\n\t\tconst y = data.chars[char].y;\n\t\tconst x1 = x;\n\t\tconst y1 = y;\n\t\tconst x2 = x + data.chars[char].width;\n\t\tconst y2 = y - data.chars[char].height;\n\t\tconst edge = 1 - data.chars[char].height / height;\n\t\treturn [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];\n\t}\n\n\tonEnable() {\n\t\tthis._fontAsset.autoLoad = true;\n\n\t\tif (this._model) {\n\t\t\tthis._element.addModelToLayers(this._model);\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tthis._fontAsset.autoLoad = false;\n\n\t\tif (this._model) {\n\t\t\tthis._element.removeModelFromLayers(this._model);\n\t\t}\n\t}\n\n\t_setStencil(stencilParams) {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0; i < instances.length; i++) {\n\t\t\t\tinstances[i].stencilFront = stencilParams;\n\t\t\t\tinstances[i].stencilBack = stencilParams;\n\t\t\t}\n\t\t}\n\t}\n\n\t_shouldAutoFitWidth() {\n\t\treturn this._autoFitWidth && !this._autoWidth;\n\t}\n\n\t_shouldAutoFitHeight() {\n\t\treturn this._autoFitHeight && !this._autoHeight;\n\t}\n\n\t_shouldAutoFit() {\n\t\treturn this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;\n\t}\n\n\t_calculateCharsPerTexture(symbolIndex) {\n\t\tconst charactersPerTexture = {};\n\n\t\tif (symbolIndex === undefined) {\n\t\t\tsymbolIndex = this._symbols.length;\n\t\t}\n\n\t\tfor (let i = 0, len = symbolIndex; i < len; i++) {\n\t\t\tconst char = this._symbols[i];\n\t\t\tlet info = this._font.data.chars[char];\n\n\t\t\tif (!info) {\n\t\t\t\tinfo = this._font.data.chars[' '];\n\n\t\t\t\tif (!info) {\n\t\t\t\t\tinfo = this._font.data.chars[Object.keys(this._font.data.chars)[0]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst map = info.map;\n\n\t\t\tif (!charactersPerTexture[map]) {\n\t\t\t\tcharactersPerTexture[map] = 1;\n\t\t\t} else {\n\t\t\t\tcharactersPerTexture[map]++;\n\t\t\t}\n\t\t}\n\n\t\treturn charactersPerTexture;\n\t}\n\n\t_updateRenderRange() {\n\t\tconst startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);\n\t\tconst endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);\n\n\t\tfor (let i = 0, len = this._meshInfo.length; i < len; i++) {\n\t\t\tconst start = startChars[i] || 0;\n\t\t\tconst end = endChars[i] || 0;\n\t\t\tconst instance = this._meshInfo[i].meshInstance;\n\n\t\t\tif (instance) {\n\t\t\t\tconst mesh = instance.mesh;\n\n\t\t\t\tif (mesh) {\n\t\t\t\t\tmesh.primitive[0].base = start * 3 * 2;\n\t\t\t\t\tmesh.primitive[0].count = (end - start) * 3 * 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset text(value) {\n\t\tthis._i18nKey = null;\n\t\tconst str = value != null && value.toString() || \"\";\n\n\t\tthis._setText(str);\n\t}\n\n\tget text() {\n\t\treturn this._text;\n\t}\n\n\tset key(value) {\n\t\tconst str = value !== null ? value.toString() : null;\n\n\t\tif (this._i18nKey === str) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._i18nKey = str;\n\n\t\tif (str) {\n\t\t\tthis._fontAsset.disableLocalization = false;\n\n\t\t\tthis._resetLocalizedText();\n\t\t} else {\n\t\t\tthis._fontAsset.disableLocalization = true;\n\t\t}\n\t}\n\n\tget key() {\n\t\treturn this._i18nKey;\n\t}\n\n\tset color(value) {\n\t\tconst r = value.r;\n\t\tconst g = value.g;\n\t\tconst b = value.b;\n\n\t\tif (this._color.r !== r || this._color.g !== g || this._color.b !== b) {\n\t\t\tthis._color.r = r;\n\t\t\tthis._color.g = g;\n\t\t\tthis._color.b = b;\n\n\t\t\tif (this._symbolColors) {\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter('material_emissive', this._colorUniform);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:color', this._color);\n\t\t}\n\t}\n\n\tget color() {\n\t\treturn this._color;\n\t}\n\n\tset opacity(value) {\n\t\tif (this._color.a !== value) {\n\t\t\tthis._color.a = value;\n\n\t\t\tif (this._model) {\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter('material_opacity', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:opacity', value);\n\t\t}\n\t}\n\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\n\tset lineHeight(value) {\n\t\tconst _prev = this._lineHeight;\n\t\tthis._lineHeight = value;\n\t\tthis._scaledLineHeight = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget lineHeight() {\n\t\treturn this._lineHeight;\n\t}\n\n\tset wrapLines(value) {\n\t\tconst _prev = this._wrapLines;\n\t\tthis._wrapLines = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget wrapLines() {\n\t\treturn this._wrapLines;\n\t}\n\n\tget lines() {\n\t\treturn this._lineContents;\n\t}\n\n\tset spacing(value) {\n\t\tconst _prev = this._spacing;\n\t\tthis._spacing = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget spacing() {\n\t\treturn this._spacing;\n\t}\n\n\tset fontSize(value) {\n\t\tconst _prev = this._fontSize;\n\t\tthis._fontSize = value;\n\t\tthis._originalFontSize = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget fontSize() {\n\t\treturn this._fontSize;\n\t}\n\n\tset fontAsset(value) {\n\t\tthis._fontAsset.defaultAsset = value;\n\t}\n\n\tget fontAsset() {\n\t\treturn this._fontAsset.localizedAsset;\n\t}\n\n\tset font(value) {\n\t\tlet previousFontType;\n\n\t\tif (this._font) {\n\t\t\tpreviousFontType = this._font.type;\n\t\t\tif (this._font.off) this._font.off('render', this._onFontRender, this);\n\t\t}\n\n\t\tthis._font = value;\n\t\tthis._fontMinY = 0;\n\t\tthis._fontMaxY = 0;\n\t\tif (!value) return;\n\t\tconst json = this._font.data;\n\n\t\tfor (const charId in json.chars) {\n\t\t\tconst data = json.chars[charId];\n\n\t\t\tif (data.bounds) {\n\t\t\t\tthis._fontMinY = Math.min(this._fontMinY, data.bounds[1]);\n\t\t\t\tthis._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);\n\t\t\t}\n\t\t}\n\n\t\tif (this._font.on) this._font.on('render', this._onFontRender, this);\n\n\t\tif (this._fontAsset.localizedAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._fontAsset.localizedAsset);\n\n\t\t\tif (asset.resource !== this._font) {\n\t\t\t\tthis._fontAsset.defaultAsset = null;\n\t\t\t}\n\t\t}\n\n\t\tif (value.type !== previousFontType) {\n\t\t\tconst screenSpace = this._element._isScreenSpace();\n\n\t\t\tthis._updateMaterial(screenSpace);\n\t\t}\n\n\t\tfor (let i = 0, len = this._font.textures.length; i < len; i++) {\n\t\t\tif (!this._meshInfo[i]) {\n\t\t\t\tthis._meshInfo[i] = new MeshInfo();\n\t\t\t} else {\n\t\t\t\tconst mi = this._meshInfo[i].meshInstance;\n\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.setParameter(\"font_sdfIntensity\", this._font.intensity);\n\t\t\t\t\tmi.setParameter(\"font_pxrange\", this._getPxRange(this._font));\n\t\t\t\t\tmi.setParameter(\"font_textureWidth\", this._font.data.info.maps[i].width);\n\n\t\t\t\t\tthis._setTextureParams(mi, this._font.textures[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet removedModel = false;\n\n\t\tfor (let i = this._font.textures.length; i < this._meshInfo.length; i++) {\n\t\t\tif (this._meshInfo[i].meshInstance) {\n\t\t\t\tif (!removedModel) {\n\t\t\t\t\tthis._element.removeModelFromLayers(this._model);\n\n\t\t\t\t\tremovedModel = true;\n\t\t\t\t}\n\n\t\t\t\tthis._removeMeshInstance(this._meshInfo[i].meshInstance);\n\t\t\t}\n\t\t}\n\n\t\tif (this._meshInfo.length > this._font.textures.length) this._meshInfo.length = this._font.textures.length;\n\n\t\tthis._updateText();\n\t}\n\n\tget font() {\n\t\treturn this._font;\n\t}\n\n\tset alignment(value) {\n\t\tif (value instanceof Vec2) {\n\t\t\tthis._alignment.set(value.x, value.y);\n\t\t} else {\n\t\t\tthis._alignment.set(value[0], value[1]);\n\t\t}\n\n\t\tif (this._font) this._updateText();\n\t}\n\n\tget alignment() {\n\t\treturn this._alignment;\n\t}\n\n\tset autoWidth(value) {\n\t\tconst old = this._autoWidth;\n\t\tthis._autoWidth = value;\n\n\t\tif (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {\n\t\t\tthis._element.width = this.width;\n\t\t}\n\n\t\tif (old !== value) {\n\t\t\tconst newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\n\t\t\tif (newFontSize !== this._fontSize) {\n\t\t\t\tthis._fontSize = newFontSize;\n\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget autoWidth() {\n\t\treturn this._autoWidth;\n\t}\n\n\tset autoHeight(value) {\n\t\tconst old = this._autoHeight;\n\t\tthis._autoHeight = value;\n\n\t\tif (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {\n\t\t\tthis._element.height = this.height;\n\t\t}\n\n\t\tif (old !== value) {\n\t\t\tconst newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\n\t\t\tif (newFontSize !== this._fontSize) {\n\t\t\t\tthis._fontSize = newFontSize;\n\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget autoHeight() {\n\t\treturn this._autoHeight;\n\t}\n\n\tset rtlReorder(value) {\n\t\tif (this._rtlReorder !== value) {\n\t\t\tthis._rtlReorder = value;\n\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText();\n\t\t\t}\n\t\t}\n\t}\n\n\tget rtlReorder() {\n\t\treturn this._rtlReorder;\n\t}\n\n\tset unicodeConverter(value) {\n\t\tif (this._unicodeConverter !== value) {\n\t\t\tthis._unicodeConverter = value;\n\n\t\t\tthis._setText(this._text);\n\t\t}\n\t}\n\n\tget unicodeConverter() {\n\t\treturn this._unicodeConverter;\n\t}\n\n\tget aabb() {\n\t\tif (this._aabbDirty) {\n\t\t\tlet initialized = false;\n\n\t\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\t\tif (!this._meshInfo[i].meshInstance) continue;\n\n\t\t\t\tif (!initialized) {\n\t\t\t\t\tthis._aabb.copy(this._meshInfo[i].meshInstance.aabb);\n\n\t\t\t\t\tinitialized = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._aabb.add(this._meshInfo[i].meshInstance.aabb);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._aabbDirty = false;\n\t\t}\n\n\t\treturn this._aabb;\n\t}\n\n\tset outlineColor(value) {\n\t\tconst r = value instanceof Color ? value.r : value[0];\n\t\tconst g = value instanceof Color ? value.g : value[1];\n\t\tconst b = value instanceof Color ? value.b : value[2];\n\t\tconst a = value instanceof Color ? value.a : value[3];\n\n\t\tif (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._outlineColor.r = r;\n\t\tthis._outlineColor.g = g;\n\t\tthis._outlineColor.b = b;\n\t\tthis._outlineColor.a = a;\n\n\t\tif (this._model) {\n\t\t\tthis._outlineColorUniform[0] = this._outlineColor.r;\n\t\t\tthis._outlineColorUniform[1] = this._outlineColor.g;\n\t\t\tthis._outlineColorUniform[2] = this._outlineColor.b;\n\t\t\tthis._outlineColorUniform[3] = this._outlineColor.a;\n\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter(\"outline_color\", this._outlineColorUniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tget outlineColor() {\n\t\treturn this._outlineColor;\n\t}\n\n\tset outlineThickness(value) {\n\t\tconst _prev = this._outlineThickness;\n\t\tthis._outlineThickness = value;\n\n\t\tif (_prev !== value && this._font) {\n\t\t\tif (this._model) {\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter(\"outline_thickness\", this._outlineThicknessScale * this._outlineThickness);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget outlineThickness() {\n\t\treturn this._outlineThickness;\n\t}\n\n\tset shadowColor(value) {\n\t\tconst r = value instanceof Color ? value.r : value[0];\n\t\tconst g = value instanceof Color ? value.g : value[1];\n\t\tconst b = value instanceof Color ? value.b : value[2];\n\t\tconst a = value instanceof Color ? value.a : value[3];\n\n\t\tif (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._shadowColor.r = r;\n\t\tthis._shadowColor.g = g;\n\t\tthis._shadowColor.b = b;\n\t\tthis._shadowColor.a = a;\n\n\t\tif (this._model) {\n\t\t\tthis._shadowColorUniform[0] = this._shadowColor.r;\n\t\t\tthis._shadowColorUniform[1] = this._shadowColor.g;\n\t\t\tthis._shadowColorUniform[2] = this._shadowColor.b;\n\t\t\tthis._shadowColorUniform[3] = this._shadowColor.a;\n\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter(\"shadow_color\", this._shadowColorUniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tget shadowColor() {\n\t\treturn this._shadowColor;\n\t}\n\n\tset shadowOffset(value) {\n\t\tconst x = value instanceof Vec2 ? value.x : value[0],\n\t\t\t\t\ty = value instanceof Vec2 ? value.y : value[1];\n\n\t\tif (this._shadowOffset.x === x && this._shadowOffset.y === y) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._shadowOffset.set(x, y);\n\n\t\tif (this._font && this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;\n\t\t\t\tthis._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;\n\t\t\t\tthis._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter(\"shadow_offset\", this._shadowOffsetUniform);\n\t\t\t}\n\t\t}\n\t}\n\n\tget shadowOffset() {\n\t\treturn this._shadowOffset;\n\t}\n\n\tset minFontSize(value) {\n\t\tif (this._minFontSize === value) return;\n\t\tthis._minFontSize = value;\n\n\t\tif (this.font && this._shouldAutoFit()) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget minFontSize() {\n\t\treturn this._minFontSize;\n\t}\n\n\tset maxFontSize(value) {\n\t\tif (this._maxFontSize === value) return;\n\t\tthis._maxFontSize = value;\n\n\t\tif (this.font && this._shouldAutoFit()) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget maxFontSize() {\n\t\treturn this._maxFontSize;\n\t}\n\n\tset autoFitWidth(value) {\n\t\tif (this._autoFitWidth === value) return;\n\t\tthis._autoFitWidth = value;\n\t\tthis._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget autoFitWidth() {\n\t\treturn this._autoFitWidth;\n\t}\n\n\tset autoFitHeight(value) {\n\t\tif (this._autoFitHeight === value) return;\n\t\tthis._autoFitHeight = value;\n\t\tthis._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget autoFitHeight() {\n\t\treturn this._autoFitHeight;\n\t}\n\n\tset maxLines(value) {\n\t\tif (this._maxLines === value) return;\n\t\tif (value === null && this._maxLines === -1) return;\n\t\tthis._maxLines = value === null ? -1 : value;\n\n\t\tif (this.font && this._wrapLines) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget maxLines() {\n\t\treturn this._maxLines;\n\t}\n\n\tset enableMarkup(value) {\n\t\tvalue = !!value;\n\t\tif (this._enableMarkup === value) return;\n\t\tthis._enableMarkup = value;\n\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\n\tget enableMarkup() {\n\t\treturn this._enableMarkup;\n\t}\n\n\tget symbols() {\n\t\treturn this._symbols;\n\t}\n\n\tget symbolColors() {\n\t\tif (this._symbolColors === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._symbolColors.map(function (c) {\n\t\t\treturn this._colorPalette.slice(c * 3, c * 3 + 3);\n\t\t}, this);\n\t}\n\n\tget rtl() {\n\t\treturn this._rtl;\n\t}\n\n\tset rangeStart(rangeStart) {\n\t\trangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));\n\n\t\tif (rangeStart !== this._rangeStart) {\n\t\t\tthis._rangeStart = rangeStart;\n\n\t\t\tthis._updateRenderRange();\n\t\t}\n\t}\n\n\tget rangeStart() {\n\t\treturn this._rangeStart;\n\t}\n\n\tset rangeEnd(rangeEnd) {\n\t\trangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));\n\n\t\tif (rangeEnd !== this._rangeEnd) {\n\t\t\tthis._rangeEnd = rangeEnd;\n\n\t\t\tthis._updateRenderRange();\n\t\t}\n\t}\n\n\tget rangeEnd() {\n\t\treturn this._rangeEnd;\n\t}\n\n}\n\nconst position = new Vec3();\nconst invParentWtm = new Mat4();\nconst vecA$1 = new Vec3();\nconst vecB$1 = new Vec3();\nconst matA = new Mat4();\nconst matB = new Mat4();\nconst matC = new Mat4();\nconst matD = new Mat4();\n\nclass ElementComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._beingInitialized = false;\n\t\tthis._anchor = new Vec4();\n\t\tthis._localAnchor = new Vec4();\n\t\tthis._pivot = new Vec2();\n\t\tthis._width = this._calculatedWidth = 32;\n\t\tthis._height = this._calculatedHeight = 32;\n\t\tthis._margin = new Vec4(0, 0, -32, -32);\n\t\tthis._modelTransform = new Mat4();\n\t\tthis._screenToWorld = new Mat4();\n\t\tthis._anchorTransform = new Mat4();\n\t\tthis._anchorDirty = true;\n\t\tthis._parentWorldTransform = new Mat4();\n\t\tthis._screenTransform = new Mat4();\n\t\tthis._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\t\tthis._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];\n\t\tthis._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\t\tthis._cornersDirty = true;\n\t\tthis._canvasCornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\t\tthis.entity.on('insert', this._onInsert, this);\n\n\t\tthis._patch();\n\n\t\tthis.screen = null;\n\t\tthis._type = ELEMENTTYPE_GROUP;\n\t\tthis._image = null;\n\t\tthis._text = null;\n\t\tthis._group = null;\n\t\tthis._drawOrder = 0;\n\t\tthis._useInput = false;\n\t\tthis._layers = [LAYERID_UI];\n\t\tthis._addedModels = [];\n\t\tthis._batchGroupId = -1;\n\t\tthis._offsetReadAt = 0;\n\t\tthis._maskOffset = 0.5;\n\t\tthis._maskedBy = null;\n\t}\n\n\tget _absLeft() {\n\t\treturn this._localAnchor.x + this._margin.x;\n\t}\n\n\tget _absRight() {\n\t\treturn this._localAnchor.z - this._margin.z;\n\t}\n\n\tget _absTop() {\n\t\treturn this._localAnchor.w - this._margin.w;\n\t}\n\n\tget _absBottom() {\n\t\treturn this._localAnchor.y + this._margin.y;\n\t}\n\n\tget _hasSplitAnchorsX() {\n\t\treturn Math.abs(this._anchor.x - this._anchor.z) > 0.001;\n\t}\n\n\tget _hasSplitAnchorsY() {\n\t\treturn Math.abs(this._anchor.y - this._anchor.w) > 0.001;\n\t}\n\n\tget aabb() {\n\t\tif (this._image) return this._image.aabb;\n\t\tif (this._text) return this._text.aabb;\n\t\treturn null;\n\t}\n\n\tset anchor(value) {\n\t\tif (value instanceof Vec4) {\n\t\t\tthis._anchor.set(value.x, value.y, value.z, value.w);\n\t\t} else {\n\t\t\tthis._anchor.set(value[0], value[1], value[2], value[3]);\n\t\t}\n\n\t\tif (!this.entity._parent && !this.screen) {\n\t\t\tthis._calculateLocalAnchors();\n\t\t} else {\n\t\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\t\t}\n\n\t\tthis._anchorDirty = true;\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire('set:anchor', this._anchor);\n\t}\n\n\tget anchor() {\n\t\treturn this._anchor;\n\t}\n\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) return;\n\n\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\tthis.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tthis.system.app.batcher.insert(BatchGroup.ELEMENT, value, this.entity);\n\t\t}\n\n\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tif (this._image && this._image._renderable.model) {\n\t\t\t\tthis.addModelToLayers(this._image._renderable.model);\n\t\t\t} else if (this._text && this._text._model) {\n\t\t\t\tthis.addModelToLayers(this._text._model);\n\t\t\t}\n\t\t}\n\n\t\tthis._batchGroupId = value;\n\t}\n\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\n\tset bottom(value) {\n\t\tthis._margin.y = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wt = this._absTop;\n\t\tconst wb = this._localAnchor.y + value;\n\n\t\tthis._setHeight(wt - wb);\n\n\t\tp.y = value + this._calculatedHeight * this._pivot.y;\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\n\tget bottom() {\n\t\treturn this._margin.y;\n\t}\n\n\tset calculatedWidth(value) {\n\t\tthis._setCalculatedWidth(value, true);\n\t}\n\n\tget calculatedWidth() {\n\t\treturn this._calculatedWidth;\n\t}\n\n\tset calculatedHeight(value) {\n\t\tthis._setCalculatedHeight(value, true);\n\t}\n\n\tget calculatedHeight() {\n\t\treturn this._calculatedHeight;\n\t}\n\n\tget canvasCorners() {\n\t\tif (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) return this._canvasCorners;\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst screenCorners = this.screenCorners;\n\t\tconst sx = device.canvas.clientWidth / device.width;\n\t\tconst sy = device.canvas.clientHeight / device.height;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tthis._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);\n\t\t}\n\n\t\tthis._canvasCornersDirty = false;\n\t\treturn this._canvasCorners;\n\t}\n\n\tset drawOrder(value) {\n\t\tlet priority = 0;\n\n\t\tif (this.screen) {\n\t\t\tpriority = this.screen.screen.priority;\n\t\t}\n\n\t\tif (value > 0xFFFFFF) {\n\t\t\tvalue = 0xFFFFFF;\n\t\t}\n\n\t\tthis._drawOrder = (priority << 24) + value;\n\t\tthis.fire('set:draworder', this._drawOrder);\n\t}\n\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\n\tset height(value) {\n\t\tthis._height = value;\n\n\t\tif (!this._hasSplitAnchorsY) {\n\t\t\tthis._setCalculatedHeight(value, true);\n\t\t}\n\n\t\tthis.fire('set:height', this._height);\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\tset layers(value) {\n\t\tif (this._addedModels.length) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\n\t\t\t\tif (layer) {\n\t\t\t\t\tfor (let j = 0; j < this._addedModels.length; j++) {\n\t\t\t\t\t\tlayer.removeMeshInstances(this._addedModels[j].meshInstances);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._layers = value;\n\t\tif (!this.enabled || !this.entity.enabled || !this._addedModels.length) return;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tfor (let j = 0; j < this._addedModels.length; j++) {\n\t\t\t\t\tlayer.addMeshInstances(this._addedModels[j].meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset left(value) {\n\t\tthis._margin.x = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wr = this._absRight;\n\t\tconst wl = this._localAnchor.x + value;\n\n\t\tthis._setWidth(wr - wl);\n\n\t\tp.x = value + this._calculatedWidth * this._pivot.x;\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\n\tget left() {\n\t\treturn this._margin.x;\n\t}\n\n\tset margin(value) {\n\t\tthis._margin.copy(value);\n\n\t\tthis._calculateSize(true, true);\n\n\t\tthis.fire('set:margin', this._margin);\n\t}\n\n\tget margin() {\n\t\treturn this._margin;\n\t}\n\n\tget maskedBy() {\n\t\treturn this._maskedBy;\n\t}\n\n\tset pivot(value) {\n\t\tconst prevX = this._pivot.x;\n\t\tconst prevY = this._pivot.y;\n\n\t\tif (value instanceof Vec2) {\n\t\t\tthis._pivot.set(value.x, value.y);\n\t\t} else {\n\t\t\tthis._pivot.set(value[0], value[1]);\n\t\t}\n\n\t\tconst mx = this._margin.x + this._margin.z;\n\t\tconst dx = this._pivot.x - prevX;\n\t\tthis._margin.x += mx * dx;\n\t\tthis._margin.z -= mx * dx;\n\t\tconst my = this._margin.y + this._margin.w;\n\t\tconst dy = this._pivot.y - prevY;\n\t\tthis._margin.y += my * dy;\n\t\tthis._margin.w -= my * dy;\n\t\tthis._anchorDirty = true;\n\t\tthis._cornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\n\t\tthis._calculateSize(false, false);\n\n\t\tthis._flagChildrenAsDirty();\n\n\t\tthis.fire('set:pivot', this._pivot);\n\t}\n\n\tget pivot() {\n\t\treturn this._pivot;\n\t}\n\n\tset right(value) {\n\t\tthis._margin.z = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wl = this._absLeft;\n\t\tconst wr = this._localAnchor.z - value;\n\n\t\tthis._setWidth(wr - wl);\n\n\t\tp.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\n\tget right() {\n\t\treturn this._margin.z;\n\t}\n\n\tget screenCorners() {\n\t\tif (!this._cornersDirty || !this.screen) return this._screenCorners;\n\t\tconst parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];\n\n\t\tthis._screenCorners[0].set(this._absLeft, this._absBottom, 0);\n\n\t\tthis._screenCorners[1].set(this._absRight, this._absBottom, 0);\n\n\t\tthis._screenCorners[2].set(this._absRight, this._absTop, 0);\n\n\t\tthis._screenCorners[3].set(this._absLeft, this._absTop, 0);\n\n\t\tconst screenSpace = this.screen.screen.screenSpace;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tthis._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);\n\n\t\t\tif (screenSpace) this._screenCorners[i].mulScalar(this.screen.screen.scale);\n\n\t\t\tif (parentBottomLeft) {\n\t\t\t\tthis._screenCorners[i].add(parentBottomLeft);\n\t\t\t}\n\t\t}\n\n\t\tthis._cornersDirty = false;\n\t\tthis._canvasCornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\t\treturn this._screenCorners;\n\t}\n\n\tget textWidth() {\n\t\treturn this._text ? this._text.width : 0;\n\t}\n\n\tget textHeight() {\n\t\treturn this._text ? this._text.height : 0;\n\t}\n\n\tset top(value) {\n\t\tthis._margin.w = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wb = this._absBottom;\n\t\tconst wt = this._localAnchor.w - value;\n\n\t\tthis._setHeight(wt - wb);\n\n\t\tp.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\n\tget top() {\n\t\treturn this._margin.w;\n\t}\n\n\tset type(value) {\n\t\tif (value !== this._type) {\n\t\t\tthis._type = value;\n\n\t\t\tif (this._image) {\n\t\t\t\tthis._image.destroy();\n\n\t\t\t\tthis._image = null;\n\t\t\t}\n\n\t\t\tif (this._text) {\n\t\t\t\tthis._text.destroy();\n\n\t\t\t\tthis._text = null;\n\t\t\t}\n\n\t\t\tif (value === ELEMENTTYPE_IMAGE) {\n\t\t\t\tthis._image = new ImageElement(this);\n\t\t\t} else if (value === ELEMENTTYPE_TEXT) {\n\t\t\t\tthis._text = new TextElement(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset useInput(value) {\n\t\tif (this._useInput === value) return;\n\t\tthis._useInput = value;\n\n\t\tif (this.system.app.elementInput) {\n\t\t\tif (value) {\n\t\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\t\tthis.system.app.elementInput.addElement(this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._useInput === true) {\n\t\t\t\tconsole.warn(\"Elements will not get any input events because this.system.app.elementInput is not created\");\n\t\t\t}\n\t\t}\n\n\t\tthis.fire('set:useInput', value);\n\t}\n\n\tget useInput() {\n\t\treturn this._useInput;\n\t}\n\n\tset width(value) {\n\t\tthis._width = value;\n\n\t\tif (!this._hasSplitAnchorsX) {\n\t\t\tthis._setCalculatedWidth(value, true);\n\t\t}\n\n\t\tthis.fire('set:width', this._width);\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\n\tget worldCorners() {\n\t\tif (!this._worldCornersDirty) {\n\t\t\treturn this._worldCorners;\n\t\t}\n\n\t\tif (this.screen) {\n\t\t\tconst screenCorners = this.screenCorners;\n\n\t\t\tif (!this.screen.screen.screenSpace) {\n\t\t\t\tmatA.copy(this.screen.screen._screenMatrix);\n\t\t\t\tmatA.data[13] = -matA.data[13];\n\t\t\t\tmatA.mul2(this.screen.getWorldTransform(), matA);\n\n\t\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\t\tmatA.transformPoint(screenCorners[i], this._worldCorners[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst localPos = this.entity.getLocalPosition();\n\t\t\tmatA.setTranslate(-localPos.x, -localPos.y, -localPos.z);\n\t\t\tmatB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());\n\t\t\tmatC.setTranslate(localPos.x, localPos.y, localPos.z);\n\t\t\tconst entity = this.entity.parent ? this.entity.parent : this.entity;\n\t\t\tmatD.copy(entity.getWorldTransform());\n\t\t\tmatD.mul(matC).mul(matB).mul(matA);\n\t\t\tvecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA$1, this._worldCorners[0]);\n\t\t\tvecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA$1, this._worldCorners[1]);\n\t\t\tvecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA$1, this._worldCorners[2]);\n\t\t\tvecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA$1, this._worldCorners[3]);\n\t\t}\n\n\t\tthis._worldCornersDirty = false;\n\t\treturn this._worldCorners;\n\t}\n\n\t_patch() {\n\t\tthis.entity._sync = this._sync;\n\t\tthis.entity.setPosition = this._setPosition;\n\t\tthis.entity.setLocalPosition = this._setLocalPosition;\n\t}\n\n\t_unpatch() {\n\t\tthis.entity._sync = Entity.prototype._sync;\n\t\tthis.entity.setPosition = Entity.prototype.setPosition;\n\t\tthis.entity.setLocalPosition = Entity.prototype.setLocalPosition;\n\t}\n\n\t_setPosition(x, y, z) {\n\t\tif (!this.element.screen) return Entity.prototype.setPosition.call(this, x, y, z);\n\n\t\tif (x instanceof Vec3) {\n\t\t\tposition.copy(x);\n\t\t} else {\n\t\t\tposition.set(x, y, z);\n\t\t}\n\n\t\tthis.getWorldTransform();\n\t\tinvParentWtm.copy(this.element._screenToWorld).invert();\n\t\tinvParentWtm.transformPoint(position, this.localPosition);\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\t_setLocalPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localPosition.copy(x);\n\t\t} else {\n\t\t\tthis.localPosition.set(x, y, z);\n\t\t}\n\n\t\tconst element = this.element;\n\t\tconst p = this.localPosition;\n\t\tconst pvt = element._pivot;\n\t\telement._margin.x = p.x - element._calculatedWidth * pvt.x;\n\t\telement._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;\n\t\telement._margin.y = p.y - element._calculatedHeight * pvt.y;\n\t\telement._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;\n\t\tif (!this._dirtyLocal) this._dirtifyLocal();\n\t}\n\n\t_sync() {\n\t\tconst element = this.element;\n\t\tconst screen = element.screen;\n\n\t\tif (screen) {\n\t\t\tif (element._anchorDirty) {\n\t\t\t\tlet resx = 0;\n\t\t\t\tlet resy = 0;\n\t\t\t\tlet px = 0;\n\t\t\t\tlet py = 1;\n\n\t\t\t\tif (this._parent && this._parent.element) {\n\t\t\t\t\tresx = this._parent.element.calculatedWidth;\n\t\t\t\t\tresy = this._parent.element.calculatedHeight;\n\t\t\t\t\tpx = this._parent.element.pivot.x;\n\t\t\t\t\tpy = this._parent.element.pivot.y;\n\t\t\t\t} else {\n\t\t\t\t\tconst resolution = screen.screen.resolution;\n\t\t\t\t\tresx = resolution.x / screen.screen.scale;\n\t\t\t\t\tresy = resolution.y / screen.screen.scale;\n\t\t\t\t}\n\n\t\t\t\telement._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);\n\n\t\t\t\telement._anchorDirty = false;\n\n\t\t\t\telement._calculateLocalAnchors();\n\t\t\t}\n\n\t\t\tif (element._sizeDirty) {\n\t\t\t\telement._calculateSize(false, false);\n\t\t\t}\n\t\t}\n\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tconst p = this.localPosition;\n\t\t\tconst pvt = element._pivot;\n\t\t\telement._margin.x = p.x - element._calculatedWidth * pvt.x;\n\t\t\telement._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;\n\t\t\telement._margin.y = p.y - element._calculatedHeight * pvt.y;\n\t\t\telement._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\n\t\tif (!screen) {\n\t\t\tif (this._dirtyWorld) {\n\t\t\t\telement._cornersDirty = true;\n\t\t\t\telement._canvasCornersDirty = true;\n\t\t\t\telement._worldCornersDirty = true;\n\t\t\t}\n\n\t\t\treturn Entity.prototype._sync.call(this);\n\t\t}\n\n\t\tif (this._dirtyWorld) {\n\t\t\tif (this._parent === null) {\n\t\t\t\tthis.worldTransform.copy(this.localTransform);\n\t\t\t} else {\n\t\t\t\tif (this._parent.element) {\n\t\t\t\t\telement._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);\n\t\t\t\t} else {\n\t\t\t\t\telement._screenToWorld.copy(element._anchorTransform);\n\t\t\t\t}\n\n\t\t\t\telement._modelTransform.mul2(element._screenToWorld, this.localTransform);\n\n\t\t\t\tif (screen) {\n\t\t\t\t\telement._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);\n\n\t\t\t\t\tif (!screen.screen.screenSpace) {\n\t\t\t\t\t\telement._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.worldTransform.mul2(element._screenToWorld, this.localTransform);\n\t\t\t\t\tconst parentWorldTransform = element._parentWorldTransform;\n\t\t\t\t\tparentWorldTransform.setIdentity();\n\t\t\t\t\tconst parent = this._parent;\n\n\t\t\t\t\tif (parent && parent.element && parent !== screen) {\n\t\t\t\t\t\tmatA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());\n\t\t\t\t\t\tparentWorldTransform.mul2(parent.element._parentWorldTransform, matA);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst depthOffset = vecA$1;\n\t\t\t\t\tdepthOffset.set(0, 0, this.localPosition.z);\n\t\t\t\t\tconst pivotOffset = vecB$1;\n\t\t\t\t\tpivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);\n\t\t\t\t\tmatA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);\n\t\t\t\t\tmatB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());\n\t\t\t\t\tmatC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);\n\n\t\t\t\t\telement._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);\n\n\t\t\t\t\telement._cornersDirty = true;\n\t\t\t\t\telement._canvasCornersDirty = true;\n\t\t\t\t\telement._worldCornersDirty = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.worldTransform.copy(element._modelTransform);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirtyWorld = false;\n\t\t}\n\t}\n\n\t_onInsert(parent) {\n\t\tconst result = this._parseUpToScreen();\n\n\t\tthis.entity._dirtifyWorld();\n\n\t\tthis._updateScreen(result.screen);\n\n\t\tthis._dirtifyMask();\n\t}\n\n\t_dirtifyMask() {\n\t\tlet current = this.entity;\n\n\t\twhile (current) {\n\t\t\tconst next = current.parent;\n\n\t\t\tif ((next === null || next.screen) && current.element) {\n\t\t\t\tif (!this.system._prerender || !this.system._prerender.length) {\n\t\t\t\t\tthis.system._prerender = [];\n\t\t\t\t\tthis.system.app.once('prerender', this._onPrerender, this);\n\t\t\t\t}\n\n\t\t\t\tconst i = this.system._prerender.indexOf(this.entity);\n\n\t\t\t\tif (i >= 0) {\n\t\t\t\t\tthis.system._prerender.splice(i, 1);\n\t\t\t\t}\n\n\t\t\t\tconst j = this.system._prerender.indexOf(current);\n\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tthis.system._prerender.push(current);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrent = next;\n\t\t}\n\t}\n\n\t_onPrerender() {\n\t\tfor (let i = 0; i < this.system._prerender.length; i++) {\n\t\t\tconst mask = this.system._prerender[i];\n\n\t\t\tif (mask.element) {\n\t\t\t\tconst depth = 1;\n\t\t\t\tmask.element.syncMask(depth);\n\t\t\t}\n\t\t}\n\n\t\tthis.system._prerender.length = 0;\n\t}\n\n\t_bindScreen(screen) {\n\t\tscreen._bindElement(this);\n\t}\n\n\t_unbindScreen(screen) {\n\t\tscreen._unbindElement(this);\n\t}\n\n\t_updateScreen(screen) {\n\t\tif (this.screen && this.screen !== screen) {\n\t\t\tthis._unbindScreen(this.screen.screen);\n\t\t}\n\n\t\tconst previousScreen = this.screen;\n\t\tthis.screen = screen;\n\n\t\tif (this.screen) {\n\t\t\tthis._bindScreen(this.screen.screen);\n\t\t}\n\n\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\n\t\tthis.fire('set:screen', this.screen, previousScreen);\n\t\tthis._anchorDirty = true;\n\t\tconst children = this.entity.children;\n\n\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\tif (children[i].element) children[i].element._updateScreen(screen);\n\t\t}\n\n\t\tif (this.screen) this.screen.screen.syncDrawOrder();\n\t}\n\n\tsyncMask(depth) {\n\t\tconst result = this._parseUpToScreen();\n\n\t\tthis._updateMask(result.mask, depth);\n\t}\n\n\t_setMaskedBy(mask) {\n\t\tconst renderableElement = this._image || this._text;\n\n\t\tif (mask) {\n\t\t\tconst ref = mask.element._image._maskRef;\n\t\t\tconst sp = new StencilParameters({\n\t\t\t\tref: ref,\n\t\t\t\tfunc: FUNC_EQUAL\n\t\t\t});\n\n\t\t\tif (renderableElement && renderableElement._setStencil) {\n\t\t\t\trenderableElement._setStencil(sp);\n\t\t\t}\n\n\t\t\tthis._maskedBy = mask;\n\t\t} else {\n\t\t\tif (renderableElement && renderableElement._setStencil) {\n\t\t\t\trenderableElement._setStencil(null);\n\t\t\t}\n\n\t\t\tthis._maskedBy = null;\n\t\t}\n\t}\n\n\t_updateMask(currentMask, depth) {\n\t\tif (currentMask) {\n\t\t\tthis._setMaskedBy(currentMask);\n\n\t\t\tif (this.mask) {\n\t\t\t\tconst ref = currentMask.element._image._maskRef;\n\t\t\t\tconst sp = new StencilParameters({\n\t\t\t\t\tref: ref,\n\t\t\t\t\tfunc: FUNC_EQUAL,\n\t\t\t\t\tzpass: STENCILOP_INCREMENT\n\t\t\t\t});\n\n\t\t\t\tthis._image._setStencil(sp);\n\n\t\t\t\tthis._image._maskRef = depth;\n\t\t\t\tdepth++;\n\t\t\t\tcurrentMask = this.entity;\n\t\t\t}\n\n\t\t\tconst children = this.entity.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i].element) {\n\t\t\t\t\tchildren[i].element._updateMask(currentMask, depth);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mask) depth--;\n\t\t} else {\n\t\t\tthis._setMaskedBy(null);\n\n\t\t\tif (this.mask) {\n\t\t\t\tconst sp = new StencilParameters({\n\t\t\t\t\tref: depth,\n\t\t\t\t\tfunc: FUNC_ALWAYS,\n\t\t\t\t\tzpass: STENCILOP_REPLACE\n\t\t\t\t});\n\n\t\t\t\tthis._image._setStencil(sp);\n\n\t\t\t\tthis._image._maskRef = depth;\n\t\t\t\tdepth++;\n\t\t\t\tcurrentMask = this.entity;\n\t\t\t}\n\n\t\t\tconst children = this.entity.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i].element) {\n\t\t\t\t\tchildren[i].element._updateMask(currentMask, depth);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mask) depth--;\n\t\t}\n\t}\n\n\t_parseUpToScreen() {\n\t\tconst result = {\n\t\t\tscreen: null,\n\t\t\tmask: null\n\t\t};\n\t\tlet parent = this.entity._parent;\n\n\t\twhile (parent && !parent.screen) {\n\t\t\tif (parent.element && parent.element.mask) {\n\t\t\t\tif (!result.mask) result.mask = parent;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\tif (parent && parent.screen) result.screen = parent;\n\t\treturn result;\n\t}\n\n\t_onScreenResize(res) {\n\t\tthis._anchorDirty = true;\n\t\tthis._cornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\n\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\n\t\tthis.fire('screen:set:resolution', res);\n\t}\n\n\t_onScreenSpaceChange() {\n\t\tthis.fire('screen:set:screenspace', this.screen.screen.screenSpace);\n\t}\n\n\t_onScreenRemove() {\n\t\tif (this.screen) {\n\t\t\tif (this.screen._destroying) {\n\t\t\t\tthis.screen = null;\n\t\t\t} else {\n\t\t\t\tthis._updateScreen(null);\n\t\t\t}\n\t\t}\n\t}\n\n\t_calculateLocalAnchors() {\n\t\tlet resx = 1000;\n\t\tlet resy = 1000;\n\t\tconst parent = this.entity._parent;\n\n\t\tif (parent && parent.element) {\n\t\t\tresx = parent.element.calculatedWidth;\n\t\t\tresy = parent.element.calculatedHeight;\n\t\t} else if (this.screen) {\n\t\t\tconst res = this.screen.screen.resolution;\n\t\t\tconst scale = this.screen.screen.scale;\n\t\t\tresx = res.x / scale;\n\t\t\tresy = res.y / scale;\n\t\t}\n\n\t\tthis._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);\n\t}\n\n\tgetOffsetPosition(x, y) {\n\t\tconst p = this.entity.getLocalPosition().clone();\n\t\tp.x += x;\n\t\tp.y += y;\n\n\t\tthis._screenToWorld.transformPoint(p, p);\n\n\t\treturn p;\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\n\t\tif (this._image) {\n\t\t\tlayer.addMeshInstances(this._image._renderable.model.meshInstances);\n\t\t} else if (this._text) {\n\t\t\tlayer.addMeshInstances(this._text._model.meshInstances);\n\t\t}\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\n\t\tif (this._image) {\n\t\t\tlayer.removeMeshInstances(this._image._renderable.model.meshInstances);\n\t\t} else if (this._text) {\n\t\t\tlayer.removeMeshInstances(this._text._model.meshInstances);\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tif (this._image) this._image.onEnable();\n\t\tif (this._text) this._text.onEnable();\n\t\tif (this._group) this._group.onEnable();\n\n\t\tif (this.useInput && this.system.app.elementInput) {\n\t\t\tthis.system.app.elementInput.addElement(this);\n\t\t}\n\n\t\tthis.system.app.scene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tthis.system.app.batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tthis.fire(\"enableelement\");\n\t}\n\n\tonDisable() {\n\t\tthis.system.app.scene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this._image) this._image.onDisable();\n\t\tif (this._text) this._text.onDisable();\n\t\tif (this._group) this._group.onDisable();\n\n\t\tif (this.system.app.elementInput && this.useInput) {\n\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tthis.system.app.batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tthis.fire(\"disableelement\");\n\t}\n\n\tonRemove() {\n\t\tthis.entity.off('insert', this._onInsert, this);\n\n\t\tthis._unpatch();\n\n\t\tif (this._image) this._image.destroy();\n\t\tif (this._text) this._text.destroy();\n\n\t\tif (this.system.app.elementInput && this.useInput) {\n\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t}\n\n\t\tif (this.screen && this.screen.screen) {\n\t\t\tthis._unbindScreen(this.screen.screen);\n\n\t\t\tthis.screen.screen.syncDrawOrder();\n\t\t}\n\n\t\tthis.off();\n\t}\n\n\t_calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {\n\t\tif (!this.entity._parent && !this.screen) return;\n\n\t\tthis._calculateLocalAnchors();\n\n\t\tconst newWidth = this._absRight - this._absLeft;\n\t\tconst newHeight = this._absTop - this._absBottom;\n\n\t\tif (propagateCalculatedWidth) {\n\t\t\tthis._setWidth(newWidth);\n\t\t} else {\n\t\t\tthis._setCalculatedWidth(newWidth, false);\n\t\t}\n\n\t\tif (propagateCalculatedHeight) {\n\t\t\tthis._setHeight(newHeight);\n\t\t} else {\n\t\t\tthis._setCalculatedHeight(newHeight, false);\n\t\t}\n\n\t\tconst p = this.entity.getLocalPosition();\n\t\tp.x = this._margin.x + this._calculatedWidth * this._pivot.x;\n\t\tp.y = this._margin.y + this._calculatedHeight * this._pivot.y;\n\t\tthis.entity.setLocalPosition(p);\n\t\tthis._sizeDirty = false;\n\t}\n\n\t_setWidth(w) {\n\t\tthis._width = w;\n\n\t\tthis._setCalculatedWidth(w, false);\n\n\t\tthis.fire('set:width', this._width);\n\t}\n\n\t_setHeight(h) {\n\t\tthis._height = h;\n\n\t\tthis._setCalculatedHeight(h, false);\n\n\t\tthis.fire('set:height', this._height);\n\t}\n\n\t_setCalculatedWidth(value, updateMargins) {\n\t\tif (Math.abs(value - this._calculatedWidth) <= 1e-4) return;\n\t\tthis._calculatedWidth = value;\n\n\t\tthis.entity._dirtifyLocal();\n\n\t\tif (updateMargins) {\n\t\t\tconst p = this.entity.getLocalPosition();\n\t\t\tconst pvt = this._pivot;\n\t\t\tthis._margin.x = p.x - this._calculatedWidth * pvt.x;\n\t\t\tthis._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;\n\t\t}\n\n\t\tthis._flagChildrenAsDirty();\n\n\t\tthis.fire('set:calculatedWidth', this._calculatedWidth);\n\t\tthis.fire('resize', this._calculatedWidth, this._calculatedHeight);\n\t}\n\n\t_setCalculatedHeight(value, updateMargins) {\n\t\tif (Math.abs(value - this._calculatedHeight) <= 1e-4) return;\n\t\tthis._calculatedHeight = value;\n\n\t\tthis.entity._dirtifyLocal();\n\n\t\tif (updateMargins) {\n\t\t\tconst p = this.entity.getLocalPosition();\n\t\t\tconst pvt = this._pivot;\n\t\t\tthis._margin.y = p.y - this._calculatedHeight * pvt.y;\n\t\t\tthis._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;\n\t\t}\n\n\t\tthis._flagChildrenAsDirty();\n\n\t\tthis.fire('set:calculatedHeight', this._calculatedHeight);\n\t\tthis.fire('resize', this._calculatedWidth, this._calculatedHeight);\n\t}\n\n\t_flagChildrenAsDirty() {\n\t\tconst c = this.entity._children;\n\n\t\tfor (let i = 0, l = c.length; i < l; i++) {\n\t\t\tif (c[i].element) {\n\t\t\t\tc[i].element._anchorDirty = true;\n\t\t\t\tc[i].element._sizeDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\taddModelToLayers(model) {\n\t\tthis._addedModels.push(model);\n\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances(model.meshInstances);\n\t\t}\n\t}\n\n\tremoveModelFromLayers(model) {\n\t\tconst idx = this._addedModels.indexOf(model);\n\n\t\tif (idx >= 0) {\n\t\t\tthis._addedModels.splice(idx, 1);\n\t\t}\n\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances(model.meshInstances);\n\t\t}\n\t}\n\n\tgetMaskOffset() {\n\t\tconst frame = this.system.app.frame;\n\n\t\tif (this._offsetReadAt !== frame) {\n\t\t\tthis._maskOffset = 0.5;\n\t\t\tthis._offsetReadAt = frame;\n\t\t}\n\n\t\tconst mo = this._maskOffset;\n\t\tthis._maskOffset -= 0.001;\n\t\treturn mo;\n\t}\n\n\tisVisibleForCamera(camera) {\n\t\tlet clipL, clipR, clipT, clipB;\n\n\t\tif (this.maskedBy) {\n\t\t\tconst corners = this.maskedBy.element.screenCorners;\n\t\t\tclipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));\n\t\t\tclipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));\n\t\t\tclipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));\n\t\t\tclipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));\n\t\t} else {\n\t\t\tconst sw = this.system.app.graphicsDevice.width;\n\t\t\tconst sh = this.system.app.graphicsDevice.height;\n\t\t\tconst cameraWidth = camera._rect.z * sw;\n\t\t\tconst cameraHeight = camera._rect.w * sh;\n\t\t\tclipL = camera._rect.x * sw;\n\t\t\tclipR = clipL + cameraWidth;\n\t\t\tclipT = (1 - camera._rect.y) * sh;\n\t\t\tclipB = clipT - cameraHeight;\n\t\t}\n\n\t\tconst hitCorners = this.screenCorners;\n\t\tconst left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));\n\t\tconst right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));\n\t\tconst bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));\n\t\tconst top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));\n\n\t\tif (right < clipL || left > clipR || bottom > clipT || top < clipB) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t_isScreenSpace() {\n\t\tif (this.screen && this.screen.screen) {\n\t\t\treturn this.screen.screen.screenSpace;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_isScreenCulled() {\n\t\tif (this.screen && this.screen.screen) {\n\t\t\treturn this.screen.screen.cull;\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nfunction _define(name) {\n\tObject.defineProperty(ElementComponent.prototype, name, {\n\t\tget: function () {\n\t\t\tif (this._text) {\n\t\t\t\treturn this._text[name];\n\t\t\t} else if (this._image) {\n\t\t\t\treturn this._image[name];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\t\tset: function (value) {\n\t\t\tif (this._text) {\n\t\t\t\tthis._text[name] = value;\n\t\t\t} else if (this._image) {\n\t\t\t\tthis._image[name] = value;\n\t\t\t}\n\t\t}\n\t});\n}\n\n_define(\"fontSize\");\n\n_define(\"minFontSize\");\n\n_define(\"maxFontSize\");\n\n_define(\"maxLines\");\n\n_define(\"autoFitWidth\");\n\n_define(\"autoFitHeight\");\n\n_define(\"color\");\n\n_define(\"font\");\n\n_define(\"fontAsset\");\n\n_define(\"spacing\");\n\n_define(\"lineHeight\");\n\n_define(\"wrapLines\");\n\n_define(\"lines\");\n\n_define(\"alignment\");\n\n_define(\"autoWidth\");\n\n_define(\"autoHeight\");\n\n_define(\"rtlReorder\");\n\n_define(\"unicodeConverter\");\n\n_define(\"text\");\n\n_define(\"key\");\n\n_define(\"texture\");\n\n_define(\"textureAsset\");\n\n_define(\"material\");\n\n_define(\"materialAsset\");\n\n_define(\"sprite\");\n\n_define(\"spriteAsset\");\n\n_define(\"spriteFrame\");\n\n_define(\"pixelsPerUnit\");\n\n_define(\"opacity\");\n\n_define(\"rect\");\n\n_define(\"mask\");\n\n_define(\"outlineColor\");\n\n_define(\"outlineThickness\");\n\n_define(\"shadowColor\");\n\n_define(\"shadowOffset\");\n\n_define(\"enableMarkup\");\n\n_define(\"rangeStart\");\n\n_define(\"rangeEnd\");\n\nclass ElementComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$e = ['enabled'];\n\nclass ElementComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'element';\n\t\tthis.ComponentType = ElementComponent;\n\t\tthis.DataType = ElementComponentData;\n\t\tthis.schema = _schema$e;\n\t\tthis._unicodeConverter = null;\n\t\tthis._rtlReorder = null;\n\t\tthis._defaultTexture = new Texture(app.graphicsDevice, {\n\t\t\twidth: 1,\n\t\t\theight: 1,\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8\n\t\t});\n\t\tthis._defaultTexture.name = 'element-system';\n\n\t\tconst pixels = this._defaultTexture.lock();\n\n\t\tconst pixelData = new Uint8Array(4);\n\t\tpixelData[0] = 255.0;\n\t\tpixelData[1] = 255.0;\n\t\tpixelData[2] = 255.0;\n\t\tpixelData[3] = 255.0;\n\t\tpixels.set(pixelData);\n\n\t\tthis._defaultTexture.unlock();\n\n\t\tthis.defaultImageMaterial = null;\n\t\tthis.defaultImage9SlicedMaterial = null;\n\t\tthis.defaultImage9TiledMaterial = null;\n\t\tthis.defaultImageMaskMaterial = null;\n\t\tthis.defaultImage9SlicedMaskMaterial = null;\n\t\tthis.defaultImage9TiledMaskMaterial = null;\n\t\tthis.defaultScreenSpaceImageMaterial = null;\n\t\tthis.defaultScreenSpaceImage9SlicedMaterial = null;\n\t\tthis.defaultScreenSpaceImage9TiledMaterial = null;\n\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial = null;\n\t\tthis.defaultScreenSpaceImageMask9TiledMaterial = null;\n\t\tthis.defaultScreenSpaceImageMaskMaterial = null;\n\t\tthis.defaultTextMaterial = null;\n\t\tthis.defaultBitmapTextMaterial = null;\n\t\tthis.defaultScreenSpaceTextMaterial = null;\n\t\tthis.defaultScreenSpaceBitmapTextMaterial = null;\n\t\tthis.defaultImageMaterials = [];\n\t\tthis.on('beforeremove', this.onRemoveComponent, this);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._defaultTexture.destroy();\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent._beingInitialized = true;\n\n\t\tif (data.anchor !== undefined) {\n\t\t\tif (data.anchor instanceof Vec4) {\n\t\t\t\tcomponent.anchor.copy(data.anchor);\n\t\t\t} else {\n\t\t\t\tcomponent.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);\n\t\t\t}\n\t\t}\n\n\t\tif (data.pivot !== undefined) {\n\t\t\tif (data.pivot instanceof Vec2) {\n\t\t\t\tcomponent.pivot.copy(data.pivot);\n\t\t\t} else {\n\t\t\t\tcomponent.pivot.set(data.pivot[0], data.pivot[1]);\n\t\t\t}\n\t\t}\n\n\t\tconst splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;\n\t\tconst splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;\n\t\tlet _marginChange = false;\n\t\tlet color;\n\n\t\tif (data.margin !== undefined) {\n\t\t\tif (data.margin instanceof Vec4) {\n\t\t\t\tcomponent.margin.copy(data.margin);\n\t\t\t} else {\n\t\t\t\tcomponent._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);\n\t\t\t}\n\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (data.left !== undefined) {\n\t\t\tcomponent._margin.x = data.left;\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (data.bottom !== undefined) {\n\t\t\tcomponent._margin.y = data.bottom;\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (data.right !== undefined) {\n\t\t\tcomponent._margin.z = data.right;\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (data.top !== undefined) {\n\t\t\tcomponent._margin.w = data.top;\n\t\t\t_marginChange = true;\n\t\t}\n\n\t\tif (_marginChange) {\n\t\t\tcomponent.margin = component._margin;\n\t\t}\n\n\t\tlet shouldForceSetAnchor = false;\n\n\t\tif (data.width !== undefined && !splitHorAnchors) {\n\t\t\tcomponent.width = data.width;\n\t\t} else if (splitHorAnchors) {\n\t\t\tshouldForceSetAnchor = true;\n\t\t}\n\n\t\tif (data.height !== undefined && !splitVerAnchors) {\n\t\t\tcomponent.height = data.height;\n\t\t} else if (splitVerAnchors) {\n\t\t\tshouldForceSetAnchor = true;\n\t\t}\n\n\t\tif (shouldForceSetAnchor) {\n\t\t\tcomponent.anchor = component.anchor;\n\t\t}\n\n\t\tif (data.enabled !== undefined) {\n\t\t\tcomponent.enabled = data.enabled;\n\t\t}\n\n\t\tif (data.useInput !== undefined) {\n\t\t\tcomponent.useInput = data.useInput;\n\t\t}\n\n\t\tcomponent.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;\n\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tcomponent.layers = data.layers.slice(0);\n\t\t}\n\n\t\tif (data.type !== undefined) {\n\t\t\tcomponent.type = data.type;\n\t\t}\n\n\t\tif (component.type === ELEMENTTYPE_IMAGE) {\n\t\t\tif (data.rect !== undefined) {\n\t\t\t\tcomponent.rect = data.rect;\n\t\t\t}\n\n\t\t\tif (data.color !== undefined) {\n\t\t\t\tcolor = data.color;\n\n\t\t\t\tif (!(color instanceof Color)) {\n\t\t\t\t\tcolor = new Color(data.color[0], data.color[1], data.color[2]);\n\t\t\t\t}\n\n\t\t\t\tcomponent.color = color;\n\t\t\t}\n\n\t\t\tif (data.opacity !== undefined) component.opacity = data.opacity;\n\t\t\tif (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;\n\t\t\tif (data.texture) component.texture = data.texture;\n\t\t\tif (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;\n\t\t\tif (data.sprite) component.sprite = data.sprite;\n\t\t\tif (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;\n\t\t\tif (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;\n\t\t\tif (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;\n\t\t\tif (data.material) component.material = data.material;\n\n\t\t\tif (data.mask !== undefined) {\n\t\t\t\tcomponent.mask = data.mask;\n\t\t\t}\n\t\t} else if (component.type === ELEMENTTYPE_TEXT) {\n\t\t\tif (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;\n\t\t\tif (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;\n\t\t\tif (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;\n\t\t\tif (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;\n\n\t\t\tif (data.text !== null && data.text !== undefined) {\n\t\t\t\tcomponent.text = data.text;\n\t\t\t} else if (data.key !== null && data.key !== undefined) {\n\t\t\t\tcomponent.key = data.key;\n\t\t\t}\n\n\t\t\tif (data.color !== undefined) {\n\t\t\t\tcolor = data.color;\n\n\t\t\t\tif (!(color instanceof Color)) {\n\t\t\t\t\tcolor = new Color(color[0], color[1], color[2]);\n\t\t\t\t}\n\n\t\t\t\tcomponent.color = color;\n\t\t\t}\n\n\t\t\tif (data.opacity !== undefined) {\n\t\t\t\tcomponent.opacity = data.opacity;\n\t\t\t}\n\n\t\t\tif (data.spacing !== undefined) component.spacing = data.spacing;\n\n\t\t\tif (data.fontSize !== undefined) {\n\t\t\t\tcomponent.fontSize = data.fontSize;\n\t\t\t\tif (!data.lineHeight) component.lineHeight = data.fontSize;\n\t\t\t}\n\n\t\t\tif (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;\n\t\t\tif (data.maxLines !== undefined) component.maxLines = data.maxLines;\n\t\t\tif (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;\n\t\t\tif (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;\n\t\t\tif (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;\n\t\t\tif (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;\n\t\t\tif (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;\n\t\t\tif (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;\n\t\t\tif (data.font !== undefined) component.font = data.font;\n\t\t\tif (data.alignment !== undefined) component.alignment = data.alignment;\n\t\t\tif (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;\n\t\t\tif (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;\n\t\t\tif (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;\n\t\t\tif (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;\n\t\t\tif (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;\n\t\t}\n\n\t\tconst result = component._parseUpToScreen();\n\n\t\tif (result.screen) {\n\t\t\tcomponent._updateScreen(result.screen);\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\tcomponent._beingInitialized = false;\n\n\t\tif (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {\n\t\t\tcomponent._image._updateMesh(component._image.mesh);\n\t\t}\n\t}\n\n\tonRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.element;\n\t\tconst data = {\n\t\t\tenabled: source.enabled,\n\t\t\twidth: source.width,\n\t\t\theight: source.height,\n\t\t\tanchor: source.anchor.clone(),\n\t\t\tpivot: source.pivot.clone(),\n\t\t\tmargin: source.margin.clone(),\n\t\t\talignment: source.alignment && source.alignment.clone() || source.alignment,\n\t\t\tautoWidth: source.autoWidth,\n\t\t\tautoHeight: source.autoHeight,\n\t\t\ttype: source.type,\n\t\t\trect: source.rect && source.rect.clone() || source.rect,\n\t\t\trtlReorder: source.rtlReorder,\n\t\t\tunicodeConverter: source.unicodeConverter,\n\t\t\tmaterialAsset: source.materialAsset,\n\t\t\tmaterial: source.material,\n\t\t\tcolor: source.color && source.color.clone() || source.color,\n\t\t\topacity: source.opacity,\n\t\t\ttextureAsset: source.textureAsset,\n\t\t\ttexture: source.texture,\n\t\t\tspriteAsset: source.spriteAsset,\n\t\t\tsprite: source.sprite,\n\t\t\tspriteFrame: source.spriteFrame,\n\t\t\tpixelsPerUnit: source.pixelsPerUnit,\n\t\t\tspacing: source.spacing,\n\t\t\tlineHeight: source.lineHeight,\n\t\t\twrapLines: source.wrapLines,\n\t\t\tlayers: source.layers,\n\t\t\tfontSize: source.fontSize,\n\t\t\tminFontSize: source.minFontSize,\n\t\t\tmaxFontSize: source.maxFontSize,\n\t\t\tautoFitWidth: source.autoFitWidth,\n\t\t\tautoFitHeight: source.autoFitHeight,\n\t\t\tmaxLines: source.maxLines,\n\t\t\tfontAsset: source.fontAsset,\n\t\t\tfont: source.font,\n\t\t\tuseInput: source.useInput,\n\t\t\tbatchGroupId: source.batchGroupId,\n\t\t\tmask: source.mask,\n\t\t\toutlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,\n\t\t\toutlineThickness: source.outlineThickness,\n\t\t\tshadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,\n\t\t\tshadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,\n\t\t\tenableMarkup: source.enableMarkup\n\t\t};\n\n\t\tif (source.key !== undefined && source.key !== null) {\n\t\t\tdata.key = source.key;\n\t\t} else {\n\t\t\tdata.text = source.text;\n\t\t}\n\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\tgetTextElementMaterial(screenSpace, msdf) {\n\t\tif (screenSpace) {\n\t\t\tif (msdf) {\n\t\t\t\tif (!this.defaultScreenSpaceTextMaterial) {\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial = new StandardMaterial();\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.name = \"defaultScreenSpaceTextMaterial\";\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.msdfMap = this._defaultTexture;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.useLighting = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.useGammaTonemap = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.useFog = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.useSkybox = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.diffuse.set(0, 0, 0);\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.emissive.set(1, 1, 1);\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.opacity = 0.5;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.depthWrite = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.depthTest = false;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.emissiveVertexColor = true;\n\t\t\t\t\tthis.defaultScreenSpaceTextMaterial.update();\n\t\t\t\t}\n\n\t\t\t\treturn this.defaultScreenSpaceTextMaterial;\n\t\t\t}\n\n\t\t\tif (!this.defaultScreenSpaceBitmapTextMaterial) {\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial = new StandardMaterial();\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.name = \"defaultScreenSpaceBitmapTextMaterial\";\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.emissiveMap = this._defaultTexture;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.emissiveTint = true;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.opacity = 0.5;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.opacityMap = this._defaultTexture;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.opacityMapChannel = 'a';\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.useLighting = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.useGammaTonemap = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.useFog = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.useSkybox = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.diffuse.set(0, 0, 0);\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.depthWrite = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.depthTest = false;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.emissiveVertexColor = true;\n\t\t\t\tthis.defaultScreenSpaceBitmapTextMaterial.update();\n\t\t\t}\n\n\t\t\treturn this.defaultScreenSpaceBitmapTextMaterial;\n\t\t}\n\n\t\tif (msdf) {\n\t\t\tif (!this.defaultTextMaterial) {\n\t\t\t\tthis.defaultTextMaterial = new StandardMaterial();\n\t\t\t\tthis.defaultTextMaterial.name = \"defaultTextMaterial\";\n\t\t\t\tthis.defaultTextMaterial.msdfMap = this._defaultTexture;\n\t\t\t\tthis.defaultTextMaterial.useLighting = false;\n\t\t\t\tthis.defaultTextMaterial.useGammaTonemap = false;\n\t\t\t\tthis.defaultTextMaterial.useFog = false;\n\t\t\t\tthis.defaultTextMaterial.useSkybox = false;\n\t\t\t\tthis.defaultTextMaterial.diffuse.set(0, 0, 0);\n\t\t\t\tthis.defaultTextMaterial.emissive.set(1, 1, 1);\n\t\t\t\tthis.defaultTextMaterial.opacity = 0.5;\n\t\t\t\tthis.defaultTextMaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\t\tthis.defaultTextMaterial.depthWrite = false;\n\t\t\t\tthis.defaultTextMaterial.emissiveVertexColor = true;\n\t\t\t\tthis.defaultTextMaterial.update();\n\t\t\t}\n\n\t\t\treturn this.defaultTextMaterial;\n\t\t}\n\n\t\tif (!this.defaultBitmapTextMaterial) {\n\t\t\tthis.defaultBitmapTextMaterial = new StandardMaterial();\n\t\t\tthis.defaultBitmapTextMaterial.name = \"defaultBitmapTextMaterial\";\n\t\t\tthis.defaultBitmapTextMaterial.emissive.set(0.5, 0.5, 0.5);\n\t\t\tthis.defaultBitmapTextMaterial.emissiveTint = true;\n\t\t\tthis.defaultBitmapTextMaterial.emissiveMap = this._defaultTexture;\n\t\t\tthis.defaultBitmapTextMaterial.opacity = 0.5;\n\t\t\tthis.defaultBitmapTextMaterial.opacityMap = this._defaultTexture;\n\t\t\tthis.defaultBitmapTextMaterial.opacityMapChannel = 'a';\n\t\t\tthis.defaultBitmapTextMaterial.useLighting = false;\n\t\t\tthis.defaultBitmapTextMaterial.useGammaTonemap = false;\n\t\t\tthis.defaultBitmapTextMaterial.useFog = false;\n\t\t\tthis.defaultBitmapTextMaterial.useSkybox = false;\n\t\t\tthis.defaultBitmapTextMaterial.diffuse.set(0, 0, 0);\n\t\t\tthis.defaultBitmapTextMaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\tthis.defaultBitmapTextMaterial.depthWrite = false;\n\t\t\tthis.defaultBitmapTextMaterial.emissiveVertexColor = true;\n\t\t\tthis.defaultBitmapTextMaterial.update();\n\t\t}\n\n\t\treturn this.defaultBitmapTextMaterial;\n\t}\n\n\t_createBaseImageMaterial() {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.diffuse.set(0, 0, 0);\n\t\tmaterial.emissive.set(0.5, 0.5, 0.5);\n\t\tmaterial.emissiveMap = this._defaultTexture;\n\t\tmaterial.emissiveTint = true;\n\t\tmaterial.opacityMap = this._defaultTexture;\n\t\tmaterial.opacityMapChannel = \"a\";\n\t\tmaterial.opacityTint = true;\n\t\tmaterial.opacity = 0;\n\t\tmaterial.useLighting = false;\n\t\tmaterial.useGammaTonemap = false;\n\t\tmaterial.useFog = false;\n\t\tmaterial.useSkybox = false;\n\t\tmaterial.blendType = BLEND_PREMULTIPLIED;\n\t\tmaterial.depthWrite = false;\n\t\treturn material;\n\t}\n\n\tgetImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {\n\t\tif (screenSpace) {\n\t\t\tif (mask) {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMask9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.name = \"defaultScreenSpaceImageMask9SlicedMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImageMask9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMask9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.name = \"defaultScreenSpaceImageMask9TiledMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImageMask9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMaskMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.name = \"defaultScreenSpaceImageMaskMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImageMaskMaterial;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImage9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.name = \"defaultScreenSpaceImage9SlicedMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImage9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImage9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.name = \"defaultScreenSpaceImage9TiledMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImage9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.name = \"defaultScreenSpaceImageMaterial\";\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultScreenSpaceImageMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (mask) {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultImage9SlicedMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.name = \"defaultImage9SlicedMaskMaterial\";\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImage9SlicedMaskMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultImage9TiledMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.name = \"defaultImage9TiledMaskMaterial\";\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImage9TiledMaskMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultImageMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImageMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.name = \"defaultImageMaskMaterial\";\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImageMaskMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImageMaskMaterial;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultImage9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.name = \"defaultImage9SlicedMaterial\";\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImage9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultImage9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.name = \"defaultImage9TiledMaterial\";\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9TiledMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImage9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultImageMaterial) {\n\t\t\t\t\t\tthis.defaultImageMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImageMaterial.name = \"defaultImageMaterial\";\n\t\t\t\t\t\tthis.defaultImageMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImageMaterial);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.defaultImageMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tregisterUnicodeConverter(func) {\n\t\tthis._unicodeConverter = func;\n\t}\n\n\tregisterRtlReorder(func) {\n\t\tthis._rtlReorder = func;\n\t}\n\n\tgetUnicodeConverter() {\n\t\treturn this._unicodeConverter;\n\t}\n\n\tgetRtlReorder() {\n\t\treturn this._rtlReorder;\n\t}\n\n}\n\nComponent._buildAccessors(ElementComponent.prototype, _schema$e);\n\nconst MOTION_FREE = 'free';\nconst MOTION_LIMITED = 'limited';\nconst MOTION_LOCKED = 'locked';\n\nconst properties = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];\n\nclass JointComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._constraint = null;\n\t\tthis._entityA = null;\n\t\tthis._entityB = null;\n\t\tthis._breakForce = 3.4e+38;\n\t\tthis._enableCollision = true;\n\t\tthis._linearMotionX = MOTION_LOCKED;\n\t\tthis._linearLimitsX = new Vec2(0, 0);\n\t\tthis._linearSpringX = false;\n\t\tthis._linearStiffnessX = 0;\n\t\tthis._linearDampingX = 1;\n\t\tthis._linearEquilibriumX = 0;\n\t\tthis._linearMotionY = MOTION_LOCKED;\n\t\tthis._linearLimitsY = new Vec2(0, 0);\n\t\tthis._linearSpringY = false;\n\t\tthis._linearStiffnessY = 0;\n\t\tthis._linearDampingY = 1;\n\t\tthis._linearEquilibriumY = 0;\n\t\tthis._linearMotionZ = MOTION_LOCKED;\n\t\tthis._linearLimitsZ = new Vec2(0, 0);\n\t\tthis._linearSpringZ = false;\n\t\tthis._linearStiffnessZ = 0;\n\t\tthis._linearDampingZ = 1;\n\t\tthis._linearEquilibriumZ = 0;\n\t\tthis._angularMotionX = MOTION_LOCKED;\n\t\tthis._angularLimitsX = new Vec2(0, 0);\n\t\tthis._angularSpringX = false;\n\t\tthis._angularStiffnessX = 0;\n\t\tthis._angularDampingX = 1;\n\t\tthis._angularEquilibriumX = 0;\n\t\tthis._angularMotionY = MOTION_LOCKED;\n\t\tthis._angularLimitsY = new Vec2(0, 0);\n\t\tthis._angularSpringY = false;\n\t\tthis._angularStiffnessY = 0;\n\t\tthis._angularDampingY = 1;\n\t\tthis._angularEquilibriumY = 0;\n\t\tthis._angularMotionZ = MOTION_LOCKED;\n\t\tthis._angularLimitsZ = new Vec2(0, 0);\n\t\tthis._angularSpringZ = false;\n\t\tthis._angularEquilibriumZ = 0;\n\t\tthis._angularDampingZ = 1;\n\t\tthis._angularStiffnessZ = 0;\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\n\tset entityA(body) {\n\t\tthis._destroyConstraint();\n\n\t\tthis._entityA = body;\n\n\t\tthis._createConstraint();\n\t}\n\n\tget entityA() {\n\t\treturn this._entityA;\n\t}\n\n\tset entityB(body) {\n\t\tthis._destroyConstraint();\n\n\t\tthis._entityB = body;\n\n\t\tthis._createConstraint();\n\t}\n\n\tget entityB() {\n\t\treturn this._entityB;\n\t}\n\n\tset breakForce(force) {\n\t\tif (this._constraint && this._breakForce !== force) {\n\t\t\tthis._constraint.setBreakingImpulseThreshold(force);\n\n\t\t\tthis._breakForce = force;\n\t\t}\n\t}\n\n\tget breakForce() {\n\t\treturn this._breakForce;\n\t}\n\n\tset enableCollision(enableCollision) {\n\t\tthis._destroyConstraint();\n\n\t\tthis._enableCollision = enableCollision;\n\n\t\tthis._createConstraint();\n\t}\n\n\tget enableCollision() {\n\t\treturn this._enableCollision;\n\t}\n\n\tset angularLimitsX(limits) {\n\t\tif (!this._angularLimitsX.equals(limits)) {\n\t\t\tthis._angularLimitsX.copy(limits);\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularLimitsX() {\n\t\treturn this._angularLimitsX;\n\t}\n\n\tset angularMotionX(value) {\n\t\tif (this._angularMotionX !== value) {\n\t\t\tthis._angularMotionX = value;\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularMotionX() {\n\t\treturn this._angularMotionX;\n\t}\n\n\tset angularLimitsY(limits) {\n\t\tif (!this._angularLimitsY.equals(limits)) {\n\t\t\tthis._angularLimitsY.copy(limits);\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularLimitsY() {\n\t\treturn this._angularLimitsY;\n\t}\n\n\tset angularMotionY(value) {\n\t\tif (this._angularMotionY !== value) {\n\t\t\tthis._angularMotionY = value;\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularMotionY() {\n\t\treturn this._angularMotionY;\n\t}\n\n\tset angularLimitsZ(limits) {\n\t\tif (!this._angularLimitsZ.equals(limits)) {\n\t\t\tthis._angularLimitsZ.copy(limits);\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularLimitsZ() {\n\t\treturn this._angularLimitsZ;\n\t}\n\n\tset angularMotionZ(value) {\n\t\tif (this._angularMotionZ !== value) {\n\t\t\tthis._angularMotionZ = value;\n\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\n\tget angularMotionZ() {\n\t\treturn this._angularMotionZ;\n\t}\n\n\tset linearLimitsX(limits) {\n\t\tif (!this._linearLimitsX.equals(limits)) {\n\t\t\tthis._linearLimitsX.copy(limits);\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearLimitsX() {\n\t\treturn this._linearLimitsX;\n\t}\n\n\tset linearMotionX(value) {\n\t\tif (this._linearMotionX !== value) {\n\t\t\tthis._linearMotionX = value;\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearMotionX() {\n\t\treturn this._linearMotionX;\n\t}\n\n\tset linearLimitsY(limits) {\n\t\tif (!this._linearLimitsY.equals(limits)) {\n\t\t\tthis._linearLimitsY.copy(limits);\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearLimitsY() {\n\t\treturn this._linearLimitsY;\n\t}\n\n\tset linearMotionY(value) {\n\t\tif (this._linearMotionY !== value) {\n\t\t\tthis._linearMotionY = value;\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearMotionY() {\n\t\treturn this._linearMotionY;\n\t}\n\n\tset linearLimitsZ(limits) {\n\t\tif (!this._linearLimitsZ.equals(limits)) {\n\t\t\tthis._linearLimitsZ.copy(limits);\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearLimitsZ() {\n\t\treturn this._linearLimitsZ;\n\t}\n\n\tset linearMotionZ(value) {\n\t\tif (this._linearMotionZ !== value) {\n\t\t\tthis._linearMotionZ = value;\n\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\n\tget linearMotionZ() {\n\t\treturn this._linearMotionZ;\n\t}\n\n\t_convertTransform(pcTransform, ammoTransform) {\n\t\tconst pos = pcTransform.getTranslation();\n\t\tconst rot = new Quat();\n\t\trot.setFromMat4(pcTransform);\n\t\tconst ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);\n\t\tconst ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);\n\t\tammoTransform.setOrigin(ammoVec);\n\t\tammoTransform.setRotation(ammoQuat);\n\t\tAmmo.destroy(ammoVec);\n\t\tAmmo.destroy(ammoQuat);\n\t}\n\n\t_updateAngularLimits() {\n\t\tconst constraint = this._constraint;\n\n\t\tif (constraint) {\n\t\t\tlet lx, ly, lz, ux, uy, uz;\n\n\t\t\tif (this._angularMotionX === MOTION_LIMITED) {\n\t\t\t\tlx = this._angularLimitsX.x * math.DEG_TO_RAD;\n\t\t\t\tux = this._angularLimitsX.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionX === MOTION_FREE) {\n\t\t\t\tlx = 1;\n\t\t\t\tux = 0;\n\t\t\t} else {\n\t\t\t\tlx = ux = 0;\n\t\t\t}\n\n\t\t\tif (this._angularMotionY === MOTION_LIMITED) {\n\t\t\t\tly = this._angularLimitsY.x * math.DEG_TO_RAD;\n\t\t\t\tuy = this._angularLimitsY.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionY === MOTION_FREE) {\n\t\t\t\tly = 1;\n\t\t\t\tuy = 0;\n\t\t\t} else {\n\t\t\t\tly = uy = 0;\n\t\t\t}\n\n\t\t\tif (this._angularMotionZ === MOTION_LIMITED) {\n\t\t\t\tlz = this._angularLimitsZ.x * math.DEG_TO_RAD;\n\t\t\t\tuz = this._angularLimitsZ.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionZ === MOTION_FREE) {\n\t\t\t\tlz = 1;\n\t\t\t\tuz = 0;\n\t\t\t} else {\n\t\t\t\tlz = uz = 0;\n\t\t\t}\n\n\t\t\tconst limits = new Ammo.btVector3(lx, ly, lz);\n\t\t\tconstraint.setAngularLowerLimit(limits);\n\t\t\tlimits.setValue(ux, uy, uz);\n\t\t\tconstraint.setAngularUpperLimit(limits);\n\t\t\tAmmo.destroy(limits);\n\t\t}\n\t}\n\n\t_updateLinearLimits() {\n\t\tconst constraint = this._constraint;\n\n\t\tif (constraint) {\n\t\t\tlet lx, ly, lz, ux, uy, uz;\n\n\t\t\tif (this._linearMotionX === MOTION_LIMITED) {\n\t\t\t\tlx = this._linearLimitsX.x;\n\t\t\t\tux = this._linearLimitsX.y;\n\t\t\t} else if (this._linearMotionX === MOTION_FREE) {\n\t\t\t\tlx = 1;\n\t\t\t\tux = 0;\n\t\t\t} else {\n\t\t\t\tlx = ux = 0;\n\t\t\t}\n\n\t\t\tif (this._linearMotionY === MOTION_LIMITED) {\n\t\t\t\tly = this._linearLimitsY.x;\n\t\t\t\tuy = this._linearLimitsY.y;\n\t\t\t} else if (this._linearMotionY === MOTION_FREE) {\n\t\t\t\tly = 1;\n\t\t\t\tuy = 0;\n\t\t\t} else {\n\t\t\t\tly = uy = 0;\n\t\t\t}\n\n\t\t\tif (this._linearMotionZ === MOTION_LIMITED) {\n\t\t\t\tlz = this._linearLimitsZ.x;\n\t\t\t\tuz = this._linearLimitsZ.y;\n\t\t\t} else if (this._linearMotionZ === MOTION_FREE) {\n\t\t\t\tlz = 1;\n\t\t\t\tuz = 0;\n\t\t\t} else {\n\t\t\t\tlz = uz = 0;\n\t\t\t}\n\n\t\t\tconst limits = new Ammo.btVector3(lx, ly, lz);\n\t\t\tconstraint.setLinearLowerLimit(limits);\n\t\t\tlimits.setValue(ux, uy, uz);\n\t\t\tconstraint.setLinearUpperLimit(limits);\n\t\t\tAmmo.destroy(limits);\n\t\t}\n\t}\n\n\t_createConstraint() {\n\t\tif (this._entityA && this._entityA.rigidbody) {\n\t\t\tthis._destroyConstraint();\n\n\t\t\tconst mat = new Mat4();\n\t\t\tconst bodyA = this._entityA.rigidbody.body;\n\t\t\tbodyA.activate();\n\t\t\tconst jointWtm = this.entity.getWorldTransform();\n\n\t\t\tconst entityAWtm = this._entityA.getWorldTransform();\n\n\t\t\tconst invEntityAWtm = entityAWtm.clone().invert();\n\t\t\tmat.mul2(invEntityAWtm, jointWtm);\n\t\t\tconst frameA = new Ammo.btTransform();\n\n\t\t\tthis._convertTransform(mat, frameA);\n\n\t\t\tif (this._entityB && this._entityB.rigidbody) {\n\t\t\t\tconst bodyB = this._entityB.rigidbody.body;\n\t\t\t\tbodyB.activate();\n\n\t\t\t\tconst entityBWtm = this._entityB.getWorldTransform();\n\n\t\t\t\tconst invEntityBWtm = entityBWtm.clone().invert();\n\t\t\t\tmat.mul2(invEntityBWtm, jointWtm);\n\t\t\t\tconst frameB = new Ammo.btTransform();\n\n\t\t\t\tthis._convertTransform(mat, frameB);\n\n\t\t\t\tthis._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);\n\t\t\t\tAmmo.destroy(frameB);\n\t\t\t} else {\n\t\t\t\tthis._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);\n\t\t\t}\n\n\t\t\tAmmo.destroy(frameA);\n\t\t\tconst axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst type = i < 3 ? '_linear' : '_angular';\n\n\t\t\t\tthis._constraint.enableSpring(i, this[type + 'Spring' + axis[i]]);\n\n\t\t\t\tthis._constraint.setDamping(i, this[type + 'Damping' + axis[i]]);\n\n\t\t\t\tthis._constraint.setEquilibriumPoint(i, this[type + 'Equilibrium' + axis[i]]);\n\n\t\t\t\tthis._constraint.setStiffness(i, this[type + 'Stiffness' + axis[i]]);\n\t\t\t}\n\n\t\t\tthis._constraint.setBreakingImpulseThreshold(this._breakForce);\n\n\t\t\tthis._updateLinearLimits();\n\n\t\t\tthis._updateAngularLimits();\n\n\t\t\tconst app = this.system.app;\n\t\t\tconst dynamicsWorld = app.systems.rigidbody.dynamicsWorld;\n\t\t\tdynamicsWorld.addConstraint(this._constraint, !this._enableCollision);\n\t\t}\n\t}\n\n\t_destroyConstraint() {\n\t\tif (this._constraint) {\n\t\t\tconst app = this.system.app;\n\t\t\tconst dynamicsWorld = app.systems.rigidbody.dynamicsWorld;\n\t\t\tdynamicsWorld.removeConstraint(this._constraint);\n\t\t\tAmmo.destroy(this._constraint);\n\t\t\tthis._constraint = null;\n\t\t}\n\t}\n\n\tinitFromData(data) {\n\t\tfor (const prop of properties) {\n\t\t\tif (data.hasOwnProperty(prop)) {\n\t\t\t\tif (data[prop] instanceof Vec2) {\n\t\t\t\t\tthis['_' + prop].copy(data[prop]);\n\t\t\t\t} else {\n\t\t\t\t\tthis['_' + prop] = data[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._createConstraint();\n\t}\n\n\tonEnable() {\n\t\tthis._createConstraint();\n\t}\n\n\tonDisable() {\n\t\tthis._destroyConstraint();\n\t}\n\n\t_onSetEnabled(prop, old, value) {}\n\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\t}\n\n}\n\nconst functionMap = {\n\tDamping: 'setDamping',\n\tEquilibrium: 'setEquilibriumPoint',\n\tSpring: 'enableSpring',\n\tStiffness: 'setStiffness'\n};\n['linear', 'angular'].forEach(type => {\n\t['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(name => {\n\t\t['X', 'Y', 'Z'].forEach(axis => {\n\t\t\tconst prop = type + name + axis;\n\t\t\tconst propInternal = '_' + prop;\n\t\t\tlet index = type === 'linear' ? 0 : 3;\n\t\t\tif (axis === 'Y') index += 1;\n\t\t\tif (axis === 'Z') index += 2;\n\t\t\tObject.defineProperty(JointComponent.prototype, prop, {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this[propInternal];\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\tif (this[propInternal] !== value) {\n\t\t\t\t\t\tthis[propInternal] = value;\n\n\t\t\t\t\t\tthis._constraint[functionMap[name]](index, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n});\n\nclass JointComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$d = ['enabled'];\n\nclass JointComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'joint';\n\t\tthis.app = app;\n\t\tthis.ComponentType = JointComponent;\n\t\tthis.DataType = JointComponentData;\n\t\tthis.schema = _schema$d;\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent.initFromData(data);\n\t}\n\n}\n\nComponent._buildAccessors(JointComponent.prototype, _schema$d);\n\nclass LayoutChildComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._minWidth = 0;\n\t\tthis._minHeight = 0;\n\t\tthis._maxWidth = null;\n\t\tthis._maxHeight = null;\n\t\tthis._fitWidthProportion = 0;\n\t\tthis._fitHeightProportion = 0;\n\t\tthis._excludeFromLayout = false;\n\t}\n\n\tset minWidth(value) {\n\t\tif (value !== this._minWidth) {\n\t\t\tthis._minWidth = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget minWidth() {\n\t\treturn this._minWidth;\n\t}\n\n\tset minHeight(value) {\n\t\tif (value !== this._minHeight) {\n\t\t\tthis._minHeight = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget minHeight() {\n\t\treturn this._minHeight;\n\t}\n\n\tset maxWidth(value) {\n\t\tif (value !== this._maxWidth) {\n\t\t\tthis._maxWidth = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget maxWidth() {\n\t\treturn this._maxWidth;\n\t}\n\n\tset maxHeight(value) {\n\t\tif (value !== this._maxHeight) {\n\t\t\tthis._maxHeight = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget maxHeight() {\n\t\treturn this._maxHeight;\n\t}\n\n\tset fitWidthProportion(value) {\n\t\tif (value !== this._fitWidthProportion) {\n\t\t\tthis._fitWidthProportion = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget fitWidthProportion() {\n\t\treturn this._fitWidthProportion;\n\t}\n\n\tset fitHeightProportion(value) {\n\t\tif (value !== this._fitHeightProportion) {\n\t\t\tthis._fitHeightProportion = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget fitHeightProportion() {\n\t\treturn this._fitHeightProportion;\n\t}\n\n\tset excludeFromLayout(value) {\n\t\tif (value !== this._excludeFromLayout) {\n\t\t\tthis._excludeFromLayout = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\n\tget excludeFromLayout() {\n\t\treturn this._excludeFromLayout;\n\t}\n\n}\n\nclass LayoutChildComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$c = ['enabled'];\n\nclass LayoutChildComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'layoutchild';\n\t\tthis.ComponentType = LayoutChildComponent;\n\t\tthis.DataType = LayoutChildComponentData;\n\t\tthis.schema = _schema$c;\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) component.enabled = data.enabled;\n\t\tif (data.minWidth !== undefined) component.minWidth = data.minWidth;\n\t\tif (data.minHeight !== undefined) component.minHeight = data.minHeight;\n\t\tif (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;\n\t\tif (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;\n\t\tif (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;\n\t\tif (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;\n\t\tif (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst layoutChild = entity.layoutchild;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: layoutChild.enabled,\n\t\t\tminWidth: layoutChild.minWidth,\n\t\t\tminHeight: layoutChild.minHeight,\n\t\t\tmaxWidth: layoutChild.maxWidth,\n\t\t\tmaxHeight: layoutChild.maxHeight,\n\t\t\tfitWidthProportion: layoutChild.fitWidthProportion,\n\t\t\tfitHeightProportion: layoutChild.fitHeightProportion,\n\t\t\texcludeFromLayout: layoutChild.excludeFromLayout\n\t\t});\n\t}\n\n}\n\nComponent._buildAccessors(LayoutChildComponent.prototype, _schema$c);\n\nconst FITTING_NONE = 0;\nconst FITTING_STRETCH = 1;\nconst FITTING_SHRINK = 2;\nconst FITTING_BOTH = 3;\n\nconst AXIS_MAPPINGS = {};\nAXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {\n\taxis: 'x',\n\tsize: 'width',\n\tcalculatedSize: 'calculatedWidth',\n\tminSize: 'minWidth',\n\tmaxSize: 'maxWidth',\n\tfitting: 'widthFitting',\n\tfittingProportion: 'fitWidthProportion'\n};\nAXIS_MAPPINGS[ORIENTATION_VERTICAL] = {\n\taxis: 'y',\n\tsize: 'height',\n\tcalculatedSize: 'calculatedHeight',\n\tminSize: 'minHeight',\n\tmaxSize: 'maxHeight',\n\tfitting: 'heightFitting',\n\tfittingProportion: 'fitHeightProportion'\n};\nconst OPPOSITE_ORIENTATION = {};\nOPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;\nOPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;\nconst PROPERTY_DEFAULTS = {\n\tminWidth: 0,\n\tminHeight: 0,\n\tmaxWidth: Number.POSITIVE_INFINITY,\n\tmaxHeight: Number.POSITIVE_INFINITY,\n\twidth: null,\n\theight: null,\n\tfitWidthProportion: 0,\n\tfitHeightProportion: 0\n};\nconst FITTING_ACTION = {\n\tNONE: 'NONE',\n\tAPPLY_STRETCHING: 'APPLY_STRETCHING',\n\tAPPLY_SHRINKING: 'APPLY_SHRINKING'\n};\nconst availableSpace = new Vec2();\n\nfunction createCalculator(orientation) {\n\tlet options;\n\tconst a = AXIS_MAPPINGS[orientation];\n\tconst b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];\n\n\tfunction minExtentA(element, size) {\n\t\treturn -size[a.size] * element.pivot[a.axis];\n\t}\n\n\tfunction minExtentB(element, size) {\n\t\treturn -size[b.size] * element.pivot[b.axis];\n\t}\n\n\tfunction maxExtentA(element, size) {\n\t\treturn size[a.size] * (1 - element.pivot[a.axis]);\n\t}\n\n\tfunction calculateAll(allElements, layoutOptions) {\n\t\tallElements = allElements.filter(shouldIncludeInLayout);\n\t\toptions = layoutOptions;\n\t\tavailableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;\n\t\tavailableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;\n\t\tresetAnchors(allElements);\n\t\tconst lines = reverseLinesIfRequired(splitLines(allElements));\n\t\tconst sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));\n\t\tconst positions = calculateBasePositions(lines, sizes);\n\t\tapplyAlignmentAndPadding(lines, sizes, positions);\n\t\tapplySizesAndPositions(lines, sizes, positions);\n\t\treturn createLayoutInfo(lines);\n\t}\n\n\tfunction shouldIncludeInLayout(element) {\n\t\tconst layoutChildComponent = element.entity.layoutchild;\n\t\treturn !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;\n\t}\n\n\tfunction resetAnchors(allElements) {\n\t\tfor (let i = 0; i < allElements.length; ++i) {\n\t\t\tconst element = allElements[i];\n\t\t\tconst anchor = element.anchor;\n\n\t\t\tif (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {\n\t\t\t\telement.anchor = Vec4.ZERO;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction splitLines(allElements) {\n\t\tif (!options.wrap) {\n\t\t\treturn [allElements];\n\t\t}\n\n\t\tconst lines = [[]];\n\t\tconst sizes = getElementSizeProperties(allElements);\n\t\tlet runningSize = 0;\n\t\tconst allowOverrun = options[a.fitting] === FITTING_SHRINK;\n\n\t\tfor (let i = 0; i < allElements.length; ++i) {\n\t\t\tif (lines[lines.length - 1].length > 0) {\n\t\t\t\trunningSize += options.spacing[a.axis];\n\t\t\t}\n\n\t\t\tconst idealElementSize = sizes[i][a.size];\n\t\t\trunningSize += idealElementSize;\n\n\t\t\tif (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {\n\t\t\t\trunningSize = idealElementSize;\n\t\t\t\tlines.push([]);\n\t\t\t}\n\n\t\t\tlines[lines.length - 1].push(allElements[i]);\n\n\t\t\tif (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {\n\t\t\t\trunningSize = 0;\n\t\t\t\tlines.push([]);\n\t\t\t}\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\tfunction reverseLinesIfRequired(lines) {\n\t\tconst reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;\n\t\tconst reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;\n\n\t\tif (reverseAxisA) {\n\t\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\t\tif (reverseAxisA) {\n\t\t\t\t\tlines[lineIndex].reverse();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (reverseAxisB) {\n\t\t\tlines.reverse();\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\tfunction calculateSizesOnAxisA(lines) {\n\t\tconst sizesAllLines = [];\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = getElementSizeProperties(line);\n\t\t\tconst idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);\n\t\t\tconst fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);\n\n\t\t\tif (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\t\tstretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);\n\t\t\t} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\t\tshrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);\n\t\t\t}\n\n\t\t\tsizesAllLines.push(sizesThisLine);\n\t\t}\n\n\t\treturn sizesAllLines;\n\t}\n\n\tfunction calculateSizesOnAxisB(lines, sizesAllLines) {\n\t\tconst largestElementsForEachLine = [];\n\t\tconst largestSizesForEachLine = [];\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tline.largestElement = null;\n\t\t\tline.largestSize = {\n\t\t\t\twidth: Number.NEGATIVE_INFINITY,\n\t\t\t\theight: Number.NEGATIVE_INFINITY\n\t\t\t};\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst sizesThisElement = sizesAllLines[lineIndex][elementIndex];\n\n\t\t\t\tif (sizesThisElement[b.size] > line.largestSize[b.size]) {\n\t\t\t\t\tline.largestElement = line[elementIndex];\n\t\t\t\t\tline.largestSize = sizesThisElement;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlargestElementsForEachLine.push(line.largestElement);\n\t\t\tlargestSizesForEachLine.push(line.largestSize);\n\t\t}\n\n\t\tconst idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);\n\t\tconst fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);\n\n\t\tif (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\tstretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);\n\t\t} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\tshrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);\n\t\t}\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst sizesForThisElement = sizesAllLines[lineIndex][elementIndex];\n\t\t\t\tconst currentSize = sizesForThisElement[b.size];\n\t\t\t\tconst availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];\n\t\t\t\tconst elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);\n\n\t\t\t\tif (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\t\t\tsizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);\n\t\t\t\t} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\t\t\tsizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn sizesAllLines;\n\t}\n\n\tfunction determineFittingAction(fittingMode, currentSize, availableSize) {\n\t\tswitch (fittingMode) {\n\t\t\tcase FITTING_NONE:\n\t\t\t\treturn FITTING_ACTION.NONE;\n\n\t\t\tcase FITTING_STRETCH:\n\t\t\t\tif (currentSize < availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_STRETCHING;\n\t\t\t\t}\n\n\t\t\t\treturn FITTING_ACTION.NONE;\n\n\t\t\tcase FITTING_SHRINK:\n\t\t\t\tif (currentSize >= availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_SHRINKING;\n\t\t\t\t}\n\n\t\t\t\treturn FITTING_ACTION.NONE;\n\n\t\t\tcase FITTING_BOTH:\n\t\t\t\tif (currentSize < availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_STRETCHING;\n\t\t\t\t}\n\n\t\t\t\treturn FITTING_ACTION.APPLY_SHRINKING;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unrecognized fitting mode: ${fittingMode}`);\n\t\t}\n\t}\n\n\tfunction calculateTotalSpace(sizes, axis) {\n\t\tconst totalSizes = sumValues(sizes, axis.size);\n\t\tconst totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];\n\t\treturn totalSizes + totalSpacing;\n\t}\n\n\tfunction stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {\n\t\tconst ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);\n\t\tconst fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);\n\t\tconst fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);\n\t\tlet remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;\n\n\t\tfor (let i = 0; i < sizesThisLine.length; ++i) {\n\t\t\tconst index = ascendingMaxSizeOrder[i];\n\t\t\tconst targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);\n\t\t\tconst targetSize = sizesThisLine[index][axis.size] + targetIncrease;\n\t\t\tconst maxSize = sizesThisLine[index][axis.maxSize];\n\t\t\tconst actualSize = Math.min(targetSize, maxSize);\n\t\t\tsizesThisLine[index][axis.size] = actualSize;\n\t\t\tconst actualIncrease = Math.max(targetSize - actualSize, 0);\n\t\t\tconst appliedIncrease = targetIncrease - actualIncrease;\n\t\t\tremainingUndershoot -= appliedIncrease;\n\t\t}\n\t}\n\n\tfunction shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {\n\t\tconst descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);\n\t\tconst fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);\n\t\tconst inverseFittingProportions = invertNormalizedValues(fittingProportions);\n\t\tconst inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);\n\t\tlet remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];\n\n\t\tfor (let i = 0; i < sizesThisLine.length; ++i) {\n\t\t\tconst index = descendingMinSizeOrder[i];\n\t\t\tconst targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);\n\t\t\tconst targetSize = sizesThisLine[index][axis.size] - targetReduction;\n\t\t\tconst minSize = sizesThisLine[index][axis.minSize];\n\t\t\tconst actualSize = Math.max(targetSize, minSize);\n\t\t\tsizesThisLine[index][axis.size] = actualSize;\n\t\t\tconst actualReduction = Math.max(actualSize - targetSize, 0);\n\t\t\tconst appliedReduction = targetReduction - actualReduction;\n\t\t\tremainingOvershoot -= appliedReduction;\n\t\t}\n\t}\n\n\tfunction calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {\n\t\tconst proportion = fittingProportions[index];\n\t\tconst sumOfRemainingProportions = fittingProportionSums[index];\n\n\t\tif (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {\n\t\t\treturn remainingAdjustment;\n\t\t}\n\n\t\treturn remainingAdjustment * proportion / sumOfRemainingProportions;\n\t}\n\n\tfunction calculateBasePositions(lines, sizes) {\n\t\tconst cursor = {};\n\t\tcursor[a.axis] = 0;\n\t\tcursor[b.axis] = 0;\n\t\tlines[a.size] = Number.NEGATIVE_INFINITY;\n\t\tconst positionsAllLines = [];\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\n\t\t\tif (line.length === 0) {\n\t\t\t\tpositionsAllLines.push([]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst positionsThisLine = [];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst element = line[elementIndex];\n\t\t\t\tconst sizesThisElement = sizesThisLine[elementIndex];\n\t\t\t\tcursor[b.axis] -= minExtentB(element, sizesThisElement);\n\t\t\t\tcursor[a.axis] -= minExtentA(element, sizesThisElement);\n\t\t\t\tpositionsThisLine[elementIndex] = {};\n\t\t\t\tpositionsThisLine[elementIndex][a.axis] = cursor[a.axis];\n\t\t\t\tpositionsThisLine[elementIndex][b.axis] = cursor[b.axis];\n\t\t\t\tcursor[b.axis] += minExtentB(element, sizesThisElement);\n\t\t\t\tcursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];\n\t\t\t}\n\n\t\t\tline[a.size] = cursor[a.axis] - options.spacing[a.axis];\n\t\t\tline[b.size] = line.largestSize[b.size];\n\t\t\tlines[a.size] = Math.max(lines[a.size], line[a.size]);\n\t\t\tcursor[a.axis] = 0;\n\t\t\tcursor[b.axis] += line[b.size] + options.spacing[b.axis];\n\t\t\tpositionsAllLines.push(positionsThisLine);\n\t\t}\n\n\t\tlines[b.size] = cursor[b.axis] - options.spacing[b.axis];\n\t\treturn positionsAllLines;\n\t}\n\n\tfunction applyAlignmentAndPadding(lines, sizes, positions) {\n\t\tconst alignmentA = options.alignment[a.axis];\n\t\tconst alignmentB = options.alignment[b.axis];\n\t\tconst paddingA = options.padding[a.axis];\n\t\tconst paddingB = options.padding[b.axis];\n\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\t\t\tconst positionsThisLine = positions[lineIndex];\n\t\t\tconst axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;\n\t\t\tconst axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];\n\t\t\t\tpositionsThisLine[elementIndex][a.axis] += axisAOffset;\n\t\t\t\tpositionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction applySizesAndPositions(lines, sizes, positions) {\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\t\t\tconst positionsThisLine = positions[lineIndex];\n\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst element = line[elementIndex];\n\t\t\t\telement[a.calculatedSize] = sizesThisLine[elementIndex][a.size];\n\t\t\t\telement[b.calculatedSize] = sizesThisLine[elementIndex][b.size];\n\n\t\t\t\tif (options.orientation === ORIENTATION_HORIZONTAL) {\n\t\t\t\t\telement.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);\n\t\t\t\t} else {\n\t\t\t\t\telement.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction createLayoutInfo(lines) {\n\t\tconst layoutWidth = lines.width;\n\t\tconst layoutHeight = lines.height;\n\t\tconst xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;\n\t\tconst yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;\n\t\treturn {\n\t\t\tbounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)\n\t\t};\n\t}\n\n\tfunction getElementSizeProperties(elements) {\n\t\tconst sizeProperties = [];\n\n\t\tfor (let i = 0; i < elements.length; ++i) {\n\t\t\tconst element = elements[i];\n\t\t\tconst minWidth = Math.max(getProperty(element, 'minWidth'), 0);\n\t\t\tconst minHeight = Math.max(getProperty(element, 'minHeight'), 0);\n\t\t\tconst maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);\n\t\t\tconst maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);\n\t\t\tconst width = clamp(getProperty(element, 'width'), minWidth, maxWidth);\n\t\t\tconst height = clamp(getProperty(element, 'height'), minHeight, maxHeight);\n\t\t\tconst fitWidthProportion = getProperty(element, 'fitWidthProportion');\n\t\t\tconst fitHeightProportion = getProperty(element, 'fitHeightProportion');\n\t\t\tsizeProperties.push({\n\t\t\t\tminWidth: minWidth,\n\t\t\t\tminHeight: minHeight,\n\t\t\t\tmaxWidth: maxWidth,\n\t\t\t\tmaxHeight: maxHeight,\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tfitWidthProportion: fitWidthProportion,\n\t\t\t\tfitHeightProportion: fitHeightProportion\n\t\t\t});\n\t\t}\n\n\t\treturn sizeProperties;\n\t}\n\n\tfunction getProperty(element, propertyName) {\n\t\tconst layoutChildComponent = element.entity.layoutchild;\n\n\t\tif (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {\n\t\t\treturn layoutChildComponent[propertyName];\n\t\t} else if (element[propertyName] !== undefined) {\n\t\t\treturn element[propertyName];\n\t\t}\n\n\t\treturn PROPERTY_DEFAULTS[propertyName];\n\t}\n\n\tfunction clamp(value, min, max) {\n\t\treturn Math.min(Math.max(value, min), max);\n\t}\n\n\tfunction sumValues(items, propertyName) {\n\t\treturn items.reduce(function (accumulator, current) {\n\t\t\treturn accumulator + current[propertyName];\n\t\t}, 0);\n\t}\n\n\tfunction getNormalizedValues(items, propertyName) {\n\t\tconst sum = sumValues(items, propertyName);\n\t\tconst normalizedValues = [];\n\t\tconst numItems = items.length;\n\n\t\tif (sum === 0) {\n\t\t\tfor (let i = 0; i < numItems; ++i) {\n\t\t\t\tnormalizedValues.push(1 / numItems);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < numItems; ++i) {\n\t\t\t\tnormalizedValues.push(items[i][propertyName] / sum);\n\t\t\t}\n\t\t}\n\n\t\treturn normalizedValues;\n\t}\n\n\tfunction invertNormalizedValues(values) {\n\t\tif (values.length === 1) {\n\t\t\treturn [1];\n\t\t}\n\n\t\tconst invertedValues = [];\n\t\tconst numValues = values.length;\n\n\t\tfor (let i = 0; i < numValues; ++i) {\n\t\t\tinvertedValues.push((1 - values[i]) / (numValues - 1));\n\t\t}\n\n\t\treturn invertedValues;\n\t}\n\n\tfunction getTraversalOrder(items, orderBy, descending) {\n\t\titems.forEach(assignIndex);\n\t\treturn items.slice().sort(function (itemA, itemB) {\n\t\t\treturn descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];\n\t\t}).map(getIndex);\n\t}\n\n\tfunction assignIndex(item, index) {\n\t\titem.index = index;\n\t}\n\n\tfunction getIndex(item) {\n\t\treturn item.index;\n\t}\n\n\tfunction createSumArray(values, order) {\n\t\tconst sumArray = [];\n\t\tsumArray[order[values.length - 1]] = values[order[values.length - 1]];\n\n\t\tfor (let i = values.length - 2; i >= 0; --i) {\n\t\t\tsumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];\n\t\t}\n\n\t\treturn sumArray;\n\t}\n\n\treturn calculateAll;\n}\n\nconst CALCULATE_FNS = {};\nCALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);\nCALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);\n\nclass LayoutCalculator {\n\tcalculateLayout(elements, options) {\n\t\tconst calculateFn = CALCULATE_FNS[options.orientation];\n\n\t\tif (!calculateFn) {\n\t\t\tthrow new Error('Unrecognized orientation value: ' + options.orientation);\n\t\t} else {\n\t\t\treturn calculateFn(elements, options);\n\t\t}\n\t}\n\n}\n\nfunction getElement(entity) {\n\treturn entity.element;\n}\n\nfunction isEnabledAndHasEnabledElement(entity) {\n\treturn entity.enabled && entity.element && entity.element.enabled;\n}\n\nclass LayoutGroupComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._orientation = ORIENTATION_HORIZONTAL;\n\t\tthis._reverseX = false;\n\t\tthis._reverseY = true;\n\t\tthis._alignment = new Vec2(0, 1);\n\t\tthis._padding = new Vec4();\n\t\tthis._spacing = new Vec2();\n\t\tthis._widthFitting = FITTING_NONE;\n\t\tthis._heightFitting = FITTING_NONE;\n\t\tthis._wrap = false;\n\t\tthis._layoutCalculator = new LayoutCalculator();\n\n\t\tthis._listenForReflowEvents(this.entity, 'on');\n\n\t\tthis.entity.children.forEach(child => {\n\t\t\tthis._listenForReflowEvents(child, 'on');\n\t\t});\n\t\tthis.entity.on('childinsert', this._onChildInsert, this);\n\t\tthis.entity.on('childremove', this._onChildRemove, this);\n\t\tsystem.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);\n\t\tsystem.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t\tsystem.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);\n\t\tsystem.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t}\n\n\tset orientation(value) {\n\t\tif (value !== this._orientation) {\n\t\t\tthis._orientation = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget orientation() {\n\t\treturn this._orientation;\n\t}\n\n\tset reverseX(value) {\n\t\tif (value !== this._reverseX) {\n\t\t\tthis._reverseX = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget reverseX() {\n\t\treturn this._reverseX;\n\t}\n\n\tset reverseY(value) {\n\t\tif (value !== this._reverseY) {\n\t\t\tthis._reverseY = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget reverseY() {\n\t\treturn this._reverseY;\n\t}\n\n\tset alignment(value) {\n\t\tif (!value.equals(this._alignment)) {\n\t\t\tthis._alignment.copy(value);\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget alignment() {\n\t\treturn this._alignment;\n\t}\n\n\tset padding(value) {\n\t\tif (!value.equals(this._padding)) {\n\t\t\tthis._padding.copy(value);\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget padding() {\n\t\treturn this._padding;\n\t}\n\n\tset spacing(value) {\n\t\tif (!value.equals(this._spacing)) {\n\t\t\tthis._spacing.copy(value);\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget spacing() {\n\t\treturn this._spacing;\n\t}\n\n\tset widthFitting(value) {\n\t\tif (value !== this._widthFitting) {\n\t\t\tthis._widthFitting = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget widthFitting() {\n\t\treturn this._widthFitting;\n\t}\n\n\tset heightFitting(value) {\n\t\tif (value !== this._heightFitting) {\n\t\t\tthis._heightFitting = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget heightFitting() {\n\t\treturn this._heightFitting;\n\t}\n\n\tset wrap(value) {\n\t\tif (value !== this._wrap) {\n\t\t\tthis._wrap = value;\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\tget wrap() {\n\t\treturn this._wrap;\n\t}\n\n\t_isSelfOrChild(entity) {\n\t\treturn entity === this.entity || this.entity.children.indexOf(entity) !== -1;\n\t}\n\n\t_listenForReflowEvents(target, onOff) {\n\t\tif (target.element) {\n\t\t\ttarget.element[onOff]('enableelement', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('disableelement', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('resize', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('set:pivot', this._scheduleReflow, this);\n\t\t}\n\n\t\tif (target.layoutchild) {\n\t\t\ttarget.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);\n\t\t\ttarget.layoutchild[onOff]('resize', this._scheduleReflow, this);\n\t\t}\n\t}\n\n\t_onElementOrLayoutComponentAdd(entity) {\n\t\tif (this._isSelfOrChild(entity)) {\n\t\t\tthis._listenForReflowEvents(entity, 'on');\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\t_onElementOrLayoutComponentRemove(entity) {\n\t\tif (this._isSelfOrChild(entity)) {\n\t\t\tthis._listenForReflowEvents(entity, 'off');\n\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\n\t_onChildInsert(child) {\n\t\tthis._listenForReflowEvents(child, 'on');\n\n\t\tthis._scheduleReflow();\n\t}\n\n\t_onChildRemove(child) {\n\t\tthis._listenForReflowEvents(child, 'off');\n\n\t\tthis._scheduleReflow();\n\t}\n\n\t_scheduleReflow() {\n\t\tif (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {\n\t\t\tthis.system.scheduleReflow(this);\n\t\t}\n\t}\n\n\treflow() {\n\t\tconst container = getElement(this.entity);\n\t\tconst elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);\n\n\t\tif (!container || elements.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst containerWidth = Math.max(container.calculatedWidth, 0);\n\t\tconst containerHeight = Math.max(container.calculatedHeight, 0);\n\t\tconst options = {\n\t\t\torientation: this._orientation,\n\t\t\treverseX: this._reverseX,\n\t\t\treverseY: this._reverseY,\n\t\t\talignment: this._alignment,\n\t\t\tpadding: this._padding,\n\t\t\tspacing: this._spacing,\n\t\t\twidthFitting: this._widthFitting,\n\t\t\theightFitting: this._heightFitting,\n\t\t\twrap: this._wrap,\n\t\t\tcontainerSize: new Vec2(containerWidth, containerHeight)\n\t\t};\n\t\tthis._isPerformingReflow = true;\n\n\t\tconst layoutInfo = this._layoutCalculator.calculateLayout(elements, options);\n\n\t\tthis._isPerformingReflow = false;\n\t\tthis.fire('reflow', layoutInfo);\n\t}\n\n\tonEnable() {\n\t\tthis._scheduleReflow();\n\t}\n\n\tonRemove() {\n\t\tthis.entity.off('childinsert', this._onChildInsert, this);\n\t\tthis.entity.off('childremove', this._onChildRemove, this);\n\n\t\tthis._listenForReflowEvents(this.entity, 'off');\n\n\t\tthis.entity.children.forEach(child => {\n\t\t\tthis._listenForReflowEvents(child, 'off');\n\t\t});\n\t\tthis.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);\n\t\tthis.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t\tthis.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);\n\t\tthis.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t}\n\n}\n\nclass LayoutGroupComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$b = ['enabled'];\nconst MAX_ITERATIONS = 100;\n\nclass LayoutGroupComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'layoutgroup';\n\t\tthis.ComponentType = LayoutGroupComponent;\n\t\tthis.DataType = LayoutGroupComponentData;\n\t\tthis.schema = _schema$b;\n\t\tthis._reflowQueue = [];\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('postUpdate', this._onPostUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) component.enabled = data.enabled;\n\t\tif (data.orientation !== undefined) component.orientation = data.orientation;\n\t\tif (data.reverseX !== undefined) component.reverseX = data.reverseX;\n\t\tif (data.reverseY !== undefined) component.reverseY = data.reverseY;\n\n\t\tif (data.alignment !== undefined) {\n\t\t\tcomponent.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;\n\t\t}\n\n\t\tif (data.padding !== undefined) {\n\t\t\tcomponent.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;\n\t\t}\n\n\t\tif (data.spacing !== undefined) {\n\t\t\tcomponent.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;\n\t\t}\n\n\t\tif (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;\n\t\tif (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;\n\t\tif (data.wrap !== undefined) component.wrap = data.wrap;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst layoutGroup = entity.layoutgroup;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: layoutGroup.enabled,\n\t\t\torientation: layoutGroup.orientation,\n\t\t\treverseX: layoutGroup.reverseX,\n\t\t\treverseY: layoutGroup.reverseY,\n\t\t\talignment: layoutGroup.alignment,\n\t\t\tpadding: layoutGroup.padding,\n\t\t\tspacing: layoutGroup.spacing,\n\t\t\twidthFitting: layoutGroup.widthFitting,\n\t\t\theightFitting: layoutGroup.heightFitting,\n\t\t\twrap: layoutGroup.wrap\n\t\t});\n\t}\n\n\tscheduleReflow(component) {\n\t\tif (this._reflowQueue.indexOf(component) === -1) {\n\t\t\tthis._reflowQueue.push(component);\n\t\t}\n\t}\n\n\t_onPostUpdate() {\n\t\tthis._processReflowQueue();\n\t}\n\n\t_processReflowQueue() {\n\t\tif (this._reflowQueue.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet iterationCount = 0;\n\n\t\twhile (this._reflowQueue.length > 0) {\n\t\t\tconst queue = this._reflowQueue.slice();\n\n\t\t\tthis._reflowQueue.length = 0;\n\t\t\tqueue.sort(function (componentA, componentB) {\n\t\t\t\treturn componentA.entity.graphDepth - componentB.entity.graphDepth;\n\t\t\t});\n\n\t\t\tfor (let i = 0; i < queue.length; ++i) {\n\t\t\t\tqueue[i].reflow();\n\t\t\t}\n\n\t\t\tif (++iterationCount >= MAX_ITERATIONS) {\n\t\t\t\tconsole.warn('Max reflow iterations limit reached, bailing.');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('postUpdate', this._onPostUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(LayoutGroupComponent.prototype, _schema$b);\n\nconst _lightProps = [];\nconst _lightPropsDefault = [];\n\nclass LightComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._cookieAsset = null;\n\t\tthis._cookieAssetId = null;\n\t\tthis._cookieAssetAdd = false;\n\t\tthis._cookieMatrix = null;\n\t}\n\n\taddLightToLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addLight(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveLightFromLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeLight(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addLightToLayers();\n\t\t}\n\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\n\t\tif (index >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tlayer.addLight(this);\n\t\t}\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\n\t\tif (index >= 0) {\n\t\t\tlayer.removeLight(this);\n\t\t}\n\t}\n\n\trefreshProperties() {\n\t\tfor (let i = 0; i < _lightProps.length; i++) {\n\t\t\tconst name = _lightProps[i];\n\t\t\tthis[name] = this[name];\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled) this.onEnable();\n\t}\n\n\tupdateShadow() {\n\t\tthis.light.updateShadow();\n\t}\n\n\tonCookieAssetSet() {\n\t\tlet forceLoad = false;\n\n\t\tif (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {\n\t\t\tthis._cookieAsset.loadFaces = true;\n\t\t\tforceLoad = true;\n\t\t}\n\n\t\tif (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);\n\t\tif (this._cookieAsset.resource) this.onCookieAssetLoad();\n\t}\n\n\tonCookieAssetAdd(asset) {\n\t\tif (this._cookieAssetId !== asset.id) return;\n\t\tthis._cookieAsset = asset;\n\t\tif (this.light.enabled) this.onCookieAssetSet();\n\n\t\tthis._cookieAsset.on('load', this.onCookieAssetLoad, this);\n\n\t\tthis._cookieAsset.on('remove', this.onCookieAssetRemove, this);\n\t}\n\n\tonCookieAssetLoad() {\n\t\tif (!this._cookieAsset || !this._cookieAsset.resource) return;\n\t\tthis.cookie = this._cookieAsset.resource;\n\t}\n\n\tonCookieAssetRemove() {\n\t\tif (!this._cookieAssetId) return;\n\n\t\tif (this._cookieAssetAdd) {\n\t\t\tthis.system.app.assets.off('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);\n\t\t\tthis._cookieAssetAdd = false;\n\t\t}\n\n\t\tif (this._cookieAsset) {\n\t\t\tthis._cookieAsset.off('load', this.onCookieAssetLoad, this);\n\n\t\t\tthis._cookieAsset.off('remove', this.onCookieAssetRemove, this);\n\n\t\t\tthis._cookieAsset = null;\n\t\t}\n\n\t\tthis.cookie = null;\n\t}\n\n\tonEnable() {\n\t\tthis.light.enabled = true;\n\t\tthis.system.app.scene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addLightToLayers();\n\t\t}\n\n\t\tif (this._cookieAsset && !this.cookie) this.onCookieAssetSet();\n\t}\n\n\tonDisable() {\n\t\tthis.light.enabled = false;\n\t\tthis.system.app.scene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tthis.removeLightFromLayers();\n\t}\n\n\tonRemove() {\n\t\tthis.onDisable();\n\t\tthis.light.destroy();\n\t\tthis.cookieAsset = null;\n\t}\n\n}\n\nfunction _defineProperty(name, defaultValue, setFunc, skipEqualsCheck) {\n\tconst c = LightComponent.prototype;\n\n\t_lightProps.push(name);\n\n\t_lightPropsDefault.push(defaultValue);\n\n\tObject.defineProperty(c, name, {\n\t\tget: function () {\n\t\t\treturn this.data[name];\n\t\t},\n\t\tset: function (value) {\n\t\t\tconst data = this.data;\n\t\t\tconst oldValue = data[name];\n\t\t\tif (!skipEqualsCheck && oldValue === value) return;\n\t\t\tdata[name] = value;\n\t\t\tif (setFunc) setFunc.call(this, value, oldValue);\n\t\t},\n\t\tconfigurable: true\n\t});\n}\n\nfunction _defineProps() {\n\t_defineProperty(\"enabled\", true, function (newValue, oldValue) {\n\t\tthis.onSetEnabled(null, oldValue, newValue);\n\t});\n\n\t_defineProperty(\"light\", null);\n\n\t_defineProperty(\"type\", 'directional', function (newValue, oldValue) {\n\t\tthis.system.changeType(this, oldValue, newValue);\n\t\tthis.refreshProperties();\n\t});\n\n\t_defineProperty(\"color\", new Color(1, 1, 1), function (newValue, oldValue) {\n\t\tthis.light.setColor(newValue);\n\t}, true);\n\n\t_defineProperty(\"intensity\", 1, function (newValue, oldValue) {\n\t\tthis.light.intensity = newValue;\n\t});\n\n\t_defineProperty(\"shape\", LIGHTSHAPE_PUNCTUAL, function (newValue, oldValue) {\n\t\tthis.light.shape = newValue;\n\t});\n\n\t_defineProperty(\"castShadows\", false, function (newValue, oldValue) {\n\t\tthis.light.castShadows = newValue;\n\t});\n\n\t_defineProperty(\"shadowDistance\", 40, function (newValue, oldValue) {\n\t\tthis.light.shadowDistance = newValue;\n\t});\n\n\t_defineProperty(\"shadowResolution\", 1024, function (newValue, oldValue) {\n\t\tthis.light.shadowResolution = newValue;\n\t});\n\n\t_defineProperty(\"shadowBias\", 0.05, function (newValue, oldValue) {\n\t\tthis.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"numCascades\", 1, function (newValue, oldValue) {\n\t\tthis.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);\n\t});\n\n\t_defineProperty(\"bakeNumSamples\", 1, function (newValue, oldValue) {\n\t\tthis.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);\n\t});\n\n\t_defineProperty(\"bakeArea\", 0, function (newValue, oldValue) {\n\t\tthis.light.bakeArea = math.clamp(newValue, 0, 180);\n\t});\n\n\t_defineProperty(\"cascadeDistribution\", 0.5, function (newValue, oldValue) {\n\t\tthis.light.cascadeDistribution = math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"normalOffsetBias\", 0, function (newValue, oldValue) {\n\t\tthis.light.normalOffsetBias = math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"range\", 10, function (newValue, oldValue) {\n\t\tthis.light.attenuationEnd = newValue;\n\t});\n\n\t_defineProperty(\"innerConeAngle\", 40, function (newValue, oldValue) {\n\t\tthis.light.innerConeAngle = newValue;\n\t});\n\n\t_defineProperty(\"outerConeAngle\", 45, function (newValue, oldValue) {\n\t\tthis.light.outerConeAngle = newValue;\n\t});\n\n\t_defineProperty(\"falloffMode\", LIGHTFALLOFF_LINEAR, function (newValue, oldValue) {\n\t\tthis.light.falloffMode = newValue;\n\t});\n\n\t_defineProperty(\"shadowType\", SHADOW_PCF3, function (newValue, oldValue) {\n\t\tthis.light.shadowType = newValue;\n\t});\n\n\t_defineProperty(\"vsmBlurSize\", 11, function (newValue, oldValue) {\n\t\tthis.light.vsmBlurSize = newValue;\n\t});\n\n\t_defineProperty(\"vsmBlurMode\", BLUR_GAUSSIAN, function (newValue, oldValue) {\n\t\tthis.light.vsmBlurMode = newValue;\n\t});\n\n\t_defineProperty(\"vsmBias\", 0.01 * 0.25, function (newValue, oldValue) {\n\t\tthis.light.vsmBias = math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"cookieAsset\", null, function (newValue, oldValue) {\n\t\tif (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) return;\n\t\tthis.onCookieAssetRemove();\n\t\tthis._cookieAssetId = null;\n\n\t\tif (newValue instanceof Asset) {\n\t\t\tthis.data.cookieAsset = newValue.id;\n\t\t\tthis._cookieAssetId = newValue.id;\n\t\t\tthis.onCookieAssetAdd(newValue);\n\t\t} else if (typeof newValue === 'number') {\n\t\t\tthis._cookieAssetId = newValue;\n\t\t\tconst asset = this.system.app.assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis.onCookieAssetAdd(asset);\n\t\t\t} else {\n\t\t\t\tthis._cookieAssetAdd = true;\n\t\t\t\tthis.system.app.assets.on('add:' + this._cookieAssetId, this.onCookieAssetAdd, this);\n\t\t\t}\n\t\t}\n\t});\n\n\t_defineProperty(\"cookie\", null, function (newValue, oldValue) {\n\t\tthis.light.cookie = newValue;\n\t});\n\n\t_defineProperty(\"cookieIntensity\", 1, function (newValue, oldValue) {\n\t\tthis.light.cookieIntensity = math.clamp(newValue, 0, 1);\n\t});\n\n\t_defineProperty(\"cookieFalloff\", true, function (newValue, oldValue) {\n\t\tthis.light.cookieFalloff = newValue;\n\t});\n\n\t_defineProperty(\"cookieChannel\", \"rgb\", function (newValue, oldValue) {\n\t\tthis.light.cookieChannel = newValue;\n\t});\n\n\t_defineProperty(\"cookieAngle\", 0, function (newValue, oldValue) {\n\t\tif (newValue !== 0 || this.cookieScale !== null) {\n\t\t\tif (!this._cookieMatrix) this._cookieMatrix = new Vec4();\n\t\t\tlet scx = 1;\n\t\t\tlet scy = 1;\n\n\t\t\tif (this.cookieScale) {\n\t\t\t\tscx = this.cookieScale.x;\n\t\t\t\tscy = this.cookieScale.y;\n\t\t\t}\n\n\t\t\tconst c = Math.cos(newValue * math.DEG_TO_RAD);\n\t\t\tconst s = Math.sin(newValue * math.DEG_TO_RAD);\n\n\t\t\tthis._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);\n\n\t\t\tthis.light.cookieTransform = this._cookieMatrix;\n\t\t} else {\n\t\t\tthis.light.cookieTransform = null;\n\t\t}\n\t});\n\n\t_defineProperty(\"cookieScale\", null, function (newValue, oldValue) {\n\t\tif (newValue !== null || this.cookieAngle !== 0) {\n\t\t\tif (!this._cookieMatrix) this._cookieMatrix = new Vec4();\n\t\t\tconst scx = newValue.x;\n\t\t\tconst scy = newValue.y;\n\t\t\tconst c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);\n\t\t\tconst s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);\n\n\t\t\tthis._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);\n\n\t\t\tthis.light.cookieTransform = this._cookieMatrix;\n\t\t} else {\n\t\t\tthis.light.cookieTransform = null;\n\t\t}\n\t}, true);\n\n\t_defineProperty(\"cookieOffset\", null, function (newValue, oldValue) {\n\t\tthis.light.cookieOffset = newValue;\n\t}, true);\n\n\t_defineProperty(\"shadowUpdateMode\", SHADOWUPDATE_REALTIME, function (newValue, oldValue) {\n\t\tthis.light.shadowUpdateMode = newValue;\n\t}, true);\n\n\t_defineProperty(\"mask\", 1, function (newValue, oldValue) {\n\t\tthis.light.mask = newValue;\n\t});\n\n\t_defineProperty(\"affectDynamic\", true, function (newValue, oldValue) {\n\t\tif (newValue) {\n\t\t\tthis.light.mask |= MASK_AFFECT_DYNAMIC;\n\t\t} else {\n\t\t\tthis.light.mask &= ~MASK_AFFECT_DYNAMIC;\n\t\t}\n\n\t\tthis.light.layersDirty();\n\t});\n\n\t_defineProperty(\"affectLightmapped\", false, function (newValue, oldValue) {\n\t\tif (newValue) {\n\t\t\tthis.light.mask |= MASK_AFFECT_LIGHTMAPPED;\n\t\t\tif (this.bake) this.light.mask &= ~MASK_BAKE;\n\t\t} else {\n\t\t\tthis.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;\n\t\t\tif (this.bake) this.light.mask |= MASK_BAKE;\n\t\t}\n\t});\n\n\t_defineProperty(\"bake\", false, function (newValue, oldValue) {\n\t\tif (newValue) {\n\t\t\tthis.light.mask |= MASK_BAKE;\n\t\t\tif (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;\n\t\t} else {\n\t\t\tthis.light.mask &= ~MASK_BAKE;\n\t\t\tif (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;\n\t\t}\n\n\t\tthis.light.layersDirty();\n\t});\n\n\t_defineProperty(\"bakeDir\", true, function (newValue, oldValue) {\n\t\tthis.light.bakeDir = newValue;\n\t});\n\n\t_defineProperty(\"isStatic\", false, function (newValue, oldValue) {\n\t\tthis.light.isStatic = newValue;\n\t});\n\n\t_defineProperty(\"layers\", [LAYERID_WORLD], function (newValue, oldValue) {\n\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(oldValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeLight(this);\n\t\t}\n\n\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\tif (!layer) continue;\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tlayer.addLight(this);\n\t\t\t}\n\t\t}\n\t});\n}\n\n_defineProps();\n\nclass LightComponentData {\n\tconstructor() {\n\t\tconst _props = _lightProps;\n\t\tconst _propsDefault = _lightPropsDefault;\n\n\t\tfor (let i = 0; i < _props.length; i++) {\n\t\t\tconst value = _propsDefault[i];\n\n\t\t\tif (value && value.clone) {\n\t\t\t\tthis[_props[i]] = value.clone();\n\t\t\t} else {\n\t\t\t\tthis[_props[i]] = value;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nconst lightTypes = {\n\t'directional': LIGHTTYPE_DIRECTIONAL,\n\t'omni': LIGHTTYPE_OMNI,\n\t'point': LIGHTTYPE_OMNI,\n\t'spot': LIGHTTYPE_SPOT\n};\n\nclass LightComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'light';\n\t\tthis.ComponentType = LightComponent;\n\t\tthis.DataType = LightComponentData;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t}\n\n\tinitializeComponentData(component, _data) {\n\t\tconst properties = _lightProps;\n\t\tconst data = {};\n\n\t\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\t\tconst property = properties[i];\n\t\t\tdata[property] = _data[property];\n\t\t}\n\n\t\tif (!data.type) data.type = component.data.type;\n\t\tcomponent.data.type = data.type;\n\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tdata.layers = data.layers.slice(0);\n\t\t}\n\n\t\tif (data.color && Array.isArray(data.color)) data.color = new Color(data.color[0], data.color[1], data.color[2]);\n\t\tif (data.cookieOffset && data.cookieOffset instanceof Array) data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);\n\t\tif (data.cookieScale && data.cookieScale instanceof Array) data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);\n\n\t\tif (data.enable) {\n\t\t\tconsole.warn(\"WARNING: enable: Property is deprecated. Set enabled property instead.\");\n\t\t\tdata.enabled = data.enable;\n\t\t}\n\n\t\tif (!data.shape) {\n\t\t\tdata.shape = LIGHTSHAPE_PUNCTUAL;\n\t\t}\n\n\t\tconst light = new Light(this.app.graphicsDevice);\n\t\tlight.type = lightTypes[data.type];\n\t\tlight._node = component.entity;\n\t\tlight._scene = this.app.scene;\n\t\tcomponent.data.light = light;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst light = entity.light;\n\t\tconst data = [];\n\t\tlet name;\n\t\tconst _props = _lightProps;\n\n\t\tfor (let i = 0; i < _props.length; i++) {\n\t\t\tname = _props[i];\n\t\t\tif (name === \"light\") continue;\n\n\t\t\tif (light[name] && light[name].clone) {\n\t\t\t\tdata[name] = light[name].clone();\n\t\t\t} else {\n\t\t\t\tdata[name] = light[name];\n\t\t\t}\n\t\t}\n\n\t\tthis.addComponent(clone, data);\n\t}\n\n\tchangeType(component, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tcomponent.light.type = lightTypes[newValue];\n\t\t}\n\t}\n\n}\n\nclass ModelComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._type = 'asset';\n\t\tthis._asset = null;\n\t\tthis._model = null;\n\t\tthis._mapping = {};\n\t\tthis._castShadows = true;\n\t\tthis._receiveShadows = true;\n\t\tthis._materialAsset = null;\n\t\tthis._material = system.defaultMaterial;\n\t\tthis._castShadowsLightmap = true;\n\t\tthis._lightmapped = false;\n\t\tthis._lightmapSizeMultiplier = 1;\n\t\tthis._isStatic = false;\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._batchGroupId = -1;\n\t\tthis._customAabb = null;\n\t\tthis._area = null;\n\t\tthis._assetOld = 0;\n\t\tthis._materialEvents = null;\n\t\tthis._dirtyModelAsset = false;\n\t\tthis._dirtyMaterialAsset = false;\n\t\tthis._clonedModel = false;\n\t\tentity.on('remove', this.onRemoveChild, this);\n\t\tentity.on('removehierarchy', this.onRemoveChild, this);\n\t\tentity.on('insert', this.onInsertChild, this);\n\t\tentity.on('inserthierarchy', this.onInsertChild, this);\n\t}\n\n\tset meshInstances(value) {\n\t\tif (!this._model) return;\n\t\tthis._model.meshInstances = value;\n\t}\n\n\tget meshInstances() {\n\t\tif (!this._model) return null;\n\t\treturn this._model.meshInstances;\n\t}\n\n\tset customAabb(value) {\n\t\tthis._customAabb = value;\n\n\t\tif (this._model) {\n\t\t\tconst mi = this._model.meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget customAabb() {\n\t\treturn this._customAabb;\n\t}\n\n\tset type(value) {\n\t\tif (this._type === value) return;\n\t\tthis._area = null;\n\t\tthis._type = value;\n\n\t\tif (value === 'asset') {\n\t\t\tif (this._asset !== null) {\n\t\t\t\tthis._bindModelAsset(this._asset);\n\t\t\t} else {\n\t\t\t\tthis.model = null;\n\t\t\t}\n\t\t} else {\n\t\t\tconst primData = getShapePrimitive(this.system.app.graphicsDevice, value);\n\t\t\tthis._area = primData.area;\n\t\t\tconst mesh = primData.mesh;\n\t\t\tconst node = new GraphNode();\n\t\t\tconst model = new Model();\n\t\t\tmodel.graph = node;\n\t\t\tmodel.meshInstances = [new MeshInstance(mesh, this._material, node)];\n\t\t\tthis.model = model;\n\t\t\tthis._asset = null;\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset asset(value) {\n\t\tconst assets = this.system.app.assets;\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tif (this._asset !== _id) {\n\t\t\tif (this._asset) {\n\t\t\t\tassets.off('add:' + this._asset, this._onModelAssetAdded, this);\n\n\t\t\t\tconst _prev = assets.get(this._asset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindModelAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._asset = _id;\n\n\t\t\tif (this._asset) {\n\t\t\t\tconst asset = assets.get(this._asset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.model = null;\n\t\t\t\t\tassets.on('add:' + this._asset, this._onModelAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindModelAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.model = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget asset() {\n\t\treturn this._asset;\n\t}\n\n\tset model(value) {\n\t\tif (this._model === value) return;\n\n\t\tif (value && value._immutable) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._model) {\n\t\t\tthis._model._immutable = false;\n\t\t\tthis.removeModelFromLayers();\n\t\t\tthis.entity.removeChild(this._model.getGraph());\n\t\t\tdelete this._model._entity;\n\n\t\t\tif (this._clonedModel) {\n\t\t\t\tthis._model.destroy();\n\n\t\t\t\tthis._clonedModel = false;\n\t\t\t}\n\t\t}\n\n\t\tthis._model = value;\n\n\t\tif (this._model) {\n\t\t\tthis._model._immutable = true;\n\t\t\tconst meshInstances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].castShadow = this._castShadows;\n\t\t\t\tmeshInstances[i].receiveShadow = this._receiveShadows;\n\t\t\t\tmeshInstances[i].isStatic = this._isStatic;\n\t\t\t\tmeshInstances[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\n\t\t\tthis.lightmapped = this._lightmapped;\n\t\t\tthis.entity.addChild(this._model.graph);\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addModelToLayers();\n\t\t\t}\n\n\t\t\tthis._model._entity = this.entity;\n\t\t\tif (this.entity.animation) this.entity.animation.setModel(this._model);\n\n\t\t\tif (this.entity.anim) {\n\t\t\t\tif (this.entity.anim.playing) {\n\t\t\t\t\tthis.entity.anim.rebind();\n\t\t\t\t} else {\n\t\t\t\t\tthis.entity.anim.resetStateGraph();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.type === 'asset') {\n\t\t\t\tthis.mapping = this._mapping;\n\t\t\t} else {\n\t\t\t\tthis._unsetMaterialEvents();\n\t\t\t}\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn this._model;\n\t}\n\n\tset lightmapped(value) {\n\t\tif (value !== this._lightmapped) {\n\t\t\tthis._lightmapped = value;\n\n\t\t\tif (this._model) {\n\t\t\t\tconst mi = this._model.meshInstances;\n\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setLightmapped(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget lightmapped() {\n\t\treturn this._lightmapped;\n\t}\n\n\tset castShadows(value) {\n\t\tif (this._castShadows === value) return;\n\t\tconst model = this._model;\n\n\t\tif (model) {\n\t\t\tconst layers = this.layers;\n\t\t\tconst scene = this.system.app.scene;\n\n\t\t\tif (this._castShadows && !value) {\n\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\t\t\tif (!layer) continue;\n\t\t\t\t\tlayer.removeShadowCasters(model.meshInstances);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst meshInstances = model.meshInstances;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].castShadow = value;\n\t\t\t}\n\n\t\t\tif (!this._castShadows && value) {\n\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\t\t\t\t\tif (!layer) continue;\n\t\t\t\t\tlayer.addShadowCasters(model.meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._castShadows = value;\n\t}\n\n\tget castShadows() {\n\t\treturn this._castShadows;\n\t}\n\n\tset receiveShadows(value) {\n\t\tif (this._receiveShadows === value) return;\n\t\tthis._receiveShadows = value;\n\n\t\tif (this._model) {\n\t\t\tconst meshInstances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\t\tmeshInstances[i].receiveShadow = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tget receiveShadows() {\n\t\treturn this._receiveShadows;\n\t}\n\n\tset castShadowsLightmap(value) {\n\t\tthis._castShadowsLightmap = value;\n\t}\n\n\tget castShadowsLightmap() {\n\t\treturn this._castShadowsLightmap;\n\t}\n\n\tset lightmapSizeMultiplier(value) {\n\t\tthis._lightmapSizeMultiplier = value;\n\t}\n\n\tget lightmapSizeMultiplier() {\n\t\treturn this._lightmapSizeMultiplier;\n\t}\n\n\tset isStatic(value) {\n\t\tif (this._isStatic === value) return;\n\t\tthis._isStatic = value;\n\n\t\tif (this._model) {\n\t\t\tconst rcv = this._model.meshInstances;\n\n\t\t\tfor (let i = 0; i < rcv.length; i++) {\n\t\t\t\tconst m = rcv[i];\n\t\t\t\tm.isStatic = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tget isStatic() {\n\t\treturn this._isStatic;\n\t}\n\n\tset layers(value) {\n\t\tconst layers = this.system.app.scene.layers;\n\n\t\tif (this.meshInstances) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\t\tif (!layer) continue;\n\t\t\t\tlayer.removeMeshInstances(this.meshInstances);\n\t\t\t}\n\t\t}\n\n\t\tthis._layers.length = 0;\n\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tthis._layers[i] = value[i];\n\t\t}\n\n\t\tif (!this.enabled || !this.entity.enabled || !this.meshInstances) return;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances(this.meshInstances);\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) return;\n\t\tconst batcher = this.system.app.batcher;\n\n\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\tbatcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tbatcher.insert(BatchGroup.MODEL, value, this.entity);\n\t\t}\n\n\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tthis.addModelToLayers();\n\t\t}\n\n\t\tthis._batchGroupId = value;\n\t}\n\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\n\tset materialAsset(value) {\n\t\tlet _id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (_id !== this._materialAsset) {\n\t\t\tif (this._materialAsset) {\n\t\t\t\tassets.off('add:' + this._materialAsset, this._onMaterialAssetAdd, this);\n\n\t\t\t\tconst _prev = assets.get(this._materialAsset);\n\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindMaterialAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._materialAsset = _id;\n\n\t\t\tif (this._materialAsset) {\n\t\t\t\tconst asset = assets.get(this._materialAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis._setMaterial(this.system.defaultMaterial);\n\n\t\t\t\t\tassets.on('add:' + this._materialAsset, this._onMaterialAssetAdd, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setMaterial(this.system.defaultMaterial);\n\t\t\t}\n\t\t}\n\t}\n\n\tget materialAsset() {\n\t\treturn this._materialAsset;\n\t}\n\n\tset material(value) {\n\t\tif (this._material === value) return;\n\t\tthis.materialAsset = null;\n\n\t\tthis._setMaterial(value);\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset mapping(value) {\n\t\tif (this._type !== 'asset') return;\n\n\t\tthis._unsetMaterialEvents();\n\n\t\tif (!value) value = {};\n\t\tthis._mapping = value;\n\t\tif (!this._model) return;\n\t\tconst meshInstances = this._model.meshInstances;\n\t\tconst modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;\n\t\tconst assetMapping = modelAsset ? modelAsset.data.mapping : null;\n\t\tlet asset = null;\n\n\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\tif (value[i] !== undefined) {\n\t\t\t\tif (value[i]) {\n\t\t\t\t\tasset = this.system.app.assets.get(value[i]);\n\n\t\t\t\t\tthis._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);\n\t\t\t\t} else {\n\t\t\t\t\tmeshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t} else if (assetMapping) {\n\t\t\t\tif (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {\n\t\t\t\t\tif (assetMapping[i].material !== undefined) {\n\t\t\t\t\t\tasset = this.system.app.assets.get(assetMapping[i].material);\n\t\t\t\t\t} else if (assetMapping[i].path !== undefined) {\n\t\t\t\t\t\tconst url = this._getMaterialAssetUrl(assetMapping[i].path);\n\n\t\t\t\t\t\tif (url) {\n\t\t\t\t\t\t\tasset = this.system.app.assets.getByUrl(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);\n\t\t\t\t} else {\n\t\t\t\t\tmeshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget mapping() {\n\t\treturn this._mapping;\n\t}\n\n\taddModelToLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this.meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveModelFromLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances(this.meshInstances);\n\t\t}\n\t}\n\n\tonRemoveChild() {\n\t\tif (this._model) this.removeModelFromLayers();\n\t}\n\n\tonInsertChild() {\n\t\tif (this._model && this.enabled && this.entity.enabled) this.addModelToLayers();\n\t}\n\n\tonRemove() {\n\t\tthis.asset = null;\n\t\tthis.model = null;\n\t\tthis.materialAsset = null;\n\n\t\tthis._unsetMaterialEvents();\n\n\t\tthis.entity.off('remove', this.onRemoveChild, this);\n\t\tthis.entity.off('insert', this.onInsertChild, this);\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addModelToLayers();\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances(this.meshInstances);\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances(this.meshInstances);\n\t}\n\n\t_setMaterialEvent(index, event, id, handler) {\n\t\tconst evt = event + ':' + id;\n\t\tthis.system.app.assets.on(evt, handler, this);\n\t\tif (!this._materialEvents) this._materialEvents = [];\n\t\tif (!this._materialEvents[index]) this._materialEvents[index] = {};\n\t\tthis._materialEvents[index][evt] = {\n\t\t\tid: id,\n\t\t\thandler: handler\n\t\t};\n\t}\n\n\t_unsetMaterialEvents() {\n\t\tconst assets = this.system.app.assets;\n\t\tconst events = this._materialEvents;\n\t\tif (!events) return;\n\n\t\tfor (let i = 0, len = events.length; i < len; i++) {\n\t\t\tif (!events[i]) continue;\n\t\t\tconst evt = events[i];\n\n\t\t\tfor (const key in evt) {\n\t\t\t\tassets.off(key, evt[key].handler, this);\n\t\t\t}\n\t\t}\n\n\t\tthis._materialEvents = null;\n\t}\n\n\t_getAssetByIdOrPath(idOrPath) {\n\t\tlet asset = null;\n\t\tconst isPath = isNaN(parseInt(idOrPath, 10));\n\n\t\tif (!isPath) {\n\t\t\tasset = this.system.app.assets.get(idOrPath);\n\t\t} else if (this.asset) {\n\t\t\tconst url = this._getMaterialAssetUrl(idOrPath);\n\n\t\t\tif (url) asset = this.system.app.assets.getByUrl(url);\n\t\t}\n\n\t\treturn asset;\n\t}\n\n\t_getMaterialAssetUrl(path) {\n\t\tif (!this.asset) return null;\n\t\tconst modelAsset = this.system.app.assets.get(this.asset);\n\t\treturn modelAsset ? modelAsset.getAbsoluteUrl(path) : null;\n\t}\n\n\t_loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (!materialAsset) return;\n\n\t\tif (materialAsset.resource) {\n\t\t\tmeshInstance.material = materialAsset.resource;\n\n\t\t\tthis._setMaterialEvent(index, 'remove', materialAsset.id, function () {\n\t\t\t\tmeshInstance.material = this.system.defaultMaterial;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {\n\t\t\t\tmeshInstance.material = asset.resource;\n\n\t\t\t\tthis._setMaterialEvent(index, 'remove', materialAsset.id, function () {\n\t\t\t\t\tmeshInstance.material = this.system.defaultMaterial;\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (this.enabled && this.entity.enabled) assets.load(materialAsset);\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tscene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tconst isAsset = this._type === 'asset';\n\t\tlet asset;\n\n\t\tif (this._model) {\n\t\t\tthis.addModelToLayers();\n\t\t} else if (isAsset && this._asset) {\n\t\t\tasset = app.assets.get(this._asset);\n\n\t\t\tif (asset && asset.resource !== this._model) {\n\t\t\t\tthis._bindModelAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (this._materialAsset) {\n\t\t\tasset = app.assets.get(this._materialAsset);\n\n\t\t\tif (asset && asset.resource !== this._material) {\n\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (isAsset) {\n\t\t\tif (this._mapping) {\n\t\t\t\tfor (const index in this._mapping) {\n\t\t\t\t\tif (this._mapping[index]) {\n\t\t\t\t\t\tasset = this._getAssetByIdOrPath(this._mapping[index]);\n\n\t\t\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\t\t\tapp.assets.load(asset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tscene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tif (this._model) {\n\t\t\tthis.removeModelFromLayers();\n\t\t}\n\t}\n\n\thide() {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].visible = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tshow() {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\n\t\t\tfor (let i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].visible = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t_bindMaterialAsset(asset) {\n\t\tasset.on('load', this._onMaterialAssetLoad, this);\n\t\tasset.on('unload', this._onMaterialAssetUnload, this);\n\t\tasset.on('remove', this._onMaterialAssetRemove, this);\n\t\tasset.on('change', this._onMaterialAssetChange, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindMaterialAsset(asset) {\n\t\tasset.off('load', this._onMaterialAssetLoad, this);\n\t\tasset.off('unload', this._onMaterialAssetUnload, this);\n\t\tasset.off('remove', this._onMaterialAssetRemove, this);\n\t\tasset.off('change', this._onMaterialAssetChange, this);\n\t}\n\n\t_onMaterialAssetAdd(asset) {\n\t\tthis.system.app.assets.off('add:' + asset.id, this._onMaterialAssetAdd, this);\n\n\t\tif (this._materialAsset === asset.id) {\n\t\t\tthis._bindMaterialAsset(asset);\n\t\t}\n\t}\n\n\t_onMaterialAssetLoad(asset) {\n\t\tthis._setMaterial(asset.resource);\n\t}\n\n\t_onMaterialAssetUnload(asset) {\n\t\tthis._setMaterial(this.system.defaultMaterial);\n\t}\n\n\t_onMaterialAssetRemove(asset) {\n\t\tthis._onMaterialAssetUnload(asset);\n\t}\n\n\t_onMaterialAssetChange(asset) {}\n\n\t_bindModelAsset(asset) {\n\t\tthis._unbindModelAsset(asset);\n\n\t\tasset.on('load', this._onModelAssetLoad, this);\n\t\tasset.on('unload', this._onModelAssetUnload, this);\n\t\tasset.on('change', this._onModelAssetChange, this);\n\t\tasset.on('remove', this._onModelAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onModelAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindModelAsset(asset) {\n\t\tasset.off('load', this._onModelAssetLoad, this);\n\t\tasset.off('unload', this._onModelAssetUnload, this);\n\t\tasset.off('change', this._onModelAssetChange, this);\n\t\tasset.off('remove', this._onModelAssetRemove, this);\n\t}\n\n\t_onModelAssetAdded(asset) {\n\t\tthis.system.app.assets.off('add:' + asset.id, this._onModelAssetAdded, this);\n\n\t\tif (asset.id === this._asset) {\n\t\t\tthis._bindModelAsset(asset);\n\t\t}\n\t}\n\n\t_onModelAssetLoad(asset) {\n\t\tthis.model = asset.resource.clone();\n\t\tthis._clonedModel = true;\n\t}\n\n\t_onModelAssetUnload(asset) {\n\t\tthis.model = null;\n\t}\n\n\t_onModelAssetChange(asset, attr, _new, _old) {\n\t\tif (attr === 'data') {\n\t\t\tthis.mapping = this._mapping;\n\t\t}\n\t}\n\n\t_onModelAssetRemove(asset) {\n\t\tthis.model = null;\n\t}\n\n\t_setMaterial(material) {\n\t\tif (this._material === material) return;\n\t\tthis._material = material;\n\t\tconst model = this._model;\n\n\t\tif (model && this._type !== 'asset') {\n\t\t\tconst meshInstances = model.meshInstances;\n\n\t\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\t\tmeshInstances[i].material = material;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass ModelComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$a = ['enabled'];\n\nclass ModelComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'model';\n\t\tthis.ComponentType = ModelComponent;\n\t\tthis.DataType = ModelComponentData;\n\t\tthis.schema = _schema$a;\n\t\tthis.defaultMaterial = DefaultMaterial.get(app.graphicsDevice);\n\t\tthis.on('beforeremove', this.onRemove, this);\n\t}\n\n\tinitializeComponentData(component, _data, properties) {\n\t\tproperties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];\n\n\t\tif (_data.batchGroupId === null || _data.batchGroupId === undefined) {\n\t\t\t_data.batchGroupId = -1;\n\t\t}\n\n\t\tif (_data.layers && _data.layers.length) {\n\t\t\t_data.layers = _data.layers.slice(0);\n\t\t}\n\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tif (_data.hasOwnProperty(properties[i])) {\n\t\t\t\tcomponent[properties[i]] = _data[properties[i]];\n\t\t\t}\n\t\t}\n\n\t\tif (_data.aabbCenter && _data.aabbHalfExtents) {\n\t\t\tcomponent.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));\n\t\t}\n\n\t\tsuper.initializeComponentData(component, _data, ['enabled']);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst data = {\n\t\t\ttype: entity.model.type,\n\t\t\tasset: entity.model.asset,\n\t\t\tcastShadows: entity.model.castShadows,\n\t\t\treceiveShadows: entity.model.receiveShadows,\n\t\t\tcastShadowsLightmap: entity.model.castShadowsLightmap,\n\t\t\tlightmapped: entity.model.lightmapped,\n\t\t\tlightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,\n\t\t\tisStatic: entity.model.isStatic,\n\t\t\tenabled: entity.model.enabled,\n\t\t\tlayers: entity.model.layers,\n\t\t\tbatchGroupId: entity.model.batchGroupId,\n\t\t\tmapping: extend({}, entity.model.mapping)\n\t\t};\n\t\tlet materialAsset = entity.model.materialAsset;\n\n\t\tif (!(materialAsset instanceof Asset) && materialAsset != null) {\n\t\t\tmaterialAsset = this.app.assets.get(materialAsset);\n\t\t}\n\n\t\tconst material = entity.model.material;\n\n\t\tif (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {\n\t\t\tdata.materialAsset = materialAsset;\n\t\t}\n\n\t\tconst component = this.addComponent(clone, data);\n\n\t\tif (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {\n\t\t\tcomponent.model = entity.model.model.clone();\n\t\t\tcomponent._clonedModel = true;\n\t\t}\n\n\t\tif (!data.materialAsset) component.material = material;\n\n\t\tif (entity.model.model) {\n\t\t\tconst meshInstances = entity.model.model.meshInstances;\n\t\t\tconst meshInstancesClone = component.model.meshInstances;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstancesClone[i].mask = meshInstances[i].mask;\n\t\t\t\tmeshInstancesClone[i].material = meshInstances[i].material;\n\t\t\t\tmeshInstancesClone[i].layer = meshInstances[i].layer;\n\t\t\t\tmeshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;\n\t\t\t}\n\t\t}\n\n\t\tif (entity.model.customAabb) {\n\t\t\tcomponent.customAabb = entity.model.customAabb.clone();\n\t\t}\n\t}\n\n\tonRemove(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n}\n\nComponent._buildAccessors(ModelComponent.prototype, _schema$a);\n\nclass RenderComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._type = 'asset';\n\t\tthis._castShadows = true;\n\t\tthis._receiveShadows = true;\n\t\tthis._castShadowsLightmap = true;\n\t\tthis._lightmapped = false;\n\t\tthis._lightmapSizeMultiplier = 1;\n\t\tthis._isStatic = false;\n\t\tthis._batchGroupId = -1;\n\t\tthis._meshInstances = [];\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._renderStyle = RENDERSTYLE_SOLID;\n\t\tthis._customAabb = null;\n\t\tthis._area = null;\n\t\tthis._rootBone = new EntityReference(this, 'rootBone');\n\n\t\tthis._rootBone.on('set:entity', this._onSetRootBone, this);\n\n\t\tthis._assetReference = new AssetReference('asset', this, system.app.assets, {\n\t\t\tadd: this._onRenderAssetAdded,\n\t\t\tload: this._onRenderAssetLoad,\n\t\t\tremove: this._onRenderAssetRemove,\n\t\t\tunload: this._onRenderAssetUnload\n\t\t}, this);\n\t\tthis._material = system.defaultMaterial;\n\t\tthis._materialReferences = [];\n\t\tentity.on('remove', this.onRemoveChild, this);\n\t\tentity.on('removehierarchy', this.onRemoveChild, this);\n\t\tentity.on('insert', this.onInsertChild, this);\n\t\tentity.on('inserthierarchy', this.onInsertChild, this);\n\t}\n\n\tset renderStyle(renderStyle) {\n\t\tif (this._renderStyle !== renderStyle) {\n\t\t\tthis._renderStyle = renderStyle;\n\n\t\t\tMeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);\n\t\t}\n\t}\n\n\tget renderStyle() {\n\t\treturn this._renderStyle;\n\t}\n\n\tset customAabb(value) {\n\t\tthis._customAabb = value;\n\t\tconst mi = this._meshInstances;\n\n\t\tif (mi) {\n\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\t\t}\n\t}\n\n\tget customAabb() {\n\t\treturn this._customAabb;\n\t}\n\n\tset type(value) {\n\t\tif (this._type !== value) {\n\t\t\tthis._area = null;\n\t\t\tthis._type = value;\n\t\t\tthis.destroyMeshInstances();\n\n\t\t\tif (value !== 'asset') {\n\t\t\t\tlet material = this._material;\n\n\t\t\t\tif (!material || material === this.system.defaultMaterial) {\n\t\t\t\t\tmaterial = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;\n\t\t\t\t}\n\n\t\t\t\tconst primData = getShapePrimitive(this.system.app.graphicsDevice, value);\n\t\t\t\tthis._area = primData.area;\n\t\t\t\tthis.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset meshInstances(value) {\n\t\tthis.destroyMeshInstances();\n\t\tthis._meshInstances = value;\n\n\t\tif (this._meshInstances) {\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\tif (!mi[i].node) {\n\t\t\t\t\tmi[i].node = this.entity;\n\t\t\t\t}\n\n\t\t\t\tmi[i].castShadow = this._castShadows;\n\t\t\t\tmi[i].receiveShadow = this._receiveShadows;\n\t\t\t\tmi[i].isStatic = this._isStatic;\n\t\t\t\tmi[i].renderStyle = this._renderStyle;\n\t\t\t\tmi[i].setLightmapped(this._lightmapped);\n\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addToLayers();\n\t\t\t}\n\t\t}\n\t}\n\n\tget meshInstances() {\n\t\treturn this._meshInstances;\n\t}\n\n\tset lightmapped(value) {\n\t\tif (value !== this._lightmapped) {\n\t\t\tthis._lightmapped = value;\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setLightmapped(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget lightmapped() {\n\t\treturn this._lightmapped;\n\t}\n\n\tset castShadows(value) {\n\t\tif (this._castShadows !== value) {\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tconst layers = this.layers;\n\t\t\t\tconst scene = this.system.app.scene;\n\n\t\t\t\tif (this._castShadows && !value) {\n\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\tconst layer = scene.layers.getLayerById(this.layers[i]);\n\n\t\t\t\t\t\tif (layer) {\n\t\t\t\t\t\t\tlayer.removeShadowCasters(mi);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].castShadow = value;\n\t\t\t\t}\n\n\t\t\t\tif (!this._castShadows && value) {\n\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\n\t\t\t\t\t\tif (layer) {\n\t\t\t\t\t\t\tlayer.addShadowCasters(mi);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._castShadows = value;\n\t\t}\n\t}\n\n\tget castShadows() {\n\t\treturn this._castShadows;\n\t}\n\n\tset receiveShadows(value) {\n\t\tif (this._receiveShadows !== value) {\n\t\t\tthis._receiveShadows = value;\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].receiveShadow = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget receiveShadows() {\n\t\treturn this._receiveShadows;\n\t}\n\n\tset castShadowsLightmap(value) {\n\t\tthis._castShadowsLightmap = value;\n\t}\n\n\tget castShadowsLightmap() {\n\t\treturn this._castShadowsLightmap;\n\t}\n\n\tset lightmapSizeMultiplier(value) {\n\t\tthis._lightmapSizeMultiplier = value;\n\t}\n\n\tget lightmapSizeMultiplier() {\n\t\treturn this._lightmapSizeMultiplier;\n\t}\n\n\tset isStatic(value) {\n\t\tif (this._isStatic !== value) {\n\t\t\tthis._isStatic = value;\n\t\t\tconst mi = this._meshInstances;\n\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].isStatic = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget isStatic() {\n\t\treturn this._isStatic;\n\t}\n\n\tset layers(value) {\n\t\tconst layers = this.system.app.scene.layers;\n\t\tlet layer;\n\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tlayer = layers.getLayerById(this._layers[i]);\n\n\t\t\t\tif (layer) {\n\t\t\t\t\tlayer.removeMeshInstances(this._meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._layers.length = 0;\n\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tthis._layers[i] = value[i];\n\t\t}\n\n\t\tif (!this.enabled || !this.entity.enabled || !this._meshInstances) return;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tlayer = layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this._meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId !== value) {\n\t\t\tconst batcher = this.system.app.batcher;\n\n\t\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\t\tbatcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t\t}\n\n\t\t\tif (this.entity.enabled && value >= 0) {\n\t\t\t\tbatcher.insert(BatchGroup.RENDER, value, this.entity);\n\t\t\t}\n\n\t\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addToLayers();\n\t\t\t}\n\n\t\t\tthis._batchGroupId = value;\n\t\t}\n\t}\n\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\n\tset material(value) {\n\t\tif (this._material !== value) {\n\t\t\tthis._material = value;\n\n\t\t\tif (this._meshInstances && this._type !== 'asset') {\n\t\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\t\tthis._meshInstances[i].material = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset materialAssets(value = []) {\n\t\tif (this._materialReferences.length > value.length) {\n\t\t\tfor (let i = value.length; i < this._materialReferences.length; i++) {\n\t\t\t\tthis._materialReferences[i].id = null;\n\t\t\t}\n\n\t\t\tthis._materialReferences.length = value.length;\n\t\t}\n\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tif (!this._materialReferences[i]) {\n\t\t\t\tthis._materialReferences.push(new AssetReference(i, this, this.system.app.assets, {\n\t\t\t\t\tadd: this._onMaterialAdded,\n\t\t\t\t\tload: this._onMaterialLoad,\n\t\t\t\t\tremove: this._onMaterialRemove,\n\t\t\t\t\tunload: this._onMaterialUnload\n\t\t\t\t}, this));\n\t\t\t}\n\n\t\t\tif (value[i]) {\n\t\t\t\tconst id = value[i] instanceof Asset ? value[i].id : value[i];\n\n\t\t\t\tif (this._materialReferences[i].id !== id) {\n\t\t\t\t\tthis._materialReferences[i].id = id;\n\t\t\t\t}\n\n\t\t\t\tif (this._materialReferences[i].asset) {\n\t\t\t\t\tthis._onMaterialAdded(i, this, this._materialReferences[i].asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._materialReferences[i].id = null;\n\n\t\t\t\tif (this._meshInstances[i]) {\n\t\t\t\t\tthis._meshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget materialAssets() {\n\t\treturn this._materialReferences.map(function (ref) {\n\t\t\treturn ref.id;\n\t\t});\n\t}\n\n\tset asset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\t\tif (this._assetReference.id === id) return;\n\n\t\tif (this._assetReference.asset && this._assetReference.asset.resource) {\n\t\t\tthis._onRenderAssetRemove();\n\t\t}\n\n\t\tthis._assetReference.id = id;\n\n\t\tif (this._assetReference.asset) {\n\t\t\tthis._onRenderAssetAdded();\n\t\t}\n\t}\n\n\tget asset() {\n\t\treturn this._assetReference.id;\n\t}\n\n\t_onSetRootBone(entity) {\n\t\tif (entity) {\n\t\t\tthis._onRootBoneChanged();\n\t\t}\n\t}\n\n\t_onRootBoneChanged() {\n\t\tthis._clearSkinInstances();\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis._cloneSkinInstances();\n\t\t}\n\t}\n\n\tdestroyMeshInstances() {\n\t\tconst meshInstances = this._meshInstances;\n\n\t\tif (meshInstances) {\n\t\t\tthis.removeFromLayers();\n\n\t\t\tthis._clearSkinInstances();\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].destroy();\n\t\t\t}\n\n\t\t\tthis._meshInstances.length = 0;\n\t\t}\n\t}\n\n\taddToLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this._meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\n\tremoveFromLayers() {\n\t\tif (this._meshInstances && this._meshInstances.length) {\n\t\t\tconst layers = this.system.app.scene.layers;\n\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\n\t\t\t\tif (layer) {\n\t\t\t\t\tlayer.removeMeshInstances(this._meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonRemoveChild() {\n\t\tthis.removeFromLayers();\n\t}\n\n\tonInsertChild() {\n\t\tif (this._meshInstances && this.enabled && this.entity.enabled) {\n\t\t\tthis.addToLayers();\n\t\t}\n\t}\n\n\tonRemove() {\n\t\tthis.destroyMeshInstances();\n\t\tthis.asset = null;\n\t\tthis.materialAsset = null;\n\t\tthis.entity.off('remove', this.onRemoveChild, this);\n\t\tthis.entity.off('insert', this.onInsertChild, this);\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addToLayers();\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances(this._meshInstances);\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances(this._meshInstances);\n\t}\n\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\n\t\tthis._rootBone.onParentComponentEnable();\n\n\t\tthis._cloneSkinInstances();\n\n\t\tscene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tscene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tconst isAsset = this._type === 'asset';\n\n\t\tif (this._meshInstances && this._meshInstances.length) {\n\t\t\tthis.addToLayers();\n\t\t} else if (isAsset && this.asset) {\n\t\t\tthis._onRenderAssetAdded();\n\t\t}\n\n\t\tfor (let i = 0; i < this._materialReferences.length; i++) {\n\t\t\tif (this._materialReferences[i].asset) {\n\t\t\t\tthis.system.app.assets.load(this._materialReferences[i].asset);\n\t\t\t}\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tscene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t}\n\n\t\tthis.removeFromLayers();\n\t}\n\n\thide() {\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tthis._meshInstances[i].visible = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tshow() {\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tthis._meshInstances[i].visible = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onRenderAssetAdded() {\n\t\tif (!this._assetReference.asset) return;\n\n\t\tif (this._assetReference.asset.resource) {\n\t\t\tthis._onRenderAssetLoad();\n\t\t} else if (this.enabled && this.entity.enabled) {\n\t\t\tthis.system.app.assets.load(this._assetReference.asset);\n\t\t}\n\t}\n\n\t_onRenderAssetLoad() {\n\t\tthis.destroyMeshInstances();\n\n\t\tif (this._assetReference.asset) {\n\t\t\tconst render = this._assetReference.asset.resource;\n\t\t\trender.off('set:meshes', this._onSetMeshes, this);\n\t\t\trender.on('set:meshes', this._onSetMeshes, this);\n\n\t\t\tif (render.meshes) {\n\t\t\t\tthis._onSetMeshes(render.meshes);\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSetMeshes(meshes) {\n\t\tthis._cloneMeshes(meshes);\n\t}\n\n\t_clearSkinInstances() {\n\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\tconst meshInstance = this._meshInstances[i];\n\t\t\tSkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);\n\t\t\tmeshInstance.skinInstance = null;\n\t\t}\n\t}\n\n\t_cloneSkinInstances() {\n\t\tif (this._meshInstances.length && this._rootBone.entity instanceof GraphNode) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tconst meshInstance = this._meshInstances[i];\n\t\t\t\tconst mesh = meshInstance.mesh;\n\n\t\t\t\tif (mesh.skin && !mesh.skinInstance) {\n\t\t\t\t\tmeshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone.entity, this.entity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_cloneMeshes(meshes) {\n\t\tif (meshes && meshes.length) {\n\t\t\tconst meshInstances = [];\n\n\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\tconst mesh = meshes[i];\n\t\t\t\tconst material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;\n\t\t\t\tconst meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);\n\t\t\t\tmeshInstances.push(meshInst);\n\n\t\t\t\tif (mesh.morph) {\n\t\t\t\t\tmeshInst.morphInstance = new MorphInstance(mesh.morph);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.meshInstances = meshInstances;\n\n\t\t\tthis._cloneSkinInstances();\n\t\t}\n\t}\n\n\t_onRenderAssetUnload() {\n\t\tif (this._type === 'asset') {\n\t\t\tthis.destroyMeshInstances();\n\t\t}\n\t}\n\n\t_onRenderAssetRemove() {\n\t\tif (this._assetReference.asset && this._assetReference.asset.resource) {\n\t\t\tthis._assetReference.asset.resource.off('set:meshes', this._onSetMeshes, this);\n\t\t}\n\n\t\tthis._onRenderAssetUnload();\n\t}\n\n\t_onMaterialAdded(index, component, asset) {\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialLoad(index, component, asset);\n\t\t} else {\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateMainMaterial(index, material) {\n\t\tif (index === 0) {\n\t\t\tthis.material = material;\n\t\t}\n\t}\n\n\t_onMaterialLoad(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = asset.resource;\n\t\t}\n\n\t\tthis._updateMainMaterial(index, asset.resource);\n\t}\n\n\t_onMaterialRemove(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = this.system.defaultMaterial;\n\t\t}\n\n\t\tthis._updateMainMaterial(index, this.system.defaultMaterial);\n\t}\n\n\t_onMaterialUnload(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = this.system.defaultMaterial;\n\t\t}\n\n\t\tthis._updateMainMaterial(index, this.system.defaultMaterial);\n\t}\n\n\tresolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {\n\t\tif (oldRender.rootBone && duplicatedIdsMap[oldRender.rootBone]) {\n\t\t\tthis.rootBone = duplicatedIdsMap[oldRender.rootBone];\n\t\t}\n\n\t\tthis._clearSkinInstances();\n\t}\n\n}\n\nclass RenderComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.rootBone = null;\n\t}\n\n}\n\nconst _schema$9 = [{\n\tname: 'rootBone',\n\ttype: 'entity'\n}, 'enabled'];\nconst _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId'];\n\nclass RenderComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'render';\n\t\tthis.ComponentType = RenderComponent;\n\t\tthis.DataType = RenderComponentData;\n\t\tthis.schema = _schema$9;\n\t\tthis.defaultMaterial = DefaultMaterial.get(app.graphicsDevice);\n\t\tthis.on('beforeremove', this.onRemove, this);\n\t}\n\n\tinitializeComponentData(component, _data, properties) {\n\t\tif (_data.batchGroupId === null || _data.batchGroupId === undefined) {\n\t\t\t_data.batchGroupId = -1;\n\t\t}\n\n\t\tif (_data.layers && _data.layers.length) {\n\t\t\t_data.layers = _data.layers.slice(0);\n\t\t}\n\n\t\tfor (let i = 0; i < _properties.length; i++) {\n\t\t\tif (_data.hasOwnProperty(_properties[i])) {\n\t\t\t\tcomponent[_properties[i]] = _data[_properties[i]];\n\t\t\t}\n\t\t}\n\n\t\tif (_data.aabbCenter && _data.aabbHalfExtents) {\n\t\t\tcomponent.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));\n\t\t}\n\n\t\tsuper.initializeComponentData(component, _data, _schema$9);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst data = {};\n\n\t\tfor (let i = 0; i < _properties.length; i++) {\n\t\t\tdata[_properties[i]] = entity.render[_properties[i]];\n\t\t}\n\n\t\tdelete data.meshInstances;\n\t\tconst component = this.addComponent(clone, data);\n\t\tconst srcMeshInstances = entity.render.meshInstances;\n\t\tconst meshes = srcMeshInstances.map(mi => mi.mesh);\n\n\t\tcomponent._onSetMeshes(meshes);\n\n\t\tfor (let m = 0; m < srcMeshInstances.length; m++) {\n\t\t\tcomponent.meshInstances[m].material = srcMeshInstances[m].material;\n\t\t}\n\n\t\tif (entity.render.customAabb) {\n\t\t\tcomponent.customAabb = entity.render.customAabb.clone();\n\t\t}\n\t}\n\n\tonRemove(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n}\n\nComponent._buildAccessors(RenderComponent.prototype, _schema$9);\n\nconst SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];\nconst COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];\nconst GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];\nconst ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];\nlet depthLayer;\n\nclass ParticleSystemComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.on(\"set_colorMapAsset\", this.onSetColorMapAsset, this);\n\t\tthis.on(\"set_normalMapAsset\", this.onSetNormalMapAsset, this);\n\t\tthis.on(\"set_meshAsset\", this.onSetMeshAsset, this);\n\t\tthis.on(\"set_mesh\", this.onSetMesh, this);\n\t\tthis.on(\"set_renderAsset\", this.onSetRenderAsset, this);\n\t\tthis.on(\"set_loop\", this.onSetLoop, this);\n\t\tthis.on(\"set_blendType\", this.onSetBlendType, this);\n\t\tthis.on(\"set_depthSoftening\", this.onSetDepthSoftening, this);\n\t\tthis.on(\"set_layers\", this.onSetLayers, this);\n\t\tSIMPLE_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetSimpleProperty, this);\n\t\t});\n\t\tCOMPLEX_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetComplexProperty, this);\n\t\t});\n\t\tGRAPH_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetGraphProperty, this);\n\t\t});\n\t\tthis._requestedDepth = false;\n\t\tthis._drawOrder = 0;\n\t}\n\n\tset drawOrder(drawOrder) {\n\t\tthis._drawOrder = drawOrder;\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.drawOrder = drawOrder;\n\t\t}\n\t}\n\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\n\taddMeshInstanceToLayers() {\n\t\tif (!this.emitter) return;\n\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t\t\tthis.emitter._layer = layer;\n\t\t}\n\t}\n\n\tremoveMeshInstanceFromLayers() {\n\t\tif (!this.emitter) return;\n\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\t}\n\n\tonSetLayers(name, oldValue, newValue) {\n\t\tif (!this.emitter) return;\n\n\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(oldValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\n\t\tif (!this.enabled || !this.entity.enabled) return;\n\n\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\t}\n\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addMeshInstanceToLayers();\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\t}\n\n\tonLayerAdded(layer) {\n\t\tif (!this.emitter) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t}\n\n\tonLayerRemoved(layer) {\n\t\tif (!this.emitter) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t}\n\n\t_bindColorMapAsset(asset) {\n\t\tasset.on('load', this._onColorMapAssetLoad, this);\n\t\tasset.on('unload', this._onColorMapAssetUnload, this);\n\t\tasset.on('remove', this._onColorMapAssetRemove, this);\n\t\tasset.on('change', this._onColorMapAssetChange, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onColorMapAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindColorMapAsset(asset) {\n\t\tasset.off('load', this._onColorMapAssetLoad, this);\n\t\tasset.off('unload', this._onColorMapAssetUnload, this);\n\t\tasset.off('remove', this._onColorMapAssetRemove, this);\n\t\tasset.off('change', this._onColorMapAssetChange, this);\n\t}\n\n\t_onColorMapAssetLoad(asset) {\n\t\tthis.colorMap = asset.resource;\n\t}\n\n\t_onColorMapAssetUnload(asset) {\n\t\tthis.colorMap = null;\n\t}\n\n\t_onColorMapAssetRemove(asset) {\n\t\tthis._onColorMapAssetUnload(asset);\n\t}\n\n\t_onColorMapAssetChange(asset) {}\n\n\tonSetColorMapAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindColorMapAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.colorMapAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._bindColorMapAsset(asset);\n\t\t\t} else {\n\t\t\t\tassets.once(\"add:\" + newValue, asset => {\n\t\t\t\t\tthis._bindColorMapAsset(asset);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.colorMap = null;\n\t\t}\n\t}\n\n\t_bindNormalMapAsset(asset) {\n\t\tasset.on('load', this._onNormalMapAssetLoad, this);\n\t\tasset.on('unload', this._onNormalMapAssetUnload, this);\n\t\tasset.on('remove', this._onNormalMapAssetRemove, this);\n\t\tasset.on('change', this._onNormalMapAssetChange, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onNormalMapAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindNormalMapAsset(asset) {\n\t\tasset.off('load', this._onNormalMapAssetLoad, this);\n\t\tasset.off('unload', this._onNormalMapAssetUnload, this);\n\t\tasset.off('remove', this._onNormalMapAssetRemove, this);\n\t\tasset.off('change', this._onNormalMapAssetChange, this);\n\t}\n\n\t_onNormalMapAssetLoad(asset) {\n\t\tthis.normalMap = asset.resource;\n\t}\n\n\t_onNormalMapAssetUnload(asset) {\n\t\tthis.normalMap = null;\n\t}\n\n\t_onNormalMapAssetRemove(asset) {\n\t\tthis._onNormalMapAssetUnload(asset);\n\t}\n\n\t_onNormalMapAssetChange(asset) {}\n\n\tonSetNormalMapAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindNormalMapAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.normalMapAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._bindNormalMapAsset(asset);\n\t\t\t} else {\n\t\t\t\tassets.once(\"add:\" + newValue, asset => {\n\t\t\t\t\tthis._bindNormalMapAsset(asset);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.normalMap = null;\n\t\t}\n\t}\n\n\t_bindMeshAsset(asset) {\n\t\tasset.on('load', this._onMeshAssetLoad, this);\n\t\tasset.on('unload', this._onMeshAssetUnload, this);\n\t\tasset.on('remove', this._onMeshAssetRemove, this);\n\t\tasset.on('change', this._onMeshAssetChange, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onMeshAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindMeshAsset(asset) {\n\t\tasset.off('load', this._onMeshAssetLoad, this);\n\t\tasset.off('unload', this._onMeshAssetUnload, this);\n\t\tasset.off('remove', this._onMeshAssetRemove, this);\n\t\tasset.off('change', this._onMeshAssetChange, this);\n\t}\n\n\t_onMeshAssetLoad(asset) {\n\t\tthis._onMeshChanged(asset.resource);\n\t}\n\n\t_onMeshAssetUnload(asset) {\n\t\tthis.mesh = null;\n\t}\n\n\t_onMeshAssetRemove(asset) {\n\t\tthis._onMeshAssetUnload(asset);\n\t}\n\n\t_onMeshAssetChange(asset) {}\n\n\tonSetMeshAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindMeshAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.meshAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._bindMeshAsset(asset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._onMeshChanged(null);\n\t\t}\n\t}\n\n\tonSetMesh(name, oldValue, newValue) {\n\t\tif (!newValue || newValue instanceof Asset || typeof newValue === 'number') {\n\t\t\tthis.meshAsset = newValue;\n\t\t} else {\n\t\t\tthis._onMeshChanged(newValue);\n\t\t}\n\t}\n\n\t_onMeshChanged(mesh) {\n\t\tif (mesh && !(mesh instanceof Mesh)) {\n\t\t\tif (mesh.meshInstances[0]) {\n\t\t\t\tmesh = mesh.meshInstances[0].mesh;\n\t\t\t} else {\n\t\t\t\tmesh = null;\n\t\t\t}\n\t\t}\n\n\t\tthis.data.mesh = mesh;\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.mesh = mesh;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t}\n\t}\n\n\tonSetRenderAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindRenderAsset(asset);\n\t\t\t}\n\t\t}\n\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.renderAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\n\t\t\tconst asset = assets.get(newValue);\n\n\t\t\tif (asset) {\n\t\t\t\tthis._bindRenderAsset(asset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._onRenderChanged(null);\n\t\t}\n\t}\n\n\t_bindRenderAsset(asset) {\n\t\tasset.on('load', this._onRenderAssetLoad, this);\n\t\tasset.on('unload', this._onRenderAssetUnload, this);\n\t\tasset.on('remove', this._onRenderAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onRenderAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindRenderAsset(asset) {\n\t\tasset.off('load', this._onRenderAssetLoad, this);\n\t\tasset.off('unload', this._onRenderAssetUnload, this);\n\t\tasset.off('remove', this._onRenderAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tasset.resource.off('set:meshes', this._onRenderSetMeshes, this);\n\t\t}\n\t}\n\n\t_onRenderAssetLoad(asset) {\n\t\tthis._onRenderChanged(asset.resource);\n\t}\n\n\t_onRenderAssetUnload(asset) {\n\t\tthis._onRenderChanged(null);\n\t}\n\n\t_onRenderAssetRemove(asset) {\n\t\tthis._onRenderAssetUnload(asset);\n\t}\n\n\t_onRenderChanged(render) {\n\t\tif (!render) {\n\t\t\tthis._onMeshChanged(null);\n\n\t\t\treturn;\n\t\t}\n\n\t\trender.off('set:meshes', this._onRenderSetMeshes, this);\n\t\trender.on('set:meshes', this._onRenderSetMeshes, this);\n\n\t\tif (render.meshes) {\n\t\t\tthis._onRenderSetMeshes(render.meshes);\n\t\t}\n\t}\n\n\t_onRenderSetMeshes(meshes) {\n\t\tthis._onMeshChanged(meshes && meshes[0]);\n\t}\n\n\tonSetLoop(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetTime();\n\t\t}\n\t}\n\n\tonSetBlendType(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.material.blendType = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t}\n\t}\n\n\t_requestDepth() {\n\t\tif (this._requestedDepth) return;\n\t\tif (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);\n\n\t\tif (depthLayer) {\n\t\t\tdepthLayer.incrementCounter();\n\t\t\tthis._requestedDepth = true;\n\t\t}\n\t}\n\n\t_releaseDepth() {\n\t\tif (!this._requestedDepth) return;\n\n\t\tif (depthLayer) {\n\t\t\tdepthLayer.decrementCounter();\n\t\t\tthis._requestedDepth = false;\n\t\t}\n\t}\n\n\tonSetDepthSoftening(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (newValue) {\n\t\t\t\tif (this.enabled && this.entity.enabled) this._requestDepth();\n\t\t\t\tif (this.emitter) this.emitter[name] = newValue;\n\t\t\t} else {\n\t\t\t\tif (this.enabled && this.entity.enabled) this._releaseDepth();\n\t\t\t\tif (this.emitter) this.emitter[name] = newValue;\n\t\t\t}\n\n\t\t\tif (this.emitter) {\n\t\t\t\tthis.reset();\n\t\t\t\tthis.emitter.resetMaterial();\n\t\t\t\tthis.rebuild();\n\t\t\t}\n\t\t}\n\t}\n\n\tonSetSimpleProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t}\n\t}\n\n\tonSetComplexProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t\tthis.reset();\n\t\t}\n\t}\n\n\tonSetGraphProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.rebuildGraphs();\n\t\t\tthis.emitter.resetMaterial();\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tconst data = this.data;\n\n\t\tfor (let i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {\n\t\t\tlet asset = data[ASSET_PROPERTIES[i]];\n\n\t\t\tif (asset) {\n\t\t\t\tif (!(asset instanceof Asset)) {\n\t\t\t\t\tconst id = parseInt(asset, 10);\n\n\t\t\t\t\tif (id >= 0) {\n\t\t\t\t\t\tasset = this.system.app.assets.get(asset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.emitter) {\n\t\t\tlet mesh = data.mesh;\n\t\t\tif (!(mesh instanceof Mesh)) mesh = null;\n\t\t\tthis.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {\n\t\t\t\tnumParticles: data.numParticles,\n\t\t\t\temitterExtents: data.emitterExtents,\n\t\t\t\temitterExtentsInner: data.emitterExtentsInner,\n\t\t\t\temitterRadius: data.emitterRadius,\n\t\t\t\temitterRadiusInner: data.emitterRadiusInner,\n\t\t\t\temitterShape: data.emitterShape,\n\t\t\t\tinitialVelocity: data.initialVelocity,\n\t\t\t\twrap: data.wrap,\n\t\t\t\tlocalSpace: data.localSpace,\n\t\t\t\tscreenSpace: data.screenSpace,\n\t\t\t\twrapBounds: data.wrapBounds,\n\t\t\t\tlifetime: data.lifetime,\n\t\t\t\trate: data.rate,\n\t\t\t\trate2: data.rate2,\n\t\t\t\torientation: data.orientation,\n\t\t\t\tparticleNormal: data.particleNormal,\n\t\t\t\tanimTilesX: data.animTilesX,\n\t\t\t\tanimTilesY: data.animTilesY,\n\t\t\t\tanimStartFrame: data.animStartFrame,\n\t\t\t\tanimNumFrames: data.animNumFrames,\n\t\t\t\tanimNumAnimations: data.animNumAnimations,\n\t\t\t\tanimIndex: data.animIndex,\n\t\t\t\trandomizeAnimIndex: data.randomizeAnimIndex,\n\t\t\t\tanimSpeed: data.animSpeed,\n\t\t\t\tanimLoop: data.animLoop,\n\t\t\t\tstartAngle: data.startAngle,\n\t\t\t\tstartAngle2: data.startAngle2,\n\t\t\t\tscaleGraph: data.scaleGraph,\n\t\t\t\tscaleGraph2: data.scaleGraph2,\n\t\t\t\tcolorGraph: data.colorGraph,\n\t\t\t\tcolorGraph2: data.colorGraph2,\n\t\t\t\talphaGraph: data.alphaGraph,\n\t\t\t\talphaGraph2: data.alphaGraph2,\n\t\t\t\tlocalVelocityGraph: data.localVelocityGraph,\n\t\t\t\tlocalVelocityGraph2: data.localVelocityGraph2,\n\t\t\t\tvelocityGraph: data.velocityGraph,\n\t\t\t\tvelocityGraph2: data.velocityGraph2,\n\t\t\t\trotationSpeedGraph: data.rotationSpeedGraph,\n\t\t\t\trotationSpeedGraph2: data.rotationSpeedGraph2,\n\t\t\t\tradialSpeedGraph: data.radialSpeedGraph,\n\t\t\t\tradialSpeedGraph2: data.radialSpeedGraph2,\n\t\t\t\tcolorMap: data.colorMap,\n\t\t\t\tnormalMap: data.normalMap,\n\t\t\t\tloop: data.loop,\n\t\t\t\tpreWarm: data.preWarm,\n\t\t\t\tsort: data.sort,\n\t\t\t\tstretch: data.stretch,\n\t\t\t\talignToMotion: data.alignToMotion,\n\t\t\t\tlighting: data.lighting,\n\t\t\t\thalfLambert: data.halfLambert,\n\t\t\t\tintensity: data.intensity,\n\t\t\t\tdepthSoftening: data.depthSoftening,\n\t\t\t\tscene: this.system.app.scene,\n\t\t\t\tmesh: mesh,\n\t\t\t\tdepthWrite: data.depthWrite,\n\t\t\t\tnoFog: data.noFog,\n\t\t\t\tnode: this.entity,\n\t\t\t\tblendType: data.blendType\n\t\t\t});\n\t\t\tthis.emitter.meshInstance.node = this.entity;\n\t\t\tthis.emitter.drawOrder = this.drawOrder;\n\n\t\t\tif (!data.autoPlay) {\n\t\t\t\tthis.pause();\n\t\t\t\tthis.emitter.meshInstance.visible = false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.emitter.colorMap) {\n\t\t\tthis.addMeshInstanceToLayers();\n\t\t}\n\n\t\tthis.system.app.scene.on(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.on(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.on(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled && data.depthSoftening) {\n\t\t\tthis._requestDepth();\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tthis.system.app.scene.off(\"set:layers\", this.onLayersChanged, this);\n\n\t\tif (this.system.app.scene.layers) {\n\t\t\tthis.system.app.scene.layers.off(\"add\", this.onLayerAdded, this);\n\t\t\tthis.system.app.scene.layers.off(\"remove\", this.onLayerRemoved, this);\n\t\t}\n\n\t\tif (this.emitter) {\n\t\t\tthis.removeMeshInstanceFromLayers();\n\t\t\tif (this.data.depthSoftening) this._releaseDepth();\n\t\t\tthis.emitter.camera = null;\n\t\t}\n\t}\n\n\tonBeforeRemove() {\n\t\tif (this.enabled) {\n\t\t\tthis.enabled = false;\n\t\t}\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.destroy();\n\t\t\tthis.emitter = null;\n\t\t}\n\n\t\tfor (let i = 0; i < ASSET_PROPERTIES.length; i++) {\n\t\t\tconst prop = ASSET_PROPERTIES[i];\n\n\t\t\tif (this.data[prop]) {\n\t\t\t\tthis[prop] = null;\n\t\t\t}\n\t\t}\n\n\t\tthis.off();\n\t}\n\n\treset() {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.reset();\n\t\t}\n\t}\n\n\tstop() {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.loop = false;\n\t\t\tthis.emitter.resetTime();\n\t\t\tthis.emitter.addTime(0, true);\n\t\t}\n\t}\n\n\tpause() {\n\t\tthis.data.paused = true;\n\t}\n\n\tunpause() {\n\t\tthis.data.paused = false;\n\t}\n\n\tplay() {\n\t\tthis.data.paused = false;\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.meshInstance.visible = true;\n\t\t\tthis.emitter.loop = this.data.loop;\n\t\t\tthis.emitter.resetTime();\n\t\t}\n\t}\n\n\tisPlaying() {\n\t\tif (this.data.paused) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.emitter && this.emitter.loop) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn Date.now() <= this.emitter.endTime;\n\t}\n\n\trebuild() {\n\t\tconst enabled = this.enabled;\n\t\tthis.enabled = false;\n\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.rebuild();\n\t\t\tthis.emitter.meshInstance.node = this.entity;\n\t\t}\n\n\t\tthis.enabled = enabled;\n\t}\n\n}\n\nclass ParticleSystemComponentData {\n\tconstructor() {\n\t\tthis.numParticles = 1;\n\t\tthis.rate = 1;\n\t\tthis.rate2 = null;\n\t\tthis.startAngle = 0;\n\t\tthis.startAngle2 = null;\n\t\tthis.lifetime = 50;\n\t\tthis.emitterExtents = new Vec3();\n\t\tthis.emitterExtentsInner = new Vec3();\n\t\tthis.emitterRadius = 0;\n\t\tthis.emitterRadiusInner = 0;\n\t\tthis.emitterShape = EMITTERSHAPE_BOX;\n\t\tthis.initialVelocity = 0;\n\t\tthis.wrapBounds = new Vec3();\n\t\tthis.localSpace = false;\n\t\tthis.screenSpace = false;\n\t\tthis.colorMap = null;\n\t\tthis.colorMapAsset = null;\n\t\tthis.normalMap = null;\n\t\tthis.normalMapAsset = null;\n\t\tthis.loop = true;\n\t\tthis.preWarm = false;\n\t\tthis.sort = 0;\n\t\tthis.mode = PARTICLEMODE_GPU;\n\t\tthis.scene = null;\n\t\tthis.lighting = false;\n\t\tthis.halfLambert = false;\n\t\tthis.intensity = 1;\n\t\tthis.stretch = 0.0;\n\t\tthis.alignToMotion = false;\n\t\tthis.depthSoftening = 0;\n\t\tthis.meshAsset = null;\n\t\tthis.mesh = null;\n\t\tthis.depthWrite = false;\n\t\tthis.noFog = false;\n\t\tthis.orientation = PARTICLEORIENTATION_SCREEN;\n\t\tthis.particleNormal = new Vec3(0, 1, 0);\n\t\tthis.animTilesX = 1;\n\t\tthis.animTilesY = 1;\n\t\tthis.animStartFrame = 0;\n\t\tthis.animNumFrames = 1;\n\t\tthis.animNumAnimations = 1;\n\t\tthis.animIndex = 0;\n\t\tthis.randomizeAnimIndex = false;\n\t\tthis.animSpeed = 1;\n\t\tthis.animLoop = true;\n\t\tthis.scaleGraph = null;\n\t\tthis.scaleGraph2 = null;\n\t\tthis.colorGraph = null;\n\t\tthis.colorGraph2 = null;\n\t\tthis.alphaGraph = null;\n\t\tthis.alphaGraph2 = null;\n\t\tthis.localVelocityGraph = null;\n\t\tthis.localVelocityGraph2 = null;\n\t\tthis.velocityGraph = null;\n\t\tthis.velocityGraph2 = null;\n\t\tthis.rotationSpeedGraph = null;\n\t\tthis.rotationSpeedGraph2 = null;\n\t\tthis.radialSpeedGraph = null;\n\t\tthis.radialSpeedGraph2 = null;\n\t\tthis.blendType = BLEND_NORMAL;\n\t\tthis.enabled = true;\n\t\tthis.paused = false;\n\t\tthis.autoPlay = true;\n\t\tthis.layers = [LAYERID_WORLD];\n\t}\n\n}\n\nconst _schema$8 = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];\n\nclass ParticleSystemComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'particlesystem';\n\t\tthis.ComponentType = ParticleSystemComponent;\n\t\tthis.DataType = ParticleSystemComponentData;\n\t\tthis.schema = _schema$8;\n\t\tthis.propertyTypes = {\n\t\t\temitterExtents: 'vec3',\n\t\t\temitterExtentsInner: 'vec3',\n\t\t\tparticleNormal: 'vec3',\n\t\t\twrapBounds: 'vec3',\n\t\t\tlocalVelocityGraph: 'curveset',\n\t\t\tlocalVelocityGraph2: 'curveset',\n\t\t\tvelocityGraph: 'curveset',\n\t\t\tvelocityGraph2: 'curveset',\n\t\t\tcolorGraph: 'curveset',\n\t\t\tcolorGraph2: 'curveset',\n\t\t\talphaGraph: 'curve',\n\t\t\talphaGraph2: 'curve',\n\t\t\trotationSpeedGraph: 'curve',\n\t\t\trotationSpeedGraph2: 'curve',\n\t\t\tradialSpeedGraph: 'curve',\n\t\t\tradialSpeedGraph2: 'curve',\n\t\t\tscaleGraph: 'curve',\n\t\t\tscaleGraph2: 'curve'\n\t\t};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, _data, properties) {\n\t\tconst data = {};\n\t\tproperties = [];\n\t\tconst types = this.propertyTypes;\n\n\t\tif (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {\n\t\t\t_data.meshAsset = _data.mesh;\n\t\t\tdelete _data.mesh;\n\t\t}\n\n\t\tfor (const prop in _data) {\n\t\t\tif (_data.hasOwnProperty(prop)) {\n\t\t\t\tproperties.push(prop);\n\t\t\t\tdata[prop] = _data[prop];\n\t\t\t}\n\n\t\t\tif (types[prop] === 'vec3') {\n\t\t\t\tif (Array.isArray(data[prop])) {\n\t\t\t\t\tdata[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);\n\t\t\t\t}\n\t\t\t} else if (types[prop] === 'curve') {\n\t\t\t\tif (!(data[prop] instanceof Curve)) {\n\t\t\t\t\tconst t = data[prop].type;\n\t\t\t\t\tdata[prop] = new Curve(data[prop].keys);\n\t\t\t\t\tdata[prop].type = t;\n\t\t\t\t}\n\t\t\t} else if (types[prop] === 'curveset') {\n\t\t\t\tif (!(data[prop] instanceof CurveSet)) {\n\t\t\t\t\tconst t = data[prop].type;\n\t\t\t\t\tdata[prop] = new CurveSet(data[prop].keys);\n\t\t\t\t\tdata[prop].type = t;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\t\tdata.layers = data.layers.slice(0);\n\t\t\t}\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.particlesystem.data;\n\t\tconst schema = this.schema;\n\t\tconst data = {};\n\n\t\tfor (let i = 0, len = schema.length; i < len; i++) {\n\t\t\tconst prop = schema[i];\n\t\t\tlet sourceProp = source[prop];\n\n\t\t\tif (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {\n\t\t\t\tsourceProp = sourceProp.clone();\n\t\t\t\tdata[prop] = sourceProp;\n\t\t\t} else if (prop === \"layers\") {\n\t\t\t\tdata.layers = source.layers.slice(0);\n\t\t\t} else {\n\t\t\t\tif (sourceProp !== null && sourceProp !== undefined) {\n\t\t\t\t\tdata[prop] = sourceProp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\t\tlet numSteps;\n\t\tconst stats = this.app.stats.particles;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tconst entity = component.entity;\n\t\t\t\tconst data = component.data;\n\n\t\t\t\tif (data.enabled && entity.enabled) {\n\t\t\t\t\tconst emitter = entity.particlesystem.emitter;\n\t\t\t\t\tif (!emitter.meshInstance.visible) continue;\n\n\t\t\t\t\tif (emitter.lighting) {\n\t\t\t\t\t\tconst layers = data.layers;\n\t\t\t\t\t\tlet lightCube;\n\n\t\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\t\tconst layer = this.app.scene.layers.getLayerById(layers[i]);\n\t\t\t\t\t\t\tif (!layer) continue;\n\n\t\t\t\t\t\t\tif (!layer._lightCube) {\n\t\t\t\t\t\t\t\tlayer._lightCube = new Float32Array(6 * 3);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlightCube = layer._lightCube;\n\n\t\t\t\t\t\t\tfor (let j = 0; j < 6; j++) {\n\t\t\t\t\t\t\t\tlightCube[j * 3] = this.app.scene.ambientLight.r;\n\t\t\t\t\t\t\t\tlightCube[j * 3 + 1] = this.app.scene.ambientLight.g;\n\t\t\t\t\t\t\t\tlightCube[j * 3 + 2] = this.app.scene.ambientLight.b;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst dirs = layer._splitLights[LIGHTTYPE_DIRECTIONAL];\n\n\t\t\t\t\t\t\tfor (let j = 0; j < dirs.length; j++) {\n\t\t\t\t\t\t\t\tfor (let c = 0; c < 6; c++) {\n\t\t\t\t\t\t\t\t\tconst weight = Math.max(emitter.lightCubeDir[c].dot(dirs[j]._direction), 0) * dirs[j]._intensity;\n\n\t\t\t\t\t\t\t\t\tlightCube[c * 3] += dirs[j]._color.r * weight;\n\t\t\t\t\t\t\t\t\tlightCube[c * 3 + 1] += dirs[j]._color.g * weight;\n\t\t\t\t\t\t\t\t\tlightCube[c * 3 + 2] += dirs[j]._color.b * weight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\temitter.constantLightCube.setValue(lightCube);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!data.paused) {\n\t\t\t\t\t\temitter.simTime += dt;\n\n\t\t\t\t\t\tif (emitter.simTime > emitter.fixedTimeStep) {\n\t\t\t\t\t\t\tnumSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);\n\t\t\t\t\t\t\temitter.simTime -= numSteps * emitter.fixedTimeStep;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (numSteps) {\n\t\t\t\t\t\t\tnumSteps = Math.min(numSteps, emitter.maxSubSteps);\n\n\t\t\t\t\t\t\tfor (let i = 0; i < numSteps; i++) {\n\t\t\t\t\t\t\t\temitter.addTime(emitter.fixedTimeStep, false);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstats._updatesPerFrame += numSteps;\n\t\t\t\t\t\t\tstats._frameTime += emitter._addTimeTime;\n\t\t\t\t\t\t\temitter._addTimeTime = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\temitter.finishFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(ParticleSystemComponent.prototype, _schema$8);\n\nclass ObjectPool {\n\tconstructor(constructorFunc, size) {\n\t\tthis._constructor = constructorFunc;\n\t\tthis._pool = [];\n\t\tthis._count = 0;\n\n\t\tthis._resize(size);\n\t}\n\n\t_resize(size) {\n\t\tif (size > this._pool.length) {\n\t\t\tfor (let i = this._pool.length; i < size; i++) {\n\t\t\t\tthis._pool[i] = new this._constructor();\n\t\t\t}\n\t\t}\n\t}\n\n\tallocate() {\n\t\tif (this._count >= this._pool.length) {\n\t\t\tthis._resize(this._pool.length * 2);\n\t\t}\n\n\t\treturn this._pool[this._count++];\n\t}\n\n\tfreeAll() {\n\t\tthis._count = 0;\n\t}\n\n}\n\nlet ammoTransform;\nlet ammoVec1, ammoVec2, ammoQuat, ammoOrigin;\n\nclass RigidBodyComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._angularDamping = 0;\n\t\tthis._angularFactor = new Vec3(1, 1, 1);\n\t\tthis._angularVelocity = new Vec3();\n\t\tthis._body = null;\n\t\tthis._friction = 0.5;\n\t\tthis._group = BODYGROUP_STATIC;\n\t\tthis._linearDamping = 0;\n\t\tthis._linearFactor = new Vec3(1, 1, 1);\n\t\tthis._linearVelocity = new Vec3();\n\t\tthis._mask = BODYMASK_NOT_STATIC;\n\t\tthis._mass = 1;\n\t\tthis._restitution = 0;\n\t\tthis._rollingFriction = 0;\n\t\tthis._simulationEnabled = false;\n\t\tthis._type = BODYTYPE_STATIC;\n\t}\n\n\tstatic onLibraryLoaded() {\n\t\tif (typeof Ammo !== 'undefined' && !ammoTransform) {\n\t\t\tammoTransform = new Ammo.btTransform();\n\t\t\tammoVec1 = new Ammo.btVector3();\n\t\t\tammoVec2 = new Ammo.btVector3();\n\t\t\tammoQuat = new Ammo.btQuaternion();\n\t\t\tammoOrigin = new Ammo.btVector3(0, 0, 0);\n\t\t}\n\t}\n\n\tset angularDamping(damping) {\n\t\tif (this._angularDamping !== damping) {\n\t\t\tthis._angularDamping = damping;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setDamping(this._linearDamping, damping);\n\t\t\t}\n\t\t}\n\t}\n\n\tget angularDamping() {\n\t\treturn this._angularDamping;\n\t}\n\n\tset angularFactor(factor) {\n\t\tif (!this._angularFactor.equals(factor)) {\n\t\t\tthis._angularFactor.copy(factor);\n\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tammoVec1.setValue(factor.x, factor.y, factor.z);\n\n\t\t\t\tthis._body.setAngularFactor(ammoVec1);\n\t\t\t}\n\t\t}\n\t}\n\n\tget angularFactor() {\n\t\treturn this._angularFactor;\n\t}\n\n\tset angularVelocity(velocity) {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tthis._body.activate();\n\n\t\t\tammoVec1.setValue(velocity.x, velocity.y, velocity.z);\n\n\t\t\tthis._body.setAngularVelocity(ammoVec1);\n\n\t\t\tthis._angularVelocity.copy(velocity);\n\t\t}\n\t}\n\n\tget angularVelocity() {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tconst velocity = this._body.getAngularVelocity();\n\n\t\t\tthis._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());\n\t\t}\n\n\t\treturn this._angularVelocity;\n\t}\n\n\tset body(body) {\n\t\tif (this._body !== body) {\n\t\t\tthis._body = body;\n\n\t\t\tif (body && this._simulationEnabled) {\n\t\t\t\tbody.activate();\n\t\t\t}\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this._body;\n\t}\n\n\tset friction(friction) {\n\t\tif (this._friction !== friction) {\n\t\t\tthis._friction = friction;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setFriction(friction);\n\t\t\t}\n\t\t}\n\t}\n\n\tget friction() {\n\t\treturn this._friction;\n\t}\n\n\tset group(group) {\n\t\tif (this._group !== group) {\n\t\t\tthis._group = group;\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.disableSimulation();\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\n\tget group() {\n\t\treturn this._group;\n\t}\n\n\tset linearDamping(damping) {\n\t\tif (this._linearDamping !== damping) {\n\t\t\tthis._linearDamping = damping;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setDamping(damping, this._angularDamping);\n\t\t\t}\n\t\t}\n\t}\n\n\tget linearDamping() {\n\t\treturn this._linearDamping;\n\t}\n\n\tset linearFactor(factor) {\n\t\tif (!this._linearFactor.equals(factor)) {\n\t\t\tthis._linearFactor.copy(factor);\n\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tammoVec1.setValue(factor.x, factor.y, factor.z);\n\n\t\t\t\tthis._body.setLinearFactor(ammoVec1);\n\t\t\t}\n\t\t}\n\t}\n\n\tget linearFactor() {\n\t\treturn this._linearFactor;\n\t}\n\n\tset linearVelocity(velocity) {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tthis._body.activate();\n\n\t\t\tammoVec1.setValue(velocity.x, velocity.y, velocity.z);\n\n\t\t\tthis._body.setLinearVelocity(ammoVec1);\n\n\t\t\tthis._linearVelocity.copy(velocity);\n\t\t}\n\t}\n\n\tget linearVelocity() {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tconst velocity = this._body.getLinearVelocity();\n\n\t\t\tthis._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());\n\t\t}\n\n\t\treturn this._linearVelocity;\n\t}\n\n\tset mask(mask) {\n\t\tif (this._mask !== mask) {\n\t\t\tthis._mask = mask;\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.disableSimulation();\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\n\tset mass(mass) {\n\t\tif (this._mass !== mass) {\n\t\t\tthis._mass = mass;\n\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tconst enabled = this.enabled && this.entity.enabled;\n\n\t\t\t\tif (enabled) {\n\t\t\t\t\tthis.disableSimulation();\n\t\t\t\t}\n\n\t\t\t\tthis._body.getCollisionShape().calculateLocalInertia(mass, ammoVec1);\n\n\t\t\t\tthis._body.setMassProps(mass, ammoVec1);\n\n\t\t\t\tthis._body.updateInertiaTensor();\n\n\t\t\t\tif (enabled) {\n\t\t\t\t\tthis.enableSimulation();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget mass() {\n\t\treturn this._mass;\n\t}\n\n\tset restitution(restitution) {\n\t\tif (this._restitution !== restitution) {\n\t\t\tthis._restitution = restitution;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setRestitution(restitution);\n\t\t\t}\n\t\t}\n\t}\n\n\tget restitution() {\n\t\treturn this._restitution;\n\t}\n\n\tset rollingFriction(friction) {\n\t\tif (this._rollingFriction !== friction) {\n\t\t\tthis._rollingFriction = friction;\n\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setRollingFriction(friction);\n\t\t\t}\n\t\t}\n\t}\n\n\tget rollingFriction() {\n\t\treturn this._rollingFriction;\n\t}\n\n\tset type(type) {\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\tthis.disableSimulation();\n\n\t\t\tswitch (type) {\n\t\t\t\tcase BODYTYPE_DYNAMIC:\n\t\t\t\t\tthis._group = BODYGROUP_DYNAMIC;\n\t\t\t\t\tthis._mask = BODYMASK_ALL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BODYTYPE_KINEMATIC:\n\t\t\t\t\tthis._group = BODYGROUP_KINEMATIC;\n\t\t\t\t\tthis._mask = BODYMASK_ALL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase BODYTYPE_STATIC:\n\t\t\t\tdefault:\n\t\t\t\t\tthis._group = BODYGROUP_STATIC;\n\t\t\t\t\tthis._mask = BODYMASK_NOT_STATIC;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthis.createBody();\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tcreateBody() {\n\t\tconst entity = this.entity;\n\t\tlet shape;\n\n\t\tif (entity.collision) {\n\t\t\tshape = entity.collision.shape;\n\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t\tdelete entity.trigger;\n\t\t\t}\n\t\t}\n\n\t\tif (shape) {\n\t\t\tif (this._body) this.system.onRemove(entity, this);\n\t\t\tconst mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;\n\n\t\t\tthis._getEntityTransform(ammoTransform);\n\n\t\t\tconst body = this.system.createBody(mass, shape, ammoTransform);\n\t\t\tbody.setRestitution(this._restitution);\n\t\t\tbody.setFriction(this._friction);\n\t\t\tbody.setRollingFriction(this._rollingFriction);\n\t\t\tbody.setDamping(this._linearDamping, this._angularDamping);\n\n\t\t\tif (this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tconst linearFactor = this._linearFactor;\n\t\t\t\tammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);\n\t\t\t\tbody.setLinearFactor(ammoVec1);\n\t\t\t\tconst angularFactor = this._angularFactor;\n\t\t\t\tammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);\n\t\t\t\tbody.setAngularFactor(ammoVec1);\n\t\t\t} else if (this._type === BODYTYPE_KINEMATIC) {\n\t\t\t\tbody.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);\n\t\t\t\tbody.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);\n\t\t\t}\n\n\t\t\tbody.entity = entity;\n\t\t\tthis.body = body;\n\n\t\t\tif (this.enabled && entity.enabled) {\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\n\tisActive() {\n\t\treturn this._body ? this._body.isActive() : false;\n\t}\n\n\tactivate() {\n\t\tif (this._body) {\n\t\t\tthis._body.activate();\n\t\t}\n\t}\n\n\tenableSimulation() {\n\t\tconst entity = this.entity;\n\n\t\tif (entity.collision && entity.collision.enabled && !this._simulationEnabled) {\n\t\t\tconst body = this._body;\n\n\t\t\tif (body) {\n\t\t\t\tthis.system.addBody(body, this._group, this._mask);\n\n\t\t\t\tswitch (this._type) {\n\t\t\t\t\tcase BODYTYPE_DYNAMIC:\n\t\t\t\t\t\tthis.system._dynamic.push(this);\n\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\t\t\t\t\tthis.syncEntityToBody();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase BODYTYPE_KINEMATIC:\n\t\t\t\t\t\tthis.system._kinematic.push(this);\n\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase BODYTYPE_STATIC:\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\t\t\t\t\tthis.syncEntityToBody();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entity.collision.type === 'compound') {\n\t\t\t\t\tthis.system._compounds.push(entity.collision);\n\t\t\t\t}\n\n\t\t\t\tbody.activate();\n\t\t\t\tthis._simulationEnabled = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdisableSimulation() {\n\t\tconst body = this._body;\n\n\t\tif (body && this._simulationEnabled) {\n\t\t\tconst system = this.system;\n\n\t\t\tlet idx = system._compounds.indexOf(this.entity.collision);\n\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._compounds.splice(idx, 1);\n\t\t\t}\n\n\t\t\tidx = system._dynamic.indexOf(this);\n\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._dynamic.splice(idx, 1);\n\t\t\t}\n\n\t\t\tidx = system._kinematic.indexOf(this);\n\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._kinematic.splice(idx, 1);\n\t\t\t}\n\n\t\t\tsystem.removeBody(body);\n\t\t\tbody.forceActivationState(BODYSTATE_DISABLE_SIMULATION);\n\t\t\tthis._simulationEnabled = false;\n\t\t}\n\t}\n\n\tapplyForce() {\n\t\tlet x, y, z;\n\t\tlet px, py, pz;\n\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tpx = arguments[1].x;\n\t\t\t\tpy = arguments[1].y;\n\t\t\t\tpz = arguments[1].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tpx = arguments[3];\n\t\t\t\tpy = arguments[4];\n\t\t\t\tpz = arguments[5];\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tammoVec1.setValue(x, y, z);\n\n\t\t\tif (px !== undefined) {\n\t\t\t\tammoVec2.setValue(px, py, pz);\n\t\t\t\tbody.applyForce(ammoVec1, ammoVec2);\n\t\t\t} else {\n\t\t\t\tbody.applyForce(ammoVec1, ammoOrigin);\n\t\t\t}\n\t\t}\n\t}\n\n\tapplyTorque() {\n\t\tlet x, y, z;\n\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tammoVec1.setValue(x, y, z);\n\t\t\tbody.applyTorque(ammoVec1);\n\t\t}\n\t}\n\n\tapplyImpulse() {\n\t\tlet x, y, z;\n\t\tlet px, py, pz;\n\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tpx = arguments[1].x;\n\t\t\t\tpy = arguments[1].y;\n\t\t\t\tpz = arguments[1].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tpx = arguments[3];\n\t\t\t\tpy = arguments[4];\n\t\t\t\tpz = arguments[5];\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tammoVec1.setValue(x, y, z);\n\n\t\t\tif (px !== undefined) {\n\t\t\t\tammoVec2.setValue(px, py, pz);\n\t\t\t\tbody.applyImpulse(ammoVec1, ammoVec2);\n\t\t\t} else {\n\t\t\t\tbody.applyImpulse(ammoVec1, ammoOrigin);\n\t\t\t}\n\t\t}\n\t}\n\n\tapplyTorqueImpulse() {\n\t\tlet x, y, z;\n\n\t\tswitch (arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tx = arguments[0].x;\n\t\t\t\ty = arguments[0].y;\n\t\t\t\tz = arguments[0].z;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tx = arguments[0];\n\t\t\t\ty = arguments[1];\n\t\t\t\tz = arguments[2];\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tammoVec1.setValue(x, y, z);\n\t\t\tbody.applyTorqueImpulse(ammoVec1);\n\t\t}\n\t}\n\n\tisStatic() {\n\t\treturn this._type === BODYTYPE_STATIC;\n\t}\n\n\tisStaticOrKinematic() {\n\t\treturn this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;\n\t}\n\n\tisKinematic() {\n\t\treturn this._type === BODYTYPE_KINEMATIC;\n\t}\n\n\t_getEntityTransform(transform) {\n\t\tconst entity = this.entity;\n\t\tconst pos = entity.getPosition();\n\t\tconst rot = entity.getRotation();\n\t\tammoVec1.setValue(pos.x, pos.y, pos.z);\n\t\tammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\ttransform.setOrigin(ammoVec1);\n\t\ttransform.setRotation(ammoQuat);\n\t}\n\n\tsyncEntityToBody() {\n\t\tconst body = this._body;\n\n\t\tif (body) {\n\t\t\tthis._getEntityTransform(ammoTransform);\n\n\t\t\tbody.setWorldTransform(ammoTransform);\n\n\t\t\tif (this._type === BODYTYPE_KINEMATIC) {\n\t\t\t\tconst motionState = body.getMotionState();\n\n\t\t\t\tif (motionState) {\n\t\t\t\t\tmotionState.setWorldTransform(ammoTransform);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbody.activate();\n\t\t}\n\t}\n\n\t_updateDynamic() {\n\t\tconst body = this._body;\n\n\t\tif (body.isActive()) {\n\t\t\tconst motionState = body.getMotionState();\n\n\t\t\tif (motionState) {\n\t\t\t\tmotionState.getWorldTransform(ammoTransform);\n\t\t\t\tconst p = ammoTransform.getOrigin();\n\t\t\t\tconst q = ammoTransform.getRotation();\n\t\t\t\tthis.entity.setPosition(p.x(), p.y(), p.z());\n\t\t\t\tthis.entity.setRotation(q.x(), q.y(), q.z(), q.w());\n\t\t\t}\n\t\t}\n\t}\n\n\t_updateKinematic() {\n\t\tconst motionState = this._body.getMotionState();\n\n\t\tif (motionState) {\n\t\t\tthis._getEntityTransform(ammoTransform);\n\n\t\t\tmotionState.setWorldTransform(ammoTransform);\n\t\t}\n\t}\n\n\tteleport() {\n\t\tif (arguments.length < 3) {\n\t\t\tif (arguments[0]) {\n\t\t\t\tthis.entity.setPosition(arguments[0]);\n\t\t\t}\n\n\t\t\tif (arguments[1]) {\n\t\t\t\tif (arguments[1] instanceof Quat) {\n\t\t\t\t\tthis.entity.setRotation(arguments[1]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.entity.setEulerAngles(arguments[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (arguments.length === 6) {\n\t\t\t\tthis.entity.setEulerAngles(arguments[3], arguments[4], arguments[5]);\n\t\t\t}\n\n\t\t\tthis.entity.setPosition(arguments[0], arguments[1], arguments[2]);\n\t\t}\n\n\t\tthis.syncEntityToBody();\n\t}\n\n\tonEnable() {\n\t\tif (!this._body) {\n\t\t\tthis.createBody();\n\t\t}\n\n\t\tthis.enableSimulation();\n\t}\n\n\tonDisable() {\n\t\tthis.disableSimulation();\n\t}\n\n}\n\nclass RigidBodyComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nlet ammoRayStart, ammoRayEnd;\n\nclass RaycastResult {\n\tconstructor(entity, point, normal) {\n\t\tthis.entity = entity;\n\t\tthis.point = point;\n\t\tthis.normal = normal;\n\t}\n\n}\n\nclass SingleContactResult {\n\tconstructor(a, b, contactPoint) {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.a = null;\n\t\t\tthis.b = null;\n\t\t\tthis.impulse = 0;\n\t\t\tthis.localPointA = new Vec3();\n\t\t\tthis.localPointB = new Vec3();\n\t\t\tthis.pointA = new Vec3();\n\t\t\tthis.pointB = new Vec3();\n\t\t\tthis.normal = new Vec3();\n\t\t} else {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.impulse = contactPoint.impulse;\n\t\t\tthis.localPointA = contactPoint.localPoint;\n\t\t\tthis.localPointB = contactPoint.localPointOther;\n\t\t\tthis.pointA = contactPoint.point;\n\t\t\tthis.pointB = contactPoint.pointOther;\n\t\t\tthis.normal = contactPoint.normal;\n\t\t}\n\t}\n\n}\n\nclass ContactPoint {\n\tconstructor(localPoint = new Vec3(), localPointOther = new Vec3(), point = new Vec3(), pointOther = new Vec3(), normal = new Vec3(), impulse = 0) {\n\t\tthis.localPoint = localPoint;\n\t\tthis.localPointOther = localPointOther;\n\t\tthis.point = point;\n\t\tthis.pointOther = pointOther;\n\t\tthis.normal = normal;\n\t\tthis.impulse = impulse;\n\t}\n\n}\n\nclass ContactResult {\n\tconstructor(other, contacts) {\n\t\tthis.other = other;\n\t\tthis.contacts = contacts;\n\t}\n\n}\n\nconst _schema$7 = ['enabled'];\n\nclass RigidBodyComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'rigidbody';\n\t\tthis._stats = app.stats.frame;\n\t\tthis.ComponentType = RigidBodyComponent;\n\t\tthis.DataType = RigidBodyComponentData;\n\t\tthis.contactPointPool = null;\n\t\tthis.contactResultPool = null;\n\t\tthis.singleContactResultPool = null;\n\t\tthis.schema = _schema$7;\n\t\tthis.maxSubSteps = 10;\n\t\tthis.fixedTimeStep = 1 / 60;\n\t\tthis.gravity = new Vec3(0, -9.81, 0);\n\t\tthis._dynamic = [];\n\t\tthis._kinematic = [];\n\t\tthis._triggers = [];\n\t\tthis._compounds = [];\n\t\tthis.collisions = {};\n\t\tthis.frameCollisions = {};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.on('remove', this.onRemove, this);\n\t}\n\n\tonLibraryLoaded() {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tthis.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n\t\t\tthis.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);\n\t\t\tthis.overlappingPairCache = new Ammo.btDbvtBroadphase();\n\t\t\tthis.solver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\t\tthis.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);\n\n\t\t\tif (this.dynamicsWorld.setInternalTickCallback) {\n\t\t\t\tconst checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');\n\t\t\t\tthis.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);\n\t\t\t}\n\n\t\t\tammoRayStart = new Ammo.btVector3();\n\t\t\tammoRayEnd = new Ammo.btVector3();\n\t\t\tRigidBodyComponent.onLibraryLoaded();\n\t\t\tthis.contactPointPool = new ObjectPool(ContactPoint, 1);\n\t\t\tthis.contactResultPool = new ObjectPool(ContactResult, 1);\n\t\t\tthis.singleContactResultPool = new ObjectPool(SingleContactResult, 1);\n\t\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\t} else {\n\t\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t\t}\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tconst props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];\n\n\t\tfor (const property of props) {\n\t\t\tif (data.hasOwnProperty(property)) {\n\t\t\t\tconst value = data[property];\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tcomponent[property] = new Vec3(value[0], value[1], value[2]);\n\t\t\t\t} else {\n\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst rigidbody = entity.rigidbody;\n\t\tconst data = {\n\t\t\tenabled: rigidbody.enabled,\n\t\t\tmass: rigidbody.mass,\n\t\t\tlinearDamping: rigidbody.linearDamping,\n\t\t\tangularDamping: rigidbody.angularDamping,\n\t\t\tlinearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],\n\t\t\tangularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],\n\t\t\tfriction: rigidbody.friction,\n\t\t\trollingFriction: rigidbody.rollingFriction,\n\t\t\trestitution: rigidbody.restitution,\n\t\t\ttype: rigidbody.type,\n\t\t\tgroup: rigidbody.group,\n\t\t\tmask: rigidbody.mask\n\t\t};\n\t\tthis.addComponent(clone, data);\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tif (component.enabled) {\n\t\t\tcomponent.enabled = false;\n\t\t}\n\t}\n\n\tonRemove(entity, component) {\n\t\tconst body = component.body;\n\n\t\tif (body) {\n\t\t\tthis.removeBody(body);\n\t\t\tthis.destroyBody(body);\n\t\t\tcomponent.body = null;\n\t\t}\n\t}\n\n\taddBody(body, group, mask) {\n\t\tif (group !== undefined && mask !== undefined) {\n\t\t\tthis.dynamicsWorld.addRigidBody(body, group, mask);\n\t\t} else {\n\t\t\tthis.dynamicsWorld.addRigidBody(body);\n\t\t}\n\t}\n\n\tremoveBody(body) {\n\t\tthis.dynamicsWorld.removeRigidBody(body);\n\t}\n\n\tcreateBody(mass, shape, transform) {\n\t\tconst localInertia = new Ammo.btVector3(0, 0, 0);\n\n\t\tif (mass !== 0) {\n\t\t\tshape.calculateLocalInertia(mass, localInertia);\n\t\t}\n\n\t\tconst motionState = new Ammo.btDefaultMotionState(transform);\n\t\tconst bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n\t\tconst body = new Ammo.btRigidBody(bodyInfo);\n\t\tAmmo.destroy(bodyInfo);\n\t\tAmmo.destroy(localInertia);\n\t\treturn body;\n\t}\n\n\tdestroyBody(body) {\n\t\tconst motionState = body.getMotionState();\n\n\t\tif (motionState) {\n\t\t\tAmmo.destroy(motionState);\n\t\t}\n\n\t\tAmmo.destroy(body);\n\t}\n\n\traycastFirst(start, end) {\n\t\tlet result = null;\n\t\tammoRayStart.setValue(start.x, start.y, start.z);\n\t\tammoRayEnd.setValue(end.x, end.y, end.z);\n\t\tconst rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);\n\t\tthis.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);\n\n\t\tif (rayCallback.hasHit()) {\n\t\t\tconst collisionObj = rayCallback.get_m_collisionObject();\n\t\t\tconst body = Ammo.castObject(collisionObj, Ammo.btRigidBody);\n\n\t\t\tif (body) {\n\t\t\t\tconst point = rayCallback.get_m_hitPointWorld();\n\t\t\t\tconst normal = rayCallback.get_m_hitNormalWorld();\n\t\t\t\tresult = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));\n\n\t\t\t\tif (arguments.length > 2) {\n\t\t\t\t\tconst callback = arguments[2];\n\t\t\t\t\tcallback(result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAmmo.destroy(rayCallback);\n\t\treturn result;\n\t}\n\n\traycastAll(start, end) {\n\t\tconst results = [];\n\t\tammoRayStart.setValue(start.x, start.y, start.z);\n\t\tammoRayEnd.setValue(end.x, end.y, end.z);\n\t\tconst rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);\n\t\tthis.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);\n\n\t\tif (rayCallback.hasHit()) {\n\t\t\tconst collisionObjs = rayCallback.get_m_collisionObjects();\n\t\t\tconst points = rayCallback.get_m_hitPointWorld();\n\t\t\tconst normals = rayCallback.get_m_hitNormalWorld();\n\t\t\tconst numHits = collisionObjs.size();\n\n\t\t\tfor (let i = 0; i < numHits; i++) {\n\t\t\t\tconst body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);\n\n\t\t\t\tif (body) {\n\t\t\t\t\tconst point = points.at(i);\n\t\t\t\t\tconst normal = normals.at(i);\n\t\t\t\t\tconst result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()));\n\t\t\t\t\tresults.push(result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAmmo.destroy(rayCallback);\n\t\treturn results;\n\t}\n\n\t_storeCollision(entity, other) {\n\t\tlet isNewCollision = false;\n\t\tconst guid = entity.getGuid();\n\t\tthis.collisions[guid] = this.collisions[guid] || {\n\t\t\tothers: [],\n\t\t\tentity: entity\n\t\t};\n\n\t\tif (this.collisions[guid].others.indexOf(other) < 0) {\n\t\t\tthis.collisions[guid].others.push(other);\n\t\t\tisNewCollision = true;\n\t\t}\n\n\t\tthis.frameCollisions[guid] = this.frameCollisions[guid] || {\n\t\t\tothers: [],\n\t\t\tentity: entity\n\t\t};\n\t\tthis.frameCollisions[guid].others.push(other);\n\t\treturn isNewCollision;\n\t}\n\n\t_createContactPointFromAmmo(contactPoint) {\n\t\tconst localPointA = contactPoint.get_m_localPointA();\n\t\tconst localPointB = contactPoint.get_m_localPointB();\n\t\tconst positionWorldOnA = contactPoint.getPositionWorldOnA();\n\t\tconst positionWorldOnB = contactPoint.getPositionWorldOnB();\n\t\tconst normalWorldOnB = contactPoint.get_m_normalWorldOnB();\n\t\tconst contact = this.contactPointPool.allocate();\n\t\tcontact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());\n\t\tcontact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());\n\t\tcontact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());\n\t\tcontact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());\n\t\tcontact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());\n\t\tcontact.impulse = contactPoint.getAppliedImpulse();\n\t\treturn contact;\n\t}\n\n\t_createReverseContactPointFromAmmo(contactPoint) {\n\t\tconst localPointA = contactPoint.get_m_localPointA();\n\t\tconst localPointB = contactPoint.get_m_localPointB();\n\t\tconst positionWorldOnA = contactPoint.getPositionWorldOnA();\n\t\tconst positionWorldOnB = contactPoint.getPositionWorldOnB();\n\t\tconst normalWorldOnB = contactPoint.get_m_normalWorldOnB();\n\t\tconst contact = this.contactPointPool.allocate();\n\t\tcontact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());\n\t\tcontact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());\n\t\tcontact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());\n\t\tcontact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());\n\t\tcontact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());\n\t\tcontact.impulse = contactPoint.getAppliedImpulse();\n\t\treturn contact;\n\t}\n\n\t_createSingleContactResult(a, b, contactPoint) {\n\t\tconst result = this.singleContactResultPool.allocate();\n\t\tresult.a = a;\n\t\tresult.b = b;\n\t\tresult.localPointA = contactPoint.localPoint;\n\t\tresult.localPointB = contactPoint.localPointOther;\n\t\tresult.pointA = contactPoint.point;\n\t\tresult.pointB = contactPoint.pointOther;\n\t\tresult.normal = contactPoint.normal;\n\t\tresult.impulse = contactPoint.impulse;\n\t\treturn result;\n\t}\n\n\t_createContactResult(other, contacts) {\n\t\tconst result = this.contactResultPool.allocate();\n\t\tresult.other = other;\n\t\tresult.contacts = contacts;\n\t\treturn result;\n\t}\n\n\t_cleanOldCollisions() {\n\t\tfor (const guid in this.collisions) {\n\t\t\tif (this.collisions.hasOwnProperty(guid)) {\n\t\t\t\tconst frameCollision = this.frameCollisions[guid];\n\t\t\t\tconst collision = this.collisions[guid];\n\t\t\t\tconst entity = collision.entity;\n\t\t\t\tconst entityCollision = entity.collision;\n\t\t\t\tconst entityRigidbody = entity.rigidbody;\n\t\t\t\tconst others = collision.others;\n\t\t\t\tconst length = others.length;\n\t\t\t\tlet i = length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tconst other = others[i];\n\n\t\t\t\t\tif (!frameCollision || frameCollision.others.indexOf(other) < 0) {\n\t\t\t\t\t\tothers.splice(i, 1);\n\n\t\t\t\t\t\tif (entity.trigger) {\n\t\t\t\t\t\t\tif (entityCollision) {\n\t\t\t\t\t\t\t\tentityCollision.fire(\"triggerleave\", other);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (other.rigidbody) {\n\t\t\t\t\t\t\t\tother.rigidbody.fire('triggerleave', entity);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!other.trigger) {\n\t\t\t\t\t\t\tif (entityRigidbody) {\n\t\t\t\t\t\t\t\tentityRigidbody.fire(\"collisionend\", other);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (entityCollision) {\n\t\t\t\t\t\t\t\tentityCollision.fire(\"collisionend\", other);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (others.length === 0) {\n\t\t\t\t\tdelete this.collisions[guid];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_hasContactEvent(entity) {\n\t\tconst c = entity.collision;\n\n\t\tif (c && (c.hasEvent(\"collisionstart\") || c.hasEvent(\"collisionend\") || c.hasEvent(\"contact\"))) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst r = entity.rigidbody;\n\t\treturn r && (r.hasEvent(\"collisionstart\") || r.hasEvent(\"collisionend\") || r.hasEvent(\"contact\"));\n\t}\n\n\t_checkForCollisions(world, timeStep) {\n\t\tconst dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);\n\t\tconst dispatcher = dynamicsWorld.getDispatcher();\n\t\tconst numManifolds = dispatcher.getNumManifolds();\n\t\tthis.frameCollisions = {};\n\n\t\tfor (let i = 0; i < numManifolds; i++) {\n\t\t\tconst manifold = dispatcher.getManifoldByIndexInternal(i);\n\t\t\tconst body0 = manifold.getBody0();\n\t\t\tconst body1 = manifold.getBody1();\n\t\t\tconst wb0 = Ammo.castObject(body0, Ammo.btRigidBody);\n\t\t\tconst wb1 = Ammo.castObject(body1, Ammo.btRigidBody);\n\t\t\tconst e0 = wb0.entity;\n\t\t\tconst e1 = wb1.entity;\n\n\t\t\tif (!e0 || !e1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst flags0 = wb0.getCollisionFlags();\n\t\t\tconst flags1 = wb1.getCollisionFlags();\n\t\t\tconst numContacts = manifold.getNumContacts();\n\t\t\tconst forwardContacts = [];\n\t\t\tconst reverseContacts = [];\n\t\t\tlet newCollision;\n\n\t\t\tif (numContacts > 0) {\n\t\t\t\tif (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {\n\t\t\t\t\tconst e0Events = e0.collision && (e0.collision.hasEvent(\"triggerenter\") || e0.collision.hasEvent(\"triggerleave\"));\n\t\t\t\t\tconst e1Events = e1.collision && (e1.collision.hasEvent(\"triggerenter\") || e1.collision.hasEvent(\"triggerleave\"));\n\t\t\t\t\tconst e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent(\"triggerenter\") || e0.rigidbody.hasEvent(\"triggerleave\"));\n\t\t\t\t\tconst e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent(\"triggerenter\") || e1.rigidbody.hasEvent(\"triggerleave\"));\n\n\t\t\t\t\tif (e0Events) {\n\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\n\t\t\t\t\t\tif (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {\n\t\t\t\t\t\t\te0.collision.fire(\"triggerenter\", e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e1Events) {\n\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\n\t\t\t\t\t\tif (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {\n\t\t\t\t\t\t\te1.collision.fire(\"triggerenter\", e0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e0BodyEvents) {\n\t\t\t\t\t\tif (!newCollision) {\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\te0.rigidbody.fire(\"triggerenter\", e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e1BodyEvents) {\n\t\t\t\t\t\tif (!newCollision) {\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\te1.rigidbody.fire(\"triggerenter\", e0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst e0Events = this._hasContactEvent(e0);\n\n\t\t\t\t\tconst e1Events = this._hasContactEvent(e1);\n\n\t\t\t\t\tconst globalEvents = this.hasEvent(\"contact\");\n\n\t\t\t\t\tif (globalEvents || e0Events || e1Events) {\n\t\t\t\t\t\tfor (let j = 0; j < numContacts; j++) {\n\t\t\t\t\t\t\tconst btContactPoint = manifold.getContactPoint(j);\n\n\t\t\t\t\t\t\tconst contactPoint = this._createContactPointFromAmmo(btContactPoint);\n\n\t\t\t\t\t\t\tif (e0Events || e1Events) {\n\t\t\t\t\t\t\t\tforwardContacts.push(contactPoint);\n\n\t\t\t\t\t\t\t\tconst reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);\n\n\t\t\t\t\t\t\t\treverseContacts.push(reverseContactPoint);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (globalEvents) {\n\t\t\t\t\t\t\t\tconst result = this._createSingleContactResult(e0, e1, contactPoint);\n\n\t\t\t\t\t\t\t\tthis.fire(\"contact\", result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (e0Events) {\n\t\t\t\t\t\t\tconst forwardResult = this._createContactResult(e1, forwardContacts);\n\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\n\t\t\t\t\t\t\tif (e0.collision) {\n\t\t\t\t\t\t\t\te0.collision.fire(\"contact\", forwardResult);\n\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te0.collision.fire(\"collisionstart\", forwardResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (e0.rigidbody) {\n\t\t\t\t\t\t\t\te0.rigidbody.fire(\"contact\", forwardResult);\n\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te0.rigidbody.fire(\"collisionstart\", forwardResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (e1Events) {\n\t\t\t\t\t\t\tconst reverseResult = this._createContactResult(e0, reverseContacts);\n\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\n\t\t\t\t\t\t\tif (e1.collision) {\n\t\t\t\t\t\t\t\te1.collision.fire(\"contact\", reverseResult);\n\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te1.collision.fire(\"collisionstart\", reverseResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (e1.rigidbody) {\n\t\t\t\t\t\t\t\te1.rigidbody.fire(\"contact\", reverseResult);\n\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te1.rigidbody.fire(\"collisionstart\", reverseResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._cleanOldCollisions();\n\n\t\tthis.contactPointPool.freeAll();\n\t\tthis.contactResultPool.freeAll();\n\t\tthis.singleContactResultPool.freeAll();\n\t}\n\n\tonUpdate(dt) {\n\t\tlet i, len;\n\t\tconst gravity = this.dynamicsWorld.getGravity();\n\n\t\tif (gravity.x() !== this.gravity.x || gravity.y() !== this.gravity.y || gravity.z() !== this.gravity.z) {\n\t\t\tgravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);\n\t\t\tthis.dynamicsWorld.setGravity(gravity);\n\t\t}\n\n\t\tconst triggers = this._triggers;\n\n\t\tfor (i = 0, len = triggers.length; i < len; i++) {\n\t\t\ttriggers[i].updateTransform();\n\t\t}\n\n\t\tconst compounds = this._compounds;\n\n\t\tfor (i = 0, len = compounds.length; i < len; i++) {\n\t\t\tcompounds[i]._updateCompound();\n\t\t}\n\n\t\tconst kinematic = this._kinematic;\n\n\t\tfor (i = 0, len = kinematic.length; i < len; i++) {\n\t\t\tkinematic[i]._updateKinematic();\n\t\t}\n\n\t\tthis.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);\n\t\tconst dynamic = this._dynamic;\n\n\t\tfor (i = 0, len = dynamic.length; i < len; i++) {\n\t\t\tdynamic[i]._updateDynamic();\n\t\t}\n\n\t\tif (!this.dynamicsWorld.setInternalTickCallback) this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tAmmo.destroy(this.dynamicsWorld);\n\t\t\tAmmo.destroy(this.solver);\n\t\t\tAmmo.destroy(this.overlappingPairCache);\n\t\t\tAmmo.destroy(this.dispatcher);\n\t\t\tAmmo.destroy(this.collisionConfiguration);\n\t\t\tthis.dynamicsWorld = null;\n\t\t\tthis.solver = null;\n\t\t\tthis.overlappingPairCache = null;\n\t\t\tthis.dispatcher = null;\n\t\t\tthis.collisionConfiguration = null;\n\t\t}\n\t}\n\n}\n\nComponent._buildAccessors(RigidBodyComponent.prototype, _schema$7);\n\nconst SCALEMODE_NONE = \"none\";\nconst SCALEMODE_BLEND = \"blend\";\n\nconst _transform = new Mat4();\n\nclass ScreenComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._resolution = new Vec2(640, 320);\n\t\tthis._referenceResolution = new Vec2(640, 320);\n\t\tthis._scaleMode = SCALEMODE_NONE;\n\t\tthis.scale = 1;\n\t\tthis._scaleBlend = 0.5;\n\t\tthis._priority = 0;\n\t\tthis._screenSpace = false;\n\t\tthis.cull = this._screenSpace;\n\t\tthis._screenMatrix = new Mat4();\n\t\tthis._elements = new Set();\n\t\tsystem.app.graphicsDevice.on(\"resizecanvas\", this._onResize, this);\n\t}\n\n\tsyncDrawOrder() {\n\t\tthis.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);\n\t}\n\n\t_recurseDrawOrderSync(e, i) {\n\t\tif (!(e instanceof Entity)) {\n\t\t\treturn i;\n\t\t}\n\n\t\tif (e.element) {\n\t\t\tconst prevDrawOrder = e.element.drawOrder;\n\t\t\te.element.drawOrder = i++;\n\n\t\t\tif (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {\n\t\t\t\tthis.system.app.batcher.markGroupDirty(e.element._batchGroupId);\n\t\t\t}\n\t\t}\n\n\t\tif (e.particlesystem) {\n\t\t\te.particlesystem.drawOrder = i++;\n\t\t}\n\n\t\tconst children = e.children;\n\n\t\tfor (let j = 0; j < children.length; j++) {\n\t\t\ti = this._recurseDrawOrderSync(children[j], i);\n\t\t}\n\n\t\treturn i;\n\t}\n\n\t_processDrawOrderSync() {\n\t\tconst i = 1;\n\n\t\tthis._recurseDrawOrderSync(this.entity, i);\n\n\t\tthis.fire('syncdraworder');\n\t}\n\n\t_calcProjectionMatrix() {\n\t\tconst w = this._resolution.x / this.scale;\n\t\tconst h = this._resolution.y / this.scale;\n\t\tconst left = 0;\n\t\tconst right = w;\n\t\tconst bottom = -h;\n\t\tconst top = 0;\n\t\tconst near = 1;\n\t\tconst far = -1;\n\n\t\tthis._screenMatrix.setOrtho(left, right, bottom, top, near, far);\n\n\t\tif (!this._screenSpace) {\n\t\t\t_transform.setScale(0.5 * w, 0.5 * h, 1);\n\n\t\t\tthis._screenMatrix.mul2(_transform, this._screenMatrix);\n\t\t}\n\t}\n\n\t_updateScale() {\n\t\tthis.scale = this._calcScale(this._resolution, this.referenceResolution);\n\t}\n\n\t_calcScale(resolution, referenceResolution) {\n\t\tconst lx = Math.log2(resolution.x / referenceResolution.x);\n\t\tconst ly = Math.log2(resolution.y / referenceResolution.y);\n\t\treturn Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);\n\t}\n\n\t_onResize(width, height) {\n\t\tif (this._screenSpace) {\n\t\t\tthis._resolution.set(width, height);\n\n\t\t\tthis.resolution = this._resolution;\n\t\t}\n\t}\n\n\t_bindElement(element) {\n\t\tthis._elements.add(element);\n\t}\n\n\t_unbindElement(element) {\n\t\tthis._elements.delete(element);\n\t}\n\n\tonRemove() {\n\t\tthis.system.app.graphicsDevice.off(\"resizecanvas\", this._onResize, this);\n\t\tthis.fire('remove');\n\n\t\tthis._elements.forEach(element => element._onScreenRemove());\n\n\t\tthis._elements.clear();\n\n\t\tthis.off();\n\t}\n\n\tset resolution(value) {\n\t\tif (!this._screenSpace) {\n\t\t\tthis._resolution.set(value.x, value.y);\n\t\t} else {\n\t\t\tthis._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);\n\t\t}\n\n\t\tthis._updateScale();\n\n\t\tthis._calcProjectionMatrix();\n\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire(\"set:resolution\", this._resolution);\n\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\n\tget resolution() {\n\t\treturn this._resolution;\n\t}\n\n\tset referenceResolution(value) {\n\t\tthis._referenceResolution.set(value.x, value.y);\n\n\t\tthis._updateScale();\n\n\t\tthis._calcProjectionMatrix();\n\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire(\"set:referenceresolution\", this._resolution);\n\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\n\tget referenceResolution() {\n\t\tif (this._scaleMode === SCALEMODE_NONE) {\n\t\t\treturn this._resolution;\n\t\t}\n\n\t\treturn this._referenceResolution;\n\t}\n\n\tset screenSpace(value) {\n\t\tthis._screenSpace = value;\n\n\t\tif (this._screenSpace) {\n\t\t\tthis._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);\n\t\t}\n\n\t\tthis.resolution = this._resolution;\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire('set:screenspace', this._screenSpace);\n\n\t\tthis._elements.forEach(element => element._onScreenSpaceChange());\n\t}\n\n\tget screenSpace() {\n\t\treturn this._screenSpace;\n\t}\n\n\tset scaleMode(value) {\n\t\tif (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {\n\t\t\tvalue = SCALEMODE_NONE;\n\t\t}\n\n\t\tif (!this._screenSpace && value !== SCALEMODE_NONE) {\n\t\t\tvalue = SCALEMODE_NONE;\n\t\t}\n\n\t\tthis._scaleMode = value;\n\t\tthis.resolution = this._resolution;\n\t\tthis.fire(\"set:scalemode\", this._scaleMode);\n\t}\n\n\tget scaleMode() {\n\t\treturn this._scaleMode;\n\t}\n\n\tset scaleBlend(value) {\n\t\tthis._scaleBlend = value;\n\n\t\tthis._updateScale();\n\n\t\tthis._calcProjectionMatrix();\n\n\t\tif (!this.entity._dirtyLocal) this.entity._dirtifyLocal();\n\t\tthis.fire(\"set:scaleblend\", this._scaleBlend);\n\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\n\tget scaleBlend() {\n\t\treturn this._scaleBlend;\n\t}\n\n\tset priority(value) {\n\t\tif (value > 0xFF) {\n\t\t\tvalue = 0xFF;\n\t\t}\n\n\t\tthis._priority = value;\n\t}\n\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\n}\n\nclass ScreenComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$6 = ['enabled'];\n\nclass ScreenComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'screen';\n\t\tthis.ComponentType = ScreenComponent;\n\t\tthis.DataType = ScreenComponentData;\n\t\tthis.schema = _schema$6;\n\t\tthis.windowResolution = new Vec2();\n\t\tthis._drawOrderSyncQueue = new IndexedList();\n\t\tthis.app.graphicsDevice.on(\"resizecanvas\", this._onResize, this);\n\t\tthis.app.systems.on('update', this._onUpdate, this);\n\t\tthis.on('beforeremove', this.onRemoveComponent, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.priority !== undefined) component.priority = data.priority;\n\t\tif (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;\n\t\tcomponent.cull = component.screenSpace;\n\t\tif (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;\n\t\tif (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;\n\n\t\tif (data.resolution !== undefined) {\n\t\t\tif (data.resolution instanceof Vec2) {\n\t\t\t\tcomponent._resolution.copy(data.resolution);\n\t\t\t} else {\n\t\t\t\tcomponent._resolution.set(data.resolution[0], data.resolution[1]);\n\t\t\t}\n\n\t\t\tcomponent.resolution = component._resolution;\n\t\t}\n\n\t\tif (data.referenceResolution !== undefined) {\n\t\t\tif (data.referenceResolution instanceof Vec2) {\n\t\t\t\tcomponent._referenceResolution.copy(data.referenceResolution);\n\t\t\t} else {\n\t\t\t\tcomponent._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);\n\t\t\t}\n\n\t\t\tcomponent.referenceResolution = component._referenceResolution;\n\t\t}\n\n\t\tcomponent.syncDrawOrder();\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.graphicsDevice.off(\"resizecanvas\", this._onResize, this);\n\t\tthis.app.systems.off('update', this._onUpdate, this);\n\t}\n\n\t_onUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components[id].entity.screen.update) components[id].entity.screen.update(dt);\n\t\t}\n\t}\n\n\t_onResize(width, height) {\n\t\tthis.windowResolution.x = width;\n\t\tthis.windowResolution.y = height;\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst screen = entity.screen;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: screen.enabled,\n\t\t\tscreenSpace: screen.screenSpace,\n\t\t\tscaleMode: screen.scaleMode,\n\t\t\tresolution: screen.resolution.clone(),\n\t\t\treferenceResolution: screen.referenceResolution.clone()\n\t\t});\n\t}\n\n\tonRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tprocessDrawOrderSyncQueue() {\n\t\tconst list = this._drawOrderSyncQueue.list();\n\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst item = list[i];\n\t\t\titem.callback.call(item.scope);\n\t\t}\n\n\t\tthis._drawOrderSyncQueue.clear();\n\t}\n\n\tqueueDrawOrderSync(id, fn, scope) {\n\t\tif (!this._drawOrderSyncQueue.list().length) {\n\t\t\tthis.app.once('prerender', this.processDrawOrderSyncQueue, this);\n\t\t}\n\n\t\tif (!this._drawOrderSyncQueue.has(id)) {\n\t\t\tthis._drawOrderSyncQueue.push(id, {\n\t\t\t\tcallback: fn,\n\t\t\t\tscope: scope\n\t\t\t});\n\t\t}\n\t}\n\n}\n\nComponent._buildAccessors(ScreenComponent.prototype, _schema$6);\n\nclass ScriptComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';\nconst METHOD_INITIALIZE = '_onInitialize';\nconst METHOD_POST_INITIALIZE = '_onPostInitialize';\nconst METHOD_UPDATE = '_onUpdate';\nconst METHOD_POST_UPDATE = '_onPostUpdate';\nlet executionOrderCounter = 0;\n\nclass ScriptComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'script';\n\t\tthis.ComponentType = ScriptComponent;\n\t\tthis.DataType = ScriptComponentData;\n\t\tthis._components = new SortedLoopArray({\n\t\t\tsortBy: '_executionOrder'\n\t\t});\n\t\tthis._enabledComponents = new SortedLoopArray({\n\t\t\tsortBy: '_executionOrder'\n\t\t});\n\t\tthis.preloading = true;\n\t\tthis.on('beforeremove', this._onBeforeRemove, this);\n\t\tthis.app.systems.on('initialize', this._onInitialize, this);\n\t\tthis.app.systems.on('postInitialize', this._onPostInitialize, this);\n\t\tthis.app.systems.on('update', this._onUpdate, this);\n\t\tthis.app.systems.on('postUpdate', this._onPostUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data) {\n\t\tcomponent._executionOrder = executionOrderCounter++;\n\n\t\tthis._components.append(component);\n\n\t\tif (executionOrderCounter > Number.MAX_SAFE_INTEGER) {\n\t\t\tthis._resetExecutionOrder();\n\t\t}\n\n\t\tcomponent.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;\n\n\t\tif (component.enabled && component.entity.enabled) {\n\t\t\tthis._enabledComponents.append(component);\n\t\t}\n\n\t\tif (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {\n\t\t\tcomponent._scriptsData = data.scripts;\n\n\t\t\tfor (let i = 0; i < data.order.length; i++) {\n\t\t\t\tcomponent.create(data.order[i], {\n\t\t\t\t\tenabled: data.scripts[data.order[i]].enabled,\n\t\t\t\t\tattributes: data.scripts[data.order[i]].attributes,\n\t\t\t\t\tpreloading: this.preloading\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst order = [];\n\t\tconst scripts = {};\n\n\t\tfor (let i = 0; i < entity.script._scripts.length; i++) {\n\t\t\tconst scriptInstance = entity.script._scripts[i];\n\t\t\tconst scriptName = scriptInstance.__scriptType.__name;\n\t\t\torder.push(scriptName);\n\t\t\tconst attributes = {};\n\n\t\t\tfor (const key in scriptInstance.__attributes) attributes[key] = scriptInstance.__attributes[key];\n\n\t\t\tscripts[scriptName] = {\n\t\t\t\tenabled: scriptInstance._enabled,\n\t\t\t\tattributes: attributes\n\t\t\t};\n\t\t}\n\n\t\tfor (const key in entity.script._scriptsIndex) {\n\t\t\tif (key.awaiting) {\n\t\t\t\torder.splice(key.ind, 0, key);\n\t\t\t}\n\t\t}\n\n\t\tconst data = {\n\t\t\tenabled: entity.script.enabled,\n\t\t\torder: order,\n\t\t\tscripts: scripts\n\t\t};\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\t_resetExecutionOrder() {\n\t\texecutionOrderCounter = 0;\n\n\t\tfor (let i = 0, len = this._components.length; i < len; i++) {\n\t\t\tthis._components.items[i]._executionOrder = executionOrderCounter++;\n\t\t}\n\t}\n\n\t_callComponentMethod(components, name, dt) {\n\t\tfor (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {\n\t\t\tcomponents.items[components.loopIndex][name](dt);\n\t\t}\n\t}\n\n\t_onInitialize() {\n\t\tthis.preloading = false;\n\n\t\tthis._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);\n\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);\n\t}\n\n\t_onPostInitialize() {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);\n\t}\n\n\t_onUpdate(dt) {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);\n\t}\n\n\t_onPostUpdate(dt) {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);\n\t}\n\n\t_addComponentToEnabled(component) {\n\t\tthis._enabledComponents.insert(component);\n\t}\n\n\t_removeComponentFromEnabled(component) {\n\t\tthis._enabledComponents.remove(component);\n\t}\n\n\t_onBeforeRemove(entity, component) {\n\t\tconst ind = this._components.items.indexOf(component);\n\n\t\tif (ind >= 0) {\n\t\t\tcomponent._onBeforeRemove();\n\t\t}\n\n\t\tthis._removeComponentFromEnabled(component);\n\n\t\tthis._components.remove(component);\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('initialize', this._onInitialize, this);\n\t\tthis.app.systems.off('postInitialize', this._onPostInitialize, this);\n\t\tthis.app.systems.off('update', this._onUpdate, this);\n\t\tthis.app.systems.off('postUpdate', this._onPostUpdate, this);\n\t}\n\n}\n\nclass ScriptLegacyComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.on(\"set_scripts\", this.onSetScripts, this);\n\t}\n\n\tsend(name, functionName) {\n\t\tconst args = Array.prototype.slice.call(arguments, 2);\n\t\tconst instances = this.entity.script.instances;\n\t\tlet fn;\n\n\t\tif (instances && instances[name]) {\n\t\t\tfn = instances[name].instance[functionName];\n\n\t\t\tif (fn) {\n\t\t\t\treturn fn.apply(instances[name].instance, args);\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tif (this.data.areScriptsLoaded && !this.system.preloading) {\n\t\t\tif (!this.data.initialized) {\n\t\t\t\tthis.system._initializeScriptComponent(this);\n\t\t\t} else {\n\t\t\t\tthis.system._enableScriptComponent(this);\n\t\t\t}\n\n\t\t\tif (!this.data.postInitialized) {\n\t\t\t\tthis.system._postInitializeScriptComponent(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tthis.system._disableScriptComponent(this);\n\t}\n\n\tonSetScripts(name, oldValue, newValue) {\n\t\tif (!this.system._inTools || this.runInTools) {\n\t\t\tif (this._updateScriptAttributes(oldValue, newValue)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.enabled) {\n\t\t\t\tthis.system._disableScriptComponent(this);\n\t\t\t}\n\n\t\t\tthis.system._destroyScriptComponent(this);\n\n\t\t\tthis.data.areScriptsLoaded = false;\n\t\t\tconst scripts = newValue;\n\t\t\tconst urls = scripts.map(function (s) {\n\t\t\t\treturn s.url;\n\t\t\t});\n\n\t\t\tif (this._loadFromCache(urls)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._loadScripts(urls);\n\t\t}\n\t}\n\n\t_updateScriptAttributes(oldValue, newValue) {\n\t\tlet onlyUpdateAttributes = true;\n\n\t\tif (oldValue.length !== newValue.length) {\n\t\t\tonlyUpdateAttributes = false;\n\t\t} else {\n\t\t\tfor (let i = 0, len = newValue.length; i < len; i++) {\n\t\t\t\tif (oldValue[i].url !== newValue[i].url) {\n\t\t\t\t\tonlyUpdateAttributes = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (onlyUpdateAttributes) {\n\t\t\tfor (const key in this.instances) {\n\t\t\t\tif (this.instances.hasOwnProperty(key)) {\n\t\t\t\t\tthis.system._updateAccessors(this.entity, this.instances[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn onlyUpdateAttributes;\n\t}\n\n\t_loadFromCache(urls) {\n\t\tconst cached = [];\n\t\tconst prefix = this.system.app._scriptPrefix || \"\";\n\t\tconst regex = /^http(s)?:\\/\\//i;\n\n\t\tfor (let i = 0, len = urls.length; i < len; i++) {\n\t\t\tlet url = urls[i];\n\n\t\t\tif (!regex.test(url)) {\n\t\t\t\turl = path.join(prefix, url);\n\t\t\t}\n\n\t\t\tconst type = this.system.app.loader.getFromCache(url, 'script');\n\n\t\t\tif (!type) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tcached.push(type);\n\t\t}\n\n\t\tfor (let i = 0, len = cached.length; i < len; i++) {\n\t\t\tconst ScriptType = cached[i];\n\n\t\t\tif (ScriptType === true) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ScriptType && this.entity.script) {\n\t\t\t\tif (!this.entity.script.instances[ScriptType._pcScriptName]) {\n\t\t\t\t\tconst instance = new ScriptType(this.entity);\n\n\t\t\t\t\tthis.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.data) {\n\t\t\tthis.data.areScriptsLoaded = true;\n\t\t}\n\n\t\tif (!this.system.preloading) {\n\t\t\tthis.system.onInitialize(this.entity);\n\t\t\tthis.system.onPostInitialize(this.entity);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t_loadScripts(urls) {\n\t\tlet count = urls.length;\n\t\tconst prefix = this.system.app._scriptPrefix || \"\";\n\t\turls.forEach(url => {\n\t\t\tlet _url = null;\n\t\t\tlet _unprefixed = null;\n\n\t\t\tif (url.toLowerCase().startsWith(\"http://\") || url.toLowerCase().startsWith(\"https://\")) {\n\t\t\t\t_unprefixed = url;\n\t\t\t\t_url = url;\n\t\t\t} else {\n\t\t\t\t_unprefixed = url;\n\t\t\t\t_url = path.join(prefix, url);\n\t\t\t}\n\n\t\t\tthis.system.app.loader.load(_url, \"script\", (err, ScriptType) => {\n\t\t\t\tcount--;\n\n\t\t\t\tif (!err) {\n\t\t\t\t\tif (ScriptType && this.entity.script) {\n\t\t\t\t\t\tif (!this.entity.script.instances[ScriptType._pcScriptName]) {\n\t\t\t\t\t\t\tconst instance = new ScriptType(this.entity);\n\n\t\t\t\t\t\t\tthis.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\n\t\t\t\tif (count === 0) {\n\t\t\t\t\tthis.data.areScriptsLoaded = true;\n\n\t\t\t\t\tif (!this.system.preloading) {\n\t\t\t\t\t\tthis.system.onInitialize(this.entity);\n\t\t\t\t\t\tthis.system.onPostInitialize(this.entity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n}\n\nclass ScriptLegacyComponentData {\n\tconstructor() {\n\t\tthis.scripts = [];\n\t\tthis.enabled = true;\n\t\tthis.instances = {};\n\t\tthis._instances = {};\n\t\tthis.runInTools = false;\n\t\tthis.attributes = {};\n\t\tthis.initialized = false;\n\t\tthis.postInitialized = false;\n\t\tthis.areScriptsLoaded = false;\n\t}\n\n}\n\nconst _schema$5 = ['enabled', 'scripts', 'instances', 'runInTools'];\nconst INITIALIZE = \"initialize\";\nconst POST_INITIALIZE = \"postInitialize\";\nconst UPDATE = \"update\";\nconst POST_UPDATE = \"postUpdate\";\nconst FIXED_UPDATE = \"fixedUpdate\";\nconst TOOLS_UPDATE = \"toolsUpdate\";\nconst ON_ENABLE = 'onEnable';\nconst ON_DISABLE = 'onDisable';\n\nclass ScriptLegacyComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'script';\n\t\tthis.ComponentType = ScriptLegacyComponent;\n\t\tthis.DataType = ScriptLegacyComponentData;\n\t\tthis.schema = _schema$5;\n\t\tthis.preloading = false;\n\t\tthis.instancesWithUpdate = [];\n\t\tthis.instancesWithFixedUpdate = [];\n\t\tthis.instancesWithPostUpdate = [];\n\t\tthis.instancesWithToolsUpdate = [];\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on(INITIALIZE, this.onInitialize, this);\n\t\tthis.app.systems.on(POST_INITIALIZE, this.onPostInitialize, this);\n\t\tthis.app.systems.on(UPDATE, this.onUpdate, this);\n\t\tthis.app.systems.on(FIXED_UPDATE, this.onFixedUpdate, this);\n\t\tthis.app.systems.on(POST_UPDATE, this.onPostUpdate, this);\n\t\tthis.app.systems.on(TOOLS_UPDATE, this.onToolsUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['runInTools', 'enabled', 'scripts'];\n\n\t\tif (data.scripts && data.scripts.length) {\n\t\t\tdata.scripts.forEach(function (script) {\n\t\t\t\tif (script.attributes && Array.isArray(script.attributes)) {\n\t\t\t\t\tconst dict = {};\n\n\t\t\t\t\tfor (let i = 0; i < script.attributes.length; i++) {\n\t\t\t\t\t\tdict[script.attributes[i].name] = script.attributes[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tscript.attributes = dict;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst src = this.store[entity.getGuid()];\n\t\tconst data = {\n\t\t\trunInTools: src.data.runInTools,\n\t\t\tscripts: [],\n\t\t\tenabled: src.data.enabled\n\t\t};\n\t\tconst scripts = src.data.scripts;\n\n\t\tfor (let i = 0, len = scripts.length; i < len; i++) {\n\t\t\tconst attributes = scripts[i].attributes;\n\n\t\t\tif (attributes) {\n\t\t\t\tdelete scripts[i].attributes;\n\t\t\t}\n\n\t\t\tdata.scripts.push(extend({}, scripts[i]));\n\n\t\t\tif (attributes) {\n\t\t\t\tdata.scripts[i].attributes = this._cloneAttributes(attributes);\n\t\t\t\tscripts[i].attributes = attributes;\n\t\t\t}\n\t\t}\n\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tif (component.enabled) {\n\t\t\tthis._disableScriptComponent(component);\n\t\t}\n\n\t\tthis._destroyScriptComponent(component);\n\t}\n\n\tonInitialize(root) {\n\t\tthis._registerInstances(root);\n\n\t\tif (root.enabled) {\n\t\t\tif (root.script && root.script.enabled) {\n\t\t\t\tthis._initializeScriptComponent(root.script);\n\t\t\t}\n\n\t\t\tconst children = root._children;\n\n\t\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\t\tthis.onInitialize(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonPostInitialize(root) {\n\t\tif (root.enabled) {\n\t\t\tif (root.script && root.script.enabled) {\n\t\t\t\tthis._postInitializeScriptComponent(root.script);\n\t\t\t}\n\n\t\t\tconst children = root._children;\n\n\t\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\t\tthis.onPostInitialize(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_callInstancesMethod(script, method) {\n\t\tconst instances = script.data.instances;\n\n\t\tfor (const name in instances) {\n\t\t\tif (instances.hasOwnProperty(name)) {\n\t\t\t\tconst instance = instances[name].instance;\n\n\t\t\t\tif (instance[method]) {\n\t\t\t\t\tinstance[method]();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_initializeScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, INITIALIZE);\n\n\t\tscript.data.initialized = true;\n\n\t\tif (script.enabled && script.entity.enabled) {\n\t\t\tthis._enableScriptComponent(script);\n\t\t}\n\t}\n\n\t_enableScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, ON_ENABLE);\n\t}\n\n\t_disableScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, ON_DISABLE);\n\t}\n\n\t_destroyScriptComponent(script) {\n\t\tconst instances = script.data.instances;\n\n\t\tfor (const name in instances) {\n\t\t\tif (instances.hasOwnProperty(name)) {\n\t\t\t\tconst instance = instances[name].instance;\n\n\t\t\t\tif (instance.destroy) {\n\t\t\t\t\tinstance.destroy();\n\t\t\t\t}\n\n\t\t\t\tif (instance.update) {\n\t\t\t\t\tconst index = this.instancesWithUpdate.indexOf(instance);\n\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (instance.fixedUpdate) {\n\t\t\t\t\tconst index = this.instancesWithFixedUpdate.indexOf(instance);\n\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithFixedUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (instance.postUpdate) {\n\t\t\t\t\tconst index = this.instancesWithPostUpdate.indexOf(instance);\n\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithPostUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (instance.toolsUpdate) {\n\t\t\t\t\tconst index = this.instancesWithToolsUpdate.indexOf(instance);\n\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithToolsUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (script.instances[name].instance === script[name]) {\n\t\t\t\t\tdelete script[name];\n\t\t\t\t}\n\n\t\t\t\tdelete script.instances[name];\n\t\t\t}\n\t\t}\n\t}\n\n\t_postInitializeScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, POST_INITIALIZE);\n\n\t\tscript.data.postInitialized = true;\n\t}\n\n\t_updateInstances(method, updateList, dt) {\n\t\tfor (let i = 0, len = updateList.length; i < len; i++) {\n\t\t\tconst item = updateList[i];\n\n\t\t\tif (item && item.entity && item.entity.enabled && item.entity.script.enabled) {\n\t\t\t\titem[method](dt);\n\t\t\t}\n\t\t}\n\t}\n\n\tonUpdate(dt) {\n\t\tthis._updateInstances(UPDATE, this.instancesWithUpdate, dt);\n\t}\n\n\tonFixedUpdate(dt) {\n\t\tthis._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);\n\t}\n\n\tonPostUpdate(dt) {\n\t\tthis._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);\n\t}\n\n\tonToolsUpdate(dt) {\n\t\tthis._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);\n\t}\n\n\tbroadcast(name, functionName) {\n\t\tconst args = Array.prototype.slice.call(arguments, 2);\n\t\tconst dataStore = this.store;\n\n\t\tfor (const id in dataStore) {\n\t\t\tif (dataStore.hasOwnProperty(id)) {\n\t\t\t\tconst data = dataStore[id].data;\n\n\t\t\t\tif (data.instances[name]) {\n\t\t\t\t\tconst fn = data.instances[name].instance[functionName];\n\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tfn.apply(data.instances[name].instance, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_preRegisterInstance(entity, url, name, instance) {\n\t\tif (entity.script) {\n\t\t\tentity.script.data._instances = entity.script.data._instances || {};\n\n\t\t\tif (entity.script.data._instances[name]) {\n\t\t\t\tthrow Error(`Script name collision '${name}'. Scripts from '${url}' and '${entity.script.data._instances[name].url}' {${entity.getGuid()}}`);\n\t\t\t}\n\n\t\t\tentity.script.data._instances[name] = {\n\t\t\t\turl: url,\n\t\t\t\tname: name,\n\t\t\t\tinstance: instance\n\t\t\t};\n\t\t}\n\t}\n\n\t_registerInstances(entity) {\n\t\tif (entity.script) {\n\t\t\tif (entity.script.data._instances) {\n\t\t\t\tentity.script.instances = entity.script.data._instances;\n\n\t\t\t\tfor (const instanceName in entity.script.instances) {\n\t\t\t\t\tconst preRegistered = entity.script.instances[instanceName];\n\t\t\t\t\tconst instance = preRegistered.instance;\n\t\t\t\t\tevents.attach(instance);\n\n\t\t\t\t\tif (instance.update) {\n\t\t\t\t\t\tthis.instancesWithUpdate.push(instance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (instance.fixedUpdate) {\n\t\t\t\t\t\tthis.instancesWithFixedUpdate.push(instance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (instance.postUpdate) {\n\t\t\t\t\t\tthis.instancesWithPostUpdate.push(instance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (instance.toolsUpdate) {\n\t\t\t\t\t\tthis.instancesWithToolsUpdate.push(instance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (entity.script.scripts) {\n\t\t\t\t\t\tthis._createAccessors(entity, preRegistered);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (entity.script[instanceName]) {\n\t\t\t\t\t\tthrow Error(`Script with name '${instanceName}' is already attached to Script Component`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentity.script[instanceName] = instance;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdelete entity.script.data._instances;\n\t\t\t}\n\t\t}\n\n\t\tconst children = entity._children;\n\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\tthis._registerInstances(children[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t_cloneAttributes(attributes) {\n\t\tconst result = {};\n\n\t\tfor (const key in attributes) {\n\t\t\tif (!attributes.hasOwnProperty(key)) continue;\n\n\t\t\tif (attributes[key].type !== 'entity') {\n\t\t\t\tresult[key] = extend({}, attributes[key]);\n\t\t\t} else {\n\t\t\t\tconst val = attributes[key].value;\n\t\t\t\tdelete attributes[key].value;\n\t\t\t\tresult[key] = extend({}, attributes[key]);\n\t\t\t\tresult[key].value = val;\n\t\t\t\tattributes[key].value = val;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_createAccessors(entity, instance) {\n\t\tconst len = entity.script.scripts.length;\n\t\tconst url = instance.url;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst script = entity.script.scripts[i];\n\n\t\t\tif (script.url === url) {\n\t\t\t\tconst attributes = script.attributes;\n\n\t\t\t\tif (script.name && attributes) {\n\t\t\t\t\tfor (const key in attributes) {\n\t\t\t\t\t\tif (attributes.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tthis._createAccessor(attributes[key], instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tentity.script.data.attributes[script.name] = this._cloneAttributes(attributes);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_createAccessor(attribute, instance) {\n\t\tconst self = this;\n\t\tattribute = {\n\t\t\tname: attribute.name,\n\t\t\tvalue: attribute.value,\n\t\t\ttype: attribute.type\n\t\t};\n\n\t\tthis._convertAttributeValue(attribute);\n\n\t\tObject.defineProperty(instance.instance, attribute.name, {\n\t\t\tget: function () {\n\t\t\t\treturn attribute.value;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconst oldValue = attribute.value;\n\t\t\t\tattribute.value = value;\n\n\t\t\t\tself._convertAttributeValue(attribute);\n\n\t\t\t\tinstance.instance.fire(\"set\", attribute.name, oldValue, attribute.value);\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\n\t_updateAccessors(entity, instance) {\n\t\tconst len = entity.script.scripts.length;\n\t\tconst url = instance.url;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst scriptComponent = entity.script;\n\t\t\tconst script = scriptComponent.scripts[i];\n\n\t\t\tif (script.url === url) {\n\t\t\t\tconst name = script.name;\n\t\t\t\tconst attributes = script.attributes;\n\n\t\t\t\tif (name) {\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\tfor (const key in attributes) {\n\t\t\t\t\t\t\tif (attributes.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tthis._createAccessor(attributes[key], instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst previousAttributes = scriptComponent.data.attributes[name];\n\n\t\t\t\t\tif (previousAttributes) {\n\t\t\t\t\t\tfor (const key in previousAttributes) {\n\t\t\t\t\t\t\tconst oldAttribute = previousAttributes[key];\n\n\t\t\t\t\t\t\tif (!(key in attributes)) {\n\t\t\t\t\t\t\t\tdelete instance.instance[oldAttribute.name];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (attributes[key].value !== oldAttribute.value) {\n\t\t\t\t\t\t\t\t\tif (instance.instance.onAttributeChanged) {\n\t\t\t\t\t\t\t\t\t\tinstance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\tscriptComponent.data.attributes[name] = this._cloneAttributes(attributes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete scriptComponent.data.attributes[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t_convertAttributeValue(attribute) {\n\t\tif (attribute.type === 'rgb' || attribute.type === 'rgba') {\n\t\t\tif (Array.isArray(attribute.value)) {\n\t\t\t\tattribute.value = attribute.value.length === 3 ? new Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);\n\t\t\t}\n\t\t} else if (attribute.type === 'vec2') {\n\t\t\tif (Array.isArray(attribute.value)) attribute.value = new Vec2(attribute.value[0], attribute.value[1]);\n\t\t} else if (attribute.type === 'vec3' || attribute.type === 'vector') {\n\t\t\tif (Array.isArray(attribute.value)) attribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);\n\t\t} else if (attribute.type === 'vec4') {\n\t\t\tif (Array.isArray(attribute.value)) attribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);\n\t\t} else if (attribute.type === 'entity') {\n\t\t\tif (attribute.value !== null && typeof attribute.value === 'string') attribute.value = this.app.root.findByGuid(attribute.value);\n\t\t} else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {\n\t\t\tconst curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;\n\t\t\tattribute.value = new curveType(attribute.value.keys);\n\t\t\tattribute.value.type = attribute.value.type;\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off(INITIALIZE, this.onInitialize, this);\n\t\tthis.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);\n\t\tthis.app.systems.off(UPDATE, this.onUpdate, this);\n\t\tthis.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);\n\t\tthis.app.systems.off(POST_UPDATE, this.onPostUpdate, this);\n\t\tthis.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(ScriptLegacyComponent.prototype, _schema$5);\n\nconst _inputScreenPosition = new Vec2();\n\nconst _inputWorldPosition = new Vec3();\n\nconst _rayOrigin = new Vec3();\n\nconst _rayDirection = new Vec3();\n\nconst _planeOrigin = new Vec3();\n\nconst _planeNormal = new Vec3();\n\nconst _entityRotation = new Quat();\n\nconst OPPOSITE_AXIS = {\n\tx: 'y',\n\ty: 'x'\n};\n\nclass ElementDragHelper extends EventHandler {\n\tconstructor(element, axis) {\n\t\tsuper();\n\n\t\tif (!element || !(element instanceof ElementComponent)) {\n\t\t\tthrow new Error('Element was null or not an ElementComponent');\n\t\t}\n\n\t\tif (axis && axis !== 'x' && axis !== 'y') {\n\t\t\tthrow new Error('Unrecognized axis: ' + axis);\n\t\t}\n\n\t\tthis._element = element;\n\t\tthis._app = element.system.app;\n\t\tthis._axis = axis || null;\n\t\tthis._enabled = true;\n\t\tthis._dragScale = new Vec3();\n\t\tthis._dragStartMousePosition = new Vec3();\n\t\tthis._dragStartHandlePosition = new Vec3();\n\t\tthis._deltaMousePosition = new Vec3();\n\t\tthis._deltaHandlePosition = new Vec3();\n\t\tthis._isDragging = false;\n\n\t\tthis._toggleLifecycleListeners('on');\n\t}\n\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);\n\n\t\tthis._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);\n\t}\n\n\t_toggleDragListeners(onOrOff) {\n\t\tconst isOn = onOrOff === 'on';\n\t\tconst addOrRemoveEventListener = isOn ? 'addEventListener' : 'removeEventListener';\n\n\t\tif (this._hasDragListeners && isOn) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._handleMouseUpOrTouchEnd) {\n\t\t\tthis._handleMouseUpOrTouchEnd = this._onMouseUpOrTouchEnd.bind(this);\n\t\t}\n\n\t\tif (this._app.mouse) {\n\t\t\tthis._app.mouse[onOrOff]('mousemove', this._onMove, this);\n\n\t\t\twindow[addOrRemoveEventListener]('mouseup', this._handleMouseUpOrTouchEnd, false);\n\t\t}\n\n\t\tif (platform.touch) {\n\t\t\tthis._app.touch[onOrOff]('touchmove', this._onMove, this);\n\n\t\t\twindow[addOrRemoveEventListener]('touchend', this._handleMouseUpOrTouchEnd, false);\n\t\t\twindow[addOrRemoveEventListener]('touchcancel', this._handleMouseUpOrTouchEnd, false);\n\t\t}\n\n\t\tthis._hasDragListeners = isOn;\n\t}\n\n\t_onMouseDownOrTouchStart(event) {\n\t\tif (this._element && !this._isDragging && this.enabled) {\n\t\t\tthis._dragCamera = event.camera;\n\n\t\t\tthis._calculateDragScale();\n\n\t\t\tconst currentMousePosition = this._screenToLocal(event);\n\n\t\t\tif (currentMousePosition) {\n\t\t\t\tthis._toggleDragListeners('on');\n\n\t\t\t\tthis._isDragging = true;\n\n\t\t\t\tthis._dragStartMousePosition.copy(currentMousePosition);\n\n\t\t\t\tthis._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());\n\n\t\t\t\tthis.fire('drag:start');\n\t\t\t}\n\t\t}\n\t}\n\n\t_onMouseUpOrTouchEnd() {\n\t\tif (this._isDragging) {\n\t\t\tthis._isDragging = false;\n\n\t\t\tthis._toggleDragListeners('off');\n\n\t\t\tthis.fire('drag:end');\n\t\t}\n\t}\n\n\t_screenToLocal(event) {\n\t\tthis._determineInputPosition(event);\n\n\t\tthis._chooseRayOriginAndDirection();\n\n\t\t_planeOrigin.copy(this._element.entity.getPosition());\n\n\t\t_planeNormal.copy(this._element.entity.forward).mulScalar(-1);\n\n\t\tconst denominator = _planeNormal.dot(_rayDirection);\n\n\t\tif (Math.abs(denominator) > 0) {\n\t\t\tconst rayOriginToPlaneOrigin = _planeOrigin.sub(_rayOrigin);\n\n\t\t\tconst collisionDistance = rayOriginToPlaneOrigin.dot(_planeNormal) / denominator;\n\n\t\t\tconst position = _rayOrigin.add(_rayDirection.mulScalar(collisionDistance));\n\n\t\t\t_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(position, position);\n\n\t\t\tposition.mul(this._dragScale);\n\t\t\treturn position;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t_determineInputPosition(event) {\n\t\tconst devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;\n\n\t\tif (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {\n\t\t\t_inputScreenPosition.x = event.x * devicePixelRatio;\n\t\t\t_inputScreenPosition.y = event.y * devicePixelRatio;\n\t\t} else if (event.changedTouches) {\n\t\t\t_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;\n\t\t\t_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;\n\t\t} else {\n\t\t\tconsole.warn('Could not determine position from input event');\n\t\t}\n\t}\n\n\t_chooseRayOriginAndDirection() {\n\t\tif (this._element.screen && this._element.screen.screen.screenSpace) {\n\t\t\t_rayOrigin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);\n\n\t\t\t_rayDirection.set(0, 0, -1);\n\t\t} else {\n\t\t\t_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));\n\n\t\t\t_rayOrigin.copy(this._dragCamera.entity.getPosition());\n\n\t\t\t_rayDirection.copy(_inputWorldPosition).sub(_rayOrigin).normalize();\n\t\t}\n\t}\n\n\t_calculateDragScale() {\n\t\tlet current = this._element.entity.parent;\n\t\tconst screen = this._element.screen && this._element.screen.screen;\n\t\tconst isWithin2DScreen = screen && screen.screenSpace;\n\t\tconst screenScale = isWithin2DScreen ? screen.scale : 1;\n\t\tconst dragScale = this._dragScale;\n\t\tdragScale.set(screenScale, screenScale, screenScale);\n\n\t\twhile (current) {\n\t\t\tdragScale.mul(current.getLocalScale());\n\t\t\tcurrent = current.parent;\n\n\t\t\tif (isWithin2DScreen && current.screen) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdragScale.x = 1 / dragScale.x;\n\t\tdragScale.y = 1 / dragScale.y;\n\t\tdragScale.z = 1 / dragScale.z;\n\t}\n\n\t_onMove(event) {\n\t\tif (this._element && this._isDragging && this.enabled && this._element.enabled && this._element.entity.enabled) {\n\t\t\tconst currentMousePosition = this._screenToLocal(event);\n\n\t\t\tif (this._dragStartMousePosition && currentMousePosition) {\n\t\t\t\tthis._deltaMousePosition.copy(currentMousePosition).sub(this._dragStartMousePosition);\n\n\t\t\t\tthis._deltaHandlePosition.copy(this._dragStartHandlePosition).add(this._deltaMousePosition);\n\n\t\t\t\tif (this._axis) {\n\t\t\t\t\tconst currentPosition = this._element.entity.getLocalPosition();\n\n\t\t\t\t\tconst constrainedAxis = OPPOSITE_AXIS[this._axis];\n\t\t\t\t\tthis._deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];\n\t\t\t\t}\n\n\t\t\t\tthis._element.entity.setLocalPosition(this._deltaHandlePosition);\n\n\t\t\t\tthis.fire('drag:move', this._deltaHandlePosition);\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._toggleLifecycleListeners('off');\n\n\t\tthis._toggleDragListeners('off');\n\t}\n\n\tset enabled(value) {\n\t\tthis._enabled = value;\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tget isDragging() {\n\t\treturn this._isDragging;\n\t}\n\n}\n\nconst SCROLL_MODE_CLAMP = 0;\nconst SCROLL_MODE_BOUNCE = 1;\nconst SCROLL_MODE_INFINITE = 2;\nconst SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;\nconst SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;\n\nconst ACTION_MOUSE = 'mouse';\nconst ACTION_KEYBOARD = 'keyboard';\nconst ACTION_GAMEPAD = 'gamepad';\nconst AXIS_MOUSE_X = 'mousex';\nconst AXIS_MOUSE_Y = 'mousey';\nconst AXIS_PAD_L_X = 'padlx';\nconst AXIS_PAD_L_Y = 'padly';\nconst AXIS_PAD_R_X = 'padrx';\nconst AXIS_PAD_R_Y = 'padry';\nconst AXIS_KEY = 'key';\nconst EVENT_KEYDOWN = 'keydown';\nconst EVENT_KEYUP = 'keyup';\nconst EVENT_MOUSEDOWN = \"mousedown\";\nconst EVENT_MOUSEMOVE = \"mousemove\";\nconst EVENT_MOUSEUP = \"mouseup\";\nconst EVENT_MOUSEWHEEL = \"mousewheel\";\nconst EVENT_TOUCHSTART = 'touchstart';\nconst EVENT_TOUCHEND = 'touchend';\nconst EVENT_TOUCHMOVE = 'touchmove';\nconst EVENT_TOUCHCANCEL = 'touchcancel';\nconst EVENT_SELECT = 'select';\nconst EVENT_SELECTSTART = 'selectstart';\nconst EVENT_SELECTEND = 'selectend';\nconst KEY_BACKSPACE = 8;\nconst KEY_TAB = 9;\nconst KEY_RETURN = 13;\nconst KEY_ENTER = 13;\nconst KEY_SHIFT = 16;\nconst KEY_CONTROL = 17;\nconst KEY_ALT = 18;\nconst KEY_PAUSE = 19;\nconst KEY_CAPS_LOCK = 20;\nconst KEY_ESCAPE = 27;\nconst KEY_SPACE = 32;\nconst KEY_PAGE_UP = 33;\nconst KEY_PAGE_DOWN = 34;\nconst KEY_END = 35;\nconst KEY_HOME = 36;\nconst KEY_LEFT = 37;\nconst KEY_UP = 38;\nconst KEY_RIGHT = 39;\nconst KEY_DOWN = 40;\nconst KEY_PRINT_SCREEN = 44;\nconst KEY_INSERT = 45;\nconst KEY_DELETE = 46;\nconst KEY_0 = 48;\nconst KEY_1 = 49;\nconst KEY_2 = 50;\nconst KEY_3 = 51;\nconst KEY_4 = 52;\nconst KEY_5 = 53;\nconst KEY_6 = 54;\nconst KEY_7 = 55;\nconst KEY_8 = 56;\nconst KEY_9 = 57;\nconst KEY_SEMICOLON = 59;\nconst KEY_EQUAL = 61;\nconst KEY_A = 65;\nconst KEY_B = 66;\nconst KEY_C = 67;\nconst KEY_D = 68;\nconst KEY_E = 69;\nconst KEY_F = 70;\nconst KEY_G = 71;\nconst KEY_H = 72;\nconst KEY_I = 73;\nconst KEY_J = 74;\nconst KEY_K = 75;\nconst KEY_L = 76;\nconst KEY_M = 77;\nconst KEY_N = 78;\nconst KEY_O = 79;\nconst KEY_P = 80;\nconst KEY_Q = 81;\nconst KEY_R = 82;\nconst KEY_S = 83;\nconst KEY_T = 84;\nconst KEY_U = 85;\nconst KEY_V = 86;\nconst KEY_W = 87;\nconst KEY_X = 88;\nconst KEY_Y = 89;\nconst KEY_Z = 90;\nconst KEY_WINDOWS = 91;\nconst KEY_CONTEXT_MENU = 93;\nconst KEY_NUMPAD_0 = 96;\nconst KEY_NUMPAD_1 = 97;\nconst KEY_NUMPAD_2 = 98;\nconst KEY_NUMPAD_3 = 99;\nconst KEY_NUMPAD_4 = 100;\nconst KEY_NUMPAD_5 = 101;\nconst KEY_NUMPAD_6 = 102;\nconst KEY_NUMPAD_7 = 103;\nconst KEY_NUMPAD_8 = 104;\nconst KEY_NUMPAD_9 = 105;\nconst KEY_MULTIPLY = 106;\nconst KEY_ADD = 107;\nconst KEY_SEPARATOR = 108;\nconst KEY_SUBTRACT = 109;\nconst KEY_DECIMAL = 110;\nconst KEY_DIVIDE = 111;\nconst KEY_F1 = 112;\nconst KEY_F2 = 113;\nconst KEY_F3 = 114;\nconst KEY_F4 = 115;\nconst KEY_F5 = 116;\nconst KEY_F6 = 117;\nconst KEY_F7 = 118;\nconst KEY_F8 = 119;\nconst KEY_F9 = 120;\nconst KEY_F10 = 121;\nconst KEY_F11 = 122;\nconst KEY_F12 = 123;\nconst KEY_COMMA = 188;\nconst KEY_PERIOD = 190;\nconst KEY_SLASH = 191;\nconst KEY_OPEN_BRACKET = 219;\nconst KEY_BACK_SLASH = 220;\nconst KEY_CLOSE_BRACKET = 221;\nconst KEY_META = 224;\nconst MOUSEBUTTON_NONE = -1;\nconst MOUSEBUTTON_LEFT = 0;\nconst MOUSEBUTTON_MIDDLE = 1;\nconst MOUSEBUTTON_RIGHT = 2;\nconst PAD_1 = 0;\nconst PAD_2 = 1;\nconst PAD_3 = 2;\nconst PAD_4 = 3;\nconst PAD_FACE_1 = 0;\nconst PAD_FACE_2 = 1;\nconst PAD_FACE_3 = 2;\nconst PAD_FACE_4 = 3;\nconst PAD_L_SHOULDER_1 = 4;\nconst PAD_R_SHOULDER_1 = 5;\nconst PAD_L_SHOULDER_2 = 6;\nconst PAD_R_SHOULDER_2 = 7;\nconst PAD_SELECT = 8;\nconst PAD_START = 9;\nconst PAD_L_STICK_BUTTON = 10;\nconst PAD_R_STICK_BUTTON = 11;\nconst PAD_UP = 12;\nconst PAD_DOWN = 13;\nconst PAD_LEFT = 14;\nconst PAD_RIGHT = 15;\nconst PAD_VENDOR = 16;\nconst PAD_L_STICK_X = 0;\nconst PAD_L_STICK_Y = 1;\nconst PAD_R_STICK_X = 2;\nconst PAD_R_STICK_Y = 3;\n\nconst _tempScrollValue = new Vec2();\n\nclass ScrollViewComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._viewportReference = new EntityReference(this, 'viewportEntity', {\n\t\t\t'element#gain': this._onViewportElementGain,\n\t\t\t'element#resize': this._onSetContentOrViewportSize\n\t\t});\n\t\tthis._contentReference = new EntityReference(this, 'contentEntity', {\n\t\t\t'element#gain': this._onContentElementGain,\n\t\t\t'element#lose': this._onContentElementLose,\n\t\t\t'element#resize': this._onSetContentOrViewportSize\n\t\t});\n\t\tthis._scrollbarUpdateFlags = {};\n\t\tthis._scrollbarReferences = {};\n\t\tthis._scrollbarReferences[ORIENTATION_HORIZONTAL] = new EntityReference(this, 'horizontalScrollbarEntity', {\n\t\t\t'scrollbar#set:value': this._onSetHorizontalScrollbarValue,\n\t\t\t'scrollbar#gain': this._onHorizontalScrollbarGain\n\t\t});\n\t\tthis._scrollbarReferences[ORIENTATION_VERTICAL] = new EntityReference(this, 'verticalScrollbarEntity', {\n\t\t\t'scrollbar#set:value': this._onSetVerticalScrollbarValue,\n\t\t\t'scrollbar#gain': this._onVerticalScrollbarGain\n\t\t});\n\t\tthis._prevContentSizes = {};\n\t\tthis._prevContentSizes[ORIENTATION_HORIZONTAL] = null;\n\t\tthis._prevContentSizes[ORIENTATION_VERTICAL] = null;\n\t\tthis._scroll = new Vec2();\n\t\tthis._velocity = new Vec3();\n\t\tthis._dragStartPosition = new Vec3();\n\t\tthis._disabledContentInput = false;\n\t\tthis._disabledContentInputEntities = [];\n\n\t\tthis._toggleLifecycleListeners('on', system);\n\n\t\tthis._toggleElementListeners('on');\n\t}\n\n\t_toggleLifecycleListeners(onOrOff, system) {\n\t\tthis[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);\n\t\tthis[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);\n\t\tsystem.app.systems.element[onOrOff]('add', this._onElementComponentAdd, this);\n\t\tsystem.app.systems.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);\n\t}\n\n\t_toggleElementListeners(onOrOff) {\n\t\tif (this.entity.element) {\n\t\t\tif (onOrOff === 'on' && this._hasElementListeners) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.entity.element[onOrOff]('resize', this._onSetContentOrViewportSize, this);\n\t\t\tthis.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);\n\t\t\tthis._hasElementListeners = onOrOff === 'on';\n\t\t}\n\t}\n\n\t_onElementComponentAdd(entity) {\n\t\tif (this.entity === entity) {\n\t\t\tthis._toggleElementListeners('on');\n\t\t}\n\t}\n\n\t_onElementComponentRemove(entity) {\n\t\tif (this.entity === entity) {\n\t\t\tthis._toggleElementListeners('off');\n\t\t}\n\t}\n\n\t_onViewportElementGain() {\n\t\tthis._syncAll();\n\t}\n\n\t_onContentElementGain() {\n\t\tthis._destroyDragHelper();\n\n\t\tthis._contentDragHelper = new ElementDragHelper(this._contentReference.entity.element);\n\n\t\tthis._contentDragHelper.on('drag:start', this._onContentDragStart, this);\n\n\t\tthis._contentDragHelper.on('drag:end', this._onContentDragEnd, this);\n\n\t\tthis._contentDragHelper.on('drag:move', this._onContentDragMove, this);\n\n\t\tthis._prevContentSizes[ORIENTATION_HORIZONTAL] = null;\n\t\tthis._prevContentSizes[ORIENTATION_VERTICAL] = null;\n\n\t\tthis._syncAll();\n\t}\n\n\t_onContentElementLose() {\n\t\tthis._destroyDragHelper();\n\t}\n\n\t_onContentDragStart() {\n\t\tif (this._contentReference.entity && this.enabled && this.entity.enabled) {\n\t\t\tthis._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());\n\t\t}\n\t}\n\n\t_onContentDragEnd() {\n\t\tthis._prevContentDragPosition = null;\n\n\t\tthis._enableContentInput();\n\t}\n\n\t_onContentDragMove(position) {\n\t\tif (this._contentReference.entity && this.enabled && this.entity.enabled) {\n\t\t\tthis._wasDragged = true;\n\n\t\t\tthis._setScrollFromContentPosition(position);\n\n\t\t\tthis._setVelocityFromContentPositionDelta(position);\n\n\t\t\tif (!this._disabledContentInput) {\n\t\t\t\tconst dx = position.x - this._dragStartPosition.x;\n\t\t\t\tconst dy = position.y - this._dragStartPosition.y;\n\n\t\t\t\tif (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {\n\t\t\t\t\tthis._disableContentInput();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onSetContentOrViewportSize() {\n\t\tthis._syncAll();\n\t}\n\n\t_onSetHorizontalScrollbarValue(scrollValueX) {\n\t\tif (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {\n\t\t\tthis._onSetScroll(scrollValueX, null);\n\t\t}\n\t}\n\n\t_onSetVerticalScrollbarValue(scrollValueY) {\n\t\tif (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {\n\t\t\tthis._onSetScroll(null, scrollValueY);\n\t\t}\n\t}\n\n\t_onSetHorizontalScrollingEnabled() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\t}\n\n\t_onSetVerticalScrollingEnabled() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t}\n\n\t_onHorizontalScrollbarGain() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\n\t\tthis._syncScrollbarPosition(ORIENTATION_HORIZONTAL);\n\t}\n\n\t_onVerticalScrollbarGain() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\n\t\tthis._syncScrollbarPosition(ORIENTATION_VERTICAL);\n\t}\n\n\t_onSetScroll(x, y, resetVelocity) {\n\t\tif (resetVelocity !== false) {\n\t\t\tthis._velocity.set(0, 0, 0);\n\t\t}\n\n\t\tlet hasChanged = false;\n\t\thasChanged |= this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);\n\t\thasChanged |= this._updateAxis(y, 'y', ORIENTATION_VERTICAL);\n\n\t\tif (hasChanged) {\n\t\t\tthis.fire('set:scroll', this._scroll);\n\t\t}\n\t}\n\n\t_updateAxis(scrollValue, axis, orientation) {\n\t\tconst hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;\n\n\t\tif (hasChanged || this._isDragging() || scrollValue === 0) {\n\t\t\tthis._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);\n\n\t\t\tthis._syncContentPosition(orientation);\n\n\t\t\tthis._syncScrollbarPosition(orientation);\n\t\t}\n\n\t\treturn hasChanged;\n\t}\n\n\t_determineNewScrollValue(scrollValue, axis, orientation) {\n\t\tif (!this._getScrollingEnabled(orientation)) {\n\t\t\treturn this._scroll[axis];\n\t\t}\n\n\t\tswitch (this.scrollMode) {\n\t\t\tcase SCROLL_MODE_CLAMP:\n\t\t\t\treturn math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));\n\n\t\t\tcase SCROLL_MODE_BOUNCE:\n\t\t\t\tthis._setVelocityFromOvershoot(scrollValue, axis, orientation);\n\n\t\t\t\treturn scrollValue;\n\n\t\t\tcase SCROLL_MODE_INFINITE:\n\t\t\t\treturn scrollValue;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('Unhandled scroll mode:' + this.scrollMode);\n\t\t\t\treturn scrollValue;\n\t\t}\n\t}\n\n\t_syncAll() {\n\t\tthis._syncContentPosition(ORIENTATION_HORIZONTAL);\n\n\t\tthis._syncContentPosition(ORIENTATION_VERTICAL);\n\n\t\tthis._syncScrollbarPosition(ORIENTATION_HORIZONTAL);\n\n\t\tthis._syncScrollbarPosition(ORIENTATION_VERTICAL);\n\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t}\n\n\t_syncContentPosition(orientation) {\n\t\tconst axis = this._getAxis(orientation);\n\n\t\tconst sign = this._getSign(orientation);\n\n\t\tconst contentEntity = this._contentReference.entity;\n\n\t\tif (contentEntity) {\n\t\t\tconst prevContentSize = this._prevContentSizes[orientation];\n\n\t\t\tconst currContentSize = this._getContentSize(orientation);\n\n\t\t\tif (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {\n\t\t\t\tconst prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);\n\n\t\t\t\tconst currMaxOffset = this._getMaxOffset(orientation, currContentSize);\n\n\t\t\t\tif (currMaxOffset === 0) {\n\t\t\t\t\tthis._scroll[axis] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tthis._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst offset = this._scroll[axis] * this._getMaxOffset(orientation);\n\n\t\t\tconst contentPosition = contentEntity.getLocalPosition();\n\t\t\tcontentPosition[axis] = offset * sign;\n\t\t\tcontentEntity.setLocalPosition(contentPosition);\n\t\t\tthis._prevContentSizes[orientation] = currContentSize;\n\t\t}\n\t}\n\n\t_syncScrollbarPosition(orientation) {\n\t\tconst axis = this._getAxis(orientation);\n\n\t\tconst scrollbarEntity = this._scrollbarReferences[orientation].entity;\n\n\t\tif (scrollbarEntity && scrollbarEntity.scrollbar) {\n\t\t\tthis._scrollbarUpdateFlags[orientation] = true;\n\t\t\tscrollbarEntity.scrollbar.value = this._scroll[axis];\n\t\t\tscrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);\n\t\t\tthis._scrollbarUpdateFlags[orientation] = false;\n\t\t}\n\t}\n\n\t_syncScrollbarEnabledState(orientation) {\n\t\tconst entity = this._scrollbarReferences[orientation].entity;\n\n\t\tif (entity) {\n\t\t\tconst isScrollingEnabled = this._getScrollingEnabled(orientation);\n\n\t\t\tconst requestedVisibility = this._getScrollbarVisibility(orientation);\n\n\t\t\tswitch (requestedVisibility) {\n\t\t\t\tcase SCROLLBAR_VISIBILITY_SHOW_ALWAYS:\n\t\t\t\t\tentity.enabled = isScrollingEnabled;\n\t\t\t\t\treturn;\n\n\t\t\t\tcase SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:\n\t\t\t\t\tentity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);\n\t\t\t\t\treturn;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('Unhandled scrollbar visibility:' + requestedVisibility);\n\t\t\t\t\tentity.enabled = isScrollingEnabled;\n\t\t\t}\n\t\t}\n\t}\n\n\t_contentIsLargerThanViewport(orientation) {\n\t\treturn this._getContentSize(orientation) > this._getViewportSize(orientation);\n\t}\n\n\t_contentPositionToScrollValue(contentPosition) {\n\t\tconst maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);\n\n\t\tconst maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);\n\n\t\tif (maxOffsetH === 0) {\n\t\t\t_tempScrollValue.x = 0;\n\t\t} else {\n\t\t\t_tempScrollValue.x = contentPosition.x / maxOffsetH;\n\t\t}\n\n\t\tif (maxOffsetV === 0) {\n\t\t\t_tempScrollValue.y = 0;\n\t\t} else {\n\t\t\t_tempScrollValue.y = contentPosition.y / -maxOffsetV;\n\t\t}\n\n\t\treturn _tempScrollValue;\n\t}\n\n\t_getMaxOffset(orientation, contentSize) {\n\t\tcontentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;\n\n\t\tconst viewportSize = this._getViewportSize(orientation);\n\n\t\tif (contentSize < viewportSize) {\n\t\t\treturn -this._getViewportSize(orientation);\n\t\t}\n\n\t\treturn viewportSize - contentSize;\n\t}\n\n\t_getMaxScrollValue(orientation) {\n\t\treturn this._contentIsLargerThanViewport(orientation) ? 1 : 0;\n\t}\n\n\t_getScrollbarHandleSize(axis, orientation) {\n\t\tconst viewportSize = this._getViewportSize(orientation);\n\n\t\tconst contentSize = this._getContentSize(orientation);\n\n\t\tif (Math.abs(contentSize) < 0.001) {\n\t\t\treturn 1;\n\t\t}\n\n\t\tconst handleSize = Math.min(viewportSize / contentSize, 1);\n\n\t\tconst overshoot = this._toOvershoot(this._scroll[axis], orientation);\n\n\t\tif (overshoot === 0) {\n\t\t\treturn handleSize;\n\t\t}\n\n\t\treturn handleSize / (1 + Math.abs(overshoot));\n\t}\n\n\t_getViewportSize(orientation) {\n\t\treturn this._getSize(orientation, this._viewportReference);\n\t}\n\n\t_getContentSize(orientation) {\n\t\treturn this._getSize(orientation, this._contentReference);\n\t}\n\n\t_getSize(orientation, entityReference) {\n\t\tif (entityReference.entity && entityReference.entity.element) {\n\t\t\treturn entityReference.entity.element[this._getCalculatedDimension(orientation)];\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_getScrollingEnabled(orientation) {\n\t\tif (orientation === ORIENTATION_HORIZONTAL) {\n\t\t\treturn this.horizontal;\n\t\t} else if (orientation === ORIENTATION_VERTICAL) {\n\t\t\treturn this.vertical;\n\t\t}\n\n\t\tconsole.warn('Unrecognized orientation: ' + orientation);\n\t}\n\n\t_getScrollbarVisibility(orientation) {\n\t\tif (orientation === ORIENTATION_HORIZONTAL) {\n\t\t\treturn this.horizontalScrollbarVisibility;\n\t\t} else if (orientation === ORIENTATION_VERTICAL) {\n\t\t\treturn this.verticalScrollbarVisibility;\n\t\t}\n\n\t\tconsole.warn('Unrecognized orientation: ' + orientation);\n\t}\n\n\t_getSign(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 1 : -1;\n\t}\n\n\t_getAxis(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';\n\t}\n\n\t_getCalculatedDimension(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';\n\t}\n\n\t_destroyDragHelper() {\n\t\tif (this._contentDragHelper) {\n\t\t\tthis._contentDragHelper.destroy();\n\t\t}\n\t}\n\n\tonUpdate() {\n\t\tif (this._contentReference.entity) {\n\t\t\tthis._updateVelocity();\n\n\t\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\n\t\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t\t}\n\t}\n\n\t_updateVelocity() {\n\t\tif (!this._isDragging()) {\n\t\t\tif (this.scrollMode === SCROLL_MODE_BOUNCE) {\n\t\t\t\tif (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {\n\t\t\t\t\tthis._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);\n\t\t\t\t}\n\n\t\t\t\tif (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {\n\t\t\t\t\tthis._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {\n\t\t\t\tconst position = this._contentReference.entity.getLocalPosition();\n\n\t\t\t\tposition.x += this._velocity.x;\n\t\t\t\tposition.y += this._velocity.y;\n\n\t\t\t\tthis._contentReference.entity.setLocalPosition(position);\n\n\t\t\t\tthis._setScrollFromContentPosition(position);\n\t\t\t}\n\n\t\t\tthis._velocity.x *= 1 - this.friction;\n\t\t\tthis._velocity.y *= 1 - this.friction;\n\t\t}\n\t}\n\n\t_hasOvershoot(axis, orientation) {\n\t\treturn Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;\n\t}\n\n\t_toOvershoot(scrollValue, orientation) {\n\t\tconst maxScrollValue = this._getMaxScrollValue(orientation);\n\n\t\tif (scrollValue < 0) {\n\t\t\treturn scrollValue;\n\t\t} else if (scrollValue > maxScrollValue) {\n\t\t\treturn scrollValue - maxScrollValue;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_setVelocityFromOvershoot(scrollValue, axis, orientation) {\n\t\tconst overshootValue = this._toOvershoot(scrollValue, orientation);\n\n\t\tconst overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);\n\n\t\tif (Math.abs(overshootPixels) > 0) {\n\t\t\tthis._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);\n\t\t}\n\t}\n\n\t_setVelocityFromContentPositionDelta(position) {\n\t\tif (this._prevContentDragPosition) {\n\t\t\tthis._velocity.sub2(position, this._prevContentDragPosition);\n\n\t\t\tthis._prevContentDragPosition.copy(position);\n\t\t} else {\n\t\t\tthis._velocity.set(0, 0, 0);\n\n\t\t\tthis._prevContentDragPosition = position.clone();\n\t\t}\n\t}\n\n\t_setScrollFromContentPosition(position) {\n\t\tlet scrollValue = this._contentPositionToScrollValue(position);\n\n\t\tif (this._isDragging()) {\n\t\t\tscrollValue = this._applyScrollValueTension(scrollValue);\n\t\t}\n\n\t\tthis._onSetScroll(scrollValue.x, scrollValue.y, false);\n\t}\n\n\t_applyScrollValueTension(scrollValue) {\n\t\tconst factor = 1;\n\n\t\tlet max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);\n\n\t\tlet overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);\n\n\t\tif (overshoot > 0) {\n\t\t\tscrollValue.x = max + factor * Math.log10(1 + overshoot);\n\t\t} else if (overshoot < 0) {\n\t\t\tscrollValue.x = -factor * Math.log10(1 - overshoot);\n\t\t}\n\n\t\tmax = this._getMaxScrollValue(ORIENTATION_VERTICAL);\n\t\tovershoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);\n\n\t\tif (overshoot > 0) {\n\t\t\tscrollValue.y = max + factor * Math.log10(1 + overshoot);\n\t\t} else if (overshoot < 0) {\n\t\t\tscrollValue.y = -factor * Math.log10(1 - overshoot);\n\t\t}\n\n\t\treturn scrollValue;\n\t}\n\n\t_isDragging() {\n\t\treturn this._contentDragHelper && this._contentDragHelper.isDragging;\n\t}\n\n\t_setScrollbarComponentsEnabled(enabled) {\n\t\tif (this._scrollbarReferences[ORIENTATION_HORIZONTAL].hasComponent('scrollbar')) {\n\t\t\tthis._scrollbarReferences[ORIENTATION_HORIZONTAL].entity.scrollbar.enabled = enabled;\n\t\t}\n\n\t\tif (this._scrollbarReferences[ORIENTATION_VERTICAL].hasComponent('scrollbar')) {\n\t\t\tthis._scrollbarReferences[ORIENTATION_VERTICAL].entity.scrollbar.enabled = enabled;\n\t\t}\n\t}\n\n\t_setContentDraggingEnabled(enabled) {\n\t\tif (this._contentDragHelper) {\n\t\t\tthis._contentDragHelper.enabled = enabled;\n\t\t}\n\t}\n\n\t_onMouseWheel(event) {\n\t\tif (this.useMouseWheel) {\n\t\t\tconst wheelEvent = event.event;\n\t\t\tconst normalizedDeltaX = wheelEvent.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x;\n\t\t\tconst normalizedDeltaY = wheelEvent.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y;\n\t\t\tconst scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));\n\t\t\tconst scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));\n\t\t\tthis.scroll = new Vec2(scrollX, scrollY);\n\t\t}\n\t}\n\n\t_enableContentInput() {\n\t\twhile (this._disabledContentInputEntities.length) {\n\t\t\tconst e = this._disabledContentInputEntities.pop();\n\n\t\t\tif (e.element) {\n\t\t\t\te.element.useInput = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._disabledContentInput = false;\n\t}\n\n\t_disableContentInput() {\n\t\tconst _disableInput = e => {\n\t\t\tif (e.element && e.element.useInput) {\n\t\t\t\tthis._disabledContentInputEntities.push(e);\n\n\t\t\t\te.element.useInput = false;\n\t\t\t}\n\n\t\t\tconst children = e.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t_disableInput(children[i]);\n\t\t\t}\n\t\t};\n\n\t\tconst contentEntity = this._contentReference.entity;\n\n\t\tif (contentEntity) {\n\t\t\tconst children = contentEntity.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t_disableInput(children[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis._disabledContentInput = true;\n\t}\n\n\tonEnable() {\n\t\tthis._viewportReference.onParentComponentEnable();\n\n\t\tthis._contentReference.onParentComponentEnable();\n\n\t\tthis._scrollbarReferences[ORIENTATION_HORIZONTAL].onParentComponentEnable();\n\n\t\tthis._scrollbarReferences[ORIENTATION_VERTICAL].onParentComponentEnable();\n\n\t\tthis._setScrollbarComponentsEnabled(true);\n\n\t\tthis._setContentDraggingEnabled(true);\n\n\t\tthis._syncAll();\n\t}\n\n\tonDisable() {\n\t\tthis._setScrollbarComponentsEnabled(false);\n\n\t\tthis._setContentDraggingEnabled(false);\n\t}\n\n\tonRemove() {\n\t\tthis._toggleLifecycleListeners('off', this.system);\n\n\t\tthis._toggleElementListeners('off');\n\n\t\tthis._destroyDragHelper();\n\t}\n\n\tset scroll(value) {\n\t\tthis._onSetScroll(value.x, value.y);\n\t}\n\n\tget scroll() {\n\t\treturn this._scroll;\n\t}\n\n}\n\nclass ScrollViewComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$4 = [{\n\tname: 'enabled',\n\ttype: 'boolean'\n}, {\n\tname: 'horizontal',\n\ttype: 'boolean'\n}, {\n\tname: 'vertical',\n\ttype: 'boolean'\n}, {\n\tname: 'scrollMode',\n\ttype: 'number'\n}, {\n\tname: 'bounceAmount',\n\ttype: 'number'\n}, {\n\tname: 'friction',\n\ttype: 'number'\n}, {\n\tname: 'dragThreshold',\n\ttype: 'number'\n}, {\n\tname: 'useMouseWheel',\n\ttype: 'boolean'\n}, {\n\tname: 'mouseWheelSensitivity',\n\ttype: 'vec2'\n}, {\n\tname: 'horizontalScrollbarVisibility',\n\ttype: 'number'\n}, {\n\tname: 'verticalScrollbarVisibility',\n\ttype: 'number'\n}, {\n\tname: 'viewportEntity',\n\ttype: 'entity'\n}, {\n\tname: 'contentEntity',\n\ttype: 'entity'\n}, {\n\tname: 'horizontalScrollbarEntity',\n\ttype: 'entity'\n}, {\n\tname: 'verticalScrollbarEntity',\n\ttype: 'entity'\n}];\nconst DEFAULT_DRAG_THRESHOLD = 10;\n\nclass ScrollViewComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'scrollview';\n\t\tthis.ComponentType = ScrollViewComponent;\n\t\tthis.DataType = ScrollViewComponentData;\n\t\tthis.schema = _schema$4;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.dragThreshold === undefined) {\n\t\t\tdata.dragThreshold = DEFAULT_DRAG_THRESHOLD;\n\t\t}\n\n\t\tif (data.useMouseWheel === undefined) {\n\t\t\tdata.useMouseWheel = true;\n\t\t}\n\n\t\tif (data.mouseWheelSensitivity === undefined) {\n\t\t\tdata.mouseWheelSensitivity = new Vec2(1, 1);\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, _schema$4);\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tconst entity = components[id].entity;\n\t\t\tconst component = entity.scrollview;\n\n\t\t\tif (component.enabled && entity.enabled) {\n\t\t\t\tcomponent.onUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(ScrollViewComponent.prototype, _schema$4);\n\nclass ScrollbarComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._app = system.app;\n\t\tthis._handleReference = new EntityReference(this, 'handleEntity', {\n\t\t\t'element#gain': this._onHandleElementGain,\n\t\t\t'element#lose': this._onHandleElementLose,\n\t\t\t'element#set:anchor': this._onSetHandleAlignment,\n\t\t\t'element#set:margin': this._onSetHandleAlignment,\n\t\t\t'element#set:pivot': this._onSetHandleAlignment\n\t\t});\n\n\t\tthis._toggleLifecycleListeners('on');\n\t}\n\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis[onOrOff]('set_value', this._onSetValue, this);\n\t\tthis[onOrOff]('set_handleSize', this._onSetHandleSize, this);\n\t\tthis[onOrOff]('set_orientation', this._onSetOrientation, this);\n\t}\n\n\t_onHandleElementGain() {\n\t\tthis._destroyDragHelper();\n\n\t\tthis._handleDragHelper = new ElementDragHelper(this._handleReference.entity.element, this._getAxis());\n\n\t\tthis._handleDragHelper.on('drag:move', this._onHandleDrag, this);\n\n\t\tthis._updateHandlePositionAndSize();\n\t}\n\n\t_onHandleElementLose() {\n\t\tthis._destroyDragHelper();\n\t}\n\n\t_onHandleDrag(position) {\n\t\tif (this._handleReference.entity && this.enabled && this.entity.enabled) {\n\t\t\tthis.value = this._handlePositionToScrollValue(position[this._getAxis()]);\n\t\t}\n\t}\n\n\t_onSetValue(name, oldValue, newValue) {\n\t\tif (Math.abs(newValue - oldValue) > 1e-5) {\n\t\t\tthis.data.value = math.clamp(newValue, 0, 1);\n\n\t\t\tthis._updateHandlePositionAndSize();\n\n\t\t\tthis.fire('set:value', this.data.value);\n\t\t}\n\t}\n\n\t_onSetHandleSize(name, oldValue, newValue) {\n\t\tif (Math.abs(newValue - oldValue) > 1e-5) {\n\t\t\tthis.data.handleSize = math.clamp(newValue, 0, 1);\n\n\t\t\tthis._updateHandlePositionAndSize();\n\t\t}\n\t}\n\n\t_onSetHandleAlignment() {\n\t\tthis._updateHandlePositionAndSize();\n\t}\n\n\t_onSetOrientation(name, oldValue, newValue) {\n\t\tif (newValue !== oldValue && this._handleReference.hasComponent('element')) {\n\t\t\tthis._handleReference.entity.element[this._getOppositeDimension()] = 0;\n\t\t}\n\t}\n\n\t_updateHandlePositionAndSize() {\n\t\tconst handleEntity = this._handleReference.entity;\n\t\tconst handleElement = handleEntity && handleEntity.element;\n\n\t\tif (handleEntity) {\n\t\t\tconst position = handleEntity.getLocalPosition();\n\t\t\tposition[this._getAxis()] = this._getHandlePosition();\n\n\t\t\tthis._handleReference.entity.setLocalPosition(position);\n\t\t}\n\n\t\tif (handleElement) {\n\t\t\thandleElement[this._getDimension()] = this._getHandleLength();\n\t\t}\n\t}\n\n\t_handlePositionToScrollValue(handlePosition) {\n\t\treturn handlePosition * this._getSign() / this._getUsableTrackLength();\n\t}\n\n\t_scrollValueToHandlePosition(value) {\n\t\treturn value * this._getSign() * this._getUsableTrackLength();\n\t}\n\n\t_getUsableTrackLength() {\n\t\treturn Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);\n\t}\n\n\t_getTrackLength() {\n\t\tif (this.entity.element) {\n\t\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_getHandleLength() {\n\t\treturn this._getTrackLength() * this.handleSize;\n\t}\n\n\t_getHandlePosition() {\n\t\treturn this._scrollValueToHandlePosition(this.value);\n\t}\n\n\t_getSign() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;\n\t}\n\n\t_getAxis() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';\n\t}\n\n\t_getDimension() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';\n\t}\n\n\t_getOppositeDimension() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';\n\t}\n\n\t_destroyDragHelper() {\n\t\tif (this._handleDragHelper) {\n\t\t\tthis._handleDragHelper.destroy();\n\t\t}\n\t}\n\n\t_setHandleDraggingEnabled(enabled) {\n\t\tif (this._handleDragHelper) {\n\t\t\tthis._handleDragHelper.enabled = enabled;\n\t\t}\n\t}\n\n\tonEnable() {\n\t\tthis._handleReference.onParentComponentEnable();\n\n\t\tthis._setHandleDraggingEnabled(true);\n\t}\n\n\tonDisable() {\n\t\tthis._setHandleDraggingEnabled(false);\n\t}\n\n\tonRemove() {\n\t\tthis._destroyDragHelper();\n\n\t\tthis._toggleLifecycleListeners('off');\n\t}\n\n}\n\nclass ScrollbarComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$3 = [{\n\tname: 'enabled',\n\ttype: 'boolean'\n}, {\n\tname: 'orientation',\n\ttype: 'number'\n}, {\n\tname: 'value',\n\ttype: 'number'\n}, {\n\tname: 'handleSize',\n\ttype: 'number'\n}, {\n\tname: 'handleEntity',\n\ttype: 'entity'\n}];\n\nclass ScrollbarComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'scrollbar';\n\t\tthis.ComponentType = ScrollbarComponent;\n\t\tthis.DataType = ScrollbarComponentData;\n\t\tthis.schema = _schema$3;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tsuper.initializeComponentData(component, data, _schema$3);\n\t}\n\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\n}\n\nComponent._buildAccessors(ScrollbarComponent.prototype, _schema$3);\n\nconst STATE_PLAYING = 0;\nconst STATE_PAUSED = 1;\nconst STATE_STOPPED = 2;\n\nfunction capTime(time, duration) {\n\treturn time % duration || 0;\n}\n\nclass SoundInstance extends EventHandler {\n\tconstructor(manager, sound, options) {\n\t\tsuper();\n\t\tthis._manager = manager;\n\t\tthis._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;\n\t\tthis._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;\n\t\tthis._loop = !!(options.loop !== undefined ? options.loop : false);\n\t\tthis._sound = sound;\n\t\tthis._state = STATE_STOPPED;\n\t\tthis._suspended = false;\n\t\tthis._suspendEndEvent = false;\n\t\tthis._suspendInstanceEvents = false;\n\t\tthis._playWhenLoaded = true;\n\t\tthis._startTime = Math.max(0, Number(options.startTime) || 0);\n\t\tthis._duration = Math.max(0, Number(options.duration) || 0);\n\t\tthis._startOffset = null;\n\t\tthis.source = null;\n\t\tthis._onPlayCallback = options.onPlay;\n\t\tthis._onPauseCallback = options.onPause;\n\t\tthis._onResumeCallback = options.onResume;\n\t\tthis._onStopCallback = options.onStop;\n\t\tthis._onEndCallback = options.onEnd;\n\n\t\tif (hasAudioContext()) {\n\t\t\tthis._startedAt = 0;\n\t\t\tthis._currentTime = 0;\n\t\t\tthis._currentOffset = 0;\n\t\t\tthis._inputNode = null;\n\t\t\tthis._connectorNode = null;\n\t\t\tthis._firstNode = null;\n\t\t\tthis._lastNode = null;\n\n\t\t\tthis._initializeNodes();\n\n\t\t\tthis._endedHandler = this._onEnded.bind(this);\n\t\t} else {\n\t\t\tthis._isReady = false;\n\t\t\tthis._loadedMetadataHandler = this._onLoadedMetadata.bind(this);\n\t\t\tthis._timeUpdateHandler = this._onTimeUpdate.bind(this);\n\t\t\tthis._endedHandler = this._onEnded.bind(this);\n\n\t\t\tthis._createSource();\n\t\t}\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = Math.max(0, Number(value) || 0);\n\t\tconst isPlaying = this._state === STATE_PLAYING;\n\t\tthis.stop();\n\n\t\tif (isPlaying) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\n\tget duration() {\n\t\tif (!this._sound) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (this._duration) {\n\t\t\treturn capTime(this._duration, this._sound.duration);\n\t\t}\n\n\t\treturn this._sound.duration;\n\t}\n\n\tget isPaused() {\n\t\treturn this._state === STATE_PAUSED;\n\t}\n\n\tget isPlaying() {\n\t\treturn this._state === STATE_PLAYING;\n\t}\n\n\tget isStopped() {\n\t\treturn this._state === STATE_STOPPED;\n\t}\n\n\tget isSuspended() {\n\t\treturn this._suspended;\n\t}\n\n\tset loop(value) {\n\t\tthis._loop = !!value;\n\n\t\tif (this.source) {\n\t\t\tthis.source.loop = this._loop;\n\t\t}\n\t}\n\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\n\tset startTime(value) {\n\t\tthis._startTime = Math.max(0, Number(value) || 0);\n\t\tconst isPlaying = this._state === STATE_PLAYING;\n\t\tthis.stop();\n\n\t\tif (isPlaying) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\n\tget startTime() {\n\t\treturn this._startTime;\n\t}\n\n\t_onPlay() {\n\t\tthis.fire('play');\n\t\tif (this._onPlayCallback) this._onPlayCallback(this);\n\t}\n\n\t_onPause() {\n\t\tthis.fire('pause');\n\t\tif (this._onPauseCallback) this._onPauseCallback(this);\n\t}\n\n\t_onResume() {\n\t\tthis.fire('resume');\n\t\tif (this._onResumeCallback) this._onResumeCallback(this);\n\t}\n\n\t_onStop() {\n\t\tthis.fire('stop');\n\t\tif (this._onStopCallback) this._onStopCallback(this);\n\t}\n\n\t_onEnded() {\n\t\tif (this._suspendEndEvent) {\n\t\t\tthis._suspendEndEvent = false;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fire('end');\n\t\tif (this._onEndCallback) this._onEndCallback(this);\n\t\tthis.stop();\n\t}\n\n\t_onManagerVolumeChange() {\n\t\tthis.volume = this._volume;\n\t}\n\n\t_onManagerSuspend() {\n\t\tif (this._state === STATE_PLAYING && !this._suspended) {\n\t\t\tthis._suspended = true;\n\t\t\tthis.pause();\n\t\t}\n\t}\n\n\t_onManagerResume() {\n\t\tif (this._suspended) {\n\t\t\tthis._suspended = false;\n\t\t\tthis.resume();\n\t\t}\n\t}\n\n}\n\nif (hasAudioContext()) {\n\tObject.assign(SoundInstance.prototype, {\n\t\t_initializeNodes: function () {\n\t\t\tthis.gain = this._manager.context.createGain();\n\t\t\tthis._inputNode = this.gain;\n\t\t\tthis._connectorNode = this.gain;\n\n\t\t\tthis._connectorNode.connect(this._manager.context.destination);\n\t\t},\n\t\tplay: function () {\n\t\t\tif (this._state !== STATE_STOPPED) {\n\t\t\t\tthis.stop();\n\t\t\t}\n\n\t\t\tif (!this.source) {\n\t\t\t\tthis._createSource();\n\t\t\t}\n\n\t\t\tlet offset = capTime(this._startOffset, this.duration);\n\t\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\t\tthis._startOffset = null;\n\n\t\t\tif (this._duration) {\n\t\t\t\tthis.source.start(0, offset, this._duration);\n\t\t\t} else {\n\t\t\t\tthis.source.start(0, offset);\n\t\t\t}\n\n\t\t\tthis._startedAt = this._manager.context.currentTime;\n\t\t\tthis._currentTime = 0;\n\t\t\tthis._currentOffset = offset;\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis.volume = this._volume;\n\t\t\tthis.loop = this._loop;\n\t\t\tthis.pitch = this._pitch;\n\n\t\t\tthis._manager.on('volumechange', this._onManagerVolumeChange, this);\n\n\t\t\tthis._manager.on('suspend', this._onManagerSuspend, this);\n\n\t\t\tthis._manager.on('resume', this._onManagerResume, this);\n\n\t\t\tthis._manager.on('destroy', this._onManagerDestroy, this);\n\n\t\t\tif (this._manager.suspended) {\n\t\t\t\tthis._onManagerSuspend();\n\t\t\t}\n\n\t\t\tif (!this._suspendInstanceEvents) this._onPlay();\n\t\t\treturn true;\n\t\t},\n\t\tpause: function () {\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tif (this._state !== STATE_PLAYING || !this.source) return false;\n\n\t\t\tthis._updateCurrentTime();\n\n\t\t\tthis._state = STATE_PAUSED;\n\t\t\tthis._suspendEndEvent = true;\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t\tthis._startOffset = null;\n\t\t\tif (!this._suspendInstanceEvents) this._onPause();\n\t\t\treturn true;\n\t\t},\n\t\tresume: function () {\n\t\t\tif (this._state !== STATE_PAUSED) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.source) {\n\t\t\t\tthis._createSource();\n\t\t\t}\n\n\t\t\tlet offset = this.currentTime;\n\n\t\t\tif (this._startOffset !== null) {\n\t\t\t\toffset = capTime(this._startOffset, this.duration);\n\t\t\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\t\t\tthis._startOffset = null;\n\t\t\t}\n\n\t\t\tif (this._duration) {\n\t\t\t\tthis.source.start(0, offset, this._duration);\n\t\t\t} else {\n\t\t\t\tthis.source.start(0, offset);\n\t\t\t}\n\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._startedAt = this._manager.context.currentTime;\n\t\t\tthis._currentOffset = offset;\n\t\t\tthis.volume = this._volume;\n\t\t\tthis.loop = this._loop;\n\t\t\tthis.pitch = this._pitch;\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tif (!this._suspendInstanceEvents) this._onResume();\n\t\t\treturn true;\n\t\t},\n\t\tstop: function () {\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tif (this._state === STATE_STOPPED || !this.source) return false;\n\n\t\t\tthis._manager.off('volumechange', this._onManagerVolumeChange, this);\n\n\t\t\tthis._manager.off('suspend', this._onManagerSuspend, this);\n\n\t\t\tthis._manager.off('resume', this._onManagerResume, this);\n\n\t\t\tthis._manager.off('destroy', this._onManagerDestroy, this);\n\n\t\t\tthis._startedAt = 0;\n\t\t\tthis._currentTime = 0;\n\t\t\tthis._currentOffset = 0;\n\t\t\tthis._startOffset = null;\n\t\t\tthis._suspendEndEvent = true;\n\n\t\t\tif (this._state === STATE_PLAYING) {\n\t\t\t\tthis.source.stop(0);\n\t\t\t}\n\n\t\t\tthis.source = null;\n\t\t\tthis._state = STATE_STOPPED;\n\t\t\tif (!this._suspendInstanceEvents) this._onStop();\n\t\t\treturn true;\n\t\t},\n\t\tsetExternalNodes: function (firstNode, lastNode) {\n\t\t\tif (!firstNode) {\n\t\t\t\tconsole.error('The firstNode must be a valid Audio Node');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!lastNode) {\n\t\t\t\tlastNode = firstNode;\n\t\t\t}\n\n\t\t\tconst speakers = this._manager.context.destination;\n\n\t\t\tif (this._firstNode !== firstNode) {\n\t\t\t\tif (this._firstNode) {\n\t\t\t\t\tthis._connectorNode.disconnect(this._firstNode);\n\t\t\t\t} else {\n\t\t\t\t\tthis._connectorNode.disconnect(speakers);\n\t\t\t\t}\n\n\t\t\t\tthis._firstNode = firstNode;\n\n\t\t\t\tthis._connectorNode.connect(firstNode);\n\t\t\t}\n\n\t\t\tif (this._lastNode !== lastNode) {\n\t\t\t\tif (this._lastNode) {\n\t\t\t\t\tthis._lastNode.disconnect(speakers);\n\t\t\t\t}\n\n\t\t\t\tthis._lastNode = lastNode;\n\n\t\t\t\tthis._lastNode.connect(speakers);\n\t\t\t}\n\t\t},\n\t\tclearExternalNodes: function () {\n\t\t\tconst speakers = this._manager.context.destination;\n\n\t\t\tif (this._firstNode) {\n\t\t\t\tthis._connectorNode.disconnect(this._firstNode);\n\n\t\t\t\tthis._firstNode = null;\n\t\t\t}\n\n\t\t\tif (this._lastNode) {\n\t\t\t\tthis._lastNode.disconnect(speakers);\n\n\t\t\t\tthis._lastNode = null;\n\t\t\t}\n\n\t\t\tthis._connectorNode.connect(speakers);\n\t\t},\n\t\tgetExternalNodes: function () {\n\t\t\treturn [this._firstNode, this._lastNode];\n\t\t},\n\t\t_createSource: function () {\n\t\t\tif (!this._sound) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst context = this._manager.context;\n\n\t\t\tif (this._sound.buffer) {\n\t\t\t\tthis.source = context.createBufferSource();\n\t\t\t\tthis.source.buffer = this._sound.buffer;\n\t\t\t\tthis.source.connect(this._inputNode);\n\t\t\t\tthis.source.onended = this._endedHandler;\n\t\t\t\tthis.source.loopStart = capTime(this._startTime, this.source.buffer.duration);\n\n\t\t\t\tif (this._duration) {\n\t\t\t\t\tthis.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.source;\n\t\t},\n\t\t_updateCurrentTime: function () {\n\t\t\tthis._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);\n\t\t},\n\t\t_onManagerDestroy: function () {\n\t\t\tif (this.source && this._state === STATE_PLAYING) {\n\t\t\t\tthis.source.stop(0);\n\t\t\t\tthis.source = null;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'volume', {\n\t\tget: function () {\n\t\t\treturn this._volume;\n\t\t},\n\t\tset: function (volume) {\n\t\t\tvolume = math.clamp(volume, 0, 1);\n\t\t\tthis._volume = volume;\n\n\t\t\tif (this.gain) {\n\t\t\t\tthis.gain.gain.value = volume * this._manager.volume;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'pitch', {\n\t\tget: function () {\n\t\t\treturn this._pitch;\n\t\t},\n\t\tset: function (pitch) {\n\t\t\tthis._currentOffset = this.currentTime;\n\t\t\tthis._startedAt = this._manager.context.currentTime;\n\t\t\tthis._pitch = Math.max(Number(pitch) || 0, 0.01);\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.playbackRate.value = this._pitch;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'sound', {\n\t\tget: function () {\n\t\t\treturn this._sound;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._sound = value;\n\n\t\t\tif (this._state !== STATE_STOPPED) {\n\t\t\t\tthis.stop();\n\t\t\t} else {\n\t\t\t\tthis._createSource();\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'currentTime', {\n\t\tget: function () {\n\t\t\tif (this._startOffset !== null) {\n\t\t\t\treturn this._startOffset;\n\t\t\t}\n\n\t\t\tif (this._state === STATE_PAUSED) {\n\t\t\t\treturn this._currentTime;\n\t\t\t}\n\n\t\t\tif (this._state === STATE_STOPPED || !this.source) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tthis._updateCurrentTime();\n\n\t\t\treturn this._currentTime;\n\t\t},\n\t\tset: function (value) {\n\t\t\tif (value < 0) return;\n\n\t\t\tif (this._state === STATE_PLAYING) {\n\t\t\t\tconst suspend = this._suspendInstanceEvents;\n\t\t\t\tthis._suspendInstanceEvents = true;\n\t\t\t\tthis.stop();\n\t\t\t\tthis._startOffset = value;\n\t\t\t\tthis.play();\n\t\t\t\tthis._suspendInstanceEvents = suspend;\n\t\t\t} else {\n\t\t\t\tthis._startOffset = value;\n\t\t\t\tthis._currentTime = value;\n\t\t\t}\n\t\t}\n\t});\n} else {\n\tObject.assign(SoundInstance.prototype, {\n\t\tplay: function () {\n\t\t\tif (this._state !== STATE_STOPPED) {\n\t\t\t\tthis.stop();\n\t\t\t}\n\n\t\t\tif (!this.source) {\n\t\t\t\tif (!this._createSource()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.volume = this._volume;\n\t\t\tthis.pitch = this._pitch;\n\t\t\tthis.loop = this._loop;\n\t\t\tthis.source.play();\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._playWhenLoaded = false;\n\n\t\t\tthis._manager.on('volumechange', this._onManagerVolumeChange, this);\n\n\t\t\tthis._manager.on('suspend', this._onManagerSuspend, this);\n\n\t\t\tthis._manager.on('resume', this._onManagerResume, this);\n\n\t\t\tthis._manager.on('destroy', this._onManagerDestroy, this);\n\n\t\t\tif (this._manager.suspended) this._onManagerSuspend();\n\t\t\tif (!this._suspendInstanceEvents) this._onPlay();\n\t\t\treturn true;\n\t\t},\n\t\tpause: function () {\n\t\t\tif (!this.source || this._state !== STATE_PLAYING) return false;\n\t\t\tthis._suspendEndEvent = true;\n\t\t\tthis.source.pause();\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis._state = STATE_PAUSED;\n\t\t\tthis._startOffset = null;\n\t\t\tif (!this._suspendInstanceEvents) this._onPause();\n\t\t\treturn true;\n\t\t},\n\t\tresume: function () {\n\t\t\tif (!this.source || this._state !== STATE_PAUSED) return false;\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._playWhenLoaded = false;\n\n\t\t\tif (this.source.paused) {\n\t\t\t\tthis.source.play();\n\t\t\t\tif (!this._suspendInstanceEvents) this._onResume();\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\t\tstop: function () {\n\t\t\tif (!this.source || this._state === STATE_STOPPED) return false;\n\n\t\t\tthis._manager.off('volumechange', this._onManagerVolumeChange, this);\n\n\t\t\tthis._manager.off('suspend', this._onManagerSuspend, this);\n\n\t\t\tthis._manager.off('resume', this._onManagerResume, this);\n\n\t\t\tthis._manager.off('destroy', this._onManagerDestroy, this);\n\n\t\t\tthis._suspendEndEvent = true;\n\t\t\tthis.source.pause();\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis._state = STATE_STOPPED;\n\t\t\tthis._startOffset = null;\n\t\t\tif (!this._suspendInstanceEvents) this._onStop();\n\t\t\treturn true;\n\t\t},\n\t\tsetExternalNodes: function () {},\n\t\tclearExternalNodes: function () {},\n\t\tgetExternalNodes: function () {\n\t\t\treturn [null, null];\n\t\t},\n\t\t_onLoadedMetadata: function () {\n\t\t\tthis.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);\n\t\t\tthis._isReady = true;\n\t\t\tlet offset = capTime(this._startOffset, this.duration);\n\t\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\t\tthis._startOffset = null;\n\t\t\tthis.source.currentTime = offset;\n\t\t},\n\t\t_createSource: function () {\n\t\t\tif (this._sound && this._sound.audio) {\n\t\t\t\tthis._isReady = false;\n\t\t\t\tthis.source = this._sound.audio.cloneNode(true);\n\t\t\t\tthis.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);\n\t\t\t\tthis.source.addEventListener('timeupdate', this._timeUpdateHandler);\n\t\t\t\tthis.source.onended = this._endedHandler;\n\t\t\t}\n\n\t\t\treturn this.source;\n\t\t},\n\t\t_onTimeUpdate: function () {\n\t\t\tif (!this._duration) return;\n\n\t\t\tif (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {\n\t\t\t\tif (this.loop) {\n\t\t\t\t\tthis.source.currentTime = capTime(this._startTime, this.source.duration);\n\t\t\t\t} else {\n\t\t\t\t\tthis.source.removeEventListener('timeupdate', this._timeUpdateHandler);\n\t\t\t\t\tthis.source.pause();\n\n\t\t\t\t\tthis._onEnded();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_onManagerDestroy: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'volume', {\n\t\tget: function () {\n\t\t\treturn this._volume;\n\t\t},\n\t\tset: function (volume) {\n\t\t\tvolume = math.clamp(volume, 0, 1);\n\t\t\tthis._volume = volume;\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.volume = volume * this._manager.volume;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'pitch', {\n\t\tget: function () {\n\t\t\treturn this._pitch;\n\t\t},\n\t\tset: function (pitch) {\n\t\t\tthis._pitch = Math.max(Number(pitch) || 0, 0.01);\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.playbackRate = this._pitch;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'sound', {\n\t\tget: function () {\n\t\t\treturn this._sound;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.stop();\n\t\t\tthis._sound = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'currentTime', {\n\t\tget: function () {\n\t\t\tif (this._startOffset !== null) {\n\t\t\t\treturn this._startOffset;\n\t\t\t}\n\n\t\t\tif (this._state === STATE_STOPPED || !this.source) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn this.source.currentTime - this._startTime;\n\t\t},\n\t\tset: function (value) {\n\t\t\tif (value < 0) return;\n\t\t\tthis._startOffset = value;\n\n\t\t\tif (this.source && this._isReady) {\n\t\t\t\tthis.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);\n\t\t\t\tthis._startOffset = null;\n\t\t\t}\n\t\t}\n\t});\n}\n\nconst MAX_DISTANCE = 10000;\n\nclass SoundInstance3d extends SoundInstance {\n\tconstructor(manager, sound, options) {\n\t\tsuper(manager, sound, options);\n\t\toptions = options || {};\n\t\tthis._position = new Vec3();\n\t\tif (options.position) this.position = options.position;\n\t\tthis._velocity = new Vec3();\n\t\tif (options.velocity) this.velocity = options.velocity;\n\t\tthis.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;\n\t\tthis.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;\n\t\tthis.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;\n\t\tthis.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;\n\t}\n\n}\n\nif (hasAudioContext()) {\n\tObject.assign(SoundInstance3d.prototype, {\n\t\t_initializeNodes: function () {\n\t\t\tthis.gain = this._manager.context.createGain();\n\t\t\tthis.panner = this._manager.context.createPanner();\n\t\t\tthis.panner.connect(this.gain);\n\t\t\tthis._inputNode = this.panner;\n\t\t\tthis._connectorNode = this.gain;\n\n\t\t\tthis._connectorNode.connect(this._manager.context.destination);\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'position', {\n\t\tget: function () {\n\t\t\treturn this._position;\n\t\t},\n\t\tset: function (position) {\n\t\t\tthis._position.copy(position);\n\n\t\t\tthis.panner.setPosition(position.x, position.y, position.z);\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'velocity', {\n\t\tget: function () {\n\t\t\treturn this._velocity;\n\t\t},\n\t\tset: function (velocity) {\n\t\t\tthis._velocity.copy(velocity);\n\n\t\t\tthis.panner.setVelocity(velocity.x, velocity.y, velocity.z);\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'maxDistance', {\n\t\tget: function () {\n\t\t\treturn this.panner.maxDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.panner.maxDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'refDistance', {\n\t\tget: function () {\n\t\t\treturn this.panner.refDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.panner.refDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {\n\t\tget: function () {\n\t\t\treturn this.panner.rolloffFactor;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.panner.rolloffFactor = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'distanceModel', {\n\t\tget: function () {\n\t\t\treturn this.panner.distanceModel;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.panner.distanceModel = value;\n\t\t}\n\t});\n} else {\n\tlet offset = new Vec3();\n\n\tconst fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {\n\t\toffset = offset.sub2(posOne, posTwo);\n\t\tconst distance = offset.length();\n\n\t\tif (distance < refDistance) {\n\t\t\treturn 1;\n\t\t} else if (distance > maxDistance) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet result = 0;\n\n\t\tif (distanceModel === DISTANCE_LINEAR) {\n\t\t\tresult = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);\n\t\t} else if (distanceModel === DISTANCE_INVERSE) {\n\t\t\tresult = refDistance / (refDistance + rollOffFactor * (distance - refDistance));\n\t\t} else if (distanceModel === DISTANCE_EXPONENTIAL) {\n\t\t\tresult = Math.pow(distance / refDistance, -rollOffFactor);\n\t\t}\n\n\t\treturn math.clamp(result, 0, 1);\n\t};\n\n\tObject.defineProperty(SoundInstance3d.prototype, 'position', {\n\t\tget: function () {\n\t\t\treturn this._position;\n\t\t},\n\t\tset: function (position) {\n\t\t\tthis._position.copy(position);\n\n\t\t\tif (this.source) {\n\t\t\t\tconst listener = this._manager.listener;\n\t\t\t\tconst lpos = listener.getPosition();\n\t\t\t\tconst factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);\n\t\t\t\tconst v = this.volume;\n\t\t\t\tthis.source.volume = v * factor * this._manager.volume;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'velocity', {\n\t\tget: function () {\n\t\t\treturn this._velocity;\n\t\t},\n\t\tset: function (velocity) {\n\t\t\tthis._velocity.copy(velocity);\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'maxDistance', {\n\t\tget: function () {\n\t\t\treturn this._maxDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._maxDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'refDistance', {\n\t\tget: function () {\n\t\t\treturn this._refDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._refDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {\n\t\tget: function () {\n\t\t\treturn this._rollOffFactor;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._rollOffFactor = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'distanceModel', {\n\t\tget: function () {\n\t\t\treturn this._distanceModel;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._distanceModel = value;\n\t\t}\n\t});\n}\n\nconst instanceOptions = {\n\tvolume: 0,\n\tpitch: 0,\n\tloop: false,\n\tstartTime: 0,\n\tduration: 0,\n\tposition: new Vec3(),\n\tmaxDistance: 0,\n\trefDistance: 0,\n\trollOffFactor: 0,\n\tdistanceModel: 0,\n\tonPlay: null,\n\tonPause: null,\n\tonResume: null,\n\tonStop: null,\n\tonEnd: null\n};\n\nclass SoundSlot extends EventHandler {\n\tconstructor(component, name = 'Untitled', options = {}) {\n\t\tsuper();\n\t\tthis.name = void 0;\n\t\tthis.instances = [];\n\t\tthis._component = component;\n\t\tthis._assets = component.system.app.assets;\n\t\tthis._manager = component.system.manager;\n\t\tthis.name = name;\n\t\tthis._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;\n\t\tthis._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;\n\t\tthis._loop = !!(options.loop !== undefined ? options.loop : false);\n\t\tthis._duration = options.duration > 0 ? options.duration : null;\n\t\tthis._startTime = Math.max(0, Number(options.startTime) || 0);\n\t\tthis._overlap = !!options.overlap;\n\t\tthis._autoPlay = !!options.autoPlay;\n\t\tthis._firstNode = null;\n\t\tthis._lastNode = null;\n\t\tthis._asset = options.asset;\n\n\t\tif (this._asset instanceof Asset) {\n\t\t\tthis._asset = this._asset.id;\n\t\t}\n\n\t\tthis._onInstancePlayHandler = this._onInstancePlay.bind(this);\n\t\tthis._onInstancePauseHandler = this._onInstancePause.bind(this);\n\t\tthis._onInstanceResumeHandler = this._onInstanceResume.bind(this);\n\t\tthis._onInstanceStopHandler = this._onInstanceStop.bind(this);\n\t\tthis._onInstanceEndHandler = this._onInstanceEnd.bind(this);\n\t}\n\n\tplay() {\n\t\tif (!this.overlap) {\n\t\t\tthis.stop();\n\t\t}\n\n\t\tif (!this.isLoaded && !this._hasAsset()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst instance = this._createInstance();\n\n\t\tthis.instances.push(instance);\n\n\t\tif (!this.isLoaded) {\n\t\t\tconst onLoad = function onLoad(sound) {\n\t\t\t\tconst playWhenLoaded = instance._playWhenLoaded;\n\t\t\t\tinstance.sound = sound;\n\n\t\t\t\tif (playWhenLoaded) {\n\t\t\t\t\tinstance.play();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.off('load', onLoad);\n\t\t\tthis.once('load', onLoad);\n\t\t\tthis.load();\n\t\t} else {\n\t\t\tinstance.play();\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\tpause() {\n\t\tlet paused = false;\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].pause()) {\n\t\t\t\tpaused = true;\n\t\t\t}\n\t\t}\n\n\t\treturn paused;\n\t}\n\n\tresume() {\n\t\tlet resumed = false;\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].resume()) resumed = true;\n\t\t}\n\n\t\treturn resumed;\n\t}\n\n\tstop() {\n\t\tlet stopped = false;\n\t\tconst instances = this.instances;\n\t\tlet i = instances.length;\n\n\t\twhile (i--) {\n\t\t\tinstances[i].stop();\n\t\t\tstopped = true;\n\t\t}\n\n\t\tinstances.length = 0;\n\t\treturn stopped;\n\t}\n\n\tload() {\n\t\tif (!this._hasAsset()) return;\n\n\t\tconst asset = this._assets.get(this._asset);\n\n\t\tif (!asset) {\n\t\t\tthis._assets.off('add:' + this._asset, this._onAssetAdd, this);\n\n\t\t\tthis._assets.once('add:' + this._asset, this._onAssetAdd, this);\n\n\t\t\treturn;\n\t\t}\n\n\t\tasset.off('remove', this._onAssetRemoved, this);\n\t\tasset.on('remove', this._onAssetRemoved, this);\n\n\t\tif (!asset.resource) {\n\t\t\tasset.off('load', this._onAssetLoad, this);\n\t\t\tasset.once('load', this._onAssetLoad, this);\n\n\t\t\tthis._assets.load(asset);\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fire('load', asset.resource);\n\t}\n\n\tsetExternalNodes(firstNode, lastNode) {\n\t\tif (!firstNode) {\n\t\t\tconsole.error('The firstNode must have a valid AudioNode');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!lastNode) {\n\t\t\tlastNode = firstNode;\n\t\t}\n\n\t\tthis._firstNode = firstNode;\n\t\tthis._lastNode = lastNode;\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].setExternalNodes(firstNode, lastNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tclearExternalNodes() {\n\t\tthis._firstNode = null;\n\t\tthis._lastNode = null;\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].clearExternalNodes();\n\t\t\t}\n\t\t}\n\t}\n\n\tgetExternalNodes() {\n\t\treturn [this._firstNode, this._lastNode];\n\t}\n\n\t_hasAsset() {\n\t\treturn this._asset != null;\n\t}\n\n\t_createInstance() {\n\t\tlet instance = null;\n\t\tconst component = this._component;\n\t\tlet sound = null;\n\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\n\t\t\tif (asset) {\n\t\t\t\tsound = asset.resource;\n\t\t\t}\n\t\t}\n\n\t\tconst data = instanceOptions;\n\t\tdata.volume = this._volume * component.volume;\n\t\tdata.pitch = this._pitch * component.pitch;\n\t\tdata.loop = this._loop;\n\t\tdata.startTime = this._startTime;\n\t\tdata.duration = this._duration;\n\t\tdata.onPlay = this._onInstancePlayHandler;\n\t\tdata.onPause = this._onInstancePauseHandler;\n\t\tdata.onResume = this._onInstanceResumeHandler;\n\t\tdata.onStop = this._onInstanceStopHandler;\n\t\tdata.onEnd = this._onInstanceEndHandler;\n\n\t\tif (component.positional) {\n\t\t\tdata.position.copy(component.entity.getPosition());\n\t\t\tdata.maxDistance = component.maxDistance;\n\t\t\tdata.refDistance = component.refDistance;\n\t\t\tdata.rollOffFactor = component.rollOffFactor;\n\t\t\tdata.distanceModel = component.distanceModel;\n\t\t\tinstance = new SoundInstance3d(this._manager, sound, data);\n\t\t} else {\n\t\t\tinstance = new SoundInstance(this._manager, sound, data);\n\t\t}\n\n\t\tif (this._firstNode) {\n\t\t\tinstance.setExternalNodes(this._firstNode, this._lastNode);\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\t_onInstancePlay(instance) {\n\t\tthis.fire('play', instance);\n\n\t\tthis._component.fire('play', this, instance);\n\t}\n\n\t_onInstancePause(instance) {\n\t\tthis.fire('pause', instance);\n\n\t\tthis._component.fire('pause', this, instance);\n\t}\n\n\t_onInstanceResume(instance) {\n\t\tthis.fire('resume', instance);\n\n\t\tthis._component.fire('resume', this, instance);\n\t}\n\n\t_onInstanceStop(instance) {\n\t\tconst idx = this.instances.indexOf(instance);\n\n\t\tif (idx !== -1) {\n\t\t\tthis.instances.splice(idx, 1);\n\t\t}\n\n\t\tthis.fire('stop', instance);\n\n\t\tthis._component.fire('stop', this, instance);\n\t}\n\n\t_onInstanceEnd(instance) {\n\t\tconst idx = this.instances.indexOf(instance);\n\n\t\tif (idx !== -1) {\n\t\t\tthis.instances.splice(idx, 1);\n\t\t}\n\n\t\tthis.fire('end', instance);\n\n\t\tthis._component.fire('end', this, instance);\n\t}\n\n\t_onAssetAdd(asset) {\n\t\tthis.load();\n\t}\n\n\t_onAssetLoad(asset) {\n\t\tthis.load();\n\t}\n\n\t_onAssetRemoved(asset) {\n\t\tasset.off('remove', this._onAssetRemoved, this);\n\n\t\tthis._assets.off('add:' + asset.id, this._onAssetAdd, this);\n\n\t\tthis.stop();\n\t}\n\n\tupdatePosition(position) {\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tinstances[i].position = position;\n\t\t}\n\t}\n\n\tset asset(value) {\n\t\tconst old = this._asset;\n\n\t\tif (old) {\n\t\t\tthis._assets.off('add:' + old, this._onAssetAdd, this);\n\n\t\t\tconst oldAsset = this._assets.get(old);\n\n\t\t\tif (oldAsset) {\n\t\t\t\toldAsset.off('remove', this._onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\n\t\tthis._asset = value;\n\n\t\tif (this._asset instanceof Asset) {\n\t\t\tthis._asset = this._asset.id;\n\t\t}\n\n\t\tif (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {\n\t\t\tthis.load();\n\t\t}\n\t}\n\n\tget asset() {\n\t\treturn this._asset;\n\t}\n\n\tset autoPlay(value) {\n\t\tthis._autoPlay = !!value;\n\t}\n\n\tget autoPlay() {\n\t\treturn this._autoPlay;\n\t}\n\n\tset duration(value) {\n\t\tthis._duration = Math.max(0, Number(value) || 0) || null;\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].duration = this._duration;\n\t\t\t}\n\t\t}\n\t}\n\n\tget duration() {\n\t\tlet assetDuration = 0;\n\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\n\t\t\tassetDuration = asset != null && asset.resource ? asset.resource.duration : 0;\n\t\t}\n\n\t\tif (this._duration != null) {\n\t\t\treturn this._duration % (assetDuration || 1);\n\t\t}\n\n\t\treturn assetDuration;\n\t}\n\n\tget isLoaded() {\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\n\t\t\tif (asset) {\n\t\t\t\treturn !!asset.resource;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget isPaused() {\n\t\tconst instances = this.instances;\n\t\tconst len = instances.length;\n\t\tif (len === 0) return false;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (!instances[i].isPaused) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget isPlaying() {\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].isPlaying) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget isStopped() {\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (!instances[i].isStopped) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tset loop(value) {\n\t\tthis._loop = !!value;\n\t\tconst instances = this.instances;\n\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tinstances[i].loop = this._loop;\n\t\t}\n\t}\n\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\n\tset overlap(value) {\n\t\tthis._overlap = !!value;\n\t}\n\n\tget overlap() {\n\t\treturn this._overlap;\n\t}\n\n\tset pitch(value) {\n\t\tthis._pitch = Math.max(Number(value) || 0, 0.01);\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].pitch = this.pitch * this._component.pitch;\n\t\t\t}\n\t\t}\n\t}\n\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\n\tset startTime(value) {\n\t\tthis._startTime = Math.max(0, Number(value) || 0);\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].startTime = this._startTime;\n\t\t\t}\n\t\t}\n\t}\n\n\tget startTime() {\n\t\treturn this._startTime;\n\t}\n\n\tset volume(value) {\n\t\tthis._volume = math.clamp(Number(value) || 0, 0, 1);\n\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].volume = this._volume * this._component.volume;\n\t\t\t}\n\t\t}\n\t}\n\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\n}\n\nclass SoundComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._volume = 1;\n\t\tthis._pitch = 1;\n\t\tthis._positional = true;\n\t\tthis._refDistance = 1;\n\t\tthis._maxDistance = 10000;\n\t\tthis._rollOffFactor = 1;\n\t\tthis._distanceModel = DISTANCE_LINEAR;\n\t\tthis._slots = {};\n\t\tthis._playingBeforeDisable = {};\n\t}\n\n\t_updateSoundInstances(property, value, isFactor) {\n\t\tconst slots = this._slots;\n\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\n\t\t\tif (!slot.overlap) {\n\t\t\t\tconst instances = slot.instances;\n\n\t\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\t\tinstances[i][property] = isFactor ? slot[property] * value : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset distanceModel(value) {\n\t\tthis._distanceModel = value;\n\n\t\tthis._updateSoundInstances('distanceModel', value, false);\n\t}\n\n\tget distanceModel() {\n\t\treturn this._distanceModel;\n\t}\n\n\tset maxDistance(value) {\n\t\tthis._maxDistance = value;\n\n\t\tthis._updateSoundInstances('maxDistance', value, false);\n\t}\n\n\tget maxDistance() {\n\t\treturn this._maxDistance;\n\t}\n\n\tset refDistance(value) {\n\t\tthis._refDistance = value;\n\n\t\tthis._updateSoundInstances('refDistance', value, false);\n\t}\n\n\tget refDistance() {\n\t\treturn this._refDistance;\n\t}\n\n\tset rollOffFactor(value) {\n\t\tthis._rollOffFactor = value;\n\n\t\tthis._updateSoundInstances('rollOffFactor', value, false);\n\t}\n\n\tget rollOffFactor() {\n\t\treturn this._rollOffFactor;\n\t}\n\n\tset pitch(value) {\n\t\tthis._pitch = value;\n\n\t\tthis._updateSoundInstances('pitch', value, true);\n\t}\n\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\n\tset volume(value) {\n\t\tthis._volume = value;\n\n\t\tthis._updateSoundInstances('volume', value, true);\n\t}\n\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\n\tset positional(newValue) {\n\t\tthis._positional = newValue;\n\t\tconst slots = this._slots;\n\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\n\t\t\tif (!slot.overlap) {\n\t\t\t\tconst instances = slot.instances;\n\t\t\t\tconst oldLength = instances.length;\n\n\t\t\t\tfor (let i = oldLength - 1; i >= 0; i--) {\n\t\t\t\t\tconst isPlaying = instances[i].isPlaying || instances[i].isSuspended;\n\t\t\t\t\tconst currentTime = instances[i].currentTime;\n\t\t\t\t\tif (isPlaying) instances[i].stop();\n\n\t\t\t\t\tconst instance = slot._createInstance();\n\n\t\t\t\t\tif (isPlaying) {\n\t\t\t\t\t\tinstance.play();\n\t\t\t\t\t\tinstance.currentTime = currentTime;\n\t\t\t\t\t}\n\n\t\t\t\t\tinstances.push(instance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget positional() {\n\t\treturn this._positional;\n\t}\n\n\tset slots(newValue) {\n\t\tconst oldValue = this._slots;\n\n\t\tif (oldValue) {\n\t\t\tfor (const key in oldValue) {\n\t\t\t\toldValue[key].stop();\n\t\t\t}\n\t\t}\n\n\t\tconst slots = {};\n\n\t\tfor (const key in newValue) {\n\t\t\tif (!(newValue[key] instanceof SoundSlot)) {\n\t\t\t\tif (newValue[key].name) {\n\t\t\t\t\tslots[newValue[key].name] = new SoundSlot(this, newValue[key].name, newValue[key]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslots[newValue[key].name] = newValue[key];\n\t\t\t}\n\t\t}\n\n\t\tthis._slots = slots;\n\t\tif (this.enabled && this.entity.enabled) this.onEnable();\n\t}\n\n\tget slots() {\n\t\treturn this._slots;\n\t}\n\n\tonEnable() {\n\t\tif (this.system._inTools) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst slots = this._slots;\n\t\tconst playingBeforeDisable = this._playingBeforeDisable;\n\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\n\t\t\tif (slot.autoPlay && slot.isStopped) {\n\t\t\t\tslot.play();\n\t\t\t} else if (playingBeforeDisable[key]) {\n\t\t\t\tslot.resume();\n\t\t\t} else if (!slot.isLoaded) {\n\t\t\t\tslot.load();\n\t\t\t}\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tconst slots = this._slots;\n\t\tconst playingBeforeDisable = {};\n\n\t\tfor (const key in slots) {\n\t\t\tif (!slots[key].overlap) {\n\t\t\t\tif (slots[key].isPlaying) {\n\t\t\t\t\tslots[key].pause();\n\t\t\t\t\tplayingBeforeDisable[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._playingBeforeDisable = playingBeforeDisable;\n\t}\n\n\tonRemove() {\n\t\tthis.off();\n\t}\n\n\taddSlot(name, options) {\n\t\tconst slots = this._slots;\n\n\t\tif (slots[name]) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst slot = new SoundSlot(this, name, options);\n\t\tslots[name] = slot;\n\n\t\tif (slot.autoPlay && this.enabled && this.entity.enabled) {\n\t\t\tslot.play();\n\t\t}\n\n\t\treturn slot;\n\t}\n\n\tremoveSlot(name) {\n\t\tconst slots = this._slots;\n\n\t\tif (slots[name]) {\n\t\t\tslots[name].stop();\n\t\t\tdelete slots[name];\n\t\t}\n\t}\n\n\tslot(name) {\n\t\treturn this._slots[name];\n\t}\n\n\tplay(name) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst slot = this._slots[name];\n\n\t\tif (!slot) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn slot.play();\n\t}\n\n\tpause(name) {\n\t\tconst slots = this._slots;\n\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tslot.pause();\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].pause();\n\t\t\t}\n\t\t}\n\t}\n\n\tresume(name) {\n\t\tconst slots = this._slots;\n\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (slot.isPaused) {\n\t\t\t\tslot.resume();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].resume();\n\t\t\t}\n\t\t}\n\t}\n\n\tstop(name) {\n\t\tconst slots = this._slots;\n\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tslot.stop();\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].stop();\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass SoundComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$2 = ['enabled'];\n\nclass SoundComponentSystem extends ComponentSystem {\n\tconstructor(app, manager) {\n\t\tsuper(app);\n\t\tthis.id = \"sound\";\n\t\tthis.ComponentType = SoundComponent;\n\t\tthis.DataType = SoundComponentData;\n\t\tthis.schema = _schema$2;\n\t\tthis.manager = manager;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t}\n\n\tset volume(volume) {\n\t\tthis.manager.volume = volume;\n\t}\n\n\tget volume() {\n\t\treturn this.manager.volume;\n\t}\n\n\tget context() {\n\t\tif (!hasAudioContext()) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.manager.context;\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];\n\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tif (data.hasOwnProperty(properties[i])) {\n\t\t\t\tcomponent[properties[i]] = data[properties[i]];\n\t\t\t}\n\t\t}\n\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst srcComponent = entity.sound;\n\t\tconst srcSlots = srcComponent.slots;\n\t\tconst slots = {};\n\n\t\tfor (const key in srcSlots) {\n\t\t\tconst srcSlot = srcSlots[key];\n\t\t\tslots[key] = {\n\t\t\t\tname: srcSlot.name,\n\t\t\t\tvolume: srcSlot.volume,\n\t\t\t\tpitch: srcSlot.pitch,\n\t\t\t\tloop: srcSlot.loop,\n\t\t\t\tduration: srcSlot.duration,\n\t\t\t\tstartTime: srcSlot.startTime,\n\t\t\t\toverlap: srcSlot.overlap,\n\t\t\t\tautoPlay: srcSlot.autoPlay,\n\t\t\t\tasset: srcSlot.asset\n\t\t\t};\n\t\t}\n\n\t\tconst cloneData = {\n\t\t\tdistanceModel: srcComponent.distanceModel,\n\t\t\tenabled: srcComponent.enabled,\n\t\t\tmaxDistance: srcComponent.maxDistance,\n\t\t\tpitch: srcComponent.pitch,\n\t\t\tpositional: srcComponent.positional,\n\t\t\trefDistance: srcComponent.refDistance,\n\t\t\trollOffFactor: srcComponent.rollOffFactor,\n\t\t\tslots: slots,\n\t\t\tvolume: srcComponent.volume\n\t\t};\n\t\treturn this.addComponent(clone, cloneData);\n\t}\n\n\tonUpdate(dt) {\n\t\tconst store = this.store;\n\n\t\tfor (const id in store) {\n\t\t\tif (store.hasOwnProperty(id)) {\n\t\t\t\tconst item = store[id];\n\t\t\t\tconst entity = item.entity;\n\n\t\t\t\tif (entity.enabled) {\n\t\t\t\t\tconst component = entity.sound;\n\n\t\t\t\t\tif (component.enabled && component.positional) {\n\t\t\t\t\t\tconst position = entity.getPosition();\n\t\t\t\t\t\tconst slots = component.slots;\n\n\t\t\t\t\t\tfor (const key in slots) {\n\t\t\t\t\t\t\tslots[key].updatePosition(position);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tconst slots = component.slots;\n\n\t\tfor (const key in slots) {\n\t\t\tif (!slots[key].overlap) {\n\t\t\t\tslots[key].stop();\n\t\t\t}\n\t\t}\n\n\t\tcomponent.onRemove();\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n\n}\n\nComponent._buildAccessors(SoundComponent.prototype, _schema$2);\n\nconst SPRITETYPE_SIMPLE = 'simple';\nconst SPRITETYPE_ANIMATED = 'animated';\n\nclass SpriteAnimationClip extends EventHandler {\n\tconstructor(component, data) {\n\t\tsuper();\n\t\tthis._component = component;\n\t\tthis._frame = 0;\n\t\tthis._sprite = null;\n\t\tthis._spriteAsset = null;\n\t\tthis.spriteAsset = data.spriteAsset;\n\t\tthis.name = data.name;\n\t\tthis.fps = data.fps || 0;\n\t\tthis.loop = data.loop || false;\n\t\tthis._playing = false;\n\t\tthis._paused = false;\n\t\tthis._time = 0;\n\t}\n\n\tget duration() {\n\t\tif (this._sprite) {\n\t\t\tconst fps = this.fps || Number.MIN_VALUE;\n\t\t\treturn this._sprite.frameKeys.length / Math.abs(fps);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tset frame(value) {\n\t\tthis._setFrame(value);\n\n\t\tconst fps = this.fps || Number.MIN_VALUE;\n\n\t\tthis._setTime(this._frame / fps);\n\t}\n\n\tget frame() {\n\t\treturn this._frame;\n\t}\n\n\tget isPaused() {\n\t\treturn this._paused;\n\t}\n\n\tget isPlaying() {\n\t\treturn this._playing;\n\t}\n\n\tset sprite(value) {\n\t\tif (this._sprite) {\n\t\t\tthis._sprite.off('set:meshes', this._onSpriteMeshesChange, this);\n\n\t\t\tthis._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);\n\n\t\t\tthis._sprite.off('set:atlas', this._onSpriteMeshesChange, this);\n\n\t\t\tif (this._sprite.atlas) {\n\t\t\t\tthis._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);\n\t\t\t}\n\t\t}\n\n\t\tthis._sprite = value;\n\n\t\tif (this._sprite) {\n\t\t\tthis._sprite.on('set:meshes', this._onSpriteMeshesChange, this);\n\n\t\t\tthis._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);\n\n\t\t\tthis._sprite.on('set:atlas', this._onSpriteMeshesChange, this);\n\n\t\t\tif (this._sprite.atlas) {\n\t\t\t\tthis._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);\n\t\t\t}\n\t\t}\n\n\t\tif (this._component.currentClip === this) {\n\t\t\tlet mi;\n\n\t\t\tif (!value || !value.atlas) {\n\t\t\t\tmi = this._component._meshInstance;\n\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.deleteParameter('texture_emissiveMap');\n\t\t\t\t\tmi.deleteParameter('texture_opacityMap');\n\t\t\t\t}\n\n\t\t\t\tthis._component._hideModel();\n\t\t\t} else {\n\t\t\t\tif (value.atlas.texture) {\n\t\t\t\t\tmi = this._component._meshInstance;\n\n\t\t\t\t\tif (mi) {\n\t\t\t\t\t\tmi.setParameter('texture_emissiveMap', value.atlas.texture);\n\t\t\t\t\t\tmi.setParameter('texture_opacityMap', value.atlas.texture);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._component.enabled && this._component.entity.enabled) {\n\t\t\t\t\t\tthis._component._showModel();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.time && this.fps) {\n\t\t\t\t\tthis.time = this.time;\n\t\t\t\t} else {\n\t\t\t\t\tthis.frame = this.frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget sprite() {\n\t\treturn this._sprite;\n\t}\n\n\tset spriteAsset(value) {\n\t\tconst assets = this._component.system.app.assets;\n\t\tlet id = value;\n\n\t\tif (value instanceof Asset) {\n\t\t\tid = value.id;\n\t\t}\n\n\t\tif (this._spriteAsset !== id) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst prev = assets.get(this._spriteAsset);\n\n\t\t\t\tif (prev) {\n\t\t\t\t\tthis._unbindSpriteAsset(prev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._spriteAsset = id;\n\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst asset = assets.get(this._spriteAsset);\n\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.sprite = null;\n\t\t\t\t\tassets.on('add:' + this._spriteAsset, this._onSpriteAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tget spriteAsset() {\n\t\treturn this._spriteAsset;\n\t}\n\n\tset time(value) {\n\t\tthis._setTime(value);\n\n\t\tif (this._sprite) {\n\t\t\tthis.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));\n\t\t} else {\n\t\t\tthis.frame = 0;\n\t\t}\n\t}\n\n\tget time() {\n\t\treturn this._time;\n\t}\n\n\t_onSpriteAssetAdded(asset) {\n\t\tthis._component.system.app.assets.off('add:' + asset.id, this._onSpriteAssetAdded, this);\n\n\t\tif (this._spriteAsset === asset.id) {\n\t\t\tthis._bindSpriteAsset(asset);\n\t\t}\n\t}\n\n\t_bindSpriteAsset(asset) {\n\t\tasset.on(\"load\", this._onSpriteAssetLoad, this);\n\t\tasset.on(\"remove\", this._onSpriteAssetRemove, this);\n\n\t\tif (asset.resource) {\n\t\t\tthis._onSpriteAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._component.system.app.assets.load(asset);\n\t\t}\n\t}\n\n\t_unbindSpriteAsset(asset) {\n\t\tasset.off(\"load\", this._onSpriteAssetLoad, this);\n\t\tasset.off(\"remove\", this._onSpriteAssetRemove, this);\n\n\t\tif (asset.resource && asset.resource.atlas) {\n\t\t\tthis._component.system.app.assets.off('load:' + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);\n\t\t}\n\t}\n\n\t_onSpriteAssetLoad(asset) {\n\t\tif (!asset.resource) {\n\t\t\tthis.sprite = null;\n\t\t} else {\n\t\t\tif (!asset.resource.atlas) {\n\t\t\t\tconst atlasAssetId = asset.data.textureAtlasAsset;\n\t\t\t\tconst assets = this._component.system.app.assets;\n\t\t\t\tassets.off('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n\t\t\t\tassets.once('load:' + atlasAssetId, this._onTextureAtlasLoad, this);\n\t\t\t} else {\n\t\t\t\tthis.sprite = asset.resource;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onTextureAtlasLoad(atlasAsset) {\n\t\tconst spriteAsset = this._spriteAsset;\n\n\t\tif (spriteAsset instanceof Asset) {\n\t\t\tthis._onSpriteAssetLoad(spriteAsset);\n\t\t} else {\n\t\t\tthis._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));\n\t\t}\n\t}\n\n\t_onSpriteAssetRemove(asset) {\n\t\tthis.sprite = null;\n\t}\n\n\t_onSpriteMeshesChange() {\n\t\tif (this._component.currentClip === this) {\n\t\t\tthis._component._showFrame(this.frame);\n\t\t}\n\t}\n\n\t_onSpritePpuChanged() {\n\t\tif (this._component.currentClip === this) {\n\t\t\tif (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {\n\t\t\t\tthis._component._showFrame(this.frame);\n\t\t\t}\n\t\t}\n\t}\n\n\t_update(dt) {\n\t\tif (this.fps === 0) return;\n\t\tif (!this._playing || this._paused || !this._sprite) return;\n\t\tconst dir = this.fps < 0 ? -1 : 1;\n\t\tconst time = this._time + dt * this._component.speed * dir;\n\t\tconst duration = this.duration;\n\t\tconst end = time > duration || time < 0;\n\n\t\tthis._setTime(time);\n\n\t\tlet frame = this.frame;\n\n\t\tif (this._sprite) {\n\t\t\tframe = Math.floor(this._sprite.frameKeys.length * this._time / duration);\n\t\t} else {\n\t\t\tframe = 0;\n\t\t}\n\n\t\tif (frame !== this._frame) {\n\t\t\tthis._setFrame(frame);\n\t\t}\n\n\t\tif (end) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis.fire('loop');\n\n\t\t\t\tthis._component.fire('loop', this);\n\t\t\t} else {\n\t\t\t\tthis._playing = false;\n\t\t\t\tthis._paused = false;\n\t\t\t\tthis.fire('end');\n\n\t\t\t\tthis._component.fire('end', this);\n\t\t\t}\n\t\t}\n\t}\n\n\t_setTime(value) {\n\t\tthis._time = value;\n\t\tconst duration = this.duration;\n\n\t\tif (this._time < 0) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis._time = this._time % duration + duration;\n\t\t\t} else {\n\t\t\t\tthis._time = 0;\n\t\t\t}\n\t\t} else if (this._time > duration) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis._time %= duration;\n\t\t\t} else {\n\t\t\t\tthis._time = duration;\n\t\t\t}\n\t\t}\n\t}\n\n\t_setFrame(value) {\n\t\tif (this._sprite) {\n\t\t\tthis._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);\n\t\t} else {\n\t\t\tthis._frame = value;\n\t\t}\n\n\t\tif (this._component.currentClip === this) {\n\t\t\tthis._component._showFrame(this._frame);\n\t\t}\n\t}\n\n\t_destroy() {\n\t\tif (this._sprite) {\n\t\t\tthis.sprite = null;\n\t\t}\n\n\t\tif (this._spriteAsset) {\n\t\t\tthis.spriteAsset = null;\n\t\t}\n\t}\n\n\tplay() {\n\t\tif (this._playing) return;\n\t\tthis._playing = true;\n\t\tthis._paused = false;\n\t\tthis.frame = 0;\n\t\tthis.fire('play');\n\n\t\tthis._component.fire('play', this);\n\t}\n\n\tpause() {\n\t\tif (!this._playing || this._paused) return;\n\t\tthis._paused = true;\n\t\tthis.fire('pause');\n\n\t\tthis._component.fire('pause', this);\n\t}\n\n\tresume() {\n\t\tif (!this._paused) return;\n\t\tthis._paused = false;\n\t\tthis.fire('resume');\n\n\t\tthis._component.fire('resume', this);\n\t}\n\n\tstop() {\n\t\tif (!this._playing) return;\n\t\tthis._playing = false;\n\t\tthis._paused = false;\n\t\tthis._time = 0;\n\t\tthis.frame = 0;\n\t\tthis.fire('stop');\n\n\t\tthis._component.fire('stop', this);\n\t}\n\n}\n\nconst PARAM_EMISSIVE_MAP = 'texture_emissiveMap';\nconst PARAM_OPACITY_MAP = 'texture_opacityMap';\nconst PARAM_EMISSIVE = 'material_emissive';\nconst PARAM_OPACITY = 'material_opacity';\nconst PARAM_INNER_OFFSET = 'innerOffset';\nconst PARAM_OUTER_SCALE = 'outerScale';\nconst PARAM_ATLAS_RECT = 'atlasRect';\n\nclass SpriteComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._type = SPRITETYPE_SIMPLE;\n\t\tthis._material = system.defaultMaterial;\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array(3);\n\t\tthis._speed = 1;\n\t\tthis._flipX = false;\n\t\tthis._flipY = false;\n\t\tthis._width = 1;\n\t\tthis._height = 1;\n\t\tthis._drawOrder = 0;\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._outerScale = new Vec2(1, 1);\n\t\tthis._outerScaleUniform = new Float32Array(2);\n\t\tthis._innerOffset = new Vec4();\n\t\tthis._innerOffsetUniform = new Float32Array(4);\n\t\tthis._atlasRect = new Vec4();\n\t\tthis._atlasRectUniform = new Float32Array(4);\n\t\tthis._batchGroupId = -1;\n\t\tthis._batchGroup = null;\n\t\tthis._node = new GraphNode();\n\t\tthis._model = new Model();\n\t\tthis._model.graph = this._node;\n\t\tthis._meshInstance = null;\n\t\tentity.addChild(this._model.graph);\n\t\tthis._model._entity = entity;\n\t\tthis._updateAabbFunc = this._updateAabb.bind(this);\n\t\tthis._addedModel = false;\n\t\tthis._autoPlayClip = null;\n\t\tthis._clips = {};\n\t\tthis._defaultClip = new SpriteAnimationClip(this, {\n\t\t\tname: this.entity.name,\n\t\t\tfps: 0,\n\t\t\tloop: false,\n\t\t\tspriteAsset: null\n\t\t});\n\t\tthis._currentClip = this._defaultClip;\n\t}\n\n\tset type(value) {\n\t\tif (this._type === value) return;\n\t\tthis._type = value;\n\n\t\tif (this._type === SPRITETYPE_SIMPLE) {\n\t\t\tthis.stop();\n\t\t\tthis._currentClip = this._defaultClip;\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis._currentClip.frame = this.frame;\n\n\t\t\t\tif (this._currentClip.sprite) {\n\t\t\t\t\tthis._showModel();\n\t\t\t\t} else {\n\t\t\t\t\tthis._hideModel();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this._type === SPRITETYPE_ANIMATED) {\n\t\t\tthis.stop();\n\n\t\t\tif (this._autoPlayClip) {\n\t\t\t\tthis._tryAutoPlay();\n\t\t\t}\n\n\t\t\tif (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {\n\t\t\t\tthis._showModel();\n\t\t\t} else {\n\t\t\t\tthis._hideModel();\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\n\tset frame(value) {\n\t\tthis._currentClip.frame = value;\n\t}\n\n\tget frame() {\n\t\treturn this._currentClip.frame;\n\t}\n\n\tset spriteAsset(value) {\n\t\tthis._defaultClip.spriteAsset = value;\n\t}\n\n\tget spriteAsset() {\n\t\treturn this._defaultClip._spriteAsset;\n\t}\n\n\tset sprite(value) {\n\t\tthis._currentClip.sprite = value;\n\t}\n\n\tget sprite() {\n\t\treturn this._currentClip.sprite;\n\t}\n\n\tset material(value) {\n\t\tthis._material = value;\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.material = value;\n\t\t}\n\t}\n\n\tget material() {\n\t\treturn this._material;\n\t}\n\n\tset color(value) {\n\t\tthis._color.r = value.r;\n\t\tthis._color.g = value.g;\n\t\tthis._color.b = value.b;\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);\n\t\t}\n\t}\n\n\tget color() {\n\t\treturn this._color;\n\t}\n\n\tset opacity(value) {\n\t\tthis._color.a = value;\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY, value);\n\t\t}\n\t}\n\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\n\tset clips(value) {\n\t\tif (!value) {\n\t\t\tfor (const name in this._clips) {\n\t\t\t\tthis.removeClip(name);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const name in this._clips) {\n\t\t\tlet found = false;\n\n\t\t\tfor (const key in value) {\n\t\t\t\tif (value[key].name === name) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tthis._clips[name].fps = value[key].fps;\n\t\t\t\t\tthis._clips[name].loop = value[key].loop;\n\n\t\t\t\t\tif (value[key].hasOwnProperty('sprite')) {\n\t\t\t\t\t\tthis._clips[name].sprite = value[key].sprite;\n\t\t\t\t\t} else if (value[key].hasOwnProperty('spriteAsset')) {\n\t\t\t\t\t\tthis._clips[name].spriteAsset = value[key].spriteAsset;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tthis.removeClip(name);\n\t\t\t}\n\t\t}\n\n\t\tfor (const key in value) {\n\t\t\tif (this._clips[value[key].name]) continue;\n\t\t\tthis.addClip(value[key]);\n\t\t}\n\n\t\tif (this._autoPlayClip) {\n\t\t\tthis._tryAutoPlay();\n\t\t}\n\n\t\tif (!this._currentClip || !this._currentClip.sprite) {\n\t\t\tthis._hideModel();\n\t\t}\n\t}\n\n\tget clips() {\n\t\treturn this._clips;\n\t}\n\n\tget currentClip() {\n\t\treturn this._currentClip;\n\t}\n\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\n\tset flipX(value) {\n\t\tif (this._flipX === value) return;\n\t\tthis._flipX = value;\n\n\t\tthis._updateTransform();\n\t}\n\n\tget flipX() {\n\t\treturn this._flipX;\n\t}\n\n\tset flipY(value) {\n\t\tif (this._flipY === value) return;\n\t\tthis._flipY = value;\n\n\t\tthis._updateTransform();\n\t}\n\n\tget flipY() {\n\t\treturn this._flipY;\n\t}\n\n\tset width(value) {\n\t\tif (value === this._width) return;\n\t\tthis._width = value;\n\t\tthis._outerScale.x = this._width;\n\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {\n\t\t\tthis._updateTransform();\n\t\t}\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\n\tset height(value) {\n\t\tif (value === this._height) return;\n\t\tthis._height = value;\n\t\tthis._outerScale.y = this.height;\n\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {\n\t\t\tthis._updateTransform();\n\t\t}\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) return;\n\t\tconst prev = this._batchGroupId;\n\t\tthis._batchGroupId = value;\n\n\t\tif (this.entity.enabled && prev >= 0) {\n\t\t\tthis.system.app.batcher.remove(BatchGroup.SPRITE, prev, this.entity);\n\t\t}\n\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tthis.system.app.batcher.insert(BatchGroup.SPRITE, value, this.entity);\n\t\t} else {\n\t\t\tif (prev >= 0) {\n\t\t\t\tif (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {\n\t\t\t\t\tthis._showModel();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\n\tset autoPlayClip(value) {\n\t\tthis._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;\n\n\t\tthis._tryAutoPlay();\n\t}\n\n\tget autoPlayClip() {\n\t\treturn this._autoPlayClip;\n\t}\n\n\tset drawOrder(value) {\n\t\tthis._drawOrder = value;\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.drawOrder = value;\n\t\t}\n\t}\n\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\n\tset layers(value) {\n\t\tif (this._addedModel) {\n\t\t\tthis._hideModel();\n\t\t}\n\n\t\tthis._layers = value;\n\n\t\tif (!this._meshInstance) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis._showModel();\n\t\t}\n\t}\n\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\n\tget aabb() {\n\t\tif (this._meshInstance) {\n\t\t\treturn this._meshInstance.aabb;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.on(\"set:layers\", this._onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.on(\"add\", this._onLayerAdded, this);\n\t\t\tscene.layers.on(\"remove\", this._onLayerRemoved, this);\n\t\t}\n\n\t\tthis._showModel();\n\n\t\tif (this._autoPlayClip) this._tryAutoPlay();\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);\n\t\t}\n\t}\n\n\tonDisable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tscene.off(\"set:layers\", this._onLayersChanged, this);\n\n\t\tif (scene.layers) {\n\t\t\tscene.layers.off(\"add\", this._onLayerAdded, this);\n\t\t\tscene.layers.off(\"remove\", this._onLayerRemoved, this);\n\t\t}\n\n\t\tthis.stop();\n\n\t\tthis._hideModel();\n\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tapp.batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);\n\t\t}\n\t}\n\n\tonDestroy() {\n\t\tthis._currentClip = null;\n\n\t\tif (this._defaultClip) {\n\t\t\tthis._defaultClip._destroy();\n\n\t\t\tthis._defaultClip = null;\n\t\t}\n\n\t\tfor (const key in this._clips) {\n\t\t\tthis._clips[key]._destroy();\n\t\t}\n\n\t\tthis._clips = null;\n\n\t\tthis._hideModel();\n\n\t\tthis._model = null;\n\n\t\tif (this._node) {\n\t\t\tif (this._node.parent) this._node.parent.removeChild(this._node);\n\t\t\tthis._node = null;\n\t\t}\n\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.material = null;\n\t\t\tthis._meshInstance.mesh = null;\n\t\t\tthis._meshInstance = null;\n\t\t}\n\t}\n\n\t_showModel() {\n\t\tif (this._addedModel) return;\n\t\tif (!this._meshInstance) return;\n\t\tconst meshInstances = [this._meshInstance];\n\n\t\tfor (let i = 0, len = this._layers.length; i < len; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(meshInstances);\n\t\t\t}\n\t\t}\n\n\t\tthis._addedModel = true;\n\t}\n\n\t_hideModel() {\n\t\tif (!this._addedModel || !this._meshInstance) return;\n\t\tconst meshInstances = [this._meshInstance];\n\n\t\tfor (let i = 0, len = this._layers.length; i < len; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeMeshInstances(meshInstances);\n\t\t\t}\n\t\t}\n\n\t\tthis._addedModel = false;\n\t}\n\n\t_showFrame(frame) {\n\t\tif (!this.sprite) return;\n\t\tconst mesh = this.sprite.meshes[frame];\n\n\t\tif (!mesh) {\n\t\t\tif (this._meshInstance) {\n\t\t\t\tthis._meshInstance.mesh = null;\n\t\t\t\tthis._meshInstance.visible = false;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tlet material;\n\n\t\tif (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tmaterial = this.system.default9SlicedMaterialSlicedMode;\n\t\t} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tmaterial = this.system.default9SlicedMaterialTiledMode;\n\t\t} else {\n\t\t\tmaterial = this.system.defaultMaterial;\n\t\t}\n\n\t\tif (!this._meshInstance) {\n\t\t\tthis._meshInstance = new MeshInstance(mesh, this._material, this._node);\n\t\t\tthis._meshInstance.castShadow = false;\n\t\t\tthis._meshInstance.receiveShadow = false;\n\t\t\tthis._meshInstance.drawOrder = this._drawOrder;\n\n\t\t\tthis._model.meshInstances.push(this._meshInstance);\n\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);\n\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY, this._color.a);\n\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis._showModel();\n\t\t\t}\n\t\t}\n\n\t\tif (this._meshInstance.material !== material) {\n\t\t\tthis._meshInstance.material = material;\n\t\t}\n\n\t\tif (this._meshInstance.mesh !== mesh) {\n\t\t\tthis._meshInstance.mesh = mesh;\n\t\t\tthis._meshInstance.visible = true;\n\t\t\tthis._meshInstance._aabbVer = -1;\n\t\t}\n\n\t\tif (this.sprite.atlas && this.sprite.atlas.texture) {\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);\n\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);\n\n\t\t\tthis._meshInstance.deleteParameter(PARAM_OPACITY_MAP);\n\t\t}\n\n\t\tif (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tthis._meshInstance._updateAabbFunc = this._updateAabbFunc;\n\t\t\tconst frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];\n\n\t\t\tif (frameData) {\n\t\t\t\tconst borderWidthScale = 2 / frameData.rect.z;\n\t\t\t\tconst borderHeightScale = 2 / frameData.rect.w;\n\n\t\t\t\tthis._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);\n\n\t\t\t\tconst tex = this.sprite.atlas.texture;\n\n\t\t\t\tthis._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);\n\t\t\t} else {\n\t\t\t\tthis._innerOffset.set(0, 0, 0, 0);\n\t\t\t}\n\n\t\t\tthis._innerOffsetUniform[0] = this._innerOffset.x;\n\t\t\tthis._innerOffsetUniform[1] = this._innerOffset.y;\n\t\t\tthis._innerOffsetUniform[2] = this._innerOffset.z;\n\t\t\tthis._innerOffsetUniform[3] = this._innerOffset.w;\n\n\t\t\tthis._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);\n\n\t\t\tthis._atlasRectUniform[0] = this._atlasRect.x;\n\t\t\tthis._atlasRectUniform[1] = this._atlasRect.y;\n\t\t\tthis._atlasRectUniform[2] = this._atlasRect.z;\n\t\t\tthis._atlasRectUniform[3] = this._atlasRect.w;\n\n\t\t\tthis._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);\n\t\t} else {\n\t\t\tthis._meshInstance._updateAabbFunc = null;\n\t\t}\n\n\t\tthis._updateTransform();\n\t}\n\n\t_updateTransform() {\n\t\tlet scaleX = this.flipX ? -1 : 1;\n\t\tlet scaleY = this.flipY ? -1 : 1;\n\t\tlet posX = 0;\n\t\tlet posY = 0;\n\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tlet w = 1;\n\t\t\tlet h = 1;\n\n\t\t\tif (this.sprite.atlas) {\n\t\t\t\tconst frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];\n\n\t\t\t\tif (frameData) {\n\t\t\t\t\tw = frameData.rect.z;\n\t\t\t\t\th = frameData.rect.w;\n\t\t\t\t\tposX = (0.5 - frameData.pivot.x) * this._width;\n\t\t\t\t\tposY = (0.5 - frameData.pivot.y) * this._height;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst scaleMulX = w / this.sprite.pixelsPerUnit;\n\t\t\tconst scaleMulY = h / this.sprite.pixelsPerUnit;\n\n\t\t\tthis._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));\n\n\t\t\tscaleX *= scaleMulX;\n\t\t\tscaleY *= scaleMulY;\n\t\t\tthis._outerScale.x /= scaleMulX;\n\t\t\tthis._outerScale.y /= scaleMulY;\n\t\t\tscaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);\n\t\t\tscaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);\n\n\t\t\tif (this._meshInstance) {\n\t\t\t\tthis._outerScaleUniform[0] = this._outerScale.x;\n\t\t\t\tthis._outerScaleUniform[1] = this._outerScale.y;\n\n\t\t\t\tthis._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);\n\t\t\t}\n\t\t}\n\n\t\tthis._node.setLocalScale(scaleX, scaleY, 1);\n\n\t\tthis._node.setLocalPosition(posX, posY, 0);\n\t}\n\n\t_updateAabb(aabb) {\n\t\taabb.center.set(0, 0, 0);\n\t\taabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);\n\t\taabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());\n\t\treturn aabb;\n\t}\n\n\t_tryAutoPlay() {\n\t\tif (!this._autoPlayClip) return;\n\t\tif (this.type !== SPRITETYPE_ANIMATED) return;\n\t\tconst clip = this._clips[this._autoPlayClip];\n\n\t\tif (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.play(clip.name);\n\t\t\t}\n\t\t}\n\t}\n\n\t_onLayersChanged(oldComp, newComp) {\n\t\toldComp.off(\"add\", this.onLayerAdded, this);\n\t\toldComp.off(\"remove\", this.onLayerRemoved, this);\n\t\tnewComp.on(\"add\", this.onLayerAdded, this);\n\t\tnewComp.on(\"remove\", this.onLayerRemoved, this);\n\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis._showModel();\n\t\t}\n\t}\n\n\t_onLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\n\t\tif (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {\n\t\t\tlayer.addMeshInstances([this._meshInstance]);\n\t\t}\n\t}\n\n\t_onLayerRemoved(layer) {\n\t\tif (!this._meshInstance) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances([this._meshInstance]);\n\t}\n\n\tremoveModelFromLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this._meshInstance]);\n\t\t}\n\t}\n\n\taddClip(data) {\n\t\tconst clip = new SpriteAnimationClip(this, {\n\t\t\tname: data.name,\n\t\t\tfps: data.fps,\n\t\t\tloop: data.loop,\n\t\t\tspriteAsset: data.spriteAsset\n\t\t});\n\t\tthis._clips[data.name] = clip;\n\t\tif (clip.name && clip.name === this._autoPlayClip) this._tryAutoPlay();\n\t\treturn clip;\n\t}\n\n\tremoveClip(name) {\n\t\tdelete this._clips[name];\n\t}\n\n\tclip(name) {\n\t\treturn this._clips[name];\n\t}\n\n\tplay(name) {\n\t\tconst clip = this._clips[name];\n\t\tconst current = this._currentClip;\n\n\t\tif (current && current !== clip) {\n\t\t\tcurrent._playing = false;\n\t\t}\n\n\t\tthis._currentClip = clip;\n\n\t\tif (this._currentClip) {\n\t\t\tthis._currentClip = clip;\n\n\t\t\tthis._currentClip.play();\n\t\t}\n\n\t\treturn clip;\n\t}\n\n\tpause() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\n\t\tif (this._currentClip.isPlaying) {\n\t\t\tthis._currentClip.pause();\n\t\t}\n\t}\n\n\tresume() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\n\t\tif (this._currentClip.isPaused) {\n\t\t\tthis._currentClip.resume();\n\t\t}\n\t}\n\n\tstop() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\n\t\tthis._currentClip.stop();\n\t}\n\n}\n\nclass SpriteComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema$1 = ['enabled'];\n\nclass SpriteComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'sprite';\n\t\tthis.ComponentType = SpriteComponent;\n\t\tthis.DataType = SpriteComponentData;\n\t\tthis.schema = _schema$1;\n\t\tthis._defaultTexture = null;\n\t\tthis._defaultMaterial = null;\n\t\tthis._default9SlicedMaterialSlicedMode = null;\n\t\tthis._default9SlicedMaterialTiledMode = null;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t}\n\n\tset defaultMaterial(material) {\n\t\tthis._defaultMaterial = material;\n\t}\n\n\tget defaultMaterial() {\n\t\tif (!this._defaultMaterial) {\n\t\t\tconst texture = new Texture(this.app.graphicsDevice, {\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8\n\t\t\t});\n\t\t\tconst pixels = new Uint8Array(texture.lock());\n\t\t\tpixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;\n\t\t\ttexture.name = 'sprite';\n\t\t\ttexture.unlock();\n\t\t\tconst material = new StandardMaterial();\n\t\t\tmaterial.diffuse.set(0, 0, 0);\n\t\t\tmaterial.emissive.set(0.5, 0.5, 0.5);\n\t\t\tmaterial.emissiveMap = texture;\n\t\t\tmaterial.emissiveMapTint = true;\n\t\t\tmaterial.opacityMap = texture;\n\t\t\tmaterial.opacityMapChannel = \"a\";\n\t\t\tmaterial.opacityTint = true;\n\t\t\tmaterial.opacity = 0;\n\t\t\tmaterial.useLighting = false;\n\t\t\tmaterial.useGammaTonemap = false;\n\t\t\tmaterial.useFog = false;\n\t\t\tmaterial.useSkybox = false;\n\t\t\tmaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\tmaterial.depthWrite = false;\n\t\t\tmaterial.pixelSnap = false;\n\t\t\tmaterial.cull = CULLFACE_NONE;\n\t\t\tmaterial.update();\n\t\t\tthis._defaultTexture = texture;\n\t\t\tthis._defaultMaterial = material;\n\t\t}\n\n\t\treturn this._defaultMaterial;\n\t}\n\n\tset default9SlicedMaterialSlicedMode(material) {\n\t\tthis._default9SlicedMaterialSlicedMode = material;\n\t}\n\n\tget default9SlicedMaterialSlicedMode() {\n\t\tif (!this._default9SlicedMaterialSlicedMode) {\n\t\t\tconst material = this.defaultMaterial.clone();\n\t\t\tmaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\tmaterial.update();\n\t\t\tthis._default9SlicedMaterialSlicedMode = material;\n\t\t}\n\n\t\treturn this._default9SlicedMaterialSlicedMode;\n\t}\n\n\tset default9SlicedMaterialTiledMode(material) {\n\t\tthis._default9SlicedMaterialTiledMode = material;\n\t}\n\n\tget default9SlicedMaterialTiledMode() {\n\t\tif (!this._default9SlicedMaterialTiledMode) {\n\t\t\tconst material = this.defaultMaterial.clone();\n\t\t\tmaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\tmaterial.update();\n\t\t\tthis._default9SlicedMaterialTiledMode = material;\n\t\t}\n\n\t\treturn this._default9SlicedMaterialTiledMode;\n\t}\n\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\n\t\tif (this._defaultTexture) {\n\t\t\tthis._defaultTexture.destroy();\n\n\t\t\tthis._defaultTexture = null;\n\t\t}\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) {\n\t\t\tcomponent.enabled = data.enabled;\n\t\t}\n\n\t\tcomponent.type = data.type;\n\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tcomponent.layers = data.layers.slice(0);\n\t\t}\n\n\t\tif (data.drawOrder !== undefined) {\n\t\t\tcomponent.drawOrder = data.drawOrder;\n\t\t}\n\n\t\tif (data.color !== undefined) {\n\t\t\tif (data.color instanceof Color) {\n\t\t\t\tcomponent.color.set(data.color.r, data.color.g, data.color.b, data.opacity !== undefined ? data.opacity : 1);\n\t\t\t} else {\n\t\t\t\tcomponent.color.set(data.color[0], data.color[1], data.color[2], data.opacity !== undefined ? data.opacity : 1);\n\t\t\t}\n\n\t\t\tcomponent.color = component.color;\n\t\t}\n\n\t\tif (data.opacity !== undefined) {\n\t\t\tcomponent.opacity = data.opacity;\n\t\t}\n\n\t\tif (data.flipX !== undefined) {\n\t\t\tcomponent.flipX = data.flipX;\n\t\t}\n\n\t\tif (data.flipY !== undefined) {\n\t\t\tcomponent.flipY = data.flipY;\n\t\t}\n\n\t\tif (data.width !== undefined) {\n\t\t\tcomponent.width = data.width;\n\t\t}\n\n\t\tif (data.height !== undefined) {\n\t\t\tcomponent.height = data.height;\n\t\t}\n\n\t\tif (data.spriteAsset !== undefined) {\n\t\t\tcomponent.spriteAsset = data.spriteAsset;\n\t\t}\n\n\t\tif (data.sprite) {\n\t\t\tcomponent.sprite = data.sprite;\n\t\t}\n\n\t\tif (data.frame !== undefined) {\n\t\t\tcomponent.frame = data.frame;\n\t\t}\n\n\t\tif (data.clips) {\n\t\t\tfor (const name in data.clips) {\n\t\t\t\tcomponent.addClip(data.clips[name]);\n\t\t\t}\n\t\t}\n\n\t\tif (data.speed !== undefined) {\n\t\t\tcomponent.speed = data.speed;\n\t\t}\n\n\t\tif (data.autoPlayClip) {\n\t\t\tcomponent.autoPlayClip = data.autoPlayClip;\n\t\t}\n\n\t\tcomponent.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.sprite;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: source.enabled,\n\t\t\ttype: source.type,\n\t\t\tspriteAsset: source.spriteAsset,\n\t\t\tsprite: source.sprite,\n\t\t\tframe: source.frame,\n\t\t\tcolor: source.color.clone(),\n\t\t\topacity: source.opacity,\n\t\t\tflipX: source.flipX,\n\t\t\tflipY: source.flipY,\n\t\t\tspeed: source.speed,\n\t\t\tclips: source.clips,\n\t\t\tautoPlayClip: source.autoPlayClip,\n\t\t\tbatchGroupId: source.batchGroupId,\n\t\t\tdrawOrder: source.drawOrder,\n\t\t\tlayers: source.layers.slice(0)\n\t\t});\n\t}\n\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\n\t\t\t\tif (component.data.enabled && component.entity.enabled) {\n\t\t\t\t\tconst sprite = component.entity.sprite;\n\n\t\t\t\t\tif (sprite._currentClip) {\n\t\t\t\t\t\tsprite._currentClip._update(dt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onDestroy();\n\t}\n\n}\n\nComponent._buildAccessors(SpriteComponent.prototype, _schema$1);\n\nclass ZoneComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._oldState = true;\n\t\tthis._size = new Vec3();\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\n\tset size(data) {\n\t\tif (data instanceof Vec3) {\n\t\t\tthis._size.copy(data);\n\t\t} else if (data instanceof Array && data.length >= 3) {\n\t\t\tthis.size.set(data[0], data[1], data[2]);\n\t\t}\n\t}\n\n\tget size() {\n\t\treturn this._size;\n\t}\n\n\tonEnable() {\n\t\tthis._checkState();\n\t}\n\n\tonDisable() {\n\t\tthis._checkState();\n\t}\n\n\t_onSetEnabled(prop, old, value) {\n\t\tthis._checkState();\n\t}\n\n\t_checkState() {\n\t\tconst state = this.enabled && this.entity.enabled;\n\t\tif (state === this._oldState) return;\n\t\tthis._oldState = state;\n\t\tthis.fire('enable');\n\t\tthis.fire('state', this.enabled);\n\t}\n\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\t}\n\n}\n\nclass ZoneComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n\n}\n\nconst _schema = ['enabled'];\n\nclass ZoneComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'zone';\n\t\tthis.ComponentType = ZoneComponent;\n\t\tthis.DataType = ZoneComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this._onBeforeRemove, this);\n\t}\n\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;\n\n\t\tif (data.size) {\n\t\t\tif (data.size instanceof Vec3) {\n\t\t\t\tcomponent.size.copy(data.size);\n\t\t\t} else if (data.size instanceof Array && data.size.length >= 3) {\n\t\t\t\tcomponent.size.set(data.size[0], data.size[1], data.size[2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcloneComponent(entity, clone) {\n\t\tconst data = {\n\t\t\tsize: entity.zone.size\n\t\t};\n\t\treturn this.addComponent(clone, data);\n\t}\n\n\t_onBeforeRemove(entity, component) {\n\t\tcomponent._onBeforeRemove();\n\t}\n\n}\n\nComponent._buildAccessors(ZoneComponent.prototype, _schema);\n\nclass ApplicationStats {\n\tconstructor(device) {\n\t\tthis.frame = {\n\t\t\tfps: 0,\n\t\t\tms: 0,\n\t\t\tdt: 0,\n\t\t\tupdateStart: 0,\n\t\t\tupdateTime: 0,\n\t\t\trenderStart: 0,\n\t\t\trenderTime: 0,\n\t\t\tphysicsStart: 0,\n\t\t\tphysicsTime: 0,\n\t\t\tcullTime: 0,\n\t\t\tsortTime: 0,\n\t\t\tskinTime: 0,\n\t\t\tmorphTime: 0,\n\t\t\tinstancingTime: 0,\n\t\t\ttriangles: 0,\n\t\t\totherPrimitives: 0,\n\t\t\tshaders: 0,\n\t\t\tmaterials: 0,\n\t\t\tcameras: 0,\n\t\t\tshadowMapUpdates: 0,\n\t\t\tshadowMapTime: 0,\n\t\t\tdepthMapTime: 0,\n\t\t\tforwardTime: 0,\n\t\t\tlightClustersTime: 0,\n\t\t\tlightClusters: 0,\n\t\t\t_timeToCountFrames: 0,\n\t\t\t_fpsAccum: 0\n\t\t};\n\t\tthis.drawCalls = {\n\t\t\tforward: 0,\n\t\t\tdepth: 0,\n\t\t\tshadow: 0,\n\t\t\timmediate: 0,\n\t\t\tmisc: 0,\n\t\t\ttotal: 0,\n\t\t\tskinned: 0,\n\t\t\tinstanced: 0,\n\t\t\tremovedByInstancing: 0\n\t\t};\n\t\tthis.misc = {\n\t\t\trenderTargetCreationTime: 0\n\t\t};\n\t\tthis.particles = {\n\t\t\tupdatesPerFrame: 0,\n\t\t\t_updatesPerFrame: 0,\n\t\t\tframeTime: 0,\n\t\t\t_frameTime: 0\n\t\t};\n\t\tthis.shaders = device._shaderStats;\n\t\tthis.vram = device._vram;\n\t\tObject.defineProperty(this.vram, 'totalUsed', {\n\t\t\tget: function () {\n\t\t\t\treturn this.tex + this.vb + this.ib;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.vram, 'geom', {\n\t\t\tget: function () {\n\t\t\t\treturn this.vb + this.ib;\n\t\t\t}\n\t\t});\n\t}\n\n\tget scene() {\n\t\treturn getApplication().scene._stats;\n\t}\n\n\tget lightmapper() {\n\t\treturn getApplication().lightmapper.stats;\n\t}\n\n\tget batcher() {\n\t\treturn getApplication().batcher._stats;\n\t}\n\n}\n\nclass SceneRegistryItem {\n\tconstructor(name, url) {\n\t\tthis.name = name;\n\t\tthis.url = url;\n\t\tthis.data = null;\n\t\tthis._loading = false;\n\t\tthis._onLoadedCallbacks = [];\n\t}\n\n\tget loaded() {\n\t\treturn !!this.data;\n\t}\n\n\tget loading() {\n\t\treturn this._loading;\n\t}\n\n}\n\nclass SceneRegistry {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis._list = [];\n\t\tthis._index = {};\n\t\tthis._urlIndex = {};\n\t}\n\n\tdestroy() {\n\t\tthis._app = null;\n\t}\n\n\tlist() {\n\t\treturn this._list;\n\t}\n\n\tadd(name, url) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst item = new SceneRegistryItem(name, url);\n\n\t\tconst i = this._list.push(item);\n\n\t\tthis._index[item.name] = i - 1;\n\t\tthis._urlIndex[item.url] = i - 1;\n\t\treturn true;\n\t}\n\n\tfind(name) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\treturn this._list[this._index[name]];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfindByUrl(url) {\n\t\tif (this._urlIndex.hasOwnProperty(url)) {\n\t\t\treturn this._list[this._urlIndex[url]];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tremove(name) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\tconst idx = this._index[name];\n\t\t\tlet item = this._list[idx];\n\t\t\tdelete this._urlIndex[item.url];\n\t\t\tdelete this._index[name];\n\n\t\t\tthis._list.splice(idx, 1);\n\n\t\t\tfor (let i = 0; i < this._list.length; i++) {\n\t\t\t\titem = this._list[i];\n\t\t\t\tthis._index[item.name] = i;\n\t\t\t\tthis._urlIndex[item.url] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t_loadSceneData(sceneItem, storeInCache, callback) {\n\t\tlet url = sceneItem;\n\n\t\tif (sceneItem instanceof SceneRegistryItem) {\n\t\t\turl = sceneItem.url;\n\t\t} else {\n\t\t\tsceneItem = this.findByUrl(url);\n\n\t\t\tif (!sceneItem) {\n\t\t\t\tsceneItem = new SceneRegistryItem('Untitled', url);\n\t\t\t}\n\t\t}\n\n\t\tif (!sceneItem.url) {\n\t\t\tcallback(\"URL or SceneRegistryItem is null when loading a scene\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (sceneItem.loaded) {\n\t\t\tcallback(null, sceneItem);\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this._app.loader.getHandler(\"hierarchy\");\n\n\t\tif (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {\n\t\t\turl = path.join(this._app.assets.prefix, url);\n\t\t}\n\n\t\tsceneItem._onLoadedCallbacks.push(callback);\n\n\t\tif (!sceneItem._loading) {\n\t\t\thandler.load(url, function (err, data) {\n\t\t\t\tsceneItem.data = data;\n\t\t\t\tsceneItem._loading = false;\n\n\t\t\t\tfor (let i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {\n\t\t\t\t\tsceneItem._onLoadedCallbacks[i](err, sceneItem);\n\t\t\t\t}\n\n\t\t\t\tif (!storeInCache) {\n\t\t\t\t\tsceneItem.data = null;\n\t\t\t\t}\n\n\t\t\t\tsceneItem._onLoadedCallbacks.length = 0;\n\t\t\t});\n\t\t}\n\n\t\tsceneItem._loading = true;\n\t}\n\n\tloadSceneData(sceneItem, callback) {\n\t\tthis._loadSceneData(sceneItem, true, callback);\n\t}\n\n\tunloadSceneData(sceneItem) {\n\t\tif (typeof sceneItem === 'string') {\n\t\t\tsceneItem = this.findByUrl(sceneItem);\n\t\t}\n\n\t\tif (sceneItem) {\n\t\t\tsceneItem.data = null;\n\t\t}\n\t}\n\n\tloadSceneHierarchy(sceneItem, callback) {\n\t\tconst self = this;\n\n\t\tconst handler = this._app.loader.getHandler(\"hierarchy\");\n\n\t\tthis._loadSceneData(sceneItem, false, function (err, sceneItem) {\n\t\t\tif (err) {\n\t\t\t\tif (callback) callback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst url = sceneItem.url;\n\t\t\tconst data = sceneItem.data;\n\n\t\t\tconst _loaded = function _loaded() {\n\t\t\t\tself._app.systems.script.preloading = true;\n\t\t\t\tconst entity = handler.open(url, data);\n\t\t\t\tself._app.systems.script.preloading = false;\n\n\t\t\t\tself._app.loader.clearCache(url, \"hierarchy\");\n\n\t\t\t\tself._app.root.addChild(entity);\n\n\t\t\t\tself._app.systems.fire('initialize', entity);\n\n\t\t\t\tself._app.systems.fire('postInitialize', entity);\n\n\t\t\t\tself._app.systems.fire('postPostInitialize', entity);\n\n\t\t\t\tif (callback) callback(err, entity);\n\t\t\t};\n\n\t\t\tself._app._preloadScripts(data, _loaded);\n\t\t});\n\t}\n\n\tloadSceneSettings(sceneItem, callback) {\n\t\tconst self = this;\n\n\t\tthis._loadSceneData(sceneItem, false, function (err, sceneItem) {\n\t\t\tif (!err) {\n\t\t\t\tself._app.applySceneSettings(sceneItem.data.settings);\n\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tloadScene(url, callback) {\n\t\tconst self = this;\n\n\t\tconst handler = this._app.loader.getHandler(\"scene\");\n\n\t\tif (this._app.assets && this._app.assets.prefix && !ABSOLUTE_URL.test(url)) {\n\t\t\turl = path.join(this._app.assets.prefix, url);\n\t\t}\n\n\t\thandler.load(url, function (err, data) {\n\t\t\tif (!err) {\n\t\t\t\tconst _loaded = function _loaded() {\n\t\t\t\t\tself._app.systems.script.preloading = true;\n\t\t\t\t\tconst scene = handler.open(url, data);\n\t\t\t\t\tconst sceneItem = self.findByUrl(url);\n\n\t\t\t\t\tif (sceneItem && !sceneItem.loaded) {\n\t\t\t\t\t\tsceneItem.data = data;\n\t\t\t\t\t}\n\n\t\t\t\t\tself._app.systems.script.preloading = false;\n\n\t\t\t\t\tself._app.loader.clearCache(url, \"scene\");\n\n\t\t\t\t\tself._app.loader.patch({\n\t\t\t\t\t\tresource: scene,\n\t\t\t\t\t\ttype: \"scene\"\n\t\t\t\t\t}, self._app.assets);\n\n\t\t\t\t\tself._app.root.addChild(scene.root);\n\n\t\t\t\t\tif (self._app.systems.rigidbody && typeof Ammo !== 'undefined') {\n\t\t\t\t\t\tself._app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback(null, scene);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tself._app._preloadScripts(data, _loaded);\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n}\n\nclass SceneDepth {\n\tconstructor(application) {\n\t\tthis.application = application;\n\t\tthis.device = application.graphicsDevice;\n\t\tthis.clearOptions = null;\n\t\tthis.layer = null;\n\t\tthis.init();\n\t}\n\n\tallocateTexture(device, name, format) {\n\t\tconst texture = new Texture(device, {\n\t\t\tformat: format,\n\t\t\twidth: device.width,\n\t\t\theight: device.height,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\ttexture.name = name;\n\t\tdevice.scope.resolve(\"uDepthMap\").setValue(texture);\n\t\treturn texture;\n\t}\n\n\tallocateRenderTarget(renderTarget, device, name, format, isDepth) {\n\t\tconst buffer = this.allocateTexture(device, name, format);\n\n\t\tif (renderTarget) {\n\t\t\trenderTarget.destroyFrameBuffers();\n\n\t\t\tif (isDepth) {\n\t\t\t\trenderTarget._depthBuffer = buffer;\n\t\t\t} else {\n\t\t\t\trenderTarget._colorBuffer = buffer;\n\t\t\t}\n\t\t} else {\n\t\t\trenderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: isDepth ? null : buffer,\n\t\t\t\tdepthBuffer: isDepth ? buffer : null,\n\t\t\t\tdepth: !isDepth,\n\t\t\t\tstencil: device.supportsStencil,\n\t\t\t\tautoResolve: false\n\t\t\t});\n\t\t}\n\n\t\treturn renderTarget;\n\t}\n\n\treleaseRenderTarget(rt) {\n\t\tif (rt) {\n\t\t\trt.destroyTextureBuffers();\n\t\t\trt.destroy();\n\t\t}\n\t}\n\n\tinitWebGl2() {\n\t\tconst app = this.application;\n\t\tconst self = this;\n\t\tthis.clearOptions = {\n\t\t\tflags: 0\n\t\t};\n\t\tthis.layer = new Layer({\n\t\t\tenabled: false,\n\t\t\tname: \"Depth\",\n\t\t\tid: LAYERID_DEPTH,\n\t\t\tonEnable: function () {\n\t\t\t\tself.releaseRenderTarget(this.renderTarget);\n\t\t\t\tthis.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, \"rt-depth2\", PIXELFORMAT_DEPTHSTENCIL, true);\n\t\t\t},\n\t\t\tonDisable: function () {\n\t\t\t\tself.releaseRenderTarget(this.renderTarget);\n\t\t\t\tthis.renderTarget = null;\n\t\t\t},\n\t\t\tonPreRenderOpaque: function (cameraPass) {\n\t\t\t\tconst gl = app.graphicsDevice.gl;\n\t\t\t\tthis.srcFbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n\n\t\t\t\tif (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {\n\t\t\t\t\tthis.onEnable();\n\t\t\t\t}\n\n\t\t\t\tthis.oldClear = this.cameras[cameraPass].camera._clearOptions;\n\t\t\t\tthis.cameras[cameraPass].camera._clearOptions = self.clearOptions;\n\t\t\t},\n\t\t\tonPostRenderOpaque: function (cameraPass) {\n\t\t\t\tif (this.renderTarget) {\n\t\t\t\t\tthis.cameras[cameraPass].camera._clearOptions = this.oldClear;\n\t\t\t\t\tapp.graphicsDevice.setRenderTarget(this.renderTarget);\n\t\t\t\t\tapp.graphicsDevice.updateBegin();\n\t\t\t\t\tconst gl = app.graphicsDevice.gl;\n\t\t\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.srcFbo);\n\t\t\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.renderTarget._glFrameBuffer);\n\t\t\t\t\tgl.blitFramebuffer(0, 0, this.renderTarget.width, this.renderTarget.height, 0, 0, this.renderTarget.width, this.renderTarget.height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tinitWebGl1() {\n\t\tconst app = this.application;\n\t\tconst self = this;\n\t\tthis.clearOptions = {\n\t\t\tcolor: [254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255],\n\t\t\tdepth: 1.0,\n\t\t\tflags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH\n\t\t};\n\t\tthis.layer = new Layer({\n\t\t\tenabled: false,\n\t\t\tname: \"Depth\",\n\t\t\tid: LAYERID_DEPTH,\n\t\t\tshaderPass: SHADER_DEPTH,\n\t\t\tonEnable: function () {\n\t\t\t\tself.releaseRenderTarget(this.renderTarget);\n\t\t\t\tthis.renderTarget = self.allocateRenderTarget(this.renderTarget, app.graphicsDevice, \"rt-depth1\", PIXELFORMAT_R8_G8_B8_A8, false);\n\t\t\t},\n\t\t\tonDisable: function () {\n\t\t\t\tself.releaseRenderTarget(this.renderTarget);\n\t\t\t\tthis.renderTarget = null;\n\t\t\t},\n\t\t\tonPostCull: function (cameraPass) {\n\t\t\t\tconst visibleObjects = this.instances.visibleOpaque[cameraPass];\n\t\t\t\tconst visibleList = visibleObjects.list;\n\t\t\t\tconst layerComposition = app.scene.layers;\n\t\t\t\tconst subLayerEnabled = layerComposition.subLayerEnabled;\n\t\t\t\tconst isTransparent = layerComposition.subLayerList;\n\t\t\t\tconst rt = app.scene.layers.getLayerById(LAYERID_WORLD).renderTarget;\n\t\t\t\tconst cam = this.cameras[cameraPass];\n\t\t\t\tlet visibleLength = 0;\n\t\t\t\tconst layers = layerComposition.layerList;\n\n\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\tconst layer = layers[i];\n\t\t\t\t\tif (layer === this) break;\n\t\t\t\t\tif (layer.renderTarget !== rt || !layer.enabled || !subLayerEnabled[i]) continue;\n\t\t\t\t\tconst layerCamId = layer.cameras.indexOf(cam);\n\t\t\t\t\tif (layerCamId < 0) continue;\n\t\t\t\t\tconst transparent = isTransparent[i];\n\t\t\t\t\tlet layerVisibleList = transparent ? layer.instances.visibleTransparent[layerCamId] : layer.instances.visibleOpaque[layerCamId];\n\t\t\t\t\tconst layerVisibleListLength = layerVisibleList.length;\n\t\t\t\t\tlayerVisibleList = layerVisibleList.list;\n\n\t\t\t\t\tfor (let j = 0; j < layerVisibleListLength; j++) {\n\t\t\t\t\t\tconst drawCall = layerVisibleList[j];\n\n\t\t\t\t\t\tif (drawCall.material && drawCall.material.depthWrite && !drawCall._noDepthDrawGl1) {\n\t\t\t\t\t\t\tvisibleList[visibleLength] = drawCall;\n\t\t\t\t\t\t\tvisibleLength++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvisibleObjects.length = visibleLength;\n\t\t\t},\n\t\t\tonPreRenderOpaque: function (cameraPass) {\n\t\t\t\tif (this.renderTarget.width !== app.graphicsDevice.width || this.renderTarget.height !== app.graphicsDevice.height) {\n\t\t\t\t\tthis.onEnable();\n\t\t\t\t}\n\n\t\t\t\tthis.oldClear = this.cameras[cameraPass].camera._clearOptions;\n\t\t\t\tthis.cameras[cameraPass].camera._clearOptions = self.clearOptions;\n\t\t\t},\n\t\t\tonDrawCall: function () {\n\t\t\t\tapp.graphicsDevice.setColorWrite(true, true, true, true);\n\t\t\t},\n\t\t\tonPostRenderOpaque: function (cameraPass) {\n\t\t\t\tif (!this.renderTarget) return;\n\t\t\t\tthis.cameras[cameraPass].camera._clearOptions = this.oldClear;\n\t\t\t}\n\t\t});\n\t}\n\n\tinit() {\n\t\tif (this.device.webgl2) {\n\t\t\tthis.initWebGl2();\n\t\t} else {\n\t\t\tthis.initWebGl1();\n\t\t}\n\t}\n\n\tpatch(layer) {\n\t\tlayer.onEnable = this.layer.onEnable;\n\t\tlayer.onDisable = this.layer.onDisable;\n\t\tlayer.onPreRenderOpaque = this.layer.onPreRenderOpaque;\n\t\tlayer.onPostRenderOpaque = this.layer.onPostRenderOpaque;\n\t\tlayer.shaderPass = this.layer.shaderPass;\n\t\tlayer.onPostCull = this.layer.onPostCull;\n\t\tlayer.onDrawCall = this.layer.onDrawCall;\n\t}\n\n}\n\nclass Progress {\n\tconstructor(length) {\n\t\tthis.length = length;\n\t\tthis.count = 0;\n\t}\n\n\tinc() {\n\t\tthis.count++;\n\t}\n\n\tdone() {\n\t\treturn this.count === this.length;\n\t}\n\n}\n\nlet app = null;\n\nclass Application extends EventHandler {\n\tconstructor(canvas, options = {}) {\n\t\tsuper();\n\t\tApplication._applications[canvas.id] = this;\n\t\tsetApplication(this);\n\t\tapp = this;\n\t\tthis._destroyRequested = false;\n\t\tthis._inFrameUpdate = false;\n\t\tthis._time = 0;\n\t\tthis.timeScale = 1;\n\t\tthis.maxDeltaTime = 0.1;\n\t\tthis.frame = 0;\n\t\tthis.autoRender = true;\n\t\tthis.renderNextFrame = false;\n\t\tthis.useLegacyScriptAttributeCloning = script.legacy;\n\t\tthis._librariesLoaded = false;\n\t\tthis._fillMode = FILLMODE_KEEP_ASPECT;\n\t\tthis._resolutionMode = RESOLUTION_FIXED;\n\t\tthis._allowResize = true;\n\t\tthis.context = this;\n\t\tif (!options.graphicsDeviceOptions) options.graphicsDeviceOptions = {};\n\n\t\tif (platform.browser && !!navigator.xr) {\n\t\t\toptions.graphicsDeviceOptions.xrCompatible = true;\n\t\t}\n\n\t\toptions.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;\n\t\tthis.graphicsDevice = new GraphicsDevice(canvas, options.graphicsDeviceOptions);\n\n\t\tthis._initDefaultMaterial();\n\n\t\tthis.stats = new ApplicationStats(this.graphicsDevice);\n\t\tthis._soundManager = new SoundManager(options);\n\t\tthis.loader = new ResourceLoader(this);\n\t\tLightsBuffer.init(this.graphicsDevice);\n\t\tthis._entityIndex = {};\n\t\tthis.scene = new Scene(this.graphicsDevice);\n\n\t\tthis._registerSceneImmediate(this.scene);\n\n\t\tthis.root = new Entity();\n\t\tthis.root._enabledInHierarchy = true;\n\t\tthis._enableList = [];\n\t\tthis._enableList.size = 0;\n\t\tthis.assets = new AssetRegistry(this.loader);\n\t\tif (options.assetPrefix) this.assets.prefix = options.assetPrefix;\n\t\tthis.bundles = new BundleRegistry(this.assets);\n\t\tthis.enableBundles = typeof TextDecoder !== 'undefined';\n\t\tthis.scriptsOrder = options.scriptsOrder || [];\n\t\tthis.scripts = new ScriptRegistry(this);\n\t\tthis.i18n = new I18n(this);\n\t\tthis.scenes = new SceneRegistry(this);\n\t\tconst self = this;\n\t\tthis.defaultLayerWorld = new Layer({\n\t\t\tname: \"World\",\n\t\t\tid: LAYERID_WORLD\n\t\t});\n\t\tthis.sceneDepth = new SceneDepth(this);\n\t\tthis.defaultLayerDepth = this.sceneDepth.layer;\n\t\tthis.defaultLayerSkybox = new Layer({\n\t\t\tenabled: true,\n\t\t\tname: \"Skybox\",\n\t\t\tid: LAYERID_SKYBOX,\n\t\t\topaqueSortMode: SORTMODE_NONE\n\t\t});\n\t\tthis.defaultLayerUi = new Layer({\n\t\t\tenabled: true,\n\t\t\tname: \"UI\",\n\t\t\tid: LAYERID_UI,\n\t\t\ttransparentSortMode: SORTMODE_MANUAL,\n\t\t\tpassThrough: false\n\t\t});\n\t\tthis.defaultLayerImmediate = new Layer({\n\t\t\tenabled: true,\n\t\t\tname: \"Immediate\",\n\t\t\tid: LAYERID_IMMEDIATE,\n\t\t\topaqueSortMode: SORTMODE_NONE,\n\t\t\tpassThrough: true\n\t\t});\n\t\tconst defaultLayerComposition = new LayerComposition(\"default\");\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerWorld);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerDepth);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerSkybox);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerWorld);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerImmediate);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerImmediate);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerUi);\n\t\tthis.scene.layers = defaultLayerComposition;\n\t\tthis._immediateLayer = this.defaultLayerImmediate;\n\t\tthis.scene.on('set:layers', function (oldComp, newComp) {\n\t\t\tconst list = newComp.layerList;\n\t\t\tlet layer;\n\n\t\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\t\tlayer = list[i];\n\n\t\t\t\tswitch (layer.id) {\n\t\t\t\t\tcase LAYERID_DEPTH:\n\t\t\t\t\t\tself.sceneDepth.patch(layer);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LAYERID_UI:\n\t\t\t\t\t\tlayer.passThrough = self.defaultLayerUi.passThrough;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LAYERID_IMMEDIATE:\n\t\t\t\t\t\tlayer.passThrough = self.defaultLayerImmediate.passThrough;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tAreaLightLuts.createPlaceholder(this.graphicsDevice);\n\t\tthis.renderer = new ForwardRenderer(this.graphicsDevice);\n\t\tthis.renderer.scene = this.scene;\n\t\tthis.lightmapper = new Lightmapper(this.graphicsDevice, this.root, this.scene, this.renderer, this.assets);\n\t\tthis.once('prerender', this._firstBake, this);\n\t\tthis.batcher = new BatchManager(this.graphicsDevice, this.root, this.scene);\n\t\tthis.once('prerender', this._firstBatch, this);\n\t\tthis.keyboard = options.keyboard || null;\n\t\tthis.mouse = options.mouse || null;\n\t\tthis.touch = options.touch || null;\n\t\tthis.gamepads = options.gamepads || null;\n\t\tthis.elementInput = options.elementInput || null;\n\t\tif (this.elementInput) this.elementInput.app = this;\n\t\tthis.vr = null;\n\t\tthis.xr = new XrManager(this);\n\t\tif (this.elementInput) this.elementInput.attachSelectEvents();\n\t\tthis._inTools = false;\n\t\tthis._skyboxAsset = null;\n\t\tthis._scriptPrefix = options.scriptPrefix || '';\n\n\t\tif (this.enableBundles) {\n\t\t\tthis.loader.addHandler(\"bundle\", new BundleHandler(this.assets));\n\t\t}\n\n\t\tthis.loader.addHandler(\"animation\", new AnimationHandler());\n\t\tthis.loader.addHandler(\"animclip\", new AnimClipHandler());\n\t\tthis.loader.addHandler(\"animstategraph\", new AnimStateGraphHandler());\n\t\tthis.loader.addHandler(\"model\", new ModelHandler(this.graphicsDevice));\n\t\tthis.loader.addHandler(\"render\", new RenderHandler(this.assets));\n\t\tthis.loader.addHandler(\"material\", new MaterialHandler(this));\n\t\tthis.loader.addHandler(\"texture\", new TextureHandler(this.graphicsDevice, this.assets, this.loader));\n\t\tthis.loader.addHandler(\"text\", new TextHandler());\n\t\tthis.loader.addHandler(\"json\", new JsonHandler());\n\t\tthis.loader.addHandler(\"audio\", new AudioHandler(this._soundManager));\n\t\tthis.loader.addHandler(\"script\", new ScriptHandler(this));\n\t\tthis.loader.addHandler(\"scene\", new SceneHandler(this));\n\t\tthis.loader.addHandler(\"cubemap\", new CubemapHandler(this.graphicsDevice, this.assets, this.loader));\n\t\tthis.loader.addHandler(\"html\", new HtmlHandler());\n\t\tthis.loader.addHandler(\"css\", new CssHandler());\n\t\tthis.loader.addHandler(\"shader\", new ShaderHandler());\n\t\tthis.loader.addHandler(\"hierarchy\", new HierarchyHandler(this));\n\t\tthis.loader.addHandler(\"folder\", new FolderHandler());\n\t\tthis.loader.addHandler(\"font\", new FontHandler(this.loader));\n\t\tthis.loader.addHandler(\"binary\", new BinaryHandler());\n\t\tthis.loader.addHandler(\"textureatlas\", new TextureAtlasHandler(this.loader));\n\t\tthis.loader.addHandler(\"sprite\", new SpriteHandler(this.assets, this.graphicsDevice));\n\t\tthis.loader.addHandler(\"template\", new TemplateHandler(this));\n\t\tthis.loader.addHandler(\"container\", new ContainerHandler(this.graphicsDevice, this.assets));\n\t\tthis.systems = new ComponentSystemRegistry();\n\t\tthis.systems.add(new RigidBodyComponentSystem(this));\n\t\tthis.systems.add(new CollisionComponentSystem(this));\n\t\tthis.systems.add(new JointComponentSystem(this));\n\t\tthis.systems.add(new AnimationComponentSystem(this));\n\t\tthis.systems.add(new AnimComponentSystem(this));\n\t\tthis.systems.add(new ModelComponentSystem(this));\n\t\tthis.systems.add(new RenderComponentSystem(this));\n\t\tthis.systems.add(new CameraComponentSystem(this));\n\t\tthis.systems.add(new LightComponentSystem(this));\n\n\t\tif (script.legacy) {\n\t\t\tthis.systems.add(new ScriptLegacyComponentSystem(this));\n\t\t} else {\n\t\t\tthis.systems.add(new ScriptComponentSystem(this));\n\t\t}\n\n\t\tthis.systems.add(new AudioSourceComponentSystem(this, this._soundManager));\n\t\tthis.systems.add(new SoundComponentSystem(this, this._soundManager));\n\t\tthis.systems.add(new AudioListenerComponentSystem(this, this._soundManager));\n\t\tthis.systems.add(new ParticleSystemComponentSystem(this));\n\t\tthis.systems.add(new ScreenComponentSystem(this));\n\t\tthis.systems.add(new ElementComponentSystem(this));\n\t\tthis.systems.add(new ButtonComponentSystem(this));\n\t\tthis.systems.add(new ScrollViewComponentSystem(this));\n\t\tthis.systems.add(new ScrollbarComponentSystem(this));\n\t\tthis.systems.add(new SpriteComponentSystem(this));\n\t\tthis.systems.add(new LayoutGroupComponentSystem(this));\n\t\tthis.systems.add(new LayoutChildComponentSystem(this));\n\t\tthis.systems.add(new ZoneComponentSystem(this));\n\t\tthis._visibilityChangeHandler = this.onVisibilityChange.bind(this);\n\n\t\tif (typeof document !== 'undefined') {\n\t\t\tif (document.hidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'hidden';\n\t\t\t\tdocument.addEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.mozHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'mozHidden';\n\t\t\t\tdocument.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.msHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'msHidden';\n\t\t\t\tdocument.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.webkitHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'webkitHidden';\n\t\t\t\tdocument.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t}\n\t\t}\n\n\t\tthis.tick = makeTick(this);\n\t}\n\n\tstatic getApplication(id) {\n\t\treturn id ? Application._applications[id] : getApplication();\n\t}\n\n\t_initDefaultMaterial() {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.name = \"Default Material\";\n\t\tmaterial.shadingModel = SPECULAR_BLINN;\n\t\tDefaultMaterial.add(this.graphicsDevice, material);\n\t}\n\n\tget fillMode() {\n\t\treturn this._fillMode;\n\t}\n\n\tget resolutionMode() {\n\t\treturn this._resolutionMode;\n\t}\n\n\tconfigure(url, callback) {\n\t\thttp.get(url, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst props = response.application_properties;\n\t\t\tconst scenes = response.scenes;\n\t\t\tconst assets = response.assets;\n\n\t\t\tthis._parseApplicationProperties(props, err => {\n\t\t\t\tthis._parseScenes(scenes);\n\n\t\t\t\tthis._parseAssets(assets);\n\n\t\t\t\tif (!err) {\n\t\t\t\t\tcallback(null);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tpreload(callback) {\n\t\tthis.fire(\"preload:start\");\n\t\tconst assets = this.assets.list({\n\t\t\tpreload: true\n\t\t});\n\t\tconst progress = new Progress(assets.length);\n\t\tlet _done = false;\n\n\t\tconst done = () => {\n\t\t\tif (!this.graphicsDevice) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!_done && progress.done()) {\n\t\t\t\t_done = true;\n\t\t\t\tthis.fire(\"preload:end\");\n\t\t\t\tcallback();\n\t\t\t}\n\t\t};\n\n\t\tconst total = assets.length;\n\n\t\tif (progress.length) {\n\t\t\tconst onAssetLoad = asset => {\n\t\t\t\tprogress.inc();\n\t\t\t\tthis.fire('preload:progress', progress.count / total);\n\t\t\t\tif (progress.done()) done();\n\t\t\t};\n\n\t\t\tconst onAssetError = (err, asset) => {\n\t\t\t\tprogress.inc();\n\t\t\t\tthis.fire('preload:progress', progress.count / total);\n\t\t\t\tif (progress.done()) done();\n\t\t\t};\n\n\t\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\t\tif (!assets[i].loaded) {\n\t\t\t\t\tassets[i].once('load', onAssetLoad);\n\t\t\t\t\tassets[i].once('error', onAssetError);\n\t\t\t\t\tthis.assets.load(assets[i]);\n\t\t\t\t} else {\n\t\t\t\t\tprogress.inc();\n\t\t\t\t\tthis.fire(\"preload:progress\", progress.count / total);\n\t\t\t\t\tif (progress.done()) done();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdone();\n\t\t}\n\t}\n\n\t_preloadScripts(sceneData, callback) {\n\t\tif (!script.legacy) {\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.systems.script.preloading = true;\n\n\t\tconst scripts = this._getScriptReferences(sceneData);\n\n\t\tconst l = scripts.length;\n\t\tconst progress = new Progress(l);\n\t\tconst regex = /^http(s)?:\\/\\//;\n\n\t\tif (l) {\n\t\t\tconst onLoad = (err, ScriptType) => {\n\t\t\t\tif (err) console.error(err);\n\t\t\t\tprogress.inc();\n\n\t\t\t\tif (progress.done()) {\n\t\t\t\t\tthis.systems.script.preloading = false;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\tlet scriptUrl = scripts[i];\n\t\t\t\tif (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) scriptUrl = path.join(self._scriptPrefix, scripts[i]);\n\t\t\t\tthis.loader.load(scriptUrl, 'script', onLoad);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.systems.script.preloading = false;\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t_handleAreaLightDataProperty(prop) {\n\t\tconst asset = this.assets.get(prop);\n\n\t\tif (asset) {\n\t\t\tthis.setAreaLightLuts(asset);\n\t\t} else {\n\t\t\tthis.assets.once('add:' + prop, this.setAreaLightLuts, this);\n\t\t}\n\t}\n\n\t_parseApplicationProperties(props, callback) {\n\t\tif (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {\n\t\t\tthis.loader.enableRetry(props.maxAssetRetries);\n\t\t}\n\n\t\tif (!props.useDevicePixelRatio) props.useDevicePixelRatio = props.use_device_pixel_ratio;\n\t\tif (!props.resolutionMode) props.resolutionMode = props.resolution_mode;\n\t\tif (!props.fillMode) props.fillMode = props.fill_mode;\n\t\tthis._width = props.width;\n\t\tthis._height = props.height;\n\n\t\tif (props.useDevicePixelRatio) {\n\t\t\tthis.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\t\t}\n\n\t\tthis.setCanvasResolution(props.resolutionMode, this._width, this._height);\n\t\tthis.setCanvasFillMode(props.fillMode, this._width, this._height);\n\n\t\tif (props.layers && props.layerOrder) {\n\t\t\tconst composition = new LayerComposition(\"application\");\n\t\t\tconst layers = {};\n\n\t\t\tfor (const key in props.layers) {\n\t\t\t\tconst data = props.layers[key];\n\t\t\t\tdata.id = parseInt(key, 10);\n\t\t\t\tdata.enabled = data.id !== LAYERID_DEPTH;\n\t\t\t\tlayers[key] = new Layer(data);\n\t\t\t}\n\n\t\t\tfor (let i = 0, len = props.layerOrder.length; i < len; i++) {\n\t\t\t\tconst sublayer = props.layerOrder[i];\n\t\t\t\tconst layer = layers[sublayer.layer];\n\t\t\t\tif (!layer) continue;\n\n\t\t\t\tif (sublayer.transparent) {\n\t\t\t\t\tcomposition.pushTransparent(layer);\n\t\t\t\t} else {\n\t\t\t\t\tcomposition.pushOpaque(layer);\n\t\t\t\t}\n\n\t\t\t\tcomposition.subLayerEnabled[i] = sublayer.enabled;\n\t\t\t}\n\n\t\t\tthis.scene.layers = composition;\n\t\t}\n\n\t\tif (props.batchGroups) {\n\t\t\tfor (let i = 0, len = props.batchGroups.length; i < len; i++) {\n\t\t\t\tconst grp = props.batchGroups[i];\n\t\t\t\tthis.batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);\n\t\t\t}\n\t\t}\n\n\t\tif (props.i18nAssets) {\n\t\t\tthis.i18n.assets = props.i18nAssets;\n\t\t}\n\n\t\tif (props.areaLightDataAsset) {\n\t\t\tthis._handleAreaLightDataProperty(props.areaLightDataAsset);\n\t\t}\n\n\t\tthis._loadLibraries(props.libraries, callback);\n\t}\n\n\t_loadLibraries(urls, callback) {\n\t\tconst len = urls.length;\n\t\tlet count = len;\n\t\tconst regex = /^http(s)?:\\/\\//;\n\n\t\tif (len) {\n\t\t\tconst onLoad = (err, script) => {\n\t\t\t\tcount--;\n\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else if (count === 0) {\n\t\t\t\t\tthis.onLibrariesLoaded();\n\t\t\t\t\tcallback(null);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\tlet url = urls[i];\n\t\t\t\tif (!regex.test(url.toLowerCase()) && this._scriptPrefix) url = path.join(this._scriptPrefix, url);\n\t\t\t\tthis.loader.load(url, 'script', onLoad);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.onLibrariesLoaded();\n\t\t\tcallback(null);\n\t\t}\n\t}\n\n\t_parseScenes(scenes) {\n\t\tif (!scenes) return;\n\n\t\tfor (let i = 0; i < scenes.length; i++) {\n\t\t\tthis.scenes.add(scenes[i].name, scenes[i].url);\n\t\t}\n\t}\n\n\t_parseAssets(assets) {\n\t\tconst list = [];\n\t\tconst scriptsIndex = {};\n\t\tconst bundlesIndex = {};\n\n\t\tif (!script.legacy) {\n\t\t\tfor (let i = 0; i < this.scriptsOrder.length; i++) {\n\t\t\t\tconst id = this.scriptsOrder[i];\n\t\t\t\tif (!assets[id]) continue;\n\t\t\t\tscriptsIndex[id] = true;\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\n\t\t\tif (this.enableBundles) {\n\t\t\t\tfor (const id in assets) {\n\t\t\t\t\tif (assets[id].type === 'bundle') {\n\t\t\t\t\t\tbundlesIndex[id] = true;\n\t\t\t\t\t\tlist.push(assets[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const id in assets) {\n\t\t\t\tif (scriptsIndex[id] || bundlesIndex[id]) continue;\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.enableBundles) {\n\t\t\t\tfor (const id in assets) {\n\t\t\t\t\tif (assets[id].type === 'bundle') {\n\t\t\t\t\t\tbundlesIndex[id] = true;\n\t\t\t\t\t\tlist.push(assets[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const id in assets) {\n\t\t\t\tif (bundlesIndex[id]) continue;\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst data = list[i];\n\t\t\tconst asset = new Asset(data.name, data.type, data.file, data.data);\n\t\t\tasset.id = parseInt(data.id, 10);\n\t\t\tasset.preload = data.preload ? data.preload : false;\n\t\t\tasset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;\n\t\t\tasset.tags.add(data.tags);\n\n\t\t\tif (data.i18n) {\n\t\t\t\tfor (const locale in data.i18n) {\n\t\t\t\t\tasset.addLocalizedAssetId(locale, data.i18n[locale]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.assets.add(asset);\n\t\t}\n\t}\n\n\t_getScriptReferences(scene) {\n\t\tlet priorityScripts = [];\n\n\t\tif (scene.settings.priority_scripts) {\n\t\t\tpriorityScripts = scene.settings.priority_scripts;\n\t\t}\n\n\t\tconst _scripts = [];\n\t\tconst _index = {};\n\n\t\tfor (let i = 0; i < priorityScripts.length; i++) {\n\t\t\t_scripts.push(priorityScripts[i]);\n\n\t\t\t_index[priorityScripts[i]] = true;\n\t\t}\n\n\t\tconst entities = scene.entities;\n\n\t\tfor (const key in entities) {\n\t\t\tif (!entities[key].components.script) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst scripts = entities[key].components.script.scripts;\n\n\t\t\tfor (let i = 0; i < scripts.length; i++) {\n\t\t\t\tif (_index[scripts[i].url]) continue;\n\n\t\t\t\t_scripts.push(scripts[i].url);\n\n\t\t\t\t_index[scripts[i].url] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn _scripts;\n\t}\n\n\tstart() {\n\t\tthis.frame = 0;\n\t\tthis.fire(\"start\", {\n\t\t\ttimestamp: now(),\n\t\t\ttarget: this\n\t\t});\n\n\t\tif (!this._librariesLoaded) {\n\t\t\tthis.onLibrariesLoaded();\n\t\t}\n\n\t\tthis.systems.fire('initialize', this.root);\n\t\tthis.fire('initialize');\n\t\tthis.systems.fire('postInitialize', this.root);\n\t\tthis.systems.fire('postPostInitialize', this.root);\n\t\tthis.fire('postinitialize');\n\t\tthis.tick();\n\t}\n\n\tinputUpdate(dt) {\n\t\tif (this.controller) {\n\t\t\tthis.controller.update(dt);\n\t\t}\n\n\t\tif (this.mouse) {\n\t\t\tthis.mouse.update(dt);\n\t\t}\n\n\t\tif (this.keyboard) {\n\t\t\tthis.keyboard.update(dt);\n\t\t}\n\n\t\tif (this.gamepads) {\n\t\t\tthis.gamepads.update(dt);\n\t\t}\n\t}\n\n\tupdate(dt) {\n\t\tthis.frame++;\n\t\tthis.graphicsDevice.updateClientRect();\n\t\tif (this.vr) this.vr.poll();\n\t\tif (script.legacy) this.systems.fire('fixedUpdate', 1.0 / 60.0);\n\t\tthis.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);\n\t\tthis.systems.fire('animationUpdate', dt);\n\t\tthis.systems.fire('postUpdate', dt);\n\t\tthis.fire(\"update\", dt);\n\t\tthis.inputUpdate(dt);\n\t}\n\n\trender() {\n\t\tthis.fire('prerender');\n\t\tthis.root.syncHierarchy();\n\t\tthis.batcher.updateAll();\n\t\tthis.renderer.renderComposition(this.scene.layers);\n\t\tthis.fire('postrender');\n\t}\n\n\t_fillFrameStatsBasic(now, dt, ms) {\n\t\tconst stats = this.stats.frame;\n\t\tstats.dt = dt;\n\t\tstats.ms = ms;\n\n\t\tif (now > stats._timeToCountFrames) {\n\t\t\tstats.fps = stats._fpsAccum;\n\t\t\tstats._fpsAccum = 0;\n\t\t\tstats._timeToCountFrames = now + 1000;\n\t\t} else {\n\t\t\tstats._fpsAccum++;\n\t\t}\n\n\t\tthis.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;\n\t\tthis.graphicsDevice._drawCallsPerFrame = 0;\n\t}\n\n\t_fillFrameStats() {\n\t\tlet stats = this.stats.frame;\n\t\tstats.cameras = this.renderer._camerasRendered;\n\t\tstats.materials = this.renderer._materialSwitches;\n\t\tstats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;\n\t\tstats.shadowMapUpdates = this.renderer._shadowMapUpdates;\n\t\tstats.shadowMapTime = this.renderer._shadowMapTime;\n\t\tstats.depthMapTime = this.renderer._depthMapTime;\n\t\tstats.forwardTime = this.renderer._forwardTime;\n\t\tconst prims = this.graphicsDevice._primsPerFrame;\n\t\tstats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);\n\t\tstats.cullTime = this.renderer._cullTime;\n\t\tstats.sortTime = this.renderer._sortTime;\n\t\tstats.skinTime = this.renderer._skinTime;\n\t\tstats.morphTime = this.renderer._morphTime;\n\t\tstats.instancingTime = this.renderer._instancingTime;\n\t\tstats.lightClusters = this.renderer._lightClusters;\n\t\tstats.lightClustersTime = this.renderer._lightClustersTime;\n\t\tstats.otherPrimitives = 0;\n\n\t\tfor (let i = 0; i < prims.length; i++) {\n\t\t\tif (i < PRIMITIVE_TRIANGLES) {\n\t\t\t\tstats.otherPrimitives += prims[i];\n\t\t\t}\n\n\t\t\tprims[i] = 0;\n\t\t}\n\n\t\tthis.renderer._camerasRendered = 0;\n\t\tthis.renderer._materialSwitches = 0;\n\t\tthis.renderer._shadowMapUpdates = 0;\n\t\tthis.graphicsDevice._shaderSwitchesPerFrame = 0;\n\t\tthis.renderer._cullTime = 0;\n\t\tthis.renderer._layerCompositionUpdateTime = 0;\n\t\tthis.renderer._lightClustersTime = 0;\n\t\tthis.renderer._sortTime = 0;\n\t\tthis.renderer._skinTime = 0;\n\t\tthis.renderer._morphTime = 0;\n\t\tthis.renderer._instancingTime = 0;\n\t\tthis.renderer._shadowMapTime = 0;\n\t\tthis.renderer._depthMapTime = 0;\n\t\tthis.renderer._forwardTime = 0;\n\t\tstats = this.stats.drawCalls;\n\t\tstats.forward = this.renderer._forwardDrawCalls;\n\t\tstats.culled = this.renderer._numDrawCallsCulled;\n\t\tstats.depth = 0;\n\t\tstats.shadow = this.renderer._shadowDrawCalls;\n\t\tstats.skinned = this.renderer._skinDrawCalls;\n\t\tstats.immediate = 0;\n\t\tstats.instanced = 0;\n\t\tstats.removedByInstancing = 0;\n\t\tstats.misc = stats.total - (stats.forward + stats.shadow);\n\t\tthis.renderer._depthDrawCalls = 0;\n\t\tthis.renderer._shadowDrawCalls = 0;\n\t\tthis.renderer._forwardDrawCalls = 0;\n\t\tthis.renderer._numDrawCallsCulled = 0;\n\t\tthis.renderer._skinDrawCalls = 0;\n\t\tthis.renderer._immediateRendered = 0;\n\t\tthis.renderer._instancedDrawCalls = 0;\n\t\tthis.renderer._removedByInstancing = 0;\n\t\tthis.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;\n\t\tstats = this.stats.particles;\n\t\tstats.updatesPerFrame = stats._updatesPerFrame;\n\t\tstats.frameTime = stats._frameTime;\n\t\tstats._updatesPerFrame = 0;\n\t\tstats._frameTime = 0;\n\t}\n\n\tsetCanvasFillMode(mode, width, height) {\n\t\tthis._fillMode = mode;\n\t\tthis.resizeCanvas(width, height);\n\t}\n\n\tsetCanvasResolution(mode, width, height) {\n\t\tthis._resolutionMode = mode;\n\n\t\tif (mode === RESOLUTION_AUTO && width === undefined) {\n\t\t\twidth = this.graphicsDevice.canvas.clientWidth;\n\t\t\theight = this.graphicsDevice.canvas.clientHeight;\n\t\t}\n\n\t\tthis.graphicsDevice.resizeCanvas(width, height);\n\t}\n\n\tisHidden() {\n\t\treturn document[this._hiddenAttr];\n\t}\n\n\tonVisibilityChange() {\n\t\tif (this.isHidden()) {\n\t\t\tthis._soundManager.suspend();\n\t\t} else {\n\t\t\tthis._soundManager.resume();\n\t\t}\n\t}\n\n\tresizeCanvas(width, height) {\n\t\tif (!this._allowResize) return;\n\t\tif (this.xr && this.xr.session) return;\n\t\tconst windowWidth = window.innerWidth;\n\t\tconst windowHeight = window.innerHeight;\n\n\t\tif (this._fillMode === FILLMODE_KEEP_ASPECT) {\n\t\t\tconst r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;\n\t\t\tconst winR = windowWidth / windowHeight;\n\n\t\t\tif (r > winR) {\n\t\t\t\twidth = windowWidth;\n\t\t\t\theight = width / r;\n\t\t\t} else {\n\t\t\t\theight = windowHeight;\n\t\t\t\twidth = height * r;\n\t\t\t}\n\t\t} else if (this._fillMode === FILLMODE_FILL_WINDOW) {\n\t\t\twidth = windowWidth;\n\t\t\theight = windowHeight;\n\t\t}\n\n\t\tthis.graphicsDevice.canvas.style.width = width + 'px';\n\t\tthis.graphicsDevice.canvas.style.height = height + 'px';\n\t\tthis.updateCanvasSize();\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\tupdateCanvasSize() {\n\t\tif (!this._allowResize || this.xr.active) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._resolutionMode === RESOLUTION_AUTO) {\n\t\t\tconst canvas = this.graphicsDevice.canvas;\n\t\t\tthis.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);\n\t\t}\n\t}\n\n\tonLibrariesLoaded() {\n\t\tthis._librariesLoaded = true;\n\t\tthis.systems.rigidbody.onLibraryLoaded();\n\t}\n\n\tapplySceneSettings(settings) {\n\t\tlet asset;\n\n\t\tif (this.systems.rigidbody && typeof Ammo !== 'undefined') {\n\t\t\tconst gravity = settings.physics.gravity;\n\t\t\tthis.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);\n\t\t}\n\n\t\tthis.scene.applySettings(settings);\n\n\t\tif (settings.render.hasOwnProperty('skybox')) {\n\t\t\tif (settings.render.skybox) {\n\t\t\t\tasset = this.assets.get(settings.render.skybox);\n\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis.setSkybox(asset);\n\t\t\t\t} else {\n\t\t\t\t\tthis.assets.once('add:' + settings.render.skybox, this.setSkybox, this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.setSkybox(null);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetAreaLightLuts(asset) {\n\t\tif (asset) {\n\t\t\tconst device = this.graphicsDevice;\n\t\t\tasset.ready(asset => {\n\t\t\t\tAreaLightLuts.set(device, asset.resource);\n\t\t\t});\n\t\t\tthis.assets.load(asset);\n\t\t}\n\t}\n\n\tsetSkybox(asset) {\n\t\tif (asset !== this._skyboxAsset) {\n\t\t\tconst onSkyboxRemoved = () => {\n\t\t\t\tthis.setSkybox(null);\n\t\t\t};\n\n\t\t\tconst onSkyboxChanged = () => {\n\t\t\t\tthis.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);\n\t\t\t};\n\n\t\t\tif (this._skyboxAsset) {\n\t\t\t\tthis.assets.off('load:' + this._skyboxAsset.id, onSkyboxChanged, this);\n\t\t\t\tthis.assets.off('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);\n\n\t\t\t\tthis._skyboxAsset.off('change', onSkyboxChanged, this);\n\t\t\t}\n\n\t\t\tthis._skyboxAsset = asset;\n\n\t\t\tif (this._skyboxAsset) {\n\t\t\t\tthis.assets.on('load:' + this._skyboxAsset.id, onSkyboxChanged, this);\n\t\t\t\tthis.assets.once('remove:' + this._skyboxAsset.id, onSkyboxRemoved, this);\n\n\t\t\t\tthis._skyboxAsset.on('change', onSkyboxChanged, this);\n\n\t\t\t\tif (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {\n\t\t\t\t\tthis._skyboxAsset.loadFaces = true;\n\t\t\t\t}\n\n\t\t\t\tthis.assets.load(this._skyboxAsset);\n\t\t\t}\n\n\t\t\tonSkyboxChanged();\n\t\t}\n\t}\n\n\tenableVr() {\n\t\tif (!this.vr) {\n\t\t\tthis.vr = new VrManager(this);\n\t\t}\n\t}\n\n\tdisableVr() {\n\t\tif (this.vr) {\n\t\t\tthis.vr.destroy();\n\t\t\tthis.vr = null;\n\t\t}\n\t}\n\n\t_firstBake() {\n\t\tthis.lightmapper.bake(null, this.scene.lightmapMode);\n\t}\n\n\t_firstBatch() {\n\t\tthis.batcher.generate();\n\t}\n\n\t_processTimestamp(timestamp) {\n\t\treturn timestamp;\n\t}\n\n\tdrawLine(start, end, color, depthTest, layer) {\n\t\tthis.scene.drawLine(start, end, color, depthTest, layer);\n\t}\n\n\tdrawLines(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.drawLines(positions, colors, depthTest, layer);\n\t}\n\n\tdrawLineArrays(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.drawLineArrays(positions, colors, depthTest, layer);\n\t}\n\n\tdrawWireSphere(center, radius, color = Color.WHITE, segments = 20, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);\n\t}\n\n\tdrawWireAlignedBox(minPoint, maxPoint, color = Color.WHITE, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer);\n\t}\n\n\tdrawMeshInstance(meshInstance, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(null, null, null, meshInstance, layer);\n\t}\n\n\tdrawMesh(mesh, material, matrix, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(material, matrix, mesh, null, layer);\n\t}\n\n\tdrawQuad(matrix, material, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);\n\t}\n\n\tdrawTexture(x, y, width, height, texture, material, layer = this.scene.defaultDrawLayer) {\n\t\tconst matrix = new Mat4();\n\t\tmatrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, height, 0.0));\n\n\t\tif (!material) {\n\t\t\tmaterial = new Material();\n\t\t\tmaterial.setParameter(\"colorMap\", texture);\n\t\t\tmaterial.shader = this.scene.immediate.getTextureShader();\n\t\t\tmaterial.update();\n\t\t}\n\n\t\tthis.drawQuad(matrix, material, layer);\n\t}\n\n\tdrawDepthTexture(x, y, width, height, layer = this.scene.defaultDrawLayer) {\n\t\tconst material = new Material();\n\t\tmaterial.shader = this.scene.immediate.getDepthTextureShader();\n\t\tmaterial.update();\n\t\tthis.drawTexture(x, y, width, height, null, material, layer);\n\t}\n\n\tdestroy() {\n\t\tif (this._inFrameUpdate) {\n\t\t\tthis._destroyRequested = true;\n\t\t\treturn;\n\t\t}\n\n\t\tconst canvasId = this.graphicsDevice.canvas.id;\n\t\tthis.off('librariesloaded');\n\n\t\tif (typeof document !== 'undefined') {\n\t\t\tdocument.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);\n\t\t}\n\n\t\tthis._visibilityChangeHandler = null;\n\t\tthis.root.destroy();\n\t\tthis.root = null;\n\n\t\tif (this.mouse) {\n\t\t\tthis.mouse.off();\n\t\t\tthis.mouse.detach();\n\t\t\tthis.mouse = null;\n\t\t}\n\n\t\tif (this.keyboard) {\n\t\t\tthis.keyboard.off();\n\t\t\tthis.keyboard.detach();\n\t\t\tthis.keyboard = null;\n\t\t}\n\n\t\tif (this.touch) {\n\t\t\tthis.touch.off();\n\t\t\tthis.touch.detach();\n\t\t\tthis.touch = null;\n\t\t}\n\n\t\tif (this.elementInput) {\n\t\t\tthis.elementInput.detach();\n\t\t\tthis.elementInput = null;\n\t\t}\n\n\t\tif (this.controller) {\n\t\t\tthis.controller = null;\n\t\t}\n\n\t\tthis.systems.destroy();\n\n\t\tif (this.scene.layers) {\n\t\t\tthis.scene.layers.destroy();\n\t\t}\n\n\t\tconst assets = this.assets.list();\n\n\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\tassets[i].unload();\n\t\t\tassets[i].off();\n\t\t}\n\n\t\tthis.assets.off();\n\t\tthis.bundles.destroy();\n\t\tthis.bundles = null;\n\t\tthis.i18n.destroy();\n\t\tthis.i18n = null;\n\n\t\tfor (const key in this.loader.getHandler('script')._cache) {\n\t\t\tconst element = this.loader.getHandler('script')._cache[key];\n\n\t\t\tconst parent = element.parentNode;\n\t\t\tif (parent) parent.removeChild(element);\n\t\t}\n\n\t\tthis.loader.getHandler('script')._cache = {};\n\t\tthis.loader.destroy();\n\t\tthis.loader = null;\n\t\tthis.scene.destroy();\n\t\tthis.scene = null;\n\t\tthis.systems = null;\n\t\tthis.context = null;\n\t\tthis.scripts.destroy();\n\t\tthis.scripts = null;\n\t\tthis.scenes.destroy();\n\t\tthis.scenes = null;\n\t\tthis.lightmapper.destroy();\n\t\tthis.lightmapper = null;\n\t\tthis.batcher.destroy();\n\t\tthis.batcher = null;\n\t\tthis._entityIndex = {};\n\t\tthis.defaultLayerDepth.onPreRenderOpaque = null;\n\t\tthis.defaultLayerDepth.onPostRenderOpaque = null;\n\t\tthis.defaultLayerDepth.onDisable = null;\n\t\tthis.defaultLayerDepth.onEnable = null;\n\t\tthis.defaultLayerDepth = null;\n\t\tthis.defaultLayerWorld = null;\n\t\tdestroyPostEffectQuad();\n\n\t\tif (this.vr) {\n\t\t\tthis.vr.destroy();\n\t\t\tthis.vr = null;\n\t\t}\n\n\t\tthis.xr.end();\n\t\tParticleEmitter.staticDestroy();\n\t\tthis.renderer.destroy();\n\t\tthis.renderer = null;\n\t\tDefaultMaterial.remove(this.graphicsDevice);\n\t\tthis.graphicsDevice.destroy();\n\t\tthis.graphicsDevice = null;\n\t\tthis.tick = null;\n\t\tthis.off();\n\n\t\tif (this._soundManager) {\n\t\t\tthis._soundManager.destroy();\n\n\t\t\tthis._soundManager = null;\n\t\t}\n\n\t\tscript.app = null;\n\t\tApplication._applications[canvasId] = null;\n\n\t\tif (getApplication() === this) {\n\t\t\tsetApplication(null);\n\t\t}\n\t}\n\n\tgetEntityFromIndex(guid) {\n\t\treturn this._entityIndex[guid];\n\t}\n\n\t_registerSceneImmediate(scene) {\n\t\tthis.on('postrender', scene.immediate.onPostRender, scene.immediate);\n\t}\n\n}\n\nApplication._applications = {};\nconst _frameEndData = {};\n\nconst makeTick = function makeTick(_app) {\n\tconst application = _app;\n\tlet frameRequest;\n\treturn function (timestamp, frame) {\n\t\tif (!application.graphicsDevice) return;\n\t\tsetApplication(application);\n\n\t\tif (frameRequest) {\n\t\t\twindow.cancelAnimationFrame(frameRequest);\n\t\t\tframeRequest = null;\n\t\t}\n\n\t\tapp = application;\n\t\tconst currentTime = application._processTimestamp(timestamp) || now();\n\t\tconst ms = currentTime - (application._time || currentTime);\n\t\tlet dt = ms / 1000.0;\n\t\tdt = math.clamp(dt, 0, application.maxDeltaTime);\n\t\tdt *= application.timeScale;\n\t\tapplication._time = currentTime;\n\n\t\tif (application.vr && application.vr.display) {\n\t\t\tframeRequest = application.vr.display.requestAnimationFrame(application.tick);\n\t\t} else if (application.xr.session) {\n\t\t\tframeRequest = application.xr.session.requestAnimationFrame(application.tick);\n\t\t} else {\n\t\t\tframeRequest = platform.browser ? window.requestAnimationFrame(application.tick) : null;\n\t\t}\n\n\t\tif (application.graphicsDevice.contextLost) return;\n\n\t\tapplication._fillFrameStatsBasic(currentTime, dt, ms);\n\n\t\tapplication._inFrameUpdate = true;\n\t\tapplication.fire(\"frameupdate\", ms);\n\n\t\tif (frame) {\n\t\t\tapplication.xr.update(frame);\n\t\t\tapplication.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;\n\t\t} else {\n\t\t\tapplication.graphicsDevice.defaultFramebuffer = null;\n\t\t}\n\n\t\tapplication.update(dt);\n\t\tapplication.fire(\"framerender\");\n\n\t\tif (application.autoRender || application.renderNextFrame) {\n\t\t\tapplication.updateCanvasSize();\n\t\t\tapplication.render();\n\t\t\tapplication.renderNextFrame = false;\n\t\t}\n\n\t\t_frameEndData.timestamp = now();\n\t\t_frameEndData.target = application;\n\t\tapplication.fire(\"frameend\", _frameEndData);\n\t\tapplication.fire(\"frameEnd\", _frameEndData);\n\n\t\tif (application.vr && application.vr.display && application.vr.display.presenting) {\n\t\t\tapplication.vr.display.submitFrame();\n\t\t}\n\n\t\tapplication._inFrameUpdate = false;\n\n\t\tif (application._destroyRequested) {\n\t\t\tapplication.destroy();\n\t\t}\n\t};\n};\n\nclass Entity extends GraphNode {\n\tconstructor(name, app) {\n\t\tsuper(name);\n\t\tthis.anim = void 0;\n\t\tthis.animation = void 0;\n\t\tthis.audiolistener = void 0;\n\t\tthis.button = void 0;\n\t\tthis.camera = void 0;\n\t\tthis.collision = void 0;\n\t\tthis.element = void 0;\n\t\tthis.layoutchild = void 0;\n\t\tthis.layoutgroup = void 0;\n\t\tthis.light = void 0;\n\t\tthis.model = void 0;\n\t\tthis.particlesystem = void 0;\n\t\tthis.render = void 0;\n\t\tthis.rigidbody = void 0;\n\t\tthis.screen = void 0;\n\t\tthis.script = void 0;\n\t\tthis.scrollbar = void 0;\n\t\tthis.scrollview = void 0;\n\t\tthis.sound = void 0;\n\t\tthis.sprite = void 0;\n\t\tif (name instanceof Application) app = name;\n\t\tthis._batchHandle = null;\n\t\tthis.c = {};\n\t\tthis._app = app;\n\n\t\tif (!app) {\n\t\t\tthis._app = Application.getApplication();\n\n\t\t\tif (!this._app) {\n\t\t\t\tthrow new Error(\"Couldn't find current application\");\n\t\t\t}\n\t\t}\n\n\t\tthis._guid = null;\n\t\tthis._destroying = false;\n\t\tthis._template = false;\n\t}\n\n\taddComponent(type, data) {\n\t\tconst system = this._app.systems[type];\n\n\t\tif (!system) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.c[type]) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn system.addComponent(this, data);\n\t}\n\n\tremoveComponent(type) {\n\t\tconst system = this._app.systems[type];\n\n\t\tif (!system) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.c[type]) {\n\t\t\treturn;\n\t\t}\n\n\t\tsystem.removeComponent(this);\n\t}\n\n\tfindComponent(type) {\n\t\tconst entity = this.findOne(function (node) {\n\t\t\treturn node.c && node.c[type];\n\t\t});\n\t\treturn entity && entity.c[type];\n\t}\n\n\tfindComponents(type) {\n\t\tconst entities = this.find(function (node) {\n\t\t\treturn node.c && node.c[type];\n\t\t});\n\t\treturn entities.map(function (entity) {\n\t\t\treturn entity.c[type];\n\t\t});\n\t}\n\n\tgetGuid() {\n\t\tif (!this._guid) {\n\t\t\tthis.setGuid(guid.create());\n\t\t}\n\n\t\treturn this._guid;\n\t}\n\n\tsetGuid(guid) {\n\t\tconst index = this._app._entityIndex;\n\n\t\tif (this._guid) {\n\t\t\tdelete index[this._guid];\n\t\t}\n\n\t\tthis._guid = guid;\n\t\tindex[this._guid] = this;\n\t}\n\n\t_notifyHierarchyStateChanged(node, enabled) {\n\t\tlet enableFirst = false;\n\t\tif (node === this && this._app._enableList.length === 0) enableFirst = true;\n\t\tnode._beingEnabled = true;\n\n\t\tnode._onHierarchyStateChanged(enabled);\n\n\t\tif (node._onHierarchyStatePostChanged) this._app._enableList.push(node);\n\t\tconst c = node._children;\n\n\t\tfor (let i = 0, len = c.length; i < len; i++) {\n\t\t\tif (c[i]._enabled) this._notifyHierarchyStateChanged(c[i], enabled);\n\t\t}\n\n\t\tnode._beingEnabled = false;\n\n\t\tif (enableFirst) {\n\t\t\tfor (let i = 0; i < this._app._enableList.length; i++) {\n\t\t\t\tthis._app._enableList[i]._onHierarchyStatePostChanged();\n\t\t\t}\n\n\t\t\tthis._app._enableList.length = 0;\n\t\t}\n\t}\n\n\t_onHierarchyStateChanged(enabled) {\n\t\tsuper._onHierarchyStateChanged(enabled);\n\n\t\tconst components = this.c;\n\n\t\tfor (const type in components) {\n\t\t\tif (components.hasOwnProperty(type)) {\n\t\t\t\tconst component = components[type];\n\n\t\t\t\tif (component.enabled) {\n\t\t\t\t\tif (enabled) {\n\t\t\t\t\t\tcomponent.onEnable();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomponent.onDisable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_onHierarchyStatePostChanged() {\n\t\tconst components = this.c;\n\n\t\tfor (const type in components) {\n\t\t\tif (components.hasOwnProperty(type)) components[type].onPostStateChange();\n\t\t}\n\t}\n\n\tfindByGuid(guid) {\n\t\tif (this._guid === guid) return this;\n\t\tconst e = this._app._entityIndex[guid];\n\n\t\tif (e && (e === this || e.isDescendantOf(this))) {\n\t\t\treturn e;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tdestroy() {\n\t\tthis._destroying = true;\n\n\t\tfor (const name in this.c) {\n\t\t\tthis.c[name].enabled = false;\n\t\t}\n\n\t\tfor (const name in this.c) {\n\t\t\tthis.c[name].system.removeComponent(this);\n\t\t}\n\n\t\tif (this._parent) this._parent.removeChild(this);\n\t\tconst children = this._children;\n\t\tlet child = children.shift();\n\n\t\twhile (child) {\n\t\t\tif (child instanceof Entity) {\n\t\t\t\tchild.destroy();\n\t\t\t}\n\n\t\t\tchild._parent = null;\n\t\t\tchild = children.shift();\n\t\t}\n\n\t\tthis.fire('destroy', this);\n\t\tthis.off();\n\n\t\tif (this._guid) {\n\t\t\tdelete this._app._entityIndex[this._guid];\n\t\t}\n\n\t\tthis._destroying = false;\n\t}\n\n\tclone() {\n\t\tconst duplicatedIdsMap = {};\n\n\t\tconst clone = this._cloneRecursively(duplicatedIdsMap);\n\n\t\tduplicatedIdsMap[this.getGuid()] = clone;\n\t\tresolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);\n\t\treturn clone;\n\t}\n\n\t_cloneRecursively(duplicatedIdsMap) {\n\t\tconst clone = new Entity(this._app);\n\n\t\tsuper._cloneInternal(clone);\n\n\t\tfor (const type in this.c) {\n\t\t\tconst component = this.c[type];\n\t\t\tcomponent.system.cloneComponent(this, clone);\n\t\t}\n\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst oldChild = this._children[i];\n\n\t\t\tif (oldChild instanceof Entity) {\n\t\t\t\tconst newChild = oldChild._cloneRecursively(duplicatedIdsMap);\n\n\t\t\t\tclone.addChild(newChild);\n\t\t\t\tduplicatedIdsMap[oldChild.getGuid()] = newChild;\n\t\t\t}\n\t\t}\n\n\t\treturn clone;\n\t}\n\n}\n\nfunction resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {\n\tif (oldEntity instanceof Entity) {\n\t\tconst components = oldEntity.c;\n\n\t\tfor (const componentName in components) {\n\t\t\tconst component = components[componentName];\n\t\t\tconst entityProperties = component.system.getPropertiesOfType('entity');\n\n\t\t\tfor (let i = 0, len = entityProperties.length; i < len; i++) {\n\t\t\t\tconst propertyDescriptor = entityProperties[i];\n\t\t\t\tconst propertyName = propertyDescriptor.name;\n\t\t\t\tconst oldEntityReferenceId = component[propertyName];\n\t\t\t\tconst entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);\n\n\t\t\t\tif (entityIsWithinOldSubtree) {\n\t\t\t\t\tconst newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();\n\n\t\t\t\t\tif (newEntityReferenceId) {\n\t\t\t\t\t\tnewEntity.c[componentName][propertyName] = newEntityReferenceId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {\n\t\t\tnewEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);\n\t\t}\n\n\t\tif (components.render) {\n\t\t\tnewEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);\n\t\t}\n\n\t\tif (components.anim) {\n\t\t\tnewEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);\n\t\t}\n\n\t\tconst _old = oldEntity.children.filter(function (e) {\n\t\t\treturn e instanceof Entity;\n\t\t});\n\n\t\tconst _new = newEntity.children.filter(function (e) {\n\t\t\treturn e instanceof Entity;\n\t\t});\n\n\t\tfor (let i = 0, len = _old.length; i < len; i++) {\n\t\t\tresolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);\n\t\t}\n\t}\n}\n\nconst _tempPoint = new Vec3();\n\nclass BakeLightAmbient extends BakeLight {\n\tconstructor(scene) {\n\t\tconst lightEntity = new Entity(\"AmbientLight\");\n\t\tlightEntity.addComponent(\"light\", {\n\t\t\ttype: \"directional\",\n\t\t\taffectDynamic: true,\n\t\t\taffectLightmapped: false,\n\t\t\tbake: true,\n\t\t\tbakeNumSamples: scene.ambientBakeNumSamples,\n\t\t\tcastShadows: true,\n\t\t\tnormalOffsetBias: 0.05,\n\t\t\tshadowBias: 0.2,\n\t\t\tshadowDistance: 1,\n\t\t\tshadowResolution: 2048,\n\t\t\tshadowType: SHADOW_PCF3,\n\t\t\tcolor: Color.WHITE,\n\t\t\tintensity: 1\n\t\t});\n\t\tsuper(scene, lightEntity.light.light);\n\t}\n\n\tget numVirtualLights() {\n\t\treturn this.light.bakeNumSamples;\n\t}\n\n\tprepareVirtualLight(index, numVirtualLights) {\n\t\trandom.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);\n\n\t\tthis.light._node.lookAt(_tempPoint.mulScalar(-1));\n\n\t\tthis.light._node.rotateLocal(90, 0, 0);\n\n\t\tconst gamma = this.scene.gammaCorrection ? 2.2 : 1;\n\t\tconst fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;\n\t\tconst linearIntensity = Math.pow(fullIntensity, gamma);\n\t\tthis.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);\n\t}\n\n}\n\nclass BakeMeshNode {\n\tconstructor(node, meshInstances = null) {\n\t\tthis.node = node;\n\t\tthis.component = node.render || node.model;\n\t\tmeshInstances = meshInstances || this.component.meshInstances;\n\t\tthis.store();\n\t\tthis.meshInstances = meshInstances;\n\t\tthis.bounds = null;\n\t\tthis.renderTargets = [];\n\t}\n\n\tstore() {\n\t\tthis.castShadows = this.component.castShadows;\n\t}\n\n\trestore() {\n\t\tthis.component.castShadows = this.castShadows;\n\t}\n\n}\n\nconst DENOISE_FILTER_SIZE = 15;\n\nclass LightmapFilters {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunks.dilatePS, \"lmDilate\");\n\t\tthis.constantTexSource = device.scope.resolve(\"source\");\n\t\tthis.constantPixelOffset = device.scope.resolve(\"pixelOffset\");\n\t\tthis.pixelOffset = new Float32Array(2);\n\t\tthis.shaderDenoise = null;\n\t\tthis.sigmas = null;\n\t\tthis.constantSigmas = null;\n\t\tthis.kernel = null;\n\t}\n\n\tsetSourceTexture(texture) {\n\t\tthis.constantTexSource.setValue(texture);\n\t}\n\n\tprepare(textureWidth, textureHeight) {\n\t\tthis.pixelOffset[0] = 1 / textureWidth;\n\t\tthis.pixelOffset[1] = 1 / textureHeight;\n\t\tthis.constantPixelOffset.setValue(this.pixelOffset);\n\t}\n\n\tprepareDenoise(filterRange, filterSmoothness) {\n\t\tif (!this.shaderDenoise) {\n\t\t\tthis.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunks.bilateralDeNoisePS, \"lmBilateralDeNoise\");\n\t\t\tthis.sigmas = new Float32Array(2);\n\t\t\tthis.constantSigmas = this.device.scope.resolve(\"sigmas\");\n\t\t\tthis.constantKernel = this.device.scope.resolve(\"kernel[0]\");\n\t\t\tthis.bZnorm = this.device.scope.resolve(\"bZnorm\");\n\t\t}\n\n\t\tthis.sigmas[0] = filterRange;\n\t\tthis.sigmas[1] = filterSmoothness;\n\t\tthis.constantSigmas.setValue(this.sigmas);\n\t\tthis.evaluateDenoiseUniforms(filterRange, filterSmoothness);\n\t}\n\n\tevaluateDenoiseUniforms(filterRange, filterSmoothness) {\n\t\tfunction normpdf(x, sigma) {\n\t\t\treturn 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\t\t}\n\n\t\tthis.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);\n\t\tconst kernel = this.kernel;\n\t\tconst kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);\n\n\t\tfor (let j = 0; j <= kSize; ++j) {\n\t\t\tconst value = normpdf(j, filterRange);\n\t\t\tkernel[kSize + j] = value;\n\t\t\tkernel[kSize - j] = value;\n\t\t}\n\n\t\tthis.constantKernel.setValue(this.kernel);\n\t\tconst bZnorm = 1 / normpdf(0.0, filterSmoothness);\n\t\tthis.bZnorm.setValue(bZnorm);\n\t}\n\n}\n\nconst MAX_LIGHTMAP_SIZE = 2048;\nconst PASS_COLOR = 0;\nconst PASS_DIR = 1;\nconst tempVec = new Vec3();\n\nclass Lightmapper {\n\tconstructor(device, root, scene, renderer, assets) {\n\t\tthis.device = device;\n\t\tthis.root = root;\n\t\tthis.scene = scene;\n\t\tthis.renderer = renderer;\n\t\tthis.assets = assets;\n\t\tthis.shadowMapCache = renderer._shadowRenderer.shadowMapCache;\n\t\tthis._tempSet = new Set();\n\t\tthis._initCalled = false;\n\t\tthis.passMaterials = [];\n\t\tthis.ambientAOMaterial = null;\n\t\tthis.fog = \"\";\n\t\tthis.ambientLight = new Color();\n\t\tthis.renderTargets = new Map();\n\t\tthis.stats = {\n\t\t\trenderPasses: 0,\n\t\t\tlightmapCount: 0,\n\t\t\ttotalRenderTime: 0,\n\t\t\tforwardTime: 0,\n\t\t\tfboTime: 0,\n\t\t\tshadowMapTime: 0,\n\t\t\tcompileTime: 0,\n\t\t\tshadersLinked: 0\n\t\t};\n\t}\n\n\tdestroy() {\n\t\tLightmapCache.decRef(this.blackTex);\n\t\tthis.blackTex = null;\n\t\tLightmapCache.destroy();\n\t\tthis.device = null;\n\t\tthis.root = null;\n\t\tthis.scene = null;\n\t\tthis.renderer = null;\n\t\tthis.assets = null;\n\t}\n\n\tinitBake(device) {\n\t\tif (!this._initCalled) {\n\t\t\tthis._initCalled = true;\n\t\t\tthis.lightmapFilters = new LightmapFilters(device);\n\t\t\tthis.constantBakeDir = device.scope.resolve(\"bakeDir\");\n\t\t\tthis.materials = [];\n\t\t\tthis.blackTex = new Texture(this.device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\t\ttype: TEXTURETYPE_RGBM\n\t\t\t});\n\t\t\tthis.blackTex.name = 'lightmapBlack';\n\t\t\tLightmapCache.incRef(this.blackTex);\n\t\t\tconst camera = new Camera();\n\t\t\tcamera.clearColor.set(0, 0, 0, 0);\n\t\t\tcamera.clearColorBuffer = true;\n\t\t\tcamera.clearDepthBuffer = false;\n\t\t\tcamera.clearStencilBuffer = false;\n\t\t\tcamera.frustumCulling = false;\n\t\t\tcamera.projection = PROJECTION_ORTHOGRAPHIC;\n\t\t\tcamera.aspectRatio = 1;\n\t\t\tcamera.node = new GraphNode();\n\t\t\tthis.camera = camera;\n\t\t}\n\n\t\tif (this.scene.clusteredLightingEnabled) {\n\t\t\tconst lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, () => {});\n\t\t\tthis.lightingParams = lightingParams;\n\t\t\tconst srcParams = this.scene.lighting;\n\t\t\tlightingParams.shadowsEnabled = srcParams.shadowsEnabled;\n\t\t\tlightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;\n\t\t\tlightingParams.cookiesEnabled = srcParams.cookiesEnabled;\n\t\t\tlightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;\n\t\t\tlightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;\n\t\t\tlightingParams.cells = new Vec3(3, 3, 3);\n\t\t\tlightingParams.maxLightsPerCell = 4;\n\t\t\tthis.worldClusters = new WorldClusters(device);\n\t\t\tthis.worldClusters.name = \"ClusterLightmapper\";\n\t\t}\n\t}\n\n\tfinishBake(bakeNodes) {\n\t\tthis.materials = [];\n\n\t\tfunction destroyRT(rt) {\n\t\t\tLightmapCache.decRef(rt.colorBuffer);\n\t\t\trt.destroy();\n\t\t}\n\n\t\tthis.renderTargets.forEach(rt => {\n\t\t\tdestroyRT(rt);\n\t\t});\n\t\tthis.renderTargets.clear();\n\t\tbakeNodes.forEach(node => {\n\t\t\tnode.renderTargets.forEach(rt => {\n\t\t\t\tdestroyRT(rt);\n\t\t\t});\n\t\t\tnode.renderTargets.length = 0;\n\t\t});\n\t\tthis.ambientAOMaterial = null;\n\n\t\tif (this.worldClusters) {\n\t\t\tthis.worldClusters.destroy();\n\t\t\tthis.worldClusters = null;\n\t\t}\n\t}\n\n\tcreateMaterialForPass(device, scene, pass, addAmbient) {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.name = `lmMaterial-pass:${pass}-ambient:${addAmbient}`;\n\t\tmaterial.chunks.transformVS = \"#define UV1LAYOUT\\n\" + shaderChunks.transformVS;\n\n\t\tif (pass === PASS_COLOR) {\n\t\t\tlet bakeLmEndChunk = shaderChunks.bakeLmEndPS;\n\n\t\t\tif (addAmbient) {\n\t\t\t\tbakeLmEndChunk = `\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = ((dDiffuseLight - 0.5) * max(${scene.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight += vec3(${scene.ambientBakeOcclusionBrightness.toFixed(1)});\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = saturate(dDiffuseLight);\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight *= dAmbientLight;\n\t\t\t\t\t\t\t\t` + bakeLmEndChunk;\n\t\t\t} else {\n\t\t\t\tmaterial.ambient = new Color(0, 0, 0);\n\t\t\t\tmaterial.ambientTint = true;\n\t\t\t}\n\n\t\t\tmaterial.chunks.endPS = bakeLmEndChunk;\n\t\t\tmaterial.lightMap = this.blackTex;\n\t\t} else {\n\t\t\tmaterial.chunks.basePS = shaderChunks.basePS + \"\\nuniform sampler2D texture_dirLightMap;\\nuniform float bakeDir;\\n\";\n\t\t\tmaterial.chunks.endPS = shaderChunks.bakeDirLmEndPS;\n\t\t}\n\n\t\tmaterial.chunks.outputAlphaPS = \"\\n\";\n\t\tmaterial.chunks.outputAlphaOpaquePS = \"\\n\";\n\t\tmaterial.chunks.outputAlphaPremulPS = \"\\n\";\n\t\tmaterial.cull = CULLFACE_NONE;\n\t\tmaterial.forceUv1 = true;\n\t\tmaterial.update();\n\t\tmaterial.updateShader(device, scene);\n\t\treturn material;\n\t}\n\n\tcreateMaterials(device, scene, passCount) {\n\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\tif (!this.passMaterials[pass]) {\n\t\t\t\tthis.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);\n\t\t\t}\n\t\t}\n\n\t\tif (!this.ambientAOMaterial) {\n\t\t\tthis.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);\n\n\t\t\tthis.ambientAOMaterial.onUpdateShader = function (options) {\n\t\t\t\toptions.lightMapWithoutAmbient = true;\n\t\t\t\toptions.separateAmbient = true;\n\t\t\t\treturn options;\n\t\t\t};\n\t\t}\n\t}\n\n\tcreateTexture(size, type, name) {\n\t\tconst tex = new Texture(this.device, {\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\tmipmaps: false,\n\t\t\ttype: type,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\ttex.name = name;\n\t\treturn tex;\n\t}\n\n\tcollectModels(node, bakeNodes, allNodes) {\n\t\tvar _node$model, _node$model2, _node$render;\n\n\t\tif (!node.enabled) return;\n\t\tlet meshInstances;\n\n\t\tif ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {\n\t\t\tif (allNodes) allNodes.push(new BakeMeshNode(node));\n\n\t\t\tif (node.model.lightmapped) {\n\t\t\t\tif (bakeNodes) {\n\t\t\t\t\tmeshInstances = node.model.model.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((_node$render = node.render) != null && _node$render.enabled) {\n\t\t\tif (allNodes) allNodes.push(new BakeMeshNode(node));\n\n\t\t\tif (node.render.lightmapped) {\n\t\t\t\tif (bakeNodes) {\n\t\t\t\t\tmeshInstances = node.render.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (meshInstances) {\n\t\t\tlet hasUv1 = true;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {\n\t\t\t\t\thasUv1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasUv1) {\n\t\t\t\tconst notInstancedMeshInstances = [];\n\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tconst mesh = meshInstances[i].mesh;\n\n\t\t\t\t\tif (this._tempSet.has(mesh)) {\n\t\t\t\t\t\tbakeNodes.push(new BakeMeshNode(node, [meshInstances[i]]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnotInstancedMeshInstances.push(meshInstances[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._tempSet.add(mesh);\n\t\t\t\t}\n\n\t\t\t\tthis._tempSet.clear();\n\n\t\t\t\tif (notInstancedMeshInstances.length > 0) {\n\t\t\t\t\tbakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\tthis.collectModels(node._children[i], bakeNodes, allNodes);\n\t\t}\n\t}\n\n\tprepareShadowCasters(nodes) {\n\t\tconst casters = [];\n\n\t\tfor (let n = 0; n < nodes.length; n++) {\n\t\t\tconst component = nodes[n].component;\n\t\t\tcomponent.castShadows = component.castShadowsLightmap;\n\n\t\t\tif (component.castShadowsLightmap) {\n\t\t\t\tconst meshes = nodes[n].meshInstances;\n\n\t\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\t\tmeshes[i].visibleThisFrame = true;\n\t\t\t\t\tcasters.push(meshes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn casters;\n\t}\n\n\tupdateTransforms(nodes) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst meshInstances = nodes[i].meshInstances;\n\n\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\tmeshInstances[j].node.getWorldTransform();\n\t\t\t}\n\t\t}\n\t}\n\n\tcalculateLightmapSize(node) {\n\t\tlet data;\n\t\tconst sizeMult = this.scene.lightmapSizeMultiplier || 16;\n\t\tconst scale = tempVec;\n\t\tlet srcArea, lightmapSizeMultiplier;\n\n\t\tif (node.model) {\n\t\t\tlightmapSizeMultiplier = node.model.lightmapSizeMultiplier;\n\n\t\t\tif (node.model.asset) {\n\t\t\t\tdata = this.assets.get(node.model.asset).data;\n\n\t\t\t\tif (data.area) {\n\t\t\t\t\tsrcArea = data.area;\n\t\t\t\t}\n\t\t\t} else if (node.model._area) {\n\t\t\t\tdata = node.model;\n\n\t\t\t\tif (data._area) {\n\t\t\t\t\tsrcArea = data._area;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.render) {\n\t\t\tlightmapSizeMultiplier = node.render.lightmapSizeMultiplier;\n\n\t\t\tif (node.render.type !== 'asset') {\n\t\t\t\tif (node.render._area) {\n\t\t\t\t\tdata = node.render;\n\n\t\t\t\t\tif (data._area) {\n\t\t\t\t\t\tsrcArea = data._area;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst area = {\n\t\t\tx: 1,\n\t\t\ty: 1,\n\t\t\tz: 1,\n\t\t\tuv: 1\n\t\t};\n\n\t\tif (srcArea) {\n\t\t\tarea.x = srcArea.x;\n\t\t\tarea.y = srcArea.y;\n\t\t\tarea.z = srcArea.z;\n\t\t\tarea.uv = srcArea.uv;\n\t\t}\n\n\t\tconst areaMult = lightmapSizeMultiplier || 1;\n\t\tarea.x *= areaMult;\n\t\tarea.y *= areaMult;\n\t\tarea.z *= areaMult;\n\t\tconst component = node.render || node.model;\n\t\tconst bounds = this.computeNodeBounds(component.meshInstances);\n\t\tscale.copy(bounds.halfExtents);\n\t\tlet totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;\n\t\ttotalArea /= area.uv;\n\t\ttotalArea = Math.sqrt(totalArea);\n\t\tconst lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);\n\t\treturn lightmapSize;\n\t}\n\n\tsetLightmapping(nodes, value, passCount, shaderDefs) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tconst meshInstances = node.meshInstances;\n\n\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\tconst meshInstance = meshInstances[j];\n\t\t\t\tmeshInstance.setLightmapped(value);\n\n\t\t\t\tif (value) {\n\t\t\t\t\tif (shaderDefs) {\n\t\t\t\t\t\tmeshInstance._shaderDefs |= shaderDefs;\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshInstance.mask = MASK_AFFECT_LIGHTMAPPED;\n\n\t\t\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\t\t\tconst tex = node.renderTargets[pass].colorBuffer;\n\t\t\t\t\t\ttex.minFilter = FILTER_LINEAR;\n\t\t\t\t\t\ttex.magFilter = FILTER_LINEAR;\n\t\t\t\t\t\tmeshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbake(nodes, mode = BAKE_COLORDIR) {\n\t\tconst device = this.device;\n\t\tconst startTime = now();\n\n\t\tthis.scene._updateSkybox(device);\n\n\t\tthis.stats.renderPasses = 0;\n\t\tthis.stats.shadowMapTime = 0;\n\t\tthis.stats.forwardTime = 0;\n\t\tconst startShaders = device._shaderStats.linked;\n\t\tconst startFboTime = device._renderTargetCreationTime;\n\t\tconst startCompileTime = device._shaderStats.compileTime;\n\t\tconst bakeNodes = [];\n\t\tconst allNodes = [];\n\n\t\tif (nodes) {\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tthis.collectModels(nodes[i], bakeNodes, null);\n\t\t\t}\n\n\t\t\tthis.collectModels(this.root, null, allNodes);\n\t\t} else {\n\t\t\tthis.collectModels(this.root, bakeNodes, allNodes);\n\t\t}\n\n\t\tif (bakeNodes.length > 0) {\n\t\t\tconst passCount = mode === BAKE_COLORDIR ? 2 : 1;\n\t\t\tthis.setLightmapping(bakeNodes, false, passCount);\n\t\t\tthis.initBake(device);\n\t\t\tthis.bakeInternal(passCount, bakeNodes, allNodes);\n\t\t\tlet shaderDefs = SHADERDEF_LM;\n\n\t\t\tif (mode === BAKE_COLORDIR) {\n\t\t\t\tshaderDefs |= SHADERDEF_DIRLM;\n\t\t\t}\n\n\t\t\tif (this.scene.ambientBake) {\n\t\t\t\tshaderDefs |= SHADERDEF_LMAMBIENT;\n\t\t\t}\n\n\t\t\tthis.setLightmapping(bakeNodes, true, passCount, shaderDefs);\n\t\t\tthis.finishBake(bakeNodes);\n\t\t}\n\n\t\tconst nowTime = now();\n\t\tthis.stats.totalRenderTime = nowTime - startTime;\n\t\tthis.stats.shadersLinked = device._shaderStats.linked - startShaders;\n\t\tthis.stats.compileTime = device._shaderStats.compileTime - startCompileTime;\n\t\tthis.stats.fboTime = device._renderTargetCreationTime - startFboTime;\n\t\tthis.stats.lightmapCount = bakeNodes.length;\n\t}\n\n\tallocateTextures(bakeNodes, passCount) {\n\t\tfor (let i = 0; i < bakeNodes.length; i++) {\n\t\t\tconst bakeNode = bakeNodes[i];\n\t\t\tconst size = this.calculateLightmapSize(bakeNode.node);\n\n\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\tconst tex = this.createTexture(size, TEXTURETYPE_DEFAULT, \"lightmapper_lightmap_\" + i);\n\t\t\t\tLightmapCache.incRef(tex);\n\t\t\t\tbakeNode.renderTargets[pass] = new RenderTarget({\n\t\t\t\t\tcolorBuffer: tex,\n\t\t\t\t\tdepth: false\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!this.renderTargets.has(size)) {\n\t\t\t\tconst tex = this.createTexture(size, TEXTURETYPE_DEFAULT, \"lightmapper_temp_lightmap_\" + size);\n\t\t\t\tLightmapCache.incRef(tex);\n\t\t\t\tthis.renderTargets.set(size, new RenderTarget({\n\t\t\t\t\tcolorBuffer: tex,\n\t\t\t\t\tdepth: false\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t}\n\n\tprepareLightsToBake(layerComposition, allLights, bakeLights) {\n\t\tif (this.scene.ambientBake) {\n\t\t\tconst ambientLight = new BakeLightAmbient(this.scene);\n\t\t\tbakeLights.push(ambientLight);\n\t\t}\n\n\t\tconst sceneLights = layerComposition._lights;\n\n\t\tfor (let i = 0; i < sceneLights.length; i++) {\n\t\t\tconst light = sceneLights[i];\n\t\t\tconst bakeLight = new BakeLightSimple(this.scene, light);\n\t\t\tallLights.push(bakeLight);\n\n\t\t\tif (light.enabled && (light.mask & MASK_BAKE) !== 0) {\n\t\t\t\tlight.isStatic = false;\n\t\t\t\tlight.mask = 0xFFFFFFFF;\n\t\t\t\tlight.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;\n\t\t\t\tbakeLights.push(bakeLight);\n\t\t\t}\n\t\t}\n\n\t\tbakeLights.sort();\n\t}\n\n\trestoreLights(allLights) {\n\t\tfor (let i = 0; i < allLights.length; i++) {\n\t\t\tallLights[i].restore();\n\t\t}\n\t}\n\n\tsetupScene() {\n\t\tthis.revertStatic = false;\n\n\t\tif (this.scene._needsStaticPrepare) {\n\t\t\tthis.scene._needsStaticPrepare = false;\n\t\t\tthis.revertStatic = true;\n\t\t}\n\n\t\tthis.fog = this.scene.fog;\n\t\tthis.ambientLight.copy(this.scene.ambientLight);\n\t\tthis.scene.fog = FOG_NONE;\n\n\t\tif (!this.scene.ambientBake) {\n\t\t\tthis.scene.ambientLight.set(0, 0, 0);\n\t\t}\n\n\t\tthis.renderer.setSceneConstants();\n\t}\n\n\trestoreScene() {\n\t\tthis.scene.fog = this.fog;\n\t\tthis.scene.ambientLight.copy(this.ambientLight);\n\n\t\tif (this.revertStatic) {\n\t\t\tthis.scene._needsStaticPrepare = true;\n\t\t}\n\t}\n\n\tcomputeNodeBounds(meshInstances) {\n\t\tconst bounds = new BoundingBox();\n\n\t\tif (meshInstances.length > 0) {\n\t\t\tbounds.copy(meshInstances[0].aabb);\n\n\t\t\tfor (let m = 1; m < meshInstances.length; m++) {\n\t\t\t\tbounds.add(meshInstances[m].aabb);\n\t\t\t}\n\t\t}\n\n\t\treturn bounds;\n\t}\n\n\tcomputeNodesBounds(nodes) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst meshInstances = nodes[i].meshInstances;\n\t\t\tnodes[i].bounds = this.computeNodeBounds(meshInstances);\n\t\t}\n\t}\n\n\tcomputeBounds(meshInstances) {\n\t\tconst bounds = new BoundingBox();\n\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tbounds.copy(meshInstances[0].aabb);\n\n\t\t\tfor (let m = 1; m < meshInstances.length; m++) {\n\t\t\t\tbounds.add(meshInstances[m].aabb);\n\t\t\t}\n\t\t}\n\n\t\treturn bounds;\n\t}\n\n\tbackupMaterials(meshInstances) {\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tthis.materials[i] = meshInstances[i].material;\n\t\t}\n\t}\n\n\trestoreMaterials(meshInstances) {\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].material = this.materials[i];\n\t\t}\n\t}\n\n\tlightCameraPrepare(device, bakeLight) {\n\t\tconst light = bakeLight.light;\n\t\tlet shadowCam;\n\n\t\tif (light.type === LIGHTTYPE_SPOT) {\n\t\t\tconst lightRenderData = light.getRenderData(null, 0);\n\t\t\tshadowCam = lightRenderData.shadowCamera;\n\n\t\t\tshadowCam._node.setPosition(light._node.getPosition());\n\n\t\t\tshadowCam._node.setRotation(light._node.getRotation());\n\n\t\t\tshadowCam._node.rotateLocal(-90, 0, 0);\n\n\t\t\tshadowCam.projection = PROJECTION_PERSPECTIVE;\n\t\t\tshadowCam.nearClip = light.attenuationEnd / 1000;\n\t\t\tshadowCam.farClip = light.attenuationEnd;\n\t\t\tshadowCam.aspectRatio = 1;\n\t\t\tshadowCam.fov = light._outerConeAngle * 2;\n\t\t\tthis.renderer.updateCameraFrustum(shadowCam);\n\t\t}\n\n\t\treturn shadowCam;\n\t}\n\n\tlightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {\n\t\tconst light = bakeLight.light;\n\t\tlet lightAffectsNode = true;\n\n\t\tif (light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\ttempVec.copy(casterBounds.center);\n\t\t\ttempVec.y += casterBounds.halfExtents.y;\n\t\t\tthis.camera.node.setPosition(tempVec);\n\t\t\tthis.camera.node.setEulerAngles(-90, 0, 0);\n\t\t\tthis.camera.nearClip = 0;\n\t\t\tthis.camera.farClip = casterBounds.halfExtents.y * 2;\n\t\t\tconst frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);\n\t\t\tthis.camera.orthoHeight = frustumSize;\n\t\t} else {\n\t\t\tif (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {\n\t\t\t\tlightAffectsNode = false;\n\t\t\t}\n\t\t}\n\n\t\tif (light.type === LIGHTTYPE_SPOT) {\n\t\t\tlet nodeVisible = false;\n\t\t\tconst meshInstances = bakeNode.meshInstances;\n\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (meshInstances[i]._isVisible(shadowCam)) {\n\t\t\t\t\tnodeVisible = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!nodeVisible) {\n\t\t\t\tlightAffectsNode = false;\n\t\t\t}\n\t\t}\n\n\t\treturn lightAffectsNode;\n\t}\n\n\tsetupLightArray(lightArray, light) {\n\t\tlightArray[LIGHTTYPE_DIRECTIONAL].length = 0;\n\t\tlightArray[LIGHTTYPE_OMNI].length = 0;\n\t\tlightArray[LIGHTTYPE_SPOT].length = 0;\n\t\tlightArray[light.type][0] = light;\n\t\tlight.visibleThisFrame = true;\n\t}\n\n\trenderShadowMap(shadowMapRendered, casters, lightArray, bakeLight) {\n\t\tconst light = bakeLight.light;\n\n\t\tif (!shadowMapRendered && light.castShadows) {\n\t\t\tif (!light.shadowMap && !this.scene.clusteredLightingEnabled) {\n\t\t\t\tlight.shadowMap = this.shadowMapCache.get(this.device, light);\n\t\t\t}\n\n\t\t\tif (light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tthis.renderer._shadowRenderer.cullDirectional(light, casters, this.camera);\n\t\t\t} else {\n\t\t\t\tthis.renderer._shadowRenderer.cullLocal(light, casters);\n\t\t\t}\n\n\t\t\tthis.renderer.renderShadows(lightArray[light.type], this.camera);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpostprocessTextures(device, bakeNodes, passCount) {\n\t\tconst numDilates2x = 1;\n\t\tconst dilateShader = this.lightmapFilters.shaderDilate;\n\t\tconst filterLightmap = this.scene.lightmapFilterEnabled;\n\n\t\tif (filterLightmap) {\n\t\t\tthis.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);\n\t\t}\n\n\t\tfor (let node = 0; node < bakeNodes.length; node++) {\n\t\t\tconst bakeNode = bakeNodes[node];\n\n\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\tconst nodeRT = bakeNode.renderTargets[pass];\n\t\t\t\tconst lightmap = nodeRT.colorBuffer;\n\t\t\t\tconst tempRT = this.renderTargets.get(lightmap.width);\n\t\t\t\tconst tempTex = tempRT.colorBuffer;\n\t\t\t\tthis.lightmapFilters.prepare(lightmap.width, lightmap.height);\n\n\t\t\t\tfor (let i = 0; i < numDilates2x; i++) {\n\t\t\t\t\tthis.lightmapFilters.setSourceTexture(lightmap);\n\t\t\t\t\tconst bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;\n\t\t\t\t\tdrawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);\n\t\t\t\t\tthis.lightmapFilters.setSourceTexture(tempTex);\n\t\t\t\t\tdrawQuadWithShader(device, nodeRT, dilateShader);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbakeInternal(passCount, bakeNodes, allNodes) {\n\t\tconst scene = this.scene;\n\t\tconst device = this.device;\n\t\tconst clusteredLightingEnabled = scene.clusteredLightingEnabled;\n\t\tthis.createMaterials(device, scene, passCount);\n\t\tthis.setupScene();\n\n\t\tscene.layers._update();\n\n\t\tthis.computeNodesBounds(bakeNodes);\n\t\tthis.allocateTextures(bakeNodes, passCount);\n\t\tconst allLights = [],\n\t\t\t\t\tbakeLights = [];\n\t\tthis.prepareLightsToBake(scene.layers, allLights, bakeLights);\n\t\tthis.updateTransforms(allNodes);\n\t\tconst casters = this.prepareShadowCasters(allNodes);\n\t\tthis.renderer.updateCpuSkinMatrices(casters);\n\t\tthis.renderer.gpuUpdate(casters);\n\t\tconst casterBounds = this.computeBounds(casters);\n\t\tlet i, j, rcv, m;\n\n\t\tfor (i = 0; i < bakeNodes.length; i++) {\n\t\t\tconst bakeNode = bakeNodes[i];\n\t\t\trcv = bakeNode.meshInstances;\n\n\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\tm = rcv[j];\n\t\t\t\tm.setLightmapped(false);\n\t\t\t\tm.mask = MASK_BAKE;\n\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex);\n\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < bakeLights.length; j++) {\n\t\t\tbakeLights[j].light.enabled = false;\n\t\t}\n\n\t\tconst lightArray = [[], [], []];\n\t\tlet pass, node;\n\t\tlet shadersUpdatedOn1stPass = false;\n\n\t\tfor (i = 0; i < bakeLights.length; i++) {\n\t\t\tconst bakeLight = bakeLights[i];\n\t\t\tconst isAmbientLight = bakeLight instanceof BakeLightAmbient;\n\t\t\tlet numVirtualLights = bakeLight.numVirtualLights;\n\n\t\t\tif (passCount > 1 && numVirtualLights > 1) {\n\t\t\t\tnumVirtualLights = 1;\n\t\t\t}\n\n\t\t\tfor (let virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {\n\t\t\t\tif (numVirtualLights > 1) {\n\t\t\t\t\tbakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);\n\t\t\t\t}\n\n\t\t\t\tbakeLight.startBake();\n\t\t\t\tlet shadowMapRendered = false;\n\t\t\t\tconst shadowCam = this.lightCameraPrepare(device, bakeLight);\n\n\t\t\t\tfor (node = 0; node < bakeNodes.length; node++) {\n\t\t\t\t\tconst bakeNode = bakeNodes[node];\n\t\t\t\t\trcv = bakeNode.meshInstances;\n\t\t\t\t\tconst lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds);\n\n\t\t\t\t\tif (!lightAffectsNode) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setupLightArray(lightArray, bakeLight.light);\n\n\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\tthis.renderer.lightTextureAtlas.update(lightArray[LIGHTTYPE_SPOT], lightArray[LIGHTTYPE_OMNI], this.lightingParams);\n\t\t\t\t\t}\n\n\t\t\t\t\tshadowMapRendered = this.renderShadowMap(shadowMapRendered, casters, lightArray, bakeLight);\n\n\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\tconst clusterLights = lightArray[LIGHTTYPE_SPOT].concat(lightArray[LIGHTTYPE_OMNI]);\n\t\t\t\t\t\tthis.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.backupMaterials(rcv);\n\n\t\t\t\t\tfor (pass = 0; pass < passCount; pass++) {\n\t\t\t\t\t\tif (pass > 0 && virtualLightIndex > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isAmbientLight && pass > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst nodeRT = bakeNode.renderTargets[pass];\n\t\t\t\t\t\tconst lightmapSize = bakeNode.renderTargets[pass].colorBuffer.width;\n\t\t\t\t\t\tconst tempRT = this.renderTargets.get(lightmapSize);\n\t\t\t\t\t\tconst tempTex = tempRT.colorBuffer;\n\n\t\t\t\t\t\tif (pass === 0) {\n\t\t\t\t\t\t\tshadersUpdatedOn1stPass = scene.updateShaders;\n\t\t\t\t\t\t} else if (shadersUpdatedOn1stPass) {\n\t\t\t\t\t\t\tscene.updateShaders = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet passMaterial = this.passMaterials[pass];\n\n\t\t\t\t\t\tif (isAmbientLight) {\n\t\t\t\t\t\t\tconst lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;\n\n\t\t\t\t\t\t\tif (lastVirtualLightForPass && pass === 0) {\n\t\t\t\t\t\t\t\tpassMaterial = this.ambientAOMaterial;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\t\t\t\trcv[j].material = passMaterial;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.renderer.updateShaders(rcv);\n\t\t\t\t\t\tthis.renderer.setCamera(this.camera, tempRT, true);\n\n\t\t\t\t\t\tif (pass === PASS_DIR) {\n\t\t\t\t\t\t\tthis.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\t\tthis.worldClusters.activate(this.renderer.lightTextureAtlas);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.renderer._forwardTime = 0;\n\t\t\t\t\t\tthis.renderer._shadowMapTime = 0;\n\t\t\t\t\t\tthis.renderer.renderForward(this.camera, rcv, rcv.length, lightArray, SHADER_FORWARDHDR);\n\t\t\t\t\t\tbakeNode.renderTargets[pass] = tempRT;\n\t\t\t\t\t\tthis.renderTargets.set(lightmapSize, nodeRT);\n\n\t\t\t\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\t\t\t\tm = rcv[j];\n\t\t\t\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);\n\t\t\t\t\t\t\tm._shaderDefs |= SHADERDEF_LM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.restoreMaterials(rcv);\n\t\t\t\t}\n\n\t\t\t\tbakeLight.endBake(this.shadowMapCache);\n\t\t\t}\n\t\t}\n\n\t\tthis.postprocessTextures(device, bakeNodes, passCount);\n\n\t\tfor (node = 0; node < allNodes.length; node++) {\n\t\t\tallNodes[node].restore();\n\t\t}\n\n\t\tthis.restoreLights(allLights);\n\t\tthis.restoreScene();\n\n\t\tif (!clusteredLightingEnabled) {\n\t\t\tthis.shadowMapCache.clear();\n\t\t}\n\t}\n\n}\n\nconst tempSet = new Set();\nconst clearDepthOptions = {\n\tdepth: 1.0,\n\tflags: CLEARFLAG_DEPTH\n};\n\nclass Picker {\n\tconstructor(app, width, height) {\n\t\tif (app instanceof GraphicsDevice) {\n\t\t\tapp = getApplication();\n\t\t}\n\n\t\tthis.app = app;\n\t\tthis.device = app.graphicsDevice;\n\t\tthis.pickColor = new Float32Array(4);\n\t\tthis.pickColor[3] = 1;\n\t\tthis.mapping = [];\n\t\tthis.cameraEntity = null;\n\t\tthis.layer = null;\n\t\tthis.layerComp = null;\n\t\tthis.initLayerComposition();\n\t\tthis._renderTarget = null;\n\t\tconst device = this.device;\n\t\tthis.clearDepthCommand = new Command(0, 0, function () {\n\t\t\tdevice.clear(clearDepthOptions);\n\t\t});\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\tthis.resize(width, height);\n\t}\n\n\tgetSelection(x, y, width, height) {\n\t\tconst device = this.device;\n\n\t\tif (typeof x === 'object') {\n\t\t\tconst rect = x;\n\t\t\tx = rect.x;\n\t\t\ty = rect.y;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\t\t} else {\n\t\t\ty = this.renderTarget.height - (y + (height || 1));\n\t\t}\n\n\t\tx = Math.floor(x);\n\t\ty = Math.floor(y);\n\t\twidth = Math.floor(Math.max(width || 1, 1));\n\t\theight = Math.floor(Math.max(height || 1, 1));\n\t\tconst origRenderTarget = device.renderTarget;\n\t\tdevice.setRenderTarget(this.renderTarget);\n\t\tdevice.updateBegin();\n\t\tconst pixels = new Uint8Array(4 * width * height);\n\t\tdevice.readPixels(x, y, width, height, pixels);\n\t\tdevice.updateEnd();\n\t\tdevice.setRenderTarget(origRenderTarget);\n\t\tconst mapping = this.mapping;\n\n\t\tfor (let i = 0; i < width * height; i++) {\n\t\t\tconst r = pixels[4 * i + 0];\n\t\t\tconst g = pixels[4 * i + 1];\n\t\t\tconst b = pixels[4 * i + 2];\n\t\t\tconst index = r << 16 | g << 8 | b;\n\n\t\t\tif (index !== 0xffffff) {\n\t\t\t\ttempSet.add(mapping[index]);\n\t\t\t}\n\t\t}\n\n\t\tconst selection = [];\n\t\ttempSet.forEach(meshInstance => selection.push(meshInstance));\n\t\ttempSet.clear();\n\t\treturn selection;\n\t}\n\n\tallocateRenderTarget() {\n\t\tconst colorBuffer = new Texture(this.device, {\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\twidth: this.width,\n\t\t\theight: this.height,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tcolorBuffer.name = 'pick';\n\t\tthis.renderTarget = new RenderTarget({\n\t\t\tcolorBuffer: colorBuffer,\n\t\t\tdepth: true\n\t\t});\n\t}\n\n\treleaseRenderTarget() {\n\t\tthis.cameraEntity.camera.renderTarget = null;\n\n\t\tif (this._renderTarget) {\n\t\t\tthis._renderTarget._colorBuffer.destroy();\n\n\t\t\tthis._renderTarget.destroy();\n\n\t\t\tthis._renderTarget = null;\n\t\t}\n\t}\n\n\tinitLayerComposition() {\n\t\tconst device = this.device;\n\t\tconst self = this;\n\t\tconst pickColorId = device.scope.resolve('uColor');\n\t\tthis.cameraEntity = new Entity();\n\t\tthis.cameraEntity.addComponent(\"camera\");\n\t\tthis.layer = new Layer({\n\t\t\tname: \"Picker\",\n\t\t\tshaderPass: SHADER_PICK,\n\t\t\topaqueSortMode: SORTMODE_NONE,\n\t\t\tonDrawCall: function (meshInstance, index) {\n\t\t\t\tself.pickColor[0] = (index >> 16 & 0xff) / 255;\n\t\t\t\tself.pickColor[1] = (index >> 8 & 0xff) / 255;\n\t\t\t\tself.pickColor[2] = (index & 0xff) / 255;\n\t\t\t\tpickColorId.setValue(self.pickColor);\n\t\t\t\tdevice.setBlending(false);\n\t\t\t\tself.mapping[index] = meshInstance;\n\t\t\t}\n\t\t});\n\t\tthis.layer.addCamera(this.cameraEntity.camera);\n\t\tthis.layerComp = new LayerComposition(\"picker\");\n\t\tthis.layerComp.pushOpaque(this.layer);\n\t}\n\n\tprepare(camera, scene, layers) {\n\t\tif (camera instanceof Camera) {\n\t\t\tcamera = camera.node.camera;\n\t\t}\n\n\t\tif (layers instanceof Layer) {\n\t\t\tlayers = [layers];\n\t\t}\n\n\t\tthis.layer.clearMeshInstances();\n\t\tconst destMeshInstances = this.layer.opaqueMeshInstances;\n\t\tconst srcLayers = scene.layers.layerList;\n\t\tconst subLayerEnabled = scene.layers.subLayerEnabled;\n\t\tconst isTransparent = scene.layers.subLayerList;\n\n\t\tfor (let i = 0; i < srcLayers.length; i++) {\n\t\t\tconst srcLayer = srcLayers[i];\n\n\t\t\tif (layers && layers.indexOf(srcLayer) < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (srcLayer.enabled && subLayerEnabled[i]) {\n\t\t\t\tconst layerCamId = srcLayer.cameras.indexOf(camera);\n\n\t\t\t\tif (layerCamId >= 0) {\n\t\t\t\t\tif (srcLayer._clearDepthBuffer) {\n\t\t\t\t\t\tdestMeshInstances.push(this.clearDepthCommand);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst meshInstances = isTransparent[i] ? srcLayer.instances.transparentMeshInstances : srcLayer.instances.opaqueMeshInstances;\n\n\t\t\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\t\t\tconst meshInstance = meshInstances[j];\n\n\t\t\t\t\t\tif (meshInstance.pick) {\n\t\t\t\t\t\t\tdestMeshInstances.push(meshInstance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {\n\t\t\tthis.releaseRenderTarget();\n\t\t\tthis.allocateRenderTarget();\n\t\t}\n\n\t\tthis.updateCamera(camera);\n\t\tthis.mapping.length = 0;\n\t\tthis.app.renderer.renderComposition(this.layerComp);\n\t}\n\n\tupdateCamera(srcCamera) {\n\t\tthis.cameraEntity.copy(srcCamera.entity);\n\t\tthis.cameraEntity.name = \"PickerCamera\";\n\t\tconst destCamera = this.cameraEntity.camera;\n\t\tdestCamera.copy(srcCamera);\n\t\tdestCamera.clearColorBuffer = true;\n\t\tdestCamera.clearDepthBuffer = true;\n\t\tdestCamera.clearStencilBuffer = true;\n\t\tdestCamera.clearColor = Color.WHITE;\n\t\tdestCamera.renderTarget = this.renderTarget;\n\t\tthis.layer.clearCameras();\n\t\tthis.layer.addCamera(destCamera);\n\t\tdestCamera.layers = [this.layer.id];\n\t}\n\n\tresize(width, height) {\n\t\tthis.width = Math.floor(width);\n\t\tthis.height = Math.floor(height);\n\t}\n\n}\n\nconst MAX_TEXTURE_SIZE = 4096;\nconst DEFAULT_TEXTURE_SIZE = 512;\n\nclass CanvasFont extends EventHandler {\n\tconstructor(app, options = {}) {\n\t\tsuper();\n\t\tthis.type = \"bitmap\";\n\t\tthis.app = app;\n\t\tthis.intensity = 0;\n\t\tthis.fontWeight = options.fontWeight || 'normal';\n\t\tthis.fontSize = parseInt(options.fontSize, 10);\n\t\tthis.glyphSize = this.fontSize;\n\t\tthis.fontName = options.fontName || 'Arial';\n\t\tthis.color = options.color || new Color(1, 1, 1);\n\t\tthis.padding = options.padding || 0;\n\t\tconst w = options.width > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.width || DEFAULT_TEXTURE_SIZE;\n\t\tconst h = options.height > MAX_TEXTURE_SIZE ? MAX_TEXTURE_SIZE : options.height || DEFAULT_TEXTURE_SIZE;\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.height = h;\n\t\tcanvas.width = w;\n\t\tconst texture = new Texture(this.app.graphicsDevice, {\n\t\t\tname: 'font',\n\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\tminFilter: FILTER_LINEAR_MIPMAP_LINEAR,\n\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tmipmaps: true\n\t\t});\n\t\ttexture.setSource(canvas);\n\t\tthis.textures = [texture];\n\t\tthis.chars = \"\";\n\t\tthis.data = {};\n\t}\n\n\tcreateTextures(text) {\n\t\tconst _chars = this._normalizeCharsSet(text);\n\n\t\tif (_chars.length !== this.chars.length) {\n\t\t\tthis._renderAtlas(_chars);\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < _chars.length; i++) {\n\t\t\tif (_chars[i] !== this.chars[i]) {\n\t\t\t\tthis._renderAtlas(_chars);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateTextures(text) {\n\t\tconst _chars = this._normalizeCharsSet(text);\n\n\t\tconst newCharsSet = [];\n\n\t\tfor (let i = 0; i < _chars.length; i++) {\n\t\t\tconst char = _chars[i];\n\n\t\t\tif (!this.data.chars[char]) {\n\t\t\t\tnewCharsSet.push(char);\n\t\t\t}\n\t\t}\n\n\t\tif (newCharsSet.length > 0) {\n\t\t\tthis._renderAtlas(this.chars.concat(newCharsSet));\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tfor (let i = 0; i < this.textures.length; i++) {\n\t\t\tthis.textures[i].destroy();\n\t\t}\n\n\t\tthis.chars = null;\n\t\tthis.color = null;\n\t\tthis.data = null;\n\t\tthis.fontName = null;\n\t\tthis.fontSize = null;\n\t\tthis.glyphSize = null;\n\t\tthis.intensity = null;\n\t\tthis.textures = null;\n\t\tthis.type = null;\n\t\tthis.fontWeight = null;\n\t}\n\n\t_getAndClearContext(canvas, clearColor) {\n\t\tconst w = canvas.width;\n\t\tconst h = canvas.height;\n\t\tconst ctx = canvas.getContext('2d', {\n\t\t\talpha: true\n\t\t});\n\t\tctx.clearRect(0, 0, w, h);\n\t\tctx.fillStyle = clearColor;\n\t\tctx.fillRect(0, 0, w, h);\n\t\treturn ctx;\n\t}\n\n\t_colorToRgbString(color, alpha) {\n\t\tlet str;\n\t\tconst r = Math.round(255 * color.r);\n\t\tconst g = Math.round(255 * color.g);\n\t\tconst b = Math.round(255 * color.b);\n\n\t\tif (alpha) {\n\t\t\tstr = `rgba(${r}, ${g}, ${b}, ${color.a})`;\n\t\t} else {\n\t\t\tstr = `rgb(${r}, ${g}, ${b})`;\n\t\t}\n\n\t\treturn str;\n\t}\n\n\trenderCharacter(context, char, x, y, color) {\n\t\tcontext.fillStyle = color;\n\t\tcontext.fillText(char, x, y);\n\t}\n\n\t_renderAtlas(charsArray) {\n\t\tthis.chars = charsArray;\n\t\tlet numTextures = 1;\n\t\tlet canvas = this.textures[numTextures - 1].getSource();\n\t\tconst w = canvas.width;\n\t\tconst h = canvas.height;\n\n\t\tconst color = this._colorToRgbString(this.color, false);\n\n\t\tconst a = this.color.a;\n\t\tthis.color.a = 1 / 255;\n\n\t\tconst transparent = this._colorToRgbString(this.color, true);\n\n\t\tthis.color.a = a;\n\t\tconst TEXT_ALIGN = 'center';\n\t\tconst TEXT_BASELINE = 'alphabetic';\n\n\t\tlet ctx = this._getAndClearContext(canvas, transparent);\n\n\t\tctx.font = this.fontWeight + ' ' + this.fontSize.toString() + 'px ' + this.fontName;\n\t\tctx.textAlign = TEXT_ALIGN;\n\t\tctx.textBaseline = TEXT_BASELINE;\n\t\tthis.data = this._createJson(this.chars, this.fontName, w, h);\n\t\tconst symbols = string.getSymbols(this.chars.join(''));\n\t\tconst prevNumTextures = this.textures.length;\n\t\tlet maxHeight = 0;\n\t\tlet maxDescent = 0;\n\t\tconst metrics = {};\n\n\t\tfor (let i = 0; i < symbols.length; i++) {\n\t\t\tconst ch = symbols[i];\n\t\t\tmetrics[ch] = this._getTextMetrics(ch);\n\t\t\tmaxHeight = Math.max(maxHeight, metrics[ch].height);\n\t\t\tmaxDescent = Math.max(maxDescent, metrics[ch].descent);\n\t\t}\n\n\t\tthis.glyphSize = Math.max(this.glyphSize, maxHeight);\n\t\tconst sx = this.glyphSize + this.padding * 2;\n\t\tconst sy = this.glyphSize + this.padding * 2;\n\n\t\tconst _xOffset = this.glyphSize / 2 + this.padding;\n\n\t\tconst _yOffset = sy - maxDescent - this.padding;\n\n\t\tlet _x = 0;\n\t\tlet _y = 0;\n\n\t\tfor (let i = 0; i < symbols.length; i++) {\n\t\t\tconst ch = symbols[i];\n\t\t\tconst code = string.getCodePoint(symbols[i]);\n\t\t\tlet fs = this.fontSize;\n\t\t\tctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;\n\t\t\tctx.textAlign = TEXT_ALIGN;\n\t\t\tctx.textBaseline = TEXT_BASELINE;\n\t\t\tlet width = ctx.measureText(ch).width;\n\n\t\t\tif (width > fs) {\n\t\t\t\tfs = this.fontSize * this.fontSize / width;\n\t\t\t\tctx.font = this.fontWeight + ' ' + fs.toString() + 'px ' + this.fontName;\n\t\t\t\twidth = this.fontSize;\n\t\t\t}\n\n\t\t\tthis.renderCharacter(ctx, ch, _x + _xOffset, _y + _yOffset, color);\n\t\t\tconst xoffset = this.padding + (this.glyphSize - width) / 2;\n\t\t\tconst yoffset = -this.padding + metrics[ch].descent - maxDescent;\n\t\t\tconst xadvance = width;\n\n\t\t\tthis._addChar(this.data, ch, code, _x, _y, sx, sy, xoffset, yoffset, xadvance, numTextures - 1, w, h);\n\n\t\t\t_x += sx;\n\n\t\t\tif (_x + sx > w) {\n\t\t\t\t_x = 0;\n\t\t\t\t_y += sy;\n\n\t\t\t\tif (_y + sy > h) {\n\t\t\t\t\tthis.textures[numTextures - 1].upload();\n\t\t\t\t\tnumTextures++;\n\t\t\t\t\t_y = 0;\n\n\t\t\t\t\tif (numTextures > prevNumTextures) {\n\t\t\t\t\t\tcanvas = document.createElement('canvas');\n\t\t\t\t\t\tcanvas.height = h;\n\t\t\t\t\t\tcanvas.width = w;\n\t\t\t\t\t\tctx = this._getAndClearContext(canvas, transparent);\n\t\t\t\t\t\tconst texture = new Texture(this.app.graphicsDevice, {\n\t\t\t\t\t\t\tformat: PIXELFORMAT_R8_G8_B8_A8,\n\t\t\t\t\t\t\tmipmaps: true\n\t\t\t\t\t\t});\n\t\t\t\t\t\ttexture.name = 'font-atlas';\n\t\t\t\t\t\ttexture.setSource(canvas);\n\t\t\t\t\t\ttexture.minFilter = FILTER_LINEAR_MIPMAP_LINEAR;\n\t\t\t\t\t\ttexture.magFilter = FILTER_LINEAR;\n\t\t\t\t\t\ttexture.addressU = ADDRESS_CLAMP_TO_EDGE;\n\t\t\t\t\t\ttexture.addressV = ADDRESS_CLAMP_TO_EDGE;\n\t\t\t\t\t\tthis.textures.push(texture);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanvas = this.textures[numTextures - 1].getSource();\n\t\t\t\t\t\tctx = this._getAndClearContext(canvas, transparent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.textures[numTextures - 1].upload();\n\n\t\tif (numTextures < prevNumTextures) {\n\t\t\tfor (let i = numTextures; i < prevNumTextures; i++) {\n\t\t\t\tthis.textures[i].destroy();\n\t\t\t}\n\n\t\t\tthis.textures.splice(numTextures);\n\t\t}\n\n\t\tthis.fire(\"render\");\n\t}\n\n\t_createJson(chars, fontName, width, height) {\n\t\tconst base = {\n\t\t\t\"version\": 3,\n\t\t\t\"intensity\": this.intensity,\n\t\t\t\"info\": {\n\t\t\t\t\"face\": fontName,\n\t\t\t\t\"width\": width,\n\t\t\t\t\"height\": height,\n\t\t\t\t\"maps\": [{\n\t\t\t\t\t\"width\": width,\n\t\t\t\t\t\"height\": height\n\t\t\t\t}]\n\t\t\t},\n\t\t\t\"chars\": {}\n\t\t};\n\t\treturn base;\n\t}\n\n\t_addChar(json, char, charCode, x, y, w, h, xoffset, yoffset, xadvance, mapNum, mapW, mapH) {\n\t\tif (json.info.maps.length < mapNum + 1) {\n\t\t\tjson.info.maps.push({\n\t\t\t\t\"width\": mapW,\n\t\t\t\t\"height\": mapH\n\t\t\t});\n\t\t}\n\n\t\tconst scale = this.fontSize / 32;\n\t\tjson.chars[char] = {\n\t\t\t\"id\": charCode,\n\t\t\t\"letter\": char,\n\t\t\t\"x\": x,\n\t\t\t\"y\": y,\n\t\t\t\"width\": w,\n\t\t\t\"height\": h,\n\t\t\t\"xadvance\": xadvance / scale,\n\t\t\t\"xoffset\": xoffset / scale,\n\t\t\t\"yoffset\": (yoffset + this.padding) / scale,\n\t\t\t\"scale\": scale,\n\t\t\t\"range\": 1,\n\t\t\t\"map\": mapNum,\n\t\t\t\"bounds\": [0, 0, w / scale, h / scale]\n\t\t};\n\t}\n\n\t_normalizeCharsSet(text) {\n\t\tconst unicodeConverterFunc = this.app.systems.element.getUnicodeConverter();\n\n\t\tif (unicodeConverterFunc) {\n\t\t\ttext = unicodeConverterFunc(text);\n\t\t}\n\n\t\tconst set = {};\n\t\tconst symbols = string.getSymbols(text);\n\n\t\tfor (let i = 0; i < symbols.length; i++) {\n\t\t\tconst ch = symbols[i];\n\t\t\tif (set[ch]) continue;\n\t\t\tset[ch] = ch;\n\t\t}\n\n\t\tconst chars = Object.keys(set);\n\t\treturn chars.sort();\n\t}\n\n\t_getTextMetrics(text) {\n\t\tconst textSpan = document.createElement('span');\n\t\ttextSpan.id = 'content-span';\n\t\ttextSpan.innerHTML = text;\n\t\tconst block = document.createElement(\"div\");\n\t\tblock.id = 'content-block';\n\t\tblock.style.display = 'inline-block';\n\t\tblock.style.width = '1px';\n\t\tblock.style.height = '0px';\n\t\tconst div = document.createElement('div');\n\t\tdiv.appendChild(textSpan);\n\t\tdiv.appendChild(block);\n\t\tdiv.style.font = this.fontSize + 'px ' + this.fontName;\n\t\tconst body = document.body;\n\t\tbody.appendChild(div);\n\t\tlet ascent = -1;\n\t\tlet descent = -1;\n\t\tlet height = -1;\n\n\t\ttry {\n\t\t\tblock.style['vertical-align'] = 'baseline';\n\t\t\tascent = block.offsetTop - textSpan.offsetTop;\n\t\t\tblock.style['vertical-align'] = 'bottom';\n\t\t\theight = block.offsetTop - textSpan.offsetTop;\n\t\t\tdescent = height - ascent;\n\t\t} finally {\n\t\t\tdocument.body.removeChild(div);\n\t\t}\n\n\t\treturn {\n\t\t\tascent: ascent,\n\t\t\tdescent: descent,\n\t\t\theight: height\n\t\t};\n\t}\n\n}\n\nclass ResourceHandler {\n\tload(url, callback, asset) {\n\t\tthrow new Error('not implemented');\n\t}\n\n\topen(url, data, asset) {\n\t\tthrow new Error('not implemented');\n\t}\n\n\tpatch(asset, assets) {}\n\n}\n\nclass SceneSettingsHandler {\n\tconstructor(app) {\n\t\tthis._app = app;\n\t\tthis.maxRetries = 0;\n\t}\n\n\tload(url, callback) {\n\t\tSceneUtils.load(url, this.maxRetries, callback);\n\t}\n\n\topen(url, data) {\n\t\treturn data.settings;\n\t}\n\n}\n\nconst reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);\n\nfunction createScript(name, app) {\n\tif (script.legacy) {\n\t\treturn null;\n\t}\n\n\tif (reservedScriptNames.has(name)) throw new Error(`script name: '${name}' is reserved, please change script name`);\n\n\tconst scriptType = function scriptType(args) {\n\t\tEventHandler.prototype.initEventHandler.call(this);\n\t\tScriptType.prototype.initScriptType.call(this, args);\n\t};\n\n\tscriptType.prototype = Object.create(ScriptType.prototype);\n\tscriptType.prototype.constructor = scriptType;\n\tscriptType.extend = ScriptType.extend;\n\tscriptType.attributes = new ScriptAttributes(scriptType);\n\tregisterScript(scriptType, name, app);\n\treturn scriptType;\n}\n\nconst reservedAttributes = {};\nScriptAttributes.reservedNames.forEach((value, value2, set) => {\n\treservedAttributes[value] = 1;\n});\ncreateScript.reservedAttributes = reservedAttributes;\n\nfunction registerScript(script, name, app) {\n\tif (script.legacy) {\n\t\treturn;\n\t}\n\n\tif (typeof script !== 'function') throw new Error(`script class: '${script}' must be a constructor function (i.e. class).`);\n\tif (!(script.prototype instanceof ScriptType)) throw new Error(`script class: '${ScriptType.__getScriptName(script)}' does not extend pc.ScriptType.`);\n\tname = name || script.__name || ScriptType.__getScriptName(script);\n\tif (reservedScriptNames.has(name)) throw new Error(`script name: '${name}' is reserved, please change script name`);\n\tscript.__name = name;\n\tconst registry = app ? app.scripts : Application.getApplication().scripts;\n\tregistry.add(script);\n\n\tScriptHandler._push(script);\n}\n\nclass KeyboardEvent {\n\tconstructor(keyboard, event) {\n\t\tif (event) {\n\t\t\tthis.key = event.keyCode;\n\t\t\tthis.element = event.target;\n\t\t\tthis.event = event;\n\t\t} else {\n\t\t\tthis.key = null;\n\t\t\tthis.element = null;\n\t\t\tthis.event = null;\n\t\t}\n\t}\n\n}\n\nconst _keyboardEvent = new KeyboardEvent();\n\nfunction makeKeyboardEvent(event) {\n\t_keyboardEvent.key = event.keyCode;\n\t_keyboardEvent.element = event.target;\n\t_keyboardEvent.event = event;\n\treturn _keyboardEvent;\n}\n\nfunction toKeyCode(s) {\n\tif (typeof s === \"string\") {\n\t\treturn s.toUpperCase().charCodeAt(0);\n\t}\n\n\treturn s;\n}\n\nconst _keyCodeToKeyIdentifier = {\n\t'9': 'Tab',\n\t'13': 'Enter',\n\t'16': 'Shift',\n\t'17': 'Control',\n\t'18': 'Alt',\n\t'27': 'Escape',\n\t'37': 'Left',\n\t'38': 'Up',\n\t'39': 'Right',\n\t'40': 'Down',\n\t'46': 'Delete',\n\t'91': 'Win'\n};\n\nclass Keyboard extends EventHandler {\n\tconstructor(element, options = {}) {\n\t\tsuper();\n\t\tthis._element = null;\n\t\tthis._keyDownHandler = this._handleKeyDown.bind(this);\n\t\tthis._keyUpHandler = this._handleKeyUp.bind(this);\n\t\tthis._keyPressHandler = this._handleKeyPress.bind(this);\n\t\tthis._visibilityChangeHandler = this._handleVisibilityChange.bind(this);\n\t\tthis._windowBlurHandler = this._handleWindowBlur.bind(this);\n\t\tthis._keymap = {};\n\t\tthis._lastmap = {};\n\n\t\tif (element) {\n\t\t\tthis.attach(element);\n\t\t}\n\n\t\tthis.preventDefault = options.preventDefault || false;\n\t\tthis.stopPropagation = options.stopPropagation || false;\n\t}\n\n\tattach(element) {\n\t\tif (this._element) {\n\t\t\tthis.detach();\n\t\t}\n\n\t\tthis._element = element;\n\n\t\tthis._element.addEventListener(\"keydown\", this._keyDownHandler, false);\n\n\t\tthis._element.addEventListener(\"keypress\", this._keyPressHandler, false);\n\n\t\tthis._element.addEventListener(\"keyup\", this._keyUpHandler, false);\n\n\t\tdocument.addEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\twindow.addEventListener('blur', this._windowBlurHandler, false);\n\t}\n\n\tdetach() {\n\t\tif (!this._element) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._element.removeEventListener(\"keydown\", this._keyDownHandler);\n\n\t\tthis._element.removeEventListener(\"keypress\", this._keyPressHandler);\n\n\t\tthis._element.removeEventListener(\"keyup\", this._keyUpHandler);\n\n\t\tthis._element = null;\n\t\tdocument.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\twindow.removeEventListener('blur', this._windowBlurHandler, false);\n\t}\n\n\ttoKeyIdentifier(keyCode) {\n\t\tkeyCode = toKeyCode(keyCode);\n\n\t\tconst id = _keyCodeToKeyIdentifier[keyCode.toString()];\n\n\t\tif (id) {\n\t\t\treturn id;\n\t\t}\n\n\t\tlet hex = keyCode.toString(16).toUpperCase();\n\t\tconst length = hex.length;\n\n\t\tfor (let count = 0; count < 4 - length; count++) {\n\t\t\thex = '0' + hex;\n\t\t}\n\n\t\treturn 'U+' + hex;\n\t}\n\n\t_handleKeyDown(event) {\n\t\tconst code = event.keyCode || event.charCode;\n\t\tif (code === undefined) return;\n\t\tconst id = this.toKeyIdentifier(code);\n\t\tthis._keymap[id] = true;\n\t\tthis.fire(\"keydown\", makeKeyboardEvent(event));\n\n\t\tif (this.preventDefault) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\tif (this.stopPropagation) {\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\t_handleKeyUp(event) {\n\t\tconst code = event.keyCode || event.charCode;\n\t\tif (code === undefined) return;\n\t\tconst id = this.toKeyIdentifier(code);\n\t\tdelete this._keymap[id];\n\t\tthis.fire(\"keyup\", makeKeyboardEvent(event));\n\n\t\tif (this.preventDefault) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\tif (this.stopPropagation) {\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\t_handleKeyPress(event) {\n\t\tthis.fire(\"keypress\", makeKeyboardEvent(event));\n\n\t\tif (this.preventDefault) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\tif (this.stopPropagation) {\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\t_handleVisibilityChange() {\n\t\tif (document.visibilityState === 'hidden') {\n\t\t\tthis._handleWindowBlur();\n\t\t}\n\t}\n\n\t_handleWindowBlur() {\n\t\tthis._keymap = {};\n\t\tthis._lastmap = {};\n\t}\n\n\tupdate() {\n\t\tfor (const prop in this._lastmap) {\n\t\t\tdelete this._lastmap[prop];\n\t\t}\n\n\t\tfor (const prop in this._keymap) {\n\t\t\tif (this._keymap.hasOwnProperty(prop)) {\n\t\t\t\tthis._lastmap[prop] = this._keymap[prop];\n\t\t\t}\n\t\t}\n\t}\n\n\tisPressed(key) {\n\t\tconst keyCode = toKeyCode(key);\n\t\tconst id = this.toKeyIdentifier(keyCode);\n\t\treturn !!this._keymap[id];\n\t}\n\n\twasPressed(key) {\n\t\tconst keyCode = toKeyCode(key);\n\t\tconst id = this.toKeyIdentifier(keyCode);\n\t\treturn !!this._keymap[id] && !!!this._lastmap[id];\n\t}\n\n\twasReleased(key) {\n\t\tconst keyCode = toKeyCode(key);\n\t\tconst id = this.toKeyIdentifier(keyCode);\n\t\treturn !!!this._keymap[id] && !!this._lastmap[id];\n\t}\n\n}\n\nfunction isMousePointerLocked() {\n\treturn !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);\n}\n\nclass MouseEvent {\n\tconstructor(mouse, event) {\n\t\tlet coords = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\n\t\tif (event) {\n\t\t\tif (event instanceof MouseEvent) {\n\t\t\t\tthrow Error(\"Expected MouseEvent\");\n\t\t\t}\n\n\t\t\tcoords = mouse._getTargetCoords(event);\n\t\t} else {\n\t\t\tevent = {};\n\t\t}\n\n\t\tif (coords) {\n\t\t\tthis.x = coords.x;\n\t\t\tthis.y = coords.y;\n\t\t} else if (isMousePointerLocked()) {\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.wheelDelta = 0;\n\n\t\tif (event.type === 'wheel') {\n\t\t\tif (event.deltaY > 0) {\n\t\t\t\tthis.wheelDelta = 1;\n\t\t\t} else if (event.deltaY < 0) {\n\t\t\t\tthis.wheelDelta = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (isMousePointerLocked()) {\n\t\t\tthis.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;\n\t\t\tthis.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;\n\t\t} else {\n\t\t\tthis.dx = this.x - mouse._lastX;\n\t\t\tthis.dy = this.y - mouse._lastY;\n\t\t}\n\n\t\tif (event.type === 'mousedown' || event.type === 'mouseup') {\n\t\t\tthis.button = event.button;\n\t\t} else {\n\t\t\tthis.button = MOUSEBUTTON_NONE;\n\t\t}\n\n\t\tthis.buttons = mouse._buttons.slice(0);\n\t\tthis.element = event.target;\n\t\tthis.ctrlKey = event.ctrlKey || false;\n\t\tthis.altKey = event.altKey || false;\n\t\tthis.shiftKey = event.shiftKey || false;\n\t\tthis.metaKey = event.metaKey || false;\n\t\tthis.event = event;\n\t}\n\n}\n\nclass Mouse extends EventHandler {\n\tconstructor(element) {\n\t\tsuper();\n\t\tthis._lastX = 0;\n\t\tthis._lastY = 0;\n\t\tthis._buttons = [false, false, false];\n\t\tthis._lastbuttons = [false, false, false];\n\t\tthis._upHandler = this._handleUp.bind(this);\n\t\tthis._downHandler = this._handleDown.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._wheelHandler = this._handleWheel.bind(this);\n\n\t\tthis._contextMenuHandler = event => {\n\t\t\tevent.preventDefault();\n\t\t};\n\n\t\tthis._target = null;\n\t\tthis._attached = false;\n\t\tthis.attach(element);\n\t}\n\n\tstatic isPointerLocked() {\n\t\treturn isMousePointerLocked();\n\t}\n\n\tattach(element) {\n\t\tthis._target = element;\n\t\tif (this._attached) return;\n\t\tthis._attached = true;\n\t\tconst opts = platform.passiveEvents ? {\n\t\t\tpassive: false\n\t\t} : false;\n\t\twindow.addEventListener(\"mouseup\", this._upHandler, opts);\n\t\twindow.addEventListener(\"mousedown\", this._downHandler, opts);\n\t\twindow.addEventListener(\"mousemove\", this._moveHandler, opts);\n\t\twindow.addEventListener(\"wheel\", this._wheelHandler, opts);\n\t}\n\n\tdetach() {\n\t\tif (!this._attached) return;\n\t\tthis._attached = false;\n\t\tthis._target = null;\n\t\tconst opts = platform.passiveEvents ? {\n\t\t\tpassive: false\n\t\t} : false;\n\t\twindow.removeEventListener(\"mouseup\", this._upHandler, opts);\n\t\twindow.removeEventListener(\"mousedown\", this._downHandler, opts);\n\t\twindow.removeEventListener(\"mousemove\", this._moveHandler, opts);\n\t\twindow.removeEventListener(\"wheel\", this._wheelHandler, opts);\n\t}\n\n\tdisableContextMenu() {\n\t\tif (!this._target) return;\n\n\t\tthis._target.addEventListener(\"contextmenu\", this._contextMenuHandler);\n\t}\n\n\tenableContextMenu() {\n\t\tif (!this._target) return;\n\n\t\tthis._target.removeEventListener(\"contextmenu\", this._contextMenuHandler);\n\t}\n\n\tenablePointerLock(success, error) {\n\t\tif (!document.body.requestPointerLock) {\n\t\t\tif (error) error();\n\t\t\treturn;\n\t\t}\n\n\t\tconst s = () => {\n\t\t\tsuccess();\n\t\t\tdocument.removeEventListener('pointerlockchange', s);\n\t\t};\n\n\t\tconst e = () => {\n\t\t\terror();\n\t\t\tdocument.removeEventListener('pointerlockerror', e);\n\t\t};\n\n\t\tif (success) {\n\t\t\tdocument.addEventListener('pointerlockchange', s, false);\n\t\t}\n\n\t\tif (error) {\n\t\t\tdocument.addEventListener('pointerlockerror', e, false);\n\t\t}\n\n\t\tdocument.body.requestPointerLock();\n\t}\n\n\tdisablePointerLock(success) {\n\t\tif (!document.exitPointerLock) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst s = () => {\n\t\t\tsuccess();\n\t\t\tdocument.removeEventListener('pointerlockchange', s);\n\t\t};\n\n\t\tif (success) {\n\t\t\tdocument.addEventListener('pointerlockchange', s, false);\n\t\t}\n\n\t\tdocument.exitPointerLock();\n\t}\n\n\tupdate() {\n\t\tthis._lastbuttons[0] = this._buttons[0];\n\t\tthis._lastbuttons[1] = this._buttons[1];\n\t\tthis._lastbuttons[2] = this._buttons[2];\n\t}\n\n\tisPressed(button) {\n\t\treturn this._buttons[button];\n\t}\n\n\twasPressed(button) {\n\t\treturn this._buttons[button] && !this._lastbuttons[button];\n\t}\n\n\twasReleased(button) {\n\t\treturn !this._buttons[button] && this._lastbuttons[button];\n\t}\n\n\t_handleUp(event) {\n\t\tthis._buttons[event.button] = false;\n\t\tconst e = new MouseEvent(this, event);\n\t\tif (!e.event) return;\n\t\tthis.fire(EVENT_MOUSEUP, e);\n\t}\n\n\t_handleDown(event) {\n\t\tthis._buttons[event.button] = true;\n\t\tconst e = new MouseEvent(this, event);\n\t\tif (!e.event) return;\n\t\tthis.fire(EVENT_MOUSEDOWN, e);\n\t}\n\n\t_handleMove(event) {\n\t\tconst e = new MouseEvent(this, event);\n\t\tif (!e.event) return;\n\t\tthis.fire(EVENT_MOUSEMOVE, e);\n\t\tthis._lastX = e.x;\n\t\tthis._lastY = e.y;\n\t}\n\n\t_handleWheel(event) {\n\t\tconst e = new MouseEvent(this, event);\n\t\tif (!e.event) return;\n\t\tthis.fire(EVENT_MOUSEWHEEL, e);\n\t}\n\n\t_getTargetCoords(event) {\n\t\tconst rect = this._target.getBoundingClientRect();\n\n\t\tconst left = Math.floor(rect.left);\n\t\tconst top = Math.floor(rect.top);\n\n\t\tif (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tx: event.clientX - left,\n\t\t\ty: event.clientY - top\n\t\t};\n\t}\n\n}\n\nclass Controller {\n\tconstructor(element, options = {}) {\n\t\tthis._keyboard = options.keyboard || null;\n\t\tthis._mouse = options.mouse || null;\n\t\tthis._gamepads = options.gamepads || null;\n\t\tthis._element = null;\n\t\tthis._actions = {};\n\t\tthis._axes = {};\n\t\tthis._axesValues = {};\n\n\t\tif (element) {\n\t\t\tthis.attach(element);\n\t\t}\n\t}\n\n\tattach(element) {\n\t\tthis._element = element;\n\n\t\tif (this._keyboard) {\n\t\t\tthis._keyboard.attach(element);\n\t\t}\n\n\t\tif (this._mouse) {\n\t\t\tthis._mouse.attach(element);\n\t\t}\n\t}\n\n\tdetach() {\n\t\tif (this._keyboard) {\n\t\t\tthis._keyboard.detach();\n\t\t}\n\n\t\tif (this._mouse) {\n\t\t\tthis._mouse.detach();\n\t\t}\n\n\t\tthis._element = null;\n\t}\n\n\tdisableContextMenu() {\n\t\tif (!this._mouse) {\n\t\t\tthis._enableMouse();\n\t\t}\n\n\t\tthis._mouse.disableContextMenu();\n\t}\n\n\tenableContextMenu() {\n\t\tif (!this._mouse) {\n\t\t\tthis._enableMouse();\n\t\t}\n\n\t\tthis._mouse.enableContextMenu();\n\t}\n\n\tupdate(dt) {\n\t\tif (this._keyboard) {\n\t\t\tthis._keyboard.update(dt);\n\t\t}\n\n\t\tif (this._mouse) {\n\t\t\tthis._mouse.update(dt);\n\t\t}\n\n\t\tif (this._gamepads) {\n\t\t\tthis._gamepads.update(dt);\n\t\t}\n\n\t\tthis._axesValues = {};\n\n\t\tfor (const key in this._axes) {\n\t\t\tthis._axesValues[key] = [];\n\t\t}\n\t}\n\n\tregisterKeys(action, keys) {\n\t\tif (!this._keyboard) {\n\t\t\tthis._enableKeyboard();\n\t\t}\n\n\t\tif (this._actions[action]) {\n\t\t\tthrow new Error(`Action: ${action} already registered`);\n\t\t}\n\n\t\tif (keys === undefined) {\n\t\t\tthrow new Error(\"Invalid button\");\n\t\t}\n\n\t\tif (!keys.length) {\n\t\t\tkeys = [keys];\n\t\t}\n\n\t\tif (this._actions[action]) {\n\t\t\tthis._actions[action].push({\n\t\t\t\ttype: ACTION_KEYBOARD,\n\t\t\t\tkeys: keys\n\t\t\t});\n\t\t} else {\n\t\t\tthis._actions[action] = [{\n\t\t\t\ttype: ACTION_KEYBOARD,\n\t\t\t\tkeys: keys\n\t\t\t}];\n\t\t}\n\t}\n\n\tregisterMouse(action, button) {\n\t\tif (!this._mouse) {\n\t\t\tthis._enableMouse();\n\t\t}\n\n\t\tif (button === undefined) {\n\t\t\tthrow new Error('Invalid button');\n\t\t}\n\n\t\tif (this._actions[action]) {\n\t\t\tthis._actions[action].push({\n\t\t\t\ttype: ACTION_MOUSE,\n\t\t\t\tbutton: button\n\t\t\t});\n\t\t} else {\n\t\t\tthis._actions[action] = [{\n\t\t\t\ttype: ACTION_MOUSE,\n\t\t\t\tbutton: -button\n\t\t\t}];\n\t\t}\n\t}\n\n\tregisterPadButton(action, pad, button) {\n\t\tif (button === undefined) {\n\t\t\tthrow new Error('Invalid button');\n\t\t}\n\n\t\tif (this._actions[action]) {\n\t\t\tthis._actions[action].push({\n\t\t\t\ttype: ACTION_GAMEPAD,\n\t\t\t\tbutton: button,\n\t\t\t\tpad: pad\n\t\t\t});\n\t\t} else {\n\t\t\tthis._actions[action] = [{\n\t\t\t\ttype: ACTION_GAMEPAD,\n\t\t\t\tbutton: button,\n\t\t\t\tpad: pad\n\t\t\t}];\n\t\t}\n\t}\n\n\tregisterAxis(options) {\n\t\tconst name = options.name;\n\n\t\tif (!this._axes[name]) {\n\t\t\tthis._axes[name] = [];\n\t\t}\n\n\t\tconst i = this._axes[name].push(name);\n\n\t\toptions = options || {};\n\t\toptions.pad = options.pad || PAD_1;\n\n\t\tconst bind = function bind(controller, source, value, key) {\n\t\t\tswitch (source) {\n\t\t\t\tcase 'mousex':\n\t\t\t\t\tcontroller._mouse.on(EVENT_MOUSEMOVE, function (e) {\n\t\t\t\t\t\tcontroller._axesValues[name][i] = e.dx / 10;\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mousey':\n\t\t\t\t\tcontroller._mouse.on(EVENT_MOUSEMOVE, function (e) {\n\t\t\t\t\t\tcontroller._axesValues[name][i] = e.dy / 10;\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'key':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._keyboard.isPressed(key) ? value : 0;\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'padrx':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._gamepads.getAxis(options.pad, PAD_R_STICK_X);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'padry':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._gamepads.getAxis(options.pad, PAD_R_STICK_Y);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'padlx':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._gamepads.getAxis(options.pad, PAD_L_STICK_X);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'padly':\n\t\t\t\t\tcontroller._axes[name].push(function () {\n\t\t\t\t\t\treturn controller._gamepads.getAxis(options.pad, PAD_L_STICK_Y);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown axis');\n\t\t\t}\n\t\t};\n\n\t\tbind(this, options.positive, 1, options.positiveKey);\n\n\t\tif (options.negativeKey || options.negative !== options.positive) {\n\t\t\tbind(this, options.negative, -1, options.negativeKey);\n\t\t}\n\t}\n\n\tisPressed(actionName) {\n\t\tif (!this._actions[actionName]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst length = this._actions[actionName].length;\n\n\t\tfor (let index = 0; index < length; ++index) {\n\t\t\tconst action = this._actions[actionName][index];\n\n\t\t\tswitch (action.type) {\n\t\t\t\tcase ACTION_KEYBOARD:\n\t\t\t\t\tif (this._keyboard) {\n\t\t\t\t\t\tconst len = action.keys.length;\n\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tif (this._keyboard.isPressed(action.keys[i])) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACTION_MOUSE:\n\t\t\t\t\tif (this._mouse && this._mouse.isPressed(action.button)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACTION_GAMEPAD:\n\t\t\t\t\tif (this._gamepads && this._gamepads.isPressed(action.pad, action.button)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\twasPressed(actionName) {\n\t\tif (!this._actions[actionName]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst length = this._actions[actionName].length;\n\n\t\tfor (let index = 0; index < length; ++index) {\n\t\t\tconst action = this._actions[actionName][index];\n\n\t\t\tswitch (action.type) {\n\t\t\t\tcase ACTION_KEYBOARD:\n\t\t\t\t\tif (this._keyboard) {\n\t\t\t\t\t\tconst len = action.keys.length;\n\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tif (this._keyboard.wasPressed(action.keys[i])) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACTION_MOUSE:\n\t\t\t\t\tif (this._mouse && this._mouse.wasPressed(action.button)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACTION_GAMEPAD:\n\t\t\t\t\tif (this._gamepads && this._gamepads.wasPressed(action.pad, action.button)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetAxis(name) {\n\t\tlet value = 0;\n\n\t\tif (this._axes[name]) {\n\t\t\tconst len = this._axes[name].length;\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tif (type(this._axes[name][i]) === 'function') {\n\t\t\t\t\tconst v = this._axes[name][i]();\n\n\t\t\t\t\tif (Math.abs(v) > Math.abs(value)) {\n\t\t\t\t\t\tvalue = v;\n\t\t\t\t\t}\n\t\t\t\t} else if (this._axesValues[name]) {\n\t\t\t\t\tif (Math.abs(this._axesValues[name][i]) > Math.abs(value)) {\n\t\t\t\t\t\tvalue = this._axesValues[name][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t_enableMouse() {\n\t\tthis._mouse = new Mouse();\n\n\t\tif (!this._element) {\n\t\t\tthrow new Error(\"Controller must be attached to an Element\");\n\t\t}\n\n\t\tthis._mouse.attach(this._element);\n\t}\n\n\t_enableKeyboard() {\n\t\tthis._keyboard = new Keyboard();\n\n\t\tif (!this._element) {\n\t\t\tthrow new Error(\"Controller must be attached to an Element\");\n\t\t}\n\n\t\tthis._keyboard.attach(this._element);\n\t}\n\n}\n\nlet targetX, targetY;\nconst vecA = new Vec3();\nconst vecB = new Vec3();\nconst rayA = new Ray();\nconst rayB = new Ray();\nconst rayC = new Ray();\nrayA.end = new Vec3();\nrayB.end = new Vec3();\nrayC.end = new Vec3();\n\nconst _pq = new Vec3();\n\nconst _pa = new Vec3();\n\nconst _pb = new Vec3();\n\nconst _pc = new Vec3();\n\nconst _pd = new Vec3();\n\nconst _m = new Vec3();\n\nconst _au = new Vec3();\n\nconst _bv = new Vec3();\n\nconst _cw = new Vec3();\n\nconst _ir = new Vec3();\n\nconst _sct = new Vec3();\n\nconst _accumulatedScale = new Vec3();\n\nconst _paddingTop = new Vec3();\n\nconst _paddingBottom = new Vec3();\n\nconst _paddingLeft = new Vec3();\n\nconst _paddingRight = new Vec3();\n\nconst _cornerBottomLeft = new Vec3();\n\nconst _cornerBottomRight = new Vec3();\n\nconst _cornerTopRight = new Vec3();\n\nconst _cornerTopLeft = new Vec3();\n\nconst ZERO_VEC4 = new Vec4();\n\nfunction scalarTriple(p1, p2, p3) {\n\treturn _sct.cross(p1, p2).dot(p3);\n}\n\nfunction intersectLineQuad(p, q, corners) {\n\t_pq.sub2(q, p);\n\n\t_pa.sub2(corners[0], p);\n\n\t_pb.sub2(corners[1], p);\n\n\t_pc.sub2(corners[2], p);\n\n\t_m.cross(_pc, _pq);\n\n\tlet v = _pa.dot(_m);\n\n\tlet u;\n\tlet w;\n\n\tif (v >= 0) {\n\t\tu = -_pb.dot(_m);\n\t\tif (u < 0) return -1;\n\t\tw = scalarTriple(_pq, _pb, _pa);\n\t\tif (w < 0) return -1;\n\t\tconst denom = 1.0 / (u + v + w);\n\n\t\t_au.copy(corners[0]).mulScalar(u * denom);\n\n\t\t_bv.copy(corners[1]).mulScalar(v * denom);\n\n\t\t_cw.copy(corners[2]).mulScalar(w * denom);\n\n\t\t_ir.copy(_au).add(_bv).add(_cw);\n\t} else {\n\t\t_pd.sub2(corners[3], p);\n\n\t\tu = _pd.dot(_m);\n\t\tif (u < 0) return -1;\n\t\tw = scalarTriple(_pq, _pa, _pd);\n\t\tif (w < 0) return -1;\n\t\tv = -v;\n\t\tconst denom = 1.0 / (u + v + w);\n\n\t\t_au.copy(corners[0]).mulScalar(u * denom);\n\n\t\t_bv.copy(corners[3]).mulScalar(v * denom);\n\n\t\t_cw.copy(corners[2]).mulScalar(w * denom);\n\n\t\t_ir.copy(_au).add(_bv).add(_cw);\n\t}\n\n\tif (_pq.sub2(corners[0], corners[2]).lengthSq() < 0.0001 * 0.0001) return -1;\n\tif (_pq.sub2(corners[1], corners[3]).lengthSq() < 0.0001 * 0.0001) return -1;\n\treturn _ir.sub(p).lengthSq();\n}\n\nclass ElementInputEvent {\n\tconstructor(event, element, camera) {\n\t\tthis.event = event;\n\t\tthis.element = element;\n\t\tthis.camera = camera;\n\t\tthis._stopPropagation = false;\n\t}\n\n\tstopPropagation() {\n\t\tthis._stopPropagation = true;\n\n\t\tif (this.event) {\n\t\t\tthis.event.stopImmediatePropagation();\n\t\t\tthis.event.stopPropagation();\n\t\t}\n\t}\n\n}\n\nclass ElementMouseEvent extends ElementInputEvent {\n\tconstructor(event, element, camera, x, y, lastX, lastY) {\n\t\tsuper(event, element, camera);\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.ctrlKey = event.ctrlKey || false;\n\t\tthis.altKey = event.altKey || false;\n\t\tthis.shiftKey = event.shiftKey || false;\n\t\tthis.metaKey = event.metaKey || false;\n\t\tthis.button = event.button;\n\n\t\tif (Mouse.isPointerLocked()) {\n\t\t\tthis.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;\n\t\t\tthis.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;\n\t\t} else {\n\t\t\tthis.dx = x - lastX;\n\t\t\tthis.dy = y - lastY;\n\t\t}\n\n\t\tthis.wheelDelta = 0;\n\n\t\tif (event.type === 'wheel') {\n\t\t\tif (event.deltaY > 0) {\n\t\t\t\tthis.wheelDelta = 1;\n\t\t\t} else if (event.deltaY < 0) {\n\t\t\t\tthis.wheelDelta = -1;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass ElementTouchEvent extends ElementInputEvent {\n\tconstructor(event, element, camera, x, y, touch) {\n\t\tsuper(event, element, camera);\n\t\tthis.touches = event.touches;\n\t\tthis.changedTouches = event.changedTouches;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.touch = touch;\n\t}\n\n}\n\nclass ElementSelectEvent extends ElementInputEvent {\n\tconstructor(event, element, camera, inputSource) {\n\t\tsuper(event, element, camera);\n\t\tthis.inputSource = inputSource;\n\t}\n\n}\n\nclass ElementInput {\n\tconstructor(domElement, options) {\n\t\tthis._app = null;\n\t\tthis._attached = false;\n\t\tthis._target = null;\n\t\tthis._enabled = true;\n\t\tthis._lastX = 0;\n\t\tthis._lastY = 0;\n\t\tthis._upHandler = this._handleUp.bind(this);\n\t\tthis._downHandler = this._handleDown.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._wheelHandler = this._handleWheel.bind(this);\n\t\tthis._touchstartHandler = this._handleTouchStart.bind(this);\n\t\tthis._touchendHandler = this._handleTouchEnd.bind(this);\n\t\tthis._touchcancelHandler = this._touchendHandler;\n\t\tthis._touchmoveHandler = this._handleTouchMove.bind(this);\n\t\tthis._sortHandler = this._sortElements.bind(this);\n\t\tthis._elements = [];\n\t\tthis._hoveredElement = null;\n\t\tthis._pressedElement = null;\n\t\tthis._touchedElements = {};\n\t\tthis._touchesForWhichTouchLeaveHasFired = {};\n\t\tthis._selectedElements = {};\n\t\tthis._selectedPressedElements = {};\n\t\tthis._useMouse = !options || options.useMouse !== false;\n\t\tthis._useTouch = !options || options.useTouch !== false;\n\t\tthis._useXr = !options || options.useXr !== false;\n\t\tthis._selectEventsAttached = false;\n\t\tif (platform.touch) this._clickedEntities = {};\n\t\tthis.attach(domElement);\n\t}\n\n\tset enabled(value) {\n\t\tthis._enabled = value;\n\t}\n\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\n\tset app(value) {\n\t\tthis._app = value;\n\t}\n\n\tget app() {\n\t\treturn this._app || getApplication();\n\t}\n\n\tattach(domElement) {\n\t\tif (this._attached) {\n\t\t\tthis._attached = false;\n\t\t\tthis.detach();\n\t\t}\n\n\t\tthis._target = domElement;\n\t\tthis._attached = true;\n\t\tconst opts = platform.passiveEvents ? {\n\t\t\tpassive: true\n\t\t} : false;\n\n\t\tif (this._useMouse) {\n\t\t\twindow.addEventListener('mouseup', this._upHandler, opts);\n\t\t\twindow.addEventListener('mousedown', this._downHandler, opts);\n\t\t\twindow.addEventListener('mousemove', this._moveHandler, opts);\n\t\t\twindow.addEventListener('wheel', this._wheelHandler, opts);\n\t\t}\n\n\t\tif (this._useTouch && platform.touch) {\n\t\t\tthis._target.addEventListener('touchstart', this._touchstartHandler, opts);\n\n\t\t\tthis._target.addEventListener('touchend', this._touchendHandler, false);\n\n\t\t\tthis._target.addEventListener('touchmove', this._touchmoveHandler, false);\n\n\t\t\tthis._target.addEventListener('touchcancel', this._touchcancelHandler, false);\n\t\t}\n\n\t\tthis.attachSelectEvents();\n\t}\n\n\tattachSelectEvents() {\n\t\tif (!this._selectEventsAttached && this._useXr && this.app && this.app.xr && this.app.xr.supported) {\n\t\t\tif (!this._clickedEntities) this._clickedEntities = {};\n\t\t\tthis._selectEventsAttached = true;\n\t\t\tthis.app.xr.on('start', this._onXrStart, this);\n\t\t}\n\t}\n\n\tdetach() {\n\t\tif (!this._attached) return;\n\t\tthis._attached = false;\n\t\tconst opts = platform.passiveEvents ? {\n\t\t\tpassive: true\n\t\t} : false;\n\n\t\tif (this._useMouse) {\n\t\t\twindow.removeEventListener('mouseup', this._upHandler, opts);\n\t\t\twindow.removeEventListener('mousedown', this._downHandler, opts);\n\t\t\twindow.removeEventListener('mousemove', this._moveHandler, opts);\n\t\t\twindow.removeEventListener('wheel', this._wheelHandler, opts);\n\t\t}\n\n\t\tif (this._useTouch) {\n\t\t\tthis._target.removeEventListener('touchstart', this._touchstartHandler, opts);\n\n\t\t\tthis._target.removeEventListener('touchend', this._touchendHandler, false);\n\n\t\t\tthis._target.removeEventListener('touchmove', this._touchmoveHandler, false);\n\n\t\t\tthis._target.removeEventListener('touchcancel', this._touchcancelHandler, false);\n\t\t}\n\n\t\tif (this._selectEventsAttached) {\n\t\t\tthis._selectEventsAttached = false;\n\t\t\tthis.app.xr.off('start', this._onXrStart, this);\n\t\t\tthis.app.xr.off('end', this._onXrEnd, this);\n\t\t\tthis.app.xr.off('update', this._onXrUpdate, this);\n\t\t\tthis.app.xr.input.off('selectstart', this._onSelectStart, this);\n\t\t\tthis.app.xr.input.off('selectend', this._onSelectEnd, this);\n\t\t\tthis.app.xr.input.off('remove', this._onXrInputRemove, this);\n\t\t}\n\n\t\tthis._target = null;\n\t}\n\n\taddElement(element) {\n\t\tif (this._elements.indexOf(element) === -1) this._elements.push(element);\n\t}\n\n\tremoveElement(element) {\n\t\tconst idx = this._elements.indexOf(element);\n\n\t\tif (idx !== -1) this._elements.splice(idx, 1);\n\t}\n\n\t_handleUp(event) {\n\t\tif (!this._enabled) return;\n\t\tif (Mouse.isPointerLocked()) return;\n\n\t\tthis._calcMouseCoords(event);\n\n\t\tif (targetX === null) return;\n\n\t\tthis._onElementMouseEvent('mouseup', event);\n\t}\n\n\t_handleDown(event) {\n\t\tif (!this._enabled) return;\n\t\tif (Mouse.isPointerLocked()) return;\n\n\t\tthis._calcMouseCoords(event);\n\n\t\tif (targetX === null) return;\n\n\t\tthis._onElementMouseEvent('mousedown', event);\n\t}\n\n\t_handleMove(event) {\n\t\tif (!this._enabled) return;\n\n\t\tthis._calcMouseCoords(event);\n\n\t\tif (targetX === null) return;\n\n\t\tthis._onElementMouseEvent('mousemove', event);\n\n\t\tthis._lastX = targetX;\n\t\tthis._lastY = targetY;\n\t}\n\n\t_handleWheel(event) {\n\t\tif (!this._enabled) return;\n\n\t\tthis._calcMouseCoords(event);\n\n\t\tif (targetX === null) return;\n\n\t\tthis._onElementMouseEvent('mousewheel', event);\n\t}\n\n\t_determineTouchedElements(event) {\n\t\tconst touchedElements = {};\n\t\tconst cameras = this.app.systems.camera.cameras;\n\n\t\tfor (let i = cameras.length - 1; i >= 0; i--) {\n\t\t\tconst camera = cameras[i];\n\t\t\tlet done = 0;\n\t\t\tconst len = event.changedTouches.length;\n\n\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\tif (touchedElements[event.changedTouches[j].identifier]) {\n\t\t\t\t\tdone++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst coords = this._calcTouchCoords(event.changedTouches[j]);\n\n\t\t\t\tconst element = this._getTargetElement(camera, coords.x, coords.y);\n\n\t\t\t\tif (element) {\n\t\t\t\t\tdone++;\n\t\t\t\t\ttouchedElements[event.changedTouches[j].identifier] = {\n\t\t\t\t\t\telement: element,\n\t\t\t\t\t\tcamera: camera,\n\t\t\t\t\t\tx: coords.x,\n\t\t\t\t\t\ty: coords.y\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (done === len) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn touchedElements;\n\t}\n\n\t_handleTouchStart(event) {\n\t\tif (!this._enabled) return;\n\n\t\tconst newTouchedElements = this._determineTouchedElements(event);\n\n\t\tfor (let i = 0, len = event.changedTouches.length; i < len; i++) {\n\t\t\tconst touch = event.changedTouches[i];\n\t\t\tconst newTouchInfo = newTouchedElements[touch.identifier];\n\t\t\tconst oldTouchInfo = this._touchedElements[touch.identifier];\n\n\t\t\tif (newTouchInfo && (!oldTouchInfo || newTouchInfo.element !== oldTouchInfo.element)) {\n\t\t\t\tthis._fireEvent(event.type, new ElementTouchEvent(event, newTouchInfo.element, newTouchInfo.camera, newTouchInfo.x, newTouchInfo.y, touch));\n\n\t\t\t\tthis._touchesForWhichTouchLeaveHasFired[touch.identifier] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const touchId in newTouchedElements) {\n\t\t\tthis._touchedElements[touchId] = newTouchedElements[touchId];\n\t\t}\n\t}\n\n\t_handleTouchEnd(event) {\n\t\tif (!this._enabled) return;\n\t\tconst cameras = this.app.systems.camera.cameras;\n\n\t\tfor (const key in this._clickedEntities) {\n\t\t\tdelete this._clickedEntities[key];\n\t\t}\n\n\t\tfor (let i = 0, len = event.changedTouches.length; i < len; i++) {\n\t\t\tconst touch = event.changedTouches[i];\n\t\t\tconst touchInfo = this._touchedElements[touch.identifier];\n\t\t\tif (!touchInfo) continue;\n\t\t\tconst element = touchInfo.element;\n\t\t\tconst camera = touchInfo.camera;\n\t\t\tconst x = touchInfo.x;\n\t\t\tconst y = touchInfo.y;\n\t\t\tdelete this._touchedElements[touch.identifier];\n\t\t\tdelete this._touchesForWhichTouchLeaveHasFired[touch.identifier];\n\n\t\t\tthis._fireEvent(event.type, new ElementTouchEvent(event, element, camera, x, y, touch));\n\n\t\t\tif (event.touches.length === 0) {\n\t\t\t\tconst coords = this._calcTouchCoords(touch);\n\n\t\t\t\tfor (let c = cameras.length - 1; c >= 0; c--) {\n\t\t\t\t\tconst hovered = this._getTargetElement(cameras[c], coords.x, coords.y);\n\n\t\t\t\t\tif (hovered === element) {\n\t\t\t\t\t\tif (!this._clickedEntities[element.entity.getGuid()]) {\n\t\t\t\t\t\t\tthis._fireEvent('click', new ElementTouchEvent(event, element, camera, x, y, touch));\n\n\t\t\t\t\t\t\tthis._clickedEntities[element.entity.getGuid()] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_handleTouchMove(event) {\n\t\tevent.preventDefault();\n\t\tif (!this._enabled) return;\n\n\t\tconst newTouchedElements = this._determineTouchedElements(event);\n\n\t\tfor (let i = 0, len = event.changedTouches.length; i < len; i++) {\n\t\t\tconst touch = event.changedTouches[i];\n\t\t\tconst newTouchInfo = newTouchedElements[touch.identifier];\n\t\t\tconst oldTouchInfo = this._touchedElements[touch.identifier];\n\n\t\t\tif (oldTouchInfo) {\n\t\t\t\tconst coords = this._calcTouchCoords(touch);\n\n\t\t\t\tif ((!newTouchInfo || newTouchInfo.element !== oldTouchInfo.element) && !this._touchesForWhichTouchLeaveHasFired[touch.identifier]) {\n\t\t\t\t\tthis._fireEvent('touchleave', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));\n\n\t\t\t\t\tthis._touchesForWhichTouchLeaveHasFired[touch.identifier] = true;\n\t\t\t\t}\n\n\t\t\t\tthis._fireEvent('touchmove', new ElementTouchEvent(event, oldTouchInfo.element, oldTouchInfo.camera, coords.x, coords.y, touch));\n\t\t\t}\n\t\t}\n\t}\n\n\t_onElementMouseEvent(eventType, event) {\n\t\tlet element;\n\t\tconst hovered = this._hoveredElement;\n\t\tthis._hoveredElement = null;\n\t\tconst cameras = this.app.systems.camera.cameras;\n\t\tlet camera;\n\n\t\tfor (let i = cameras.length - 1; i >= 0; i--) {\n\t\t\tcamera = cameras[i];\n\t\t\telement = this._getTargetElement(camera, targetX, targetY);\n\t\t\tif (element) break;\n\t\t}\n\n\t\tif (element) {\n\t\t\tthis._fireEvent(eventType, new ElementMouseEvent(event, element, camera, targetX, targetY, this._lastX, this._lastY));\n\n\t\t\tthis._hoveredElement = element;\n\n\t\t\tif (eventType === 'mousedown') {\n\t\t\t\tthis._pressedElement = element;\n\t\t\t}\n\t\t}\n\n\t\tif (hovered !== this._hoveredElement) {\n\t\t\tif (hovered) {\n\t\t\t\tthis._fireEvent('mouseleave', new ElementMouseEvent(event, hovered, camera, targetX, targetY, this._lastX, this._lastY));\n\t\t\t}\n\n\t\t\tif (this._hoveredElement) {\n\t\t\t\tthis._fireEvent('mouseenter', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));\n\t\t\t}\n\t\t}\n\n\t\tif (eventType === 'mouseup' && this._pressedElement) {\n\t\t\tif (this._pressedElement === this._hoveredElement) {\n\t\t\t\tthis._pressedElement = null;\n\n\t\t\t\tif (!this._clickedEntities || !this._clickedEntities[this._hoveredElement.entity.getGuid()]) {\n\t\t\t\t\tthis._fireEvent('click', new ElementMouseEvent(event, this._hoveredElement, camera, targetX, targetY, this._lastX, this._lastY));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._pressedElement = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t_onXrStart() {\n\t\tthis.app.xr.on('end', this._onXrEnd, this);\n\t\tthis.app.xr.on('update', this._onXrUpdate, this);\n\t\tthis.app.xr.input.on('selectstart', this._onSelectStart, this);\n\t\tthis.app.xr.input.on('selectend', this._onSelectEnd, this);\n\t\tthis.app.xr.input.on('remove', this._onXrInputRemove, this);\n\t}\n\n\t_onXrEnd() {\n\t\tthis.app.xr.off('update', this._onXrUpdate, this);\n\t\tthis.app.xr.input.off('selectstart', this._onSelectStart, this);\n\t\tthis.app.xr.input.off('selectend', this._onSelectEnd, this);\n\t\tthis.app.xr.input.off('remove', this._onXrInputRemove, this);\n\t}\n\n\t_onXrUpdate() {\n\t\tif (!this._enabled) return;\n\t\tconst inputSources = this.app.xr.input.inputSources;\n\n\t\tfor (let i = 0; i < inputSources.length; i++) {\n\t\t\tthis._onElementSelectEvent('selectmove', inputSources[i], null);\n\t\t}\n\t}\n\n\t_onXrInputRemove(inputSource) {\n\t\tconst hovered = this._selectedElements[inputSource.id];\n\n\t\tif (hovered) {\n\t\t\tinputSource._elementEntity = null;\n\n\t\t\tthis._fireEvent('selectleave', new ElementSelectEvent(null, hovered, null, inputSource));\n\t\t}\n\n\t\tdelete this._selectedElements[inputSource.id];\n\t\tdelete this._selectedPressedElements[inputSource.id];\n\t}\n\n\t_onSelectStart(inputSource, event) {\n\t\tif (!this._enabled) return;\n\n\t\tthis._onElementSelectEvent('selectstart', inputSource, event);\n\t}\n\n\t_onSelectEnd(inputSource, event) {\n\t\tif (!this._enabled) return;\n\n\t\tthis._onElementSelectEvent('selectend', inputSource, event);\n\t}\n\n\t_onElementSelectEvent(eventType, inputSource, event) {\n\t\tlet element;\n\t\tconst hoveredBefore = this._selectedElements[inputSource.id];\n\t\tlet hoveredNow;\n\t\tconst cameras = this.app.systems.camera.cameras;\n\t\tlet camera;\n\n\t\tif (inputSource.elementInput) {\n\t\t\trayC.set(inputSource.getOrigin(), inputSource.getDirection());\n\n\t\t\tfor (let i = cameras.length - 1; i >= 0; i--) {\n\t\t\t\tcamera = cameras[i];\n\t\t\t\telement = this._getTargetElementByRay(rayC, camera);\n\t\t\t\tif (element) break;\n\t\t\t}\n\t\t}\n\n\t\tinputSource._elementEntity = element || null;\n\n\t\tif (element) {\n\t\t\tthis._selectedElements[inputSource.id] = element;\n\t\t\thoveredNow = element;\n\t\t} else {\n\t\t\tdelete this._selectedElements[inputSource.id];\n\t\t}\n\n\t\tif (hoveredBefore !== hoveredNow) {\n\t\t\tif (hoveredBefore) this._fireEvent('selectleave', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n\t\t\tif (hoveredNow) this._fireEvent('selectenter', new ElementSelectEvent(event, hoveredNow, camera, inputSource));\n\t\t}\n\n\t\tif (eventType === 'selectstart') {\n\t\t\tthis._selectedPressedElements[inputSource.id] = hoveredNow;\n\t\t\tif (hoveredNow) this._fireEvent('selectstart', new ElementSelectEvent(event, hoveredNow, camera, inputSource));\n\t\t}\n\n\t\tconst pressed = this._selectedPressedElements[inputSource.id];\n\n\t\tif (!inputSource.elementInput && pressed) {\n\t\t\tdelete this._selectedPressedElements[inputSource.id];\n\t\t\tif (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n\t\t}\n\n\t\tif (eventType === 'selectend' && inputSource.elementInput) {\n\t\t\tdelete this._selectedPressedElements[inputSource.id];\n\t\t\tif (hoveredBefore) this._fireEvent('selectend', new ElementSelectEvent(event, hoveredBefore, camera, inputSource));\n\n\t\t\tif (pressed && pressed === hoveredBefore) {\n\t\t\t\tthis._fireEvent('click', new ElementSelectEvent(event, pressed, camera, inputSource));\n\t\t\t}\n\t\t}\n\t}\n\n\t_fireEvent(name, evt) {\n\t\tlet element = evt.element;\n\n\t\twhile (true) {\n\t\t\telement.fire(name, evt);\n\t\t\tif (evt._stopPropagation) break;\n\t\t\tif (!element.entity.parent) break;\n\t\t\telement = element.entity.parent.element;\n\t\t\tif (!element) break;\n\t\t}\n\t}\n\n\t_calcMouseCoords(event) {\n\t\tconst rect = this._target.getBoundingClientRect();\n\n\t\tconst left = Math.floor(rect.left);\n\t\tconst top = Math.floor(rect.top);\n\n\t\tif (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {\n\t\t\ttargetX = null;\n\t\t\ttargetY = null;\n\t\t} else {\n\t\t\ttargetX = event.clientX - left;\n\t\t\ttargetY = event.clientY - top;\n\t\t}\n\t}\n\n\t_calcTouchCoords(touch) {\n\t\tlet totalOffsetX = 0;\n\t\tlet totalOffsetY = 0;\n\t\tlet target = touch.target;\n\n\t\twhile (!(target instanceof HTMLElement)) {\n\t\t\ttarget = target.parentNode;\n\t\t}\n\n\t\tlet currentElement = target;\n\n\t\tdo {\n\t\t\ttotalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;\n\t\t\ttotalOffsetY += currentElement.offsetTop - currentElement.scrollTop;\n\t\t\tcurrentElement = currentElement.offsetParent;\n\t\t} while (currentElement);\n\n\t\treturn {\n\t\t\tx: touch.pageX - totalOffsetX,\n\t\t\ty: touch.pageY - totalOffsetY\n\t\t};\n\t}\n\n\t_sortElements(a, b) {\n\t\tconst layerOrder = this.app.scene.layers.sortTransparentLayers(a.layers, b.layers);\n\t\tif (layerOrder !== 0) return layerOrder;\n\t\tif (a.screen && !b.screen) return -1;\n\t\tif (!a.screen && b.screen) return 1;\n\t\tif (!a.screen && !b.screen) return 0;\n\t\tif (a.screen.screen.screenSpace && !b.screen.screen.screenSpace) return -1;\n\t\tif (b.screen.screen.screenSpace && !a.screen.screen.screenSpace) return 1;\n\t\treturn b.drawOrder - a.drawOrder;\n\t}\n\n\t_getTargetElement(camera, x, y) {\n\t\tlet result = null;\n\t\tlet closestDistance3d = Infinity;\n\n\t\tthis._elements.sort(this._sortHandler);\n\n\t\tlet rayScreen, ray3d;\n\n\t\tfor (let i = 0, len = this._elements.length; i < len; i++) {\n\t\t\tconst element = this._elements[i];\n\n\t\t\tif (element.screen && element.screen.screen.screenSpace) {\n\t\t\t\tif (rayScreen === undefined) {\n\t\t\t\t\trayScreen = this._calculateRayScreen(x, y, camera, rayA) ? rayA : null;\n\t\t\t\t}\n\n\t\t\t\tif (!rayScreen) continue;\n\n\t\t\t\tconst currentDistance = this._checkElement(rayScreen, element, true);\n\n\t\t\t\tif (currentDistance >= 0) {\n\t\t\t\t\tresult = element;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ray3d === undefined) {\n\t\t\t\t\tray3d = this._calculateRay3d(x, y, camera, rayB) ? rayB : null;\n\t\t\t\t}\n\n\t\t\t\tif (!ray3d) continue;\n\n\t\t\t\tconst currentDistance = this._checkElement(ray3d, element, false);\n\n\t\t\t\tif (currentDistance >= 0) {\n\t\t\t\t\tif (currentDistance < closestDistance3d) {\n\t\t\t\t\t\tresult = element;\n\t\t\t\t\t\tclosestDistance3d = currentDistance;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (element.screen) {\n\t\t\t\t\t\tresult = element;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_getTargetElementByRay(ray, camera) {\n\t\tlet result = null;\n\t\trayA.origin.copy(ray.origin);\n\t\trayA.direction.copy(ray.direction);\n\t\trayA.end.copy(rayA.direction).mulScalar(camera.farClip * 2).add(rayA.origin);\n\n\t\tthis._elements.sort(this._sortHandler);\n\n\t\tfor (let i = 0, len = this._elements.length; i < len; i++) {\n\t\t\tconst element = this._elements[i];\n\n\t\t\tif (!element.screen || !element.screen.screen.screenSpace) {\n\t\t\t\tif (this._checkElement(rayA, element, false) >= 0) {\n\t\t\t\t\tresult = element;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t_buildHitCorners(element, screenOrWorldCorners, scaleX, scaleY, scaleZ) {\n\t\tlet hitCorners = screenOrWorldCorners;\n\t\tconst button = element.entity && element.entity.button;\n\n\t\tif (button) {\n\t\t\tconst hitPadding = element.entity.button.hitPadding || ZERO_VEC4;\n\n\t\t\t_paddingTop.copy(element.entity.up);\n\n\t\t\t_paddingBottom.copy(_paddingTop).mulScalar(-1);\n\n\t\t\t_paddingRight.copy(element.entity.right);\n\n\t\t\t_paddingLeft.copy(_paddingRight).mulScalar(-1);\n\n\t\t\t_paddingTop.mulScalar(hitPadding.w * scaleY);\n\n\t\t\t_paddingBottom.mulScalar(hitPadding.y * scaleY);\n\n\t\t\t_paddingRight.mulScalar(hitPadding.z * scaleX);\n\n\t\t\t_paddingLeft.mulScalar(hitPadding.x * scaleX);\n\n\t\t\t_cornerBottomLeft.copy(hitCorners[0]).add(_paddingBottom).add(_paddingLeft);\n\n\t\t\t_cornerBottomRight.copy(hitCorners[1]).add(_paddingBottom).add(_paddingRight);\n\n\t\t\t_cornerTopRight.copy(hitCorners[2]).add(_paddingTop).add(_paddingRight);\n\n\t\t\t_cornerTopLeft.copy(hitCorners[3]).add(_paddingTop).add(_paddingLeft);\n\n\t\t\thitCorners = [_cornerBottomLeft, _cornerBottomRight, _cornerTopRight, _cornerTopLeft];\n\t\t}\n\n\t\tif (scaleX < 0) {\n\t\t\tconst left = hitCorners[2].x;\n\t\t\tconst right = hitCorners[0].x;\n\t\t\thitCorners[0].x = left;\n\t\t\thitCorners[1].x = right;\n\t\t\thitCorners[2].x = right;\n\t\t\thitCorners[3].x = left;\n\t\t}\n\n\t\tif (scaleY < 0) {\n\t\t\tconst bottom = hitCorners[2].y;\n\t\t\tconst top = hitCorners[0].y;\n\t\t\thitCorners[0].y = bottom;\n\t\t\thitCorners[1].y = bottom;\n\t\t\thitCorners[2].y = top;\n\t\t\thitCorners[3].y = top;\n\t\t}\n\n\t\tif (scaleZ < 0) {\n\t\t\tconst x = hitCorners[2].x;\n\t\t\tconst y = hitCorners[2].y;\n\t\t\tconst z = hitCorners[2].z;\n\t\t\thitCorners[2].x = hitCorners[0].x;\n\t\t\thitCorners[2].y = hitCorners[0].y;\n\t\t\thitCorners[2].z = hitCorners[0].z;\n\t\t\thitCorners[0].x = x;\n\t\t\thitCorners[0].y = y;\n\t\t\thitCorners[0].z = z;\n\t\t}\n\n\t\treturn hitCorners;\n\t}\n\n\t_calculateScaleToScreen(element) {\n\t\tlet current = element.entity;\n\t\tconst screenScale = element.screen.screen.scale;\n\n\t\t_accumulatedScale.set(screenScale, screenScale, screenScale);\n\n\t\twhile (current && !current.screen) {\n\t\t\t_accumulatedScale.mul(current.getLocalScale());\n\n\t\t\tcurrent = current.parent;\n\t\t}\n\n\t\treturn _accumulatedScale;\n\t}\n\n\t_calculateScaleToWorld(element) {\n\t\tlet current = element.entity;\n\n\t\t_accumulatedScale.set(1, 1, 1);\n\n\t\twhile (current) {\n\t\t\t_accumulatedScale.mul(current.getLocalScale());\n\n\t\t\tcurrent = current.parent;\n\t\t}\n\n\t\treturn _accumulatedScale;\n\t}\n\n\t_calculateRayScreen(x, y, camera, ray) {\n\t\tconst sw = this.app.graphicsDevice.width;\n\t\tconst sh = this.app.graphicsDevice.height;\n\t\tconst cameraWidth = camera.rect.z * sw;\n\t\tconst cameraHeight = camera.rect.w * sh;\n\t\tconst cameraLeft = camera.rect.x * sw;\n\t\tconst cameraRight = cameraLeft + cameraWidth;\n\t\tconst cameraBottom = (1 - camera.rect.y) * sh;\n\t\tconst cameraTop = cameraBottom - cameraHeight;\n\n\t\tlet _x = x * sw / this._target.clientWidth;\n\n\t\tlet _y = y * sh / this._target.clientHeight;\n\n\t\tif (_x >= cameraLeft && _x <= cameraRight && _y <= cameraBottom && _y >= cameraTop) {\n\t\t\t_x = sw * (_x - cameraLeft) / cameraWidth;\n\t\t\t_y = sh * (_y - cameraTop) / cameraHeight;\n\t\t\t_y = sh - _y;\n\t\t\tray.origin.set(_x, _y, 1);\n\t\t\tray.direction.set(0, 0, -1);\n\t\t\tray.end.copy(ray.direction).mulScalar(2).add(ray.origin);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_calculateRay3d(x, y, camera, ray) {\n\t\tconst sw = this._target.clientWidth;\n\t\tconst sh = this._target.clientHeight;\n\t\tconst cameraWidth = camera.rect.z * sw;\n\t\tconst cameraHeight = camera.rect.w * sh;\n\t\tconst cameraLeft = camera.rect.x * sw;\n\t\tconst cameraRight = cameraLeft + cameraWidth;\n\t\tconst cameraBottom = (1 - camera.rect.y) * sh;\n\t\tconst cameraTop = cameraBottom - cameraHeight;\n\t\tlet _x = x;\n\t\tlet _y = y;\n\n\t\tif (x >= cameraLeft && x <= cameraRight && y <= cameraBottom && _y >= cameraTop) {\n\t\t\t_x = sw * (_x - cameraLeft) / cameraWidth;\n\t\t\t_y = sh * (_y - cameraTop) / cameraHeight;\n\t\t\tcamera.screenToWorld(_x, _y, camera.nearClip, vecA);\n\t\t\tcamera.screenToWorld(_x, _y, camera.farClip, vecB);\n\t\t\tray.origin.copy(vecA);\n\t\t\tray.direction.set(0, 0, -1);\n\t\t\tray.end.copy(vecB);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_checkElement(ray, element, screen) {\n\t\tif (element.maskedBy) {\n\t\t\tif (this._checkElement(ray, element.maskedBy.element, screen) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tlet scale;\n\n\t\tif (screen) {\n\t\t\tscale = this._calculateScaleToScreen(element);\n\t\t} else {\n\t\t\tscale = this._calculateScaleToWorld(element);\n\t\t}\n\n\t\tconst corners = this._buildHitCorners(element, screen ? element.screenCorners : element.worldCorners, scale.x, scale.y, scale.z);\n\n\t\treturn intersectLineQuad(ray.origin, ray.end, corners);\n\t}\n\n}\n\nconst MAPS = {\n\tDEFAULT: {\n\t\tbuttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_3', 'PAD_FACE_4', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],\n\t\taxes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']\n\t},\n\tPS3: {\n\t\tbuttons: ['PAD_FACE_1', 'PAD_FACE_2', 'PAD_FACE_4', 'PAD_FACE_3', 'PAD_L_SHOULDER_1', 'PAD_R_SHOULDER_1', 'PAD_L_SHOULDER_2', 'PAD_R_SHOULDER_2', 'PAD_SELECT', 'PAD_START', 'PAD_L_STICK_BUTTON', 'PAD_R_STICK_BUTTON', 'PAD_UP', 'PAD_DOWN', 'PAD_LEFT', 'PAD_RIGHT', 'PAD_VENDOR'],\n\t\taxes: ['PAD_L_STICK_X', 'PAD_L_STICK_Y', 'PAD_R_STICK_X', 'PAD_R_STICK_Y']\n\t}\n};\nconst PRODUCT_CODES = {\n\t'Product: 0268': 'PS3'\n};\n\nclass GamePads {\n\tconstructor() {\n\t\tthis.gamepadsSupported = !!navigator.getGamepads || !!navigator.webkitGetGamepads;\n\t\tthis.current = [];\n\t\tthis.previous = [];\n\t\tthis.deadZone = 0.25;\n\t}\n\n\tupdate() {\n\t\tfor (let i = 0, l = this.current.length; i < l; i++) {\n\t\t\tconst buttons = this.current[i].pad.buttons;\n\t\t\tconst buttonsLen = buttons.length;\n\n\t\t\tfor (let j = 0; j < buttonsLen; j++) {\n\t\t\t\tif (this.previous[i] === undefined) {\n\t\t\t\t\tthis.previous[i] = [];\n\t\t\t\t}\n\n\t\t\t\tthis.previous[i][j] = buttons[j].pressed;\n\t\t\t}\n\t\t}\n\n\t\tthis.poll(this.current);\n\t}\n\n\tpoll(pads = []) {\n\t\tif (pads.length > 0) {\n\t\t\tpads.length = 0;\n\t\t}\n\n\t\tif (this.gamepadsSupported) {\n\t\t\tconst padDevices = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads();\n\n\t\t\tfor (let i = 0, len = padDevices.length; i < len; i++) {\n\t\t\t\tif (padDevices[i]) {\n\t\t\t\t\tpads.push({\n\t\t\t\t\t\tmap: this.getMap(padDevices[i]),\n\t\t\t\t\t\tpad: padDevices[i]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn pads;\n\t}\n\n\tgetMap(pad) {\n\t\tfor (const code in PRODUCT_CODES) {\n\t\t\tif (pad.id.indexOf(code) >= 0) {\n\t\t\t\treturn MAPS[PRODUCT_CODES[code]];\n\t\t\t}\n\t\t}\n\n\t\treturn MAPS.DEFAULT;\n\t}\n\n\tisPressed(index, button) {\n\t\tif (!this.current[index]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst key = this.current[index].map.buttons[button];\n\t\treturn this.current[index].pad.buttons[pc[key]].pressed;\n\t}\n\n\twasPressed(index, button) {\n\t\tif (!this.current[index]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst key = this.current[index].map.buttons[button];\n\t\tconst i = pc[key];\n\t\treturn this.current[index].pad.buttons[i].pressed && !(this.previous[index] && this.previous[index][i]);\n\t}\n\n\twasReleased(index, button) {\n\t\tif (!this.current[index]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst key = this.current[index].map.buttons[button];\n\t\tconst i = pc[key];\n\t\treturn !this.current[index].pad.buttons[i].pressed && this.previous[index] && this.previous[index][i];\n\t}\n\n\tgetAxis(index, axes) {\n\t\tif (!this.current[index]) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst key = this.current[index].map.axes[axes];\n\t\tlet value = this.current[index].pad.axes[pc[key]];\n\n\t\tif (Math.abs(value) < this.deadZone) {\n\t\t\tvalue = 0;\n\t\t}\n\n\t\treturn value;\n\t}\n\n}\n\nfunction getTouchTargetCoords(touch) {\n\tlet totalOffsetX = 0;\n\tlet totalOffsetY = 0;\n\tlet target = touch.target;\n\n\twhile (!(target instanceof HTMLElement)) {\n\t\ttarget = target.parentNode;\n\t}\n\n\tlet currentElement = target;\n\n\tdo {\n\t\ttotalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;\n\t\ttotalOffsetY += currentElement.offsetTop - currentElement.scrollTop;\n\t\tcurrentElement = currentElement.offsetParent;\n\t} while (currentElement);\n\n\treturn {\n\t\tx: touch.pageX - totalOffsetX,\n\t\ty: touch.pageY - totalOffsetY\n\t};\n}\n\nclass Touch {\n\tconstructor(touch) {\n\t\tconst coords = getTouchTargetCoords(touch);\n\t\tthis.id = touch.identifier;\n\t\tthis.x = coords.x;\n\t\tthis.y = coords.y;\n\t\tthis.target = touch.target;\n\t\tthis.touch = touch;\n\t}\n\n}\n\nclass TouchEvent {\n\tconstructor(device, event) {\n\t\tthis.element = event.target;\n\t\tthis.event = event;\n\t\tthis.touches = [];\n\t\tthis.changedTouches = [];\n\n\t\tif (event) {\n\t\t\tfor (let i = 0, l = event.touches.length; i < l; i++) {\n\t\t\t\tthis.touches.push(new Touch(event.touches[i]));\n\t\t\t}\n\n\t\t\tfor (let i = 0, l = event.changedTouches.length; i < l; i++) {\n\t\t\t\tthis.changedTouches.push(new Touch(event.changedTouches[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\tgetTouchById(id, list) {\n\t\tfor (let i = 0, l = list.length; i < l; i++) {\n\t\t\tif (list[i].id === id) {\n\t\t\t\treturn list[i];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n\nclass TouchDevice extends EventHandler {\n\tconstructor(element) {\n\t\tsuper();\n\t\tthis._element = null;\n\t\tthis._startHandler = this._handleTouchStart.bind(this);\n\t\tthis._endHandler = this._handleTouchEnd.bind(this);\n\t\tthis._moveHandler = this._handleTouchMove.bind(this);\n\t\tthis._cancelHandler = this._handleTouchCancel.bind(this);\n\t\tthis.attach(element);\n\t}\n\n\tattach(element) {\n\t\tif (this._element) {\n\t\t\tthis.detach();\n\t\t}\n\n\t\tthis._element = element;\n\n\t\tthis._element.addEventListener('touchstart', this._startHandler, false);\n\n\t\tthis._element.addEventListener('touchend', this._endHandler, false);\n\n\t\tthis._element.addEventListener('touchmove', this._moveHandler, false);\n\n\t\tthis._element.addEventListener('touchcancel', this._cancelHandler, false);\n\t}\n\n\tdetach() {\n\t\tif (this._element) {\n\t\t\tthis._element.removeEventListener('touchstart', this._startHandler, false);\n\n\t\t\tthis._element.removeEventListener('touchend', this._endHandler, false);\n\n\t\t\tthis._element.removeEventListener('touchmove', this._moveHandler, false);\n\n\t\t\tthis._element.removeEventListener('touchcancel', this._cancelHandler, false);\n\t\t}\n\n\t\tthis._element = null;\n\t}\n\n\t_handleTouchStart(e) {\n\t\tthis.fire('touchstart', new TouchEvent(this, e));\n\t}\n\n\t_handleTouchEnd(e) {\n\t\tthis.fire('touchend', new TouchEvent(this, e));\n\t}\n\n\t_handleTouchMove(e) {\n\t\te.preventDefault();\n\t\tthis.fire('touchmove', new TouchEvent(this, e));\n\t}\n\n\t_handleTouchCancel(e) {\n\t\tthis.fire('touchcancel', new TouchEvent(this, e));\n\t}\n\n}\n\nconst log = {\n\twrite: function (text) {\n\t\tconsole.log(text);\n\t},\n\topen: function () {\n\t\tlog.write(\"Powered by PlayCanvas \" + version + \" \" + revision);\n\t},\n\tinfo: function (text) {\n\t\tconsole.info(\"INFO:\t\t\" + text);\n\t},\n\tdebug: function (text) {\n\t\tconsole.debug(\"DEBUG:\t \" + text);\n\t},\n\terror: function (text) {\n\t\tconsole.error(\"ERROR:\t \" + text);\n\t},\n\twarning: function (text) {\n\t\tconsole.warn(\"WARNING: \" + text);\n\t},\n\talert: function (text) {\n\t\tlog.write(\"ALERT:\t \" + text);\n\t\talert(text);\n\t},\n\tassert: function (condition, text) {\n\t\tif (condition === false) {\n\t\t\tlog.write(\"ASSERT:\t\" + text);\n\t\t}\n\t}\n};\n\nstring.endsWith = function (s, subs) {\n\treturn s.endsWith(subs);\n};\n\nstring.startsWith = function (s, subs) {\n\treturn s.startsWith(subs);\n};\n\nconst time = {\n\tnow: now,\n\tTimer: Timer\n};\nObject.defineProperty(Color.prototype, \"data\", {\n\tget: function () {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Float32Array(4);\n\t\t}\n\n\t\tthis._data[0] = this.r;\n\t\tthis._data[1] = this.g;\n\t\tthis._data[2] = this.b;\n\t\tthis._data[3] = this.a;\n\t\treturn this._data;\n\t}\n});\nObject.defineProperty(Color.prototype, \"data3\", {\n\tget: function () {\n\t\tif (!this._data3) {\n\t\t\tthis._data3 = new Float32Array(3);\n\t\t}\n\n\t\tthis._data3[0] = this.r;\n\t\tthis._data3[1] = this.g;\n\t\tthis._data3[2] = this.b;\n\t\treturn this._data3;\n\t}\n});\nfunction inherits(Self, Super) {\n\tconst Temp = function Temp() {};\n\n\tconst Func = function Func(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n\t\tSuper.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n\t\tSelf.call(this, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n\t};\n\n\tFunc._super = Super.prototype;\n\tTemp.prototype = Super.prototype;\n\tFunc.prototype = new Temp();\n\treturn Func;\n}\nfunction makeArray(arr) {\n\treturn Array.prototype.slice.call(arr);\n}\nmath.INV_LOG2 = Math.LOG2E;\nmath.intToBytes = math.intToBytes32;\nmath.bytesToInt = math.bytesToInt32;\nObject.defineProperty(Vec2.prototype, \"data\", {\n\tget: function () {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Float32Array(2);\n\t\t}\n\n\t\tthis._data[0] = this.x;\n\t\tthis._data[1] = this.y;\n\t\treturn this._data;\n\t}\n});\nVec2.prototype.scale = Vec2.prototype.mulScalar;\nObject.defineProperty(Vec3.prototype, \"data\", {\n\tget: function () {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Float32Array(3);\n\t\t}\n\n\t\tthis._data[0] = this.x;\n\t\tthis._data[1] = this.y;\n\t\tthis._data[2] = this.z;\n\t\treturn this._data;\n\t}\n});\nVec3.prototype.scale = Vec3.prototype.mulScalar;\nObject.defineProperty(Vec4.prototype, \"data\", {\n\tget: function () {\n\t\tif (!this._data) {\n\t\t\tthis._data = new Float32Array(4);\n\t\t}\n\n\t\tthis._data[0] = this.x;\n\t\tthis._data[1] = this.y;\n\t\tthis._data[2] = this.z;\n\t\tthis._data[3] = this.w;\n\t\treturn this._data;\n\t}\n});\nVec4.prototype.scale = Vec4.prototype.mulScalar;\nconst shape = {\n\tAabb: BoundingBox,\n\tSphere: BoundingSphere,\n\tPlane: Plane\n};\nBoundingSphere.prototype.intersectRay = BoundingSphere.prototype.intersectsRay;\n\nFrustum.prototype.update = function (projectionMatrix, viewMatrix) {\n\tconst viewProj = new Mat4();\n\tviewProj.mul2(projectionMatrix, viewMatrix);\n\tthis.setFromMat4(viewProj);\n};\n\nconst ELEMENTTYPE_INT8 = TYPE_INT8;\nconst ELEMENTTYPE_UINT8 = TYPE_UINT8;\nconst ELEMENTTYPE_INT16 = TYPE_INT16;\nconst ELEMENTTYPE_UINT16 = TYPE_UINT16;\nconst ELEMENTTYPE_INT32 = TYPE_INT32;\nconst ELEMENTTYPE_UINT32 = TYPE_UINT32;\nconst ELEMENTTYPE_FLOAT32 = TYPE_FLOAT32;\nfunction UnsupportedBrowserError(message) {\n\tthis.name = \"UnsupportedBrowserError\";\n\tthis.message = message || \"\";\n}\nUnsupportedBrowserError.prototype = Error.prototype;\nfunction ContextCreationError(message) {\n\tthis.name = \"ContextCreationError\";\n\tthis.message = message || \"\";\n}\nContextCreationError.prototype = Error.prototype;\nconst gfx = {\n\tADDRESS_CLAMP_TO_EDGE: ADDRESS_CLAMP_TO_EDGE,\n\tADDRESS_MIRRORED_REPEAT: ADDRESS_MIRRORED_REPEAT,\n\tADDRESS_REPEAT: ADDRESS_REPEAT,\n\tBLENDMODE_ZERO: BLENDMODE_ZERO,\n\tBLENDMODE_ONE: BLENDMODE_ONE,\n\tBLENDMODE_SRC_COLOR: BLENDMODE_SRC_COLOR,\n\tBLENDMODE_ONE_MINUS_SRC_COLOR: BLENDMODE_ONE_MINUS_SRC_COLOR,\n\tBLENDMODE_DST_COLOR: BLENDMODE_DST_COLOR,\n\tBLENDMODE_ONE_MINUS_DST_COLOR: BLENDMODE_ONE_MINUS_DST_COLOR,\n\tBLENDMODE_SRC_ALPHA: BLENDMODE_SRC_ALPHA,\n\tBLENDMODE_SRC_ALPHA_SATURATE: BLENDMODE_SRC_ALPHA_SATURATE,\n\tBLENDMODE_ONE_MINUS_SRC_ALPHA: BLENDMODE_ONE_MINUS_SRC_ALPHA,\n\tBLENDMODE_DST_ALPHA: BLENDMODE_DST_ALPHA,\n\tBLENDMODE_ONE_MINUS_DST_ALPHA: BLENDMODE_ONE_MINUS_DST_ALPHA,\n\tBUFFER_STATIC: BUFFER_STATIC,\n\tBUFFER_DYNAMIC: BUFFER_DYNAMIC,\n\tBUFFER_STREAM: BUFFER_STREAM,\n\tCULLFACE_NONE: CULLFACE_NONE,\n\tCULLFACE_BACK: CULLFACE_BACK,\n\tCULLFACE_FRONT: CULLFACE_FRONT,\n\tCULLFACE_FRONTANDBACK: CULLFACE_FRONTANDBACK,\n\tELEMENTTYPE_INT8: TYPE_INT8,\n\tELEMENTTYPE_UINT8: TYPE_UINT8,\n\tELEMENTTYPE_INT16: TYPE_INT16,\n\tELEMENTTYPE_UINT16: TYPE_UINT16,\n\tELEMENTTYPE_INT32: TYPE_INT32,\n\tELEMENTTYPE_UINT32: TYPE_UINT32,\n\tELEMENTTYPE_FLOAT32: TYPE_FLOAT32,\n\tFILTER_NEAREST: FILTER_NEAREST,\n\tFILTER_LINEAR: FILTER_LINEAR,\n\tFILTER_NEAREST_MIPMAP_NEAREST: FILTER_NEAREST_MIPMAP_NEAREST,\n\tFILTER_NEAREST_MIPMAP_LINEAR: FILTER_NEAREST_MIPMAP_LINEAR,\n\tFILTER_LINEAR_MIPMAP_NEAREST: FILTER_LINEAR_MIPMAP_NEAREST,\n\tFILTER_LINEAR_MIPMAP_LINEAR: FILTER_LINEAR_MIPMAP_LINEAR,\n\tINDEXFORMAT_UINT8: INDEXFORMAT_UINT8,\n\tINDEXFORMAT_UINT16: INDEXFORMAT_UINT16,\n\tINDEXFORMAT_UINT32: INDEXFORMAT_UINT32,\n\tPIXELFORMAT_R5_G6_B5: PIXELFORMAT_R5_G6_B5,\n\tPIXELFORMAT_R8_G8_B8: PIXELFORMAT_R8_G8_B8,\n\tPIXELFORMAT_R8_G8_B8_A8: PIXELFORMAT_R8_G8_B8_A8,\n\tPRIMITIVE_POINTS: PRIMITIVE_POINTS,\n\tPRIMITIVE_LINES: PRIMITIVE_LINES,\n\tPRIMITIVE_LINELOOP: PRIMITIVE_LINELOOP,\n\tPRIMITIVE_LINESTRIP: PRIMITIVE_LINESTRIP,\n\tPRIMITIVE_TRIANGLES: PRIMITIVE_TRIANGLES,\n\tPRIMITIVE_TRISTRIP: PRIMITIVE_TRISTRIP,\n\tPRIMITIVE_TRIFAN: PRIMITIVE_TRIFAN,\n\tSEMANTIC_POSITION: SEMANTIC_POSITION,\n\tSEMANTIC_NORMAL: SEMANTIC_NORMAL,\n\tSEMANTIC_COLOR: SEMANTIC_COLOR,\n\tSEMANTIC_TEXCOORD: SEMANTIC_TEXCOORD,\n\tSEMANTIC_TEXCOORD0: SEMANTIC_TEXCOORD0,\n\tSEMANTIC_TEXCOORD1: SEMANTIC_TEXCOORD1,\n\tSEMANTIC_ATTR0: SEMANTIC_ATTR0,\n\tSEMANTIC_ATTR1: SEMANTIC_ATTR1,\n\tSEMANTIC_ATTR2: SEMANTIC_ATTR2,\n\tSEMANTIC_ATTR3: SEMANTIC_ATTR3,\n\tTEXTURELOCK_READ: TEXTURELOCK_READ,\n\tTEXTURELOCK_WRITE: TEXTURELOCK_WRITE,\n\tdrawQuadWithShader: drawQuadWithShader,\n\tprogramlib: programlib,\n\tshaderChunks: shaderChunks,\n\tContextCreationError: ContextCreationError,\n\tDevice: GraphicsDevice,\n\tIndexBuffer: IndexBuffer,\n\tProgramLibrary: ProgramLibrary,\n\tRenderTarget: RenderTarget,\n\tScopeId: ScopeId,\n\tShader: Shader,\n\tShaderInput: ShaderInput,\n\tTexture: Texture,\n\tUnsupportedBrowserError: UnsupportedBrowserError,\n\tVertexBuffer: VertexBuffer,\n\tVertexFormat: VertexFormat,\n\tVertexIterator: VertexIterator\n};\nconst posteffect = {\n\tcreateFullscreenQuad: createFullscreenQuad,\n\tdrawFullscreenQuad: drawFullscreenQuad,\n\tPostEffect: PostEffect$1,\n\tPostEffectQueue: PostEffectQueue\n};\nObject.defineProperty(shaderChunks, \"transformSkinnedVS\", {\n\tget: function () {\n\t\treturn \"#define SKIN\\n\" + shaderChunks.transformVS;\n\t}\n});\nconst deprecatedChunks = {\n\t'ambientPrefilteredCube.frag': 'ambientEnv.frag',\n\t'ambientPrefilteredCubeLod.frag': 'ambientEnv.frag',\n\t'dpAtlasQuad.frag': null,\n\t'genParaboloid.frag': null,\n\t'prefilterCubemap.frag': null,\n\t'reflectionDpAtlas.frag': 'reflectionEnv.frag',\n\t'reflectionPrefilteredCube.frag': 'reflectionEnv.frag',\n\t'reflectionPrefilteredCubeLod.frag': 'reflectionEnv.frag'\n};\nObject.keys(deprecatedChunks).forEach(chunkName => {\n\tdeprecatedChunks[chunkName];\n\tObject.defineProperty(shaderChunks, chunkName, {\n\t\tget: function () {\n\t\t\treturn null;\n\t\t},\n\t\tset: function () {}\n\t});\n});\nObject.defineProperties(Texture.prototype, {\n\trgbm: {\n\t\tget: function () {\n\t\t\treturn this.type === TEXTURETYPE_RGBM;\n\t\t},\n\t\tset: function (rgbm) {\n\t\t\tthis.type = rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t}\n\t},\n\tswizzleGGGR: {\n\t\tget: function () {\n\t\t\treturn this.type === TEXTURETYPE_SWIZZLEGGGR;\n\t\t},\n\t\tset: function (swizzleGGGR) {\n\t\t\tthis.type = swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;\n\t\t}\n\t}\n});\nconst PhongMaterial = StandardMaterial;\nconst scene = {\n\tpartitionSkin: partitionSkin,\n\tprocedural: {\n\t\tcalculateTangents: calculateTangents,\n\t\tcreateMesh: createMesh$1,\n\t\tcreateTorus: createTorus,\n\t\tcreateCylinder: createCylinder,\n\t\tcreateCapsule: createCapsule,\n\t\tcreateCone: createCone,\n\t\tcreateSphere: createSphere,\n\t\tcreatePlane: createPlane,\n\t\tcreateBox: createBox\n\t},\n\tBasicMaterial: BasicMaterial,\n\tCommand: Command,\n\tDepthMaterial: DepthMaterial,\n\tForwardRenderer: ForwardRenderer,\n\tGraphNode: GraphNode,\n\tMaterial: Material,\n\tMesh: Mesh,\n\tMeshInstance: MeshInstance,\n\tModel: Model,\n\tParticleEmitter: ParticleEmitter,\n\tPhongMaterial: StandardMaterial,\n\tPicker: Picker,\n\tProjection: {\n\t\tORTHOGRAPHIC: PROJECTION_ORTHOGRAPHIC,\n\t\tPERSPECTIVE: PROJECTION_PERSPECTIVE\n\t},\n\tScene: Scene,\n\tSkin: Skin,\n\tSkinInstance: SkinInstance\n};\nObject.defineProperty(Scene.prototype, 'defaultMaterial', {\n\tget: function () {\n\t\treturn DefaultMaterial.get(getApplication().graphicsDevice);\n\t}\n});\n['128', '64', '32', '16', '8', '4'].forEach((size, index) => {\n\tObject.defineProperty(Scene.prototype, `skyboxPrefiltered${size}`, {\n\t\tget: function () {\n\t\t\treturn this._prefilteredCubemaps[index];\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._prefilteredCubemaps[index] = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t});\n});\nObject.defineProperty(Batch.prototype, 'model', {\n\tget: function () {\n\t\treturn null;\n\t}\n});\n\nMeshInstance.prototype.syncAabb = function () {};\n\nMorph.prototype.getTarget = function (index) {\n\treturn this.targets[index];\n};\n\nGraphNode.prototype._dirtify = function (local) {\n\tif (local) this._dirtifyLocal();else this._dirtifyWorld();\n};\n\nGraphNode.prototype.addLabel = function (label) {\n\tthis._labels[label] = true;\n};\n\nGraphNode.prototype.getLabels = function () {\n\treturn Object.keys(this._labels);\n};\n\nGraphNode.prototype.hasLabel = function (label) {\n\treturn !!this._labels[label];\n};\n\nGraphNode.prototype.removeLabel = function (label) {\n\tdelete this._labels[label];\n};\n\nGraphNode.prototype.findByLabel = function (label, results = []) {\n\tif (this.hasLabel(label)) {\n\t\tresults.push(this);\n\t}\n\n\tfor (let i = 0; i < this._children.length; ++i) {\n\t\tresults = this._children[i].findByLabel(label, results);\n\t}\n\n\treturn results;\n};\n\nGraphNode.prototype.getChildren = function () {\n\treturn this.children;\n};\n\nGraphNode.prototype.getName = function () {\n\treturn this.name;\n};\n\nGraphNode.prototype.getPath = function () {\n\treturn this.path;\n};\n\nGraphNode.prototype.getRoot = function () {\n\treturn this.root;\n};\n\nGraphNode.prototype.getParent = function () {\n\treturn this.parent;\n};\n\nGraphNode.prototype.setName = function (name) {\n\tthis.name = name;\n};\n\nMaterial.prototype.getName = function () {\n\treturn this.name;\n};\n\nMaterial.prototype.setName = function (name) {\n\tthis.name = name;\n};\n\nMaterial.prototype.getShader = function () {\n\treturn this.shader;\n};\n\nMaterial.prototype.setShader = function (shader) {\n\tthis.shader = shader;\n};\n\nfunction _defineAlias(newName, oldName) {\n\tObject.defineProperty(StandardMaterial.prototype, oldName, {\n\t\tget: function () {\n\t\t\treturn this[newName];\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis[newName] = value;\n\t\t}\n\t});\n}\n\n_defineAlias(\"diffuseTint\", \"diffuseMapTint\");\n\n_defineAlias(\"specularTint\", \"specularMapTint\");\n\n_defineAlias(\"emissiveTint\", \"emissiveMapTint\");\n\n_defineAlias(\"aoVertexColor\", \"aoMapVertexColor\");\n\n_defineAlias(\"diffuseVertexColor\", \"diffuseMapVertexColor\");\n\n_defineAlias(\"specularVertexColor\", \"specularMapVertexColor\");\n\n_defineAlias(\"emissiveVertexColor\", \"emissiveMapVertexColor\");\n\n_defineAlias(\"metalnessVertexColor\", \"metalnessMapVertexColor\");\n\n_defineAlias(\"glossVertexColor\", \"glossMapVertexColor\");\n\n_defineAlias(\"opacityVertexColor\", \"opacityMapVertexColor\");\n\n_defineAlias(\"lightVertexColor\", \"lightMapVertexColor\");\n\nconst anim = {\n\tAnimation: Animation,\n\tKey: Key,\n\tNode: Node,\n\tSkeleton: Skeleton\n};\n\nAnimation.prototype.getDuration = function () {\n\treturn this.duration;\n};\n\nAnimation.prototype.getName = function () {\n\treturn this.name;\n};\n\nAnimation.prototype.getNodes = function () {\n\treturn this.nodes;\n};\n\nAnimation.prototype.setDuration = function (duration) {\n\tthis.duration = duration;\n};\n\nAnimation.prototype.setName = function (name) {\n\tthis.name = name;\n};\n\nSkeleton.prototype.getAnimation = function () {\n\treturn this.animation;\n};\n\nSkeleton.prototype.getCurrentTime = function () {\n\treturn this.currentTime;\n};\n\nSkeleton.prototype.getLooping = function () {\n\treturn this.looping;\n};\n\nSkeleton.prototype.getNumNodes = function () {\n\treturn this.numNodes;\n};\n\nSkeleton.prototype.setAnimation = function (animation) {\n\tthis.animation = animation;\n};\n\nSkeleton.prototype.setCurrentTime = function (time) {\n\tthis.currentTime = time;\n};\n\nSkeleton.prototype.setLooping = function (looping) {\n\tthis.looping = looping;\n};\n\nconst audio = {\n\tAudioManager: SoundManager,\n\tChannel: Channel,\n\tChannel3d: Channel3d,\n\tListener: Listener,\n\tSound: Sound\n};\n\nSoundManager.prototype.getListener = function () {\n\treturn this.listener;\n};\n\nSoundManager.prototype.getVolume = function () {\n\treturn this.volume;\n};\n\nSoundManager.prototype.setVolume = function (volume) {\n\tthis.volume = volume;\n};\n\nconst asset = {\n\tASSET_ANIMATION: 'animation',\n\tASSET_AUDIO: 'audio',\n\tASSET_IMAGE: 'image',\n\tASSET_JSON: 'json',\n\tASSET_MODEL: 'model',\n\tASSET_MATERIAL: 'material',\n\tASSET_TEXT: 'text',\n\tASSET_TEXTURE: 'texture',\n\tASSET_CUBEMAP: 'cubemap',\n\tASSET_SCRIPT: 'script'\n};\n\nAssetRegistry.prototype.getAssetById = function (id) {\n\treturn this.get(id);\n};\n\nObject.defineProperty(XrInputSource.prototype, 'ray', {\n\tget: function () {\n\t\treturn this._rayLocal;\n\t}\n});\nObject.defineProperty(XrInputSource.prototype, 'position', {\n\tget: function () {\n\t\treturn this._localPosition;\n\t}\n});\nObject.defineProperty(XrInputSource.prototype, 'rotation', {\n\tget: function () {\n\t\treturn this._localRotation;\n\t}\n});\nconst input = {\n\tgetTouchTargetCoords: getTouchTargetCoords,\n\tController: Controller,\n\tGamePads: GamePads,\n\tKeyboard: Keyboard,\n\tKeyboardEvent: KeyboardEvent,\n\tMouse: Mouse,\n\tMouseEvent: MouseEvent,\n\tTouch: Touch,\n\tTouchDevice: TouchDevice,\n\tTouchEvent: TouchEvent\n};\nObject.defineProperty(ElementInput.prototype, 'wheel', {\n\tget: function () {\n\t\treturn this.wheelDelta * -2;\n\t}\n});\nObject.defineProperty(MouseEvent.prototype, 'wheel', {\n\tget: function () {\n\t\treturn this.wheelDelta * -2;\n\t}\n});\nconst RIGIDBODY_TYPE_STATIC = BODYTYPE_STATIC;\nconst RIGIDBODY_TYPE_DYNAMIC = BODYTYPE_DYNAMIC;\nconst RIGIDBODY_TYPE_KINEMATIC = BODYTYPE_KINEMATIC;\nconst RIGIDBODY_CF_STATIC_OBJECT = BODYFLAG_STATIC_OBJECT;\nconst RIGIDBODY_CF_KINEMATIC_OBJECT = BODYFLAG_KINEMATIC_OBJECT;\nconst RIGIDBODY_CF_NORESPONSE_OBJECT = BODYFLAG_NORESPONSE_OBJECT;\nconst RIGIDBODY_ACTIVE_TAG = BODYSTATE_ACTIVE_TAG;\nconst RIGIDBODY_ISLAND_SLEEPING = BODYSTATE_ISLAND_SLEEPING;\nconst RIGIDBODY_WANTS_DEACTIVATION = BODYSTATE_WANTS_DEACTIVATION;\nconst RIGIDBODY_DISABLE_DEACTIVATION = BODYSTATE_DISABLE_DEACTIVATION;\nconst RIGIDBODY_DISABLE_SIMULATION = BODYSTATE_DISABLE_SIMULATION;\nconst fw = {\n\tApplication: Application,\n\tComponent: Component,\n\tComponentSystem: ComponentSystem,\n\tEntity: Entity,\n\tFillMode: {\n\t\tNONE: FILLMODE_NONE,\n\t\tFILL_WINDOW: FILLMODE_FILL_WINDOW,\n\t\tKEEP_ASPECT: FILLMODE_KEEP_ASPECT\n\t},\n\tResolutionMode: {\n\t\tAUTO: RESOLUTION_AUTO,\n\t\tFIXED: RESOLUTION_FIXED\n\t}\n};\n\nApplication.prototype.isFullscreen = function () {\n\treturn !!document.fullscreenElement;\n};\n\nApplication.prototype.enableFullscreen = function (element, success, error) {\n\telement = element || this.graphicsDevice.canvas;\n\n\tconst s = function s() {\n\t\tsuccess();\n\t\tdocument.removeEventListener('fullscreenchange', s);\n\t};\n\n\tconst e = function e() {\n\t\terror();\n\t\tdocument.removeEventListener('fullscreenerror', e);\n\t};\n\n\tif (success) {\n\t\tdocument.addEventListener('fullscreenchange', s, false);\n\t}\n\n\tif (error) {\n\t\tdocument.addEventListener('fullscreenerror', e, false);\n\t}\n\n\tif (element.requestFullscreen) {\n\t\telement.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n\t} else {\n\t\terror();\n\t}\n};\n\nApplication.prototype.disableFullscreen = function (success) {\n\tconst s = function s() {\n\t\tsuccess();\n\t\tdocument.removeEventListener('fullscreenchange', s);\n\t};\n\n\tif (success) {\n\t\tdocument.addEventListener('fullscreenchange', s, false);\n\t}\n\n\tdocument.exitFullscreen();\n};\n\nApplication.prototype.getSceneUrl = function (name) {\n\tconst entry = this.scenes.find(name);\n\n\tif (entry) {\n\t\treturn entry.url;\n\t}\n\n\treturn null;\n};\n\nApplication.prototype.loadScene = function (url, callback) {\n\tthis.scenes.loadScene(url, callback);\n};\n\nApplication.prototype.loadSceneHierarchy = function (url, callback) {\n\tthis.scenes.loadSceneHierarchy(url, callback);\n};\n\nApplication.prototype.loadSceneSettings = function (url, callback) {\n\tthis.scenes.loadSceneSettings(url, callback);\n};\n\nApplication.prototype.renderMeshInstance = function (meshInstance, options) {\n\tconst layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;\n\tthis.scene.immediate.drawMesh(null, null, null, meshInstance, layer);\n};\n\nApplication.prototype.renderMesh = function (mesh, material, matrix, options) {\n\tconst layer = options != null && options.layer ? options.layer : this.scene.defaultDrawLayer;\n\tthis.scene.immediate.drawMesh(material, matrix, mesh, null, layer);\n};\n\nApplication.prototype._addLines = function (positions, colors, options) {\n\tconst layer = options && options.layer ? options.layer : this.scene.layers.getLayerById(LAYERID_IMMEDIATE);\n\tconst depthTest = options && options.depthTest !== undefined ? options.depthTest : true;\n\tconst batch = this.scene.immediate.getBatch(layer, depthTest);\n\tbatch.addLines(positions, colors);\n};\n\nApplication.prototype.renderLine = function (start, end, color) {\n\tlet endColor = color;\n\tlet options;\n\tconst arg3 = arguments[3];\n\tconst arg4 = arguments[4];\n\n\tif (arg3 instanceof Color) {\n\t\tendColor = arg3;\n\n\t\tif (typeof arg4 === 'number') {\n\t\t\tif (arg4 === LINEBATCH_OVERLAY) {\n\t\t\t\toptions = {\n\t\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\t\tdepthTest: false\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\toptions = {\n\t\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\t\tdepthTest: true\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\toptions = arg4;\n\t\t}\n\t} else if (typeof arg3 === 'number') {\n\t\tendColor = color;\n\n\t\tif (arg3 === LINEBATCH_OVERLAY) {\n\t\t\toptions = {\n\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\tdepthTest: false\n\t\t\t};\n\t\t} else {\n\t\t\toptions = {\n\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\tdepthTest: true\n\t\t\t};\n\t\t}\n\t} else if (arg3) {\n\t\toptions = arg3;\n\t}\n\n\tthis._addLines([start, end], [color, endColor], options);\n};\n\nApplication.prototype.renderLines = function (position, color, options) {\n\tif (!options) {\n\t\toptions = {\n\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\tdepthTest: true\n\t\t};\n\t} else if (typeof options === 'number') {\n\t\tif (options === LINEBATCH_OVERLAY) {\n\t\t\toptions = {\n\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\tdepthTest: false\n\t\t\t};\n\t\t} else {\n\t\t\toptions = {\n\t\t\t\tlayer: this.scene.layers.getLayerById(LAYERID_IMMEDIATE),\n\t\t\t\tdepthTest: true\n\t\t\t};\n\t\t}\n\t}\n\n\tconst multiColor = !!color.length;\n\n\tif (multiColor) {\n\t\tif (position.length !== color.length) {\n\t\t\tconsole.error(\"renderLines: position/color arrays have different lengths\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (position.length % 2 !== 0) {\n\t\tconsole.error(\"renderLines: array length is not divisible by 2\");\n\t\treturn;\n\t}\n\n\tthis._addLines(position, color, options);\n};\n\nObject.defineProperty(CameraComponent.prototype, \"node\", {\n\tget: function () {\n\t\treturn this.entity;\n\t}\n});\nObject.defineProperty(LightComponent.prototype, \"enable\", {\n\tget: function () {\n\t\treturn this.enabled;\n\t},\n\tset: function (value) {\n\t\tthis.enabled = value;\n\t}\n});\n\nModelComponent.prototype.setVisible = function (visible) {\n\tthis.enabled = visible;\n};\n\nObject.defineProperty(ModelComponent.prototype, \"aabb\", {\n\tget: function () {\n\t\treturn null;\n\t},\n\tset: function (type) {}\n});\nObject.defineProperty(RenderComponent.prototype, \"aabb\", {\n\tget: function () {\n\t\treturn null;\n\t},\n\tset: function (type) {}\n});\nObject.defineProperty(RigidBodyComponent.prototype, \"bodyType\", {\n\tget: function () {\n\t\treturn this.type;\n\t},\n\tset: function (type) {\n\t\tthis.type = type;\n\t}\n});\n\nRigidBodyComponent.prototype.syncBodyToEntity = function () {\n\tthis._updateDynamic();\n};\n\nRigidBodyComponentSystem.prototype.setGravity = function () {\n\tif (arguments.length === 1) {\n\t\tthis.gravity.copy(arguments[0]);\n\t} else {\n\t\tthis.gravity.set(arguments[0], arguments[1], arguments[2]);\n\t}\n};\n\nfunction basisSetDownloadConfig(glueUrl, wasmUrl, fallbackUrl) {\n\tbasisInitialize({\n\t\tglueUrl: glueUrl,\n\t\twasmUrl: wasmUrl,\n\t\tfallbackUrl: fallbackUrl,\n\t\tlazyInit: true\n\t});\n}\nfunction prefilterCubemap(options) {}\nclass AssetListLoader extends EventHandler {\n\tconstructor(assetList, assetRegistry) {\n\t\tsuper();\n\t\tthis._assets = [];\n\t\tthis._registry = assetRegistry;\n\t\tthis._loaded = false;\n\t\tthis._count = 0;\n\t\tthis._total = 0;\n\t\tthis._failed = [];\n\t\tthis._waitingAssets = [];\n\n\t\tif (assetList.length && assetList[0] instanceof Asset) {\n\t\t\tthis._assets = assetList;\n\t\t} else {\n\t\t\tfor (let i = 0; i < assetList.length; i++) {\n\t\t\t\tconst asset = assetRegistry.get(assetList[i]);\n\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis._assets.push(asset);\n\t\t\t\t} else {\n\t\t\t\t\tthis._waitForAsset(assetList[i]);\n\n\t\t\t\t\tthis._total++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._registry.off(\"load\", this._onLoad);\n\n\t\tthis._registry.off(\"error\", this._onError);\n\n\t\tthis._waitingAssets.forEach(id => {\n\t\t\tthis._registry.off(\"add:\" + id, this._onAddAsset);\n\t\t});\n\n\t\tthis.off(\"progress\");\n\t\tthis.off(\"load\");\n\t}\n\n\tload(done, scope) {\n\t\tthis._count = 0;\n\t\tthis._failed = [];\n\t\tthis._callback = done;\n\t\tthis._scope = scope;\n\n\t\tthis._registry.on(\"load\", this._onLoad, this);\n\n\t\tthis._registry.on(\"error\", this._onError, this);\n\n\t\tfor (let i = 0, l = this._assets.length; i < l; i++) {\n\t\t\tconst asset = this._assets[i];\n\n\t\t\tif (!asset.loading && !asset.loaded) {\n\t\t\t\tthis._registry.load(asset);\n\n\t\t\t\tthis._total++;\n\t\t\t}\n\t\t}\n\t}\n\n\tready(done, scope) {\n\t\tscope = scope || this;\n\n\t\tif (this._loaded) {\n\t\t\tdone.call(scope, this._assets);\n\t\t} else {\n\t\t\tthis.once(\"load\", function (assets) {\n\t\t\t\tdone.call(scope, assets);\n\t\t\t});\n\t\t}\n\t}\n\n\t_loadingComplete() {\n\t\tthis._loaded = true;\n\n\t\tthis._registry.off(\"load\", this._onLoad, this);\n\n\t\tthis._registry.off(\"error\", this._onError, this);\n\n\t\tif (this._failed && this._failed.length) {\n\t\t\tif (this._callback) {\n\t\t\t\tthis._callback.call(this._scope, \"Failed to load some assets\", this._failed);\n\t\t\t}\n\n\t\t\tthis.fire(\"error\", this._failed);\n\t\t} else {\n\t\t\tif (this._callback) {\n\t\t\t\tthis._callback.call(this._scope);\n\t\t\t}\n\n\t\t\tthis.fire(\"load\", this._assets);\n\t\t}\n\t}\n\n\t_onLoad(asset) {\n\t\tif (this._assets.indexOf(asset) >= 0) {\n\t\t\tthis._count++;\n\t\t\tthis.fire(\"progress\", asset);\n\t\t}\n\n\t\tif (this._count === this._total) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._loadingComplete(this._failed);\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\t_onError(err, asset) {\n\t\tif (this._assets.indexOf(asset) >= 0) {\n\t\t\tthis._count++;\n\n\t\t\tthis._failed.push(asset);\n\t\t}\n\n\t\tif (this._count === this._total) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._loadingComplete(this._failed);\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\t_onAddAsset(asset) {\n\t\tconst index = this._waitingAssets.indexOf(asset);\n\n\t\tif (index >= 0) {\n\t\t\tthis._waitingAssets.splice(index, 1);\n\t\t}\n\n\t\tthis._assets.push(asset);\n\n\t\tfor (let i = 0, l = this._assets.length; i < l; i++) {\n\t\t\tasset = this._assets[i];\n\n\t\t\tif (!asset.loading && !asset.loaded) {\n\t\t\t\tthis._registry.load(asset);\n\t\t\t}\n\t\t}\n\t}\n\n\t_waitForAsset(assetId) {\n\t\tthis._waitingAssets.push(assetId);\n\n\t\tthis._registry.once('add:' + assetId, this._onAddAsset, this);\n\t}\n\n}\n\nexport { ABSOLUTE_URL, ACTION_GAMEPAD, ACTION_KEYBOARD, ACTION_MOUSE, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START, ASPECT_AUTO, ASPECT_MANUAL, ASSET_ANIMATION, ASSET_AUDIO, ASSET_CONTAINER, ASSET_CSS, ASSET_CUBEMAP, ASSET_HTML, ASSET_IMAGE, ASSET_JSON, ASSET_MATERIAL, ASSET_MODEL, ASSET_SCRIPT, ASSET_SHADER, ASSET_TEXT, ASSET_TEXTURE, AXIS_KEY, AXIS_MOUSE_X, AXIS_MOUSE_Y, AXIS_PAD_L_X, AXIS_PAD_L_Y, AXIS_PAD_R_X, AXIS_PAD_R_Y, AnimBinder, AnimClip, AnimClipHandler, AnimComponent, AnimComponentLayer, AnimComponentSystem, AnimController, AnimCurve, AnimData, AnimEvaluator, AnimEvents, AnimSnapshot, AnimStateGraph, AnimStateGraphHandler, AnimTarget, AnimTrack, Animation, AnimationComponent, AnimationComponentSystem, AnimationHandler, Application, Asset, AssetListLoader, AssetReference, AssetRegistry, AudioHandler, AudioListenerComponent, AudioListenerComponentSystem, AudioSourceComponent, AudioSourceComponentSystem, BAKE_COLOR, BAKE_COLORDIR, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MAX, BLEND_MIN, BLEND_MULTIPLICATIVE, BLEND_MULTIPLICATIVE2X, BLEND_NONE, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_SCREEN, BLEND_SUBTRACTIVE, BLUR_BOX, BLUR_GAUSSIAN, BODYFLAG_KINEMATIC_OBJECT, BODYFLAG_NORESPONSE_OBJECT, BODYFLAG_STATIC_OBJECT, BODYGROUP_DEFAULT, BODYGROUP_DYNAMIC, BODYGROUP_ENGINE_1, BODYGROUP_ENGINE_2, BODYGROUP_ENGINE_3, BODYGROUP_KINEMATIC, BODYGROUP_NONE, BODYGROUP_STATIC, BODYGROUP_TRIGGER, BODYGROUP_USER_1, BODYGROUP_USER_2, BODYGROUP_USER_3, BODYGROUP_USER_4, BODYGROUP_USER_5, BODYGROUP_USER_6, BODYGROUP_USER_7, BODYGROUP_USER_8, BODYMASK_ALL, BODYMASK_NONE, BODYMASK_NOT_STATIC, BODYMASK_NOT_STATIC_KINEMATIC, BODYMASK_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_DISABLE_SIMULATION, BODYSTATE_ISLAND_SLEEPING, BODYSTATE_WANTS_DEACTIVATION, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYTYPE_STATIC, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT, BasicMaterial, Batch, BatchGroup, BatchManager, BinaryHandler, BoundingBox, BoundingSphere, Bundle, BundleHandler, BundleRegistry, ButtonComponent, ButtonComponentSystem, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, COMPUPDATED_BLEND, COMPUPDATED_CAMERAS, COMPUPDATED_INSTANCES, COMPUPDATED_LIGHTS, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CUBEPROJ_BOX, CUBEPROJ_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, CURVE_CARDINAL, CURVE_CATMULL, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_SPLINE, CURVE_STEP, Camera, CameraComponent, CameraComponentSystem, CanvasFont, CollisionComponent, CollisionComponentSystem, Color, Command, Component, ComponentSystem, ComponentSystemRegistry, ContactPoint, ContactResult, ContainerHandler, ContainerResource, ContextCreationError, Controller, CssHandler, CubemapHandler, Curve, CurveSet, DETAILMODE_ADD, DETAILMODE_MAX, DETAILMODE_MIN, DETAILMODE_MUL, DETAILMODE_OVERLAY, DETAILMODE_SCREEN, DISTANCE_EXPONENTIAL, DISTANCE_INVERSE, DISTANCE_LINEAR, DefaultAnimBinder, DepthMaterial, ELEMENTTYPE_FLOAT32, ELEMENTTYPE_GROUP, ELEMENTTYPE_IMAGE, ELEMENTTYPE_INT16, ELEMENTTYPE_INT32, ELEMENTTYPE_INT8, ELEMENTTYPE_TEXT, ELEMENTTYPE_UINT16, ELEMENTTYPE_UINT32, ELEMENTTYPE_UINT8, EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, EVENT_KEYDOWN, EVENT_KEYUP, EVENT_MOUSEDOWN, EVENT_MOUSEMOVE, EVENT_MOUSEUP, EVENT_MOUSEWHEEL, EVENT_SELECT, EVENT_SELECTEND, EVENT_SELECTSTART, EVENT_TOUCHCANCEL, EVENT_TOUCHEND, EVENT_TOUCHMOVE, EVENT_TOUCHSTART, ElementComponent, ElementComponentSystem, ElementDragHelper, ElementInput, ElementInputEvent, ElementMouseEvent, ElementSelectEvent, ElementTouchEvent, Entity, EntityReference, EnvLighting, EventHandler, FILLMODE_FILL_WINDOW, FILLMODE_KEEP_ASPECT, FILLMODE_NONE, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FITTING_BOTH, FITTING_NONE, FITTING_SHRINK, FITTING_STRETCH, FOG_EXP, FOG_EXP2, FOG_LINEAR, FOG_NONE, FONT_BITMAP, FONT_MSDF, FRESNEL_NONE, FRESNEL_SCHLICK, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, FolderHandler, Font, FontHandler, ForwardRenderer, Frustum, GAMMA_NONE, GAMMA_SRGB, GAMMA_SRGBFAST, GAMMA_SRGBHDR, GamePads, GraphNode, GraphicsDevice, HierarchyHandler, HtmlHandler, Http, I18n, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, INTERPOLATION_CUBIC, INTERPOLATION_LINEAR, INTERPOLATION_STEP, ImageElement, IndexBuffer, IndexedList, JointComponent, JointComponentSystem, JsonHandler, JsonStandardMaterialParser, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_A, KEY_ADD, KEY_ALT, KEY_B, KEY_BACKSPACE, KEY_BACK_SLASH, KEY_C, KEY_CAPS_LOCK, KEY_CLOSE_BRACKET, KEY_COMMA, KEY_CONTEXT_MENU, KEY_CONTROL, KEY_D, KEY_DECIMAL, KEY_DELETE, KEY_DIVIDE, KEY_DOWN, KEY_E, KEY_END, KEY_ENTER, KEY_EQUAL, KEY_ESCAPE, KEY_F, KEY_F1, KEY_F10, KEY_F11, KEY_F12, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_G, KEY_H, KEY_HOME, KEY_I, KEY_INSERT, KEY_J, KEY_K, KEY_L, KEY_LEFT, KEY_M, KEY_META, KEY_MULTIPLY, KEY_N, KEY_NUMPAD_0, KEY_NUMPAD_1, KEY_NUMPAD_2, KEY_NUMPAD_3, KEY_NUMPAD_4, KEY_NUMPAD_5, KEY_NUMPAD_6, KEY_NUMPAD_7, KEY_NUMPAD_8, KEY_NUMPAD_9, KEY_O, KEY_OPEN_BRACKET, KEY_P, KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_PAUSE, KEY_PERIOD, KEY_PRINT_SCREEN, KEY_Q, KEY_R, KEY_RETURN, KEY_RIGHT, KEY_S, KEY_SEMICOLON, KEY_SEPARATOR, KEY_SHIFT, KEY_SLASH, KEY_SPACE, KEY_SUBTRACT, KEY_T, KEY_TAB, KEY_U, KEY_UP, KEY_V, KEY_W, KEY_WINDOWS, KEY_X, KEY_Y, KEY_Z, Key, Keyboard, KeyboardEvent, LAYERID_DEPTH, LAYERID_IMMEDIATE, LAYERID_SKYBOX, LAYERID_UI, LAYERID_WORLD, LAYER_FX, LAYER_GIZMO, LAYER_HUD, LAYER_WORLD, LIGHTFALLOFF_INVERSESQUARED, LIGHTFALLOFF_LINEAR, LIGHTSHAPE_DISK, LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_SPHERE, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, LINEBATCH_GIZMO, LINEBATCH_OVERLAY, LINEBATCH_WORLD, Layer, LayerComposition, LayoutCalculator, LayoutChildComponent, LayoutChildComponentSystem, LayoutGroupComponent, LayoutGroupComponentSystem, Light, LightComponent, LightComponentSystem, LightingParams, Lightmapper, LocalizedAsset, MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, MOTION_FREE, MOTION_LIMITED, MOTION_LOCKED, MOUSEBUTTON_LEFT, MOUSEBUTTON_MIDDLE, MOUSEBUTTON_NONE, MOUSEBUTTON_RIGHT, Mat3, Mat4, Material, MaterialHandler, Mesh, MeshInstance, Model, ModelComponent, ModelComponentSystem, ModelHandler, Morph, MorphInstance, MorphTarget, Mouse, MouseEvent, Node, ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL, OrientedBox, PAD_1, PAD_2, PAD_3, PAD_4, PAD_DOWN, PAD_FACE_1, PAD_FACE_2, PAD_FACE_3, PAD_FACE_4, PAD_LEFT, PAD_L_SHOULDER_1, PAD_L_SHOULDER_2, PAD_L_STICK_BUTTON, PAD_L_STICK_X, PAD_L_STICK_Y, PAD_RIGHT, PAD_R_SHOULDER_1, PAD_R_SHOULDER_2, PAD_R_STICK_BUTTON, PAD_R_STICK_X, PAD_R_STICK_Y, PAD_SELECT, PAD_START, PAD_UP, PAD_VENDOR, PARTICLEMODE_CPU, PARTICLEMODE_GPU, PARTICLEORIENTATION_EMITTER, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLESORT_DISTANCE, PARTICLESORT_NEWER_FIRST, PARTICLESORT_NONE, PARTICLESORT_OLDER_FIRST, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT3, PIXELFORMAT_DXT5, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_L8, PIXELFORMAT_L8_A8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R32F, PIXELFORMAT_R4_G4_B4_A4, PIXELFORMAT_R5_G5_B5_A1, PIXELFORMAT_R5_G6_B5, PIXELFORMAT_R8_G8_B8, PIXELFORMAT_R8_G8_B8_A8, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_SRGB, PIXELFORMAT_SRGBA, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, ParticleEmitter, ParticleSystemComponent, ParticleSystemComponentSystem, PhongMaterial, Picker, Plane, PostEffect$1 as PostEffect, PostEffectQueue, ProgramLibrary, Quat, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID, RENDERSTYLE_WIREFRAME, RESOLUTION_AUTO, RESOLUTION_FIXED, RIGIDBODY_ACTIVE_TAG, RIGIDBODY_CF_KINEMATIC_OBJECT, RIGIDBODY_CF_NORESPONSE_OBJECT, RIGIDBODY_CF_STATIC_OBJECT, RIGIDBODY_DISABLE_DEACTIVATION, RIGIDBODY_DISABLE_SIMULATION, RIGIDBODY_ISLAND_SLEEPING, RIGIDBODY_TYPE_DYNAMIC, RIGIDBODY_TYPE_KINEMATIC, RIGIDBODY_TYPE_STATIC, RIGIDBODY_WANTS_DEACTIVATION, Ray, RaycastResult, ReadStream, RenderComponent, RenderComponentSystem, RenderHandler, RenderTarget, ResourceHandler, ResourceLoader, RigidBodyComponent, RigidBodyComponentSystem, SCALEMODE_BLEND, SCALEMODE_NONE, SCROLLBAR_VISIBILITY_SHOW_ALWAYS, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLL_MODE_INFINITE, SEMANTIC_ATTR, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERDEF_DIRLM, SHADERDEF_INSTANCING, SHADERDEF_LM, SHADERDEF_LMAMBIENT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_NOSHADOW, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_TANGENTS, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERTAG_MATERIAL, SHADER_DEPTH, SHADER_FORWARD, SHADER_FORWARDHDR, SHADER_PICK, SHADER_SHADOW, SHADOWUPDATE_NONE, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, SHADOW_COUNT, SHADOW_DEPTH, SHADOW_PCF1, SHADOW_PCF3, SHADOW_PCF5, SHADOW_VSM16, SHADOW_VSM32, SHADOW_VSM8, SORTKEY_DEPTH, SORTKEY_FORWARD, SORTMODE_BACK2FRONT, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTMODE_MANUAL, SORTMODE_MATERIALMESH, SORTMODE_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, SPECOCC_NONE, SPECULAR_BLINN, SPECULAR_PHONG, SPRITETYPE_ANIMATED, SPRITETYPE_SIMPLE, SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, Scene, SceneHandler, SceneRegistry, SceneRegistryItem, SceneSettingsHandler, ScopeId, ScopeSpace, ScreenComponent, ScreenComponentSystem, ScriptAttributes, ScriptComponent, ScriptComponentSystem, ScriptHandler, ScriptLegacyComponent, ScriptLegacyComponentSystem, ScriptRegistry, ScriptType, ScrollViewComponent, ScrollViewComponentSystem, ScrollbarComponent, ScrollbarComponentSystem, Shader, ShaderHandler, SingleContactResult, Skeleton, Skin, SkinBatchInstance, SkinInstance, SortedLoopArray, Sound, SoundComponent, SoundComponentSystem, SoundInstance, SoundInstance3d, SoundManager, SoundSlot, Sprite, SpriteAnimationClip, SpriteComponent, SpriteComponentSystem, SpriteHandler, StandardMaterial, StencilParameters, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_SWIZZLEGGGR, TONEMAP_ACES, TONEMAP_ACES2, TONEMAP_FILMIC, TONEMAP_HEJL, TONEMAP_LINEAR, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, Tags, Template, TemplateHandler, TextElement, TextHandler, Texture, TextureAtlas, TextureAtlasHandler, TextureHandler, TextureParser, Timer, Touch, TouchDevice, TouchEvent, TransformFeedback, UNIFORMTYPE_BOOL, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC4, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC4, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, URI, UnsupportedBrowserError, VIEW_CENTER, VIEW_LEFT, VIEW_RIGHT, Vec2, Vec3, Vec4, VertexBuffer, VertexFormat, VertexIterator, VrDisplay, VrManager, WorldClusters, XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGUSAGE_GPU, XRHAND_LEFT, XRHAND_NONE, XRHAND_RIGHT, XRSPACE_BOUNDEDFLOOR, XRSPACE_LOCAL, XRSPACE_LOCALFLOOR, XRSPACE_UNBOUNDED, XRSPACE_VIEWER, XRTARGETRAY_GAZE, XRTARGETRAY_POINTER, XRTARGETRAY_SCREEN, XRTRACKABLE_MESH, XRTRACKABLE_PLANE, XRTRACKABLE_POINT, XRTYPE_AR, XRTYPE_INLINE, XRTYPE_VR, XrDepthSensing, XrDomOverlay, XrHitTest, XrHitTestSource, XrImageTracking, XrInput, XrInputSource, XrLightEstimation, XrManager, XrPlane, XrPlaneDetection, XrTrackedImage, ZoneComponent, ZoneComponentSystem, anim, app, apps, asset, audio, basisInitialize, basisSetDownloadConfig, basisTranscode, calculateNormals, calculateTangents, common, config, createBox, createCapsule, createCone, createCylinder, createMesh$1 as createMesh, createPlane, createScript, createSphere, createStyle, createTorus, createURI, data, drawFullscreenQuad, drawQuadWithShader, drawTexture, events, extend, fw, getTouchTargetCoords, gfx, guid, http, inherits, input, isDefined, log, makeArray, math, now, path, platform, posteffect, prefilterCubemap, programlib, registerScript, reprojectTexture, revision, scene, script, semanticToLocation, shFromCubemap, shaderChunks, shadowTypeToString, shape, string, time, type, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, version };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./index/index.ts\");\n",""],"names":[],"sourceRoot":""}